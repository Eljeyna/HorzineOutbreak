	TITLE	Z:\XashXTSRC\client\render\r_studiodecal.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DI@OHIF@StudioDecalList?3?5too?5many?5studio@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@2@H@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@2@AAUDecalVertex_t@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??AddClippedDecalToTriangle@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@2@AAUDecalClipState_t@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??IntersectPlane@CStudioModelRenderer@@AAEHAAUDecalClipState_t@@HHHM@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??CreateDecalForMaterial@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@2@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@LJH@historyList?4Count?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@HAOP@vertices?4Count?$CI?$CJ?5?$DO?$DN?5decalToRemov@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??RetireDecal@CStudioModelRenderer@@AAEXAAV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DrawDecal@CStudioModelRenderer@@AAEXPAUcl_entity_s@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09OHNN@elem?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@MFGO@elem?5?$CL?5num?5?$DM?$DN?5Count?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector2D@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector2D@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??XVector2D@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector2D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@QAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@Vector@@QAEXMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NormalizeLength@Vector@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CrossProduct@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QAEPAMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QAEPAMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Random@RandomRange@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudBase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CHudBase@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VidInit@CHudBase@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@CHudBase@@UAEHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CHudBase@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@CHudBase@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitHUDData@CHudBase@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudBase@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudAmmo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudAmmo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudHealth@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudHealth@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudGeiger@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudGeiger@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudBattery@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudBattery@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudTrain@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudTrain@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudFlashlight@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudFlashlight@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudMessage@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudMessage@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudScoreboard@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudScoreboard@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudStatusBar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudStatusBar@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudDeathNotice@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudDeathNotice@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudSayText@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudSayText@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudMenu@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudMenu@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudAmmoSecondary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudAmmoSecondary@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudTextMessage@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudTextMessage@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudStatusIcons@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudStatusIcons@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudMOTD@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudMOTD@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ViewSmoothingData_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudAmmo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudBase@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudHealth@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudGeiger@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudBattery@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudTrain@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudFlashlight@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudMessage@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudScoreboard@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudStatusBar@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudDeathNotice@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudSayText@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudMenu@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudAmmoSecondary@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudTextMessage@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudStatusIcons@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudMOTD@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pHitboxSet@CStudioBoneSetup@@QBEPAUmstudiohitboxset_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitBoneWeights@CStudioBoneSetup@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?debugMsg@CStudioBoneSetup@@UAAXPADZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?debugLine@CStudioBoneSetup@@UAEXABVVector@@0HHH_NM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateDecalList@CStudioModelRenderer@@AAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyDecalList@CStudioModelRenderer@@AAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioClearDecals@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAllDecals@CStudioModelRenderer@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioDecalList@CStudioModelRenderer@@QAEHPAUdecallist_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ComputePoseToDecal@CStudioModelRenderer@@AAE_NABVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFrontFacing@CStudioModelRenderer@@AAE_NABVVector@@PAUmstudioboneweight_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDecalRotateTransform@CStudioModelRenderer@@AAE?AVmatrix3x3@@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransformToDecalSpace@CStudioModelRenderer@@AAE_NAAUDecalBuildInfo_t@1@ABVVector@@PAUmstudioboneweight_t@@AAVVector2D@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProjectDecalOntoMesh@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ComputeClipFlags@CStudioModelRenderer@@AAEHABVVector2D@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertMeshVertexToDecalVertex@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HAAUDecalVertex_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@AAUDecalVertex_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddClippedDecalToTriangle@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@AAUDecalClipState_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IntersectPlane@CStudioModelRenderer@@AAEHAAUDecalClipState_t@@HHHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClipTriangleAgainstPlane@CStudioModelRenderer@@AAEXAAUDecalClipState_t@@HHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClipDecal@CStudioModelRenderer@@AAE_NAAUDecalBuildInfo_t@1@HHHPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DecalClipState_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DecalVertex_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTriangleToDecal@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDecalToMesh@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDecalToModel@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateDecalForMaterial@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDecalMaterial@CStudioModelRenderer@@AAEHAAUDecalModelList_t@1@HPAUmstudiomat_s@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RetireDecal@CStudioModelRenderer@@AAEXAAV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShouldRetireDecal@CStudioModelRenderer@@AAE_NPAUDecalMaterial_t@1@ABV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDecalToMaterialList@CStudioModelRenderer@@AAEHPAUDecalMaterial_t@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioDecalShoot@CStudioModelRenderer@@QAEXABVVector@@0HPAUcl_entity_s@@HPAUmodelstate_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DecalBuildInfo_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ComputeDecalTransform@CStudioModelRenderer@@AAEXAAUDecalMaterial_t@1@QBVmatrix3x4@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawDecalMaterial@CStudioModelRenderer@@AAEXAAUDecalMaterial_t@1@QBVmatrix3x4@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawDecal@CStudioModelRenderer@@AAEXPAUcl_entity_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UJiggleData@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveMultiple@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGABUDecalVertex_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Head@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Next@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Head@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Next@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Head@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Alloc@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinkBefore@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Next@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IBEABUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUJiggleData@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHHABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsLeft@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@GH@@QAEAAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@GH@@QAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGGABUDecalVertex_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlink@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsInList@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocInternal@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@GH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinkBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlink@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocInternal@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Construct@@YAXPAUDecalVertex_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecalVertex_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinkBefore@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlink@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocInternal@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinkBefore@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlink@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocInternal@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Construct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Previous@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinkBefore@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlink@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocInternal@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DecalVertex_t@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Decal_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GDecalMaterial_t@CStudioModelRenderer@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DecalModelList_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GDecalModelList_t@CStudioModelRenderer@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1DecalModelList_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@GH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@GH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@GH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@GH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsInList@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsInList@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsInList@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsInList@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@GH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@GH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@GH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Previous@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Previous@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Previous@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Previous@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CHudBase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CStudioBoneSetup@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudSayText@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudFlashlight@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudGeiger@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudDeathNotice@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudBattery@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudTrain@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudMenu@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudTextMessage@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudAmmo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudHealth@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudStatusIcons@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudAmmoSecondary@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudStatusBar@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudMessage@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudMOTD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudScoreboard@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L55256:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L55257
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L55256
$L55257:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?CreateDecalList@CStudioModelRenderer@@AAEGXZ	; CStudioModelRenderer::CreateDecalList
PUBLIC	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
PUBLIC	??A?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::operator[]
PUBLIC	?AddToTail@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::AddToTail
;	COMDAT ?CreateDecalList@CStudioModelRenderer@@AAEGXZ
_TEXT	SEGMENT
_this$ = -4
_handle$ = -8
?CreateDecalList@CStudioModelRenderer@@AAEGXZ PROC NEAR	; CStudioModelRenderer::CreateDecalList, COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 37   : 	word handle = m_DecalList.AddToTail();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?AddToTail@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::AddToTail
	mov	WORD PTR _handle$[ebp], ax

; 38   : 
; 39   : 	m_DecalList[handle].m_FirstMaterial = m_DecalMaterial.InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	mov	si, ax
	mov	ax, WORD PTR _handle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::operator[]
	mov	WORD PTR [eax], si

; 40   : 
; 41   : 	return handle;

	mov	ax, WORD PTR _handle$[ebp]

; 42   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateDecalList@CStudioModelRenderer@@AAEGXZ ENDP	; CStudioModelRenderer::CreateDecalList
_TEXT	ENDS
PUBLIC	?DestroyDecalList@CStudioModelRenderer@@AAEXG@Z	; CStudioModelRenderer::DestroyDecalList
PUBLIC	?Remove@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Remove
PUBLIC	?Next@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Next
PUBLIC	?Remove@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Remove
;	COMDAT ?DestroyDecalList@CStudioModelRenderer@@AAEXG@Z
_TEXT	SEGMENT
_handle$ = 8
_this$ = -4
_mat$ = -8
_next$71910 = -12
?DestroyDecalList@CStudioModelRenderer@@AAEXG@Z PROC NEAR ; CStudioModelRenderer::DestroyDecalList, COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 46   : 	if( handle == INVALID_HANDLE )

	mov	eax, DWORD PTR _handle$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	eax, 65535				; 0000ffffH
	jne	SHORT $L71905

; 47   : 		return;

	jmp	SHORT $L71904
$L71905:

; 48   : 
; 49   : 	// blat out all geometry associated with all materials
; 50   : 	word mat = m_DecalList[handle].m_FirstMaterial;

	mov	cx, WORD PTR _handle$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::operator[]
	mov	dx, WORD PTR [eax]
	mov	WORD PTR _mat$[ebp], dx
$L71908:

; 51   : 
; 52   : 	while( mat != m_DecalMaterial.InvalidIndex( ))

	mov	esi, DWORD PTR _mat$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L71909

; 54   : 		word next = m_DecalMaterial.Next( mat );

	mov	ax, WORD PTR _mat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Next@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Next
	mov	WORD PTR _next$71910[ebp], ax

; 55   : 		m_DecalMaterial.Remove( mat );

	mov	cx, WORD PTR _mat$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Remove@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Remove

; 56   : 		mat = next;

	mov	dx, WORD PTR _next$71910[ebp]
	mov	WORD PTR _mat$[ebp], dx

; 57   : 	}

	jmp	SHORT $L71908
$L71909:

; 58   : 
; 59   : 	m_DecalList.Remove( handle );

	mov	ax, WORD PTR _handle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?Remove@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Remove
$L71904:

; 60   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DestroyDecalList@CStudioModelRenderer@@AAEXG@Z ENDP	; CStudioModelRenderer::DestroyDecalList
_TEXT	ENDS
PUBLIC	?StudioClearDecals@CStudioModelRenderer@@QAEXXZ	; CStudioModelRenderer::StudioClearDecals
PUBLIC	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
PUBLIC	?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Count
;	COMDAT ?StudioClearDecals@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
_inst$71919 = -12
?StudioClearDecals@CStudioModelRenderer@@QAEXXZ PROC NEAR ; CStudioModelRenderer::StudioClearDecals, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 64   : 	// NOTE: should destroy in reverse-oreder because it's linked list not array!
; 65   : 	for( int i = m_ModelInstances.Count(); --i >= 0; )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Count
	mov	DWORD PTR _i$[ebp], eax
$L71917:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L71918

; 67   : 		ModelInstance_t& inst = m_ModelInstances[i];

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	DWORD PTR _inst$71919[ebp], eax

; 68   : 
; 69   : 		if( inst.m_DecalHandle == INVALID_HANDLE )

	mov	edx, DWORD PTR _inst$71919[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+8]
	cmp	eax, 65535				; 0000ffffH
	jne	SHORT $L71920

; 70   : 			continue;	// not initialized?

	jmp	SHORT $L71917
$L71920:

; 71   : 
; 72   : 		DestroyDecalList( inst.m_DecalHandle );

	mov	ecx, DWORD PTR _inst$71919[ebp]
	mov	dx, WORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DestroyDecalList@CStudioModelRenderer@@AAEXG@Z ; CStudioModelRenderer::DestroyDecalList

; 73   : 		inst.m_DecalHandle = INVALID_HANDLE;

	mov	eax, DWORD PTR _inst$71919[ebp]
	mov	WORD PTR [eax+8], 65535			; 0000ffffH

; 74   : 	}

	jmp	SHORT $L71917
$L71918:

; 75   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioClearDecals@CStudioModelRenderer@@QAEXXZ ENDP	; CStudioModelRenderer::StudioClearDecals
_TEXT	ENDS
PUBLIC	?RemoveAllDecals@CStudioModelRenderer@@QAEXH@Z	; CStudioModelRenderer::RemoveAllDecals
EXTRN	?g_fRenderInitialized@@3HA:DWORD		; g_fRenderInitialized
EXTRN	?gEngfuncs@@3Ucl_enginefuncs_s@@A:BYTE		; gEngfuncs
;	COMDAT ?RemoveAllDecals@CStudioModelRenderer@@QAEXH@Z
_TEXT	SEGMENT
_entityIndex$ = 8
_this$ = -4
_ent$ = -8
_inst$ = -12
?RemoveAllDecals@CStudioModelRenderer@@QAEXH@Z PROC NEAR ; CStudioModelRenderer::RemoveAllDecals, COMDAT

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 	if( !g_fRenderInitialized ) return;

	cmp	DWORD PTR ?g_fRenderInitialized@@3HA, 0	; g_fRenderInitialized
	jne	SHORT $L71925
	jmp	$L71924
$L71925:

; 83   : 
; 84   : 	cl_entity_t *ent = gEngfuncs.GetEntityByIndex( entityIndex );

	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 85   : 
; 86   : 	if( !ent || ent->modelhandle == INVALID_HANDLE )

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $L71928
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+2960], 65535		; 0000ffffH
	jne	SHORT $L71927
$L71928:

; 87   : 		return;

	jmp	SHORT $L71924
$L71927:

; 88   : 
; 89   : 	ModelInstance_t *inst = &m_ModelInstances[ent->modelhandle];

	mov	edx, DWORD PTR _ent$[ebp]
	mov	ax, WORD PTR [edx+2960]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	DWORD PTR _inst$[ebp], eax

; 90   : 
; 91   : 	if( !IsModelInstanceValid( inst ))

	mov	ecx, DWORD PTR _inst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+144]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L71930

; 92   : 		return;	// no instance data

	jmp	SHORT $L71924
$L71930:

; 93   : 
; 94   : 	if( inst->m_DecalHandle == INVALID_HANDLE )

	mov	ecx, DWORD PTR _inst$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+8]
	cmp	edx, 65535				; 0000ffffH
	jne	SHORT $L71931

; 95   : 		return;	// no decals data

	jmp	SHORT $L71924
$L71931:

; 96   : 
; 97   : 	DestroyDecalList( inst->m_DecalHandle );

	mov	eax, DWORD PTR _inst$[ebp]
	mov	cx, WORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DestroyDecalList@CStudioModelRenderer@@AAEXG@Z ; CStudioModelRenderer::DestroyDecalList

; 98   : 	inst->m_DecalHandle = INVALID_HANDLE;

	mov	edx, DWORD PTR _inst$[ebp]
	mov	WORD PTR [edx+8], 65535			; 0000ffffH
$L71924:

; 99   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAllDecals@CStudioModelRenderer@@QAEXH@Z ENDP	; CStudioModelRenderer::RemoveAllDecals
_TEXT	ENDS
PUBLIC	?StudioDecalList@CStudioModelRenderer@@QAEHPAUdecallist_s@@H@Z ; CStudioModelRenderer::StudioDecalList
PUBLIC	??_C@_0DI@OHIF@StudioDecalList?3?5too?5many?5studio@ ; `string'
PUBLIC	??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::operator[]
PUBLIC	??A?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::operator[]
PUBLIC	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
PUBLIC	?Head@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Head
PUBLIC	?Next@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Next
EXTRN	?ALERT@@YAXW4ALERT_TYPE@@PADZZ:NEAR		; ALERT
EXTRN	?gRenderfuncs@@3Urender_api_s@@A:BYTE		; gRenderfuncs
EXTRN	?Q_strncpy@@YAIPADPBDI@Z:NEAR			; Q_strncpy
EXTRN	?COM_FileBase@@YAXPBDPAD@Z:NEAR			; COM_FileBase
;	COMDAT ??_C@_0DI@OHIF@StudioDecalList?3?5too?5many?5studio@
; File z:\xashxtsrc\client\render\r_studiodecal.cpp
CONST	SEGMENT
??_C@_0DI@OHIF@StudioDecalList?3?5too?5many?5studio@ DB 'StudioDecalList:'
	DB	' too many studio decals on save', 0dH, 'estore', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?StudioDecalList@CStudioModelRenderer@@QAEHPAUdecallist_s@@H@Z
_TEXT	SEGMENT
_pBaseList$ = 8
_count$ = 12
_this$ = -4
_maxStudioDecals$ = -8
_pList$ = -12
_pEntity$ = -16
_decalname$ = -80
_total$ = -84
_i$ = -88
_decalHandle$71947 = -92
_list$71949 = -96
_decalMaterial$71950 = -100
_mat$71951 = -104
_decalMaterial$71955 = -108
_decal$71956 = -112
_pdecal$71960 = -116
?StudioDecalList@CStudioModelRenderer@@QAEHPAUdecallist_s@@H@Z PROC NEAR ; CStudioModelRenderer::StudioDecalList, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 	if( !g_fRenderInitialized )

	cmp	DWORD PTR ?g_fRenderInitialized@@3HA, 0	; g_fRenderInitialized
	jne	SHORT $L71937

; 107  : 		return 0;

	xor	eax, eax
	jmp	$L71936
$L71937:

; 108  : 
; 109  : 	int maxStudioDecals = MAX_STUDIO_DECALS + (MAX_BMODEL_DECALS - count);

	mov	eax, 4096				; 00001000H
	sub	eax, DWORD PTR _count$[ebp]
	add	eax, 4096				; 00001000H
	mov	DWORD PTR _maxStudioDecals$[ebp], eax

; 110  : 	decallist_t *pList = pBaseList + count;	// shift list to first free slot

	mov	ecx, DWORD PTR _count$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _pBaseList$[ebp]
	add	edx, ecx
	mov	DWORD PTR _pList$[ebp], edx

; 111  : 	cl_entity_t *pEntity = NULL;

	mov	DWORD PTR _pEntity$[ebp], 0

; 112  : 	char decalname[64];
; 113  : 	int total = 0;

	mov	DWORD PTR _total$[ebp], 0

; 114  : 
; 115  : 	for( int i = 0; i < m_ModelInstances.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L71944
$L71945:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L71944:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	$end_serialize$71964

; 117  : 		word decalHandle = m_ModelInstances[i].m_DecalHandle;

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	dx, WORD PTR [eax+8]
	mov	WORD PTR _decalHandle$71947[ebp], dx

; 118  : 
; 119  : 		if( decalHandle == INVALID_HANDLE )

	mov	eax, DWORD PTR _decalHandle$71947[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	eax, 65535				; 0000ffffH
	jne	SHORT $L71948

; 120  : 			continue;	// no decals for this entity

	jmp	SHORT $L71945
$L71948:

; 121  : 
; 122  : 		DecalModelList_t const& list = m_DecalList[decalHandle];

	mov	cx, WORD PTR _decalHandle$71947[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::operator[]
	mov	DWORD PTR _list$71949[ebp], eax

; 123  : 		word decalMaterial = m_DecalList[decalHandle].m_FirstMaterial;

	mov	dx, WORD PTR _decalHandle$71947[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::operator[]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR _decalMaterial$71950[ebp], ax

; 124  : 
; 125  : 		// setup the decal entity
; 126  : 		pEntity = m_ModelInstances[i].m_pEntity;

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _pEntity$[ebp], edx

; 127  : 
; 128  : 		for( word mat = list.m_FirstMaterial; mat != m_DecalMaterial.InvalidIndex(); mat = m_DecalMaterial.Next( mat ))

	mov	eax, DWORD PTR _list$71949[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _mat$71951[ebp], cx
	jmp	SHORT $L71952
$L71953:
	mov	dx, WORD PTR _mat$71951[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Next@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Next
	mov	WORD PTR _mat$71951[ebp], ax
$L71952:
	mov	esi, DWORD PTR _mat$71951[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	$L71954

; 130  : 			DecalMaterial_t& decalMaterial = m_DecalMaterial[mat];

	mov	ax, WORD PTR _mat$71951[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::operator[]
	mov	DWORD PTR _decalMaterial$71955[ebp], eax

; 131  : 			word decal = decalMaterial.m_Decals.Head();

	mov	ecx, DWORD PTR _decalMaterial$71955[ebp]
	add	ecx, 64					; 00000040H
	call	?Head@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Head
	mov	WORD PTR _decal$71956[ebp], ax

; 132  : 
; 133  : 			// setup the decal texture
; 134  : 			Q_strncpy( decalname, GET_TEXTURE_NAME( decalMaterial.decalTexture ), sizeof( decalname ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _decalMaterial$71955[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+52
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _decalname$[ebp]
	push	eax
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH
$L71958:

; 135  : 
; 136  : 			while( decal != decalMaterial.m_Decals.InvalidIndex( ))

	mov	esi, DWORD PTR _decal$71956[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	$L71959

; 138  : 				Decal_t *pdecal = &decalMaterial.m_Decals[decal];

	mov	cx, WORD PTR _decal$71956[ebp]
	push	ecx
	mov	ecx, DWORD PTR _decalMaterial$71955[ebp]
	add	ecx, 64					; 00000040H
	call	??A?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::operator[]
	mov	DWORD PTR _pdecal$71960[ebp], eax

; 139  : 
; 140  : 				if( FBitSet( pdecal->flags, FDECAL_DONTSAVE ))

	mov	edx, DWORD PTR _pdecal$71960[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+68]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $L71961

; 142  : 					decal = decalMaterial.m_Decals.Next( decal ); 

	mov	cx, WORD PTR _decal$71956[ebp]
	push	ecx
	mov	ecx, DWORD PTR _decalMaterial$71955[ebp]
	add	ecx, 64					; 00000040H
	call	?Next@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Next
	mov	WORD PTR _decal$71956[ebp], ax

; 143  : 					continue;

	jmp	SHORT $L71958
$L71961:

; 145  : 
; 146  : 				pList[total].depth = pdecal->depth;

	mov	edx, DWORD PTR _total$[ebp]
	shl	edx, 7
	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR _pdecal$71960[ebp]
	mov	cl, BYTE PTR [ecx+40]
	mov	BYTE PTR [eax+edx+78], cl

; 147  : 				pList[total].flags = pdecal->flags|FDECAL_STUDIO;

	mov	edx, DWORD PTR _pdecal$71960[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+68]
	or	al, 64					; 00000040H
	mov	ecx, DWORD PTR _total$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _pList$[ebp]
	mov	BYTE PTR [edx+ecx+79], al

; 148  : 				pList[total].entityIndex = pEntity->index;

	mov	eax, DWORD PTR _total$[ebp]
	shl	eax, 7
	mov	ecx, DWORD PTR _pList$[ebp]
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	dx, WORD PTR [edx]
	mov	WORD PTR [ecx+eax+76], dx

; 149  : 				pList[total].studio_state = pdecal->state;

	mov	esi, DWORD PTR _pdecal$71960[ebp]
	add	esi, 8
	mov	eax, DWORD PTR _total$[ebp]
	shl	eax, 7
	mov	ecx, DWORD PTR _pList$[ebp]
	lea	edi, DWORD PTR [ecx+eax+96]
	mov	ecx, 7
	rep movsd
	movsw

; 150  : 				pList[total].position = pdecal->vecLocalEnd;

	mov	edx, DWORD PTR _pdecal$71960[ebp]
	add	edx, 56					; 00000038H
	mov	eax, DWORD PTR _total$[ebp]
	shl	eax, 7
	mov	ecx, DWORD PTR _pList$[ebp]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 151  : 				pList[total].impactPlaneNormal = pdecal->vecLocalStart;

	mov	eax, DWORD PTR _pdecal$71960[ebp]
	add	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _total$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _pList$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+84]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 152  : 				COM_FileBase( decalname, pList[total].name );

	mov	ecx, DWORD PTR _total$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _pList$[ebp]
	lea	eax, DWORD PTR [edx+ecx+12]
	push	eax
	lea	ecx, DWORD PTR _decalname$[ebp]
	push	ecx
	call	?COM_FileBase@@YAXPBDPAD@Z		; COM_FileBase
	add	esp, 8

; 153  : 				total++;

	mov	edx, DWORD PTR _total$[ebp]
	add	edx, 1
	mov	DWORD PTR _total$[ebp], edx

; 154  : 
; 155  : 				// check for list overflow
; 156  : 				if( total >= maxStudioDecals )

	mov	eax, DWORD PTR _total$[ebp]
	cmp	eax, DWORD PTR _maxStudioDecals$[ebp]
	jl	SHORT $L71962

; 158  : 					ALERT( at_error, "StudioDecalList: too many studio decals on save\restore\n" );

	push	OFFSET FLAT:??_C@_0DI@OHIF@StudioDecalList?3?5too?5many?5studio@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 8

; 159  : 					goto end_serialize;

	jmp	SHORT $L71965
$L71962:

; 161  : 
; 162  : 				decal = decalMaterial.m_Decals.Next( decal ); 

	mov	cx, WORD PTR _decal$71956[ebp]
	push	ecx
	mov	ecx, DWORD PTR _decalMaterial$71955[ebp]
	add	ecx, 64					; 00000040H
	call	?Next@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Next
	mov	WORD PTR _decal$71956[ebp], ax

; 163  : 			}

	jmp	$L71958
$L71959:

; 164  : 		}

	jmp	$L71953
$L71954:

; 165  : 	}

	jmp	$L71945
$end_serialize$71964:

; 166  : end_serialize:
; 167  : 
; 168  : 	return total;

	mov	eax, DWORD PTR _total$[ebp]
	jmp	SHORT $L71936
$L71965:

; 169  : }

	jmp	SHORT $end_serialize$71964
$L71936:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?StudioDecalList@CStudioModelRenderer@@QAEHPAUdecallist_s@@H@Z ENDP ; CStudioModelRenderer::StudioDecalList
_TEXT	ENDS
PUBLIC	??Amatrix3x4@@QAEPAMH@Z				; matrix3x4::operator[]
PUBLIC	??0matrix3x4@@QAE@ABV0@@Z			; matrix3x4::matrix3x4
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	?NormalizeLength@Vector@@QAEMXZ			; Vector::NormalizeLength
PUBLIC	?DotProduct@@YAMABVVector@@0@Z			; DotProduct
PUBLIC	?CrossProduct@@YA?AVVector@@ABV1@0@Z		; CrossProduct
PUBLIC	__real@4@00000000000000000000
PUBLIC	__real@8@3ff583126e978d4fe000
PUBLIC	?ComputePoseToDecal@CStudioModelRenderer@@AAE_NABVVector@@0@Z ; CStudioModelRenderer::ComputePoseToDecal
EXTRN	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z:NEAR	; matrix3x4::ConcatTransforms
EXTRN	__fltused:NEAR
EXTRN	??0matrix3x4@@QAE@XZ:NEAR			; matrix3x4::matrix3x4
;	COMDAT __real@4@00000000000000000000
; File z:\xashxtsrc\client\render\r_studiodecal.cpp
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT __real@8@3ff583126e978d4fe000
CONST	SEGMENT
__real@8@3ff583126e978d4fe000 DQ 03f50624dd2f1a9fcr ; 0.001
CONST	ENDS
;	COMDAT ?ComputePoseToDecal@CStudioModelRenderer@@AAE_NABVVector@@0@Z
_TEXT	SEGMENT
_vecStart$ = 8
_vecEnd$ = 12
_this$ = -4
_decalU$ = -16
_decalV$ = -28
_decalN$ = -40
_vecDelta$ = -52
_worldToDecal$ = -100
_fixup$71983 = -112
_i$ = -116
$T74388 = -128
$T74389 = -140
$T74390 = -152
$T74391 = -164
$T74392 = -176
$T74393 = -188
$T74394 = -200
$T74396 = -252
?ComputePoseToDecal@CStudioModelRenderer@@AAE_NABVVector@@0@Z PROC NEAR ; CStudioModelRenderer::ComputePoseToDecal, COMDAT

; 175  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 176  : 	// Create a transform that projects world coordinates into a basis for the decal
; 177  : 	Vector decalU, decalV, decalN, vecDelta;

	lea	ecx, DWORD PTR _decalU$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _decalV$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _decalN$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _vecDelta$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 178  : 	matrix3x4	worldToDecal;

	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 179  : 
; 180  : 	// Bloat a little bit so we get the intersection
; 181  : 	vecDelta = (vecEnd - vecStart) * 1.1f;

	push	1066192077				; 3f8ccccdH
	lea	eax, DWORD PTR $T74389[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecStart$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T74388[ebp]
	push	edx
	mov	ecx, DWORD PTR _vecEnd$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecDelta$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecDelta$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecDelta$[ebp+8], eax

; 182  : 
; 183  : 	// Get the z axis
; 184  : 	decalN = vecDelta * -1.0f;

	push	-1082130432				; bf800000H
	lea	ecx, DWORD PTR $T74390[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecDelta$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _decalN$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _decalN$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _decalN$[ebp+8], edx

; 185  : 	if( decalN.NormalizeLength() == 0.0f )

	lea	ecx, DWORD PTR _decalN$[ebp]
	call	?NormalizeLength@Vector@@QAEMXZ		; Vector::NormalizeLength
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L71979

; 186  : 		return false;

	xor	al, al
	jmp	$L71970
$L71979:

; 187  : 
; 188  : 	// Deal with the u axis
; 189  : 	decalU = CrossProduct( Vector( 0.0f, 0.0f, 1.0f ), decalN );

	lea	eax, DWORD PTR _decalN$[ebp]
	push	eax
	push	1065353216				; 3f800000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T74391[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T74392[ebp]
	push	ecx
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _decalU$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _decalU$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _decalU$[ebp+8], edx

; 190  : 
; 191  : 	if( decalU.NormalizeLength() < 1e-3 )

	lea	ecx, DWORD PTR _decalU$[ebp]
	call	?NormalizeLength@Vector@@QAEMXZ		; Vector::NormalizeLength
	fcomp	QWORD PTR __real@8@3ff583126e978d4fe000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71985

; 193  : 		// if up parallel or antiparallel to ray, deal...
; 194  : 		Vector fixup( 0.0f, 1.0f, 0.0f );

	push	0
	push	1065353216				; 3f800000H
	push	0
	lea	ecx, DWORD PTR _fixup$71983[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 195  : 		decalU = CrossProduct( fixup, decalN );

	lea	eax, DWORD PTR _decalN$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fixup$71983[ebp]
	push	ecx
	lea	edx, DWORD PTR $T74393[ebp]
	push	edx
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _decalU$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _decalU$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _decalU$[ebp+8], eax

; 196  : 
; 197  : 		if( decalU.NormalizeLength() < 1e-3 )

	lea	ecx, DWORD PTR _decalU$[ebp]
	call	?NormalizeLength@Vector@@QAEMXZ		; Vector::NormalizeLength
	fcomp	QWORD PTR __real@8@3ff583126e978d4fe000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71985

; 198  : 			return false;

	xor	al, al
	jmp	$L71970
$L71985:

; 200  : 
; 201  : 	decalV = CrossProduct( decalN, decalU );

	lea	ecx, DWORD PTR _decalU$[ebp]
	push	ecx
	lea	edx, DWORD PTR _decalN$[ebp]
	push	edx
	lea	eax, DWORD PTR $T74394[ebp]
	push	eax
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _decalV$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _decalV$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _decalV$[ebp+8], eax

; 202  : 
; 203  : 	// Since I want world-to-decal, I gotta take the inverse of the decal
; 204  : 	// to world. Assuming post-multiplying column vectors, the decal to world = 
; 205  : 	// [ Ux Vx Nx | vecEnd[0] ]
; 206  : 	// [ Uy Vy Ny | vecEnd[1] ]
; 207  : 	// [ Uz Vz Nz | vecEnd[2] ]
; 208  : 
; 209  : 	worldToDecal[0][0] = decalU.x;

	push	0
	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _decalU$[ebp]
	mov	DWORD PTR [eax], ecx

; 210  : 	worldToDecal[1][0] = decalU.y;

	push	1
	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR _decalU$[ebp+4]
	mov	DWORD PTR [eax], edx

; 211  : 	worldToDecal[2][0] = decalU.z;

	push	2
	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _decalU$[ebp+8]
	mov	DWORD PTR [eax], ecx

; 212  : 
; 213  : 	worldToDecal[0][1] = decalV.x;

	push	0
	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR _decalV$[ebp]
	mov	DWORD PTR [eax+4], edx

; 214  : 	worldToDecal[1][1] = decalV.y;

	push	1
	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _decalV$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 215  : 	worldToDecal[2][1] = decalV.z;

	push	2
	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR _decalV$[ebp+8]
	mov	DWORD PTR [eax+4], edx

; 216  : 
; 217  : 	worldToDecal[0][2] = decalN.x;

	push	0
	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _decalN$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 218  : 	worldToDecal[1][2] = decalN.y;

	push	1
	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR _decalN$[ebp+4]
	mov	DWORD PTR [eax+8], edx

; 219  : 	worldToDecal[2][2] = decalN.z;

	push	2
	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _decalN$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 220  : 
; 221  : 	// g-cont. just invert matrix here?
; 222  : 	worldToDecal[3][0] = -DotProduct( vecEnd, decalU );

	lea	edx, DWORD PTR _decalU$[ebp]
	push	edx
	mov	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fchs
	fstp	DWORD PTR -256+[ebp]
	push	3
	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -256+[ebp]
	mov	DWORD PTR [eax], ecx

; 223  : 	worldToDecal[3][1] = -DotProduct( vecEnd, decalV );

	lea	edx, DWORD PTR _decalV$[ebp]
	push	edx
	mov	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fchs
	fstp	DWORD PTR -260+[ebp]
	push	3
	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -260+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 224  : 	worldToDecal[3][2] = -DotProduct( vecEnd, decalN );

	lea	edx, DWORD PTR _decalN$[ebp]
	push	edx
	mov	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fchs
	fstp	DWORD PTR -264+[ebp]
	push	3
	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -264+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 225  : 
; 226  : 	// Compute transforms from pose space to decal plane space
; 227  : 	for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L71988
$L71989:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L71988:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+140]
	jge	SHORT $L71990

; 229  : 		m_pdecaltransform[i] = worldToDecal.ConcatTransforms( m_pworldtransform[i] );

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1274076]
	sub	esp, 48					; 00000030H
	mov	ecx, esp
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	eax, DWORD PTR $T74396[ebp]
	push	eax
	lea	ecx, DWORD PTR _worldToDecal$[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	esi, eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [edx+ecx+219356]
	mov	ecx, 12					; 0000000cH
	rep movsd

; 230  : 	}

	jmp	SHORT $L71989
$L71990:

; 231  : 
; 232  : 	return true;

	mov	al, 1
$L71970:

; 233  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ComputePoseToDecal@CStudioModelRenderer@@AAE_NABVVector@@0@Z ENDP ; CStudioModelRenderer::ComputePoseToDecal
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T74408 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T74408[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T74413 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T74413[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	__real@4@3fff8000000000000000
;	COMDAT __real@4@3fff8000000000000000
; File z:\xashxtsrc\game_shared\vector.h
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT ?NormalizeLength@Vector@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4
_flLen$ = -8
_flInvLen$54771 = -12
?NormalizeLength@Vector@@QAEMXZ PROC NEAR		; Vector::NormalizeLength, COMDAT

; 245  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 247  : 
; 248  : 		if( flLen )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L54770

; 250  : 			float flInvLen = 1.0f / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flInvLen$54771[ebp]

; 251  : 			x *= flInvLen, y *= flInvLen, z *= flInvLen;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flInvLen$54771[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flInvLen$54771[ebp]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flInvLen$54771[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]
$L54770:

; 253  : 
; 254  : 		return flLen;

	fld	DWORD PTR _flLen$[ebp]

; 255  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NormalizeLength@Vector@@QAEMXZ ENDP			; Vector::NormalizeLength
_TEXT	ENDS
EXTRN	_sqrt:NEAR
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProduct@@YAMABVVector@@0@Z PROC NEAR		; DotProduct, COMDAT

; 289  : inline float DotProduct(const Vector& a, const Vector& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector@@0@Z ENDP			; DotProduct
_TEXT	ENDS
;	COMDAT ?CrossProduct@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT
_a$ = 12
_b$ = 16
___$ReturnUdt$ = 8
$T74424 = -12
?CrossProduct@@YA?AVVector@@ABV1@0@Z PROC NEAR		; CrossProduct, COMDAT

; 291  : inline Vector CrossProduct( const Vector& a, const Vector& b ) { return Vector( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+4]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T74424[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CrossProduct@@YA?AVVector@@ABV1@0@Z ENDP		; CrossProduct
_TEXT	ENDS
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
;	COMDAT ??Amatrix3x4@@QAEPAMH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??Amatrix3x4@@QAEPAMH@Z PROC NEAR			; matrix3x4::operator[], COMDAT

; 497  : 	float* operator[]( int i ) { return mat[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, eax
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??Amatrix3x4@@QAEPAMH@Z ENDP				; matrix3x4::operator[]
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
_$S4$ = -8
_$S5$ = -12
_$S6$ = -16
??0matrix3x4@@QAE@ABV0@@Z PROC NEAR			; matrix3x4::matrix3x4, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S4$[ebp], 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _$S5$[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR _$S6$[ebp], ecx
$L55527:
	mov	edx, DWORD PTR _$S6$[ebp]
	push	edx
	mov	ecx, DWORD PTR _$S5$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR _$S5$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _$S5$[ebp], eax
	mov	ecx, DWORD PTR _$S6$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _$S6$[ebp], ecx
	mov	edx, DWORD PTR _$S4$[ebp]
	sub	edx, 1
	mov	DWORD PTR _$S4$[ebp], edx
	cmp	DWORD PTR _$S4$[ebp], 0
	ja	SHORT $L55527
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix3x4@@QAE@ABV0@@Z ENDP				; matrix3x4::matrix3x4
_TEXT	ENDS
PUBLIC	??Amatrix3x3@@QAEPAMH@Z				; matrix3x3::operator[]
PUBLIC	??0matrix3x3@@QAE@ABV0@@Z			; matrix3x3::matrix3x3
PUBLIC	?GetDecalRotateTransform@CStudioModelRenderer@@AAE?AVmatrix3x3@@E@Z ; CStudioModelRenderer::GetDecalRotateTransform
EXTRN	??0matrix3x3@@QAE@XZ:NEAR			; matrix3x3::matrix3x3
;	COMDAT ?GetDecalRotateTransform@CStudioModelRenderer@@AAE?AVmatrix3x3@@E@Z
_TEXT	SEGMENT
_vertexBone$ = 12
___$ReturnUdt$ = 8
_this$ = -4
_transform$ = -40
?GetDecalRotateTransform@CStudioModelRenderer@@AAE?AVmatrix3x3@@E@Z PROC NEAR ; CStudioModelRenderer::GetDecalRotateTransform, COMDAT

; 268  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 269  : 	matrix3x3	transform;

	lea	ecx, DWORD PTR _transform$[ebp]
	call	??0matrix3x3@@QAE@XZ			; matrix3x3::matrix3x3

; 270  : 
; 271  : 	transform[0][0] = m_pdecaltransform[vertexBone][0][0];

	push	0
	mov	eax, DWORD PTR _vertexBone$[ebp]
	and	eax, 255				; 000000ffH
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	push	0
	lea	ecx, DWORD PTR _transform$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx

; 272  : 	transform[0][1] = m_pdecaltransform[vertexBone][1][0];

	push	1
	mov	eax, DWORD PTR _vertexBone$[ebp]
	and	eax, 255				; 000000ffH
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	push	0
	lea	ecx, DWORD PTR _transform$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax+4], edx

; 273  : 	transform[0][2] = m_pdecaltransform[vertexBone][2][0];

	push	2
	mov	eax, DWORD PTR _vertexBone$[ebp]
	and	eax, 255				; 000000ffH
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	push	0
	lea	ecx, DWORD PTR _transform$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax+8], edx

; 274  : 
; 275  : 	transform[1][0] = m_pdecaltransform[vertexBone][0][1];

	push	0
	mov	eax, DWORD PTR _vertexBone$[ebp]
	and	eax, 255				; 000000ffH
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	push	1
	lea	ecx, DWORD PTR _transform$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], edx

; 276  : 	transform[1][1] = m_pdecaltransform[vertexBone][1][1];

	push	1
	mov	eax, DWORD PTR _vertexBone$[ebp]
	and	eax, 255				; 000000ffH
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	push	1
	lea	ecx, DWORD PTR _transform$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx

; 277  : 	transform[1][2] = m_pdecaltransform[vertexBone][2][1];

	push	2
	mov	eax, DWORD PTR _vertexBone$[ebp]
	and	eax, 255				; 000000ffH
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	push	1
	lea	ecx, DWORD PTR _transform$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], edx

; 278  : 
; 279  : 	transform[2][0] = m_pdecaltransform[vertexBone][0][2];

	push	0
	mov	eax, DWORD PTR _vertexBone$[ebp]
	and	eax, 255				; 000000ffH
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	push	2
	lea	ecx, DWORD PTR _transform$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax], edx

; 280  : 	transform[2][1] = m_pdecaltransform[vertexBone][1][2];

	push	1
	mov	eax, DWORD PTR _vertexBone$[ebp]
	and	eax, 255				; 000000ffH
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	push	2
	lea	ecx, DWORD PTR _transform$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx

; 281  : 	transform[2][2] = m_pdecaltransform[vertexBone][2][2];

	push	2
	mov	eax, DWORD PTR _vertexBone$[ebp]
	and	eax, 255				; 000000ffH
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	push	2
	lea	ecx, DWORD PTR _transform$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx

; 282  : 
; 283  : 	return transform;

	lea	eax, DWORD PTR _transform$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0matrix3x3@@QAE@ABV0@@Z		; matrix3x3::matrix3x3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetDecalRotateTransform@CStudioModelRenderer@@AAE?AVmatrix3x3@@E@Z ENDP ; CStudioModelRenderer::GetDecalRotateTransform
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QAEPAMH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??Amatrix3x3@@QAEPAMH@Z PROC NEAR			; matrix3x3::operator[], COMDAT

; 133  : 	float* operator[]( int i ) { return mat[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, eax
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??Amatrix3x3@@QAEPAMH@Z ENDP				; matrix3x3::operator[]
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
_$S1$ = -8
_$S2$ = -12
_$S3$ = -16
??0matrix3x3@@QAE@ABV0@@Z PROC NEAR			; matrix3x3::matrix3x3, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S1$[ebp], 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _$S2$[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR _$S3$[ebp], ecx
$L55264:
	mov	edx, DWORD PTR _$S3$[ebp]
	push	edx
	mov	ecx, DWORD PTR _$S2$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR _$S2$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _$S2$[ebp], eax
	mov	ecx, DWORD PTR _$S3$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _$S3$[ebp], ecx
	mov	edx, DWORD PTR _$S1$[ebp]
	sub	edx, 1
	mov	DWORD PTR _$S1$[ebp], edx
	cmp	DWORD PTR _$S1$[ebp], 0
	ja	SHORT $L55264
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix3x3@@QAE@ABV0@@Z ENDP				; matrix3x3::matrix3x3
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@QAM@Z				; Vector::Vector
PUBLIC	__real@4@4006ff00000000000000
PUBLIC	?TransformToDecalSpace@CStudioModelRenderer@@AAE_NAAUDecalBuildInfo_t@1@ABVVector@@PAUmstudioboneweight_t@@AAVVector2D@@@Z ; CStudioModelRenderer::TransformToDecalSpace
EXTRN	_fabs:NEAR
;	COMDAT __real@4@4006ff00000000000000
; File z:\xashxtsrc\client\render\r_studiodecal.cpp
CONST	SEGMENT
__real@4@4006ff00000000000000 DD 0437f0000r	; 255
CONST	ENDS
;	COMDAT ?TransformToDecalSpace@CStudioModelRenderer@@AAE_NAAUDecalBuildInfo_t@1@ABVVector@@PAUmstudioboneweight_t@@AAVVector2D@@@Z
_TEXT	SEGMENT
_build$ = 8
_pos$ = 12
_pboneweight$ = 16
_uv$ = 20
_this$ = -4
_decalMat$ = -40
_z$ = -44
_vertexBone$72023 = -48
_weight$72029 = -52
_i$72030 = -56
_vertexBone$72034 = -60
$T74439 = -96
$T74440 = -108
$T74441 = -120
$T74442 = -132
$T74443 = -168
$T74444 = -180
$T74445 = -192
$T74446 = -204
?TransformToDecalSpace@CStudioModelRenderer@@AAE_NAAUDecalBuildInfo_t@1@ABVVector@@PAUmstudioboneweight_t@@AAVVector2D@@@Z PROC NEAR ; CStudioModelRenderer::TransformToDecalSpace, COMDAT

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 	// NOTE: This only works to rotate normals if there's no scale in the
; 289  : 	// pose to world transforms. If we ever add scale, we'll need to
; 290  : 	// multiply by the inverse transpose of the pose to world
; 291  : 	matrix3x3 decalMat;

	lea	ecx, DWORD PTR _decalMat$[ebp]
	call	??0matrix3x3@@QAE@XZ			; matrix3x3::matrix3x3

; 292  : 	float z;
; 293  : 
; 294  : 	if( pboneweight->weight[0] == 255 )

	mov	eax, DWORD PTR _pboneweight$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	jne	$L72022

; 296  : 		byte vertexBone = pboneweight->bone[0];

	mov	edx, DWORD PTR _pboneweight$[ebp]
	mov	al, BYTE PTR [edx+4]
	mov	BYTE PTR _vertexBone$72023[ebp], al

; 297  : 
; 298  : 		decalMat = GetDecalRotateTransform( vertexBone );

	mov	cl, BYTE PTR _vertexBone$72023[ebp]
	push	ecx
	lea	edx, DWORD PTR $T74439[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDecalRotateTransform@CStudioModelRenderer@@AAE?AVmatrix3x3@@E@Z ; CStudioModelRenderer::GetDecalRotateTransform
	mov	esi, eax
	mov	ecx, 9
	lea	edi, DWORD PTR _decalMat$[ebp]
	rep movsd

; 299  : 		uv.x = (DotProduct( pos, decalMat[0] ) + m_pdecaltransform[vertexBone][3][0]);

	push	0
	lea	ecx, DWORD PTR _decalMat$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	push	eax
	lea	ecx, DWORD PTR $T74440[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	lea	eax, DWORD PTR $T74440[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	fstp	DWORD PTR -208+[ebp]
	add	esp, 8
	push	3
	mov	edx, DWORD PTR _vertexBone$72023[ebp]
	and	edx, 255				; 000000ffH
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR -208+[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _uv$[ebp]
	fstp	DWORD PTR [ecx]

; 300  : 		uv.y = -(DotProduct( pos, decalMat[1] ) + m_pdecaltransform[vertexBone][3][1]);

	push	1
	lea	ecx, DWORD PTR _decalMat$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	push	eax
	lea	ecx, DWORD PTR $T74441[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	lea	edx, DWORD PTR $T74441[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	fstp	DWORD PTR -212+[ebp]
	add	esp, 8
	push	3
	mov	ecx, DWORD PTR _vertexBone$72023[ebp]
	and	ecx, 255				; 000000ffH
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR -212+[ebp]
	fadd	DWORD PTR [eax+4]
	fchs
	mov	eax, DWORD PTR _uv$[ebp]
	fstp	DWORD PTR [eax+4]

; 301  : 		z = DotProduct( pos, decalMat[2] ) + m_pdecaltransform[vertexBone][3][2];

	push	2
	lea	ecx, DWORD PTR _decalMat$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	push	eax
	lea	ecx, DWORD PTR $T74442[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	lea	ecx, DWORD PTR $T74442[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	fstp	DWORD PTR -216+[ebp]
	add	esp, 8
	push	3
	mov	eax, DWORD PTR _vertexBone$72023[ebp]
	and	eax, 255				; 000000ffH
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR -216+[ebp]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _z$[ebp]

; 303  : 	else

	jmp	$L72033
$L72022:

; 305  : 		float	weight;
; 306  : 
; 307  : 		uv.x = uv.y = z = 0.0f;

	mov	DWORD PTR _z$[ebp], 0
	mov	edx, DWORD PTR _uv$[ebp]
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _uv$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx], edx

; 308  : 
; 309  : 		for( int i = 0; i < MAXSTUDIOBONEWEIGHTS; i++ )

	mov	DWORD PTR _i$72030[ebp], 0
	jmp	SHORT $L72031
$L72032:
	mov	eax, DWORD PTR _i$72030[ebp]
	add	eax, 1
	mov	DWORD PTR _i$72030[ebp], eax
$L72031:
	cmp	DWORD PTR _i$72030[ebp], 4
	jge	$L72033

; 311  : 			byte vertexBone = pboneweight->bone[i];

	mov	ecx, DWORD PTR _pboneweight$[ebp]
	add	ecx, DWORD PTR _i$72030[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR _vertexBone$72034[ebp], dl

; 312  : 
; 313  : 			if( vertexBone == -1 )

	mov	eax, DWORD PTR _vertexBone$72034[ebp]
	and	eax, 255				; 000000ffH
	cmp	eax, -1
	jne	SHORT $L72035

; 314  : 				break;

	jmp	$L72033
$L72035:

; 315  : 
; 316  : 			decalMat = GetDecalRotateTransform( vertexBone );

	mov	cl, BYTE PTR _vertexBone$72034[ebp]
	push	ecx
	lea	edx, DWORD PTR $T74443[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDecalRotateTransform@CStudioModelRenderer@@AAE?AVmatrix3x3@@E@Z ; CStudioModelRenderer::GetDecalRotateTransform
	mov	esi, eax
	mov	ecx, 9
	lea	edi, DWORD PTR _decalMat$[ebp]
	rep movsd

; 317  : 			weight = (pboneweight->weight[i] / 255.0f);

	mov	eax, DWORD PTR _pboneweight$[ebp]
	add	eax, DWORD PTR _i$72030[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax]
	mov	DWORD PTR -220+[ebp], ecx
	fild	DWORD PTR -220+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR _weight$72029[ebp]

; 318  : 
; 319  : 			uv.x += (DotProduct( pos, decalMat[0] ) + m_pdecaltransform[vertexBone][3][0]) * weight;

	push	0
	lea	ecx, DWORD PTR _decalMat$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	push	eax
	lea	ecx, DWORD PTR $T74444[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	lea	edx, DWORD PTR $T74444[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	fstp	DWORD PTR -224+[ebp]
	add	esp, 8
	push	3
	mov	ecx, DWORD PTR _vertexBone$72034[ebp]
	and	ecx, 255				; 000000ffH
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR -224+[ebp]
	fadd	DWORD PTR [eax]
	fmul	DWORD PTR _weight$72029[ebp]
	mov	eax, DWORD PTR _uv$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _uv$[ebp]
	fstp	DWORD PTR [ecx]

; 320  : 			uv.y += -(DotProduct( pos, decalMat[1] ) + m_pdecaltransform[vertexBone][3][1]) * weight;

	push	1
	lea	ecx, DWORD PTR _decalMat$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	push	eax
	lea	ecx, DWORD PTR $T74445[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	lea	edx, DWORD PTR $T74445[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	fstp	DWORD PTR -228+[ebp]
	add	esp, 8
	push	3
	mov	ecx, DWORD PTR _vertexBone$72034[ebp]
	and	ecx, 255				; 000000ffH
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR -228+[ebp]
	fadd	DWORD PTR [eax+4]
	fchs
	fmul	DWORD PTR _weight$72029[ebp]
	mov	eax, DWORD PTR _uv$[ebp]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _uv$[ebp]
	fstp	DWORD PTR [ecx+4]

; 321  : 			z += (DotProduct( pos, decalMat[2] ) + m_pdecaltransform[vertexBone][3][2]) * weight;

	push	2
	lea	ecx, DWORD PTR _decalMat$[ebp]
	call	??Amatrix3x3@@QAEPAMH@Z			; matrix3x3::operator[]
	push	eax
	lea	ecx, DWORD PTR $T74446[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	lea	edx, DWORD PTR $T74446[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	fstp	DWORD PTR -232+[ebp]
	add	esp, 8
	push	3
	mov	ecx, DWORD PTR _vertexBone$72034[ebp]
	and	ecx, 255				; 000000ffH
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR -232+[ebp]
	fadd	DWORD PTR [eax+8]
	fmul	DWORD PTR _weight$72029[ebp]
	fadd	DWORD PTR _z$[ebp]
	fstp	DWORD PTR _z$[ebp]

; 322  : 		}

	jmp	$L72032
$L72033:

; 324  : 
; 325  : 	return ( fabs( z ) < build.m_Radius );

	fld	DWORD PTR _z$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	eax, DWORD PTR _build$[ebp]
	fld	DWORD PTR [eax+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L74447
	mov	DWORD PTR -236+[ebp], 1
	jmp	SHORT $L74448
$L74447:
	mov	DWORD PTR -236+[ebp], 0
$L74448:
	mov	al, BYTE PTR -236+[ebp]

; 326  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TransformToDecalSpace@CStudioModelRenderer@@AAE_NAAUDecalBuildInfo_t@1@ABVVector@@PAUmstudioboneweight_t@@AAVVector2D@@@Z ENDP ; CStudioModelRenderer::TransformToDecalSpace
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@QAM@Z
_TEXT	SEGMENT
_rgfl$ = 8
_this$ = -4
??0Vector@@QAE@QAM@Z PROC NEAR				; Vector::Vector, COMDAT

; 138  : 	inline Vector(float rgfl[3])			{ x = rgfl[0]; y = rgfl[1]; z = rgfl[2];   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@QAM@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	??XVector2D@@QAEAAV0@M@Z			; Vector2D::operator*=
PUBLIC	??BVector2D@@QAEPAMXZ				; Vector2D::operator float *
PUBLIC	__real@4@3ffe8000000000000000
PUBLIC	?ProjectDecalOntoMesh@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z ; CStudioModelRenderer::ProjectDecalOntoMesh
PUBLIC	?IsFrontFacing@CStudioModelRenderer@@AAE_NABVVector@@PAUmstudioboneweight_t@@@Z ; CStudioModelRenderer::IsFrontFacing
;	COMDAT __real@4@3ffe8000000000000000
; File z:\xashxtsrc\client\render\r_studiodecal.cpp
CONST	SEGMENT
__real@4@3ffe8000000000000000 DD 03f000000r	; 0.5
CONST	ENDS
;	COMDAT ?ProjectDecalOntoMesh@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z
_TEXT	SEGMENT
_build$ = 8
_this$ = -4
_invRadius$ = -8
_pVertexInfo$ = -12
_j$ = -16
_vert$72050 = -20
_inValidArea$72052 = -24
?ProjectDecalOntoMesh@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z PROC NEAR ; CStudioModelRenderer::ProjectDecalOntoMesh, COMDAT

; 329  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 330  : 	float invRadius = (build.m_Radius != 0.0f) ? 1.0f / build.m_Radius : 1.0f;

	mov	eax, DWORD PTR _build$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L74455
	mov	ecx, DWORD PTR _build$[ebp]
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR [ecx+8]
	fstp	DWORD PTR -28+[ebp]
	jmp	SHORT $L74456
$L74455:
	mov	DWORD PTR -28+[ebp], 1065353216		; 3f800000H
$L74456:
	mov	edx, DWORD PTR -28+[ebp]
	mov	DWORD PTR _invRadius$[ebp], edx

; 331  : 
; 332  : 	DecalVertexInfo_t* pVertexInfo = build.m_pVertexInfo;

	mov	eax, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _pVertexInfo$[ebp], ecx

; 333  : 
; 334  : 	// For this to work, the plane and intercept must have been transformed
; 335  : 	// into pose space. Also, we'll not be bothering with flexes.
; 336  : 	for( int j = 0; j < build.m_pDecalMesh->numvertices; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L72047
$L72048:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L72047:
	mov	eax, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	$L72049

; 338  : 		DecalVertex_t *vert = &m_decalverts[m_arrayelems[build.m_pDecalMesh->firstvertex + j]];

	mov	eax, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+3772124]
	shl	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+225500]
	mov	DWORD PTR _vert$72050[ebp], eax

; 339  : 
; 340  : 		// No decal vertex yet...
; 341  : 		pVertexInfo[j].m_VertexIndex = 0xFFFF;

	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _pVertexInfo$[ebp]
	mov	WORD PTR [edx+ecx+8], 65535		; 0000ffffH

; 342  : 
; 343  : 		// We need to know if the normal is pointing in the negative direction
; 344  : 		// if so, blow off all triangles connected to that vertex.
; 345  : 		pVertexInfo[j].m_FrontFacing = IsFrontFacing( vert->m_Normal, &vert->m_BoneWeights );

	mov	eax, DWORD PTR _vert$72050[ebp]
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR _vert$72050[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsFrontFacing@CStudioModelRenderer@@AAE_NABVVector@@PAUmstudioboneweight_t@@@Z ; CStudioModelRenderer::IsFrontFacing
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR _pVertexInfo$[ebp]
	mov	BYTE PTR [ecx+edx+10], al

; 346  : 
; 347  : 		if( !pVertexInfo[j].m_FrontFacing )

	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pVertexInfo$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+edx+10]
	test	ecx, ecx
	jne	SHORT $L72051

; 348  : 			continue;

	jmp	$L72048
$L72051:

; 349  : 
; 350  : 		bool inValidArea = TransformToDecalSpace( build, vert->m_Position, &vert->m_BoneWeights, pVertexInfo[j].m_UV );

	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pVertexInfo$[ebp]
	add	eax, edx
	push	eax
	mov	ecx, DWORD PTR _vert$72050[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	edx, DWORD PTR _vert$72050[ebp]
	push	edx
	mov	eax, DWORD PTR _build$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TransformToDecalSpace@CStudioModelRenderer@@AAE_NAAUDecalBuildInfo_t@1@ABVVector@@PAUmstudioboneweight_t@@AAVVector2D@@@Z ; CStudioModelRenderer::TransformToDecalSpace
	mov	BYTE PTR _inValidArea$72052[ebp], al

; 351  : 		pVertexInfo[j].m_InValidArea = inValidArea;

	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _pVertexInfo$[ebp]
	mov	al, BYTE PTR _inValidArea$72052[ebp]
	mov	BYTE PTR [edx+ecx+11], al

; 352  : 
; 353  : 		pVertexInfo[j].m_UV *= invRadius * 0.5f;

	fld	DWORD PTR _invRadius$[ebp]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _pVertexInfo$[ebp]
	add	ecx, edx
	call	??XVector2D@@QAEAAV0@M@Z		; Vector2D::operator*=

; 354  : 		pVertexInfo[j].m_UV[0] += 0.5f;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pVertexInfo$[ebp]
	add	ecx, eax
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	mov	DWORD PTR -32+[ebp], eax
	mov	ecx, DWORD PTR -32+[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@3ffe8000000000000000
	mov	edx, DWORD PTR -32+[ebp]
	fstp	DWORD PTR [edx]

; 355  : 		pVertexInfo[j].m_UV[1] += 0.5f;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pVertexInfo$[ebp]
	add	ecx, eax
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	add	eax, 4
	mov	DWORD PTR -36+[ebp], eax
	mov	ecx, DWORD PTR -36+[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@3ffe8000000000000000
	mov	edx, DWORD PTR -36+[ebp]
	fstp	DWORD PTR [edx]

; 356  : 	}

	jmp	$L72048
$L72049:

; 357  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ProjectDecalOntoMesh@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z ENDP ; CStudioModelRenderer::ProjectDecalOntoMesh
_TEXT	ENDS
;	COMDAT ??XVector2D@@QAEAAV0@M@Z
_TEXT	SEGMENT
_s$ = 8
_this$ = -4
??XVector2D@@QAEAAV0@M@Z PROC NEAR			; Vector2D::operator*=, COMDAT

; 82   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 		x *= s; y *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 84   : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 85   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??XVector2D@@QAEAAV0@M@Z ENDP				; Vector2D::operator*=
_TEXT	ENDS
;	COMDAT ??BVector2D@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector2D@@QAEPAMXZ PROC NEAR				; Vector2D::operator float *, COMDAT

; 98   : 	operator float *()		 { return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector2D@@QAEPAMXZ ENDP				; Vector2D::operator float *
_TEXT	ENDS
PUBLIC	__real@4@3ffbcccccd0000000000
;	COMDAT __real@4@3ffbcccccd0000000000
; File z:\xashxtsrc\client\render\r_studiodecal.cpp
CONST	SEGMENT
__real@4@3ffbcccccd0000000000 DD 03dcccccdr	; 0.1
CONST	ENDS
;	COMDAT ?IsFrontFacing@CStudioModelRenderer@@AAE_NABVVector@@PAUmstudioboneweight_t@@@Z
_TEXT	SEGMENT
_norm$ = 8
_pboneweight$ = 12
_this$ = -4
_z$ = -8
_decalN$ = -20
_i$72002 = -24
?IsFrontFacing@CStudioModelRenderer@@AAE_NABVVector@@PAUmstudioboneweight_t@@@Z PROC NEAR ; CStudioModelRenderer::IsFrontFacing, COMDAT

; 236  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 	float z = 0.0f;

	mov	DWORD PTR _z$[ebp], 0

; 238  : 	Vector decalN;

	lea	ecx, DWORD PTR _decalN$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 239  : 
; 240  : 	// NOTE: This only works to rotate normals if there's no scale in the
; 241  : 	// pose to world transforms. If we ever add scale, we'll need to
; 242  : 	// multiply by the inverse transpose of the pose to decal
; 243  : 	if( pboneweight->weight[0] == 255 )

	mov	eax, DWORD PTR _pboneweight$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $L72000

; 245  : 		decalN.x = m_pdecaltransform[pboneweight->bone[0]][0][2];

	push	0
	mov	edx, DWORD PTR _pboneweight$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _decalN$[ebp], edx

; 246  : 		decalN.y = m_pdecaltransform[pboneweight->bone[0]][1][2];

	push	1
	mov	eax, DWORD PTR _pboneweight$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _decalN$[ebp+4], eax

; 247  : 		decalN.z = m_pdecaltransform[pboneweight->bone[0]][2][2];

	push	2
	mov	ecx, DWORD PTR _pboneweight$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _decalN$[ebp+8], ecx

; 248  : 
; 249  : 		z = DotProduct( norm, decalN );

	lea	edx, DWORD PTR _decalN$[ebp]
	push	edx
	mov	eax, DWORD PTR _norm$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _z$[ebp]

; 251  : 	else

	jmp	$L72005
$L72000:

; 253  : 		for( int i = 0; i < MAXSTUDIOBONEWEIGHTS; i++ )

	mov	DWORD PTR _i$72002[ebp], 0
	jmp	SHORT $L72003
$L72004:
	mov	ecx, DWORD PTR _i$72002[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$72002[ebp], ecx
$L72003:
	cmp	DWORD PTR _i$72002[ebp], 4
	jge	$L72005

; 255  : 			if( pboneweight->bone[i] == -1 )

	mov	edx, DWORD PTR _pboneweight$[ebp]
	add	edx, DWORD PTR _i$72002[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, -1
	jne	SHORT $L72006

; 256  : 				break;

	jmp	$L72005
$L72006:

; 257  : 			decalN.x = m_pdecaltransform[pboneweight->bone[i]][0][2];

	push	0
	mov	ecx, DWORD PTR _pboneweight$[ebp]
	add	ecx, DWORD PTR _i$72002[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _decalN$[ebp], ecx

; 258  : 			decalN.y = m_pdecaltransform[pboneweight->bone[i]][1][2];

	push	1
	mov	edx, DWORD PTR _pboneweight$[ebp]
	add	edx, DWORD PTR _i$72002[ebp]
	movsx	eax, BYTE PTR [edx+4]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _decalN$[ebp+4], edx

; 259  : 			decalN.z = m_pdecaltransform[pboneweight->bone[i]][2][2];

	push	2
	mov	eax, DWORD PTR _pboneweight$[ebp]
	add	eax, DWORD PTR _i$72002[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+219356]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _decalN$[ebp+8], eax

; 260  : 			z += DotProduct( norm, decalN ) * (pboneweight->weight[i] / 255.0f);

	lea	ecx, DWORD PTR _decalN$[ebp]
	push	ecx
	mov	edx, DWORD PTR _norm$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	mov	eax, DWORD PTR _pboneweight$[ebp]
	add	eax, DWORD PTR _i$72002[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax]
	mov	DWORD PTR -28+[ebp], ecx
	fild	DWORD PTR -28+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fmulp	ST(1), ST(0)
	fadd	DWORD PTR _z$[ebp]
	fstp	DWORD PTR _z$[ebp]

; 261  : 		}

	jmp	$L72004
$L72005:

; 263  : 
; 264  : 	return ( z >= 0.1f );

	fld	DWORD PTR _z$[ebp]
	fcomp	DWORD PTR __real@4@3ffbcccccd0000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L74465
	mov	DWORD PTR -32+[ebp], 1
	jmp	SHORT $L74466
$L74465:
	mov	DWORD PTR -32+[ebp], 0
$L74466:
	mov	al, BYTE PTR -32+[ebp]

; 265  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?IsFrontFacing@CStudioModelRenderer@@AAE_NABVVector@@PAUmstudioboneweight_t@@@Z ENDP ; CStudioModelRenderer::IsFrontFacing
_TEXT	ENDS
PUBLIC	?ComputeClipFlags@CStudioModelRenderer@@AAEHABVVector2D@@@Z ; CStudioModelRenderer::ComputeClipFlags
;	COMDAT ?ComputeClipFlags@CStudioModelRenderer@@AAEHABVVector2D@@@Z
_TEXT	SEGMENT
_uv$ = 8
_this$ = -4
_flags$ = -8
?ComputeClipFlags@CStudioModelRenderer@@AAEHABVVector2D@@@Z PROC NEAR ; CStudioModelRenderer::ComputeClipFlags, COMDAT

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 361  : 	// Otherwise we gotta do the test
; 362  : 	int flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 363  : 
; 364  : 	if( uv.x < 0.0f )

	mov	eax, DWORD PTR _uv$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72058

; 365  : 		SetBits( flags, DECAL_CLIP_MINUSU );

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 1
	mov	DWORD PTR _flags$[ebp], ecx

; 366  : 	else if( uv.x > 1.0f )

	jmp	SHORT $L72060
$L72058:
	mov	edx, DWORD PTR _uv$[ebp]
	fld	DWORD PTR [edx]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L72060

; 367  : 		SetBits( flags, DECAL_CLIP_PLUSU );

	mov	eax, DWORD PTR _flags$[ebp]
	or	al, 4
	mov	DWORD PTR _flags$[ebp], eax
$L72060:

; 368  : 
; 369  : 	if( uv.y < 0.0f )

	mov	ecx, DWORD PTR _uv$[ebp]
	fld	DWORD PTR [ecx+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72061

; 370  : 		SetBits( flags, DECAL_CLIP_MINUSV );

	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 2
	mov	DWORD PTR _flags$[ebp], edx

; 371  : 	else if( uv.y > 1.0f )

	jmp	SHORT $L72063
$L72061:
	mov	eax, DWORD PTR _uv$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L72063

; 372  : 		SetBits( flags, DECAL_CLIP_PLUSV );

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 8
	mov	DWORD PTR _flags$[ebp], ecx
$L72063:

; 373  : 
; 374  : 	return flags;

	mov	eax, DWORD PTR _flags$[ebp]

; 375  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ComputeClipFlags@CStudioModelRenderer@@AAEHABVVector2D@@@Z ENDP ; CStudioModelRenderer::ComputeClipFlags
_TEXT	ENDS
PUBLIC	?ConvertMeshVertexToDecalVertex@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HAAUDecalVertex_t@@@Z ; CStudioModelRenderer::ConvertMeshVertexToDecalVertex
;	COMDAT ?ConvertMeshVertexToDecalVertex@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HAAUDecalVertex_t@@@Z
_TEXT	SEGMENT
_build$ = 8
_meshIndex$ = 12
_decalVertex$ = 16
_this$ = -4
?ConvertMeshVertexToDecalVertex@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HAAUDecalVertex_t@@@Z PROC NEAR ; CStudioModelRenderer::ConvertMeshVertexToDecalVertex, COMDAT

; 381  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 382  : 	// Copy over the data;
; 383  : 	decalVertex = m_decalverts[m_arrayelems[build.m_pDecalMesh->firstvertex + meshIndex]];

	mov	eax, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _meshIndex$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+3772124]
	shl	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	lea	esi, DWORD PTR [edx+ecx+225500]
	mov	ecx, 16					; 00000010H
	mov	edi, DWORD PTR _decalVertex$[ebp]
	rep movsd

; 384  : 
; 385  : 	// get the texture coords from the decal planar projection
; 386  : 	decalVertex.m_TexCoord0 = build.m_pVertexInfo[meshIndex].m_UV;

	mov	eax, DWORD PTR _meshIndex$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _build$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [edx+eax+4]
	mov	eax, DWORD PTR _decalVertex$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], edx

; 387  : 
; 388  : 	// if meshIndex is valid this vertex was created from original
; 389  : 	decalVertex.m_MeshVertexIndex = meshIndex;

	mov	ecx, DWORD PTR _decalVertex$[ebp]
	mov	dx, WORD PTR _meshIndex$[ebp]
	mov	WORD PTR [ecx+60], dx

; 390  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ConvertMeshVertexToDecalVertex@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HAAUDecalVertex_t@@@Z ENDP ; CStudioModelRenderer::ConvertMeshVertexToDecalVertex
_TEXT	ENDS
PUBLIC	?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@H@Z ; CStudioModelRenderer::AddVertexToDecal
PUBLIC	?__LINE__Var@?1??AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@2@H@Z@4FA ; `CStudioModelRenderer::AddVertexToDecal'::`2'::__LINE__Var
PUBLIC	??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
PUBLIC	??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
PUBLIC	??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::operator[]
PUBLIC	?AddToTail@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::AddToTail
PUBLIC	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
PUBLIC	__real@8@bff583126e978d4fe000
;	COMDAT ?__LINE__Var@?1??AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@2@H@Z@4FA
; File z:\xashxtsrc\client\render\r_studiodecal.cpp
_DATA	SEGMENT
?__LINE__Var@?1??AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@2@H@Z@4FA DW 018cH ; `CStudioModelRenderer::AddVertexToDecal'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@
CONST	SEGMENT
??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@ DB 'z:\xashxtsrc\cl'
	DB	'ient\render\r_studiodecal.cpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@
CONST	SEGMENT
??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@8@bff583126e978d4fe000
CONST	SEGMENT
__real@8@bff583126e978d4fe000 DQ 0bf50624dd2f1a9fcr ; -0.001
CONST	ENDS
;	COMDAT ?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@H@Z
_TEXT	SEGMENT
_build$ = 8
_meshIndex$ = 12
_this$ = -4
_pVertexInfo$ = -8
_decalVertexList$72077 = -12
_v$72078 = -16
?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@H@Z PROC NEAR ; CStudioModelRenderer::AddVertexToDecal, COMDAT

; 396  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 397  : 	DecalVertexInfo_t* pVertexInfo = build.m_pVertexInfo;

	mov	eax, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _pVertexInfo$[ebp], ecx

; 398  : 
; 399  : 	// If we've never seen this vertex before, we need to add a new decal vert
; 400  : 	if( pVertexInfo[meshIndex].m_VertexIndex == 0xFFFF )

	mov	edx, DWORD PTR _meshIndex$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pVertexInfo$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+edx+8]
	cmp	ecx, 65535				; 0000ffffH
	jne	$L72087

; 402  : 		DecalVertexList_t& decalVertexList = build.m_pDecalMaterial->m_Vertices;

	mov	edx, DWORD PTR _build$[ebp]
	mov	eax, DWORD PTR [edx+60]
	add	eax, 36					; 00000024H
	mov	DWORD PTR _decalVertexList$72077[ebp], eax

; 403  : 		int v = decalVertexList.AddToTail();

	mov	ecx, DWORD PTR _decalVertexList$72077[ebp]
	call	?AddToTail@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::AddToTail
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _v$72078[ebp], eax

; 404  : 
; 405  : 		// Copy over the data;
; 406  : 		ConvertMeshVertexToDecalVertex( build, meshIndex, build.m_pDecalMaterial->m_Vertices[v] );

	mov	cx, WORD PTR _v$72078[ebp]
	push	ecx
	mov	edx, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	add	ecx, 36					; 00000024H
	call	??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::operator[]
	push	eax
	mov	eax, DWORD PTR _meshIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _build$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvertMeshVertexToDecalVertex@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HAAUDecalVertex_t@@@Z ; CStudioModelRenderer::ConvertMeshVertexToDecalVertex

; 407  : 
; 408  : #ifdef _DEBUG
; 409  : 		// Make sure clipped vertices are in the right range...
; 410  : 		if( build.m_UseClipVert )

	mov	edx, DWORD PTR _build$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+88]
	test	eax, eax
	je	$L72085

; 412  : 			ASSERT(( decalVertexList[v].m_TexCoord0[0] >= -1e-3 ) && ( decalVertexList[v].m_TexCoord0[0] - 1.0f < 1e-3 ));

	mov	cx, WORD PTR _v$72078[ebp]
	push	ecx
	mov	ecx, DWORD PTR _decalVertexList$72077[ebp]
	call	??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::operator[]
	mov	ecx, eax
	add	ecx, 24					; 00000018H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	fld	DWORD PTR [eax]
	fcomp	QWORD PTR __real@8@bff583126e978d4fe000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L72082
	mov	dx, WORD PTR _v$72078[ebp]
	push	edx
	mov	ecx, DWORD PTR _decalVertexList$72077[ebp]
	call	??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::operator[]
	mov	ecx, eax
	add	ecx, 24					; 00000018H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	fld	DWORD PTR [eax]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	fcomp	QWORD PTR __real@8@3ff583126e978d4fe000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L72081
$L72082:
	movsx	eax, WORD PTR ?__LINE__Var@?1??AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@2@H@Z@4FA ; `CStudioModelRenderer::AddVertexToDecal'::`2'::__LINE__Var
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET FLAT:??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72081:

; 413  : 			ASSERT(( decalVertexList[v].m_TexCoord0[1] >= -1e-3 ) && ( decalVertexList[v].m_TexCoord0[1] - 1.0f < 1e-3 ));

	mov	cx, WORD PTR _v$72078[ebp]
	push	ecx
	mov	ecx, DWORD PTR _decalVertexList$72077[ebp]
	call	??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::operator[]
	mov	ecx, eax
	add	ecx, 24					; 00000018H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	fld	DWORD PTR [eax+4]
	fcomp	QWORD PTR __real@8@bff583126e978d4fe000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L72086
	mov	dx, WORD PTR _v$72078[ebp]
	push	edx
	mov	ecx, DWORD PTR _decalVertexList$72077[ebp]
	call	??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::operator[]
	mov	ecx, eax
	add	ecx, 24					; 00000018H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	fcomp	QWORD PTR __real@8@3ff583126e978d4fe000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L72085
$L72086:
	movsx	eax, WORD PTR ?__LINE__Var@?1??AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@2@H@Z@4FA ; `CStudioModelRenderer::AddVertexToDecal'::`2'::__LINE__Var
	add	eax, 17					; 00000011H
	push	eax
	push	OFFSET FLAT:??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72085:

; 415  : #endif
; 416  : 
; 417  : 		// Store off the index of this vertex so we can reference it again
; 418  : 		pVertexInfo[meshIndex].m_VertexIndex = build.m_VertexCount;

	mov	ecx, DWORD PTR _meshIndex$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _pVertexInfo$[ebp]
	mov	eax, DWORD PTR _build$[ebp]
	mov	ax, WORD PTR [eax+82]
	mov	WORD PTR [edx+ecx+8], ax

; 419  : 		++build.m_VertexCount;

	mov	ecx, DWORD PTR _build$[ebp]
	mov	dx, WORD PTR [ecx+82]
	add	dx, 1
	mov	eax, DWORD PTR _build$[ebp]
	mov	WORD PTR [eax+82], dx

; 420  : 		if( build.m_FirstVertex == decalVertexList.InvalidIndex( ))

	mov	ecx, DWORD PTR _build$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+80]
	mov	esi, edx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L72087

; 421  : 			build.m_FirstVertex = v;

	mov	eax, DWORD PTR _build$[ebp]
	mov	cx, WORD PTR _v$72078[ebp]
	mov	WORD PTR [eax+80], cx
$L72087:

; 423  : 
; 424  : 	return pVertexInfo[meshIndex].m_VertexIndex;

	mov	edx, DWORD PTR _meshIndex$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pVertexInfo$[ebp]
	mov	ax, WORD PTR [eax+edx+8]

; 425  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@H@Z ENDP ; CStudioModelRenderer::AddVertexToDecal
_TEXT	ENDS
PUBLIC	?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@AAUDecalVertex_t@@@Z ; CStudioModelRenderer::AddVertexToDecal
PUBLIC	?__LINE__Var@?1??AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@2@AAUDecalVertex_t@@@Z@4FA ; `CStudioModelRenderer::AddVertexToDecal'::`2'::__LINE__Var
PUBLIC	?AddToTail@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGABUDecalVertex_t@@@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::AddToTail
PUBLIC	?Next@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Next
;	COMDAT ?__LINE__Var@?1??AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@2@AAUDecalVertex_t@@@Z@4FA
; File z:\xashxtsrc\client\render\r_studiodecal.cpp
_DATA	SEGMENT
?__LINE__Var@?1??AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@2@AAUDecalVertex_t@@@Z@4FA DW 01afH ; `CStudioModelRenderer::AddVertexToDecal'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@AAUDecalVertex_t@@@Z
_TEXT	SEGMENT
_build$ = 8
_vert$ = 12
_this$ = -4
_decalVertexList$ = -8
_vertexCount$ = -12
_i$ = -16
_temp$72100 = -28
_idx$ = -32
$T74479 = -44
$T74480 = -56
?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@AAUDecalVertex_t@@@Z PROC NEAR ; CStudioModelRenderer::AddVertexToDecal, COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	// This creates a unique vertex
; 433  : 	DecalVertexList_t& decalVertexList = build.m_pDecalMaterial->m_Vertices;

	mov	eax, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR _decalVertexList$[ebp], ecx

; 434  : 
; 435  : 	// Try to see if the clipped vertex already exists in our decal list...
; 436  : 	// Only search for matches with verts appearing in the current decal
; 437  : 	word vertexCount = 0;

	mov	WORD PTR _vertexCount$[ebp], 0

; 438  : 
; 439  : 	for( word i = build.m_FirstVertex; i != decalVertexList.InvalidIndex(); i = decalVertexList.Next(i), ++vertexCount )

	mov	edx, DWORD PTR _build$[ebp]
	mov	ax, WORD PTR [edx+80]
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $L72096
$L72097:
	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _decalVertexList$[ebp]
	call	?Next@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Next
	mov	WORD PTR _i$[ebp], ax
	mov	dx, WORD PTR _vertexCount$[ebp]
	add	dx, 1
	mov	WORD PTR _vertexCount$[ebp], dx
$L72096:
	mov	esi, DWORD PTR _i$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	$L72098

; 441  : 		// Only bother to check against clipped vertices
; 442  : 		if( decalVertexList[i].m_MeshVertexIndex != INVALID_HANDLE )

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decalVertexList$[ebp]
	call	??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::operator[]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+60]
	cmp	ecx, 65535				; 0000ffffH
	je	SHORT $L72099

; 443  : 			continue;

	jmp	SHORT $L72097
$L72099:

; 444  : 
; 445  : 		// They must have the same position, and normal
; 446  : 		// texcoord will fall right out if the positions match
; 447  : 		Vector temp = decalVertexList[i].m_Position - vert.m_Position;

	mov	edx, DWORD PTR _vert$[ebp]
	push	edx
	lea	eax, DWORD PTR $T74479[ebp]
	push	eax
	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _decalVertexList$[ebp]
	call	??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::operator[]
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _temp$72100[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 448  : 		if(( fabs( temp[0] ) > 1e-3 ) || (fabs( temp[1] ) > 1e-3 ) || ( fabs( temp[2] ) > 1e-3 ))

	lea	ecx, DWORD PTR _temp$72100[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3ff583126e978d4fe000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L72103
	lea	ecx, DWORD PTR _temp$72100[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3ff583126e978d4fe000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L72103
	lea	ecx, DWORD PTR _temp$72100[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3ff583126e978d4fe000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L72102
$L72103:

; 449  : 			continue;

	jmp	$L72097
$L72102:

; 450  : 
; 451  : 		temp = decalVertexList[i].m_Normal - vert.m_Normal;

	mov	edx, DWORD PTR _vert$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	lea	eax, DWORD PTR $T74480[ebp]
	push	eax
	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _decalVertexList$[ebp]
	call	??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::operator[]
	mov	ecx, eax
	add	ecx, 12					; 0000000cH
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _temp$72100[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _temp$72100[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _temp$72100[ebp+8], edx

; 452  : 		if(( fabs( temp[0] ) > 1e-3 ) || ( fabs( temp[1] ) > 1e-3 ) || ( fabs( temp[2] ) > 1e-3 ))

	lea	ecx, DWORD PTR _temp$72100[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3ff583126e978d4fe000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L72106
	lea	ecx, DWORD PTR _temp$72100[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3ff583126e978d4fe000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L72106
	lea	ecx, DWORD PTR _temp$72100[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3ff583126e978d4fe000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L72105
$L72106:

; 453  : 			continue;

	jmp	$L72097
$L72105:

; 454  : 
; 455  : 		return vertexCount;

	mov	ax, WORD PTR _vertexCount$[ebp]
	jmp	$L72092
$L72098:

; 457  : 
; 458  : 	// This path is the path taken by clipped vertices
; 459  : 	ASSERT( (vert.m_TexCoord0[0] >= -1e-3) && (vert.m_TexCoord0[0] - 1.0f < 1e-3) );

	mov	ecx, DWORD PTR _vert$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	fld	DWORD PTR [eax]
	fcomp	QWORD PTR __real@8@bff583126e978d4fe000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L72109
	mov	ecx, DWORD PTR _vert$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	fld	DWORD PTR [eax]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	fcomp	QWORD PTR __real@8@3ff583126e978d4fe000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L72108
$L72109:
	movsx	eax, WORD PTR ?__LINE__Var@?1??AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@2@AAUDecalVertex_t@@@Z@4FA ; `CStudioModelRenderer::AddVertexToDecal'::`2'::__LINE__Var
	add	eax, 28					; 0000001cH
	push	eax
	push	OFFSET FLAT:??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72108:

; 460  : 	ASSERT( (vert.m_TexCoord0[1] >= -1e-3) && (vert.m_TexCoord0[1] - 1.0f < 1e-3) );

	mov	ecx, DWORD PTR _vert$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	fld	DWORD PTR [eax+4]
	fcomp	QWORD PTR __real@8@bff583126e978d4fe000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L72111
	mov	ecx, DWORD PTR _vert$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	fcomp	QWORD PTR __real@8@3ff583126e978d4fe000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L72110
$L72111:
	movsx	ecx, WORD PTR ?__LINE__Var@?1??AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@2@AAUDecalVertex_t@@@Z@4FA ; `CStudioModelRenderer::AddVertexToDecal'::`2'::__LINE__Var
	add	ecx, 29					; 0000001dH
	push	ecx
	push	OFFSET FLAT:??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72110:

; 461  : 
; 462  : 	// Must create a new vertex...
; 463  : 	word idx = decalVertexList.AddToTail( vert );

	mov	edx, DWORD PTR _vert$[ebp]
	push	edx
	mov	ecx, DWORD PTR _decalVertexList$[ebp]
	call	?AddToTail@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGABUDecalVertex_t@@@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::AddToTail
	mov	WORD PTR _idx$[ebp], ax

; 464  : 	if( build.m_FirstVertex == decalVertexList.InvalidIndex( ))

	mov	eax, DWORD PTR _build$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+80]
	mov	esi, ecx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L72113

; 465  : 		build.m_FirstVertex = idx;

	mov	edx, DWORD PTR _build$[ebp]
	mov	ax, WORD PTR _idx$[ebp]
	mov	WORD PTR [edx+80], ax
$L72113:

; 466  : 
; 467  : 	ASSERT( vertexCount == build.m_VertexCount );

	mov	ecx, DWORD PTR _vertexCount$[ebp]
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _build$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+82]
	cmp	ecx, eax
	je	SHORT $L72114
	movsx	ecx, WORD PTR ?__LINE__Var@?1??AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@2@AAUDecalVertex_t@@@Z@4FA ; `CStudioModelRenderer::AddVertexToDecal'::`2'::__LINE__Var
	add	ecx, 36					; 00000024H
	push	ecx
	push	OFFSET FLAT:??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72114:

; 468  : 
; 469  : 	return build.m_VertexCount++;

	mov	edx, DWORD PTR _build$[ebp]
	mov	ax, WORD PTR [edx+82]
	mov	ecx, DWORD PTR _build$[ebp]
	mov	dx, WORD PTR [ecx+82]
	add	dx, 1
	mov	ecx, DWORD PTR _build$[ebp]
	mov	WORD PTR [ecx+82], dx
$L72092:

; 470  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@AAUDecalVertex_t@@@Z ENDP ; CStudioModelRenderer::AddVertexToDecal
_TEXT	ENDS
PUBLIC	?AddClippedDecalToTriangle@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@AAUDecalClipState_t@@@Z ; CStudioModelRenderer::AddClippedDecalToTriangle
PUBLIC	?AddToTail@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHABG@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::AddToTail
PUBLIC	?__LINE__Var@?1??AddClippedDecalToTriangle@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@2@AAUDecalClipState_t@@@Z@4FA ; `CStudioModelRenderer::AddClippedDecalToTriangle'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??AddClippedDecalToTriangle@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@2@AAUDecalClipState_t@@@Z@4FA
; File z:\xashxtsrc\client\render\r_studiodecal.cpp
_DATA	SEGMENT
?__LINE__Var@?1??AddClippedDecalToTriangle@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@2@AAUDecalClipState_t@@@Z@4FA DW 01dcH ; `CStudioModelRenderer::AddClippedDecalToTriangle'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?AddClippedDecalToTriangle@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@AAUDecalClipState_t@@@Z
_TEXT	SEGMENT
_build$ = 8
_clipState$ = 12
_this$ = -4
_i$ = -8
_indices$ = -24
_vertIdx$72127 = -28
?AddClippedDecalToTriangle@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@AAUDecalClipState_t@@@Z PROC NEAR ; CStudioModelRenderer::AddClippedDecalToTriangle, COMDAT

; 476  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 	ASSERT( clipState.m_VertCount <= 7 );

	mov	eax, DWORD PTR _clipState$[ebp]
	cmp	DWORD PTR [eax], 7
	jle	SHORT $L72121
	movsx	ecx, WORD PTR ?__LINE__Var@?1??AddClippedDecalToTriangle@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@2@AAUDecalClipState_t@@@Z@4FA ; `CStudioModelRenderer::AddClippedDecalToTriangle'::`2'::__LINE__Var
	add	ecx, 1
	push	ecx
	push	OFFSET FLAT:??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72121:

; 481  : 	word indices[7];
; 482  : 	for( i = 0; i < clipState.m_VertCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72124
$L72125:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L72124:
	mov	eax, DWORD PTR _clipState$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $L72126

; 484  : 		// First add the vertices
; 485  : 		int vertIdx = clipState.m_Indices[clipState.m_Pass][i];

	mov	edx, DWORD PTR _clipState$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+60]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _clipState$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _vertIdx$72127[ebp], ecx

; 486  : 
; 487  : 		if( vertIdx < 3 )

	cmp	DWORD PTR _vertIdx$72127[ebp], 3
	jge	SHORT $L72128

; 489  : 			indices[i] = AddVertexToDecal( build, clipState.m_ClipVerts[vertIdx].m_MeshVertexIndex );

	mov	edx, DWORD PTR _vertIdx$72127[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _clipState$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+edx+128]
	push	ecx
	mov	edx, DWORD PTR _build$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@H@Z ; CStudioModelRenderer::AddVertexToDecal
	mov	ecx, DWORD PTR _i$[ebp]
	mov	WORD PTR _indices$[ebp+ecx*2], ax

; 491  : 		else

	jmp	SHORT $L72129
$L72128:

; 493  : 			indices[i] = AddVertexToDecal( build, clipState.m_ClipVerts[vertIdx] );

	mov	edx, DWORD PTR _vertIdx$72127[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _clipState$[ebp]
	lea	ecx, DWORD PTR [eax+edx+68]
	push	ecx
	mov	edx, DWORD PTR _build$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@AAUDecalVertex_t@@@Z ; CStudioModelRenderer::AddVertexToDecal
	mov	ecx, DWORD PTR _i$[ebp]
	mov	WORD PTR _indices$[ebp+ecx*2], ax
$L72129:

; 495  : 	}

	jmp	$L72125
$L72126:

; 496  : 
; 497  : 	// Add a trifan worth of triangles
; 498  : 	for( i = 1; i < clipState.m_VertCount - 1; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L72130
$L72131:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L72130:
	mov	eax, DWORD PTR _clipState$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $L72132

; 500  : 		build.m_pDecalMaterial->m_Indices.AddToTail( indices[0] );

	lea	edx, DWORD PTR _indices$[ebp]
	push	edx
	mov	eax, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	add	ecx, 16					; 00000010H
	call	?AddToTail@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHABG@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::AddToTail

; 501  : 		build.m_pDecalMaterial->m_Indices.AddToTail( indices[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _indices$[ebp+ecx*2]
	push	edx
	mov	eax, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	add	ecx, 16					; 00000010H
	call	?AddToTail@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHABG@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::AddToTail

; 502  : 		build.m_pDecalMaterial->m_Indices.AddToTail( indices[i+1] );

	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _indices$[ebp+ecx*2+2]
	push	edx
	mov	eax, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	add	ecx, 16					; 00000010H
	call	?AddToTail@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHABG@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::AddToTail

; 503  : 	}

	jmp	SHORT $L72131
$L72132:

; 504  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddClippedDecalToTriangle@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@AAUDecalClipState_t@@@Z ENDP ; CStudioModelRenderer::AddClippedDecalToTriangle
_TEXT	ENDS
PUBLIC	??HVector2D@@QBE?AV0@ABV0@@Z			; Vector2D::operator+
PUBLIC	??GVector2D@@QBE?AV0@ABV0@@Z			; Vector2D::operator-
PUBLIC	??DVector2D@@QBE?AV0@M@Z			; Vector2D::operator*
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	?__LINE__Var@?1??IntersectPlane@CStudioModelRenderer@@AAEHAAUDecalClipState_t@@HHHM@Z@4FA ; `CStudioModelRenderer::IntersectPlane'::`2'::__LINE__Var
PUBLIC	?IntersectPlane@CStudioModelRenderer@@AAEHAAUDecalClipState_t@@HHHM@Z ; CStudioModelRenderer::IntersectPlane
EXTRN	__ftol:NEAR
;	COMDAT ?__LINE__Var@?1??IntersectPlane@CStudioModelRenderer@@AAEHAAUDecalClipState_t@@HHHM@Z@4FA
; File z:\xashxtsrc\client\render\r_studiodecal.cpp
_DATA	SEGMENT
?__LINE__Var@?1??IntersectPlane@CStudioModelRenderer@@AAEHAAUDecalClipState_t@@HHHM@Z@4FA DW 01feH ; `CStudioModelRenderer::IntersectPlane'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?IntersectPlane@CStudioModelRenderer@@AAEHAAUDecalClipState_t@@HHHM@Z
_TEXT	SEGMENT
_state$ = 8
_start$ = 12
_end$ = 16
_normalInd$ = 20
_val$ = 24
_this$ = -4
_startVert$ = -8
_endVert$ = -12
_dir$ = -20
_t$ = -24
_out$ = -28
_newVert$ = -32
_pbones$ = -36
_i$ = -40
_j$72172 = -44
$T74485 = -52
$T74486 = -64
$T74487 = -76
$T74488 = -88
$T74489 = -100
$T74490 = -112
$T74491 = -124
$T74492 = -136
$T74493 = -144
$T74494 = -152
$T74495 = -160
$T74496 = -168
$T74497 = -176
$T74498 = -184
?IntersectPlane@CStudioModelRenderer@@AAEHAAUDecalClipState_t@@HHHM@Z PROC NEAR ; CStudioModelRenderer::IntersectPlane, COMDAT

; 510  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 	DecalVertex_t& startVert = state.m_ClipVerts[start];

	mov	eax, DWORD PTR _start$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax+68]
	mov	DWORD PTR _startVert$[ebp], edx

; 512  : 	DecalVertex_t& endVert = state.m_ClipVerts[end];

	mov	eax, DWORD PTR _end$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax+68]
	mov	DWORD PTR _endVert$[ebp], edx

; 513  : 
; 514  : 	Vector2D dir = endVert.m_TexCoord0 - startVert.m_TexCoord0;

	mov	eax, DWORD PTR _startVert$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR $T74485[ebp]
	push	ecx
	mov	ecx, DWORD PTR _endVert$[ebp]
	add	ecx, 24					; 00000018H
	call	??GVector2D@@QBE?AV0@ABV0@@Z		; Vector2D::operator-
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _dir$[ebp], edx
	mov	DWORD PTR _dir$[ebp+4], eax

; 515  : 
; 516  : 	ASSERT( dir[normalInd] != 0.0f );

	lea	ecx, DWORD PTR _dir$[ebp]
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	mov	ecx, DWORD PTR _normalInd$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L72146
	movsx	edx, WORD PTR ?__LINE__Var@?1??IntersectPlane@CStudioModelRenderer@@AAEHAAUDecalClipState_t@@HHHM@Z@4FA ; `CStudioModelRenderer::IntersectPlane'::`2'::__LINE__Var
	add	edx, 6
	push	edx
	push	OFFSET FLAT:??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72146:

; 517  : 	float t = (val - startVert.m_TexCoord0[normalInd]) / dir[normalInd];

	mov	ecx, DWORD PTR _startVert$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	mov	ecx, DWORD PTR _normalInd$[ebp]
	fld	DWORD PTR _val$[ebp]
	fsub	DWORD PTR [eax+ecx*4]
	fstp	DWORD PTR -188+[ebp]
	lea	ecx, DWORD PTR _dir$[ebp]
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	mov	edx, DWORD PTR _normalInd$[ebp]
	fld	DWORD PTR -188+[ebp]
	fdiv	DWORD PTR [eax+edx*4]
	fstp	DWORD PTR _t$[ebp]

; 518  : 				 
; 519  : 	// Allocate a clipped vertex
; 520  : 	DecalVertex_t& out = state.m_ClipVerts[state.m_ClipVertCount];

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	shl	ecx, 6
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx+68]
	mov	DWORD PTR _out$[ebp], eax

; 521  : 	int newVert = state.m_ClipVertCount++;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _newVert$[ebp], edx
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	add	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+64], ecx

; 522  : 
; 523  : 	mstudiobone_t *pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+144]
	mov	DWORD PTR _pbones$[ebp], eax

; 524  : 
; 525  : 	// the clipped vertex has no analogue in the original mesh
; 526  : 	out.m_MeshVertexIndex = INVALID_HANDLE;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	WORD PTR [ecx+60], 65535		; 0000ffffH

; 527  : 
; 528  : 	// just select bone by interpolation factor
; 529  : 	if( t <= 0.5f ) out.m_BoneWeights = startVert.m_BoneWeights;

	fld	DWORD PTR _t$[ebp]
	fcomp	DWORD PTR __real@4@3ffe8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L72153
	mov	edx, DWORD PTR _startVert$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+52], eax
	mov	DWORD PTR [edx+56], ecx

; 530  : 	else out.m_BoneWeights = endVert.m_BoneWeights;

	jmp	SHORT $L72154
$L72153:
	mov	eax, DWORD PTR _endVert$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], edx
$L72154:

; 531  : 
; 532  : 	// Interpolate position
; 533  : 	out.m_Position = startVert.m_Position * (1.0f - t) + endVert.m_Position * t;

	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T74487[ebp]
	push	edx
	mov	ecx, DWORD PTR _endVert$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T74488[ebp]
	push	eax
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _t$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T74486[ebp]
	push	ecx
	mov	ecx, DWORD PTR _startVert$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 534  : 
; 535  : 	// Interpolate normal
; 536  : 	out.m_Normal = startVert.m_Normal * (1.0f - t) + endVert.m_Normal * t;

	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T74490[ebp]
	push	edx
	mov	ecx, DWORD PTR _endVert$[ebp]
	add	ecx, 12					; 0000000cH
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T74491[ebp]
	push	eax
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _t$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T74489[ebp]
	push	ecx
	mov	ecx, DWORD PTR _startVert$[ebp]
	add	ecx, 12					; 0000000cH
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 537  : 	out.m_Normal = out.m_Normal.Normalize();

	lea	ecx, DWORD PTR $T74492[ebp]
	push	ecx
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 538  : 
; 539  : 	// Interpolate texture coord
; 540  : 	out.m_TexCoord0 = startVert.m_TexCoord0 + (endVert.m_TexCoord0 - startVert.m_TexCoord0) * t;

	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T74494[ebp]
	push	edx
	mov	eax, DWORD PTR _startVert$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR $T74493[ebp]
	push	ecx
	mov	ecx, DWORD PTR _endVert$[ebp]
	add	ecx, 24					; 00000018H
	call	??GVector2D@@QBE?AV0@ABV0@@Z		; Vector2D::operator-
	mov	ecx, eax
	call	??DVector2D@@QBE?AV0@M@Z		; Vector2D::operator*
	push	eax
	lea	edx, DWORD PTR $T74495[ebp]
	push	edx
	mov	ecx, DWORD PTR _startVert$[ebp]
	add	ecx, 24					; 00000018H
	call	??HVector2D@@QBE?AV0@ABV0@@Z		; Vector2D::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], edx

; 541  : 	out.m_TexCoord1 = startVert.m_TexCoord1 + (endVert.m_TexCoord1 - startVert.m_TexCoord1) * t;

	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T74497[ebp]
	push	edx
	mov	eax, DWORD PTR _startVert$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	lea	ecx, DWORD PTR $T74496[ebp]
	push	ecx
	mov	ecx, DWORD PTR _endVert$[ebp]
	add	ecx, 32					; 00000020H
	call	??GVector2D@@QBE?AV0@ABV0@@Z		; Vector2D::operator-
	mov	ecx, eax
	call	??DVector2D@@QBE?AV0@M@Z		; Vector2D::operator*
	push	eax
	lea	edx, DWORD PTR $T74498[ebp]
	push	edx
	mov	ecx, DWORD PTR _startVert$[ebp]
	add	ecx, 32					; 00000020H
	call	??HVector2D@@QBE?AV0@ABV0@@Z		; Vector2D::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], edx

; 542  : 
; 543  : 	// Interpolate lighting
; 544  : 	for( int i = 0; i < LM_STYLES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72169
$L72170:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L72169:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$L72171

; 546  : 		for( int j = 0; j < 3; j++ )

	mov	DWORD PTR _j$72172[ebp], 0
	jmp	SHORT $L72173
$L72174:
	mov	edx, DWORD PTR _j$72172[ebp]
	add	edx, 1
	mov	DWORD PTR _j$72172[ebp], edx
$L72173:
	cmp	DWORD PTR _j$72172[ebp], 3
	jge	SHORT $L72175

; 547  : 			out.m_Light[i][j] = startVert.m_Light[i][j] + (endVert.m_Light[i][j] - startVert.m_Light[i][j]) * t;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 3
	mov	ecx, DWORD PTR _j$72172[ebp]
	add	ecx, eax
	mov	edx, DWORD PTR _startVert$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+ecx+40]
	mov	DWORD PTR -192+[ebp], eax
	fild	DWORD PTR -192+[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 3
	mov	edx, DWORD PTR _j$72172[ebp]
	add	edx, ecx
	mov	eax, DWORD PTR _endVert$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+edx+40]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 3
	mov	eax, DWORD PTR _j$72172[ebp]
	add	eax, edx
	mov	edx, DWORD PTR _startVert$[ebp]
	xor	ebx, ebx
	mov	bl, BYTE PTR [edx+eax+40]
	sub	ecx, ebx
	mov	DWORD PTR -196+[ebp], ecx
	fild	DWORD PTR -196+[ebp]
	fmul	DWORD PTR _t$[ebp]
	faddp	ST(1), ST(0)
	call	__ftol
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 3
	mov	edx, DWORD PTR _j$72172[ebp]
	add	edx, ecx
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx+40], al
	jmp	$L72174
$L72175:

; 548  : 	}

	jmp	$L72170
$L72171:

; 549  : 
; 550  : 	// Compute the clip flags baby...
; 551  : 	state.m_ClipFlags[newVert] = ComputeClipFlags( out.m_TexCoord0 );

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeClipFlags@CStudioModelRenderer@@AAEHABVVector2D@@@Z ; CStudioModelRenderer::ComputeClipFlags
	mov	ecx, DWORD PTR _newVert$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+ecx*4+1092], eax

; 552  : 
; 553  : 	return newVert;

	mov	eax, DWORD PTR _newVert$[ebp]

; 554  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?IntersectPlane@CStudioModelRenderer@@AAEHAAUDecalClipState_t@@HHHM@Z ENDP ; CStudioModelRenderer::IntersectPlane
_TEXT	ENDS
PUBLIC	??0Vector2D@@QAE@MM@Z				; Vector2D::Vector2D
;	COMDAT ??HVector2D@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T74502 = -12
??HVector2D@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector2D::operator+, COMDAT

; 61   : 	inline Vector2D operator+(const Vector2D& v) const { return Vector2D(x+v.x, y+v.y); }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx]
	fadd	DWORD PTR [eax]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T74502[ebp]
	call	??0Vector2D@@QAE@MM@Z			; Vector2D::Vector2D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector2D@@QBE?AV0@ABV0@@Z ENDP			; Vector2D::operator+
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_this$ = -4
??0Vector2D@@QAE@MM@Z PROC NEAR				; Vector2D::Vector2D, COMDAT

; 58   : 	inline Vector2D(float X, float Y) { x = X; y = Y; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0Vector2D@@QAE@MM@Z ENDP				; Vector2D::Vector2D
_TEXT	ENDS
;	COMDAT ??GVector2D@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T74507 = -12
??GVector2D@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector2D::operator-, COMDAT

; 62   : 	inline Vector2D operator-(const Vector2D& v) const { return Vector2D(x-v.x, y-v.y); }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [eax]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T74507[ebp]
	call	??0Vector2D@@QAE@MM@Z			; Vector2D::Vector2D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector2D@@QBE?AV0@ABV0@@Z ENDP			; Vector2D::operator-
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T74510 = -12
??DVector2D@@QBE?AV0@M@Z PROC NEAR			; Vector2D::operator*, COMDAT

; 63   : 	inline Vector2D operator*(float fl) const { return Vector2D(x*fl, y*fl); }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T74510[ebp]
	call	??0Vector2D@@QAE@MM@Z			; Vector2D::Vector2D
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector2D@@QBE?AV0@M@Z ENDP				; Vector2D::operator*
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T74513 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T74513[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_flLen$ = -8
$T74516 = -20
?Normalize@Vector@@QBE?AV1@XZ PROC NEAR			; Vector::Normalize, COMDAT

; 232  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 234  : 
; 235  : 		if( flLen )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L54765

; 237  : 			flLen = 1.0f / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 238  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T74516[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L54763
$L54765:

; 240  : 
; 241  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L54763:

; 242  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
PUBLIC	?ClipTriangleAgainstPlane@CStudioModelRenderer@@AAEXAAUDecalClipState_t@@HHM@Z ; CStudioModelRenderer::ClipTriangleAgainstPlane
;	COMDAT ?ClipTriangleAgainstPlane@CStudioModelRenderer@@AAEXAAUDecalClipState_t@@HHM@Z
_TEXT	SEGMENT
_state$ = 8
_normalInd$ = 12
_flag$ = 16
_val$ = 20
_this$ = -4
_outVertCount$ = -8
_start$ = -12
_startInside$ = -16
_i$ = -20
_end$72190 = -24
_endInside$72191 = -28
_clipVert$72194 = -32
_clipVert$72197 = -36
?ClipTriangleAgainstPlane@CStudioModelRenderer@@AAEXAAUDecalClipState_t@@HHM@Z PROC NEAR ; CStudioModelRenderer::ClipTriangleAgainstPlane, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	// Ye Olde Sutherland-Hodgman clipping algorithm
; 562  : 	int outVertCount = 0;

	mov	DWORD PTR _outVertCount$[ebp], 0

; 563  : 	int start = state.m_Indices[state.m_Pass][state.m_VertCount - 1];

	mov	eax, DWORD PTR _state$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+60]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+edx*4-4]
	mov	DWORD PTR _start$[ebp], eax

; 564  : 	bool startInside = (state.m_ClipFlags[start] & flag) == 0;

	mov	ecx, DWORD PTR _start$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1092]
	and	eax, DWORD PTR _flag$[ebp]
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	BYTE PTR _startInside$[ebp], al

; 565  : 	for( int i = 0; i < state.m_VertCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72187
$L72188:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L72187:
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	$L72189

; 567  : 		int end = state.m_Indices[state.m_Pass][i];

	mov	ecx, DWORD PTR _state$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+60]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _end$72190[ebp], eax

; 568  : 
; 569  : 		bool endInside = (state.m_ClipFlags[end] & flag) == 0;

	mov	ecx, DWORD PTR _end$72190[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1092]
	and	eax, DWORD PTR _flag$[ebp]
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	BYTE PTR _endInside$72191[ebp], al

; 570  : 
; 571  : 		if( endInside )

	mov	ecx, DWORD PTR _endInside$72191[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	$L72192

; 573  : 			if( !startInside )

	mov	edx, DWORD PTR _startInside$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L72193

; 575  : 				int clipVert = IntersectPlane( state, start, end, normalInd, val );

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _normalInd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$72190[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IntersectPlane@CStudioModelRenderer@@AAEHAAUDecalClipState_t@@HHHM@Z ; CStudioModelRenderer::IntersectPlane
	mov	DWORD PTR _clipVert$72194[ebp], eax

; 576  : 				state.m_Indices[!state.m_Pass][outVertCount++] = clipVert;

	mov	edx, DWORD PTR _state$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+60]
	neg	eax
	sbb	eax, eax
	inc	eax
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	mov	eax, DWORD PTR _outVertCount$[ebp]
	mov	ecx, DWORD PTR _clipVert$72194[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	mov	edx, DWORD PTR _outVertCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _outVertCount$[ebp], edx
$L72193:

; 578  : 			state.m_Indices[!state.m_Pass][outVertCount++] = end;

	mov	eax, DWORD PTR _state$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+60]
	neg	ecx
	sbb	ecx, ecx
	inc	ecx
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	mov	ecx, DWORD PTR _outVertCount$[ebp]
	mov	edx, DWORD PTR _end$72190[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _outVertCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _outVertCount$[ebp], eax

; 580  : 		else

	jmp	SHORT $L72196
$L72192:

; 582  : 			if( startInside )

	mov	ecx, DWORD PTR _startInside$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L72196

; 584  : 				int clipVert = IntersectPlane( state, start, end, normalInd, val );

	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	mov	eax, DWORD PTR _normalInd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$72190[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IntersectPlane@CStudioModelRenderer@@AAEHAAUDecalClipState_t@@HHHM@Z ; CStudioModelRenderer::IntersectPlane
	mov	DWORD PTR _clipVert$72197[ebp], eax

; 585  : 				state.m_Indices[!state.m_Pass][outVertCount++] = clipVert;

	mov	ecx, DWORD PTR _state$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+60]
	neg	edx
	sbb	edx, edx
	inc	edx
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	mov	edx, DWORD PTR _outVertCount$[ebp]
	mov	eax, DWORD PTR _clipVert$72197[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR _outVertCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outVertCount$[ebp], ecx
$L72196:

; 588  : 
; 589  : 		start = end;

	mov	edx, DWORD PTR _end$72190[ebp]
	mov	DWORD PTR _start$[ebp], edx

; 590  : 		startInside = endInside;

	mov	al, BYTE PTR _endInside$72191[ebp]
	mov	BYTE PTR _startInside$[ebp], al

; 591  : 	}

	jmp	$L72188
$L72189:

; 592  : 
; 593  : 	state.m_Pass = !state.m_Pass;

	mov	ecx, DWORD PTR _state$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+60]
	neg	edx
	sbb	edx, edx
	inc	edx
	mov	eax, DWORD PTR _state$[ebp]
	mov	BYTE PTR [eax+60], dl

; 594  : 	state.m_VertCount = outVertCount;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR _outVertCount$[ebp]
	mov	DWORD PTR [ecx], edx

; 595  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ClipTriangleAgainstPlane@CStudioModelRenderer@@AAEXAAUDecalClipState_t@@HHM@Z ENDP ; CStudioModelRenderer::ClipTriangleAgainstPlane
_TEXT	ENDS
PUBLIC	??0DecalClipState_t@@QAE@XZ			; DecalClipState_t::DecalClipState_t
PUBLIC	?ClipDecal@CStudioModelRenderer@@AAE_NAAUDecalBuildInfo_t@1@HHHPAH@Z ; CStudioModelRenderer::ClipDecal
;	COMDAT ?ClipDecal@CStudioModelRenderer@@AAE_NAAUDecalBuildInfo_t@1@HHHPAH@Z
_TEXT	SEGMENT
_build$ = 8
_i1$ = 12
_i2$ = 16
_i3$ = 20
_pClipFlags$ = 24
_this$ = -4
_clipState$ = -1160
_i$ = -1164
?ClipDecal@CStudioModelRenderer@@AAE_NAAUDecalBuildInfo_t@1@HHHPAH@Z PROC NEAR ; CStudioModelRenderer::ClipDecal, COMDAT

; 601  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1228				; 000004ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 602  : 	DecalClipState_t clipState;

	lea	ecx, DWORD PTR _clipState$[ebp]
	call	??0DecalClipState_t@@QAE@XZ		; DecalClipState_t::DecalClipState_t

; 603  : 	clipState.m_VertCount = 3;

	mov	DWORD PTR _clipState$[ebp], 3

; 604  : 
; 605  : 	ConvertMeshVertexToDecalVertex( build, i1, clipState.m_ClipVerts[0] );

	lea	eax, DWORD PTR _clipState$[ebp+68]
	push	eax
	mov	ecx, DWORD PTR _i1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _build$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvertMeshVertexToDecalVertex@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HAAUDecalVertex_t@@@Z ; CStudioModelRenderer::ConvertMeshVertexToDecalVertex

; 606  : 	ConvertMeshVertexToDecalVertex( build, i2, clipState.m_ClipVerts[1] );

	lea	eax, DWORD PTR _clipState$[ebp+132]
	push	eax
	mov	ecx, DWORD PTR _i2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _build$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvertMeshVertexToDecalVertex@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HAAUDecalVertex_t@@@Z ; CStudioModelRenderer::ConvertMeshVertexToDecalVertex

; 607  : 	ConvertMeshVertexToDecalVertex( build, i3, clipState.m_ClipVerts[2] );

	lea	eax, DWORD PTR _clipState$[ebp+196]
	push	eax
	mov	ecx, DWORD PTR _i3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _build$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvertMeshVertexToDecalVertex@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HAAUDecalVertex_t@@@Z ; CStudioModelRenderer::ConvertMeshVertexToDecalVertex

; 608  : 
; 609  : 	clipState.m_ClipVertCount = 3;

	mov	DWORD PTR _clipState$[ebp+64], 3

; 610  : 
; 611  : 	for( int i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72208
$L72209:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L72208:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $L72210

; 613  : 		clipState.m_ClipFlags[i] = pClipFlags[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pClipFlags$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _clipState$[ebp+ecx*4+1092], edx

; 614  : 		clipState.m_Indices[0][i] = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _clipState$[ebp+eax*4+4], ecx

; 615  : 	}

	jmp	SHORT $L72209
$L72210:

; 616  : 
; 617  : 	clipState.m_Pass = 0;

	mov	BYTE PTR _clipState$[ebp+60], 0

; 618  : 
; 619  : 	// Clip against each plane
; 620  : 	ClipTriangleAgainstPlane( clipState, 0, DECAL_CLIP_MINUSU, 0.0f );

	push	0
	push	1
	push	0
	lea	edx, DWORD PTR _clipState$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipTriangleAgainstPlane@CStudioModelRenderer@@AAEXAAUDecalClipState_t@@HHM@Z ; CStudioModelRenderer::ClipTriangleAgainstPlane

; 621  : 	if( clipState.m_VertCount < 3 )

	cmp	DWORD PTR _clipState$[ebp], 3
	jge	SHORT $L72211

; 622  : 		return false;

	xor	al, al
	jmp	$L72205
$L72211:

; 623  : 
; 624  : 	ClipTriangleAgainstPlane( clipState, 0, DECAL_CLIP_PLUSU, 1.0f );

	push	1065353216				; 3f800000H
	push	4
	push	0
	lea	eax, DWORD PTR _clipState$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipTriangleAgainstPlane@CStudioModelRenderer@@AAEXAAUDecalClipState_t@@HHM@Z ; CStudioModelRenderer::ClipTriangleAgainstPlane

; 625  : 	if( clipState.m_VertCount < 3 )

	cmp	DWORD PTR _clipState$[ebp], 3
	jge	SHORT $L72212

; 626  : 		return false;

	xor	al, al
	jmp	SHORT $L72205
$L72212:

; 627  : 
; 628  : 	ClipTriangleAgainstPlane( clipState, 1, DECAL_CLIP_MINUSV, 0.0f );

	push	0
	push	2
	push	1
	lea	ecx, DWORD PTR _clipState$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipTriangleAgainstPlane@CStudioModelRenderer@@AAEXAAUDecalClipState_t@@HHM@Z ; CStudioModelRenderer::ClipTriangleAgainstPlane

; 629  : 	if( clipState.m_VertCount < 3 )

	cmp	DWORD PTR _clipState$[ebp], 3
	jge	SHORT $L72213

; 630  : 		return false;

	xor	al, al
	jmp	SHORT $L72205
$L72213:

; 631  : 
; 632  : 	ClipTriangleAgainstPlane( clipState, 1, DECAL_CLIP_PLUSV, 1.0f );

	push	1065353216				; 3f800000H
	push	8
	push	1
	lea	edx, DWORD PTR _clipState$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipTriangleAgainstPlane@CStudioModelRenderer@@AAEXAAUDecalClipState_t@@HHM@Z ; CStudioModelRenderer::ClipTriangleAgainstPlane

; 633  : 	if( clipState.m_VertCount < 3 )

	cmp	DWORD PTR _clipState$[ebp], 3
	jge	SHORT $L72214

; 634  : 		return false;

	xor	al, al
	jmp	SHORT $L72205
$L72214:

; 635  : 
; 636  : 	// Only add the clipped decal to the triangle if it's one bone
; 637  : 	// otherwise just return if it was clipped
; 638  : 	if( build.m_UseClipVert )

	mov	eax, DWORD PTR _build$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+88]
	test	ecx, ecx
	je	SHORT $L72215

; 640  : 		AddClippedDecalToTriangle( build, clipState );

	lea	edx, DWORD PTR _clipState$[ebp]
	push	edx
	mov	eax, DWORD PTR _build$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddClippedDecalToTriangle@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@AAUDecalClipState_t@@@Z ; CStudioModelRenderer::AddClippedDecalToTriangle
$L72215:

; 642  : 
; 643  : 	return true;

	mov	al, 1
$L72205:

; 644  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?ClipDecal@CStudioModelRenderer@@AAE_NAAUDecalBuildInfo_t@1@HHHPAH@Z ENDP ; CStudioModelRenderer::ClipDecal
_TEXT	ENDS
PUBLIC	??0DecalVertex_t@@QAE@XZ			; DecalVertex_t::DecalVertex_t
;	COMDAT ??0DecalClipState_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0DecalClipState_t@@QAE@XZ PROC NEAR			; DecalClipState_t::DecalClipState_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0DecalVertex_t@@QAE@XZ	; DecalVertex_t::DecalVertex_t
	push	16					; 00000010H
	push	64					; 00000040H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0DecalClipState_t@@QAE@XZ ENDP			; DecalClipState_t::DecalClipState_t
_TEXT	ENDS
PUBLIC	??0Vector2D@@QAE@XZ				; Vector2D::Vector2D
;	COMDAT ??0DecalVertex_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0DecalVertex_t@@QAE@XZ PROC NEAR			; DecalVertex_t::DecalVertex_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0DecalVertex_t@@QAE@XZ ENDP				; DecalVertex_t::DecalVertex_t
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector2D@@QAE@XZ PROC NEAR				; Vector2D::Vector2D, COMDAT

; 57   : 	inline Vector2D(void) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector2D@@QAE@XZ ENDP				; Vector2D::Vector2D
_TEXT	ENDS
PUBLIC	?AddTriangleToDecal@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HHH@Z ; CStudioModelRenderer::AddTriangleToDecal
;	COMDAT ?AddTriangleToDecal@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HHH@Z
_TEXT	SEGMENT
_build$ = 8
_i1$ = 12
_i2$ = 16
_i3$ = 20
_this$ = -4
_pVertexInfo$ = -8
_clipFlags$ = -20
_doClip$ = -24
_validTri$72239 = -28
$T74529 = -32
$T74530 = -36
$T74531 = -40
?AddTriangleToDecal@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HHH@Z PROC NEAR ; CStudioModelRenderer::AddTriangleToDecal, COMDAT

; 650  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 	DecalVertexInfo_t* pVertexInfo = build.m_pVertexInfo;

	mov	eax, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _pVertexInfo$[ebp], ecx

; 652  : 
; 653  : 	// All must be front-facing for a decal to be added
; 654  : 	if(( !pVertexInfo[i1].m_FrontFacing ) || ( !pVertexInfo[i2].m_FrontFacing ) || ( !pVertexInfo[i3].m_FrontFacing ))

	mov	edx, DWORD PTR _i1$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pVertexInfo$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+edx+10]
	test	ecx, ecx
	je	SHORT $L72230
	mov	edx, DWORD PTR _i2$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pVertexInfo$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+edx+10]
	test	ecx, ecx
	je	SHORT $L72230
	mov	edx, DWORD PTR _i3$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pVertexInfo$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+edx+10]
	test	ecx, ecx
	jne	SHORT $L72229
$L72230:

; 656  : 		return;

	jmp	$L72227
$L72229:

; 658  : 
; 659  : 	// This is used to prevent poke through; if the points are too far away
; 660  : 	// from the contact point, then don't add the decal
; 661  : 	if(( !pVertexInfo[i1].m_InValidArea ) && ( !pVertexInfo[i2].m_InValidArea ) && ( !pVertexInfo[i3].m_InValidArea ))

	mov	edx, DWORD PTR _i1$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pVertexInfo$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+edx+11]
	test	ecx, ecx
	jne	SHORT $L72231
	mov	edx, DWORD PTR _i2$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pVertexInfo$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+edx+11]
	test	ecx, ecx
	jne	SHORT $L72231
	mov	edx, DWORD PTR _i3$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pVertexInfo$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+edx+11]
	test	ecx, ecx
	jne	SHORT $L72231

; 663  : 		return;

	jmp	$L72227
$L72231:

; 668  : 
; 669  : 	clipFlags[0] = ComputeClipFlags( pVertexInfo[i1].m_UV );

	mov	edx, DWORD PTR _i1$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pVertexInfo$[ebp]
	add	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeClipFlags@CStudioModelRenderer@@AAEHABVVector2D@@@Z ; CStudioModelRenderer::ComputeClipFlags
	mov	DWORD PTR _clipFlags$[ebp], eax

; 670  : 	clipFlags[1] = ComputeClipFlags( pVertexInfo[i2].m_UV );

	mov	ecx, DWORD PTR _i2$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _pVertexInfo$[ebp]
	add	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeClipFlags@CStudioModelRenderer@@AAEHABVVector2D@@@Z ; CStudioModelRenderer::ComputeClipFlags
	mov	DWORD PTR _clipFlags$[ebp+4], eax

; 671  : 	clipFlags[2] = ComputeClipFlags( pVertexInfo[i3].m_UV );

	mov	eax, DWORD PTR _i3$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pVertexInfo$[ebp]
	add	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeClipFlags@CStudioModelRenderer@@AAEHABVVector2D@@@Z ; CStudioModelRenderer::ComputeClipFlags
	mov	DWORD PTR _clipFlags$[ebp+8], eax

; 672  : 
; 673  : 	// Cull... The result is non-zero if they're all outside the same plane
; 674  : 	if(( clipFlags[0] & ( clipFlags[1] & clipFlags[2] )) != 0 )

	mov	edx, DWORD PTR _clipFlags$[ebp+4]
	and	edx, DWORD PTR _clipFlags$[ebp+8]
	mov	eax, DWORD PTR _clipFlags$[ebp]
	and	eax, edx
	test	eax, eax
	je	SHORT $L72233

; 675  : 		return;

	jmp	$L72227
$L72233:

; 676  : 
; 677  : 	bool doClip = true;

	mov	BYTE PTR _doClip$[ebp], 1

; 678  : 	
; 679  : 	// Trivial accept for skinned polys... if even one vert is inside
; 680  : 	// the draw region, accept
; 681  : 	if(( !build.m_UseClipVert ) && ( !clipFlags[0] || !clipFlags[1] || !clipFlags[2] ))

	mov	ecx, DWORD PTR _build$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+88]
	test	edx, edx
	jne	SHORT $L72235
	cmp	DWORD PTR _clipFlags$[ebp], 0
	je	SHORT $L72236
	cmp	DWORD PTR _clipFlags$[ebp+4], 0
	je	SHORT $L72236
	cmp	DWORD PTR _clipFlags$[ebp+8], 0
	jne	SHORT $L72235
$L72236:

; 682  : 		doClip = false;

	mov	BYTE PTR _doClip$[ebp], 0
$L72235:

; 683  : 
; 684  : 	// Trivial accept... no clip flags set means all in
; 685  : 	// Don't clip if we have more than one bone... we'll need to do skinning
; 686  : 	// and we can't clip the bone indices
; 687  : 	// We *do* want to clip in the one bone case though; useful for large
; 688  : 	// static props.
; 689  : 	if( doClip && ( clipFlags[0] || clipFlags[1] || clipFlags[2] ))

	mov	eax, DWORD PTR _doClip$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L72240
	cmp	DWORD PTR _clipFlags$[ebp], 0
	jne	SHORT $L72238
	cmp	DWORD PTR _clipFlags$[ebp+4], 0
	jne	SHORT $L72238
	cmp	DWORD PTR _clipFlags$[ebp+8], 0
	je	SHORT $L72240
$L72238:

; 691  : 		bool validTri = ClipDecal( build, i1, i2, i3, clipFlags );

	lea	ecx, DWORD PTR _clipFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i3$[ebp]
	push	edx
	mov	eax, DWORD PTR _i2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _build$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipDecal@CStudioModelRenderer@@AAE_NAAUDecalBuildInfo_t@1@HHHPAH@Z ; CStudioModelRenderer::ClipDecal
	mov	BYTE PTR _validTri$72239[ebp], al

; 692  : 
; 693  : 		// Don't add the triangle if we culled the triangle or if 
; 694  : 		// we had one or less bones
; 695  : 		if( build.m_UseClipVert || ( !validTri ))

	mov	eax, DWORD PTR _build$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+88]
	test	ecx, ecx
	jne	SHORT $L72241
	mov	edx, DWORD PTR _validTri$72239[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L72240
$L72241:

; 696  : 			return;

	jmp	SHORT $L72227
$L72240:

; 698  : 
; 699  : 	// Add the vertices to the decal since there was no clipping
; 700  : 	build.m_pDecalMaterial->m_Indices.AddToTail( AddVertexToDecal( build, i1 ));

	mov	eax, DWORD PTR _i1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _build$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@H@Z ; CStudioModelRenderer::AddVertexToDecal
	mov	WORD PTR $T74529[ebp], ax
	lea	edx, DWORD PTR $T74529[ebp]
	push	edx
	mov	eax, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	add	ecx, 16					; 00000010H
	call	?AddToTail@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHABG@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::AddToTail

; 701  : 	build.m_pDecalMaterial->m_Indices.AddToTail( AddVertexToDecal( build, i2 ));

	mov	ecx, DWORD PTR _i2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _build$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@H@Z ; CStudioModelRenderer::AddVertexToDecal
	mov	WORD PTR $T74530[ebp], ax
	lea	eax, DWORD PTR $T74530[ebp]
	push	eax
	mov	ecx, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	add	ecx, 16					; 00000010H
	call	?AddToTail@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHABG@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::AddToTail

; 702  : 	build.m_pDecalMaterial->m_Indices.AddToTail( AddVertexToDecal( build, i3 ));

	mov	edx, DWORD PTR _i3$[ebp]
	push	edx
	mov	eax, DWORD PTR _build$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddVertexToDecal@CStudioModelRenderer@@AAEGAAUDecalBuildInfo_t@1@H@Z ; CStudioModelRenderer::AddVertexToDecal
	mov	WORD PTR $T74531[ebp], ax
	lea	ecx, DWORD PTR $T74531[ebp]
	push	ecx
	mov	edx, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	add	ecx, 16					; 00000010H
	call	?AddToTail@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHABG@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::AddToTail
$L72227:

; 703  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddTriangleToDecal@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HHH@Z ENDP ; CStudioModelRenderer::AddTriangleToDecal
_TEXT	ENDS
PUBLIC	?AddDecalToMesh@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z ; CStudioModelRenderer::AddDecalToMesh
EXTRN	__alloca_probe:NEAR
;	COMDAT ?AddDecalToMesh@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z
_TEXT	SEGMENT
_build$ = 8
_this$ = -4
_j$ = -8
?AddDecalToMesh@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z PROC NEAR ; CStudioModelRenderer::AddDecalToMesh, COMDAT

; 706  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 707  : 	build.m_pVertexInfo = (DecalVertexInfo_t *)stackalloc( build.m_pDecalMesh->numvertices * sizeof( DecalVertexInfo_t ));

	mov	eax, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [ecx+8]
	imul	eax, 12					; 0000000cH
	add	eax, 15					; 0000000fH
	and	al, -16					; fffffff0H
	add	eax, 3
	and	al, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR -12+[ebp], esp
	mov	edx, DWORD PTR _build$[ebp]
	mov	eax, DWORD PTR -12+[ebp]
	mov	DWORD PTR [edx+64], eax

; 708  : 
; 709  : 	// project all vertices for this group into decal space
; 710  : 	// Note we do this work at a mesh level instead of a model level
; 711  : 	// because vertices are not shared across mesh boundaries
; 712  : 	ProjectDecalOntoMesh( build );

	mov	ecx, DWORD PTR _build$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProjectDecalOntoMesh@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z ; CStudioModelRenderer::ProjectDecalOntoMesh

; 713  : 
; 714  : 	for( int j = 0; j < build.m_pDecalMesh->numvertices; j += 3 )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L72252
$L72253:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 3
	mov	DWORD PTR _j$[ebp], edx
$L72252:
	mov	eax, DWORD PTR _build$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $L72254

; 716  : 		AddTriangleToDecal( build, j + 0, j + 1, j + 2 );

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _j$[ebp]
	push	edx
	mov	eax, DWORD PTR _build$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddTriangleToDecal@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@HHH@Z ; CStudioModelRenderer::AddTriangleToDecal

; 717  : 	}

	jmp	SHORT $L72253
$L72254:

; 718  : }

	lea	esp, DWORD PTR [ebp-88]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddDecalToMesh@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z ENDP ; CStudioModelRenderer::AddDecalToMesh
_TEXT	ENDS
PUBLIC	?GetDecalMaterial@CStudioModelRenderer@@AAEHAAUDecalModelList_t@1@HPAUmstudiomat_s@@_N@Z ; CStudioModelRenderer::GetDecalMaterial
PUBLIC	?ShouldRetireDecal@CStudioModelRenderer@@AAE_NPAUDecalMaterial_t@1@ABV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z ; CStudioModelRenderer::ShouldRetireDecal
PUBLIC	?CreateDecalForMaterial@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z ; CStudioModelRenderer::CreateDecalForMaterial
PUBLIC	?RetireDecal@CStudioModelRenderer@@AAEXAAV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z ; CStudioModelRenderer::RetireDecal
PUBLIC	?Count@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBEHXZ	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Count
PUBLIC	?AddDecalToModel@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z ; CStudioModelRenderer::AddDecalToModel
EXTRN	_memcpy:NEAR
EXTRN	?HalfToFloat@@YAMG@Z:NEAR			; HalfToFloat
;	COMDAT ?AddDecalToModel@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z
_TEXT	SEGMENT
_buildInfo$ = 8
_this$ = -4
_pstudioverts$ = -8
_pstudionorms$ = -12
_pvertbone$ = -16
_list$ = -20
_defaultBoneWeight$ = -28
_vl$ = -32
_pskinref$ = -36
_i$ = -40
_numVerts$ = -44
_pvertweight$ = -48
_pDecalMesh$ = -52
_offset$72283 = -56
_pmesh$72294 = -60
_ptricmds$72297 = -64
_pCurMesh$72300 = -68
_s$72301 = -72
_t$72303 = -76
_vertexState$72308 = -80
_tri_strip$72309 = -84
_out$72320 = -88
_materialIdx$72333 = -92
?AddDecalToModel@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z PROC NEAR ; CStudioModelRenderer::AddDecalToModel, COMDAT

; 721  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 722  : 	Vector *pstudioverts = (Vector *)((byte *)m_pStudioHeader + m_pSubModel->vertindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+88]
	mov	DWORD PTR _pstudioverts$[ebp], eax

; 723  : 	Vector *pstudionorms = (Vector *)((byte *)m_pStudioHeader + m_pSubModel->normindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+100]
	mov	DWORD PTR _pstudionorms$[ebp], ecx

; 724  : 	byte *pvertbone = ((byte *)m_pStudioHeader + m_pSubModel->vertinfoindex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19132]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	add	edx, DWORD PTR [eax+84]
	mov	DWORD PTR _pvertbone$[ebp], edx

; 725  : 	DecalModelList_t& list = m_DecalList[m_pModelInstance->m_DecalHandle];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	dx, WORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::operator[]
	mov	DWORD PTR _list$[ebp], eax

; 726  : 	mstudioboneweight_t	defaultBoneWeight;
; 727  : 	dvertlight_t	*vl = NULL;

	mov	DWORD PTR _vl$[ebp], 0

; 728  : 	short		*pskinref;
; 729  : 	int 		i, numVerts;
; 730  : 
; 731  : 	// if weights was missed their offsets just equal to 0
; 732  : 	mstudioboneweight_t	*pvertweight = (mstudioboneweight_t *)((byte *)m_pStudioHeader + m_pSubModel->blendvertinfoindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+104]
	mov	DWORD PTR _pvertweight$[ebp], eax

; 733  : 	DecalMesh_t *pDecalMesh = (DecalMesh_t *)stackalloc( m_pSubModel->nummesh * sizeof( DecalMesh_t ));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19132]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 12					; 0000000cH
	add	eax, 15					; 0000000fH
	and	al, -16					; fffffff0H
	add	eax, 3
	and	al, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR -96+[ebp], esp
	mov	eax, DWORD PTR -96+[ebp]
	mov	DWORD PTR _pDecalMesh$[ebp], eax

; 734  : 	pskinref = (short *)((byte *)m_pStudioHeader + m_pStudioHeader->skinindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+200]
	mov	DWORD PTR _pskinref$[ebp], ecx

; 735  : 	if( !pDecalMesh ) return; // empty mesh?

	cmp	DWORD PTR _pDecalMesh$[ebp], 0
	jne	SHORT $L72281
	jmp	$L72258
$L72281:

; 736  : 
; 737  : 	// initialize default boneweight
; 738  : 	defaultBoneWeight.bone[0] = 0;

	mov	BYTE PTR _defaultBoneWeight$[ebp+4], 0

; 739  : 	defaultBoneWeight.bone[1] = -1;

	mov	BYTE PTR _defaultBoneWeight$[ebp+5], -1

; 740  : 	defaultBoneWeight.bone[2] = -1;

	mov	BYTE PTR _defaultBoneWeight$[ebp+6], -1

; 741  : 	defaultBoneWeight.bone[3] = -1;

	mov	BYTE PTR _defaultBoneWeight$[ebp+7], -1

; 742  : 	defaultBoneWeight.weight[0] = 255;

	mov	BYTE PTR _defaultBoneWeight$[ebp], 255	; 000000ffH

; 743  : 	defaultBoneWeight.weight[1] = 0;

	mov	BYTE PTR _defaultBoneWeight$[ebp+1], 0

; 744  : 	defaultBoneWeight.weight[2] = 0;

	mov	BYTE PTR _defaultBoneWeight$[ebp+2], 0

; 745  : 	defaultBoneWeight.weight[3] = 0;

	mov	BYTE PTR _defaultBoneWeight$[ebp+3], 0

; 746  : 
; 747  : 	if( buildInfo.modelLight != NULL )

	mov	edx, DWORD PTR _buildInfo$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $L72290

; 749  : 		int	offset = (byte *)m_pSubModel - (byte *)m_pStudioHeader; // search for submodel offset

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+19132]
	sub	edx, DWORD PTR [ecx+19124]
	mov	DWORD PTR _offset$72283[ebp], edx

; 750  : 
; 751  : 		for( i = 0; i < MAXSTUDIOMODELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72286
$L72287:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L72286:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $L72288

; 753  : 			if( buildInfo.modelLight->submodels[i].submodel_offset == offset )

	mov	ecx, DWORD PTR _buildInfo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*8+12]
	cmp	ecx, DWORD PTR _offset$72283[ebp]
	jne	SHORT $L72289

; 754  : 				break;			

	jmp	SHORT $L72288
$L72289:

; 755  : 		}

	jmp	SHORT $L72287
$L72288:

; 756  : 
; 757  : 		// has vertexlighting for this submodel
; 758  : 		if( i != MAXSTUDIOMODELS )

	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	je	SHORT $L72290

; 759  : 			vl = &buildInfo.modelLight->verts[buildInfo.modelLight->submodels[i].vertex_offset];

	mov	edx, DWORD PTR _buildInfo$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _buildInfo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx+ecx*8+16]
	imul	edx, 28					; 0000001cH
	lea	eax, DWORD PTR [eax+edx+268]
	mov	DWORD PTR _vl$[ebp], eax
$L72290:

; 761  : 
; 762  : 	m_nNumArrayVerts = m_nNumArrayElems = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344992], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+5344988], 0

; 763  : 
; 764  : 	// build all the data for current submodel
; 765  : 	for( i = 0; i < m_pSubModel->nummesh; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72291
$L72292:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L72291:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19132]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+72]
	jge	$L72293

; 767  : 		mstudiomesh_t *pmesh = (mstudiomesh_t *)((byte *)m_pStudioHeader + m_pSubModel->meshindex) + i;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+76]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 20					; 00000014H
	add	ecx, edx
	mov	DWORD PTR _pmesh$72294[ebp], ecx

; 768  : 		short *ptricmds = (short *)((byte *)m_pStudioHeader + pmesh->triindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _pmesh$72294[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _ptricmds$72297[ebp], ecx

; 769  : 		DecalMesh_t *pCurMesh = pDecalMesh + i;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pDecalMesh$[ebp]
	add	ecx, eax
	mov	DWORD PTR _pCurMesh$72300[ebp], ecx

; 770  : 
; 771  : 		pCurMesh->pmaterial = &m_pRenderModel->materials[pskinref[pmesh->skinref]];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	mov	ecx, DWORD PTR _pmesh$72294[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _pskinref$[ebp]
	movsx	edx, WORD PTR [ecx+edx*2]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR [eax+384]
	add	eax, edx
	mov	ecx, DWORD PTR _pCurMesh$72300[ebp]
	mov	DWORD PTR [ecx], eax

; 772  : 		pCurMesh->firstvertex = m_nNumArrayElems;

	mov	edx, DWORD PTR _pCurMesh$72300[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	mov	DWORD PTR [edx+4], ecx

; 773  : 		pCurMesh->numvertices = m_nNumArrayElems;

	mov	edx, DWORD PTR _pCurMesh$72300[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	mov	DWORD PTR [edx+8], ecx

; 774  : 
; 775  : 		float s = 1.0f / (float)pCurMesh->pmaterial->pSource->width;

	mov	edx, DWORD PTR _pCurMesh$72300[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	fild	DWORD PTR [ecx+68]
	fdivr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _s$72301[ebp]

; 776  : 		float t = 1.0f / (float)pCurMesh->pmaterial->pSource->height;

	mov	edx, DWORD PTR _pCurMesh$72300[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	fild	DWORD PTR [ecx+72]
	fdivr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _t$72303[ebp]
$L72306:

; 777  : 
; 778  : 		while( numVerts = *( ptricmds++ ))

	mov	edx, DWORD PTR _ptricmds$72297[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR _numVerts$[ebp], eax
	mov	ecx, DWORD PTR _numVerts$[ebp]
	mov	edx, DWORD PTR _ptricmds$72297[ebp]
	add	edx, 2
	mov	DWORD PTR _ptricmds$72297[ebp], edx
	test	ecx, ecx
	je	$L72307

; 780  : 			int	vertexState = 0;

	mov	DWORD PTR _vertexState$72308[ebp], 0

; 781  : 			qboolean	tri_strip = true;

	mov	DWORD PTR _tri_strip$72309[ebp], 1

; 782  : 
; 783  : 			if( numVerts < 0 )

	cmp	DWORD PTR _numVerts$[ebp], 0
	jge	SHORT $L72310

; 785  : 				tri_strip = false;

	mov	DWORD PTR _tri_strip$72309[ebp], 0

; 786  : 				numVerts = -numVerts;

	mov	eax, DWORD PTR _numVerts$[ebp]
	neg	eax
	mov	DWORD PTR _numVerts$[ebp], eax
$L72310:

; 788  : 
; 789  : 			for( ; numVerts > 0; numVerts--, ptricmds += 4 )

	jmp	SHORT $L72311
$L72312:
	mov	ecx, DWORD PTR _numVerts$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _numVerts$[ebp], ecx
	mov	edx, DWORD PTR _ptricmds$72297[ebp]
	add	edx, 8
	mov	DWORD PTR _ptricmds$72297[ebp], edx
$L72311:
	cmp	DWORD PTR _numVerts$[ebp], 0
	jle	$L72313

; 791  : 				// build in indices
; 792  : 				if( vertexState++ < 3 )

	mov	eax, DWORD PTR _vertexState$72308[ebp]
	mov	ecx, DWORD PTR _vertexState$72308[ebp]
	add	ecx, 1
	mov	DWORD PTR _vertexState$72308[ebp], ecx
	cmp	eax, 3
	jge	SHORT $L72314

; 794  : 					m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+5344988]
	mov	DWORD PTR [ecx+eax*4+3772124], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+5344992], ecx

; 796  : 				else if( tri_strip )

	jmp	$L72319
$L72314:
	cmp	DWORD PTR _tri_strip$72309[ebp], 0
	je	$L72316

; 798  : 					// flip triangles between clockwise and counter clockwise
; 799  : 					if( vertexState & 1 )

	mov	eax, DWORD PTR _vertexState$72308[ebp]
	and	eax, 1
	test	eax, eax
	je	$L72317

; 801  : 						// draw triangle [n-2 n-1 n]
; 802  : 						m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts - 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	sub	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+ecx*4+3772124], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5344992], edx

; 803  : 						m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+ecx*4+3772124], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5344992], edx

; 804  : 						m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+5344988]
	mov	DWORD PTR [eax+edx*4+3772124], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344992], eax

; 806  : 					else

	jmp	$L72318
$L72317:

; 808  : 						// draw triangle [n-1 n-2 n]
; 809  : 						m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts - 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+3772124], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344992], eax

; 810  : 						m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts - 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	sub	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+3772124], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344992], eax

; 811  : 						m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+5344988]
	mov	DWORD PTR [ecx+eax*4+3772124], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+5344992], ecx
$L72318:

; 814  : 				else

	jmp	$L72319
$L72316:

; 816  : 					// draw triangle fan [0 n-1 n]
; 817  : 					m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts - ( vertexState - 1 );

	mov	eax, DWORD PTR _vertexState$72308[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+ecx*4+3772124], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5344992], edx

; 818  : 					m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+ecx*4+3772124], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5344992], edx

; 819  : 					m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+5344988]
	mov	DWORD PTR [eax+edx*4+3772124], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344992], eax
$L72319:

; 821  : 
; 822  : 				DecalVertex_t *out = &m_decalverts[m_nNumArrayVerts];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	shl	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+225500]
	mov	DWORD PTR _out$72320[ebp], edx

; 823  : 
; 824  : 				out->m_Position = pstudioverts[ptricmds[0]];

	mov	eax, DWORD PTR _ptricmds$72297[ebp]
	movsx	ecx, WORD PTR [eax]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _pstudioverts$[ebp]
	add	edx, ecx
	mov	eax, DWORD PTR _out$72320[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 825  : 				out->m_Normal = pstudionorms[ptricmds[1]];

	mov	eax, DWORD PTR _ptricmds$72297[ebp]
	movsx	ecx, WORD PTR [eax+2]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _pstudionorms$[ebp]
	add	edx, ecx
	mov	eax, DWORD PTR _out$72320[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 826  : 
; 827  : 				if( m_pRenderModel->poseToBone != NULL )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	cmp	DWORD PTR [ecx+376], 0
	je	SHORT $L72321

; 829  : 					out->m_BoneWeights = pvertweight[ptricmds[0]];

	mov	edx, DWORD PTR _ptricmds$72297[ebp]
	movsx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _pvertweight$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	mov	ecx, DWORD PTR _out$72320[ebp]
	mov	DWORD PTR [ecx+52], edx
	mov	DWORD PTR [ecx+56], eax

; 831  : 				else

	jmp	SHORT $L72322
$L72321:

; 833  : 					out->m_BoneWeights = defaultBoneWeight;

	mov	edx, DWORD PTR _out$72320[ebp]
	mov	eax, DWORD PTR _defaultBoneWeight$[ebp]
	mov	DWORD PTR [edx+52], eax
	mov	ecx, DWORD PTR _defaultBoneWeight$[ebp+4]
	mov	DWORD PTR [edx+56], ecx

; 834  : 					out->m_BoneWeights.bone[0] = pvertbone[ptricmds[0]];

	mov	edx, DWORD PTR _ptricmds$72297[ebp]
	movsx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _out$72320[ebp]
	mov	edx, DWORD PTR _pvertbone$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx+56], al
$L72322:

; 836  : 
; 837  : 				if( pCurMesh->pmaterial->pSource->flags & STUDIO_NF_CHROME )

	mov	ecx, DWORD PTR _pCurMesh$72300[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+64]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L72323

; 839  : 					// probably always equal 64 (see studiomdl.c for details)
; 840  : 					out->m_TexCoord1[0] = s;

	mov	ecx, DWORD PTR _out$72320[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	mov	edx, DWORD PTR _s$72301[ebp]
	mov	DWORD PTR [eax], edx

; 841  : 					out->m_TexCoord1[1] = t;

	mov	ecx, DWORD PTR _out$72320[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	mov	ecx, DWORD PTR _t$72303[ebp]
	mov	DWORD PTR [eax+4], ecx

; 843  : 				else if( pCurMesh->pmaterial->pSource->flags & STUDIO_NF_UV_COORDS )

	jmp	$L72326
$L72323:
	mov	edx, DWORD PTR _pCurMesh$72300[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+64]
	and	edx, -2147483648			; 80000000H
	test	edx, edx
	je	SHORT $L72325

; 845  : 					out->m_TexCoord1[0] = HalfToFloat( ptricmds[2] );

	mov	eax, DWORD PTR _ptricmds$72297[ebp]
	mov	cx, WORD PTR [eax+4]
	push	ecx
	call	?HalfToFloat@@YAMG@Z			; HalfToFloat
	fstp	DWORD PTR -100+[ebp]
	add	esp, 4
	mov	ecx, DWORD PTR _out$72320[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	mov	edx, DWORD PTR -100+[ebp]
	mov	DWORD PTR [eax], edx

; 846  : 					out->m_TexCoord1[1] = HalfToFloat( ptricmds[3] );

	mov	eax, DWORD PTR _ptricmds$72297[ebp]
	mov	cx, WORD PTR [eax+6]
	push	ecx
	call	?HalfToFloat@@YAMG@Z			; HalfToFloat
	fstp	DWORD PTR -104+[ebp]
	add	esp, 4
	mov	ecx, DWORD PTR _out$72320[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	mov	edx, DWORD PTR -104+[ebp]
	mov	DWORD PTR [eax+4], edx

; 848  : 				else

	jmp	SHORT $L72326
$L72325:

; 850  : 					out->m_TexCoord1[0] = ptricmds[2] * s;

	mov	eax, DWORD PTR _ptricmds$72297[ebp]
	movsx	ecx, WORD PTR [eax+4]
	mov	DWORD PTR -108+[ebp], ecx
	fild	DWORD PTR -108+[ebp]
	fmul	DWORD PTR _s$72301[ebp]
	fstp	DWORD PTR -112+[ebp]
	mov	ecx, DWORD PTR _out$72320[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	mov	edx, DWORD PTR -112+[ebp]
	mov	DWORD PTR [eax], edx

; 851  : 					out->m_TexCoord1[1] = ptricmds[3] * t;

	mov	eax, DWORD PTR _ptricmds$72297[ebp]
	movsx	ecx, WORD PTR [eax+6]
	mov	DWORD PTR -116+[ebp], ecx
	fild	DWORD PTR -116+[ebp]
	fmul	DWORD PTR _t$72303[ebp]
	fstp	DWORD PTR -120+[ebp]
	mov	ecx, DWORD PTR _out$72320[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector2D@@QAEPAMXZ			; Vector2D::operator float *
	mov	edx, DWORD PTR -120+[ebp]
	mov	DWORD PTR [eax+4], edx
$L72326:

; 853  : 
; 854  : 				// accumulate vertex lighting too
; 855  : 				if( vl != NULL )

	cmp	DWORD PTR _vl$[ebp], 0
	je	SHORT $L72327

; 856  : 					memcpy( &out->m_Light, vl[m_nNumArrayVerts].light, LM_STYLES * 3 );

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _vl$[ebp]
	add	edx, ecx
	push	edx
	mov	eax, DWORD PTR _out$72320[ebp]
	add	eax, 40					; 00000028H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$L72327:

; 857  : 				m_nNumArrayVerts++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5344988], edx

; 858  : 			}

	jmp	$L72312
$L72313:

; 859  : 		}

	jmp	$L72306
$L72307:

; 860  : 		pCurMesh->numvertices = m_nNumArrayElems - pCurMesh->firstvertex;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pCurMesh$72300[ebp]
	mov	eax, DWORD PTR [ecx+5344992]
	sub	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _pCurMesh$72300[ebp]
	mov	DWORD PTR [ecx+8], eax

; 861  : 	}

	jmp	$L72292
$L72293:

; 862  : 
; 863  : 	for( i = 0; i < m_pSubModel->nummesh; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72328
$L72329:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L72328:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19132]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+72]
	jge	$L72330

; 865  : 		buildInfo.m_Mesh = i;

	mov	eax, DWORD PTR _buildInfo$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 866  : 		buildInfo.m_pDecalMesh = pDecalMesh + i;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pDecalMesh$[ebp]
	add	eax, edx
	mov	ecx, DWORD PTR _buildInfo$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 867  : 		buildInfo.m_pMesh = (mstudiomesh_t *)((byte *)m_pStudioHeader + m_pSubModel->meshindex) + i;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19132]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	add	edx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	add	edx, eax
	mov	ecx, DWORD PTR _buildInfo$[ebp]
	mov	DWORD PTR [ecx+52], edx

; 868  : 		int materialIdx = GetDecalMaterial( list, buildInfo.m_iDecalTexture, buildInfo.m_pDecalMesh->pmaterial );

	push	0
	mov	edx, DWORD PTR _buildInfo$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _buildInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDecalMaterial@CStudioModelRenderer@@AAEHAAUDecalModelList_t@1@HPAUmstudiomat_s@@_N@Z ; CStudioModelRenderer::GetDecalMaterial
	mov	DWORD PTR _materialIdx$72333[ebp], eax

; 869  : 
; 870  : 		// if material was changed or not init
; 871  : 		if(( buildInfo.m_iDecalMaterial == -1 ) || ( buildInfo.m_iDecalMaterial != materialIdx ))

	mov	edx, DWORD PTR _buildInfo$[ebp]
	cmp	DWORD PTR [edx], -1
	je	SHORT $L72335
	mov	eax, DWORD PTR _buildInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _materialIdx$72333[ebp]
	je	$L72334
$L72335:

; 873  : 			// time to dump accumulated vertices from previous material
; 874  : 			CreateDecalForMaterial( buildInfo );

	mov	edx, DWORD PTR _buildInfo$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateDecalForMaterial@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z ; CStudioModelRenderer::CreateDecalForMaterial

; 875  : 
; 876  : 			materialIdx = GetDecalMaterial( list, buildInfo.m_iDecalTexture, buildInfo.m_pDecalMesh->pmaterial, true );

	push	1
	mov	eax, DWORD PTR _buildInfo$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _buildInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _list$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDecalMaterial@CStudioModelRenderer@@AAEHAAUDecalModelList_t@1@HPAUmstudiomat_s@@_N@Z ; CStudioModelRenderer::GetDecalMaterial
	mov	DWORD PTR _materialIdx$72333[ebp], eax

; 877  : 			buildInfo.m_pDecalMaterial = &m_DecalMaterial[materialIdx];

	mov	ax, WORD PTR _materialIdx$72333[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::operator[]
	mov	ecx, DWORD PTR _buildInfo$[ebp]
	mov	DWORD PTR [ecx+60], eax
$L72337:

; 878  : 
; 879  : 			// Check to see if we should retire the decal
; 880  : 			while( ShouldRetireDecal( buildInfo.m_pDecalMaterial, list.m_DecalHistory ))

	mov	edx, DWORD PTR _list$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _buildInfo$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldRetireDecal@CStudioModelRenderer@@AAE_NPAUDecalMaterial_t@1@ABV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z ; CStudioModelRenderer::ShouldRetireDecal
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L72338

; 881  : 				RetireDecal( list.m_DecalHistory );

	mov	edx, DWORD PTR _list$[ebp]
	add	edx, 4
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RetireDecal@CStudioModelRenderer@@AAEXAAV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z ; CStudioModelRenderer::RetireDecal
	jmp	SHORT $L72337
$L72338:

; 882  : 
; 883  : 			buildInfo.m_FirstVertex = buildInfo.m_pDecalMaterial->m_Vertices.InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _buildInfo$[ebp]
	mov	WORD PTR [ecx+80], ax

; 884  : 			buildInfo.m_PrevIndexCount = buildInfo.m_pDecalMaterial->m_Indices.Count();

	mov	edx, DWORD PTR _buildInfo$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	add	ecx, 16					; 00000010H
	call	?Count@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBEHXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Count
	mov	ecx, DWORD PTR _buildInfo$[ebp]
	mov	DWORD PTR [ecx+84], eax

; 885  : 			buildInfo.m_iDecalMaterial = materialIdx;

	mov	edx, DWORD PTR _buildInfo$[ebp]
	mov	eax, DWORD PTR _materialIdx$72333[ebp]
	mov	DWORD PTR [edx], eax

; 886  : 			buildInfo.m_VertexCount = 0;

	mov	ecx, DWORD PTR _buildInfo$[ebp]
	mov	WORD PTR [ecx+82], 0
$L72334:

; 888  : 
; 889  : 		AddDecalToMesh( buildInfo );

	mov	edx, DWORD PTR _buildInfo$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddDecalToMesh@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z ; CStudioModelRenderer::AddDecalToMesh

; 890  : 	}

	jmp	$L72329
$L72330:
$L72258:

; 891  : }

	lea	esp, DWORD PTR [ebp-196]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddDecalToModel@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z ENDP ; CStudioModelRenderer::AddDecalToModel
_TEXT	ENDS
PUBLIC	?AddDecalToMaterialList@CStudioModelRenderer@@AAEHPAUDecalMaterial_t@1@@Z ; CStudioModelRenderer::AddDecalToMaterialList
PUBLIC	??A?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::operator[]
PUBLIC	?AddToTail@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::AddToTail
PUBLIC	?__LINE__Var@?1??CreateDecalForMaterial@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@2@@Z@4FA ; `CStudioModelRenderer::CreateDecalForMaterial'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??CreateDecalForMaterial@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@2@@Z@4FA
; File z:\xashxtsrc\client\render\r_studiodecal.cpp
_DATA	SEGMENT
?__LINE__Var@?1??CreateDecalForMaterial@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@2@@Z@4FA DW 037eH ; `CStudioModelRenderer::CreateDecalForMaterial'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?CreateDecalForMaterial@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z
_TEXT	SEGMENT
_buildInfo$ = 8
_this$ = -4
_decalIndexCount$72344 = -8
_list$72345 = -12
_decalIndex$72348 = -16
_decal$72349 = -20
_h$72350 = -24
?CreateDecalForMaterial@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z PROC NEAR ; CStudioModelRenderer::CreateDecalForMaterial, COMDAT

; 894  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 895  : 	// add this to the list of decals in this material
; 896  : 	if( buildInfo.m_VertexCount && buildInfo.m_iDecalMaterial != -1 && buildInfo.m_pDecalMaterial != NULL )

	mov	eax, DWORD PTR _buildInfo$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+82]
	test	ecx, ecx
	je	$L72343
	mov	edx, DWORD PTR _buildInfo$[ebp]
	cmp	DWORD PTR [edx], -1
	je	$L72343
	mov	eax, DWORD PTR _buildInfo$[ebp]
	cmp	DWORD PTR [eax+60], 0
	je	$L72343

; 898  : 		int decalIndexCount = buildInfo.m_pDecalMaterial->m_Indices.Count() - buildInfo.m_PrevIndexCount;

	mov	ecx, DWORD PTR _buildInfo$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	add	ecx, 16					; 00000010H
	call	?Count@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBEHXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Count
	mov	edx, DWORD PTR _buildInfo$[ebp]
	sub	eax, DWORD PTR [edx+84]
	mov	DWORD PTR _decalIndexCount$72344[ebp], eax

; 899  : 		DecalModelList_t& list = m_DecalList[m_pModelInstance->m_DecalHandle];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	dx, WORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::operator[]
	mov	DWORD PTR _list$72345[ebp], eax

; 900  : 		ASSERT( decalIndexCount > 0 );

	cmp	DWORD PTR _decalIndexCount$72344[ebp], 0
	jg	SHORT $L72347
	movsx	eax, WORD PTR ?__LINE__Var@?1??CreateDecalForMaterial@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@2@@Z@4FA ; `CStudioModelRenderer::CreateDecalForMaterial'::`2'::__LINE__Var
	add	eax, 6
	push	eax
	push	OFFSET FLAT:??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72347:

; 901  : 
; 902  : 		int decalIndex = AddDecalToMaterialList( buildInfo.m_pDecalMaterial );

	mov	ecx, DWORD PTR _buildInfo$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddDecalToMaterialList@CStudioModelRenderer@@AAEHPAUDecalMaterial_t@1@@Z ; CStudioModelRenderer::AddDecalToMaterialList
	mov	DWORD PTR _decalIndex$72348[ebp], eax

; 903  : 		Decal_t& decal = buildInfo.m_pDecalMaterial->m_Decals[decalIndex];

	mov	ax, WORD PTR _decalIndex$72348[ebp]
	push	eax
	mov	ecx, DWORD PTR _buildInfo$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	add	ecx, 64					; 00000040H
	call	??A?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::operator[]
	mov	DWORD PTR _decal$72349[ebp], eax

; 904  : 		decal.m_VertexCount = buildInfo.m_VertexCount;

	mov	edx, DWORD PTR _buildInfo$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+82]
	mov	ecx, DWORD PTR _decal$72349[ebp]
	mov	DWORD PTR [ecx+4], eax

; 905  : 		decal.m_IndexCount = decalIndexCount;

	mov	edx, DWORD PTR _decal$72349[ebp]
	mov	eax, DWORD PTR _decalIndexCount$72344[ebp]
	mov	DWORD PTR [edx], eax

; 906  : 
; 907  : 		decal.state = *buildInfo.modelState;

	mov	ecx, DWORD PTR _buildInfo$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	mov	edi, DWORD PTR _decal$72349[ebp]
	add	edi, 8
	mov	ecx, 7
	rep movsd
	movsw

; 908  : 		decal.depth = buildInfo.decalDepth;

	mov	edx, DWORD PTR _decal$72349[ebp]
	mov	eax, DWORD PTR _buildInfo$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+40], ecx

; 909  : 		decal.vecLocalStart = buildInfo.vecLocalStart;

	mov	edx, DWORD PTR _buildInfo$[ebp]
	add	edx, 24					; 00000018H
	mov	eax, DWORD PTR _decal$72349[ebp]
	add	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 910  : 		decal.vecLocalEnd = buildInfo.vecLocalEnd;

	mov	eax, DWORD PTR _buildInfo$[ebp]
	add	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _decal$72349[ebp]
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 911  : 		decal.flags = buildInfo.decalFlags;

	mov	ecx, DWORD PTR _decal$72349[ebp]
	mov	edx, DWORD PTR _buildInfo$[ebp]
	mov	al, BYTE PTR [edx+48]
	mov	BYTE PTR [ecx+68], al

; 912  : 
; 913  : 		// Add this decal to the history...
; 914  : 		int h = list.m_DecalHistory.AddToTail();

	mov	ecx, DWORD PTR _list$72345[ebp]
	add	ecx, 4
	call	?AddToTail@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::AddToTail
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _h$72350[ebp], eax

; 915  : 		list.m_DecalHistory[h].m_Material = buildInfo.m_iDecalMaterial;

	mov	cx, WORD PTR _h$72350[ebp]
	push	ecx
	mov	ecx, DWORD PTR _list$72345[ebp]
	add	ecx, 4
	call	??A?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::operator[]
	mov	edx, DWORD PTR _buildInfo$[ebp]
	mov	cx, WORD PTR [edx]
	mov	WORD PTR [eax], cx

; 916  : 		list.m_DecalHistory[h].m_Decal = decalIndex;

	mov	dx, WORD PTR _h$72350[ebp]
	push	edx
	mov	ecx, DWORD PTR _list$72345[ebp]
	add	ecx, 4
	call	??A?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::operator[]
	mov	cx, WORD PTR _decalIndex$72348[ebp]
	mov	WORD PTR [eax+2], cx
$L72343:

; 918  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CreateDecalForMaterial@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z ENDP ; CStudioModelRenderer::CreateDecalForMaterial
_TEXT	ENDS
PUBLIC	?Alloc@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEG_N@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Alloc
PUBLIC	?LinkBefore@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::LinkBefore
EXTRN	?GL_UberShaderForStudioDecal@@YAGPAUmstudiomat_s@@@Z:NEAR ; GL_UberShaderForStudioDecal
EXTRN	?tr@@3Uref_globals_t@@A:BYTE			; tr
;	COMDAT ?GetDecalMaterial@CStudioModelRenderer@@AAEHAAUDecalModelList_t@1@HPAUmstudiomat_s@@_N@Z
_TEXT	SEGMENT
_decalList$ = 8
_decalTexture$ = 12
_mat$ = 16
_create$ = 20
_this$ = -4
_modelTexture$ = -8
_hProgram$ = -12
_j$ = -16
_pdecal$72366 = -20
?GetDecalMaterial@CStudioModelRenderer@@AAEHAAUDecalModelList_t@1@HPAUmstudiomat_s@@_N@Z PROC NEAR ; CStudioModelRenderer::GetDecalMaterial, COMDAT

; 924  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 925  : 	// first we need to determine model texture, because we only require textures for alpha and solid modes.
; 926  : 	// otherwise we can use stub like '*whiteTexture' to prevent produce multiple materials
; 927  : 	int modelTexture = tr.whiteTexture;

	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+32
	mov	DWORD PTR _modelTexture$[ebp], eax

; 928  : 
; 929  : 	if( FBitSet( mat->flags, STUDIO_NF_MASKED|STUDIO_NF_HAS_ALPHA ))

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 524352				; 00080040H
	test	edx, edx
	je	SHORT $L72359

; 930  : 		modelTexture = mat->gl_diffuse_id;

	mov	eax, DWORD PTR _mat$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+4]
	mov	DWORD PTR _modelTexture$[ebp], ecx
$L72359:

; 931  : 
; 932  : 	word hProgram = GL_UberShaderForStudioDecal( mat );

	mov	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?GL_UberShaderForStudioDecal@@YAGPAUmstudiomat_s@@@Z ; GL_UberShaderForStudioDecal
	add	esp, 4
	mov	WORD PTR _hProgram$[ebp], ax

; 933  : 
; 934  : 	if( !create && !hProgram )

	mov	eax, DWORD PTR _create$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L72361
	mov	ecx, DWORD PTR _hProgram$[ebp]
	and	ecx, 65535				; 0000ffffH
	test	ecx, ecx
	jne	SHORT $L72361

; 935  : 		return 0xFFFF; // create a new material with invalid shader

	mov	eax, 65535				; 0000ffffH
	jmp	$L72357
$L72361:

; 936  : 
; 937  : 	for( word j = decalList.m_FirstMaterial; j != m_DecalMaterial.InvalidIndex(); j = m_DecalMaterial.Next( j ))

	mov	edx, DWORD PTR _decalList$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $L72363
$L72364:
	mov	cx, WORD PTR _j$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Next@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Next
	mov	WORD PTR _j$[ebp], ax
$L72363:
	mov	esi, DWORD PTR _j$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L72365

; 939  : 		DecalMaterial_t *pdecal = &m_DecalMaterial[j];

	mov	dx, WORD PTR _j$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::operator[]
	mov	DWORD PTR _pdecal$72366[ebp], eax

; 940  : 
; 941  : 		if( pdecal->decalTexture == decalTexture && pdecal->modelTexture == modelTexture && pdecal->hProgram == hProgram )

	mov	eax, DWORD PTR _pdecal$72366[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _decalTexture$[ebp]
	jne	SHORT $L72367
	mov	edx, DWORD PTR _pdecal$72366[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _modelTexture$[ebp]
	jne	SHORT $L72367
	mov	ecx, DWORD PTR _pdecal$72366[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx]
	mov	eax, DWORD PTR _hProgram$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L72367

; 943  : 			return j;

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 65535				; 0000ffffH
	jmp	$L72357
$L72367:

; 945  : 	}

	jmp	SHORT $L72364
$L72365:

; 946  : 
; 947  : 	if( !create ) return 0xFFFF; // material was not found

	mov	ecx, DWORD PTR _create$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L72368
	mov	eax, 65535				; 0000ffffH
	jmp	$L72357
$L72368:

; 948  : 
; 949  : 	// If we got here, this must be the first time we saw this material
; 950  : 	j = m_DecalMaterial.Alloc( true );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Alloc@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEG_N@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Alloc
	mov	WORD PTR _j$[ebp], ax

; 951  : 	
; 952  : 	// Link it into the list of data
; 953  : 	if( decalList.m_FirstMaterial != m_DecalMaterial.InvalidIndex( ))

	mov	edx, DWORD PTR _decalList$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx]
	mov	esi, eax
	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L72369

; 954  : 		m_DecalMaterial.LinkBefore( decalList.m_FirstMaterial, j );

	mov	cx, WORD PTR _j$[ebp]
	push	ecx
	mov	edx, DWORD PTR _decalList$[ebp]
	mov	ax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?LinkBefore@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::LinkBefore
$L72369:

; 955  : 	decalList.m_FirstMaterial = j;

	mov	ecx, DWORD PTR _decalList$[ebp]
	mov	dx, WORD PTR _j$[ebp]
	mov	WORD PTR [ecx], dx

; 956  : 
; 957  : 	m_DecalMaterial[j].decalTexture = decalTexture;

	mov	ax, WORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::operator[]
	mov	ecx, DWORD PTR _decalTexture$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 958  : 	m_DecalMaterial[j].modelTexture = modelTexture;

	mov	dx, WORD PTR _j$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::operator[]
	mov	ecx, DWORD PTR _modelTexture$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 959  : 	m_DecalMaterial[j].hProgram = hProgram;

	mov	dx, WORD PTR _j$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::operator[]
	mov	cx, WORD PTR _hProgram$[ebp]
	mov	WORD PTR [eax], cx

; 960  : 	m_DecalMaterial[j].flags = mat->flags;

	mov	dx, WORD PTR _j$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::operator[]
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 961  : 
; 962  : 	if( !hProgram ) // it's invalid material, disable shader

	mov	eax, DWORD PTR _hProgram$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jne	SHORT $L72370

; 963  : 		m_DecalMaterial[j].flags |= STUDIO_NF_NODRAW;

	mov	cx, WORD PTR _j$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::operator[]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR -24+[ebp], eax
	mov	edx, DWORD PTR -24+[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 65536				; 00010000H
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR [ecx], eax
$L72370:

; 964  : 
; 965  : 	return j;

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 65535				; 0000ffffH
$L72357:

; 966  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetDecalMaterial@CStudioModelRenderer@@AAEHAAUDecalModelList_t@1@HPAUmstudiomat_s@@_N@Z ENDP ; CStudioModelRenderer::GetDecalMaterial
_TEXT	ENDS
PUBLIC	?Remove@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Remove
PUBLIC	?Count@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEHXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Count
PUBLIC	?Head@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Head
PUBLIC	?RemoveMultiple@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXHH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::RemoveMultiple
PUBLIC	?Remove@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Remove
PUBLIC	?Count@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEHXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::Count
PUBLIC	?Head@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::Head
PUBLIC	?__LINE__Var@?1??RetireDecal@CStudioModelRenderer@@AAEXAAV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z@4FA ; `CStudioModelRenderer::RetireDecal'::`2'::__LINE__Var
PUBLIC	??_C@_0BE@LJH@historyList?4Count?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0DA@HAOP@vertices?4Count?$CI?$CJ?5?$DO?$DN?5decalToRemov@ ; `string'
PUBLIC	?Remove@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Remove
EXTRN	__assert:NEAR
;	COMDAT ?__LINE__Var@?1??RetireDecal@CStudioModelRenderer@@AAEXAAV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z@4FA
; File z:\xashxtsrc\client\render\r_studiodecal.cpp
_DATA	SEGMENT
?__LINE__Var@?1??RetireDecal@CStudioModelRenderer@@AAEXAAV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z@4FA DW 03ccH ; `CStudioModelRenderer::RetireDecal'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BE@LJH@historyList?4Count?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BE@LJH@historyList?4Count?$CI?$CJ?$AA@ DB 'historyList.Count()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HAOP@vertices?4Count?$CI?$CJ?5?$DO?$DN?5decalToRemov@
CONST	SEGMENT
??_C@_0DA@HAOP@vertices?4Count?$CI?$CJ?5?$DO?$DN?5decalToRemov@ DB 'verti'
	DB	'ces.Count() >= decalToRemove.m_VertexCount', 00H ; `string'
CONST	ENDS
;	COMDAT ?RetireDecal@CStudioModelRenderer@@AAEXAAV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z
_TEXT	SEGMENT
_historyList$ = 8
_this$ = -4
_decalHistory$ = -8
_material$ = -12
_vertices$ = -16
_decalToRemove$ = -20
_next$ = -24
_vert$ = -28
_vertsToRemove$ = -32
?RetireDecal@CStudioModelRenderer@@AAEXAAV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z PROC NEAR ; CStudioModelRenderer::RetireDecal, COMDAT

; 972  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 973  : 	assert( historyList.Count() );

	mov	ecx, DWORD PTR _historyList$[ebp]
	call	?Count@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEHXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Count
	test	eax, eax
	jne	SHORT $L74543
	movsx	eax, WORD PTR ?__LINE__Var@?1??RetireDecal@CStudioModelRenderer@@AAEXAAV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z@4FA ; `CStudioModelRenderer::RetireDecal'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BE@LJH@historyList?4Count?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74543:

; 974  : 	DecalHistory_t& decalHistory = historyList[ historyList.Head() ];

	mov	ecx, DWORD PTR _historyList$[ebp]
	call	?Head@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Head
	push	eax
	mov	ecx, DWORD PTR _historyList$[ebp]
	call	??A?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::operator[]
	mov	DWORD PTR _decalHistory$[ebp], eax

; 975  : 
; 976  : 	// Find the decal material for the decal to remove
; 977  : 	DecalMaterial_t& material = m_DecalMaterial[decalHistory.m_Material];

	mov	edx, DWORD PTR _decalHistory$[ebp]
	mov	ax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::operator[]
	mov	DWORD PTR _material$[ebp], eax

; 978  : 
; 979  : 	DecalVertexList_t& vertices = material.m_Vertices;

	mov	ecx, DWORD PTR _material$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR _vertices$[ebp], ecx

; 980  : 	Decal_t& decalToRemove = material.m_Decals[decalHistory.m_Decal];

	mov	edx, DWORD PTR _decalHistory$[ebp]
	mov	ax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _material$[ebp]
	add	ecx, 64					; 00000040H
	call	??A?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::operator[]
	mov	DWORD PTR _decalToRemove$[ebp], eax

; 981  : 	
; 982  : 	// Now clear out the vertices referenced by the indices....
; 983  : 	word next, vert = vertices.Head();

	mov	ecx, DWORD PTR _vertices$[ebp]
	call	?Head@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::Head
	mov	WORD PTR _vert$[ebp], ax

; 984  : 	assert( vertices.Count() >= decalToRemove.m_VertexCount );

	mov	ecx, DWORD PTR _vertices$[ebp]
	call	?Count@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEHXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::Count
	mov	ecx, DWORD PTR _decalToRemove$[ebp]
	cmp	eax, DWORD PTR [ecx+4]
	jge	SHORT $L74544
	movsx	edx, WORD PTR ?__LINE__Var@?1??RetireDecal@CStudioModelRenderer@@AAEXAAV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z@4FA ; `CStudioModelRenderer::RetireDecal'::`2'::__LINE__Var
	add	edx, 12					; 0000000cH
	push	edx
	push	OFFSET FLAT:??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0DA@HAOP@vertices?4Count?$CI?$CJ?5?$DO?$DN?5decalToRemov@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74544:

; 985  : 
; 986  : 	int vertsToRemove = decalToRemove.m_VertexCount;

	mov	ecx, DWORD PTR _decalToRemove$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _vertsToRemove$[ebp], edx
$L72388:

; 987  : 
; 988  : 	while( vertsToRemove > 0 )

	cmp	DWORD PTR _vertsToRemove$[ebp], 0
	jle	SHORT $L72389

; 990  : 		// blat out the vertices
; 991  : 		next = vertices.Next( vert );

	mov	ax, WORD PTR _vert$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vertices$[ebp]
	call	?Next@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Next
	mov	WORD PTR _next$[ebp], ax

; 992  : 		vertices.Remove( vert );

	mov	cx, WORD PTR _vert$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vertices$[ebp]
	call	?Remove@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Remove

; 993  : 		vertsToRemove--;

	mov	edx, DWORD PTR _vertsToRemove$[ebp]
	sub	edx, 1
	mov	DWORD PTR _vertsToRemove$[ebp], edx

; 994  : 		vert = next;

	mov	ax, WORD PTR _next$[ebp]
	mov	WORD PTR _vert$[ebp], ax

; 995  : 	}

	jmp	SHORT $L72388
$L72389:

; 996  : 
; 997  : 	material.m_Indices.RemoveMultiple( 0, decalToRemove.m_IndexCount );

	mov	ecx, DWORD PTR _decalToRemove$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	0
	mov	ecx, DWORD PTR _material$[ebp]
	add	ecx, 16					; 00000010H
	call	?RemoveMultiple@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXHH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::RemoveMultiple

; 998  : 
; 999  : 	// Remove the decal
; 1000 : 	material.m_Decals.Remove( decalHistory.m_Decal );

	mov	eax, DWORD PTR _decalHistory$[ebp]
	mov	cx, WORD PTR [eax+2]
	push	ecx
	mov	ecx, DWORD PTR _material$[ebp]
	add	ecx, 64					; 00000040H
	call	?Remove@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Remove

; 1001 : 
; 1002 : 	// Clear the decal out of the history
; 1003 : 	historyList.Remove( historyList.Head() );

	mov	ecx, DWORD PTR _historyList$[ebp]
	call	?Head@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Head
	push	eax
	mov	ecx, DWORD PTR _historyList$[ebp]
	call	?Remove@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Remove

; 1004 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RetireDecal@CStudioModelRenderer@@AAEXAAV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z ENDP ; CStudioModelRenderer::RetireDecal
_TEXT	ENDS
;	COMDAT ?ShouldRetireDecal@CStudioModelRenderer@@AAE_NPAUDecalMaterial_t@1@ABV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z
_TEXT	SEGMENT
_pDecalMaterial$ = 8
_decalHistory$ = 12
_this$ = -4
?ShouldRetireDecal@CStudioModelRenderer@@AAE_NPAUDecalMaterial_t@1@ABV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z PROC NEAR ; CStudioModelRenderer::ShouldRetireDecal, COMDAT

; 1007 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1008 : 	// Check to see if we should retire the decal
; 1009 : 	return ( decalHistory.Count() >= 50 ) || ( pDecalMaterial->m_Indices.Count() > 2048 );

	mov	ecx, DWORD PTR _decalHistory$[ebp]
	call	?Count@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEHXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Count
	cmp	eax, 50					; 00000032H
	jge	SHORT $L74547
	mov	ecx, DWORD PTR _pDecalMaterial$[ebp]
	add	ecx, 16					; 00000010H
	call	?Count@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBEHXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Count
	cmp	eax, 2048				; 00000800H
	jg	SHORT $L74547
	mov	DWORD PTR -8+[ebp], 0
	jmp	SHORT $L74548
$L74547:
	mov	DWORD PTR -8+[ebp], 1
$L74548:
	mov	al, BYTE PTR -8+[ebp]

; 1010 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShouldRetireDecal@CStudioModelRenderer@@AAE_NPAUDecalMaterial_t@1@ABV?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@@Z ENDP ; CStudioModelRenderer::ShouldRetireDecal
_TEXT	ENDS
PUBLIC	?AddToTail@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::AddToTail
;	COMDAT ?AddDecalToMaterialList@CStudioModelRenderer@@AAEHPAUDecalMaterial_t@1@@Z
_TEXT	SEGMENT
_pMaterial$ = 8
_this$ = -4
_decalList$ = -8
?AddDecalToMaterialList@CStudioModelRenderer@@AAEHPAUDecalMaterial_t@1@@Z PROC NEAR ; CStudioModelRenderer::AddDecalToMaterialList, COMDAT

; 1013 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1014 : 	DecalList_t& decalList = pMaterial->m_Decals;

	mov	eax, DWORD PTR _pMaterial$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _decalList$[ebp], eax

; 1015 : 	return decalList.AddToTail();

	mov	ecx, DWORD PTR _decalList$[ebp]
	call	?AddToTail@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::AddToTail
	and	eax, 65535				; 0000ffffH

; 1016 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddDecalToMaterialList@CStudioModelRenderer@@AAEHPAUDecalMaterial_t@1@@Z ENDP ; CStudioModelRenderer::AddDecalToMaterialList
_TEXT	ENDS
PUBLIC	?StudioDecalShoot@CStudioModelRenderer@@QAEXABVVector@@0HPAUcl_entity_s@@HPAUmodelstate_s@@@Z ; CStudioModelRenderer::StudioDecalShoot
PUBLIC	??0DecalBuildInfo_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::DecalBuildInfo_t::DecalBuildInfo_t
EXTRN	?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUcl_entity_s@@@Z:NEAR ; CStudioModelRenderer::StudioSetEntity
EXTRN	?VectorITransform@matrix3x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix3x4::VectorITransform
EXTRN	?world@@3PAUgl_world_t@@A:DWORD			; world
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	_memset:NEAR
;	COMDAT ?StudioDecalShoot@CStudioModelRenderer@@QAEXABVVector@@0HPAUcl_entity_s@@HPAUmodelstate_s@@@Z
_TEXT	SEGMENT
_vecSrc$ = 8
_vecEnd$ = 12
_decalTexture$ = 16
_ent$ = 20
_flags$ = 24
_state$ = 28
_this$ = -4
_vecLocalSrc$ = -16
_vecLocalEnd$ = -28
_i$72419 = -32
_i$72426 = -36
_i$ = -40
_w$ = -44
_h$ = -48
_radius$ = -52
_buildInfo$ = -144
_cacheID$72449 = -148
_dvl$72450 = -152
_k$ = -156
$T74554 = -208
$T74556 = -260
$T74557 = -272
$T74558 = -284
?StudioDecalShoot@CStudioModelRenderer@@QAEXABVVector@@0HPAUcl_entity_s@@HPAUmodelstate_s@@@Z PROC NEAR ; CStudioModelRenderer::StudioDecalShoot, COMDAT

; 1026 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1027 : 	Vector	vecLocalSrc;

	lea	ecx, DWORD PTR _vecLocalSrc$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1028 : 	Vector	vecLocalEnd;

	lea	ecx, DWORD PTR _vecLocalEnd$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1029 : 
; 1030 : 	if( !g_fRenderInitialized )

	cmp	DWORD PTR ?g_fRenderInitialized@@3HA, 0	; g_fRenderInitialized
	jne	SHORT $L72411

; 1031 : 		return;

	jmp	$L72408
$L72411:

; 1032 : 
; 1033 : 	if( !ent || ent == gEngfuncs.GetViewModel( ))

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $L72413
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+208
	cmp	DWORD PTR _ent$[ebp], eax
	jne	SHORT $L72412
$L72413:

; 1034 : 		return; // no decals for viewmodel

	jmp	$L72408
$L72412:

; 1035 : 
; 1036 : 	if( !StudioSetEntity( ent ))

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUcl_entity_s@@@Z ; CStudioModelRenderer::StudioSetEntity
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L72414

; 1037 : 		return;

	jmp	$L72408
$L72414:

; 1038 : 
; 1039 : 	if( m_pStudioHeader->numbodyparts == 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	cmp	DWORD PTR [edx+204], 0
	jne	SHORT $L72415

; 1040 : 		return;

	jmp	$L72408
$L72415:

; 1041 : 
; 1042 : 	tr.time = GET_CLIENT_TIME();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+216
	fstp	QWORD PTR ?tr@@3Uref_globals_t@@A+8

; 1043 : 	tr.oldtime = GET_CLIENT_OLDTIME();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+420
	fstp	QWORD PTR ?tr@@3Uref_globals_t@@A+16

; 1044 : 
; 1045 : 	// allocate new decallist
; 1046 : 	if( m_pModelInstance->m_DecalHandle == INVALID_HANDLE )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+8]
	cmp	edx, 65535				; 0000ffffH
	jne	SHORT $L72416

; 1047 : 		m_pModelInstance->m_DecalHandle = CreateDecalList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateDecalList@CStudioModelRenderer@@AAEGXZ ; CStudioModelRenderer::CreateDecalList
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	WORD PTR [edx+8], ax
$L72416:

; 1048 : 
; 1049 : 	m_fShootDecal = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+92], 1

; 1050 : 	m_fDoInterp = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 1051 : 
; 1052 : 	if( FBitSet( flags, FDECAL_LOCAL_SPACE ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 128				; 00000080H
	test	edx, edx
	je	SHORT $L72417

; 1054 : 		// make sure what model is in local space
; 1055 : 		m_pCurrentEntity->origin = g_vecZero;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	add	ecx, 2888				; 00000b48H
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [ecx+8], edx

; 1056 : 		m_pCurrentEntity->angles = g_vecZero;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	add	ecx, 2900				; 00000b54H
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [ecx+8], edx
$L72417:

; 1058 : 
; 1059 : 	// setup bones
; 1060 : 	StudioSetUpTransform ( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+20]

; 1061 : 	StudioSetupBones ( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+24]

; 1062 : 
; 1063 : 	// setup worldtransform array
; 1064 : 	if( m_pRenderModel->poseToBone != NULL )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	cmp	DWORD PTR [ecx+376], 0
	je	$L72418

; 1066 : 		for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$72419[ebp], 0
	jmp	SHORT $L72420
$L72421:
	mov	edx, DWORD PTR _i$72419[ebp]
	add	edx, 1
	mov	DWORD PTR _i$72419[ebp], edx
$L72420:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _i$72419[ebp]
	cmp	edx, DWORD PTR [ecx+140]
	jge	SHORT $L72422

; 1067 : 			m_pworldtransform[i] = m_pModelInstance->m_pbones[i].ConcatTransforms( m_pRenderModel->poseToBone->posetobone[i] );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	edx, DWORD PTR _i$72419[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR [ecx+376]
	add	eax, edx
	sub	esp, 48					; 00000030H
	mov	ecx, esp
	push	eax
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	ecx, DWORD PTR $T74554[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$72419[ebp]
	imul	ecx, 48					; 00000030H
	lea	ecx, DWORD PTR [eax+ecx+11548]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	esi, eax
	mov	edx, DWORD PTR _i$72419[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [eax+edx+1274076]
	mov	ecx, 12					; 0000000cH
	rep movsd
	jmp	SHORT $L72421
$L72422:

; 1069 : 	else

	jmp	SHORT $L72429
$L72418:

; 1071 : 		// no pose to bone just copy the bones
; 1072 : 		for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$72426[ebp], 0
	jmp	SHORT $L72427
$L72428:
	mov	ecx, DWORD PTR _i$72426[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$72426[ebp], ecx
$L72427:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _i$72426[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $L72429

; 1073 : 			m_pworldtransform[i] = m_pModelInstance->m_pbones[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$72426[ebp]
	imul	ecx, 48					; 00000030H
	lea	esi, DWORD PTR [eax+ecx+11548]
	mov	edx, DWORD PTR _i$72426[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [eax+edx+1274076]
	mov	ecx, 12					; 0000000cH
	rep movsd
	jmp	SHORT $L72428
$L72429:

; 1075 : 
; 1076 : 	for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72431
$L72432:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L72431:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $L72433

; 1077 : 		m_pworldtransform[i] = m_pModelInstance->m_protationmatrix.ConcatTransforms( m_pworldtransform[i] );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1274076]
	sub	esp, 48					; 00000030H
	mov	edx, esp
	push	ecx
	mov	ecx, edx
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	eax, DWORD PTR $T74556[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+19112]
	add	ecx, 11452				; 00002cbcH
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	esi, eax
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [eax+edx+1274076]
	mov	ecx, 12					; 0000000cH
	rep movsd
	jmp	SHORT $L72432
$L72433:

; 1078 : 
; 1079 : 	if( FBitSet( flags, FDECAL_LOCAL_SPACE ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 128				; 00000080H
	test	ecx, ecx
	je	SHORT $L72436

; 1081 : 		vecLocalSrc = vecSrc;

	mov	edx, DWORD PTR _vecSrc$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _vecLocalSrc$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _vecLocalSrc$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _vecLocalSrc$[ebp+8], edx

; 1082 : 		vecLocalEnd = vecEnd;

	mov	eax, DWORD PTR _vecEnd$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecLocalEnd$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecLocalEnd$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecLocalEnd$[ebp+8], eax

; 1084 : 	else

	jmp	SHORT $L72437
$L72436:

; 1086 : 		vecLocalSrc = m_pModelInstance->m_protationmatrix.VectorITransform( vecSrc );

	mov	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T74557[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 11452				; 00002cbcH
	call	?VectorITransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorITransform
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecLocalSrc$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecLocalSrc$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecLocalSrc$[ebp+8], eax

; 1087 : 		vecLocalEnd = m_pModelInstance->m_protationmatrix.VectorITransform( vecEnd );

	mov	ecx, DWORD PTR _vecEnd$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T74558[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 11452				; 00002cbcH
	call	?VectorITransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorITransform
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecLocalEnd$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecLocalEnd$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecLocalEnd$[ebp+8], eax

; 1088 : 		SetBits( flags, FDECAL_LOCAL_SPACE ); // now it's in local space

	mov	ecx, DWORD PTR _flags$[ebp]
	or	cl, -128				; ffffff80H
	mov	DWORD PTR _flags$[ebp], ecx
$L72437:

; 1090 : 
; 1091 : 	if( !ComputePoseToDecal( vecSrc, vecEnd ))

	mov	edx, DWORD PTR _vecEnd$[ebp]
	push	edx
	mov	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputePoseToDecal@CStudioModelRenderer@@AAE_NABVVector@@0@Z ; CStudioModelRenderer::ComputePoseToDecal
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L72440

; 1093 : 		m_fShootDecal = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+92], 0

; 1094 : 		m_fDoInterp = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], 1

; 1095 : 		return;

	jmp	$L72408
$L72440:

; 1097 : 
; 1098 : 	float w = (float)RENDER_GET_PARM( PARM_TEX_SRC_WIDTH, decalTexture ) * 0.5f;

	mov	eax, DWORD PTR _decalTexture$[ebp]
	push	eax
	push	3
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A
	add	esp, 8
	mov	DWORD PTR -288+[ebp], eax
	fild	DWORD PTR -288+[ebp]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fstp	DWORD PTR _w$[ebp]

; 1099 : 	float h = (float)RENDER_GET_PARM( PARM_TEX_SRC_HEIGHT, decalTexture ) * 0.5f;

	mov	ecx, DWORD PTR _decalTexture$[ebp]
	push	ecx
	push	4
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A
	add	esp, 8
	mov	DWORD PTR -292+[ebp], eax
	fild	DWORD PTR -292+[ebp]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fstp	DWORD PTR _h$[ebp]

; 1100 :  	float radius = Q_max( w, h ) * 0.5f; // scale decals so the look same as on world geometry

	fld	DWORD PTR _w$[ebp]
	fcomp	DWORD PTR _h$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L74559
	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR -296+[ebp], edx
	jmp	SHORT $L74560
$L74559:
	mov	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR -296+[ebp], eax
$L74560:
	fld	DWORD PTR -296+[ebp]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fstp	DWORD PTR _radius$[ebp]

; 1101 : 
; 1102 : 	// This sucker is state needed only when building decals
; 1103 : 	DecalBuildInfo_t buildInfo;

	lea	ecx, DWORD PTR _buildInfo$[ebp]
	call	??0DecalBuildInfo_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::DecalBuildInfo_t::DecalBuildInfo_t

; 1104 : 	memset( &buildInfo, 0, sizeof( buildInfo ));

	push	92					; 0000005cH
	push	0
	lea	ecx, DWORD PTR _buildInfo$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1105 : 	buildInfo.vecLocalStart = vecLocalSrc;

	mov	edx, DWORD PTR _vecLocalSrc$[ebp]
	mov	DWORD PTR _buildInfo$[ebp+24], edx
	mov	eax, DWORD PTR _vecLocalSrc$[ebp+4]
	mov	DWORD PTR _buildInfo$[ebp+28], eax
	mov	ecx, DWORD PTR _vecLocalSrc$[ebp+8]
	mov	DWORD PTR _buildInfo$[ebp+32], ecx

; 1106 : 	buildInfo.vecLocalEnd = vecLocalEnd;

	mov	edx, DWORD PTR _vecLocalEnd$[ebp]
	mov	DWORD PTR _buildInfo$[ebp+36], edx
	mov	eax, DWORD PTR _vecLocalEnd$[ebp+4]
	mov	DWORD PTR _buildInfo$[ebp+40], eax
	mov	ecx, DWORD PTR _vecLocalEnd$[ebp+8]
	mov	DWORD PTR _buildInfo$[ebp+44], ecx

; 1107 : 	buildInfo.m_UseClipVert = ( m_pStudioHeader->numbones <= 1 ); // produce clipped verts only for static props

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+140], 1
	setle	cl
	mov	BYTE PTR _buildInfo$[ebp+88], cl

; 1108 : 	buildInfo.decalDepth = m_pModelInstance->m_DecalCount++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _buildInfo$[ebp+20], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	DWORD PTR [eax+12], ecx

; 1109 : 	buildInfo.m_iDecalTexture = decalTexture;

	mov	ecx, DWORD PTR _decalTexture$[ebp]
	mov	DWORD PTR _buildInfo$[ebp+4], ecx

; 1110 : 	buildInfo.decalFlags = (byte)flags;

	mov	dl, BYTE PTR _flags$[ebp]
	mov	BYTE PTR _buildInfo$[ebp+48], dl

; 1111 : 	buildInfo.m_iDecalMaterial = -1;

	mov	DWORD PTR _buildInfo$[ebp], -1

; 1112 : 	buildInfo.modelState = state;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR _buildInfo$[ebp+12], eax

; 1113 : 	buildInfo.m_Radius = radius;

	mov	ecx, DWORD PTR _radius$[ebp]
	mov	DWORD PTR _buildInfo$[ebp+8], ecx

; 1114 : 
; 1115 : 	// special check for per-vertex lighting
; 1116 : 	if(( ent->curstate.iuser3 > 0 ) && world->vertex_lighting != NULL )

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+956], 0
	jle	SHORT $L72451
	mov	eax, DWORD PTR ?world@@3PAUgl_world_t@@A ; world
	cmp	DWORD PTR [eax+120], 0
	je	SHORT $L72451

; 1118 : 		int		cacheID = m_pCurrentEntity->curstate.iuser3 - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	eax, DWORD PTR [edx+956]
	sub	eax, 1
	mov	DWORD PTR _cacheID$72449[ebp], eax

; 1119 : 		dvlightlump_t	*dvl = world->vertex_lighting;

	mov	ecx, DWORD PTR ?world@@3PAUgl_world_t@@A ; world
	mov	edx, DWORD PTR [ecx+120]
	mov	DWORD PTR _dvl$72450[ebp], edx

; 1120 : 
; 1121 : 		if( cacheID < dvl->nummodels && dvl->dataofs[cacheID] != -1 )

	mov	eax, DWORD PTR _dvl$72450[ebp]
	mov	ecx, DWORD PTR _cacheID$72449[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $L72451
	mov	edx, DWORD PTR _cacheID$72449[ebp]
	mov	eax, DWORD PTR _dvl$72450[ebp]
	cmp	DWORD PTR [eax+edx*4+12], -1
	je	SHORT $L72451

; 1122 : 			buildInfo.modelLight = (dmodellight_t *)((byte *)world->vertex_lighting + dvl->dataofs[cacheID]);

	mov	ecx, DWORD PTR ?world@@3PAUgl_world_t@@A ; world
	mov	edx, DWORD PTR [ecx+120]
	mov	eax, DWORD PTR _cacheID$72449[ebp]
	mov	ecx, DWORD PTR _dvl$72450[ebp]
	add	edx, DWORD PTR [ecx+eax*4+12]
	mov	DWORD PTR _buildInfo$[ebp+16], edx
$L72451:

; 1124 : 
; 1125 : 	// step over all body parts + add decals to them all!
; 1126 : 	for( int k = 0; k < m_pStudioHeader->numbodyparts; k++ ) 

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L72455
$L72456:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$L72455:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR [ecx+204]
	jge	SHORT $L72457

; 1128 : 		// grab the model for this body part
; 1129 : 		buildInfo.m_Model = StudioSetupModel( k, (void **)&m_pBodyPart, (void **)&m_pSubModel );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 19132				; 00004abcH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 19128				; 00004ab8H
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+92]
	mov	DWORD PTR _buildInfo$[ebp+76], eax

; 1130 : 		buildInfo.m_Body = k;

	mov	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR _buildInfo$[ebp+68], eax

; 1131 : 		AddDecalToModel( buildInfo );

	lea	ecx, DWORD PTR _buildInfo$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddDecalToModel@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z ; CStudioModelRenderer::AddDecalToModel

; 1132 : 	}

	jmp	SHORT $L72456
$L72457:

; 1133 : 
; 1134 : 	// dump remainig vertices
; 1135 : 	CreateDecalForMaterial( buildInfo );

	lea	edx, DWORD PTR _buildInfo$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateDecalForMaterial@CStudioModelRenderer@@AAEXAAUDecalBuildInfo_t@1@@Z ; CStudioModelRenderer::CreateDecalForMaterial

; 1136 : 
; 1137 : 	m_fShootDecal = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+92], 0

; 1138 : 	m_fDoInterp = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 1
$L72408:

; 1139 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?StudioDecalShoot@CStudioModelRenderer@@QAEXABVVector@@0HPAUcl_entity_s@@HPAUmodelstate_s@@@Z ENDP ; CStudioModelRenderer::StudioDecalShoot
_TEXT	ENDS
;	COMDAT ??0DecalBuildInfo_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0DecalBuildInfo_t@CStudioModelRenderer@@QAE@XZ PROC NEAR ; CStudioModelRenderer::DecalBuildInfo_t::DecalBuildInfo_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0DecalBuildInfo_t@CStudioModelRenderer@@QAE@XZ ENDP	; CStudioModelRenderer::DecalBuildInfo_t::DecalBuildInfo_t
_TEXT	ENDS
PUBLIC	?ComputeDecalTransform@CStudioModelRenderer@@AAEXAAUDecalMaterial_t@1@QBVmatrix3x4@@@Z ; CStudioModelRenderer::ComputeDecalTransform
EXTRN	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix3x4::VectorTransform
EXTRN	?VectorRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix3x4::VectorRotate
;	COMDAT ?ComputeDecalTransform@CStudioModelRenderer@@AAEXAAUDecalMaterial_t@1@QBVmatrix3x4@@@Z
_TEXT	SEGMENT
_decalMaterial$ = 8
_bones$ = 12
_this$ = -4
_verts$ = -8
_skinMat$ = -56
_alpha$ = -60
_i$ = -64
_vertex$72475 = -68
_bone$72476 = -72
_bl$72482 = -84
_scale$72483 = -88
_map$72484 = -92
_vertexLight$72490 = -104
_vecNormal$72491 = -116
_lv$72492 = -120
_vertexLight$72496 = -132
_lv$72497 = -136
$T74565 = -148
$T74566 = -160
$T74573 = -172
$T74574 = -184
$T74575 = -196
?ComputeDecalTransform@CStudioModelRenderer@@AAEXAAUDecalMaterial_t@1@QBVmatrix3x4@@@Z PROC NEAR ; CStudioModelRenderer::ComputeDecalTransform, COMDAT

; 1142 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 	DecalVertexList_t& verts = decalMaterial.m_Vertices; 

	mov	eax, DWORD PTR _decalMaterial$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR _verts$[ebp], eax

; 1144 : 	m_nNumArrayVerts = m_nNumArrayElems = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344992], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+5344988], 0

; 1145 : 	matrix3x4	skinMat;

	lea	ecx, DWORD PTR _skinMat$[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 1146 : 	byte alpha = 255;

	mov	BYTE PTR _alpha$[ebp], 255		; 000000ffH

; 1147 : 
; 1148 : 	if( !R_ModelOpaque( m_pCurrentEntity->curstate.rendermode ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx+760], 0
	je	SHORT $L72470

; 1149 : 		alpha = m_pCurrentEntity->curstate.renderamt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	cl, BYTE PTR [eax+764]
	mov	BYTE PTR _alpha$[ebp], cl
$L72470:

; 1150 : 
; 1151 : 	for( word i = verts.Head(); i != verts.InvalidIndex(); i = verts.Next( i ))

	mov	ecx, DWORD PTR _verts$[ebp]
	call	?Head@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::Head
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $L72472
$L72473:
	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _verts$[ebp]
	call	?Next@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Next
	mov	WORD PTR _i$[ebp], ax
$L72472:
	mov	esi, DWORD PTR _i$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	$L72474

; 1153 : 		DecalVertex_t& vertex = verts[i];

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _verts$[ebp]
	call	??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::operator[]
	mov	DWORD PTR _vertex$72475[ebp], eax

; 1154 : 		int bone = vertex.m_BoneWeights.bone[0];

	mov	ecx, DWORD PTR _vertex$72475[ebp]
	movsx	edx, BYTE PTR [ecx+56]
	mov	DWORD PTR _bone$72476[ebp], edx

; 1155 : 
; 1156 : 		if( m_pRenderModel->poseToBone != NULL )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	cmp	DWORD PTR [ecx+376], 0
	je	SHORT $L72477

; 1158 : 			ComputeSkinMatrix( &vertex.m_BoneWeights, m_pworldtransform, skinMat );

	lea	edx, DWORD PTR _skinMat$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1274076				; 001370dcH
	push	eax
	mov	ecx, DWORD PTR _vertex$72475[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]

; 1159 : 			m_arrayverts[m_nNumArrayVerts] = skinMat.VectorTransform( vertex.m_Position );

	mov	ecx, DWORD PTR _vertex$72475[ebp]
	push	ecx
	lea	edx, DWORD PTR $T74565[ebp]
	push	edx
	lea	ecx, DWORD PTR _skinMat$[ebp]
	call	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorTransform
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	imul	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+edx+1674972]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1161 : 		else

	jmp	SHORT $L72479
$L72477:

; 1163 : 			m_arrayverts[m_nNumArrayVerts] = bones[bone].VectorTransform( vertex.m_Position );

	mov	ecx, DWORD PTR _vertex$72475[ebp]
	push	ecx
	lea	edx, DWORD PTR $T74566[ebp]
	push	edx
	mov	eax, DWORD PTR _bone$72476[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _bones$[ebp]
	add	ecx, eax
	call	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorTransform
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	imul	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+edx+1674972]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L72479:

; 1165 : 
; 1166 : 		if( FBitSet( m_pModelInstance->info_flags, MF_VERTEX_LIGHTING ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR [edx+16]
	and	eax, 2
	test	eax, eax
	je	$L72481

; 1168 : 			unsigned int	bl[3], scale;
; 1169 : 
; 1170 : 			bl[0] = bl[1] = bl[2] = 0;

	mov	DWORD PTR _bl$72482[ebp+8], 0
	mov	ecx, DWORD PTR _bl$72482[ebp+8]
	mov	DWORD PTR _bl$72482[ebp+4], ecx
	mov	edx, DWORD PTR _bl$72482[ebp+4]
	mov	DWORD PTR _bl$72482[ebp], edx

; 1171 : 
; 1172 : 			// add all the lightmaps
; 1173 : 			for( int map = 0; map < MAXLIGHTMAPS && m_pModelInstance->styles[map] != 255; map++ )

	mov	DWORD PTR _map$72484[ebp], 0
	jmp	SHORT $L72485
$L72486:
	mov	eax, DWORD PTR _map$72484[ebp]
	add	eax, 1
	mov	DWORD PTR _map$72484[ebp], eax
$L72485:
	cmp	DWORD PTR _map$72484[ebp], 4
	jge	$L72487
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _map$72484[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+eax+24]
	cmp	ecx, 255				; 000000ffH
	je	$L72487

; 1175 : 				scale = tr.lightstylevalue[m_pModelInstance->styles[map]];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _map$72484[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [eax+ecx+24]
	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A[edx*4+72056]
	mov	DWORD PTR _scale$72483[ebp], eax

; 1176 : 				bl[0] += TEXTURE_TO_TEXGAMMA( vertex.m_Light[map][0] ) * scale;

	mov	ecx, DWORD PTR _map$72484[ebp]
	imul	ecx, 3
	mov	edx, DWORD PTR _vertex$72475[ebp]
	mov	al, BYTE PTR [edx+ecx+40]
	push	eax
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+24
	add	esp, 4
	and	eax, 255				; 000000ffH
	imul	eax, DWORD PTR _scale$72483[ebp]
	mov	ecx, DWORD PTR _bl$72482[ebp]
	add	ecx, eax
	mov	DWORD PTR _bl$72482[ebp], ecx

; 1177 : 				bl[1] += TEXTURE_TO_TEXGAMMA( vertex.m_Light[map][1] ) * scale;

	mov	edx, DWORD PTR _map$72484[ebp]
	imul	edx, 3
	mov	eax, DWORD PTR _vertex$72475[ebp]
	mov	cl, BYTE PTR [eax+edx+41]
	push	ecx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+24
	add	esp, 4
	and	eax, 255				; 000000ffH
	imul	eax, DWORD PTR _scale$72483[ebp]
	mov	edx, DWORD PTR _bl$72482[ebp+4]
	add	edx, eax
	mov	DWORD PTR _bl$72482[ebp+4], edx

; 1178 : 				bl[2] += TEXTURE_TO_TEXGAMMA( vertex.m_Light[map][2] ) * scale;

	mov	eax, DWORD PTR _map$72484[ebp]
	imul	eax, 3
	mov	ecx, DWORD PTR _vertex$72475[ebp]
	mov	dl, BYTE PTR [ecx+eax+42]
	push	edx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+24
	add	esp, 4
	and	eax, 255				; 000000ffH
	imul	eax, DWORD PTR _scale$72483[ebp]
	mov	ecx, DWORD PTR _bl$72482[ebp+8]
	add	ecx, eax
	mov	DWORD PTR _bl$72482[ebp+8], ecx

; 1179 : 			}

	jmp	$L72486
$L72487:

; 1180 : 
; 1181 : 			m_arraycolor[m_nNumArrayVerts][0] = Q_min(( bl[0] >> 7 ), 255 );

	mov	edx, DWORD PTR _bl$72482[ebp]
	shr	edx, 7
	cmp	edx, 255				; 000000ffH
	jae	SHORT $L74567
	mov	eax, DWORD PTR _bl$72482[ebp]
	shr	eax, 7
	mov	DWORD PTR -200+[ebp], eax
	jmp	SHORT $L74568
$L74567:
	mov	DWORD PTR -200+[ebp], 255		; 000000ffH
$L74568:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR -200+[ebp]
	mov	BYTE PTR [eax+edx*4+3509980], cl

; 1182 : 			m_arraycolor[m_nNumArrayVerts][1] = Q_min(( bl[1] >> 7 ), 255 );

	mov	edx, DWORD PTR _bl$72482[ebp+4]
	shr	edx, 7
	cmp	edx, 255				; 000000ffH
	jae	SHORT $L74569
	mov	eax, DWORD PTR _bl$72482[ebp+4]
	shr	eax, 7
	mov	DWORD PTR -204+[ebp], eax
	jmp	SHORT $L74570
$L74569:
	mov	DWORD PTR -204+[ebp], 255		; 000000ffH
$L74570:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR -204+[ebp]
	mov	BYTE PTR [eax+edx*4+3509981], cl

; 1183 : 			m_arraycolor[m_nNumArrayVerts][2] = Q_min(( bl[2] >> 7 ), 255 );

	mov	edx, DWORD PTR _bl$72482[ebp+8]
	shr	edx, 7
	cmp	edx, 255				; 000000ffH
	jae	SHORT $L74571
	mov	eax, DWORD PTR _bl$72482[ebp+8]
	shr	eax, 7
	mov	DWORD PTR -208+[ebp], eax
	jmp	SHORT $L74572
$L74571:
	mov	DWORD PTR -208+[ebp], 255		; 000000ffH
$L74572:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR -208+[ebp]
	mov	BYTE PTR [eax+edx*4+3509982], cl

; 1185 : 		else if( m_pRenderModel->poseToBone != NULL )

	jmp	$L72495
$L72481:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	cmp	DWORD PTR [eax+376], 0
	je	$L72489

; 1187 : 			Vector vertexLight, vecNormal;

	lea	ecx, DWORD PTR _vertexLight$72490[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _vecNormal$72491[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1188 : 			float lv;
; 1189 : 
; 1190 : 			vecNormal = skinMat.VectorRotate( vertex.m_Normal );

	mov	ecx, DWORD PTR _vertex$72475[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	lea	edx, DWORD PTR $T74573[ebp]
	push	edx
	lea	ecx, DWORD PTR _skinMat$[ebp]
	call	?VectorRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorRotate
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecNormal$72491[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecNormal$72491[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecNormal$72491[ebp+8], eax

; 1191 : 			StudioLighting( &lv, -1, decalMaterial.flags, vecNormal );

	lea	ecx, DWORD PTR _vecNormal$72491[ebp]
	push	ecx
	mov	edx, DWORD PTR _decalMaterial$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	-1
	lea	ecx, DWORD PTR _lv$72492[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+108]

; 1192 : 			vertexLight = m_pModelInstance->lighting.color * lv;

	mov	ecx, DWORD PTR _lv$72492[ebp]
	push	ecx
	lea	edx, DWORD PTR $T74574[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 36					; 00000024H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vertexLight$72490[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vertexLight$72490[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vertexLight$72490[ebp+8], eax

; 1193 : 
; 1194 : 			m_arraycolor[m_nNumArrayVerts][0] = vertexLight.x * 255;

	fld	DWORD PTR _vertexLight$72490[ebp]
	fmul	DWORD PTR __real@4@4006ff00000000000000
	call	__ftol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx*4+3509980], al

; 1195 : 			m_arraycolor[m_nNumArrayVerts][1] = vertexLight.y * 255;

	fld	DWORD PTR _vertexLight$72490[ebp+4]
	fmul	DWORD PTR __real@4@4006ff00000000000000
	call	__ftol
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+5344988]
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx*4+3509981], al

; 1196 : 			m_arraycolor[m_nNumArrayVerts][2] = vertexLight.z * 255;

	fld	DWORD PTR _vertexLight$72490[ebp+8]
	fmul	DWORD PTR __real@4@4006ff00000000000000
	call	__ftol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx*4+3509982], al

; 1198 : 		else

	jmp	$L72495
$L72489:

; 1200 : 			Vector vertexLight;

	lea	ecx, DWORD PTR _vertexLight$72496[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1201 : 			float lv;
; 1202 : 
; 1203 : 			// NOTE: studiolights used local coordinates for bonelighting so we pass untransformed normal
; 1204 : 			StudioLighting( &lv, bone, decalMaterial.flags, vertex.m_Normal );

	mov	edx, DWORD PTR _vertex$72475[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _decalMaterial$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _bone$72476[ebp]
	push	edx
	lea	eax, DWORD PTR _lv$72497[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+108]

; 1205 : 			vertexLight = m_pModelInstance->lighting.color * lv;

	mov	eax, DWORD PTR _lv$72497[ebp]
	push	eax
	lea	ecx, DWORD PTR $T74575[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	add	ecx, 36					; 00000024H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vertexLight$72496[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vertexLight$72496[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vertexLight$72496[ebp+8], eax

; 1206 : 
; 1207 : 			m_arraycolor[m_nNumArrayVerts][0] = vertexLight.x * 255;

	fld	DWORD PTR _vertexLight$72496[ebp]
	fmul	DWORD PTR __real@4@4006ff00000000000000
	call	__ftol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx*4+3509980], al

; 1208 : 			m_arraycolor[m_nNumArrayVerts][1] = vertexLight.y * 255;

	fld	DWORD PTR _vertexLight$72496[ebp+4]
	fmul	DWORD PTR __real@4@4006ff00000000000000
	call	__ftol
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+5344988]
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx*4+3509981], al

; 1209 : 			m_arraycolor[m_nNumArrayVerts][2] = vertexLight.z * 255;

	fld	DWORD PTR _vertexLight$72496[ebp+8]
	fmul	DWORD PTR __real@4@4006ff00000000000000
	call	__ftol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx*4+3509982], al
$L72495:

; 1211 : 
; 1212 : 		m_arraycoord[m_nNumArrayVerts].x = vertex.m_TexCoord0.x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vertex$72475[ebp]
	mov	edx, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+eax+2461404], edx

; 1213 : 		m_arraycoord[m_nNumArrayVerts].y = vertex.m_TexCoord0.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vertex$72475[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+ecx+2461408], eax

; 1214 : 		m_arraycoord[m_nNumArrayVerts].z = vertex.m_TexCoord1.x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vertex$72475[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+edx+2461412], ecx

; 1215 : 		m_arraycoord[m_nNumArrayVerts].w = vertex.m_TexCoord1.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vertex$72475[ebp]
	mov	edx, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+eax+2461416], edx

; 1216 : 		m_arraycolor[m_nNumArrayVerts][3] = alpha; // fade decals when fade corpse 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _alpha$[ebp]
	mov	BYTE PTR [edx+ecx*4+3509983], al

; 1217 : 		m_nNumArrayVerts++;	

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5344988], edx

; 1218 : 	}

	jmp	$L72473
$L72474:

; 1219 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ComputeDecalTransform@CStudioModelRenderer@@AAEXAAUDecalMaterial_t@1@QBVmatrix3x4@@@Z ENDP ; CStudioModelRenderer::ComputeDecalTransform
_TEXT	ENDS
PUBLIC	?DrawDecalMaterial@CStudioModelRenderer@@AAEXAAUDecalMaterial_t@1@QBVmatrix3x4@@@Z ; CStudioModelRenderer::DrawDecalMaterial
PUBLIC	??A?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::operator[]
EXTRN	?pglDrawRangeElementsEXT@@3P6GXIIIHIPBX@ZA:DWORD ; pglDrawRangeElementsEXT
EXTRN	?pglDrawElements@@3P6GXIHIPBX@ZA:DWORD		; pglDrawElements
EXTRN	?r_stats@@3Uref_stats_t@@A:BYTE			; r_stats
EXTRN	?GL_Support@@YA_NH@Z:NEAR			; GL_Support
;	COMDAT ?DrawDecalMaterial@CStudioModelRenderer@@AAEXAAUDecalMaterial_t@1@QBVmatrix3x4@@@Z
_TEXT	SEGMENT
_decalMaterial$ = 8
_bones$ = 12
_this$ = -4
_indexCount$ = -8
_vertexCount$ = -12
_decal$ = -16
_indicesRemaining$ = -20
_vertexOffset$ = -24
_i$ = -28
?DrawDecalMaterial@CStudioModelRenderer@@AAEXAAUDecalMaterial_t@1@QBVmatrix3x4@@@Z PROC NEAR ; CStudioModelRenderer::DrawDecalMaterial, COMDAT

; 1225 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1226 : 	// It's possible for the index count to become zero due to decal retirement
; 1227 : 	int indexCount = decalMaterial.m_Indices.Count();

	mov	ecx, DWORD PTR _decalMaterial$[ebp]
	add	ecx, 16					; 00000010H
	call	?Count@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBEHXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Count
	mov	DWORD PTR _indexCount$[ebp], eax

; 1228 : 	if( indexCount == 0 ) return;

	cmp	DWORD PTR _indexCount$[ebp], 0
	jne	SHORT $L72505
	jmp	$L72503
$L72505:

; 1229 : 
; 1230 : 	int vertexCount = decalMaterial.m_Vertices.Count();

	mov	ecx, DWORD PTR _decalMaterial$[ebp]
	add	ecx, 36					; 00000024H
	call	?Count@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEHXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::Count
	mov	DWORD PTR _vertexCount$[ebp], eax

; 1231 : 
; 1232 : 	ComputeDecalTransform( decalMaterial, bones );

	mov	eax, DWORD PTR _bones$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decalMaterial$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeDecalTransform@CStudioModelRenderer@@AAEXAAUDecalMaterial_t@1@QBVmatrix3x4@@@Z ; CStudioModelRenderer::ComputeDecalTransform

; 1233 : 
; 1234 : 	// Set the indices
; 1235 : 	// This is a little tricky. Because we can retire decals, the indices
; 1236 : 	// for each decal start at 0. We output all the vertices in order of
; 1237 : 	// each decal, and then fix up the indices based on how many vertices
; 1238 : 	// we wrote out for the decals
; 1239 : 	word decal = decalMaterial.m_Decals.Head();

	mov	ecx, DWORD PTR _decalMaterial$[ebp]
	add	ecx, 64					; 00000040H
	call	?Head@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Head
	mov	WORD PTR _decal$[ebp], ax

; 1240 : 	int indicesRemaining = decalMaterial.m_Decals[decal].m_IndexCount;

	mov	dx, WORD PTR _decal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _decalMaterial$[ebp]
	add	ecx, 64					; 00000040H
	call	??A?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _indicesRemaining$[ebp], eax

; 1241 : 	int vertexOffset = 0;

	mov	DWORD PTR _vertexOffset$[ebp], 0

; 1242 : 
; 1243 : 	for( int i = 0; i < indexCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72511
$L72512:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L72511:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _indexCount$[ebp]
	jge	$L72513

; 1245 : 		m_arrayelems[m_nNumArrayElems] = decalMaterial.m_Indices[i] + vertexOffset; 

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decalMaterial$[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::operator[]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax]
	add	ecx, DWORD PTR _vertexOffset$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+eax*4+3772124], ecx

; 1246 : 		m_nNumArrayElems++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+5344992], ecx

; 1247 : 
; 1248 : 		if( --indicesRemaining <= 0 )

	mov	eax, DWORD PTR _indicesRemaining$[ebp]
	sub	eax, 1
	mov	DWORD PTR _indicesRemaining$[ebp], eax
	cmp	DWORD PTR _indicesRemaining$[ebp], 0
	jg	SHORT $L72515

; 1250 : 			vertexOffset += decalMaterial.m_Decals[decal].m_VertexCount;

	mov	cx, WORD PTR _decal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _decalMaterial$[ebp]
	add	ecx, 64					; 00000040H
	call	??A?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::operator[]
	mov	edx, DWORD PTR _vertexOffset$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vertexOffset$[ebp], edx

; 1251 : 			decal = decalMaterial.m_Decals.Next( decal ); 

	mov	ax, WORD PTR _decal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decalMaterial$[ebp]
	add	ecx, 64					; 00000040H
	call	?Next@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Next
	mov	WORD PTR _decal$[ebp], ax

; 1252 : 
; 1253 : 			if( decal != decalMaterial.m_Decals.InvalidIndex( ))

	mov	esi, DWORD PTR _decal$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L72515

; 1254 : 				indicesRemaining = decalMaterial.m_Decals[decal].m_IndexCount;

	mov	cx, WORD PTR _decal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _decalMaterial$[ebp]
	add	ecx, 64					; 00000040H
	call	??A?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _indicesRemaining$[ebp], edx
$L72515:

; 1256 : 	}

	jmp	$L72512
$L72513:

; 1257 : 
; 1258 : 	if( GL_Support( R_DRAW_RANGEELEMENTS_EXT ))

	push	9
	call	?GL_Support@@YA_NH@Z			; GL_Support
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L72516

; 1259 : 		pglDrawRangeElementsEXT( GL_TRIANGLES, 0, m_nNumArrayVerts, m_nNumArrayElems, GL_UNSIGNED_INT, m_arrayelems );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 3772124				; 00398edcH
	push	eax
	push	5125					; 00001405H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	push	ecx
	push	0
	push	4
	call	DWORD PTR ?pglDrawRangeElementsEXT@@3P6GXIIIHIPBX@ZA ; pglDrawRangeElementsEXT

; 1260 : 	else pglDrawElements( GL_TRIANGLES, m_nNumArrayElems, GL_UNSIGNED_INT, m_arrayelems );

	jmp	SHORT $L72517
$L72516:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 3772124				; 00398edcH
	push	edx
	push	5125					; 00001405H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	push	ecx
	push	4
	call	DWORD PTR ?pglDrawElements@@3P6GXIHIPBX@ZA ; pglDrawElements
$L72517:

; 1261 : 
; 1262 : 	r_stats.c_total_tris += (m_nNumArrayElems / 3);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	edx, DWORD PTR ?r_stats@@3Uref_stats_t@@A+52
	add	edx, eax
	mov	DWORD PTR ?r_stats@@3Uref_stats_t@@A+52, edx

; 1263 : 	r_stats.num_flushes++;

	mov	eax, DWORD PTR ?r_stats@@3Uref_stats_t@@A+76
	add	eax, 1
	mov	DWORD PTR ?r_stats@@3Uref_stats_t@@A+76, eax
$L72503:

; 1264 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?DrawDecalMaterial@CStudioModelRenderer@@AAEXAAUDecalMaterial_t@1@QBVmatrix3x4@@@Z ENDP ; CStudioModelRenderer::DrawDecalMaterial
_TEXT	ENDS
PUBLIC	?DrawDecal@CStudioModelRenderer@@AAEXPAUcl_entity_s@@@Z ; CStudioModelRenderer::DrawDecal
PUBLIC	?__LINE__Var@?1??DrawDecal@CStudioModelRenderer@@AAEXPAUcl_entity_s@@@Z@4FA ; `CStudioModelRenderer::DrawDecal'::`2'::__LINE__Var
EXTRN	?VectorIRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix3x4::VectorIRotate
EXTRN	?pglBlendFunc@@3P6GXII@ZA:DWORD			; pglBlendFunc
EXTRN	?glsl_programs@@3PAUglsl_prog_s@@A:BYTE		; glsl_programs
EXTRN	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z:NEAR	; GL_BindShader
EXTRN	?pglVertexPointer@@3P6GXHIHPBX@ZA:DWORD		; pglVertexPointer
EXTRN	?pglColorPointer@@3P6GXHIHPBX@ZA:DWORD		; pglColorPointer
EXTRN	?pglTexCoordPointer@@3P6GXHIHPBX@ZA:DWORD	; pglTexCoordPointer
EXTRN	?pglDisable@@3P6GXI@ZA:DWORD			; pglDisable
EXTRN	?pglDisableClientState@@3P6GXI@ZA:DWORD		; pglDisableClientState
EXTRN	?pglEnable@@3P6GXI@ZA:DWORD			; pglEnable
EXTRN	?pglEnableClientState@@3P6GXI@ZA:DWORD		; pglEnableClientState
EXTRN	?pglUniform4fARB@@3P6GXHMMMM@ZA:DWORD		; pglUniform4fARB
EXTRN	?pglPolygonOffset@@3P6GXMM@ZA:DWORD		; pglPolygonOffset
EXTRN	?RI@@3PAUref_instance_t@@A:DWORD		; RI
EXTRN	?r_polyoffset@@3PAUcvar_s@@A:DWORD		; r_polyoffset
EXTRN	?glConfig@@3UglConfig_t@@A:BYTE			; glConfig
EXTRN	?GL_Cull@@YAXI@Z:NEAR				; GL_Cull
EXTRN	?GL_DepthMask@@YAXH@Z:NEAR			; GL_DepthMask
EXTRN	?GL_AlphaTest@@YAXH@Z:NEAR			; GL_AlphaTest
EXTRN	?GL_Blend@@YAXH@Z:NEAR				; GL_Blend
;	COMDAT ?__LINE__Var@?1??DrawDecal@CStudioModelRenderer@@AAEXPAUcl_entity_s@@@Z@4FA
; File z:\xashxtsrc\client\render\r_studiodecal.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DrawDecal@CStudioModelRenderer@@AAEXPAUcl_entity_s@@@Z@4FA DW 04f6H ; `CStudioModelRenderer::DrawDecal'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?DrawDecal@CStudioModelRenderer@@AAEXPAUcl_entity_s@@@Z
_TEXT	SEGMENT
_e$ = 8
_this$ = -4
_inst$ = -8
_list$ = -12
_m$ = -16
_i$72529 = -20
$T74581 = -104
$T74582 = -116
_i$72536 = -24
_i$72541 = -28
_decalTexture$ = -32
_modelTexture$ = -36
_hLastShader$ = -40
_mat$ = -44
_decalMaterial$72554 = -48
_valid$72555 = -52
?DrawDecal@CStudioModelRenderer@@AAEXPAUcl_entity_s@@@Z PROC NEAR ; CStudioModelRenderer::DrawDecal, COMDAT

; 1270 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1271 : 	if( e->modelhandle == INVALID_HANDLE )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+2960], 65535		; 0000ffffH
	jne	SHORT $L72522

; 1272 : 		return;

	jmp	$L72521
$L72522:

; 1273 : 
; 1274 : 	ModelInstance_t *inst = &m_ModelInstances[e->modelhandle];

	mov	ecx, DWORD PTR _e$[ebp]
	mov	dx, WORD PTR [ecx+2960]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	DWORD PTR _inst$[ebp], eax

; 1275 : 
; 1276 : 	if( inst->visframe != tr.realframecount )

	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR [eax+34088]
	cmp	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1411992
	je	SHORT $L72524

; 1277 : 		return;	// model is culled

	jmp	$L72521
$L72524:

; 1278 : 
; 1279 : 	if( inst->m_DecalHandle == INVALID_HANDLE )

	mov	edx, DWORD PTR _inst$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+8]
	cmp	eax, 65535				; 0000ffffH
	jne	SHORT $L72525

; 1280 : 		return;	// no decals for this model

	jmp	$L72521
$L72525:

; 1281 : 
; 1282 : 	// All decal vertex data is are stored in pose space
; 1283 : 	// So as long as the pose-to-world transforms are set, we're all ready!
; 1284 : 
; 1285 : 	// Get the decal list for this lod
; 1286 : 	DecalModelList_t const& list = m_DecalList[inst->m_DecalHandle];

	mov	ecx, DWORD PTR _inst$[ebp]
	mov	dx, WORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::operator[]
	mov	DWORD PTR _list$[ebp], eax

; 1287 : 
; 1288 : 	mposetobone_t *m = m_pRenderModel->poseToBone;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	edx, DWORD PTR [ecx+376]
	mov	DWORD PTR _m$[ebp], edx

; 1289 : 
; 1290 : 	// setup bone transform
; 1291 : 	if( m != NULL )

	cmp	DWORD PTR _m$[ebp], 0
	je	SHORT $L72528

; 1293 : 		for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$72529[ebp], 0
	jmp	SHORT $L72530
$L72531:
	mov	eax, DWORD PTR _i$72529[ebp]
	add	eax, 1
	mov	DWORD PTR _i$72529[ebp], eax
$L72530:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$72529[ebp]
	cmp	eax, DWORD PTR [edx+140]
	jge	SHORT $L72532

; 1294 : 			m_pworldtransform[i] = m_pModelInstance->m_pbones[i].ConcatTransforms( m->posetobone[i] );

	mov	ecx, DWORD PTR _i$72529[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _m$[ebp]
	add	edx, ecx
	sub	esp, 48					; 00000030H
	mov	ecx, esp
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	eax, DWORD PTR $T74581[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$72529[ebp]
	imul	eax, 48					; 00000030H
	lea	ecx, DWORD PTR [edx+eax+11548]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	esi, eax
	mov	ecx, DWORD PTR _i$72529[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [edx+ecx+1274076]
	mov	ecx, 12					; 0000000cH
	rep movsd
	jmp	SHORT $L72531
$L72532:

; 1296 : 	else

	jmp	SHORT $L72539
$L72528:

; 1298 : 		// no pose to bone just copy the bones
; 1299 : 		for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$72536[ebp], 0
	jmp	SHORT $L72537
$L72538:
	mov	eax, DWORD PTR _i$72536[ebp]
	add	eax, 1
	mov	DWORD PTR _i$72536[ebp], eax
$L72537:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$72536[ebp]
	cmp	eax, DWORD PTR [edx+140]
	jge	SHORT $L72539

; 1300 : 			m_pworldtransform[i] = m_pModelInstance->m_pbones[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$72536[ebp]
	imul	eax, 48					; 00000030H
	lea	esi, DWORD PTR [edx+eax+11548]
	mov	ecx, DWORD PTR _i$72536[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [edx+ecx+1274076]
	mov	ecx, 12					; 0000000cH
	rep movsd
	jmp	SHORT $L72538
$L72539:

; 1302 : 
; 1303 : 	// setup bone lighting
; 1304 : 	if( !m_pRenderModel->poseToBone && !FBitSet( m_pModelInstance->info_flags, MF_VERTEX_LIGHTING ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	cmp	DWORD PTR [ecx+376], 0
	jne	SHORT $L72544
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 2
	test	ecx, ecx
	jne	SHORT $L72544

; 1306 : 		for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$72541[ebp], 0
	jmp	SHORT $L72542
$L72543:
	mov	edx, DWORD PTR _i$72541[ebp]
	add	edx, 1
	mov	DWORD PTR _i$72541[ebp], edx
$L72542:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _i$72541[ebp]
	cmp	edx, DWORD PTR [ecx+140]
	jge	SHORT $L72544

; 1307 : 			m_bonelightvecs[i] = m_pworldtransform[i].VectorIRotate( inst->lighting.plightvec );

	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	lea	ecx, DWORD PTR $T74582[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$72541[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1274076]
	call	?VectorIRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorIRotate
	mov	ecx, DWORD PTR _i$72541[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+1280220]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $L72543
$L72544:

; 1309 : 
; 1310 : 	GL_Blend( GL_TRUE );

	push	1
	call	?GL_Blend@@YAXH@Z			; GL_Blend
	add	esp, 4

; 1311 : 	pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR ?pglBlendFunc@@3P6GXII@ZA	; pglBlendFunc

; 1312 : 
; 1313 : 	if( CVAR_TO_BOOL( r_polyoffset ))

	cmp	DWORD PTR ?r_polyoffset@@3PAUcvar_s@@A, 0 ; r_polyoffset
	je	SHORT $L74583
	mov	ecx, DWORD PTR ?r_polyoffset@@3PAUcvar_s@@A ; r_polyoffset
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L74583
	mov	BYTE PTR -120+[ebp], 1
	jmp	SHORT $L74584
$L74583:
	mov	BYTE PTR -120+[ebp], 0
$L74584:
	mov	edx, DWORD PTR -120+[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72546

; 1315 : 		pglEnable( GL_POLYGON_OFFSET_FILL );

	push	32823					; 00008037H
	call	DWORD PTR ?pglEnable@@3P6GXI@ZA		; pglEnable

; 1316 : 		pglPolygonOffset( -1.0f, -r_polyoffset->value );

	mov	eax, DWORD PTR ?r_polyoffset@@3PAUcvar_s@@A ; r_polyoffset
	fld	DWORD PTR [eax+12]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	push	-1082130432				; bf800000H
	call	DWORD PTR ?pglPolygonOffset@@3P6GXMM@ZA	; pglPolygonOffset
$L72546:

; 1318 : 
; 1319 : 	GL_DepthMask( GL_FALSE );

	push	0
	call	?GL_DepthMask@@YAXH@Z			; GL_DepthMask
	add	esp, 4

; 1320 : 	GL_AlphaTest( GL_FALSE );

	push	0
	call	?GL_AlphaTest@@YAXH@Z			; GL_AlphaTest
	add	esp, 4

; 1321 : 
; 1322 : 	GL_SelectTexture( GL_TEXTURE0 ); // keep texcoords at 0-th unit

	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+136
	add	esp, 4

; 1323 : 	pglEnableClientState( GL_TEXTURE_COORD_ARRAY );

	push	32888					; 00008078H
	call	DWORD PTR ?pglEnableClientState@@3P6GXI@ZA ; pglEnableClientState

; 1324 : 	pglTexCoordPointer( 4, GL_FLOAT, 16, m_arraycoord );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2461404				; 00258edcH
	push	ecx
	push	16					; 00000010H
	push	5126					; 00001406H
	push	4
	call	DWORD PTR ?pglTexCoordPointer@@3P6GXHIHPBX@ZA ; pglTexCoordPointer

; 1325 : 
; 1326 : 	pglEnableClientState( GL_COLOR_ARRAY );

	push	32886					; 00008076H
	call	DWORD PTR ?pglEnableClientState@@3P6GXI@ZA ; pglEnableClientState

; 1327 : 	pglColorPointer( 4, GL_UNSIGNED_BYTE, 0, m_arraycolor );

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 3509980				; 00358edcH
	push	edx
	push	0
	push	5121					; 00001401H
	push	4
	call	DWORD PTR ?pglColorPointer@@3P6GXHIHPBX@ZA ; pglColorPointer

; 1328 : 
; 1329 : 	pglEnableClientState( GL_VERTEX_ARRAY );

	push	32884					; 00008074H
	call	DWORD PTR ?pglEnableClientState@@3P6GXI@ZA ; pglEnableClientState

; 1330 : 	pglVertexPointer( 3, GL_FLOAT, 12, m_arrayverts );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1674972				; 00198edcH
	push	eax
	push	12					; 0000000cH
	push	5126					; 00001406H
	push	3
	call	DWORD PTR ?pglVertexPointer@@3P6GXHIHPBX@ZA ; pglVertexPointer

; 1331 : 
; 1332 : 	int decalTexture = -1;

	mov	DWORD PTR _decalTexture$[ebp], -1

; 1333 : 	int modelTexture = -1;

	mov	DWORD PTR _modelTexture$[ebp], -1

; 1334 : 	word hLastShader = -1;

	mov	WORD PTR _hLastShader$[ebp], 65535	; 0000ffffH

; 1335 : 
; 1336 : 	// Draw each set of decals using a particular material
; 1337 : 	for( word mat = list.m_FirstMaterial; mat != m_DecalMaterial.InvalidIndex(); mat = m_DecalMaterial.Next( mat ))

	mov	ecx, DWORD PTR _list$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR _mat$[ebp], dx
	jmp	SHORT $L72551
$L72552:
	mov	ax, WORD PTR _mat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Next@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Next
	mov	WORD PTR _mat$[ebp], ax
$L72551:
	mov	esi, DWORD PTR _mat$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	$L72553

; 1339 : 		DecalMaterial_t& decalMaterial = m_DecalMaterial[mat];

	mov	cx, WORD PTR _mat$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::operator[]
	mov	DWORD PTR _decalMaterial$72554[ebp], eax

; 1340 : 		bool valid = FBitSet( decalMaterial.flags, STUDIO_NF_NODRAW ) ? false : true;

	mov	edx, DWORD PTR _decalMaterial$72554[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 65536				; 00010000H
	test	eax, eax
	sete	cl
	mov	BYTE PTR _valid$72555[ebp], cl

; 1341 : 
; 1342 : 		// NOTE: even if shader was failed we can draw the decals with some limitations
; 1343 : 		if( valid && (( mat == list.m_FirstMaterial ) || ( RI->currentshader != &glsl_programs[decalMaterial.hProgram] )))

	mov	edx, DWORD PTR _valid$72555[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	$L72556
	mov	eax, DWORD PTR _mat$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _list$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx]
	cmp	eax, edx
	je	SHORT $L72557
	mov	eax, DWORD PTR _decalMaterial$72554[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax]
	imul	ecx, 876				; 0000036cH
	add	ecx, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [edx+28], ecx
	je	$L72556
$L72557:

; 1345 : 			GL_BindShader( &glsl_programs[decalMaterial.hProgram] );			

	mov	eax, DWORD PTR _decalMaterial$72554[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax]
	imul	ecx, 876				; 0000036cH
	add	ecx, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	push	ecx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 1346 : 			ASSERT( RI->currentshader != NULL );

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $L72559
	movsx	eax, WORD PTR ?__LINE__Var@?1??DrawDecal@CStudioModelRenderer@@AAEXPAUcl_entity_s@@@Z@4FA ; `CStudioModelRenderer::DrawDecal'::`2'::__LINE__Var
	add	eax, 76					; 0000004cH
	push	eax
	push	OFFSET FLAT:??_C@_0CN@MAOK@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72559:

; 1347 : 			pglUniform4fARB( RI->currentshader->u_FogParams, tr.fogColor[0], tr.fogColor[1], tr.fogColor[2], tr.fogDensity );

	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1411972
	push	ecx
	mov	ecx, OFFSET FLAT:?tr@@3Uref_globals_t@@A+1411960
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax+8]
	push	edx
	mov	ecx, OFFSET FLAT:?tr@@3Uref_globals_t@@A+1411960
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, OFFSET FLAT:?tr@@3Uref_globals_t@@A+1411960
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+768]
	push	ecx
	call	DWORD PTR ?pglUniform4fARB@@3P6GXHMMMM@ZA ; pglUniform4fARB
$L72556:

; 1349 : 
; 1350 : 		if(( decalTexture != decalMaterial.decalTexture ) || ( modelTexture != decalMaterial.modelTexture ))

	mov	edx, DWORD PTR _decalMaterial$72554[ebp]
	mov	eax, DWORD PTR _decalTexture$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $L72561
	mov	ecx, DWORD PTR _decalMaterial$72554[ebp]
	mov	edx, DWORD PTR _modelTexture$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $L72560
$L72561:

; 1352 : 			// bind the decal texture
; 1353 : 			GL_Bind( GL_TEXTURE0, decalMaterial.decalTexture );

	mov	eax, DWORD PTR _decalMaterial$72554[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+132
	add	esp, 8

; 1354 : 			if( valid ) GL_Bind( GL_TEXTURE1, decalMaterial.modelTexture );

	mov	edx, DWORD PTR _valid$72555[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72562
	mov	eax, DWORD PTR _decalMaterial$72554[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	1
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+132
	add	esp, 8
$L72562:

; 1355 : 			decalTexture = decalMaterial.decalTexture;

	mov	edx, DWORD PTR _decalMaterial$72554[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _decalTexture$[ebp], eax

; 1356 : 			modelTexture = decalMaterial.modelTexture;

	mov	ecx, DWORD PTR _decalMaterial$72554[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _modelTexture$[ebp], edx
$L72560:

; 1358 : 
; 1359 : 		// adjust the cull state
; 1360 : 		if( valid && FBitSet( decalMaterial.flags, STUDIO_NF_HAS_ALPHA ))

	mov	eax, DWORD PTR _valid$72555[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L72563
	mov	ecx, DWORD PTR _decalMaterial$72554[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 524288				; 00080000H
	test	edx, edx
	je	SHORT $L72563

; 1361 : 			GL_Cull( GL_NONE );

	push	0
	call	?GL_Cull@@YAXI@Z			; GL_Cull
	add	esp, 4

; 1362 : 		else GL_Cull( GL_FRONT );

	jmp	SHORT $L72564
$L72563:
	push	1028					; 00000404H
	call	?GL_Cull@@YAXI@Z			; GL_Cull
	add	esp, 4
$L72564:

; 1363 : 
; 1364 : 		DrawDecalMaterial( decalMaterial, m_pworldtransform );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1274076				; 001370dcH
	push	eax
	mov	ecx, DWORD PTR _decalMaterial$72554[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawDecalMaterial@CStudioModelRenderer@@AAEXAAUDecalMaterial_t@1@QBVmatrix3x4@@@Z ; CStudioModelRenderer::DrawDecalMaterial

; 1365 : 	}

	jmp	$L72552
$L72553:

; 1366 : 
; 1367 : 	pglDisableClientState( GL_TEXTURE_COORD_ARRAY );

	push	32888					; 00008078H
	call	DWORD PTR ?pglDisableClientState@@3P6GXI@ZA ; pglDisableClientState

; 1368 : 	pglDisableClientState( GL_VERTEX_ARRAY );

	push	32884					; 00008074H
	call	DWORD PTR ?pglDisableClientState@@3P6GXI@ZA ; pglDisableClientState

; 1369 : 	pglDisableClientState( GL_COLOR_ARRAY );

	push	32886					; 00008076H
	call	DWORD PTR ?pglDisableClientState@@3P6GXI@ZA ; pglDisableClientState

; 1370 : 	if( CVAR_TO_BOOL( r_polyoffset ))

	cmp	DWORD PTR ?r_polyoffset@@3PAUcvar_s@@A, 0 ; r_polyoffset
	je	SHORT $L74585
	mov	edx, DWORD PTR ?r_polyoffset@@3PAUcvar_s@@A ; r_polyoffset
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L74585
	mov	BYTE PTR -124+[ebp], 1
	jmp	SHORT $L74586
$L74585:
	mov	BYTE PTR -124+[ebp], 0
$L74586:
	mov	eax, DWORD PTR -124+[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L72565

; 1371 : 		pglDisable( GL_POLYGON_OFFSET_FILL );

	push	32823					; 00008037H
	call	DWORD PTR ?pglDisable@@3P6GXI@ZA	; pglDisable
$L72565:

; 1372 : 	GL_SelectTexture( glConfig.max_texture_units - 1 ); // force to cleanup all the units

	mov	ecx, DWORD PTR ?glConfig@@3UglConfig_t@@A+40
	sub	ecx, 1
	push	ecx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+136
	add	esp, 4

; 1373 : 	GL_CleanUpTextureUnits( 0 );

	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+148
	add	esp, 4

; 1374 : 	GL_Cull( GL_FRONT );

	push	1028					; 00000404H
	call	?GL_Cull@@YAXI@Z			; GL_Cull
	add	esp, 4
$L72521:

; 1375 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DrawDecal@CStudioModelRenderer@@AAEXPAUcl_entity_s@@@Z ENDP ; CStudioModelRenderer::DrawDecal
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex, COMDAT

; 100  : 	inline static I  InvalidIndex()  { return INVALID_LLIST_IDX; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	or	ax, 65535				; 0000ffffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex, COMDAT

; 100  : 	inline static I  InvalidIndex()  { return INVALID_LLIST_IDX; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	or	ax, 65535				; 0000ffffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex, COMDAT

; 100  : 	inline static I  InvalidIndex()  { return INVALID_LLIST_IDX; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	or	ax, 65535				; 0000ffffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@GH@@QAEAAGH@Z			; CUtlMemory<unsigned short,int>::operator[]
;	COMDAT ??A?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z PROC NEAR	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@GH@@QAEAAGH@Z		; CUtlMemory<unsigned short,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ENDP	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBEHXZ PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBEHXZ ENDP	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Count
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base
PUBLIC	?InsertBefore@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHHABG@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::InsertBefore
PUBLIC	??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
PUBLIC	??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT
??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ DB '('
	DB	'Base() == NULL) || (&src < Base()) || (&src >= (Base() + Coun'
	DB	't()) )', 00H				; `string'
CONST	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHABG@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHABG@Z PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base
	test	eax, eax
	je	SHORT $L74599
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L74599
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBEHXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Count
	lea	eax, DWORD PTR [esi+eax*2]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L74599
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74599:

; 520  : 	return InsertBefore( m_Size, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHHABG@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHABG@Z ENDP ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::AddToTail
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element
PUBLIC	?ShiftElementsLeft@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXHH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ShiftElementsLeft
PUBLIC	??_C@_09OHNN@elem?5?$DO?$DN?50?$AA@		; `string'
PUBLIC	??_C@_0BG@MFGO@elem?5?$CL?5num?5?$DM?$DN?5Count?$CI?$CJ?$AA@ ; `string'
PUBLIC	?Destruct@@YAXPAG@Z				; Destruct
;	COMDAT ??_C@_09OHNN@elem?5?$DO?$DN?50?$AA@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_09OHNN@elem?5?$DO?$DN?50?$AA@ DB 'elem >= 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MFGO@elem?5?$CL?5num?5?$DM?$DN?5Count?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BG@MFGO@elem?5?$CL?5num?5?$DM?$DN?5Count?$CI?$CJ?$AA@ DB 'elem + n'
	DB	'um <= Count()', 00H				; `string'
CONST	ENDS
;	COMDAT ?RemoveMultiple@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_i$ = -8
?RemoveMultiple@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXHH@Z PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::RemoveMultiple, COMDAT

; 713  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 714  : 	assert( elem >= 0 );

	cmp	DWORD PTR _elem$[ebp], 0
	jge	SHORT $L74602
	push	714					; 000002caH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_09OHNN@elem?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74602:

; 715  : 	assert( elem + num <= Count() );

	mov	esi, DWORD PTR _elem$[ebp]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBEHXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Count
	cmp	esi, eax
	jle	SHORT $L74603
	push	715					; 000002cbH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0BG@MFGO@elem?5?$CL?5num?5?$DM?$DN?5Count?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74603:

; 716  : 
; 717  : 	for (int i = elem + num; --i >= elem; )

	mov	edx, DWORD PTR _elem$[ebp]
	add	edx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _i$[ebp], edx
$L72626:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _elem$[ebp]
	jl	SHORT $L72627

; 718  : 		Destruct(&Element(i));

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element
	push	eax
	call	?Destruct@@YAXPAG@Z			; Destruct
	add	esp, 4
	jmp	SHORT $L72626
$L72627:

; 719  : 
; 720  : 	ShiftElementsLeft(elem, num);

	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsLeft@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXHH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ShiftElementsLeft

; 721  : 	m_Size -= num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 722  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?RemoveMultiple@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXHH@Z ENDP ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::RemoveMultiple
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::operator[], COMDAT

; 213  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]

; 215  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::operator[]
_TEXT	ENDS
PUBLIC	?InsertBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGGABUDecalVertex_t@@@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InsertBefore
;	COMDAT ?AddToTail@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGABUDecalVertex_t@@@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGABUDecalVertex_t@@@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::AddToTail, COMDAT

; 478  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 479  : 	return InsertBefore( InvalidIndex(), src ); 

	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGGABUDecalVertex_t@@@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InsertBefore

; 480  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGABUDecalVertex_t@@@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::AddToTail
_TEXT	ENDS
PUBLIC	?InsertBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InsertBefore
;	COMDAT ?AddToTail@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4
?AddToTail@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGXZ PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::AddToTail, COMDAT

; 431  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	return InsertBefore( InvalidIndex() ); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InsertBefore

; 433  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddToTail@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGXZ ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::AddToTail
_TEXT	ENDS
PUBLIC	?Free@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Free
;	COMDAT ?Remove@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
?Remove@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::Remove, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	Free( elem );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Free

; 519  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::Remove
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEHXZ PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::Count, COMDAT

; 229  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 	return m_ElementCount; 

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+18]
	mov	eax, ecx

; 231  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEHXZ ENDP	; CUtlLinkedList<DecalVertex_t,unsigned short>::Count
_TEXT	ENDS
;	COMDAT ?Head@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
?Head@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGXZ PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::Head, COMDAT

; 246  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 	return m_Head; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+12]

; 248  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Head@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGXZ ENDP	; CUtlLinkedList<DecalVertex_t,unsigned short>::Head
_TEXT	ENDS
PUBLIC	?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsValidIndex
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
PUBLIC	??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
PUBLIC	??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@	; `string'
;	COMDAT ??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@
; File z:\xashxtsrc\game_shared\utllinkedlist.h
CONST	SEGMENT
??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utllinkedlist.h', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@ DB 'IsValidIndex(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ?Next@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Next@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::Next, COMDAT

; 265  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 266  : 	assert( IsValidIndex(i) ); 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74618
	push	266					; 0000010aH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74618:

; 267  : 	return InternalElement(i).m_Next; 

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	ax, WORD PTR [eax+66]

; 268  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Next@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z ENDP	; CUtlLinkedList<DecalVertex_t,unsigned short>::Next
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ??A?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::operator[], COMDAT

; 213  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]

; 215  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::operator[]
_TEXT	ENDS
PUBLIC	?InsertBefore@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEGG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InsertBefore
;	COMDAT ?AddToTail@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4
?AddToTail@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::AddToTail, COMDAT

; 431  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	return InsertBefore( InvalidIndex() ); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEGG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InsertBefore

; 433  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddToTail@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::AddToTail
_TEXT	ENDS
PUBLIC	?Free@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Free
;	COMDAT ?Remove@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
?Remove@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Remove, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	Free( elem );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Free

; 519  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Remove
_TEXT	ENDS
;	COMDAT ?Head@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
?Head@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Head, COMDAT

; 246  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 	return m_Head; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+12]

; 248  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Head@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Head
_TEXT	ENDS
PUBLIC	?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsValidIndex
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
;	COMDAT ?Next@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Next@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Next, COMDAT

; 265  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 266  : 	assert( IsValidIndex(i) ); 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74629
	push	266					; 0000010aH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74629:

; 267  : 	return InternalElement(i).m_Next; 

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	ax, WORD PTR [eax+74]

; 268  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Next@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Next
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ??A?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::operator[], COMDAT

; 213  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]

; 215  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::operator[]
_TEXT	ENDS
PUBLIC	?InsertBefore@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InsertBefore
PUBLIC	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
;	COMDAT ?AddToTail@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4
?AddToTail@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::AddToTail, COMDAT

; 431  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	return InsertBefore( InvalidIndex() ); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InsertBefore

; 433  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddToTail@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::AddToTail
_TEXT	ENDS
PUBLIC	?Free@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Free
;	COMDAT ?Remove@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
?Remove@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Remove, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	Free( elem );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Free

; 519  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Remove
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEHXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Count, COMDAT

; 229  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 	return m_ElementCount; 

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+18]
	mov	eax, ecx

; 231  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEHXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Count
_TEXT	ENDS
;	COMDAT ?Head@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
?Head@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Head, COMDAT

; 246  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 	return m_Head; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+12]

; 248  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Head@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Head
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::operator[], COMDAT

; 213  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]

; 215  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::operator[]
_TEXT	ENDS
PUBLIC	?Free@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Free
;	COMDAT ?Remove@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
?Remove@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Remove, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	Free( elem );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Free

; 519  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Remove
_TEXT	ENDS
PUBLIC	?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z ; Construct
PUBLIC	?Element@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Element
PUBLIC	?AllocInternal@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEG_N@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::AllocInternal
;	COMDAT ?Alloc@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEG_N@Z
_TEXT	SEGMENT
_multilist$ = 8
_this$ = -4
_elem$ = -8
?Alloc@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEG_N@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Alloc, COMDAT

; 370  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 371  : 	I elem = AllocInternal( multilist );

	mov	al, BYTE PTR _multilist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocInternal@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEG_N@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::AllocInternal
	mov	WORD PTR _elem$[ebp], ax

; 372  : 	Construct( &Element(elem) );

	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Element
	push	eax
	call	?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z ; Construct
	add	esp, 4

; 373  : 
; 374  : 	return elem;

	mov	ax, WORD PTR _elem$[ebp]

; 375  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Alloc@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEG_N@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Alloc
_TEXT	ENDS
PUBLIC	??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@	; `string'
PUBLIC	?Unlink@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Unlink
PUBLIC	?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsValidIndex
PUBLIC	?IsInList@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsInList
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
;	COMDAT ??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utllinkedlist.h
CONST	SEGMENT
??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ DB 'IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@ DB 'IsInList(before)', 00H ; `string'
CONST	ENDS
;	COMDAT ?LinkBefore@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXGG@Z
_TEXT	SEGMENT
_before$ = 8
_elem$ = 12
_this$ = -4
_newElem$ = -8
_beforeElem$72725 = -12
?LinkBefore@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::LinkBefore, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 560  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74648
	push	560					; 00000230H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74648:

; 561  : 	
; 562  : 	// Unlink it if it's in the list at the moment
; 563  : 	Unlink(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlink@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Unlink

; 564  : 	
; 565  : 	ListElem_t& newElem = InternalElement(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
	mov	DWORD PTR _newElem$[ebp], eax

; 566  : 	
; 567  : 	// The element *after* our newly linked one is the one we linked before.
; 568  : 	newElem.m_Next = before;

	mov	ecx, DWORD PTR _newElem$[ebp]
	mov	dx, WORD PTR _before$[ebp]
	mov	WORD PTR [ecx+94], dx

; 569  : 	
; 570  : 	if (before == InvalidIndex())

	mov	esi, DWORD PTR _before$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L72721

; 572  : 		// In this case, we're linking to the end of the list, so reset the tail
; 573  : 		newElem.m_Previous = m_Tail;

	mov	eax, DWORD PTR _newElem$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+14]
	mov	WORD PTR [eax+92], dx

; 574  : 		m_Tail = elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+14], cx

; 576  : 	else

	jmp	SHORT $L72722
$L72721:

; 578  : 		// Here, we're not linking to the end. Set the prev pointer to point to
; 579  : 		// the element we're linking.
; 580  : 		assert( IsInList(before) );

	mov	dx, WORD PTR _before$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsInList
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74649
	push	580					; 00000244H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74649:

; 581  : 		ListElem_t& beforeElem = InternalElement(before);

	mov	cx, WORD PTR _before$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
	mov	DWORD PTR _beforeElem$72725[ebp], eax

; 582  : 		newElem.m_Previous = beforeElem.m_Previous;

	mov	edx, DWORD PTR _newElem$[ebp]
	mov	eax, DWORD PTR _beforeElem$72725[ebp]
	mov	cx, WORD PTR [eax+92]
	mov	WORD PTR [edx+92], cx

; 583  : 		beforeElem.m_Previous = elem;

	mov	edx, DWORD PTR _beforeElem$72725[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+92], ax
$L72722:

; 585  : 	
; 586  : 	// Reset the head if we linked to the head of the list
; 587  : 	if (newElem.m_Previous == InvalidIndex())

	mov	ecx, DWORD PTR _newElem$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+92]
	mov	esi, edx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L72726

; 588  : 		m_Head = elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+12], cx

; 589  : 	else

	jmp	SHORT $L72727
$L72726:

; 590  : 		InternalElement(newElem.m_Previous).m_Next = elem;

	mov	edx, DWORD PTR _newElem$[ebp]
	mov	ax, WORD PTR [edx+92]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+94], cx
$L72727:

; 591  : 	
; 592  : 	// one more element baby
; 593  : 	++m_ElementCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+18]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+18], ax

; 594  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?LinkBefore@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::LinkBefore
_TEXT	ENDS
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
;	COMDAT ?Next@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Next@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Next, COMDAT

; 265  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 266  : 	assert( IsValidIndex(i) ); 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74652
	push	266					; 0000010aH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74652:

; 267  : 	return InternalElement(i).m_Next; 

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
	mov	ax, WORD PTR [eax+94]

; 268  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Next@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Next
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ??A?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::operator[], COMDAT

; 213  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]

; 215  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::operator[]
_TEXT	ENDS
PUBLIC	?InsertBefore@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InsertBefore
PUBLIC	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
;	COMDAT ?AddToTail@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4
?AddToTail@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::AddToTail, COMDAT

; 431  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	return InsertBefore( InvalidIndex() ); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InsertBefore

; 433  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddToTail@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::AddToTail
_TEXT	ENDS
PUBLIC	?Free@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Free
;	COMDAT ?Remove@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
?Remove@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Remove, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	Free( elem );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Free

; 519  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Remove
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[], COMDAT

; 213  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[]

; 215  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Count, COMDAT

; 229  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 	return m_ElementCount; 

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+18]
	mov	eax, ecx

; 231  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Count
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@GH@@QAEPAGXZ			; CUtlMemory<unsigned short,int>::Base
;	COMDAT ?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@GH@@QAEPAGXZ		; CUtlMemory<unsigned short,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ ENDP	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IBEABUListElem_t@1@G@Z
_TEXT	SEGMENT
_this$ = -4
_i$ = 8
?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IBEABUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement, COMDAT

; 136  : 	ListElem_t const& InternalElement( I i ) const { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IBEABUListElem_t@1@G@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z
_TEXT	SEGMENT
_this$ = -4
_i$ = 8
?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement, COMDAT

; 136  : 	ListElem_t const& InternalElement( I i ) const { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex, COMDAT

; 100  : 	inline static I  InvalidIndex()  { return INVALID_LLIST_IDX; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	or	ax, 65535				; 0000ffffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT
_this$ = -4
_i$ = 8
?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement, COMDAT

; 135  : 	ListElem_t& InternalElement( I i ) { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z
_TEXT	SEGMENT
_this$ = -4
_i$ = 8
?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement, COMDAT

; 136  : 	ListElem_t const& InternalElement( I i ) const { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex, COMDAT

; 100  : 	inline static I  InvalidIndex()  { return INVALID_LLIST_IDX; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	or	ax, 65535				; 0000ffffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@GH@@QAEAAGH@Z		; CUtlMemory<unsigned short,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ENDP ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element
_TEXT	ENDS
PUBLIC	??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
PUBLIC	?CopyConstruct@@YAXPAGABG@Z			; CopyConstruct
PUBLIC	?IsValidIndex@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBE_NH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXHH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ShiftElementsRight
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ DB '('
	DB	'elem == Count()) || IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHHABG@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHHABG@Z PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base
	test	eax, eax
	je	SHORT $L74681
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L74681
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBEHXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Count
	lea	eax, DWORD PTR [esi+eax*2]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L74681
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74681:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBEHXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L74682
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBE_NH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74682
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74682:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXHH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAGABG@Z		; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEHHABG@Z ENDP ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
EXTRN	_memmove:NEAR
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ DB 'I'
	DB	'sValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 )', 00H ; `string'
CONST	ENDS
;	COMDAT ?ShiftElementsLeft@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsLeft@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXHH@Z PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ShiftElementsLeft, COMDAT

; 456  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBE_NH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74685
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L74685
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L74685
	push	457					; 000001c9H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74685:

; 458  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 459  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L72835
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L72835

; 461  : 		memmove( &Element(elem), &Element(elem+num), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	add	eax, DWORD PTR _num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 462  : 
; 463  : #ifdef _DEBUG
; 464  : 		memset( &Element(m_Size-num), 0xDD, num * sizeof(T) );

	mov	edx, DWORD PTR _num$[ebp]
	shl	edx, 1
	push	edx
	push	221					; 000000ddH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$L72835:

; 467  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsLeft@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXHH@Z ENDP ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ShiftElementsLeft
_TEXT	ENDS
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
PUBLIC	?IsIdxValid@?$CUtlMemory@GH@@QBE_NH@Z		; CUtlMemory<unsigned short,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ		; CUtlMemory<unsigned short,int>::IsReadOnly
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@GH@@QAEAAGH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@GH@@QAEAAGH@Z PROC NEAR			; CUtlMemory<unsigned short,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ	; CUtlMemory<unsigned short,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74688
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74688:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@GH@@QBE_NH@Z	; CUtlMemory<unsigned short,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74689
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74689:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*2]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@GH@@QAEAAGH@Z ENDP			; CUtlMemory<unsigned short,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@GH@@QAEPAGXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@GH@@QAEPAGXZ PROC NEAR		; CUtlMemory<unsigned short,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ	; CUtlMemory<unsigned short,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74692
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74692:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@GH@@QAEPAGXZ ENDP			; CUtlMemory<unsigned short,int>::Base
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAG@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAG@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	2
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAG@Z ENDP				; Destruct
_TEXT	ENDS
PUBLIC	?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z	; CopyConstruct
PUBLIC	?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Element
PUBLIC	?LinkBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXGG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::LinkBefore
PUBLIC	?AllocInternal@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEG_N@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::AllocInternal
;	COMDAT ?InsertBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGGABUDecalVertex_t@@@Z
_TEXT	SEGMENT
_before$ = 8
_src$ = 12
_this$ = -4
_newNode$ = -8
?InsertBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGGABUDecalVertex_t@@@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::InsertBefore, COMDAT

; 442  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 443  : 	// Make a new node
; 444  : 	I   newNode = AllocInternal();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocInternal@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEG_N@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::AllocInternal
	mov	WORD PTR _newNode$[ebp], ax

; 445  : 	
; 446  : 	// Link it in
; 447  : 	LinkBefore( before, newNode );

	mov	ax, WORD PTR _newNode$[ebp]
	push	eax
	mov	cx, WORD PTR _before$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXGG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::LinkBefore

; 448  : 	
; 449  : 	// Construct the data
; 450  : 	CopyConstruct( &Element(newNode), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	ax, WORD PTR _newNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Element
	push	eax
	call	?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z ; CopyConstruct
	add	esp, 8

; 451  : 	
; 452  : 	return newNode;

	mov	ax, WORD PTR _newNode$[ebp]

; 453  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGGABUDecalVertex_t@@@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::InsertBefore
_TEXT	ENDS
PUBLIC	?Construct@@YAXPAUDecalVertex_t@@@Z		; Construct
;	COMDAT ?InsertBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGG@Z
_TEXT	SEGMENT
_before$ = 8
_this$ = -4
_newNode$ = -8
?InsertBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGG@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::InsertBefore, COMDAT

; 395  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 396  : 	// Make a new node
; 397  : 	I   newNode = AllocInternal();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocInternal@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEG_N@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::AllocInternal
	mov	WORD PTR _newNode$[ebp], ax

; 398  : 	
; 399  : 	// Link it in
; 400  : 	LinkBefore( before, newNode );

	mov	ax, WORD PTR _newNode$[ebp]
	push	eax
	mov	cx, WORD PTR _before$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXGG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::LinkBefore

; 401  : 	
; 402  : 	// Construct the data
; 403  : 	Construct( &Element(newNode) );

	mov	dx, WORD PTR _newNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Element
	push	eax
	call	?Construct@@YAXPAUDecalVertex_t@@@Z	; Construct
	add	esp, 4

; 404  : 	
; 405  : 	return newNode;

	mov	ax, WORD PTR _newNode$[ebp]

; 406  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InsertBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEGG@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::InsertBefore
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAUDecalVertex_t@@@Z		; Destruct
PUBLIC	?Unlink@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Unlink
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
;	COMDAT ?Free@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_internalElem$ = -8
?Free@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::Free, COMDAT

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74701
	push	380					; 0000017cH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74701:

; 381  : 	Unlink(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlink@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Unlink

; 382  : 
; 383  : 	ListElem_t &internalElem = InternalElement(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	DWORD PTR _internalElem$[ebp], eax

; 384  : 	Destruct( &internalElem.m_Element );

	mov	ecx, DWORD PTR _internalElem$[ebp]
	push	ecx
	call	?Destruct@@YAXPAUDecalVertex_t@@@Z	; Destruct
	add	esp, 4

; 385  : 	internalElem.m_Next = m_FirstFree;

	mov	edx, DWORD PTR _internalElem$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	mov	WORD PTR [edx+66], cx

; 386  : 	m_FirstFree = elem;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+16], ax

; 387  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Free@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z ENDP	; CUtlLinkedList<DecalVertex_t,unsigned short>::Free
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsValidIndex, COMDAT

; 277  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return (i < m_TotalElements) && (i >= 0) &&
; 279  : 		((m_Memory[i].m_Previous != i) || (m_Memory[i].m_Next == i));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L74704
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L74704
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+64]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L74705
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+66]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L74704
$L74705:
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L74706
$L74704:
	mov	DWORD PTR -8+[ebp], 0
$L74706:
	mov	al, BYTE PTR -8+[ebp]

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsValidIndex
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsIdxValid
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74709
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74709:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 68					; 00000044H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74712
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74712:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74713
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74713:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
PUBLIC	?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z ; Construct
PUBLIC	?Element@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Element
PUBLIC	?LinkBefore@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXGG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::LinkBefore
PUBLIC	?AllocInternal@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEG_N@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::AllocInternal
;	COMDAT ?InsertBefore@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEGG@Z
_TEXT	SEGMENT
_before$ = 8
_this$ = -4
_newNode$ = -8
?InsertBefore@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InsertBefore, COMDAT

; 395  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 396  : 	// Make a new node
; 397  : 	I   newNode = AllocInternal();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocInternal@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEG_N@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::AllocInternal
	mov	WORD PTR _newNode$[ebp], ax

; 398  : 	
; 399  : 	// Link it in
; 400  : 	LinkBefore( before, newNode );

	mov	ax, WORD PTR _newNode$[ebp]
	push	eax
	mov	cx, WORD PTR _before$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkBefore@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXGG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::LinkBefore

; 401  : 	
; 402  : 	// Construct the data
; 403  : 	Construct( &Element(newNode) );

	mov	dx, WORD PTR _newNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Element
	push	eax
	call	?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z ; Construct
	add	esp, 4

; 404  : 	
; 405  : 	return newNode;

	mov	ax, WORD PTR _newNode$[ebp]

; 406  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InsertBefore@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InsertBefore
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z ; Destruct
PUBLIC	?Unlink@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Unlink
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
;	COMDAT ?Free@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_internalElem$ = -8
?Free@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Free, COMDAT

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74718
	push	380					; 0000017cH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74718:

; 381  : 	Unlink(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlink@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Unlink

; 382  : 
; 383  : 	ListElem_t &internalElem = InternalElement(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	DWORD PTR _internalElem$[ebp], eax

; 384  : 	Destruct( &internalElem.m_Element );

	mov	ecx, DWORD PTR _internalElem$[ebp]
	push	ecx
	call	?Destruct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z ; Destruct
	add	esp, 4

; 385  : 	internalElem.m_Next = m_FirstFree;

	mov	edx, DWORD PTR _internalElem$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	mov	WORD PTR [edx+74], cx

; 386  : 	m_FirstFree = elem;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+16], ax

; 387  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Free@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Free
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsValidIndex, COMDAT

; 277  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return (i < m_TotalElements) && (i >= 0) &&
; 279  : 		((m_Memory[i].m_Previous != i) || (m_Memory[i].m_Next == i));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L74721
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L74721
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+72]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L74722
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+74]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L74721
$L74722:
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L74723
$L74721:
	mov	DWORD PTR -8+[ebp], 0
$L74723:
	mov	al, BYTE PTR -8+[ebp]

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsValidIndex
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsIdxValid
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74726
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74726:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74729
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74729:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74730
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74730:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
PUBLIC	?Element@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Element
PUBLIC	?LinkBefore@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::LinkBefore
PUBLIC	?AllocInternal@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEG_N@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::AllocInternal
PUBLIC	?Construct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z ; Construct
;	COMDAT ?InsertBefore@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEGG@Z
_TEXT	SEGMENT
_before$ = 8
_this$ = -4
_newNode$ = -8
?InsertBefore@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InsertBefore, COMDAT

; 395  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 396  : 	// Make a new node
; 397  : 	I   newNode = AllocInternal();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocInternal@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEG_N@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::AllocInternal
	mov	WORD PTR _newNode$[ebp], ax

; 398  : 	
; 399  : 	// Link it in
; 400  : 	LinkBefore( before, newNode );

	mov	ax, WORD PTR _newNode$[ebp]
	push	eax
	mov	cx, WORD PTR _before$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkBefore@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::LinkBefore

; 401  : 	
; 402  : 	// Construct the data
; 403  : 	Construct( &Element(newNode) );

	mov	dx, WORD PTR _newNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Element
	push	eax
	call	?Construct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z ; Construct
	add	esp, 4

; 404  : 	
; 405  : 	return newNode;

	mov	ax, WORD PTR _newNode$[ebp]

; 406  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InsertBefore@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InsertBefore
_TEXT	ENDS
PUBLIC	?Unlink@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Unlink
PUBLIC	?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsValidIndex
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
PUBLIC	?Destruct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z ; Destruct
;	COMDAT ?Free@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_internalElem$ = -8
?Free@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Free, COMDAT

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74735
	push	380					; 0000017cH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74735:

; 381  : 	Unlink(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlink@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Unlink

; 382  : 
; 383  : 	ListElem_t &internalElem = InternalElement(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	mov	DWORD PTR _internalElem$[ebp], eax

; 384  : 	Destruct( &internalElem.m_Element );

	mov	ecx, DWORD PTR _internalElem$[ebp]
	push	ecx
	call	?Destruct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z ; Destruct
	add	esp, 4

; 385  : 	internalElem.m_Next = m_FirstFree;

	mov	edx, DWORD PTR _internalElem$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	mov	WORD PTR [edx+6], cx

; 386  : 	m_FirstFree = elem;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+16], ax

; 387  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Free@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Free
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74738
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74738:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74739
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74739:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Element, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]

; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Element
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z ; Destruct
;	COMDAT ?Free@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_internalElem$ = -8
?Free@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Free, COMDAT

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74744
	push	380					; 0000017cH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74744:

; 381  : 	Unlink(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlink@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Unlink

; 382  : 
; 383  : 	ListElem_t &internalElem = InternalElement(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
	mov	DWORD PTR _internalElem$[ebp], eax

; 384  : 	Destruct( &internalElem.m_Element );

	mov	ecx, DWORD PTR _internalElem$[ebp]
	push	ecx
	call	?Destruct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z ; Destruct
	add	esp, 4

; 385  : 	internalElem.m_Next = m_FirstFree;

	mov	edx, DWORD PTR _internalElem$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	mov	WORD PTR [edx+94], cx

; 386  : 	m_FirstFree = elem;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+16], ax

; 387  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Free@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Free
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Base
;	COMDAT ?Unlink@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_pBase$72974 = -8
_pOldElem$72975 = -12
?Unlink@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Unlink, COMDAT

; 637  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74747
	push	638					; 0000027eH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74747:

; 639  : 	if (IsInList(elem))

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsInList
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L72973

; 641  : 		ListElem_t *pBase = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Base
	mov	DWORD PTR _pBase$72974[ebp], eax

; 642  : 		ListElem_t *pOldElem = &pBase[elem];

	mov	eax, DWORD PTR _elem$[ebp]
	and	eax, 65535				; 0000ffffH
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR _pBase$72974[ebp]
	add	ecx, eax
	mov	DWORD PTR _pOldElem$72975[ebp], ecx

; 643  : 		
; 644  : 		// If we're the first guy, reset the head
; 645  : 		// otherwise, make our previous node's next pointer = our next
; 646  : 		if ( pOldElem->m_Previous != INVALID_LLIST_IDX )

	mov	edx, DWORD PTR _pOldElem$72975[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+92]
	cmp	eax, 65535				; 0000ffffH
	je	SHORT $L72977

; 648  : 			pBase[pOldElem->m_Previous].m_Next = pOldElem->m_Next;

	mov	ecx, DWORD PTR _pOldElem$72975[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+92]
	imul	edx, 96					; 00000060H
	mov	eax, DWORD PTR _pBase$72974[ebp]
	mov	ecx, DWORD PTR _pOldElem$72975[ebp]
	mov	cx, WORD PTR [ecx+94]
	mov	WORD PTR [eax+edx+94], cx

; 650  : 		else

	jmp	SHORT $L72978
$L72977:

; 652  : 			m_Head = pOldElem->m_Next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pOldElem$72975[ebp]
	mov	cx, WORD PTR [eax+94]
	mov	WORD PTR [edx+12], cx
$L72978:

; 654  : 		
; 655  : 		// If we're the last guy, reset the tail
; 656  : 		// otherwise, make our next node's prev pointer = our prev
; 657  : 		if ( pOldElem->m_Next != INVALID_LLIST_IDX )

	mov	edx, DWORD PTR _pOldElem$72975[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+94]
	cmp	eax, 65535				; 0000ffffH
	je	SHORT $L72980

; 659  : 			pBase[pOldElem->m_Next].m_Previous = pOldElem->m_Previous;

	mov	ecx, DWORD PTR _pOldElem$72975[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+94]
	imul	edx, 96					; 00000060H
	mov	eax, DWORD PTR _pBase$72974[ebp]
	mov	ecx, DWORD PTR _pOldElem$72975[ebp]
	mov	cx, WORD PTR [ecx+92]
	mov	WORD PTR [eax+edx+92], cx

; 661  : 		else

	jmp	SHORT $L72981
$L72980:

; 663  : 			m_Tail = pOldElem->m_Previous;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pOldElem$72975[ebp]
	mov	cx, WORD PTR [eax+92]
	mov	WORD PTR [edx+14], cx
$L72981:

; 665  : 		
; 666  : 		// This marks this node as not in the list, 
; 667  : 		// but not in the free list either
; 668  : 		pOldElem->m_Previous = pOldElem->m_Next = elem;

	mov	edx, DWORD PTR _pOldElem$72975[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+94], ax
	mov	ecx, DWORD PTR _pOldElem$72975[ebp]
	mov	dx, WORD PTR _elem$[ebp]
	mov	WORD PTR [ecx+92], dx

; 669  : 		
; 670  : 		// One less puppy
; 671  : 		--m_ElementCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+18]
	sub	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+18], cx
$L72973:

; 673  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Unlink@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Unlink
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsValidIndex, COMDAT

; 277  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return (i < m_TotalElements) && (i >= 0) &&
; 279  : 		((m_Memory[i].m_Previous != i) || (m_Memory[i].m_Next == i));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L74750
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L74750
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+92]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L74751
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+94]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L74750
$L74751:
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L74752
$L74750:
	mov	DWORD PTR -8+[ebp], 0
$L74752:
	mov	al, BYTE PTR -8+[ebp]

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsValidIndex
_TEXT	ENDS
PUBLIC	?Previous@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Previous
;	COMDAT ?IsInList@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsInList@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsInList, COMDAT

; 284  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 285  : 	return (i < m_TotalElements) && (i >= 0) && (Previous(i) != i);

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L74755
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L74755
	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Previous@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Previous
	and	eax, 65535				; 0000ffffH
	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 65535				; 0000ffffH
	cmp	eax, edx
	je	SHORT $L74755
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L74756
$L74755:
	mov	DWORD PTR -8+[ebp], 0
$L74756:
	mov	al, BYTE PTR -8+[ebp]

; 286  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsInList@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsInList
_TEXT	ENDS
PUBLIC	??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@ ; `string'
PUBLIC	??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
PUBLIC	?ResetDbgInfo@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ResetDbgInfo
PUBLIC	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Grow
;	COMDAT ??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@
; File z:\xashxtsrc\game_shared\utllinkedlist.h
CONST	SEGMENT
??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@ DB 'm_TotalEl'
	DB	'ements != InvalidIndex()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@ DB 'elem != Inva'
	DB	'lidIndex()', 00H				; `string'
CONST	ENDS
;	COMDAT ?AllocInternal@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEG_N@Z
_TEXT	SEGMENT
_multilist$ = 8
_this$ = -4
_elem$ = -8
?AllocInternal@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEG_N@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::AllocInternal, COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 336  : 	I elem;
; 337  : 	if (m_FirstFree == InvalidIndex())

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+16]
	mov	esi, ecx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	$L72995

; 339  : 		// Nothing in the free list; add.
; 340  : 		// Since nothing is in the free list, m_TotalElements == total # of elements
; 341  : 		// the list knows about.
; 342  : 		if (m_TotalElements == m_Memory.NumAllocated())

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::NumAllocated
	cmp	esi, eax
	jne	SHORT $L72996

; 343  : 			m_Memory.Grow();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Grow
$L72996:

; 344  : 
; 345  : 		assert( m_TotalElements != InvalidIndex() );

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	mov	esi, edx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L74759
	push	345					; 00000159H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74759:

; 346  : 
; 347  : 		elem = (I)m_TotalElements;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+20]
	mov	WORD PTR _elem$[ebp], dx

; 348  : 		++m_TotalElements;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+20]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], cx

; 349  : 
; 350  : 		assert( elem != InvalidIndex() );

	mov	esi, DWORD PTR _elem$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L74760
	push	350					; 0000015eH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74760:

; 352  : 	else

	jmp	SHORT $L73002
$L72995:

; 354  : 		elem = m_FirstFree;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+16]
	mov	WORD PTR _elem$[ebp], dx

; 355  : 		m_FirstFree = InternalElement(m_FirstFree).m_Next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+94]
	mov	WORD PTR [edx+16], ax
$L73002:

; 357  : 	
; 358  : 	if (!multilist)

	mov	ecx, DWORD PTR _multilist$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L73003

; 359  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = elem;

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+92], cx
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+94], cx

; 360  : 	else

	jmp	SHORT $L73004
$L73003:

; 361  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	mov	si, ax
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
	add	eax, 92					; 0000005cH
	mov	DWORD PTR -12+[ebp], eax
	mov	eax, DWORD PTR -12+[ebp]
	mov	WORD PTR [eax], si
	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
	mov	edx, DWORD PTR -12+[ebp]
	mov	cx, WORD PTR [edx]
	mov	WORD PTR [eax+94], cx
$L73004:

; 362  : 
; 363  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ResetDbgInfo

; 364  : 
; 365  : 	return elem;

	mov	ax, WORD PTR _elem$[ebp]

; 366  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocInternal@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEG_N@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::AllocInternal
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsIdxValid
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74763
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74763:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 96					; 00000060H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74766
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74766:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74767
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74767:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
PUBLIC	??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ	; CStudioModelRenderer::DecalMaterial_t::DecalMaterial_t
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlmemory.h
xdata$x	SEGMENT
__ehfuncinfo$?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z$0
xdata$x	ENDS
;	COMDAT ?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
$T74770 = -16
$T74771 = -20
__$EHRec$ = -12
?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z PROC NEAR ; Construct, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 38   : 	new( pMemory ) T;

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	92					; 0000005cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T74771[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T74771[ebp], 0
	je	SHORT $L74772
	mov	ecx, DWORD PTR $T74771[ebp]
	call	??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::DecalMaterial_t::DecalMaterial_t
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L74773
$L74772:
	mov	DWORD PTR -24+[ebp], 0
$L74773:
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T74770[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 39   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z$0:
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T74771[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?Construct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z ENDP ; Construct
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 79   : 	{return; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z ; Construct
PUBLIC	?Element@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Element
PUBLIC	?LinkBefore@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::LinkBefore
PUBLIC	?AllocInternal@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEG_N@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::AllocInternal
;	COMDAT ?InsertBefore@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEGG@Z
_TEXT	SEGMENT
_before$ = 8
_this$ = -4
_newNode$ = -8
?InsertBefore@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InsertBefore, COMDAT

; 395  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 396  : 	// Make a new node
; 397  : 	I   newNode = AllocInternal();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocInternal@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEG_N@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::AllocInternal
	mov	WORD PTR _newNode$[ebp], ax

; 398  : 	
; 399  : 	// Link it in
; 400  : 	LinkBefore( before, newNode );

	mov	ax, WORD PTR _newNode$[ebp]
	push	eax
	mov	cx, WORD PTR _before$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkBefore@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::LinkBefore

; 401  : 	
; 402  : 	// Construct the data
; 403  : 	Construct( &Element(newNode) );

	mov	dx, WORD PTR _newNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Element
	push	eax
	call	?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z ; Construct
	add	esp, 4

; 404  : 	
; 405  : 	return newNode;

	mov	ax, WORD PTR _newNode$[ebp]

; 406  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InsertBefore@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InsertBefore
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z ; Destruct
PUBLIC	?Unlink@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Unlink
PUBLIC	?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsValidIndex
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
;	COMDAT ?Free@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_internalElem$ = -8
?Free@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Free, COMDAT

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74793
	push	380					; 0000017cH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74793:

; 381  : 	Unlink(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlink@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Unlink

; 382  : 
; 383  : 	ListElem_t &internalElem = InternalElement(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
	mov	DWORD PTR _internalElem$[ebp], eax

; 384  : 	Destruct( &internalElem.m_Element );

	mov	ecx, DWORD PTR _internalElem$[ebp]
	push	ecx
	call	?Destruct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z ; Destruct
	add	esp, 4

; 385  : 	internalElem.m_Next = m_FirstFree;

	mov	edx, DWORD PTR _internalElem$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	mov	WORD PTR [edx+34], cx

; 386  : 	m_FirstFree = elem;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+16], ax

; 387  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Free@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Free
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74796
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74796:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74797
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74797:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74800
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74800:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74801
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74801:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 34096				; 00008530H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >
PUBLIC	??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::~CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >
PUBLIC	??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z	; CUtlLinkedList<DecalVertex_t,unsigned short>::CUtlLinkedList<DecalVertex_t,unsigned short>
PUBLIC	??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ	; CUtlLinkedList<DecalVertex_t,unsigned short>::~CUtlLinkedList<DecalVertex_t,unsigned short>
PUBLIC	??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ DD 019930520H
	DD	02H
	DD	FLAT:__unwindtable$??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT ??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ PROC NEAR ; CStudioModelRenderer::DecalMaterial_t::DecalMaterial_t, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::CUtlLinkedList<DecalVertex_t,unsigned short>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::~CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >
	ret	0
__unwindfunclet$??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::~CUtlLinkedList<DecalVertex_t,unsigned short>
	ret	0
__ehhandler$??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0DecalMaterial_t@CStudioModelRenderer@@QAE@XZ ENDP	; CStudioModelRenderer::DecalMaterial_t::DecalMaterial_t
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT
_this$ = -4
_i$ = 8
?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement, COMDAT

; 135  : 	ListElem_t& InternalElement( I i ) { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT
_this$ = -4
_i$ = 8
?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement, COMDAT

; 135  : 	ListElem_t& InternalElement( I i ) { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement, COMDAT

; 135  : 	ListElem_t& InternalElement( I i ) { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ResetDbgInfo, COMDAT

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		m_pElements = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 141  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ResetDbgInfo
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT
_this$ = -4
_i$ = 8
?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement, COMDAT

; 135  : 	ListElem_t& InternalElement( I i ) { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@GH@@QAE@HH@Z			; CUtlMemory<unsigned short,int>::CUtlMemory<unsigned short,int>
PUBLIC	??1?$CUtlMemory@GH@@QAE@XZ			; CUtlMemory<unsigned short,int>::~CUtlMemory<unsigned short,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_this$ = -16
??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z PROC NEAR	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@GH@@QAE@HH@Z		; CUtlMemory<unsigned short,int>::CUtlMemory<unsigned short,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@GH@@QAE@XZ		; CUtlMemory<unsigned short,int>::~CUtlMemory<unsigned short,int>
	ret	0
__ehhandler$??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@HH@Z ENDP	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >
PUBLIC	?Purge@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ PROC NEAR	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::~CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@GH@@QAE@XZ		; CUtlMemory<unsigned short,int>::~CUtlMemory<unsigned short,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@GH@@QAE@XZ		; CUtlMemory<unsigned short,int>::~CUtlMemory<unsigned short,int>
	ret	0
__ehhandler$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ ENDP		; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::~CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >
;	COMDAT ?IsValidIndex@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBE_NH@Z PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L74843
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L74843
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L74844
$L74843:
	mov	DWORD PTR -8+[ebp], 0
$L74844:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBE_NH@Z ENDP ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@GH@@QBEHXZ		; CUtlMemory<unsigned short,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@GH@@QAEXH@Z			; CUtlMemory<unsigned short,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXH@Z PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@GH@@QBEHXZ	; CUtlMemory<unsigned short,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L73103

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@GH@@QBEHXZ	; CUtlMemory<unsigned short,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@GH@@QAEXH@Z		; CUtlMemory<unsigned short,int>::Grow
$L73103:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXH@Z ENDP ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::GrowVector
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXHH@Z PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@GV?$CUtlMemory@GH@@@@QBE_NH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74849
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L74849
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L74849
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74849:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L73111
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L73111

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L73111:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXHH@Z ENDP ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ShiftElementsRight
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@GH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@GH@@QBE_NH@Z PROC NEAR		; CUtlMemory<unsigned short,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L74852
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L74852
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L74853
$L74852:
	mov	DWORD PTR -8+[ebp], 0
$L74853:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@GH@@QBE_NH@Z ENDP		; CUtlMemory<unsigned short,int>::IsIdxValid
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ PROC NEAR		; CUtlMemory<unsigned short,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ ENDP		; CUtlMemory<unsigned short,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAGABG@Z
_TEXT	SEGMENT
$T74858 = -4
_pMemory$ = 8
_src$ = 12
?CopyConstruct@@YAXPAGABG@Z PROC NEAR			; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	2
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T74858[ebp], eax
	cmp	DWORD PTR $T74858[ebp], 0
	je	SHORT $L74859
	mov	ecx, DWORD PTR $T74858[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR [ecx], ax
	mov	ecx, DWORD PTR $T74858[ebp]
	mov	DWORD PTR -8+[ebp], ecx
	jmp	SHORT $L74860
$L74859:
	mov	DWORD PTR -8+[ebp], 0
$L74860:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyConstruct@@YAXPAGABG@Z ENDP			; CopyConstruct
_TEXT	ENDS
PUBLIC	?ConstructList@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEXXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::ConstructList
PUBLIC	?ResetDbgInfo@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEXXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::ResetDbgInfo
PUBLIC	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>
PUBLIC	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_this$ = -16
??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::CUtlLinkedList<DecalVertex_t,unsigned short>, COMDAT

; 166  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 167  : 	ConstructList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConstructList@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEXXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::ConstructList

; 168  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEXXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::ResetDbgInfo

; 169  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@HH@Z ENDP	; CUtlLinkedList<DecalVertex_t,unsigned short>::CUtlLinkedList<DecalVertex_t,unsigned short>
PUBLIC	?RemoveAll@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::RemoveAll
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ PROC NEAR	; CUtlLinkedList<DecalVertex_t,unsigned short>::~CUtlLinkedList<DecalVertex_t,unsigned short>, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 182  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::RemoveAll

; 183  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ ENDP	; CUtlLinkedList<DecalVertex_t,unsigned short>::~CUtlLinkedList<DecalVertex_t,unsigned short>
;	COMDAT ?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::Element, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]

; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::Element
_TEXT	ENDS
PUBLIC	?IsInList@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsInList
;	COMDAT ?LinkBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXGG@Z
_TEXT	SEGMENT
_before$ = 8
_elem$ = 12
_this$ = -4
_newElem$ = -8
_beforeElem$73147 = -12
?LinkBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXGG@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::LinkBefore, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 560  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74883
	push	560					; 00000230H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74883:

; 561  : 	
; 562  : 	// Unlink it if it's in the list at the moment
; 563  : 	Unlink(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlink@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Unlink

; 564  : 	
; 565  : 	ListElem_t& newElem = InternalElement(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	DWORD PTR _newElem$[ebp], eax

; 566  : 	
; 567  : 	// The element *after* our newly linked one is the one we linked before.
; 568  : 	newElem.m_Next = before;

	mov	ecx, DWORD PTR _newElem$[ebp]
	mov	dx, WORD PTR _before$[ebp]
	mov	WORD PTR [ecx+66], dx

; 569  : 	
; 570  : 	if (before == InvalidIndex())

	mov	esi, DWORD PTR _before$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L73144

; 572  : 		// In this case, we're linking to the end of the list, so reset the tail
; 573  : 		newElem.m_Previous = m_Tail;

	mov	eax, DWORD PTR _newElem$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+14]
	mov	WORD PTR [eax+64], dx

; 574  : 		m_Tail = elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+14], cx

; 576  : 	else

	jmp	SHORT $L73145
$L73144:

; 578  : 		// Here, we're not linking to the end. Set the prev pointer to point to
; 579  : 		// the element we're linking.
; 580  : 		assert( IsInList(before) );

	mov	dx, WORD PTR _before$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsInList
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74884
	push	580					; 00000244H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74884:

; 581  : 		ListElem_t& beforeElem = InternalElement(before);

	mov	cx, WORD PTR _before$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	DWORD PTR _beforeElem$73147[ebp], eax

; 582  : 		newElem.m_Previous = beforeElem.m_Previous;

	mov	edx, DWORD PTR _newElem$[ebp]
	mov	eax, DWORD PTR _beforeElem$73147[ebp]
	mov	cx, WORD PTR [eax+64]
	mov	WORD PTR [edx+64], cx

; 583  : 		beforeElem.m_Previous = elem;

	mov	edx, DWORD PTR _beforeElem$73147[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+64], ax
$L73145:

; 585  : 	
; 586  : 	// Reset the head if we linked to the head of the list
; 587  : 	if (newElem.m_Previous == InvalidIndex())

	mov	ecx, DWORD PTR _newElem$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+64]
	mov	esi, edx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L73148

; 588  : 		m_Head = elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+12], cx

; 589  : 	else

	jmp	SHORT $L73149
$L73148:

; 590  : 		InternalElement(newElem.m_Previous).m_Next = elem;

	mov	edx, DWORD PTR _newElem$[ebp]
	mov	ax, WORD PTR [edx+64]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+66], cx
$L73149:

; 591  : 	
; 592  : 	// one more element baby
; 593  : 	++m_ElementCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+18]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+18], ax

; 594  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?LinkBefore@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXGG@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::LinkBefore
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@XZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Base
;	COMDAT ?Unlink@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_pBase$73156 = -8
_pOldElem$73157 = -12
?Unlink@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::Unlink, COMDAT

; 637  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74887
	push	638					; 0000027eH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74887:

; 639  : 	if (IsInList(elem))

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsInList
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L73155

; 641  : 		ListElem_t *pBase = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@XZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Base
	mov	DWORD PTR _pBase$73156[ebp], eax

; 642  : 		ListElem_t *pOldElem = &pBase[elem];

	mov	eax, DWORD PTR _elem$[ebp]
	and	eax, 65535				; 0000ffffH
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR _pBase$73156[ebp]
	add	ecx, eax
	mov	DWORD PTR _pOldElem$73157[ebp], ecx

; 643  : 		
; 644  : 		// If we're the first guy, reset the head
; 645  : 		// otherwise, make our previous node's next pointer = our next
; 646  : 		if ( pOldElem->m_Previous != INVALID_LLIST_IDX )

	mov	edx, DWORD PTR _pOldElem$73157[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+64]
	cmp	eax, 65535				; 0000ffffH
	je	SHORT $L73159

; 648  : 			pBase[pOldElem->m_Previous].m_Next = pOldElem->m_Next;

	mov	ecx, DWORD PTR _pOldElem$73157[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+64]
	imul	edx, 68					; 00000044H
	mov	eax, DWORD PTR _pBase$73156[ebp]
	mov	ecx, DWORD PTR _pOldElem$73157[ebp]
	mov	cx, WORD PTR [ecx+66]
	mov	WORD PTR [eax+edx+66], cx

; 650  : 		else

	jmp	SHORT $L73160
$L73159:

; 652  : 			m_Head = pOldElem->m_Next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pOldElem$73157[ebp]
	mov	cx, WORD PTR [eax+66]
	mov	WORD PTR [edx+12], cx
$L73160:

; 654  : 		
; 655  : 		// If we're the last guy, reset the tail
; 656  : 		// otherwise, make our next node's prev pointer = our prev
; 657  : 		if ( pOldElem->m_Next != INVALID_LLIST_IDX )

	mov	edx, DWORD PTR _pOldElem$73157[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+66]
	cmp	eax, 65535				; 0000ffffH
	je	SHORT $L73162

; 659  : 			pBase[pOldElem->m_Next].m_Previous = pOldElem->m_Previous;

	mov	ecx, DWORD PTR _pOldElem$73157[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+66]
	imul	edx, 68					; 00000044H
	mov	eax, DWORD PTR _pBase$73156[ebp]
	mov	ecx, DWORD PTR _pOldElem$73157[ebp]
	mov	cx, WORD PTR [ecx+64]
	mov	WORD PTR [eax+edx+64], cx

; 661  : 		else

	jmp	SHORT $L73163
$L73162:

; 663  : 			m_Tail = pOldElem->m_Previous;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pOldElem$73157[ebp]
	mov	cx, WORD PTR [eax+64]
	mov	WORD PTR [edx+14], cx
$L73163:

; 665  : 		
; 666  : 		// This marks this node as not in the list, 
; 667  : 		// but not in the free list either
; 668  : 		pOldElem->m_Previous = pOldElem->m_Next = elem;

	mov	edx, DWORD PTR _pOldElem$73157[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+66], ax
	mov	ecx, DWORD PTR _pOldElem$73157[ebp]
	mov	dx, WORD PTR _elem$[ebp]
	mov	WORD PTR [ecx+64], dx

; 669  : 		
; 670  : 		// One less puppy
; 671  : 		--m_ElementCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+18]
	sub	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+18], cx
$L73155:

; 673  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Unlink@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXG@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::Unlink
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Grow
;	COMDAT ?AllocInternal@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEG_N@Z
_TEXT	SEGMENT
_multilist$ = 8
_this$ = -4
_elem$ = -8
?AllocInternal@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEG_N@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::AllocInternal, COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 336  : 	I elem;
; 337  : 	if (m_FirstFree == InvalidIndex())

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+16]
	mov	esi, ecx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	$L73169

; 339  : 		// Nothing in the free list; add.
; 340  : 		// Since nothing is in the free list, m_TotalElements == total # of elements
; 341  : 		// the list knows about.
; 342  : 		if (m_TotalElements == m_Memory.NumAllocated())

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::NumAllocated
	cmp	esi, eax
	jne	SHORT $L73170

; 343  : 			m_Memory.Grow();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Grow
$L73170:

; 344  : 
; 345  : 		assert( m_TotalElements != InvalidIndex() );

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	mov	esi, edx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L74890
	push	345					; 00000159H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74890:

; 346  : 
; 347  : 		elem = (I)m_TotalElements;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+20]
	mov	WORD PTR _elem$[ebp], dx

; 348  : 		++m_TotalElements;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+20]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], cx

; 349  : 
; 350  : 		assert( elem != InvalidIndex() );

	mov	esi, DWORD PTR _elem$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L74891
	push	350					; 0000015eH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74891:

; 352  : 	else

	jmp	SHORT $L73174
$L73169:

; 354  : 		elem = m_FirstFree;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+16]
	mov	WORD PTR _elem$[ebp], dx

; 355  : 		m_FirstFree = InternalElement(m_FirstFree).m_Next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+66]
	mov	WORD PTR [edx+16], ax
$L73174:

; 357  : 	
; 358  : 	if (!multilist)

	mov	ecx, DWORD PTR _multilist$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L73175

; 359  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = elem;

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+64], cx
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+66], cx

; 360  : 	else

	jmp	SHORT $L73176
$L73175:

; 361  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	mov	si, ax
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	add	eax, 64					; 00000040H
	mov	DWORD PTR -12+[ebp], eax
	mov	eax, DWORD PTR -12+[ebp]
	mov	WORD PTR [eax], si
	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	edx, DWORD PTR -12+[ebp]
	mov	cx, WORD PTR [edx]
	mov	WORD PTR [eax+66], cx
$L73176:

; 362  : 
; 363  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEXXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::ResetDbgInfo

; 364  : 
; 365  : 	return elem;

	mov	ax, WORD PTR _elem$[ebp]

; 366  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocInternal@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEG_N@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::AllocInternal
_TEXT	ENDS
PUBLIC	??0DecalVertex_t@@QAE@ABU0@@Z			; DecalVertex_t::DecalVertex_t
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlmemory.h
xdata$x	SEGMENT
__ehfuncinfo$?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z$0
xdata$x	ENDS
;	COMDAT ?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z
_TEXT	SEGMENT
$T74894 = -16
$T74895 = -20
__$EHRec$ = -12
_pMemory$ = 8
_src$ = 12
?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z PROC NEAR	; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	64					; 00000040H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T74895[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T74895[ebp], 0
	je	SHORT $L74896
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T74895[ebp]
	call	??0DecalVertex_t@@QAE@ABU0@@Z		; DecalVertex_t::DecalVertex_t
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L74897
$L74896:
	mov	DWORD PTR -24+[ebp], 0
$L74897:
	mov	edx, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T74894[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 45   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z$0:
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T74895[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?CopyConstruct@@YAXPAUDecalVertex_t@@ABU1@@Z ENDP	; CopyConstruct
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlmemory.h
xdata$x	SEGMENT
__ehfuncinfo$?Construct@@YAXPAUDecalVertex_t@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?Construct@@YAXPAUDecalVertex_t@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?Construct@@YAXPAUDecalVertex_t@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Construct@@YAXPAUDecalVertex_t@@@Z$0
xdata$x	ENDS
;	COMDAT ?Construct@@YAXPAUDecalVertex_t@@@Z
_TEXT	SEGMENT
$T74907 = -16
$T74908 = -20
__$EHRec$ = -12
_pMemory$ = 8
?Construct@@YAXPAUDecalVertex_t@@@Z PROC NEAR		; Construct, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Construct@@YAXPAUDecalVertex_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 38   : 	new( pMemory ) T;

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	64					; 00000040H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T74908[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T74908[ebp], 0
	je	SHORT $L74909
	mov	ecx, DWORD PTR $T74908[ebp]
	call	??0DecalVertex_t@@QAE@XZ		; DecalVertex_t::DecalVertex_t
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L74910
$L74909:
	mov	DWORD PTR -24+[ebp], 0
$L74910:
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T74907[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 39   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Construct@@YAXPAUDecalVertex_t@@@Z$0:
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T74908[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?Construct@@YAXPAUDecalVertex_t@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?Construct@@YAXPAUDecalVertex_t@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?Construct@@YAXPAUDecalVertex_t@@@Z ENDP		; Construct
;	COMDAT ?Destruct@@YAXPAUDecalVertex_t@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUDecalVertex_t@@@Z PROC NEAR		; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	64					; 00000040H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUDecalVertex_t@@@Z ENDP			; Destruct
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L74922
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L74922
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L74923
$L74922:
	mov	DWORD PTR -8+[ebp], 0
$L74923:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
PUBLIC	?ConstructList@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ConstructList
PUBLIC	?ResetDbgInfo@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ResetDbgInfo
PUBLIC	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>
PUBLIC	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_this$ = -16
??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>, COMDAT

; 166  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 167  : 	ConstructList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConstructList@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ConstructList

; 168  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ResetDbgInfo

; 169  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@HH@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>
;	COMDAT ?Element@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Element, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]

; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Element
_TEXT	ENDS
PUBLIC	?IsInList@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsInList
;	COMDAT ?LinkBefore@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXGG@Z
_TEXT	SEGMENT
_before$ = 8
_elem$ = 12
_this$ = -4
_newElem$ = -8
_beforeElem$73222 = -12
?LinkBefore@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::LinkBefore, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 560  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74939
	push	560					; 00000230H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74939:

; 561  : 	
; 562  : 	// Unlink it if it's in the list at the moment
; 563  : 	Unlink(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlink@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Unlink

; 564  : 	
; 565  : 	ListElem_t& newElem = InternalElement(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	DWORD PTR _newElem$[ebp], eax

; 566  : 	
; 567  : 	// The element *after* our newly linked one is the one we linked before.
; 568  : 	newElem.m_Next = before;

	mov	ecx, DWORD PTR _newElem$[ebp]
	mov	dx, WORD PTR _before$[ebp]
	mov	WORD PTR [ecx+74], dx

; 569  : 	
; 570  : 	if (before == InvalidIndex())

	mov	esi, DWORD PTR _before$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L73219

; 572  : 		// In this case, we're linking to the end of the list, so reset the tail
; 573  : 		newElem.m_Previous = m_Tail;

	mov	eax, DWORD PTR _newElem$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+14]
	mov	WORD PTR [eax+72], dx

; 574  : 		m_Tail = elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+14], cx

; 576  : 	else

	jmp	SHORT $L73220
$L73219:

; 578  : 		// Here, we're not linking to the end. Set the prev pointer to point to
; 579  : 		// the element we're linking.
; 580  : 		assert( IsInList(before) );

	mov	dx, WORD PTR _before$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsInList
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74940
	push	580					; 00000244H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74940:

; 581  : 		ListElem_t& beforeElem = InternalElement(before);

	mov	cx, WORD PTR _before$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	DWORD PTR _beforeElem$73222[ebp], eax

; 582  : 		newElem.m_Previous = beforeElem.m_Previous;

	mov	edx, DWORD PTR _newElem$[ebp]
	mov	eax, DWORD PTR _beforeElem$73222[ebp]
	mov	cx, WORD PTR [eax+72]
	mov	WORD PTR [edx+72], cx

; 583  : 		beforeElem.m_Previous = elem;

	mov	edx, DWORD PTR _beforeElem$73222[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+72], ax
$L73220:

; 585  : 	
; 586  : 	// Reset the head if we linked to the head of the list
; 587  : 	if (newElem.m_Previous == InvalidIndex())

	mov	ecx, DWORD PTR _newElem$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+72]
	mov	esi, edx
	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L73223

; 588  : 		m_Head = elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+12], cx

; 589  : 	else

	jmp	SHORT $L73224
$L73223:

; 590  : 		InternalElement(newElem.m_Previous).m_Next = elem;

	mov	edx, DWORD PTR _newElem$[ebp]
	mov	ax, WORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+74], cx
$L73224:

; 591  : 	
; 592  : 	// one more element baby
; 593  : 	++m_ElementCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+18]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+18], ax

; 594  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?LinkBefore@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::LinkBefore
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Base
;	COMDAT ?Unlink@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_pBase$73231 = -8
_pOldElem$73232 = -12
?Unlink@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Unlink, COMDAT

; 637  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74943
	push	638					; 0000027eH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74943:

; 639  : 	if (IsInList(elem))

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsInList
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L73230

; 641  : 		ListElem_t *pBase = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Base
	mov	DWORD PTR _pBase$73231[ebp], eax

; 642  : 		ListElem_t *pOldElem = &pBase[elem];

	mov	eax, DWORD PTR _elem$[ebp]
	and	eax, 65535				; 0000ffffH
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _pBase$73231[ebp]
	add	ecx, eax
	mov	DWORD PTR _pOldElem$73232[ebp], ecx

; 643  : 		
; 644  : 		// If we're the first guy, reset the head
; 645  : 		// otherwise, make our previous node's next pointer = our next
; 646  : 		if ( pOldElem->m_Previous != INVALID_LLIST_IDX )

	mov	edx, DWORD PTR _pOldElem$73232[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+72]
	cmp	eax, 65535				; 0000ffffH
	je	SHORT $L73234

; 648  : 			pBase[pOldElem->m_Previous].m_Next = pOldElem->m_Next;

	mov	ecx, DWORD PTR _pOldElem$73232[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+72]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR _pBase$73231[ebp]
	mov	ecx, DWORD PTR _pOldElem$73232[ebp]
	mov	cx, WORD PTR [ecx+74]
	mov	WORD PTR [eax+edx+74], cx

; 650  : 		else

	jmp	SHORT $L73235
$L73234:

; 652  : 			m_Head = pOldElem->m_Next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pOldElem$73232[ebp]
	mov	cx, WORD PTR [eax+74]
	mov	WORD PTR [edx+12], cx
$L73235:

; 654  : 		
; 655  : 		// If we're the last guy, reset the tail
; 656  : 		// otherwise, make our next node's prev pointer = our prev
; 657  : 		if ( pOldElem->m_Next != INVALID_LLIST_IDX )

	mov	edx, DWORD PTR _pOldElem$73232[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+74]
	cmp	eax, 65535				; 0000ffffH
	je	SHORT $L73237

; 659  : 			pBase[pOldElem->m_Next].m_Previous = pOldElem->m_Previous;

	mov	ecx, DWORD PTR _pOldElem$73232[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+74]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR _pBase$73231[ebp]
	mov	ecx, DWORD PTR _pOldElem$73232[ebp]
	mov	cx, WORD PTR [ecx+72]
	mov	WORD PTR [eax+edx+72], cx

; 661  : 		else

	jmp	SHORT $L73238
$L73237:

; 663  : 			m_Tail = pOldElem->m_Previous;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pOldElem$73232[ebp]
	mov	cx, WORD PTR [eax+72]
	mov	WORD PTR [edx+14], cx
$L73238:

; 665  : 		
; 666  : 		// This marks this node as not in the list, 
; 667  : 		// but not in the free list either
; 668  : 		pOldElem->m_Previous = pOldElem->m_Next = elem;

	mov	edx, DWORD PTR _pOldElem$73232[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+74], ax
	mov	ecx, DWORD PTR _pOldElem$73232[ebp]
	mov	dx, WORD PTR _elem$[ebp]
	mov	WORD PTR [ecx+72], dx

; 669  : 		
; 670  : 		// One less puppy
; 671  : 		--m_ElementCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+18]
	sub	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+18], cx
$L73230:

; 673  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Unlink@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Unlink
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Grow
;	COMDAT ?AllocInternal@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEG_N@Z
_TEXT	SEGMENT
_multilist$ = 8
_this$ = -4
_elem$ = -8
?AllocInternal@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEG_N@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::AllocInternal, COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 336  : 	I elem;
; 337  : 	if (m_FirstFree == InvalidIndex())

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+16]
	mov	esi, ecx
	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	$L73244

; 339  : 		// Nothing in the free list; add.
; 340  : 		// Since nothing is in the free list, m_TotalElements == total # of elements
; 341  : 		// the list knows about.
; 342  : 		if (m_TotalElements == m_Memory.NumAllocated())

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::NumAllocated
	cmp	esi, eax
	jne	SHORT $L73245

; 343  : 			m_Memory.Grow();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Grow
$L73245:

; 344  : 
; 345  : 		assert( m_TotalElements != InvalidIndex() );

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	mov	esi, edx
	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L74946
	push	345					; 00000159H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74946:

; 346  : 
; 347  : 		elem = (I)m_TotalElements;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+20]
	mov	WORD PTR _elem$[ebp], dx

; 348  : 		++m_TotalElements;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+20]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], cx

; 349  : 
; 350  : 		assert( elem != InvalidIndex() );

	mov	esi, DWORD PTR _elem$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L74947
	push	350					; 0000015eH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74947:

; 352  : 	else

	jmp	SHORT $L73249
$L73244:

; 354  : 		elem = m_FirstFree;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+16]
	mov	WORD PTR _elem$[ebp], dx

; 355  : 		m_FirstFree = InternalElement(m_FirstFree).m_Next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+74]
	mov	WORD PTR [edx+16], ax
$L73249:

; 357  : 	
; 358  : 	if (!multilist)

	mov	ecx, DWORD PTR _multilist$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L73250

; 359  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = elem;

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+72], cx
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+74], cx

; 360  : 	else

	jmp	SHORT $L73251
$L73250:

; 361  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	mov	si, ax
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	add	eax, 72					; 00000048H
	mov	DWORD PTR -12+[ebp], eax
	mov	eax, DWORD PTR -12+[ebp]
	mov	WORD PTR [eax], si
	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	edx, DWORD PTR -12+[ebp]
	mov	cx, WORD PTR [edx]
	mov	WORD PTR [eax+74], cx
$L73251:

; 362  : 
; 363  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ResetDbgInfo

; 364  : 
; 365  : 	return elem;

	mov	ax, WORD PTR _elem$[ebp]

; 366  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocInternal@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEG_N@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::AllocInternal
_TEXT	ENDS
PUBLIC	??0Decal_t@CStudioModelRenderer@@QAE@XZ		; CStudioModelRenderer::Decal_t::Decal_t
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlmemory.h
xdata$x	SEGMENT
__ehfuncinfo$?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z$0
xdata$x	ENDS
;	COMDAT ?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
$T74950 = -16
$T74951 = -20
__$EHRec$ = -12
?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z PROC NEAR ; Construct, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 38   : 	new( pMemory ) T;

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	72					; 00000048H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T74951[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T74951[ebp], 0
	je	SHORT $L74952
	mov	ecx, DWORD PTR $T74951[ebp]
	call	??0Decal_t@CStudioModelRenderer@@QAE@XZ	; CStudioModelRenderer::Decal_t::Decal_t
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L74953
$L74952:
	mov	DWORD PTR -24+[ebp], 0
$L74953:
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T74950[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 39   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z$0:
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T74951[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?Construct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z ENDP	; Construct
;	COMDAT ?Destruct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z PROC NEAR ; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	72					; 00000048H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z ENDP	; Destruct
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L74965
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L74965
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L74966
$L74965:
	mov	DWORD PTR -8+[ebp], 0
$L74966:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Element, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]

; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Element
_TEXT	ENDS
PUBLIC	?IsInList@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsInList
;	COMDAT ?LinkBefore@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXGG@Z
_TEXT	SEGMENT
_before$ = 8
_elem$ = 12
_this$ = -4
_newElem$ = -8
_beforeElem$73283 = -12
?LinkBefore@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::LinkBefore, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 560  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74973
	push	560					; 00000230H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74973:

; 561  : 	
; 562  : 	// Unlink it if it's in the list at the moment
; 563  : 	Unlink(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlink@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Unlink

; 564  : 	
; 565  : 	ListElem_t& newElem = InternalElement(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	mov	DWORD PTR _newElem$[ebp], eax

; 566  : 	
; 567  : 	// The element *after* our newly linked one is the one we linked before.
; 568  : 	newElem.m_Next = before;

	mov	ecx, DWORD PTR _newElem$[ebp]
	mov	dx, WORD PTR _before$[ebp]
	mov	WORD PTR [ecx+6], dx

; 569  : 	
; 570  : 	if (before == InvalidIndex())

	mov	esi, DWORD PTR _before$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L73280

; 572  : 		// In this case, we're linking to the end of the list, so reset the tail
; 573  : 		newElem.m_Previous = m_Tail;

	mov	eax, DWORD PTR _newElem$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+14]
	mov	WORD PTR [eax+4], dx

; 574  : 		m_Tail = elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+14], cx

; 576  : 	else

	jmp	SHORT $L73281
$L73280:

; 578  : 		// Here, we're not linking to the end. Set the prev pointer to point to
; 579  : 		// the element we're linking.
; 580  : 		assert( IsInList(before) );

	mov	dx, WORD PTR _before$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsInList
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74974
	push	580					; 00000244H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74974:

; 581  : 		ListElem_t& beforeElem = InternalElement(before);

	mov	cx, WORD PTR _before$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	mov	DWORD PTR _beforeElem$73283[ebp], eax

; 582  : 		newElem.m_Previous = beforeElem.m_Previous;

	mov	edx, DWORD PTR _newElem$[ebp]
	mov	eax, DWORD PTR _beforeElem$73283[ebp]
	mov	cx, WORD PTR [eax+4]
	mov	WORD PTR [edx+4], cx

; 583  : 		beforeElem.m_Previous = elem;

	mov	edx, DWORD PTR _beforeElem$73283[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+4], ax
$L73281:

; 585  : 	
; 586  : 	// Reset the head if we linked to the head of the list
; 587  : 	if (newElem.m_Previous == InvalidIndex())

	mov	ecx, DWORD PTR _newElem$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+4]
	mov	esi, edx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L73284

; 588  : 		m_Head = elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+12], cx

; 589  : 	else

	jmp	SHORT $L73285
$L73284:

; 590  : 		InternalElement(newElem.m_Previous).m_Next = elem;

	mov	edx, DWORD PTR _newElem$[ebp]
	mov	ax, WORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+6], cx
$L73285:

; 591  : 	
; 592  : 	// one more element baby
; 593  : 	++m_ElementCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+18]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+18], ax

; 594  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?LinkBefore@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::LinkBefore
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Base
;	COMDAT ?Unlink@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_pBase$73292 = -8
_pOldElem$73293 = -12
?Unlink@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Unlink, COMDAT

; 637  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74977
	push	638					; 0000027eH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74977:

; 639  : 	if (IsInList(elem))

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsInList
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L73291

; 641  : 		ListElem_t *pBase = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Base
	mov	DWORD PTR _pBase$73292[ebp], eax

; 642  : 		ListElem_t *pOldElem = &pBase[elem];

	mov	eax, DWORD PTR _elem$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _pBase$73292[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _pOldElem$73293[ebp], edx

; 643  : 		
; 644  : 		// If we're the first guy, reset the head
; 645  : 		// otherwise, make our previous node's next pointer = our next
; 646  : 		if ( pOldElem->m_Previous != INVALID_LLIST_IDX )

	mov	eax, DWORD PTR _pOldElem$73293[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+4]
	cmp	ecx, 65535				; 0000ffffH
	je	SHORT $L73295

; 648  : 			pBase[pOldElem->m_Previous].m_Next = pOldElem->m_Next;

	mov	edx, DWORD PTR _pOldElem$73293[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+4]
	mov	ecx, DWORD PTR _pBase$73292[ebp]
	mov	edx, DWORD PTR _pOldElem$73293[ebp]
	mov	dx, WORD PTR [edx+6]
	mov	WORD PTR [ecx+eax*8+6], dx

; 650  : 		else

	jmp	SHORT $L73296
$L73295:

; 652  : 			m_Head = pOldElem->m_Next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOldElem$73293[ebp]
	mov	dx, WORD PTR [ecx+6]
	mov	WORD PTR [eax+12], dx
$L73296:

; 654  : 		
; 655  : 		// If we're the last guy, reset the tail
; 656  : 		// otherwise, make our next node's prev pointer = our prev
; 657  : 		if ( pOldElem->m_Next != INVALID_LLIST_IDX )

	mov	eax, DWORD PTR _pOldElem$73293[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+6]
	cmp	ecx, 65535				; 0000ffffH
	je	SHORT $L73298

; 659  : 			pBase[pOldElem->m_Next].m_Previous = pOldElem->m_Previous;

	mov	edx, DWORD PTR _pOldElem$73293[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+6]
	mov	ecx, DWORD PTR _pBase$73292[ebp]
	mov	edx, DWORD PTR _pOldElem$73293[ebp]
	mov	dx, WORD PTR [edx+4]
	mov	WORD PTR [ecx+eax*8+4], dx

; 661  : 		else

	jmp	SHORT $L73299
$L73298:

; 663  : 			m_Tail = pOldElem->m_Previous;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOldElem$73293[ebp]
	mov	dx, WORD PTR [ecx+4]
	mov	WORD PTR [eax+14], dx
$L73299:

; 665  : 		
; 666  : 		// This marks this node as not in the list, 
; 667  : 		// but not in the free list either
; 668  : 		pOldElem->m_Previous = pOldElem->m_Next = elem;

	mov	eax, DWORD PTR _pOldElem$73293[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+6], cx
	mov	edx, DWORD PTR _pOldElem$73293[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+4], ax

; 669  : 		
; 670  : 		// One less puppy
; 671  : 		--m_ElementCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+18]
	sub	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], dx
$L73291:

; 673  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Unlink@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Unlink
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsValidIndex, COMDAT

; 277  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return (i < m_TotalElements) && (i >= 0) &&
; 279  : 		((m_Memory[i].m_Previous != i) || (m_Memory[i].m_Next == i));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L74980
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L74980
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L74981
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+6]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L74980
$L74981:
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L74982
$L74980:
	mov	DWORD PTR -8+[ebp], 0
$L74982:
	mov	al, BYTE PTR -8+[ebp]

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsValidIndex
_TEXT	ENDS
PUBLIC	?ResetDbgInfo@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ResetDbgInfo
PUBLIC	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Grow
;	COMDAT ?AllocInternal@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEG_N@Z
_TEXT	SEGMENT
_multilist$ = 8
_this$ = -4
_elem$ = -8
?AllocInternal@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEG_N@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::AllocInternal, COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 336  : 	I elem;
; 337  : 	if (m_FirstFree == InvalidIndex())

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+16]
	mov	esi, ecx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	$L73309

; 339  : 		// Nothing in the free list; add.
; 340  : 		// Since nothing is in the free list, m_TotalElements == total # of elements
; 341  : 		// the list knows about.
; 342  : 		if (m_TotalElements == m_Memory.NumAllocated())

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::NumAllocated
	cmp	esi, eax
	jne	SHORT $L73310

; 343  : 			m_Memory.Grow();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Grow
$L73310:

; 344  : 
; 345  : 		assert( m_TotalElements != InvalidIndex() );

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	mov	esi, edx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L74985
	push	345					; 00000159H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74985:

; 346  : 
; 347  : 		elem = (I)m_TotalElements;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+20]
	mov	WORD PTR _elem$[ebp], dx

; 348  : 		++m_TotalElements;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+20]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], cx

; 349  : 
; 350  : 		assert( elem != InvalidIndex() );

	mov	esi, DWORD PTR _elem$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L74986
	push	350					; 0000015eH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L74986:

; 352  : 	else

	jmp	SHORT $L73314
$L73309:

; 354  : 		elem = m_FirstFree;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+16]
	mov	WORD PTR _elem$[ebp], dx

; 355  : 		m_FirstFree = InternalElement(m_FirstFree).m_Next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+6]
	mov	WORD PTR [edx+16], ax
$L73314:

; 357  : 	
; 358  : 	if (!multilist)

	mov	ecx, DWORD PTR _multilist$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L73315

; 359  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = elem;

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+4], cx
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+6], cx

; 360  : 	else

	jmp	SHORT $L73316
$L73315:

; 361  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	mov	si, ax
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	add	eax, 4
	mov	DWORD PTR -12+[ebp], eax
	mov	eax, DWORD PTR -12+[ebp]
	mov	WORD PTR [eax], si
	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	mov	edx, DWORD PTR -12+[ebp]
	mov	cx, WORD PTR [edx]
	mov	WORD PTR [eax+6], cx
$L73316:

; 362  : 
; 363  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ResetDbgInfo

; 364  : 
; 365  : 	return elem;

	mov	ax, WORD PTR _elem$[ebp]

; 366  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocInternal@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEG_N@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::AllocInternal
_TEXT	ENDS
;	COMDAT ?Construct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
$T74989 = -4
?Construct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z PROC NEAR ; Construct, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 38   : 	new( pMemory ) T;

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T74989[ebp], eax

; 39   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Construct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z ENDP ; Construct
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z PROC NEAR ; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z ENDP ; Destruct
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L74994
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L74994
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L74995
$L74994:
	mov	DWORD PTR -8+[ebp], 0
$L74995:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?Previous@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Previous@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Previous, COMDAT

; 258  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 259  : 	assert( IsValidIndex(i) ); 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75000
	push	259					; 00000103H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75000:

; 260  : 	return InternalElement(i).m_Previous; 

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
	mov	ax, WORD PTR [eax+92]

; 261  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Previous@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBEGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Previous
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L75003
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L75003
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L75004
$L75003:
	mov	DWORD PTR -8+[ebp], 0
$L75004:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L75007
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75007:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Base
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEHXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEHXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::NumAllocated
_TEXT	ENDS
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
EXTRN	_malloc:NEAR
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEXH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L75012
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75012:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L73355

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L75013
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75013:

; 567  : 		return;

	jmp	$L73352
$L73355:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	96					; 00000060H
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L73375

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L73367
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L73367

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L73375
$L73367:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L73371

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75014
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75014:

; 589  : 				return;

	jmp	$L73352
$L73371:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L73375

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L73371
$L73375:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L73378

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 96					; 00000060H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L75015
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75015:

; 603  : 	else

	jmp	SHORT $L75016
$L73378:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 96					; 00000060H
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L75016
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75016:
$L73352:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L64793

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L64798
$L64793:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L64795

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L64795:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L64798

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L64795
$L64798:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
PUBLIC	??_GDecalMaterial_t@CStudioModelRenderer@@QAEPAXI@Z ; CStudioModelRenderer::DecalMaterial_t::`scalar deleting destructor'
;	COMDAT ?Destruct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z PROC NEAR ; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();

	push	0
	mov	ecx, DWORD PTR _pMemory$[ebp]
	call	??_GDecalMaterial_t@CStudioModelRenderer@@QAEPAXI@Z ; CStudioModelRenderer::DecalMaterial_t::`scalar deleting destructor'

; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	92					; 0000005cH
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z ENDP ; Destruct
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Element, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]

; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Element
_TEXT	ENDS
PUBLIC	?IsInList@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsInList
;	COMDAT ?LinkBefore@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXGG@Z
_TEXT	SEGMENT
_before$ = 8
_elem$ = 12
_this$ = -4
_newElem$ = -8
_beforeElem$73406 = -12
?LinkBefore@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::LinkBefore, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 560  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75027
	push	560					; 00000230H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75027:

; 561  : 	
; 562  : 	// Unlink it if it's in the list at the moment
; 563  : 	Unlink(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlink@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Unlink

; 564  : 	
; 565  : 	ListElem_t& newElem = InternalElement(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
	mov	DWORD PTR _newElem$[ebp], eax

; 566  : 	
; 567  : 	// The element *after* our newly linked one is the one we linked before.
; 568  : 	newElem.m_Next = before;

	mov	ecx, DWORD PTR _newElem$[ebp]
	mov	dx, WORD PTR _before$[ebp]
	mov	WORD PTR [ecx+34], dx

; 569  : 	
; 570  : 	if (before == InvalidIndex())

	mov	esi, DWORD PTR _before$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L73403

; 572  : 		// In this case, we're linking to the end of the list, so reset the tail
; 573  : 		newElem.m_Previous = m_Tail;

	mov	eax, DWORD PTR _newElem$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+14]
	mov	WORD PTR [eax+32], dx

; 574  : 		m_Tail = elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+14], cx

; 576  : 	else

	jmp	SHORT $L73404
$L73403:

; 578  : 		// Here, we're not linking to the end. Set the prev pointer to point to
; 579  : 		// the element we're linking.
; 580  : 		assert( IsInList(before) );

	mov	dx, WORD PTR _before$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsInList
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75028
	push	580					; 00000244H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75028:

; 581  : 		ListElem_t& beforeElem = InternalElement(before);

	mov	cx, WORD PTR _before$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
	mov	DWORD PTR _beforeElem$73406[ebp], eax

; 582  : 		newElem.m_Previous = beforeElem.m_Previous;

	mov	edx, DWORD PTR _newElem$[ebp]
	mov	eax, DWORD PTR _beforeElem$73406[ebp]
	mov	cx, WORD PTR [eax+32]
	mov	WORD PTR [edx+32], cx

; 583  : 		beforeElem.m_Previous = elem;

	mov	edx, DWORD PTR _beforeElem$73406[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+32], ax
$L73404:

; 585  : 	
; 586  : 	// Reset the head if we linked to the head of the list
; 587  : 	if (newElem.m_Previous == InvalidIndex())

	mov	ecx, DWORD PTR _newElem$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+32]
	mov	esi, edx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L73407

; 588  : 		m_Head = elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+12], cx

; 589  : 	else

	jmp	SHORT $L73408
$L73407:

; 590  : 		InternalElement(newElem.m_Previous).m_Next = elem;

	mov	edx, DWORD PTR _newElem$[ebp]
	mov	ax, WORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+34], cx
$L73408:

; 591  : 	
; 592  : 	// one more element baby
; 593  : 	++m_ElementCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+18]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+18], ax

; 594  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?LinkBefore@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::LinkBefore
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Base
;	COMDAT ?Unlink@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_pBase$73415 = -8
_pOldElem$73416 = -12
?Unlink@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Unlink, COMDAT

; 637  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75031
	push	638					; 0000027eH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75031:

; 639  : 	if (IsInList(elem))

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsInList
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L73414

; 641  : 		ListElem_t *pBase = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Base
	mov	DWORD PTR _pBase$73415[ebp], eax

; 642  : 		ListElem_t *pOldElem = &pBase[elem];

	mov	eax, DWORD PTR _elem$[ebp]
	and	eax, 65535				; 0000ffffH
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _pBase$73415[ebp]
	add	ecx, eax
	mov	DWORD PTR _pOldElem$73416[ebp], ecx

; 643  : 		
; 644  : 		// If we're the first guy, reset the head
; 645  : 		// otherwise, make our previous node's next pointer = our next
; 646  : 		if ( pOldElem->m_Previous != INVALID_LLIST_IDX )

	mov	edx, DWORD PTR _pOldElem$73416[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+32]
	cmp	eax, 65535				; 0000ffffH
	je	SHORT $L73418

; 648  : 			pBase[pOldElem->m_Previous].m_Next = pOldElem->m_Next;

	mov	ecx, DWORD PTR _pOldElem$73416[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+32]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _pBase$73415[ebp]
	mov	ecx, DWORD PTR _pOldElem$73416[ebp]
	mov	cx, WORD PTR [ecx+34]
	mov	WORD PTR [eax+edx+34], cx

; 650  : 		else

	jmp	SHORT $L73419
$L73418:

; 652  : 			m_Head = pOldElem->m_Next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pOldElem$73416[ebp]
	mov	cx, WORD PTR [eax+34]
	mov	WORD PTR [edx+12], cx
$L73419:

; 654  : 		
; 655  : 		// If we're the last guy, reset the tail
; 656  : 		// otherwise, make our next node's prev pointer = our prev
; 657  : 		if ( pOldElem->m_Next != INVALID_LLIST_IDX )

	mov	edx, DWORD PTR _pOldElem$73416[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+34]
	cmp	eax, 65535				; 0000ffffH
	je	SHORT $L73421

; 659  : 			pBase[pOldElem->m_Next].m_Previous = pOldElem->m_Previous;

	mov	ecx, DWORD PTR _pOldElem$73416[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+34]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _pBase$73415[ebp]
	mov	ecx, DWORD PTR _pOldElem$73416[ebp]
	mov	cx, WORD PTR [ecx+32]
	mov	WORD PTR [eax+edx+32], cx

; 661  : 		else

	jmp	SHORT $L73422
$L73421:

; 663  : 			m_Tail = pOldElem->m_Previous;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pOldElem$73416[ebp]
	mov	cx, WORD PTR [eax+32]
	mov	WORD PTR [edx+14], cx
$L73422:

; 665  : 		
; 666  : 		// This marks this node as not in the list, 
; 667  : 		// but not in the free list either
; 668  : 		pOldElem->m_Previous = pOldElem->m_Next = elem;

	mov	edx, DWORD PTR _pOldElem$73416[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+34], ax
	mov	ecx, DWORD PTR _pOldElem$73416[ebp]
	mov	dx, WORD PTR _elem$[ebp]
	mov	WORD PTR [ecx+32], dx

; 669  : 		
; 670  : 		// One less puppy
; 671  : 		--m_ElementCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+18]
	sub	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+18], cx
$L73414:

; 673  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Unlink@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Unlink
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsValidIndex, COMDAT

; 277  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return (i < m_TotalElements) && (i >= 0) &&
; 279  : 		((m_Memory[i].m_Previous != i) || (m_Memory[i].m_Next == i));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L75034
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L75034
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+32]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L75035
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+34]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L75034
$L75035:
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L75036
$L75034:
	mov	DWORD PTR -8+[ebp], 0
$L75036:
	mov	al, BYTE PTR -8+[ebp]

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsValidIndex
_TEXT	ENDS
PUBLIC	?ResetDbgInfo@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ResetDbgInfo
PUBLIC	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Grow
;	COMDAT ?AllocInternal@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEG_N@Z
_TEXT	SEGMENT
_multilist$ = 8
_this$ = -4
_elem$ = -8
?AllocInternal@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEG_N@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::AllocInternal, COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 336  : 	I elem;
; 337  : 	if (m_FirstFree == InvalidIndex())

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+16]
	mov	esi, ecx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	$L73432

; 339  : 		// Nothing in the free list; add.
; 340  : 		// Since nothing is in the free list, m_TotalElements == total # of elements
; 341  : 		// the list knows about.
; 342  : 		if (m_TotalElements == m_Memory.NumAllocated())

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::NumAllocated
	cmp	esi, eax
	jne	SHORT $L73433

; 343  : 			m_Memory.Grow();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Grow
$L73433:

; 344  : 
; 345  : 		assert( m_TotalElements != InvalidIndex() );

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	mov	esi, edx
	call	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L75039
	push	345					; 00000159H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75039:

; 346  : 
; 347  : 		elem = (I)m_TotalElements;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+20]
	mov	WORD PTR _elem$[ebp], dx

; 348  : 		++m_TotalElements;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+20]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], cx

; 349  : 
; 350  : 		assert( elem != InvalidIndex() );

	mov	esi, DWORD PTR _elem$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L75040
	push	350					; 0000015eH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75040:

; 352  : 	else

	jmp	SHORT $L73437
$L73432:

; 354  : 		elem = m_FirstFree;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+16]
	mov	WORD PTR _elem$[ebp], dx

; 355  : 		m_FirstFree = InternalElement(m_FirstFree).m_Next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+34]
	mov	WORD PTR [edx+16], ax
$L73437:

; 357  : 	
; 358  : 	if (!multilist)

	mov	ecx, DWORD PTR _multilist$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L73438

; 359  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = elem;

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+32], cx
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+34], cx

; 360  : 	else

	jmp	SHORT $L73439
$L73438:

; 361  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
	mov	si, ax
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
	add	eax, 32					; 00000020H
	mov	DWORD PTR -12+[ebp], eax
	mov	eax, DWORD PTR -12+[ebp]
	mov	WORD PTR [eax], si
	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
	mov	edx, DWORD PTR -12+[ebp]
	mov	cx, WORD PTR [edx]
	mov	WORD PTR [eax+34], cx
$L73439:

; 362  : 
; 363  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ResetDbgInfo

; 364  : 
; 365  : 	return elem;

	mov	ax, WORD PTR _elem$[ebp]

; 366  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocInternal@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEG_N@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::AllocInternal
_TEXT	ENDS
PUBLIC	??0DecalModelList_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::DecalModelList_t::DecalModelList_t
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlmemory.h
xdata$x	SEGMENT
__ehfuncinfo$?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z$0
xdata$x	ENDS
;	COMDAT ?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
$T75043 = -16
$T75044 = -20
__$EHRec$ = -12
_pMemory$ = 8
?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z PROC NEAR ; Construct, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 38   : 	new( pMemory ) T;

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	32					; 00000020H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T75044[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T75044[ebp], 0
	je	SHORT $L75045
	mov	ecx, DWORD PTR $T75044[ebp]
	call	??0DecalModelList_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::DecalModelList_t::DecalModelList_t
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L75046
$L75045:
	mov	DWORD PTR -24+[ebp], 0
$L75046:
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T75043[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 39   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z$0:
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T75044[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?Construct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z ENDP ; Construct
PUBLIC	??_GDecalModelList_t@CStudioModelRenderer@@QAEPAXI@Z ; CStudioModelRenderer::DecalModelList_t::`scalar deleting destructor'
;	COMDAT ?Destruct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z PROC NEAR ; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();

	push	0
	mov	ecx, DWORD PTR _pMemory$[ebp]
	call	??_GDecalModelList_t@CStudioModelRenderer@@QAEPAXI@Z ; CStudioModelRenderer::DecalModelList_t::`scalar deleting destructor'

; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	32					; 00000020H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z ENDP ; Destruct
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L75058
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L75058
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L75059
$L75058:
	mov	DWORD PTR -8+[ebp], 0
$L75059:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L75064
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L75064
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L75065
$L75064:
	mov	DWORD PTR -8+[ebp], 0
$L75065:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ??0DecalVertex_t@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0DecalVertex_t@@QAE@ABU0@@Z PROC NEAR			; DecalVertex_t::DecalVertex_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], eax
	mov	DWORD PTR [edx+28], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], edx
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], eax
	mov	DWORD PTR [edx+56], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dx, WORD PTR [ecx+60]
	mov	WORD PTR [eax+60], dx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0DecalVertex_t@@QAE@ABU0@@Z ENDP			; DecalVertex_t::DecalVertex_t
_TEXT	ENDS
;	COMDAT ??0Decal_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Decal_t@CStudioModelRenderer@@QAE@XZ PROC NEAR	; CStudioModelRenderer::Decal_t::Decal_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Decal_t@CStudioModelRenderer@@QAE@XZ ENDP		; CStudioModelRenderer::Decal_t::Decal_t
_TEXT	ENDS
PUBLIC	??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ	; CStudioModelRenderer::DecalMaterial_t::~DecalMaterial_t
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ??_GDecalMaterial_t@CStudioModelRenderer@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GDecalMaterial_t@CStudioModelRenderer@@QAEPAXI@Z PROC NEAR ; CStudioModelRenderer::DecalMaterial_t::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::DecalMaterial_t::~DecalMaterial_t
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L73475
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L73475:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDecalMaterial_t@CStudioModelRenderer@@QAEPAXI@Z ENDP ; CStudioModelRenderer::DecalMaterial_t::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>
;	COMDAT ??0DecalModelList_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0DecalModelList_t@CStudioModelRenderer@@QAE@XZ PROC NEAR ; CStudioModelRenderer::DecalModelList_t::DecalModelList_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0DecalModelList_t@CStudioModelRenderer@@QAE@XZ ENDP	; CStudioModelRenderer::DecalModelList_t::DecalModelList_t
_TEXT	ENDS
PUBLIC	??1DecalModelList_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::DecalModelList_t::~DecalModelList_t
;	COMDAT ??_GDecalModelList_t@CStudioModelRenderer@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GDecalModelList_t@CStudioModelRenderer@@QAEPAXI@Z PROC NEAR ; CStudioModelRenderer::DecalModelList_t::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DecalModelList_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::DecalModelList_t::~DecalModelList_t
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L73480
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L73480:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDecalModelList_t@CStudioModelRenderer@@QAEPAXI@Z ENDP ; CStudioModelRenderer::DecalModelList_t::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ DD 019930520H
	DD	02H
	DD	FLAT:__unwindtable$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT ??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ PROC NEAR ; CStudioModelRenderer::DecalMaterial_t::~DecalMaterial_t, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::~CUtlLinkedList<DecalVertex_t,unsigned short>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::~CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::~CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >
	ret	0
__unwindfunclet$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::~CUtlLinkedList<DecalVertex_t,unsigned short>
	ret	0
__ehhandler$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ ENDP	; CStudioModelRenderer::DecalMaterial_t::~DecalMaterial_t
PUBLIC	?RemoveAll@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::RemoveAll
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 182  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::RemoveAll

; 183  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>
PUBLIC	??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>
;	COMDAT ??1DecalModelList_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1DecalModelList_t@CStudioModelRenderer@@QAE@XZ PROC NEAR ; CStudioModelRenderer::DecalModelList_t::~DecalModelList_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1DecalModelList_t@CStudioModelRenderer@@QAE@XZ ENDP	; CStudioModelRenderer::DecalModelList_t::~DecalModelList_t
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ ENDP ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ResetDbgInfo
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::ResetDbgInfo, COMDAT

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		m_pElements = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@XZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 141  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEXXZ ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::ResetDbgInfo
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ResetDbgInfo, COMDAT

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		m_pElements = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 141  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ResetDbgInfo
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ResetDbgInfo, COMDAT

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		m_pElements = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 141  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ResetDbgInfo
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ResetDbgInfo, COMDAT

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		m_pElements = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 141  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@GH@@QAEXXZ			; CUtlMemory<unsigned short,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@GH@@QAEXXZ		; CUtlMemory<unsigned short,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ ENDP	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Purge
_TEXT	ENDS
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
PUBLIC	?ValidateGrowSize@?$CUtlMemory@GH@@IAEXXZ	; CUtlMemory<unsigned short,int>::ValidateGrowSize
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@GH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@GH@@QAE@HH@Z PROC NEAR			; CUtlMemory<unsigned short,int>::CUtlMemory<unsigned short,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@GH@@IAEXXZ ; CUtlMemory<unsigned short,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L75116
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75116:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L73507

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L73507:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@GH@@QAE@HH@Z ENDP			; CUtlMemory<unsigned short,int>::CUtlMemory<unsigned short,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@GH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@GH@@QAE@XZ PROC NEAR			; CUtlMemory<unsigned short,int>::~CUtlMemory<unsigned short,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@GH@@QAEXXZ		; CUtlMemory<unsigned short,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@GH@@QAE@XZ ENDP				; CUtlMemory<unsigned short,int>::~CUtlMemory<unsigned short,int>
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@GH@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@GH@@QBEHXZ PROC NEAR		; CUtlMemory<unsigned short,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@GH@@QBEHXZ ENDP		; CUtlMemory<unsigned short,int>::NumAllocated
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@GH@@QBE_NXZ	; CUtlMemory<unsigned short,int>::IsExternallyAllocated
;	COMDAT ?Grow@?$CUtlMemory@GH@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@GH@@QAEXH@Z PROC NEAR		; CUtlMemory<unsigned short,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L75123
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75123:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@GH@@QBE_NXZ ; CUtlMemory<unsigned short,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L73521

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L75124
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75124:

; 567  : 		return;

	jmp	$L73519
$L73521:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	2
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L73540

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L73532
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L73532

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L73540
$L73532:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L73536

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75125
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75125:

; 589  : 				return;

	jmp	$L73519
$L73536:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L73540

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L73536
$L73540:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L73543

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L75126
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75126:

; 603  : 	else

	jmp	SHORT $L75127
$L73543:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L75127
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75127:
$L73519:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@GH@@QAEXH@Z ENDP			; CUtlMemory<unsigned short,int>::Grow
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_prev$ = -8
_i$ = -12
?RemoveAll@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXXZ PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::RemoveAll, COMDAT

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 524  : 	if (m_TotalElements == 0)

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $L73554

; 525  : 		return;

	jmp	$L73553
$L73554:

; 526  : 
; 527  : 	// Put everything into the free list
; 528  : 	I prev = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	mov	WORD PTR _prev$[ebp], ax

; 529  : 	for (int i = (int)m_TotalElements; --i >= 0; )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	DWORD PTR _i$[ebp], eax
$L73559:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L73560

; 531  : 		// Invoke the destructor
; 532  : 		if (IsValidIndex((I)i))

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L73562

; 533  : 			Destruct( &Element((I)i) );

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Element
	push	eax
	call	?Destruct@@YAXPAUDecalVertex_t@@@Z	; Destruct
	add	esp, 4
$L73562:

; 534  : 		
; 535  : 		// next points to the next free list item
; 536  : 		InternalElement((I)i).m_Next = prev;

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	dx, WORD PTR _prev$[ebp]
	mov	WORD PTR [eax+66], dx

; 537  : 		
; 538  : 		// Indicates it's in the free list
; 539  : 		InternalElement((I)i).m_Previous = (I)i;

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+64], cx

; 540  : 		prev = (I)i;

	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR _prev$[ebp], dx

; 541  : 	}

	jmp	SHORT $L73559
$L73560:

; 542  : 	
; 543  : 	// First free points to the first element
; 544  : 	m_FirstFree = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+16], 0

; 545  : 	
; 546  : 	// Clear everything else out
; 547  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 548  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 549  : 	m_ElementCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0
$L73553:

; 550  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXXZ ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::RemoveAll
_TEXT	ENDS
PUBLIC	?Previous@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Previous
;	COMDAT ?IsInList@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsInList@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsInList, COMDAT

; 284  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 285  : 	return (i < m_TotalElements) && (i >= 0) && (Previous(i) != i);

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L75132
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L75132
	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Previous@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Previous
	and	eax, 65535				; 0000ffffH
	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 65535				; 0000ffffH
	cmp	eax, edx
	je	SHORT $L75132
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L75133
$L75132:
	mov	DWORD PTR -8+[ebp], 0
$L75133:
	mov	al, BYTE PTR -8+[ebp]

; 286  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsInList@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsInList
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ConstructList@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::ConstructList, COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 189  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 190  : 	m_FirstFree = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+16], ax

; 191  : 	m_ElementCount = m_TotalElements = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0

; 192  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ConstructList@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEXXZ ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::ConstructList
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::ValidateGrowSize
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@HH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L75138
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75138:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L73584

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 68					; 00000044H
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L73584:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@HH@Z ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Purge
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L75143
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75143:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@XZ ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Base
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEHXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEHXZ ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::NumAllocated
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
;	COMDAT ?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L75148
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75148:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L73602

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L75149
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75149:

; 567  : 		return;

	jmp	$L73600
$L73602:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	68					; 00000044H
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L73621

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L73613
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L73613

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L73621
$L73613:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L73617

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75150
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75150:

; 589  : 				return;

	jmp	$L73600
$L73617:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L73621

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L73617
$L73621:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L73624

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 68					; 00000044H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L75151
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75151:

; 603  : 	else

	jmp	SHORT $L75152
$L73624:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 68					; 00000044H
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L75152
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75152:
$L73600:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXH@Z ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Grow
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_prev$ = -8
_i$ = -12
?RemoveAll@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::RemoveAll, COMDAT

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 524  : 	if (m_TotalElements == 0)

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $L73635

; 525  : 		return;

	jmp	$L73634
$L73635:

; 526  : 
; 527  : 	// Put everything into the free list
; 528  : 	I prev = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	mov	WORD PTR _prev$[ebp], ax

; 529  : 	for (int i = (int)m_TotalElements; --i >= 0; )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	DWORD PTR _i$[ebp], eax
$L73640:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L73641

; 531  : 		// Invoke the destructor
; 532  : 		if (IsValidIndex((I)i))

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L73643

; 533  : 			Destruct( &Element((I)i) );

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Element
	push	eax
	call	?Destruct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z ; Destruct
	add	esp, 4
$L73643:

; 534  : 		
; 535  : 		// next points to the next free list item
; 536  : 		InternalElement((I)i).m_Next = prev;

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	dx, WORD PTR _prev$[ebp]
	mov	WORD PTR [eax+74], dx

; 537  : 		
; 538  : 		// Indicates it's in the free list
; 539  : 		InternalElement((I)i).m_Previous = (I)i;

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+72], cx

; 540  : 		prev = (I)i;

	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR _prev$[ebp], dx

; 541  : 	}

	jmp	SHORT $L73640
$L73641:

; 542  : 	
; 543  : 	// First free points to the first element
; 544  : 	m_FirstFree = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+16], 0

; 545  : 	
; 546  : 	// Clear everything else out
; 547  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 548  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 549  : 	m_ElementCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0
$L73634:

; 550  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::RemoveAll
_TEXT	ENDS
PUBLIC	?Previous@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Previous
;	COMDAT ?IsInList@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsInList@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsInList, COMDAT

; 284  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 285  : 	return (i < m_TotalElements) && (i >= 0) && (Previous(i) != i);

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L75157
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L75157
	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Previous@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Previous
	and	eax, 65535				; 0000ffffH
	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 65535				; 0000ffffH
	cmp	eax, edx
	je	SHORT $L75157
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L75158
$L75157:
	mov	DWORD PTR -8+[ebp], 0
$L75158:
	mov	al, BYTE PTR -8+[ebp]

; 286  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsInList@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsInList
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ConstructList@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ConstructList, COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 189  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 190  : 	m_FirstFree = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+16], ax

; 191  : 	m_ElementCount = m_TotalElements = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0

; 192  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ConstructList@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ConstructList
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::ValidateGrowSize
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L75163
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75163:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L73665

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L73665:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Purge
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L75168
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75168:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Base
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEHXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEHXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::NumAllocated
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
;	COMDAT ?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L75173
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75173:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L73683

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L75174
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75174:

; 567  : 		return;

	jmp	$L73681
$L73683:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	76					; 0000004cH
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L73702

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L73694
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L73694

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L73702
$L73694:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L73698

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75175
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75175:

; 589  : 				return;

	jmp	$L73681
$L73698:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L73702

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L73698
$L73702:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L73705

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L75176
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75176:

; 603  : 	else

	jmp	SHORT $L75177
$L73705:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L75177
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75177:
$L73681:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Grow
_TEXT	ENDS
PUBLIC	?ConstructList@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ConstructList
PUBLIC	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>
PUBLIC	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_this$ = -16
??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>, COMDAT

; 166  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 167  : 	ConstructList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConstructList@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ConstructList

; 168  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ResetDbgInfo

; 169  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@HH@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>
PUBLIC	?RemoveAll@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::RemoveAll
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 182  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::RemoveAll

; 183  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>
PUBLIC	?Previous@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Previous
;	COMDAT ?IsInList@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsInList@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsInList, COMDAT

; 284  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 285  : 	return (i < m_TotalElements) && (i >= 0) && (Previous(i) != i);

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L75198
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L75198
	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Previous@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Previous
	and	eax, 65535				; 0000ffffH
	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 65535				; 0000ffffH
	cmp	eax, edx
	je	SHORT $L75198
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L75199
$L75198:
	mov	DWORD PTR -8+[ebp], 0
$L75199:
	mov	al, BYTE PTR -8+[ebp]

; 286  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsInList@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsInList
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75202
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75202:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L75205
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75205:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Base
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEHXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEHXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::NumAllocated
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
;	COMDAT ?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L75210
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75210:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L73742

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L75211
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75211:

; 567  : 		return;

	jmp	$L73740
$L73742:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	8
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L73761

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L73753
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L73753

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L73761
$L73753:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L73757

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75212
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75212:

; 589  : 				return;

	jmp	$L73740
$L73757:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L73761

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L73757
$L73761:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L73764

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L75213
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75213:

; 603  : 	else

	jmp	SHORT $L75214
$L73764:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 3
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L75214
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75214:
$L73740:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Grow
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
_TEXT	ENDS
PUBLIC	?Previous@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Previous
;	COMDAT ?IsInList@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsInList@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsInList, COMDAT

; 284  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 285  : 	return (i < m_TotalElements) && (i >= 0) && (Previous(i) != i);

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L75219
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L75219
	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Previous@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Previous
	and	eax, 65535				; 0000ffffH
	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 65535				; 0000ffffH
	cmp	eax, edx
	je	SHORT $L75219
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L75220
$L75219:
	mov	DWORD PTR -8+[ebp], 0
$L75220:
	mov	al, BYTE PTR -8+[ebp]

; 286  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsInList@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsInList
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75223
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75223:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L75226
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75226:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Base
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEHXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEHXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::NumAllocated
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
;	COMDAT ?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEXH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L75231
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75231:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L73796

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L75232
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75232:

; 567  : 		return;

	jmp	$L73794
$L73796:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	36					; 00000024H
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L73815

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L73807
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L73807

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L73815
$L73807:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L73811

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75233
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75233:

; 589  : 				return;

	jmp	$L73794
$L73811:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L73815

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L73811
$L73815:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L73818

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 36					; 00000024H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L75234
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75234:

; 603  : 	else

	jmp	SHORT $L75235
$L73818:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 36					; 00000024H
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L75235
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75235:
$L73794:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Grow
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@GH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@GH@@IAEXXZ PROC NEAR	; CUtlMemory<unsigned short,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@GH@@IAEXXZ ENDP		; CUtlMemory<unsigned short,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@IAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@IAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@IAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@IAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L73837:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L73838

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element
	push	eax
	call	?Destruct@@YAXPAG@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L73837
$L73838:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ ENDP	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::RemoveAll
_TEXT	ENDS
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@GH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@GH@@QAEXXZ PROC NEAR		; CUtlMemory<unsigned short,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@GH@@QBE_NXZ ; CUtlMemory<unsigned short,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L73845

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L73846

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L73846:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L73845:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@GH@@QAEXXZ ENDP			; CUtlMemory<unsigned short,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@GH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@GH@@QBE_NXZ PROC NEAR ; CUtlMemory<unsigned short,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@GH@@QBE_NXZ ENDP	; CUtlMemory<unsigned short,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?Previous@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Previous@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::Previous, COMDAT

; 258  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 259  : 	assert( IsValidIndex(i) ); 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75250
	push	259					; 00000103H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75250:

; 260  : 	return InternalElement(i).m_Previous; 

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	ax, WORD PTR [eax+64]

; 261  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Previous@?$CUtlLinkedList@UDecalVertex_t@@G@@QBEGG@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::Previous
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L73859

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L73860

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L73860:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L73859:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?Previous@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Previous@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Previous, COMDAT

; 258  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 259  : 	assert( IsValidIndex(i) ); 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75257
	push	259					; 00000103H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75257:

; 260  : 	return InternalElement(i).m_Previous; 

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	ax, WORD PTR [eax+72]

; 261  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Previous@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBEGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Previous
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L73873

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L73874

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L73874:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L73873:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_prev$ = -8
_i$ = -12
?RemoveAll@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::RemoveAll, COMDAT

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 524  : 	if (m_TotalElements == 0)

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $L73882

; 525  : 		return;

	jmp	$L73881
$L73882:

; 526  : 
; 527  : 	// Put everything into the free list
; 528  : 	I prev = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	mov	WORD PTR _prev$[ebp], ax

; 529  : 	for (int i = (int)m_TotalElements; --i >= 0; )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	DWORD PTR _i$[ebp], eax
$L73887:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L73888

; 531  : 		// Invoke the destructor
; 532  : 		if (IsValidIndex((I)i))

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L73890

; 533  : 			Destruct( &Element((I)i) );

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Element
	push	eax
	call	?Destruct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z ; Destruct
	add	esp, 4
$L73890:

; 534  : 		
; 535  : 		// next points to the next free list item
; 536  : 		InternalElement((I)i).m_Next = prev;

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	mov	dx, WORD PTR _prev$[ebp]
	mov	WORD PTR [eax+6], dx

; 537  : 		
; 538  : 		// Indicates it's in the free list
; 539  : 		InternalElement((I)i).m_Previous = (I)i;

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+4], cx

; 540  : 		prev = (I)i;

	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR _prev$[ebp], dx

; 541  : 	}

	jmp	SHORT $L73887
$L73888:

; 542  : 	
; 543  : 	// First free points to the first element
; 544  : 	m_FirstFree = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+16], 0

; 545  : 	
; 546  : 	// Clear everything else out
; 547  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 548  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 549  : 	m_ElementCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0
$L73881:

; 550  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::RemoveAll
_TEXT	ENDS
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
;	COMDAT ?Previous@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Previous@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Previous, COMDAT

; 258  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 259  : 	assert( IsValidIndex(i) ); 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75266
	push	259					; 00000103H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75266:

; 260  : 	return InternalElement(i).m_Previous; 

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	mov	ax, WORD PTR [eax+4]

; 261  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Previous@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBEGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Previous
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ConstructList@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ConstructList, COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 189  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 190  : 	m_FirstFree = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+16], ax

; 191  : 	m_ElementCount = m_TotalElements = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0

; 192  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ConstructList@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ConstructList
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::ValidateGrowSize
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L75271
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75271:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L73913

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 3
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L73913:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Purge
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
_TEXT	ENDS
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
;	COMDAT ?Previous@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Previous@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBEGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Previous, COMDAT

; 258  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 259  : 	assert( IsValidIndex(i) ); 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75278
	push	259					; 00000103H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L75278:

; 260  : 	return InternalElement(i).m_Previous; 

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
	mov	ax, WORD PTR [eax+32]

; 261  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Previous@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBEGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Previous
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement, COMDAT

; 136  : 	ListElem_t const& InternalElement( I i ) const { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@IAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@IAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z
_TEXT	SEGMENT
_this$ = -4
_i$ = 8
?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement, COMDAT

; 136  : 	ListElem_t const& InternalElement( I i ) const { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L73939

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L73940

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L73940:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L73939:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Purge
_TEXT	ENDS
END
