	TITLE	Z:\XashXTSRC\client\render\r_studio.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0M@FENB@cl_himodels?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@NMBJ@r_drawviewmodel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@IMCO@r_glowshellfreq?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DNEG@cl_righthand?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02OHJF@90?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@LDK@cl_viewmodel_fov?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FBAH@1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GFEF@r_studio_compatible?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03JFJK@5?40?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@OBFE@cl_lod_scale?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FDBP@cl_lod_bias?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PECN@incar?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@EKL@Couldn?8t?5create?5instance?5for?5ent@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DestroyInstance@CStudioModelRenderer@@EAEXG@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@HEGK@?$CFs?5static?5model?5have?5skeleton?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@FINL@Couldn?8t?5find?5submodel?5?$CFs?5for?5bo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@PKOH@CreateMeshCache?3?5memory?5buffer?5o@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BJFC@CreateMeshCache?3?5memory?5buffer?5u@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DM@IMPB@vertexlit?5instance?5created?0?5mode@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@FGLG@failed?5to?5create?5vertex?5lighting@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EE@GFNN@failed?5to?5create?5vertex?5lighting@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CLLM@failed?5to?5create?5vertex?5lighting@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??ReleaseVBOCache@CStudioModelRenderer@@EAEXPAPAUmvbocache_s@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DestroyMeshCache@CStudioModelRenderer@@EAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@IPNL@textures?1?$CFs?1?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CKIE@?$CFs?4tga?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06MMEP@?$CFs?4dds?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??LoadStudioMaterials@CStudioModelRenderer@@EAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??FreeStudioMaterials@CStudioModelRenderer@@EAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09DLNN@studioLOD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@FCKL@?$CFs?1?$CFs?$CFi?$CFi?4mdl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DENN@loading?3?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FJMP@Bip01?5Spine?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@EAIO@Bip01?5Pelvis?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??CalculateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DM@EGCF@StudioSetupBones?3?5sequence?5?$CFi?1?$CFi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??StudioBuildNormalTable@CStudioModelRenderer@@EAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??StudioGenerateNormals@CStudioModelRenderer@@EAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@KMAD@Too?5many?5attachments?5on?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??StudioDrawPoints@CStudioModelRenderer@@EAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DD@BPHA@FollowEntity?3?5?$CFi?5with?5model?5?$CFs?5h@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@PBGN@R_AddMeshToLightList?3?5light?5list@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@KGMD@R_AddMeshToDrawList?3?5mesh?5draw?5l@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@PPBK@?$CFs?5missed?5cache?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AddStudioToLightList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DrawLightForMeshList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DrawStudioMeshes@CStudioModelRenderer@@EAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DrawStudioMeshesShadow@CStudioModelRenderer@@EAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@QAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@Vector@@QAEXMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CrossProduct@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABVRadian@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QAEPAMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bmatrix3x4@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetForward@matrix3x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRight@matrix3x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetUp@matrix3x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOrigin@matrix3x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetForward@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRight@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetUp@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetOrigin@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVmatrix3x4@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QAEPAMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyToArray@matrix4x4@@QBEXPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FILE_EXISTS@@YA_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Random@RandomRange@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudBase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CHudBase@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VidInit@CHudBase@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@CHudBase@@UAEHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CHudBase@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@CHudBase@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitHUDData@CHudBase@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudBase@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudAmmo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudAmmo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudHealth@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudHealth@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudGeiger@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudGeiger@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudBattery@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudBattery@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudTrain@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudTrain@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudFlashlight@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudFlashlight@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudMessage@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudMessage@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudScoreboard@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudScoreboard@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudStatusBar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudStatusBar@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudDeathNotice@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudDeathNotice@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudSayText@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudSayText@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudMenu@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudMenu@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudAmmoSecondary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudAmmoSecondary@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudTextMessage@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudTextMessage@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudStatusIcons@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudStatusIcons@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudMOTD@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudMOTD@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ViewSmoothingData_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudAmmo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudBase@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudHealth@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudGeiger@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudBattery@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudTrain@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudFlashlight@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudMessage@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudScoreboard@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudStatusBar@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudDeathNotice@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudSayText@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudMenu@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudAmmoSecondary@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudTextMessage@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudStatusIcons@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudMOTD@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPlane@CFrustum@@QBEPBUmplane_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CJiggleBones@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CJiggleBones@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CStudioBoneSetup@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pHitboxSet@CStudioBoneSetup@@QBEPAUmstudiohitboxset_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountPoseParameters@CStudioBoneSetup@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNumIKChains@CStudioBoneSetup@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitBoneWeights@CStudioBoneSetup@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?debugMsg@CStudioBoneSetup@@UAAXPADZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?debugLine@CStudioBoneSetup@@UAEXABVVector@@0HHH_NM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStudioPointers@CStudioBoneSetup@@QAEXPAUstudiohdr_t@@PBM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBoneWeights@CStudioBoneSetup@@QAEXPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRealTime@CStudioBoneSetup@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E11
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E13
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E14
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HUD_GetStudioModelInterface@@YAHHPAPAUr_studio_interface_s@@PAUengine_studio_api_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?debugMsg@CBaseBoneSetup@@UAAXPADZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAnimSourceData@CBaseBoneSetup@@UAEPAUmstudioanim_t@@PAUmstudioseqdesc_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?debugLine@CBaseBoneSetup@@UAEXABVVector@@0HHH_NM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VidInit@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStudioModelRenderer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseBoneSetup@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DecalVertex_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CStudioModelRenderer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUcl_entity_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUgl_studiomesh_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioSetupInstance@CStudioModelRenderer@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsModelInstanceValid@CStudioModelRenderer@@EAE_NPAUModelInstance_t@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyInstance@CStudioModelRenderer@@EAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCJiggleBones@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearInstanceData@CStudioModelRenderer@@EAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessUserData@CStudioModelRenderer@@QAEXPAUmodel_s@@HPBE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckBoneCache@CStudioModelRenderer@@EAE_NM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadLocalMatrix@CStudioModelRenderer@@QAEXHPAUmstudioboneinfo_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ComputeSkinMatrix@CStudioModelRenderer@@EAEXPAUmstudioboneweight_t@@QBVmatrix3x4@@AAV3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E17
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0svert_v0_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E19
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0svert_v1_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E21
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0svert_v2_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E23
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0svert_v3_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E25
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0xvert_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E29
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E28
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E27
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateMeshCacheVL@CStudioModelRenderer@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeMeshCacheVL@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateMeshCacheVL@CStudioModelRenderer@@EAEXPAUdmodellight_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseVBOCache@CStudioModelRenderer@@EAEXPAPAUmvbocache_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyMeshCache@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStudioMaterials@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeStudioMaterials@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyAllModelInstances@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QSortStudioMeshes@CStudioModelRenderer@@AAEXPAUgl_studiomesh_t@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntityRenderMode@CStudioModelRenderer@@QAEHPAUcl_entity_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioExtractBbox@CStudioModelRenderer@@EAEHPAUcl_entity_s@@PAUstudiohdr_t@@HAAVVector@@2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioComputeBBox@CStudioModelRenderer@@EAEHPAUcl_entity_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioPlayerBlend@CStudioModelRenderer@@EAEXPAUmstudioseqdesc_t@@AAHAAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddBlendSequence@CStudioModelRenderer@@EAEXHHM_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcStairSmoothValue@CStudioModelRenderer@@AAEMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioCheckLOD@CStudioModelRenderer@@EAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioSetUpTransform@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioEstimateFrame@CStudioModelRenderer@@EAEMPAUmstudioseqdesc_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioEstimateGaitFrame@CStudioModelRenderer@@EAEMPAUmstudioseqdesc_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioEstimateInterpolant@CStudioModelRenderer@@EAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioInterpolatePoseParams@CStudioModelRenderer@@EAEXPAUcl_entity_s@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioInterpolateBlends@CStudioModelRenderer@@EAEXPAUcl_entity_s@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioGetAnim@CStudioModelRenderer@@QAEPAUmstudioanim_t@@PAUmodel_s@@PAUmstudioseqdesc_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioFxTransform@CStudioModelRenderer@@EAEXPAUcl_entity_s@@AAVmatrix3x4@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BlendSequence@CStudioModelRenderer@@EAEXQAVVector@@QAVVector4D@@PAUmstudioblendseq_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalculateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioSetBonesExternal@CStudioModelRenderer@@QAEXPBUcl_entity_s@@QBVVector@@QBVRadian@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioCalcBonesProcedural@CStudioModelRenderer@@EAEXQAVVector@@QAVVector4D@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioSetupBones@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E32
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E31
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CIKContext@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E35
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E34
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioBuildNormalTable@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioGenerateNormals@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioSetupChrome@CStudioModelRenderer@@EAEXPAMHABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioCalcAttachments@CStudioModelRenderer@@EAEXQAVmatrix3x4@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioGetAttachment@CStudioModelRenderer@@QAEXPBUcl_entity_s@@HPAVVector@@1H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioGetAttachmentNumber@CStudioModelRenderer@@QAEHPBUcl_entity_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioSequenceDuration@CStudioModelRenderer@@QAEMPBUcl_entity_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioSetupModel@CStudioModelRenderer@@EAEHHPAPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioLighting@CStudioModelRenderer@@EAEXPAMHHABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioStaticLight@CStudioModelRenderer@@EAEXPAUcl_entity_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0alight_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioClientEvents@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioSetRenderMode@CStudioModelRenderer@@EAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioDrawMeshChrome@CStudioModelRenderer@@AAEXPAFMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioDrawPoints@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioDrawShell@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioDrawHulls@CStudioModelRenderer@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioDrawAbsBBox@CStudioModelRenderer@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioDrawBones@CStudioModelRenderer@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioDrawAttachments@CStudioModelRenderer@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioSetupRenderer@CStudioModelRenderer@@EAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioRestoreRenderer@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioRenderModel@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioDrawModel@CStudioModelRenderer@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioFormatAttachment@CStudioModelRenderer@@EAEXAAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawStudioModelInternal@CStudioModelRenderer@@QAEXPAUcl_entity_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChooseStudioProgram@CStudioModelRenderer@@EAEGPAUstudiohdr_t@@PAUmstudiomat_s@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMeshToDrawList@CStudioModelRenderer@@EAEXPAUstudiohdr_t@@PBUvbomesh_s@@_N2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddBodyPartToDrawList@CStudioModelRenderer@@EAEXPAUstudiohdr_t@@PAUmbodypart_s@@H_N2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawMeshFromBuffer@CStudioModelRenderer@@AAEXPBUvbomesh_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddStudioToLightList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildMeshListForLight@CStudioModelRenderer@@EAEXPAUplight_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawLightForMeshList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderDynLightList@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawStudioMeshes@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawStudioMeshesShadow@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RunViewModelEvents@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawViewModel@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearLightCache@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UJiggleData@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEAAVCIKTarget@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEPAVCIKTarget@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUJiggleData@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AlignValue@@YAPADPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GDecalMaterial_t@CStudioModelRenderer@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEPAUikcontextikrule_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinkBefore@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlink@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocInternal@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GDecalModelList_t@CStudioModelRenderer@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GModelInstance_t@CStudioModelRenderer@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1DecalModelList_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0mstudiolight_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0BoneCache_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0StudioAttachment_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ModelInstance_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAVCIKTarget@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUikcontextikrule_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsInList@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@GH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@Uikcontextikrule_t@@H@@QAEAAUikcontextikrule_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Previous@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@GH@@QAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@GH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecalVertex_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@GH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@GH@@QAEAAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@GH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CHudBase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CStudioBoneSetup@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseBoneSetup@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CStudioModelRenderer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudSayText@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudFlashlight@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudGeiger@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudDeathNotice@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudBattery@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudTrain@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudMenu@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudTextMessage@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudAmmo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudHealth@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudStatusIcons@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudAmmoSecondary@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudStatusBar@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudMessage@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudMOTD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudScoreboard@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?g_StudioRenderer@@3VCStudioModelRenderer@@A	; g_StudioRenderer
PUBLIC	?IEngineStudio@@3Uengine_studio_api_s@@A	; IEngineStudio
_BSS	SEGMENT
?g_StudioRenderer@@3VCStudioModelRenderer@@A DB 0522ef0H DUP (?) ; g_StudioRenderer
?IEngineStudio@@3Uengine_studio_api_s@@A DB 0b8H DUP (?) ; IEngineStudio
_BSS	ENDS
CRT$XCU	SEGMENT
_$S15	DD	FLAT:_$E14
CRT$XCU	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L55256:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L55257
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L55256
$L55257:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
;	COMDAT _$E14
_TEXT	SEGMENT
_$E14	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E11
	call	_$E13
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E14	ENDP
_TEXT	ENDS
PUBLIC	??0CStudioModelRenderer@@QAE@XZ			; CStudioModelRenderer::CStudioModelRenderer
;	COMDAT _$E11
_TEXT	SEGMENT
_$E11	PROC NEAR					; COMDAT

; 36   : CStudioModelRenderer g_StudioRenderer;

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:?g_StudioRenderer@@3VCStudioModelRenderer@@A
	call	??0CStudioModelRenderer@@QAE@XZ		; CStudioModelRenderer::CStudioModelRenderer
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E11	ENDP
_TEXT	ENDS
EXTRN	_atexit:NEAR
;	COMDAT _$E13
_TEXT	SEGMENT
_$E13	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:_$E12
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E13	ENDP
_TEXT	ENDS
PUBLIC	??1CStudioModelRenderer@@UAE@XZ			; CStudioModelRenderer::~CStudioModelRenderer
;	COMDAT _$E12
_TEXT	SEGMENT
_$E12	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:?g_StudioRenderer@@3VCStudioModelRenderer@@A
	call	??1CStudioModelRenderer@@UAE@XZ		; CStudioModelRenderer::~CStudioModelRenderer
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E12	ENDP
_TEXT	ENDS
PUBLIC	?Init@CStudioModelRenderer@@QAEXXZ		; CStudioModelRenderer::Init
PUBLIC	?HUD_GetStudioModelInterface@@YAHHPAPAUr_studio_interface_s@@PAUengine_studio_api_s@@@Z ; HUD_GetStudioModelInterface
EXTRN	?g_fRenderInitialized@@3HA:DWORD		; g_fRenderInitialized
EXTRN	?Init@CSpriteModelRenderer@@UAEXXZ:NEAR		; CSpriteModelRenderer::Init
EXTRN	?g_SpriteRenderer@@3VCSpriteModelRenderer@@A:BYTE ; g_SpriteRenderer
EXTRN	_memcpy:NEAR
;	COMDAT ?HUD_GetStudioModelInterface@@YAHHPAPAUr_studio_interface_s@@PAUengine_studio_api_s@@@Z
_TEXT	SEGMENT
_version$ = 8
_pstudio$ = 16
?HUD_GetStudioModelInterface@@YAHHPAPAUr_studio_interface_s@@PAUengine_studio_api_s@@@Z PROC NEAR ; HUD_GetStudioModelInterface, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 44   : 	if( version != STUDIO_INTERFACE_VERSION )

	cmp	DWORD PTR _version$[ebp], 1
	je	SHORT $L71915

; 45   : 		return 0;

	xor	eax, eax
	jmp	SHORT $L71914
$L71915:

; 46   : 
; 47   : 	// Copy in engine helper functions
; 48   : 	memcpy( &IEngineStudio, pstudio, sizeof( IEngineStudio ));

	push	184					; 000000b8H
	mov	eax, DWORD PTR _pstudio$[ebp]
	push	eax
	push	OFFSET FLAT:?IEngineStudio@@3Uengine_studio_api_s@@A ; IEngineStudio
	call	_memcpy
	add	esp, 12					; 0000000cH

; 49   : 
; 50   : 	if( g_fRenderInitialized )

	cmp	DWORD PTR ?g_fRenderInitialized@@3HA, 0	; g_fRenderInitialized
	je	SHORT $L71916

; 52   : 		// Initialize local variables, etc.
; 53   : 		g_StudioRenderer.Init();

	mov	ecx, OFFSET FLAT:?g_StudioRenderer@@3VCStudioModelRenderer@@A
	call	?Init@CStudioModelRenderer@@QAEXXZ	; CStudioModelRenderer::Init

; 54   : 
; 55   : 		g_SpriteRenderer.Init();

	mov	ecx, OFFSET FLAT:?g_SpriteRenderer@@3VCSpriteModelRenderer@@A
	call	?Init@CSpriteModelRenderer@@UAEXXZ	; CSpriteModelRenderer::Init
$L71916:

; 57   : 
; 58   : 	// Success
; 59   : 	return 1;

	mov	eax, 1
$L71914:

; 60   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HUD_GetStudioModelInterface@@YAHHPAPAUr_studio_interface_s@@PAUengine_studio_api_s@@@Z ENDP ; HUD_GetStudioModelInterface
_TEXT	ENDS
PUBLIC	?debugMsg@CBaseBoneSetup@@UAAXPADZZ		; CBaseBoneSetup::debugMsg
EXTRN	?developer_level@@3HA:DWORD			; developer_level
EXTRN	?gEngfuncs@@3Ucl_enginefuncs_s@@A:BYTE		; gEngfuncs
EXTRN	?Q_vsnprintf@@YAHPADIPBD0@Z:NEAR		; Q_vsnprintf
;	COMDAT ?debugMsg@CBaseBoneSetup@@UAAXPADZZ
_TEXT	SEGMENT
_szFmt$ = 12
_buffer$ = -2048
_args$ = -2052
?debugMsg@CBaseBoneSetup@@UAAXPADZZ PROC NEAR		; CBaseBoneSetup::debugMsg, COMDAT

; 68   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2116				; 00000844H
	push	ebx
	push	esi
	push	edi

; 69   : 	char	buffer[2048];	// must support > 1k messages
; 70   : 	va_list	args;
; 71   : 
; 72   : 	if( developer_level <= DEV_NONE )

	cmp	DWORD PTR ?developer_level@@3HA, 0	; developer_level
	jg	SHORT $L71924

; 73   : 		return;

	jmp	SHORT $L71921
$L71924:

; 74   : 
; 75   : 	va_start( args, szFmt );

	lea	eax, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 76   : 	Q_vsnprintf( buffer, 2048, szFmt, args );

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFmt$[ebp]
	push	edx
	push	2048					; 00000800H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	?Q_vsnprintf@@YAHPADIPBD0@Z		; Q_vsnprintf
	add	esp, 16					; 00000010H

; 77   : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 78   : 
; 79   : 	gEngfuncs.Con_Printf( buffer );

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+160
	add	esp, 4
$L71921:

; 80   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?debugMsg@CBaseBoneSetup@@UAAXPADZZ ENDP		; CBaseBoneSetup::debugMsg
_TEXT	ENDS
PUBLIC	?GetAnimSourceData@CBaseBoneSetup@@UAEPAUmstudioanim_t@@PAUmstudioseqdesc_t@@@Z ; CBaseBoneSetup::GetAnimSourceData
PUBLIC	?StudioGetAnim@CStudioModelRenderer@@QAEPAUmstudioanim_t@@PAUmodel_s@@PAUmstudioseqdesc_t@@@Z ; CStudioModelRenderer::StudioGetAnim
EXTRN	?RI@@3PAUref_instance_t@@A:DWORD		; RI
;	COMDAT ?GetAnimSourceData@CBaseBoneSetup@@UAEPAUmstudioanim_t@@PAUmstudioseqdesc_t@@@Z
_TEXT	SEGMENT
_pseqdesc$ = 8
_this$ = -4
?GetAnimSourceData@CBaseBoneSetup@@UAEPAUmstudioanim_t@@PAUmstudioseqdesc_t@@@Z PROC NEAR ; CBaseBoneSetup::GetAnimSourceData, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 	return g_StudioRenderer.StudioGetAnim( RI->currentmodel, pseqdesc );

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	ecx, OFFSET FLAT:?g_StudioRenderer@@3VCStudioModelRenderer@@A
	call	?StudioGetAnim@CStudioModelRenderer@@QAEPAUmstudioanim_t@@PAUmodel_s@@PAUmstudioseqdesc_t@@@Z ; CStudioModelRenderer::StudioGetAnim

; 85   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAnimSourceData@CBaseBoneSetup@@UAEPAUmstudioanim_t@@PAUmstudioseqdesc_t@@@Z ENDP ; CBaseBoneSetup::GetAnimSourceData
_TEXT	ENDS
PUBLIC	?debugLine@CBaseBoneSetup@@UAEXABVVector@@0HHH_NM@Z ; CBaseBoneSetup::debugLine
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
EXTRN	?pglBegin@@3P6GXI@ZA:DWORD			; pglBegin
EXTRN	?pglVertex3fv@@3P6GXPBM@ZA:DWORD		; pglVertex3fv
EXTRN	?pglColor3ub@@3P6GXEEE@ZA:DWORD			; pglColor3ub
EXTRN	?pglDisable@@3P6GXI@ZA:DWORD			; pglDisable
EXTRN	?pglEnd@@3P6GXXZA:DWORD				; pglEnd
;	COMDAT ?debugLine@CBaseBoneSetup@@UAEXABVVector@@0HHH_NM@Z
_TEXT	SEGMENT
_origin$ = 8
_dest$ = 12
_r$ = 16
_g$ = 20
_b$ = 24
_noDepthTest$ = 28
_this$ = -4
?debugLine@CBaseBoneSetup@@UAEXABVVector@@0HHH_NM@Z PROC NEAR ; CBaseBoneSetup::debugLine, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 89   : 	if( noDepthTest )

	mov	eax, DWORD PTR _noDepthTest$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L71943

; 90   : 		pglDisable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR ?pglDisable@@3P6GXI@ZA	; pglDisable
$L71943:

; 91   : 
; 92   : 	pglColor3ub( r, g, b );

	mov	cl, BYTE PTR _b$[ebp]
	push	ecx
	mov	dl, BYTE PTR _g$[ebp]
	push	edx
	mov	al, BYTE PTR _r$[ebp]
	push	eax
	call	DWORD PTR ?pglColor3ub@@3P6GXEEE@ZA	; pglColor3ub

; 93   : 
; 94   : 	pglBegin( GL_LINES );

	push	1
	call	DWORD PTR ?pglBegin@@3P6GXI@ZA		; pglBegin

; 95   : 		pglVertex3fv( origin );

	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 96   : 		pglVertex3fv( dest );

	mov	ecx, DWORD PTR _dest$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 97   : 	pglEnd();

	call	DWORD PTR ?pglEnd@@3P6GXXZA		; pglEnd

; 98   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?debugLine@CBaseBoneSetup@@UAEXABVVector@@0HHH_NM@Z ENDP ; CBaseBoneSetup::debugLine
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QBEPBMXZ PROC NEAR				; Vector::operator float const *, COMDAT

; 229  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
PUBLIC	??_C@_0M@FENB@cl_himodels?$AA@			; `string'
PUBLIC	??_C@_0BA@NMBJ@r_drawviewmodel?$AA@		; `string'
PUBLIC	??_C@_0BA@IMCO@r_glowshellfreq?$AA@		; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_0N@DNEG@cl_righthand?$AA@			; `string'
PUBLIC	??_C@_02OHJF@90?$AA@				; `string'
PUBLIC	??_C@_0BB@LDK@cl_viewmodel_fov?$AA@		; `string'
PUBLIC	??_C@_01FBAH@1?$AA@				; `string'
PUBLIC	??_C@_0BE@GFEF@r_studio_compatible?$AA@		; `string'
PUBLIC	??_C@_03JFJK@5?40?$AA@				; `string'
PUBLIC	??_C@_0N@OBFE@cl_lod_scale?$AA@			; `string'
PUBLIC	??_C@_0M@FDBP@cl_lod_bias?$AA@			; `string'
;	COMDAT ??_C@_0M@FENB@cl_himodels?$AA@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_C@_0M@FENB@cl_himodels?$AA@ DB 'cl_himodels', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NMBJ@r_drawviewmodel?$AA@
CONST	SEGMENT
??_C@_0BA@NMBJ@r_drawviewmodel?$AA@ DB 'r_drawviewmodel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IMCO@r_glowshellfreq?$AA@
CONST	SEGMENT
??_C@_0BA@IMCO@r_glowshellfreq?$AA@ DB 'r_glowshellfreq', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DNEG@cl_righthand?$AA@
CONST	SEGMENT
??_C@_0N@DNEG@cl_righthand?$AA@ DB 'cl_righthand', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02OHJF@90?$AA@
CONST	SEGMENT
??_C@_02OHJF@90?$AA@ DB '90', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LDK@cl_viewmodel_fov?$AA@
CONST	SEGMENT
??_C@_0BB@LDK@cl_viewmodel_fov?$AA@ DB 'cl_viewmodel_fov', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01FBAH@1?$AA@
CONST	SEGMENT
??_C@_01FBAH@1?$AA@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GFEF@r_studio_compatible?$AA@
CONST	SEGMENT
??_C@_0BE@GFEF@r_studio_compatible?$AA@ DB 'r_studio_compatible', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JFJK@5?40?$AA@
CONST	SEGMENT
??_C@_03JFJK@5?40?$AA@ DB '5.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OBFE@cl_lod_scale?$AA@
CONST	SEGMENT
??_C@_0N@OBFE@cl_lod_scale?$AA@ DB 'cl_lod_scale', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FDBP@cl_lod_bias?$AA@
CONST	SEGMENT
??_C@_0M@FDBP@cl_lod_bias?$AA@ DB 'cl_lod_bias', 00H	; `string'
CONST	ENDS
;	COMDAT ?Init@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Init@CStudioModelRenderer@@QAEXXZ PROC NEAR		; CStudioModelRenderer::Init, COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 	// Set up some variables shared with engine
; 109  : 	m_pCvarHiModels		= IEngineStudio.GetCvar( "cl_himodels" );

	push	OFFSET FLAT:??_C@_0M@FENB@cl_himodels?$AA@ ; `string'
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+44
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], eax

; 110  : 	m_pCvarDrawViewModel	= IEngineStudio.GetCvar( "r_drawviewmodel" );

	push	OFFSET FLAT:??_C@_0BA@NMBJ@r_drawviewmodel?$AA@ ; `string'
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+44
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], eax

; 111  : 	m_pCvarGlowShellFreq	= IEngineStudio.GetCvar( "r_glowshellfreq" );

	push	OFFSET FLAT:??_C@_0BA@IMCO@r_glowshellfreq?$AA@ ; `string'
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+44
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+116], eax

; 112  : 	m_pCvarHand		= CVAR_REGISTER( "cl_righthand", "0", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@DNEG@cl_righthand?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+108], eax

; 113  : 	m_pCvarViewmodelFov		= CVAR_REGISTER( "cl_viewmodel_fov", "90", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_02OHJF@90?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BB@LDK@cl_viewmodel_fov?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], eax

; 114  : 	m_pCvarCompatible		= CVAR_REGISTER( "r_studio_compatible", "1", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BE@GFEF@r_studio_compatible?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], eax

; 115  : 	m_pCvarLodScale		= CVAR_REGISTER( "cl_lod_scale", "5.0", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_03JFJK@5?40?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@OBFE@cl_lod_scale?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], eax

; 116  : 	m_pCvarLodBias		= CVAR_REGISTER( "cl_lod_bias", "0", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0M@FDBP@cl_lod_bias?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+128], eax

; 117  : 
; 118  : 	m_pChromeSprite		= IEngineStudio.GetChromeSprite();

	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+52
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19144], eax

; 119  : 	m_chromeCount		= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+219352], 0

; 120  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Init@CStudioModelRenderer@@QAEXXZ ENDP			; CStudioModelRenderer::Init
_TEXT	ENDS
PUBLIC	?VidInit@CStudioModelRenderer@@QAEXXZ		; CStudioModelRenderer::VidInit
;	COMDAT ?VidInit@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?VidInit@CStudioModelRenderer@@QAEXXZ PROC NEAR		; CStudioModelRenderer::VidInit, COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 130  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VidInit@CStudioModelRenderer@@QAEXXZ ENDP		; CStudioModelRenderer::VidInit
_TEXT	ENDS
PUBLIC	?IsModelInstanceValid@CStudioModelRenderer@@EAE_NPAUModelInstance_t@1@@Z ; CStudioModelRenderer::IsModelInstanceValid
PUBLIC	?DestroyInstance@CStudioModelRenderer@@EAEXG@Z	; CStudioModelRenderer::DestroyInstance
PUBLIC	?DrawStudioMeshes@CStudioModelRenderer@@EAEXXZ	; CStudioModelRenderer::DrawStudioMeshes
PUBLIC	?DrawStudioMeshesShadow@CStudioModelRenderer@@EAEXXZ ; CStudioModelRenderer::DrawStudioMeshesShadow
PUBLIC	?StudioDrawShell@CStudioModelRenderer@@EAEXXZ	; CStudioModelRenderer::StudioDrawShell
PUBLIC	?StudioCheckLOD@CStudioModelRenderer@@EAEHXZ	; CStudioModelRenderer::StudioCheckLOD
PUBLIC	?StudioBuildNormalTable@CStudioModelRenderer@@EAEXXZ ; CStudioModelRenderer::StudioBuildNormalTable
PUBLIC	?StudioGenerateNormals@CStudioModelRenderer@@EAEXXZ ; CStudioModelRenderer::StudioGenerateNormals
PUBLIC	?CheckBoneCache@CStudioModelRenderer@@EAE_NM@Z	; CStudioModelRenderer::CheckBoneCache
PUBLIC	?RenderDynLightList@CStudioModelRenderer@@EAEXXZ ; CStudioModelRenderer::RenderDynLightList
PUBLIC	?AddStudioToLightList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z ; CStudioModelRenderer::AddStudioToLightList
PUBLIC	?BuildMeshListForLight@CStudioModelRenderer@@EAEXPAUplight_s@@@Z ; CStudioModelRenderer::BuildMeshListForLight
PUBLIC	?DrawLightForMeshList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z ; CStudioModelRenderer::DrawLightForMeshList
PUBLIC	?CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z ; CStudioModelRenderer::CreateMeshCache
PUBLIC	?ReleaseVBOCache@CStudioModelRenderer@@EAEXPAPAUmvbocache_s@@@Z ; CStudioModelRenderer::ReleaseVBOCache
PUBLIC	??0CBaseBoneSetup@@QAE@XZ			; CBaseBoneSetup::CBaseBoneSetup
PUBLIC	?DestroyMeshCache@CStudioModelRenderer@@EAEXXZ	; CStudioModelRenderer::DestroyMeshCache
PUBLIC	?CreateMeshCacheVL@CStudioModelRenderer@@EAEXPAUdmodellight_t@@H@Z ; CStudioModelRenderer::CreateMeshCacheVL
PUBLIC	?LoadStudioMaterials@CStudioModelRenderer@@EAEXXZ ; CStudioModelRenderer::LoadStudioMaterials
PUBLIC	?FreeStudioMaterials@CStudioModelRenderer@@EAEXXZ ; CStudioModelRenderer::FreeStudioMaterials
PUBLIC	?UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ ; CStudioModelRenderer::UpdateInstanceMaterials
PUBLIC	?ClearInstanceData@CStudioModelRenderer@@EAEX_N@Z ; CStudioModelRenderer::ClearInstanceData
PUBLIC	?StudioDrawModel@CStudioModelRenderer@@UAEHH@Z	; CStudioModelRenderer::StudioDrawModel
PUBLIC	?StudioExtractBbox@CStudioModelRenderer@@EAEHPAUcl_entity_s@@PAUstudiohdr_t@@HAAVVector@@2@Z ; CStudioModelRenderer::StudioExtractBbox
PUBLIC	?StudioComputeBBox@CStudioModelRenderer@@EAEHPAUcl_entity_s@@@Z ; CStudioModelRenderer::StudioComputeBBox
PUBLIC	?StudioSetUpTransform@CStudioModelRenderer@@EAEXXZ ; CStudioModelRenderer::StudioSetUpTransform
PUBLIC	?StudioSetupBones@CStudioModelRenderer@@EAEXXZ	; CStudioModelRenderer::StudioSetupBones
PUBLIC	?StudioCalcBonesProcedural@CStudioModelRenderer@@EAEXQAVVector@@QAVVector4D@@@Z ; CStudioModelRenderer::StudioCalcBonesProcedural
PUBLIC	?StudioCalcAttachments@CStudioModelRenderer@@EAEXQAVmatrix3x4@@H@Z ; CStudioModelRenderer::StudioCalcAttachments
PUBLIC	?AddBlendSequence@CStudioModelRenderer@@EAEXHHM_N@Z ; CStudioModelRenderer::AddBlendSequence
PUBLIC	?BlendSequence@CStudioModelRenderer@@EAEXQAVVector@@QAVVector4D@@PAUmstudioblendseq_t@@@Z ; CStudioModelRenderer::BlendSequence
PUBLIC	?UpdateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z ; CStudioModelRenderer::UpdateIKLocks
PUBLIC	?CalculateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z ; CStudioModelRenderer::CalculateIKLocks
PUBLIC	?StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z ; CStudioModelRenderer::StudioMergeBones
PUBLIC	?StudioEstimateInterpolant@CStudioModelRenderer@@EAEMXZ ; CStudioModelRenderer::StudioEstimateInterpolant
PUBLIC	?StudioEstimateGaitFrame@CStudioModelRenderer@@EAEMPAUmstudioseqdesc_t@@@Z ; CStudioModelRenderer::StudioEstimateGaitFrame
PUBLIC	?StudioEstimateFrame@CStudioModelRenderer@@EAEMPAUmstudioseqdesc_t@@@Z ; CStudioModelRenderer::StudioEstimateFrame
PUBLIC	?StudioInterpolateBlends@CStudioModelRenderer@@EAEXPAUcl_entity_s@@M@Z ; CStudioModelRenderer::StudioInterpolateBlends
PUBLIC	?StudioInterpolatePoseParams@CStudioModelRenderer@@EAEXPAUcl_entity_s@@M@Z ; CStudioModelRenderer::StudioInterpolatePoseParams
PUBLIC	?StudioFxTransform@CStudioModelRenderer@@EAEXPAUcl_entity_s@@AAVmatrix3x4@@@Z ; CStudioModelRenderer::StudioFxTransform
PUBLIC	?ComputeSkinMatrix@CStudioModelRenderer@@EAEXPAUmstudioboneweight_t@@QBVmatrix3x4@@AAV3@@Z ; CStudioModelRenderer::ComputeSkinMatrix
PUBLIC	?StudioSetupChrome@CStudioModelRenderer@@EAEXPAMHABVVector@@@Z ; CStudioModelRenderer::StudioSetupChrome
PUBLIC	?StudioRenderModel@CStudioModelRenderer@@EAEXXZ	; CStudioModelRenderer::StudioRenderModel
PUBLIC	?StudioSetupModel@CStudioModelRenderer@@EAEHHPAPAX0@Z ; CStudioModelRenderer::StudioSetupModel
PUBLIC	?StudioSetRenderMode@CStudioModelRenderer@@EAEXH@Z ; CStudioModelRenderer::StudioSetRenderMode
PUBLIC	?StudioPlayerBlend@CStudioModelRenderer@@EAEXPAUmstudioseqdesc_t@@AAHAAM@Z ; CStudioModelRenderer::StudioPlayerBlend
PUBLIC	?StudioClientEvents@CStudioModelRenderer@@EAEXXZ ; CStudioModelRenderer::StudioClientEvents
PUBLIC	?StudioLighting@CStudioModelRenderer@@EAEXPAMHHABVVector@@@Z ; CStudioModelRenderer::StudioLighting
PUBLIC	?StudioDrawPoints@CStudioModelRenderer@@EAEXXZ	; CStudioModelRenderer::StudioDrawPoints
PUBLIC	?StudioStaticLight@CStudioModelRenderer@@EAEXPAUcl_entity_s@@@Z ; CStudioModelRenderer::StudioStaticLight
PUBLIC	?StudioFormatAttachment@CStudioModelRenderer@@EAEXAAVVector@@@Z ; CStudioModelRenderer::StudioFormatAttachment
PUBLIC	?ChooseStudioProgram@CStudioModelRenderer@@EAEGPAUstudiohdr_t@@PAUmstudiomat_s@@_N@Z ; CStudioModelRenderer::ChooseStudioProgram
PUBLIC	?AddMeshToDrawList@CStudioModelRenderer@@EAEXPAUstudiohdr_t@@PBUvbomesh_s@@_N2@Z ; CStudioModelRenderer::AddMeshToDrawList
PUBLIC	?AddBodyPartToDrawList@CStudioModelRenderer@@EAEXPAUstudiohdr_t@@PAUmbodypart_s@@H_N2@Z ; CStudioModelRenderer::AddBodyPartToDrawList
PUBLIC	??_7CStudioModelRenderer@@6B@			; CStudioModelRenderer::`vftable'
PUBLIC	??_GCStudioModelRenderer@@UAEPAXI@Z		; CStudioModelRenderer::`scalar deleting destructor'
PUBLIC	??_ECStudioModelRenderer@@UAEPAXI@Z		; CStudioModelRenderer::`vector deleting destructor'
PUBLIC	?StudioSetupRenderer@CStudioModelRenderer@@EAEXH@Z ; CStudioModelRenderer::StudioSetupRenderer
PUBLIC	?StudioRestoreRenderer@CStudioModelRenderer@@EAEXXZ ; CStudioModelRenderer::StudioRestoreRenderer
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>
PUBLIC	??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>
PUBLIC	??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>
PUBLIC	??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>
PUBLIC	??0Vector4D@@QAE@XZ				; Vector4D::Vector4D
PUBLIC	??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>
PUBLIC	??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>
PUBLIC	??0DecalVertex_t@@QAE@XZ			; DecalVertex_t::DecalVertex_t
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??0matrix3x4@@QAE@XZ:NEAR			; matrix3x4::matrix3x4
;	COMDAT ??_7CStudioModelRenderer@@6B@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_7CStudioModelRenderer@@6B@ DD FLAT:??_ECStudioModelRenderer@@UAEPAXI@Z ; CStudioModelRenderer::`vftable'
	DD	FLAT:?StudioDrawModel@CStudioModelRenderer@@UAEHH@Z
	DD	FLAT:?CreateMeshCacheVL@CStudioModelRenderer@@EAEXPAUdmodellight_t@@H@Z
	DD	FLAT:?StudioExtractBbox@CStudioModelRenderer@@EAEHPAUcl_entity_s@@PAUstudiohdr_t@@HAAVVector@@2@Z
	DD	FLAT:?StudioComputeBBox@CStudioModelRenderer@@EAEHPAUcl_entity_s@@@Z
	DD	FLAT:?StudioSetUpTransform@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?StudioSetupBones@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?StudioCalcBonesProcedural@CStudioModelRenderer@@EAEXQAVVector@@QAVVector4D@@@Z
	DD	FLAT:?StudioCalcAttachments@CStudioModelRenderer@@EAEXQAVmatrix3x4@@H@Z
	DD	FLAT:?AddBlendSequence@CStudioModelRenderer@@EAEXHHM_N@Z
	DD	FLAT:?BlendSequence@CStudioModelRenderer@@EAEXQAVVector@@QAVVector4D@@PAUmstudioblendseq_t@@@Z
	DD	FLAT:?UpdateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z
	DD	FLAT:?CalculateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z
	DD	FLAT:?StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z
	DD	FLAT:?StudioEstimateInterpolant@CStudioModelRenderer@@EAEMXZ
	DD	FLAT:?StudioEstimateGaitFrame@CStudioModelRenderer@@EAEMPAUmstudioseqdesc_t@@@Z
	DD	FLAT:?StudioEstimateFrame@CStudioModelRenderer@@EAEMPAUmstudioseqdesc_t@@@Z
	DD	FLAT:?StudioInterpolateBlends@CStudioModelRenderer@@EAEXPAUcl_entity_s@@M@Z
	DD	FLAT:?StudioInterpolatePoseParams@CStudioModelRenderer@@EAEXPAUcl_entity_s@@M@Z
	DD	FLAT:?StudioFxTransform@CStudioModelRenderer@@EAEXPAUcl_entity_s@@AAVmatrix3x4@@@Z
	DD	FLAT:?ComputeSkinMatrix@CStudioModelRenderer@@EAEXPAUmstudioboneweight_t@@QBVmatrix3x4@@AAV3@@Z
	DD	FLAT:?StudioSetupChrome@CStudioModelRenderer@@EAEXPAMHABVVector@@@Z
	DD	FLAT:?StudioRenderModel@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?StudioSetupModel@CStudioModelRenderer@@EAEHHPAPAX0@Z
	DD	FLAT:?StudioSetRenderMode@CStudioModelRenderer@@EAEXH@Z
	DD	FLAT:?StudioPlayerBlend@CStudioModelRenderer@@EAEXPAUmstudioseqdesc_t@@AAHAAM@Z
	DD	FLAT:?StudioClientEvents@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?StudioLighting@CStudioModelRenderer@@EAEXPAMHHABVVector@@@Z
	DD	FLAT:?StudioDrawPoints@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?StudioStaticLight@CStudioModelRenderer@@EAEXPAUcl_entity_s@@@Z
	DD	FLAT:?StudioFormatAttachment@CStudioModelRenderer@@EAEXAAVVector@@@Z
	DD	FLAT:?ChooseStudioProgram@CStudioModelRenderer@@EAEGPAUstudiohdr_t@@PAUmstudiomat_s@@_N@Z
	DD	FLAT:?AddMeshToDrawList@CStudioModelRenderer@@EAEXPAUstudiohdr_t@@PBUvbomesh_s@@_N2@Z
	DD	FLAT:?AddBodyPartToDrawList@CStudioModelRenderer@@EAEXPAUstudiohdr_t@@PAUmbodypart_s@@H_N2@Z
	DD	FLAT:?StudioSetupRenderer@CStudioModelRenderer@@EAEXH@Z
	DD	FLAT:?StudioRestoreRenderer@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?IsModelInstanceValid@CStudioModelRenderer@@EAE_NPAUModelInstance_t@1@@Z
	DD	FLAT:?DestroyInstance@CStudioModelRenderer@@EAEXG@Z
	DD	FLAT:?DrawStudioMeshes@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?DrawStudioMeshesShadow@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?StudioDrawShell@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?StudioCheckLOD@CStudioModelRenderer@@EAEHXZ
	DD	FLAT:?StudioBuildNormalTable@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?StudioGenerateNormals@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?CheckBoneCache@CStudioModelRenderer@@EAE_NM@Z
	DD	FLAT:?RenderDynLightList@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?AddStudioToLightList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z
	DD	FLAT:?BuildMeshListForLight@CStudioModelRenderer@@EAEXPAUplight_s@@@Z
	DD	FLAT:?DrawLightForMeshList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z
	DD	FLAT:?CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z
	DD	FLAT:?ReleaseVBOCache@CStudioModelRenderer@@EAEXPAPAUmvbocache_s@@@Z
	DD	FLAT:?DestroyMeshCache@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?LoadStudioMaterials@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?FreeStudioMaterials@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ
	DD	FLAT:?ClearInstanceData@CStudioModelRenderer@@EAEX_N@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CStudioModelRenderer@@QAE@XZ DD 019930520H
	DD	03H
	DD	FLAT:__unwindtable$??0CStudioModelRenderer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CStudioModelRenderer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CStudioModelRenderer@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CStudioModelRenderer@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CStudioModelRenderer@@QAE@XZ$2
xdata$x	ENDS
;	COMDAT ??0CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0CStudioModelRenderer@@QAE@XZ PROC NEAR		; CStudioModelRenderer::CStudioModelRenderer, COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CStudioModelRenderer@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	??0CBaseBoneSetup@@QAE@XZ		; CBaseBoneSetup::CBaseBoneSetup
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 19148				; 00004accH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	128					; 00000080H
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 150744				; 00024cd8H
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	128					; 00000080H
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152280				; 000252d8H
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0matrix3x4@@QAE@XZ	; matrix3x4::matrix3x4
	push	128					; 00000080H
	push	48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 219356				; 000358dcH
	push	edx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0DecalVertex_t@@QAE@XZ	; DecalVertex_t::DecalVertex_t
	push	16384					; 00004000H
	push	64					; 00000040H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 225500				; 000370dcH
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0matrix3x4@@QAE@XZ	; matrix3x4::matrix3x4
	push	128					; 00000080H
	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1274076				; 001370dcH
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	128					; 00000080H
	push	12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1280220				; 001388dcH
	push	edx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	16384					; 00004000H
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1281756				; 00138edcH
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	16384					; 00004000H
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1478364				; 00168edcH
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	65536					; 00010000H
	push	12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1674972				; 00198edcH
	push	edx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	65536					; 00010000H
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2461404				; 00258edcH
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7CStudioModelRenderer@@6B@ ; CStudioModelRenderer::`vftable'

; 140  : 	m_fDoInterp	= true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], 1

; 141  : 	m_pCurrentEntity	= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+19104], 0

; 142  : 	m_pCvarHiModels	= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], 0

; 143  : 	m_pCvarDrawViewModel= NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], 0

; 144  : 	m_pCvarHand	= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], 0

; 145  : 	m_pChromeSprite	= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19144], 0

; 146  : 	m_pStudioHeader	= NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+19124], 0

; 147  : 	m_pBodyPart	= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+19128], 0

; 148  : 	m_pSubModel	= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19132], 0

; 149  : 	m_pPlayerInfo	= NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+19116], 0

; 150  : 	m_pRenderModel	= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+19108], 0

; 151  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CStudioModelRenderer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>
	ret	0
__unwindfunclet$??0CStudioModelRenderer@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>
	ret	0
__unwindfunclet$??0CStudioModelRenderer@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>
	ret	0
__ehhandler$??0CStudioModelRenderer@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CStudioModelRenderer@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CStudioModelRenderer@@QAE@XZ ENDP			; CStudioModelRenderer::CStudioModelRenderer
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector4D@@QAE@XZ PROC NEAR				; Vector4D::Vector4D, COMDAT

; 311  : 	inline Vector4D( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector4D@@QAE@XZ ENDP				; Vector4D::Vector4D
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ??_GCStudioModelRenderer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCStudioModelRenderer@@UAEPAXI@Z PROC NEAR		; CStudioModelRenderer::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CStudioModelRenderer@@UAE@XZ		; CStudioModelRenderer::~CStudioModelRenderer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L71981
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L71981:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCStudioModelRenderer@@UAEPAXI@Z ENDP		; CStudioModelRenderer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7CBaseBoneSetup@@6B@				; CBaseBoneSetup::`vftable'
PUBLIC	??0CStudioBoneSetup@@QAE@XZ			; CStudioBoneSetup::CStudioBoneSetup
;	COMDAT ??_7CBaseBoneSetup@@6B@
CONST	SEGMENT
??_7CBaseBoneSetup@@6B@ DD FLAT:?debugMsg@CBaseBoneSetup@@UAAXPADZZ ; CBaseBoneSetup::`vftable'
	DD	FLAT:?GetAnimSourceData@CBaseBoneSetup@@UAEPAUmstudioanim_t@@PAUmstudioseqdesc_t@@@Z
	DD	FLAT:?debugLine@CBaseBoneSetup@@UAEXABVVector@@0HHH_NM@Z
CONST	ENDS
;	COMDAT ??0CBaseBoneSetup@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseBoneSetup@@QAE@XZ PROC NEAR			; CBaseBoneSetup::CBaseBoneSetup, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CStudioBoneSetup@@QAE@XZ		; CStudioBoneSetup::CStudioBoneSetup
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseBoneSetup@@6B@ ; CBaseBoneSetup::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseBoneSetup@@QAE@XZ ENDP				; CBaseBoneSetup::CBaseBoneSetup
_TEXT	ENDS
PUBLIC	?InitBoneWeights@CStudioBoneSetup@@AAEXXZ	; CStudioBoneSetup::InitBoneWeights
PUBLIC	?debugMsg@CStudioBoneSetup@@UAAXPADZZ		; CStudioBoneSetup::debugMsg
PUBLIC	?debugLine@CStudioBoneSetup@@UAEXABVVector@@0HHH_NM@Z ; CStudioBoneSetup::debugLine
PUBLIC	??_7CStudioBoneSetup@@6B@			; CStudioBoneSetup::`vftable'
EXTRN	?GetAnimSourceData@CStudioBoneSetup@@UAEPAUmstudioanim_t@@PAUmstudioseqdesc_t@@@Z:NEAR ; CStudioBoneSetup::GetAnimSourceData
;	COMDAT ??_7CStudioBoneSetup@@6B@
; File z:\xashxtsrc\game_shared\bs_defs.h
CONST	SEGMENT
??_7CStudioBoneSetup@@6B@ DD FLAT:?debugMsg@CStudioBoneSetup@@UAAXPADZZ ; CStudioBoneSetup::`vftable'
	DD	FLAT:?GetAnimSourceData@CStudioBoneSetup@@UAEPAUmstudioanim_t@@PAUmstudioseqdesc_t@@@Z
	DD	FLAT:?debugLine@CStudioBoneSetup@@UAEXABVVector@@0HHH_NM@Z
CONST	ENDS
;	COMDAT ??0CStudioBoneSetup@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CStudioBoneSetup@@QAE@XZ PROC NEAR			; CStudioBoneSetup::CStudioBoneSetup, COMDAT

; 33   : 	CStudioBoneSetup()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0matrix3x4@@QAE@XZ	; matrix3x4::matrix3x4
	push	128					; 00000080H
	push	48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 536				; 00000218H
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0matrix3x4@@QAE@XZ	; matrix3x4::matrix3x4
	push	128					; 00000080H
	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6680				; 00001a18H
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0matrix3x4@@QAE@XZ	; matrix3x4::matrix3x4
	push	128					; 00000080H
	push	48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12824				; 00003218H
	push	edx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CStudioBoneSetup@@6B@ ; CStudioBoneSetup::`vftable'

; 34   : 	{
; 35   : 		InitBoneWeights();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitBoneWeights@CStudioBoneSetup@@AAEXXZ ; CStudioBoneSetup::InitBoneWeights

; 36   : 		m_pStudioHeader = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+18968], 0

; 37   : 		m_flBoneControllers = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+520], 0

; 38   : 		m_flPoseParams = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+524], 0

; 39   : 		m_iBoneMask = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+528], 0

; 40   : 	} 

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CStudioBoneSetup@@QAE@XZ ENDP			; CStudioBoneSetup::CStudioBoneSetup
_TEXT	ENDS
EXTRN	__fltused:NEAR
;	COMDAT ?InitBoneWeights@CStudioBoneSetup@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?InitBoneWeights@CStudioBoneSetup@@AAEXXZ PROC NEAR	; CStudioBoneSetup::InitBoneWeights, COMDAT

; 290  : 	void InitBoneWeights( void ) { for( int i = 0; i < MAXSTUDIOBONES; i++ ) m_flDefaultBoneWeight[i] = 1.0f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L66517
$L66518:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L66517:
	cmp	DWORD PTR _i$[ebp], 128			; 00000080H
	jge	SHORT $L66519
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], 1065353216	; 3f800000H
	jmp	SHORT $L66518
$L66519:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitBoneWeights@CStudioBoneSetup@@AAEXXZ ENDP		; CStudioBoneSetup::InitBoneWeights
_TEXT	ENDS
;	COMDAT ?debugMsg@CStudioBoneSetup@@UAAXPADZZ
_TEXT	SEGMENT
?debugMsg@CStudioBoneSetup@@UAAXPADZZ PROC NEAR		; CStudioBoneSetup::debugMsg, COMDAT

; 337  : 	virtual void debugMsg( char *szFmt, ... ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?debugMsg@CStudioBoneSetup@@UAAXPADZZ ENDP		; CStudioBoneSetup::debugMsg
_TEXT	ENDS
;	COMDAT ?debugLine@CStudioBoneSetup@@UAEXABVVector@@0HHH_NM@Z
_TEXT	SEGMENT
_this$ = -4
?debugLine@CStudioBoneSetup@@UAEXABVVector@@0HHH_NM@Z PROC NEAR ; CStudioBoneSetup::debugLine, COMDAT

; 339  : 	virtual void debugLine( const Vector& origin, const Vector& dest, int r, int g, int b, bool noDepthTest = false, float duration = 0.0f ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?debugLine@CStudioBoneSetup@@UAEXABVVector@@0HHH_NM@Z ENDP ; CStudioBoneSetup::debugLine
_TEXT	ENDS
PUBLIC	??0Vector2D@@QAE@XZ				; Vector2D::Vector2D
;	COMDAT ??0DecalVertex_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0DecalVertex_t@@QAE@XZ PROC NEAR			; DecalVertex_t::DecalVertex_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0DecalVertex_t@@QAE@XZ ENDP				; DecalVertex_t::DecalVertex_t
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector2D@@QAE@XZ PROC NEAR				; Vector2D::Vector2D, COMDAT

; 57   : 	inline Vector2D(void) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector2D@@QAE@XZ ENDP				; Vector2D::Vector2D
_TEXT	ENDS
;	COMDAT xdata$x
; File z:\xashxtsrc\client\render\r_studio.cpp
xdata$x	SEGMENT
__ehfuncinfo$??1CStudioModelRenderer@@UAE@XZ DD 019930520H
	DD	02H
	DD	FLAT:__unwindtable$??1CStudioModelRenderer@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CStudioModelRenderer@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CStudioModelRenderer@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CStudioModelRenderer@@UAE@XZ$1
xdata$x	ENDS
;	COMDAT ??1CStudioModelRenderer@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1CStudioModelRenderer@@UAE@XZ PROC NEAR		; CStudioModelRenderer::~CStudioModelRenderer, COMDAT

; 160  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CStudioModelRenderer@@UAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CStudioModelRenderer@@6B@ ; CStudioModelRenderer::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 161  : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CStudioModelRenderer@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>
	ret	0
__unwindfunclet$??1CStudioModelRenderer@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>
	ret	0
__ehhandler$??1CStudioModelRenderer@@UAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CStudioModelRenderer@@UAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CStudioModelRenderer@@UAE@XZ ENDP			; CStudioModelRenderer::~CStudioModelRenderer
PUBLIC	?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUcl_entity_s@@@Z ; CStudioModelRenderer::StudioSetEntity
PUBLIC	?StudioSetupInstance@CStudioModelRenderer@@AAE_NXZ ; CStudioModelRenderer::StudioSetupInstance
PUBLIC	__real@4@00000000000000000000
PUBLIC	??_C@_05PECN@incar?$AA@				; `string'
PUBLIC	??_C@_0CI@EKL@Couldn?8t?5create?5instance?5for?5ent@ ; `string'
EXTRN	?ALERT@@YAXW4ALERT_TYPE@@PADZZ:NEAR		; ALERT
EXTRN	?gRenderfuncs@@3Urender_api_s@@A:BYTE		; gRenderfuncs
EXTRN	?UTIL_IsLocal@@YA_NH@Z:NEAR			; UTIL_IsLocal
EXTRN	_atoi:NEAR
;	COMDAT ??_C@_05PECN@incar?$AA@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_C@_05PECN@incar?$AA@ DB 'incar', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EKL@Couldn?8t?5create?5instance?5for?5ent@
CONST	SEGMENT
??_C@_0CI@EKL@Couldn?8t?5create?5instance?5for?5ent@ DB 'Couldn''t create'
	DB	' instance for entity %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@4@00000000000000000000
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT ?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUcl_entity_s@@@Z
_TEXT	SEGMENT
_pEnt$ = 8
_this$ = -4
_iPlayerIndex$71998 = -8
?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUcl_entity_s@@@Z PROC NEAR ; CStudioModelRenderer::StudioSetEntity, COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 	if( !pEnt || !pEnt->model || pEnt->model->type != mod_studio )

	cmp	DWORD PTR _pEnt$[ebp], 0
	je	SHORT $L71995
	mov	eax, DWORD PTR _pEnt$[ebp]
	cmp	DWORD PTR [eax+2964], 0
	je	SHORT $L71995
	mov	ecx, DWORD PTR _pEnt$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	cmp	DWORD PTR [edx+68], 3
	je	SHORT $L71994
$L71995:

; 173  : 		return false;

	xor	al, al
	jmp	$L71993
$L71994:

; 174  : 
; 175  : 	m_pCurrentEntity = RI->currententity = pEnt;

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR _pEnt$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	DWORD PTR [edx+19104], eax

; 176  : 	SET_CURRENT_ENTITY( m_pCurrentEntity );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	push	edx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+32
	add	esp, 4

; 177  : 	m_pPlayerInfo = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+19116], 0

; 178  : 
; 179  : 	if( !m_fDrawViewModel && ( m_pCurrentEntity->player || m_pCurrentEntity->curstate.renderfx == kRenderFxDeadPlayer ))

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+93]
	test	edx, edx
	jne	$L71996
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L71997
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	cmp	DWORD PTR [eax+772], 17			; 00000011H
	jne	$L71996
$L71997:

; 181  : 		int	iPlayerIndex;
; 182  : 
; 183  : 		if( m_pCurrentEntity->curstate.renderfx == kRenderFxDeadPlayer )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	cmp	DWORD PTR [edx+772], 17			; 00000011H
	jne	SHORT $L71999

; 184  : 			iPlayerIndex = m_pCurrentEntity->curstate.renderamt - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	edx, DWORD PTR [ecx+764]
	sub	edx, 1
	mov	DWORD PTR _iPlayerIndex$71998[ebp], edx

; 185  : 		else iPlayerIndex = m_pCurrentEntity->curstate.number - 1;

	jmp	SHORT $L72000
$L71999:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	edx, DWORD PTR [ecx+692]
	sub	edx, 1
	mov	DWORD PTR _iPlayerIndex$71998[ebp], edx
$L72000:

; 186  :           
; 187  : 		if( iPlayerIndex < 0 || iPlayerIndex >= GET_MAX_CLIENTS( ))

	cmp	DWORD PTR _iPlayerIndex$71998[ebp], 0
	jl	SHORT $L72002
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+144
	cmp	DWORD PTR _iPlayerIndex$71998[ebp], eax
	jl	SHORT $L72001
$L72002:

; 188  : 			return false;

	xor	al, al
	jmp	$L71993
$L72001:

; 189  : 
; 190  : 		if( RP_LOCALCLIENT( m_pCurrentEntity ) && atoi( gEngfuncs.PhysInfo_ValueForKey( "incar" )))

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+204
	test	eax, eax
	je	SHORT $L72003
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+19104]
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+204
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $L72003
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L72003
	push	OFFSET FLAT:??_C@_05PECN@incar?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+176
	add	esp, 4
	push	eax
	call	_atoi
	add	esp, 4
	test	eax, eax
	je	SHORT $L72003

; 191  : 			return false;

	xor	al, al
	jmp	$L71993
$L72003:

; 192  : 
; 193  : 		if( RP_NORMALPASS() && RP_LOCALCLIENT( m_pCurrentEntity ) && !FBitSet( RI->params, RP_THIRDPERSON ) && UTIL_IsLocal( RI->viewentity ))

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx]
	and	edx, 483				; 000001e3H
	test	edx, edx
	jne	SHORT $L72005
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+204
	test	eax, eax
	je	SHORT $L72005
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+19104]
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+204
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $L72005
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L72005
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx]
	and	edx, 8192				; 00002000H
	test	edx, edx
	jne	SHORT $L72005
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UTIL_IsLocal@@YA_NH@Z			; UTIL_IsLocal
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L72005

; 195  : 			// hide playermodel in firstperson
; 196  : 			return false;

	xor	al, al
	jmp	$L71993
$L72005:

; 200  : 			RI->currentmodel = m_pRenderModel = IEngineStudio.SetupPlayerModel( iPlayerIndex );

	mov	edx, DWORD PTR _iPlayerIndex$71998[ebp]
	push	edx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+124
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19108], eax
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	DWORD PTR [edx+20], ecx

; 201  : 
; 202  : 			// show highest resolution multiplayer model
; 203  : 			if( CVAR_TO_BOOL( m_pCvarHiModels ) && m_pRenderModel != m_pCurrentEntity->model )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+100], 0
	je	SHORT $L75968
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L75968
	mov	BYTE PTR -12+[ebp], 1
	jmp	SHORT $L75969
$L75968:
	mov	BYTE PTR -12+[ebp], 0
$L75969:
	mov	edx, DWORD PTR -12+[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72007
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	cmp	eax, DWORD PTR [ecx+2964]
	je	SHORT $L72007

; 204  : 				m_pCurrentEntity->curstate.body = 255;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	DWORD PTR [edx+788], 255		; 000000ffH
$L72007:

; 205  : 
; 206  : 			if( !( !developer_level && GET_MAX_CLIENTS() == 1 ) && ( m_pRenderModel == m_pCurrentEntity->model ))

	cmp	DWORD PTR ?developer_level@@3HA, 0	; developer_level
	jne	SHORT $L72009
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+144
	cmp	eax, 1
	je	SHORT $L72008
$L72009:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	cmp	eax, DWORD PTR [ecx+2964]
	jne	SHORT $L72008

; 207  : 				m_pCurrentEntity->curstate.body = 1; // force helmet

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	DWORD PTR [edx+788], 1
$L72008:

; 209  : 
; 210  : 		// setup the playerinfo
; 211  : 		if( m_pCurrentEntity->player )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L72010

; 212  : 			m_pPlayerInfo = IEngineStudio.PlayerInfo( iPlayerIndex );

	mov	edx, DWORD PTR _iPlayerIndex$71998[ebp]
	push	edx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+28
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19116], eax
$L72010:

; 214  : 	else

	jmp	SHORT $L72011
$L71996:

; 216  : 		RI->currentmodel = m_pRenderModel = RI->currententity->model;

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+2964]
	mov	DWORD PTR [ecx+19108], edx
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	DWORD PTR [eax+20], edx
$L72011:

; 218  : 
; 219  : 	if( m_pRenderModel == NULL )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+19108], 0
	jne	SHORT $L72012

; 220  : 		return false;

	xor	al, al
	jmp	SHORT $L71993
$L72012:

; 221  : 
; 222  : 	m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	push	edx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19124], eax

; 223  : 
; 224  :  	// downloading in-progress ?
; 225  : 	if( m_pStudioHeader == NULL )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+19124], 0
	jne	SHORT $L72014

; 226  : 		return false;

	xor	al, al
	jmp	SHORT $L71993
$L72014:

; 227  : 
; 228  : 	// tell the engine about model
; 229  : 	IEngineStudio.StudioSetHeader( m_pStudioHeader );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+140
	add	esp, 4

; 230  : 	IEngineStudio.SetRenderModel( m_pRenderModel );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	push	eax
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+144
	add	esp, 4

; 231  : 
; 232  : 	if( !StudioSetupInstance( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioSetupInstance@CStudioModelRenderer@@AAE_NXZ ; CStudioModelRenderer::StudioSetupInstance
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L72015

; 234  : 		ALERT( at_error, "Couldn't create instance for entity %d\n", pEnt->index );

	mov	ecx, DWORD PTR _pEnt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET FLAT:??_C@_0CI@EKL@Couldn?8t?5create?5instance?5for?5ent@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH

; 235  : 		return false; // out of memory ?

	xor	al, al
	jmp	SHORT $L71993
$L72015:

; 237  : 
; 238  : 	// all done
; 239  : 	return true;

	mov	al, 1
$L71993:

; 240  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUcl_entity_s@@@Z ENDP ; CStudioModelRenderer::StudioSetEntity
_TEXT	ENDS
PUBLIC	?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUgl_studiomesh_t@@@Z ; CStudioModelRenderer::StudioSetEntity
PUBLIC	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
;	COMDAT ?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUgl_studiomesh_t@@@Z
_TEXT	SEGMENT
_entry$ = 8
_this$ = -4
_phdr$ = -8
?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUgl_studiomesh_t@@@Z PROC NEAR ; CStudioModelRenderer::StudioSetEntity, COMDAT

; 246  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 	studiohdr_t *phdr;
; 248  : 
; 249  : 	if( !entry || !entry->parent || !entry->model )

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $L72023
	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $L72023
	mov	ecx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $L72022
$L72023:

; 250  : 		return false; // bad entry?

	xor	al, al
	jmp	$L72020
$L72022:

; 251  : 
; 252  : 	if( entry->parent->modelhandle == INVALID_HANDLE )

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+2960], 65535		; 0000ffffH
	jne	SHORT $L72024

; 253  : 		return false; // not initialized?

	xor	al, al
	jmp	$L72020
$L72024:

; 254  : 
; 255  : 	if(( phdr = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel )) == NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	push	edx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	DWORD PTR _phdr$[ebp], eax
	cmp	DWORD PTR _phdr$[ebp], 0
	jne	SHORT $L72026

; 256  : 		return false; // no model?

	xor	al, al
	jmp	SHORT $L72020
$L72026:

; 257  : 
; 258  : 	RI->currentmodel = m_pRenderModel = entry->model;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+19108], edx
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	DWORD PTR [eax+20], edx

; 259  : 	RI->currententity = m_pCurrentEntity = entry->parent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+19104], edx
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	DWORD PTR [eax+16], edx

; 260  : 	m_pModelInstance = &m_ModelInstances[entry->parent->modelhandle];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	dx, WORD PTR [ecx+2960]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19112], eax

; 261  : 	m_pStudioHeader = phdr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	mov	DWORD PTR [edx+19124], eax

; 262  : 	m_pPlayerInfo = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19116], 0

; 263  : 
; 264  : 	return true;

	mov	al, 1
$L72020:

; 265  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUgl_studiomesh_t@@@Z ENDP ; CStudioModelRenderer::StudioSetEntity
_TEXT	ENDS
PUBLIC	?SetStudioPointers@CStudioBoneSetup@@QAEXPAUstudiohdr_t@@PBM@Z ; CStudioBoneSetup::SetStudioPointers
PUBLIC	?AddToTail@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::AddToTail
;	COMDAT ?StudioSetupInstance@CStudioModelRenderer@@AAE_NXZ
_TEXT	SEGMENT
_this$ = -4
?StudioSetupInstance@CStudioModelRenderer@@AAE_NXZ PROC NEAR ; CStudioModelRenderer::StudioSetupInstance, COMDAT

; 268  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 269  : 	// first call ?
; 270  : 	if( m_pCurrentEntity->modelhandle == INVALID_HANDLE )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx+2960], 65535		; 0000ffffH
	jne	SHORT $L72031

; 272  : 		m_pCurrentEntity->modelhandle = m_ModelInstances.AddToTail();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?AddToTail@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::AddToTail
	and	eax, 65535				; 0000ffffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19104]
	mov	DWORD PTR [ecx+2960], eax

; 273  : 
; 274  : 		if( m_pCurrentEntity->modelhandle == INVALID_HANDLE )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	cmp	DWORD PTR [eax+2960], 65535		; 0000ffffH
	jne	SHORT $L72032

; 275  : 			return false; // out of memory ?

	xor	al, al
	jmp	$L72030
$L72032:

; 276  : 
; 277  : 		m_pModelInstance = &m_ModelInstances[m_pCurrentEntity->modelhandle];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	ax, WORD PTR [edx+2960]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19112], eax

; 278  : 		ClearInstanceData( true );

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+220]

; 280  : 	else

	jmp	SHORT $L72034
$L72031:

; 282  : 		m_pModelInstance = &m_ModelInstances[m_pCurrentEntity->modelhandle];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	ax, WORD PTR [edx+2960]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19112], eax

; 283  : 
; 284  : 		// model has been changed or something like
; 285  : 		if( !IsModelInstanceValid( m_pModelInstance ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+144]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L72034

; 286  : 			ClearInstanceData( false );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+220]
$L72034:

; 288  : 
; 289  : 	m_boneSetup.SetStudioPointers( m_pStudioHeader, m_pModelInstance->m_poseparameter );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 7020				; 00001b6cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?SetStudioPointers@CStudioBoneSetup@@QAEXPAUstudiohdr_t@@PBM@Z ; CStudioBoneSetup::SetStudioPointers

; 290  : 
; 291  : 	return true;

	mov	al, 1
$L72030:

; 292  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioSetupInstance@CStudioModelRenderer@@AAE_NXZ ENDP	; CStudioModelRenderer::StudioSetupInstance
_TEXT	ENDS
;	COMDAT ?SetStudioPointers@CStudioBoneSetup@@QAEXPAUstudiohdr_t@@PBM@Z
_TEXT	SEGMENT
_pStudioHdr$ = 8
_pPoseParams$ = 12
_this$ = -4
?SetStudioPointers@CStudioBoneSetup@@QAEXPAUstudiohdr_t@@PBM@Z PROC NEAR ; CStudioBoneSetup::SetStudioPointers, COMDAT

; 347  : 	void SetStudioPointers( studiohdr_t *pStudioHdr, const float *pPoseParams ) { m_pStudioHeader = pStudioHdr; m_flPoseParams = pPoseParams; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pStudioHdr$[ebp]
	mov	DWORD PTR [eax+18968], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pPoseParams$[ebp]
	mov	DWORD PTR [edx+524], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetStudioPointers@CStudioBoneSetup@@QAEXPAUstudiohdr_t@@PBM@Z ENDP ; CStudioBoneSetup::SetStudioPointers
_TEXT	ENDS
;	COMDAT ?IsModelInstanceValid@CStudioModelRenderer@@EAE_NPAUModelInstance_t@1@@Z
_TEXT	SEGMENT
_inst$ = 8
_this$ = -4
_pModel$ = -8
?IsModelInstanceValid@CStudioModelRenderer@@EAE_NPAUModelInstance_t@1@@Z PROC NEAR ; CStudioModelRenderer::IsModelInstanceValid, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 299  : 	const model_t *pModel;
; 300  : 
; 301  : 	if( !m_fDrawViewModel && ( inst->m_pEntity->player || m_pCurrentEntity->curstate.renderfx == kRenderFxDeadPlayer ))

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+93]
	test	ecx, ecx
	jne	SHORT $L72040
	mov	edx, DWORD PTR _inst$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L72041
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	cmp	DWORD PTR [edx+772], 17			; 00000011H
	jne	SHORT $L72040
$L72041:

; 303  : 		if( m_pCurrentEntity->curstate.renderfx == kRenderFxDeadPlayer )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx+772], 17			; 00000011H
	jne	SHORT $L72042

; 304  : 			pModel = IEngineStudio.SetupPlayerModel( inst->m_pEntity->curstate.renderamt - 1 );

	mov	edx, DWORD PTR _inst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+764]
	sub	ecx, 1
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+124
	add	esp, 4
	mov	DWORD PTR _pModel$[ebp], eax

; 305  : 		else pModel = IEngineStudio.SetupPlayerModel( inst->m_pEntity->curstate.number - 1 );

	jmp	SHORT $L72043
$L72042:
	mov	edx, DWORD PTR _inst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+692]
	sub	ecx, 1
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+124
	add	esp, 4
	mov	DWORD PTR _pModel$[ebp], eax
$L72043:

; 307  : 	else pModel = inst->m_pEntity->model;

	jmp	SHORT $L72044
$L72040:
	mov	edx, DWORD PTR _inst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+2964]
	mov	DWORD PTR _pModel$[ebp], ecx
$L72044:

; 308  : 
; 309  : 	return inst->m_pModel == pModel;

	mov	edx, DWORD PTR _inst$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _pModel$[ebp]
	sete	cl
	mov	al, cl

; 310  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsModelInstanceValid@CStudioModelRenderer@@EAE_NPAUModelInstance_t@1@@Z ENDP ; CStudioModelRenderer::IsModelInstanceValid
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DestroyInstance@CStudioModelRenderer@@EAEXG@Z@4FA ; `CStudioModelRenderer::DestroyInstance'::`2'::__LINE__Var
PUBLIC	??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
PUBLIC	??_GCJiggleBones@@QAEPAXI@Z			; CJiggleBones::`scalar deleting destructor'
PUBLIC	?Remove@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Remove
PUBLIC	?IsValidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsValidIndex
EXTRN	?DestroyDecalList@CStudioModelRenderer@@AAEXG@Z:NEAR ; CStudioModelRenderer::DestroyDecalList
;	COMDAT ?__LINE__Var@?1??DestroyInstance@CStudioModelRenderer@@EAEXG@Z@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DestroyInstance@CStudioModelRenderer@@EAEXG@Z@4FA DW 0139H ; `CStudioModelRenderer::DestroyInstance'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@
CONST	SEGMENT
??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ DB 'z:\xashxtsrc\cl'
	DB	'ient\render\r_studio.cpp', 00H		; `string'
CONST	ENDS
;	COMDAT ?DestroyInstance@CStudioModelRenderer@@EAEXG@Z
_TEXT	SEGMENT
$T75982 = -12
$T75983 = -16
_handle$ = 8
_this$ = -4
_inst$ = -8
?DestroyInstance@CStudioModelRenderer@@EAEXG@Z PROC NEAR ; CStudioModelRenderer::DestroyInstance, COMDAT

; 313  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 314  : 	if( !m_ModelInstances.IsValidIndex( handle ))

	mov	ax, WORD PTR _handle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?IsValidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L72049

; 315  : 		return;

	jmp	$L72048
$L72049:

; 316  : 
; 317  : 	ModelInstance_t *inst = &m_ModelInstances[handle];

	mov	cx, WORD PTR _handle$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	DWORD PTR _inst$[ebp], eax

; 318  : 
; 319  : 	DestroyDecalList( inst->m_DecalHandle );

	mov	edx, DWORD PTR _inst$[ebp]
	mov	ax, WORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DestroyDecalList@CStudioModelRenderer@@AAEXG@Z ; CStudioModelRenderer::DestroyDecalList

; 320  : 	inst->m_DecalHandle = INVALID_HANDLE;

	mov	ecx, DWORD PTR _inst$[ebp]
	mov	WORD PTR [ecx+8], 65535			; 0000ffffH

; 321  : 
; 322  : 	if( inst->materials != NULL )

	mov	edx, DWORD PTR _inst$[ebp]
	cmp	DWORD PTR [edx+11448], 0
	je	SHORT $L72051

; 323  : 		Mem_Free( inst->materials );

	movsx	eax, WORD PTR ?__LINE__Var@?1??DestroyInstance@CStudioModelRenderer@@EAEXG@Z@4FA ; `CStudioModelRenderer::DestroyInstance'::`2'::__LINE__Var
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	mov	ecx, DWORD PTR _inst$[ebp]
	mov	edx, DWORD PTR [ecx+11448]
	push	edx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+220
	add	esp, 12					; 0000000cH
$L72051:

; 324  : 	inst->materials = NULL;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	DWORD PTR [eax+11448], 0

; 325  : 
; 326  : 	if( inst->m_pJiggleBones != NULL )

	mov	ecx, DWORD PTR _inst$[ebp]
	cmp	DWORD PTR [ecx+7304], 0
	je	SHORT $L75985

; 327  : 		delete inst->m_pJiggleBones;

	mov	edx, DWORD PTR _inst$[ebp]
	mov	eax, DWORD PTR [edx+7304]
	mov	DWORD PTR $T75983[ebp], eax
	mov	ecx, DWORD PTR $T75983[ebp]
	mov	DWORD PTR $T75982[ebp], ecx
	cmp	DWORD PTR $T75982[ebp], 0
	je	SHORT $L75984
	push	1
	mov	ecx, DWORD PTR $T75982[ebp]
	call	??_GCJiggleBones@@QAEPAXI@Z		; CJiggleBones::`scalar deleting destructor'
	mov	DWORD PTR -20+[ebp], eax
	jmp	SHORT $L75985
$L75984:
	mov	DWORD PTR -20+[ebp], 0
$L75985:

; 328  : 	inst->m_pJiggleBones = NULL;

	mov	edx, DWORD PTR _inst$[ebp]
	mov	DWORD PTR [edx+7304], 0

; 329  : 
; 330  : 	m_ModelInstances.Remove( handle );

	mov	ax, WORD PTR _handle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?Remove@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Remove
$L72048:

; 331  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DestroyInstance@CStudioModelRenderer@@EAEXG@Z ENDP	; CStudioModelRenderer::DestroyInstance
_TEXT	ENDS
PUBLIC	??1CJiggleBones@@QAE@XZ				; CJiggleBones::~CJiggleBones
;	COMDAT ??_GCJiggleBones@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCJiggleBones@@QAEPAXI@Z PROC NEAR			; CJiggleBones::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CJiggleBones@@QAE@XZ			; CJiggleBones::~CJiggleBones
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L72060
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L72060:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCJiggleBones@@QAEPAXI@Z ENDP			; CJiggleBones::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ	; CUtlLinkedList<JiggleData,unsigned short>::~CUtlLinkedList<JiggleData,unsigned short>
PUBLIC	?RemoveAll@?$CUtlLinkedList@UJiggleData@@G@@QAEXXZ ; CUtlLinkedList<JiggleData,unsigned short>::RemoveAll
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\jigglebones.h
xdata$x	SEGMENT
__ehfuncinfo$??1CJiggleBones@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CJiggleBones@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CJiggleBones@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CJiggleBones@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CJiggleBones@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1CJiggleBones@@QAE@XZ PROC NEAR			; CJiggleBones::~CJiggleBones, COMDAT

; 71   : 	~CJiggleBones() { m_jiggleBoneState.RemoveAll(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CJiggleBones@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlLinkedList@UJiggleData@@G@@QAEXXZ ; CUtlLinkedList<JiggleData,unsigned short>::RemoveAll
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ ; CUtlLinkedList<JiggleData,unsigned short>::~CUtlLinkedList<JiggleData,unsigned short>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CJiggleBones@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ ; CUtlLinkedList<JiggleData,unsigned short>::~CUtlLinkedList<JiggleData,unsigned short>
	ret	0
__ehhandler$??1CJiggleBones@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CJiggleBones@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CJiggleBones@@QAE@XZ ENDP				; CJiggleBones::~CJiggleBones
PUBLIC	?__LINE__Var@?1??UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::UpdateInstanceMaterials'::`2'::__LINE__Var
PUBLIC	??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
;	COMDAT ?__LINE__Var@?1??UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ@4FA DW 014eH ; `CStudioModelRenderer::UpdateInstanceMaterials'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@
CONST	SEGMENT
??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::UpdateInstanceMaterials, COMDAT

; 334  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 335  : 	ASSERT( m_pStudioHeader != NULL );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+19124], 0
	jne	SHORT $L72066
	movsx	ecx, WORD PTR ?__LINE__Var@?1??UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::UpdateInstanceMaterials'::`2'::__LINE__Var
	add	ecx, 1
	push	ecx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72066:

; 336  : 	ASSERT( m_pModelInstance != NULL );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+19112], 0
	jne	SHORT $L72068
	movsx	eax, WORD PTR ?__LINE__Var@?1??UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::UpdateInstanceMaterials'::`2'::__LINE__Var
	add	eax, 2
	push	eax
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72068:

; 337  : 
; 338  : 	// model was changed, so we need to realloc materials
; 339  : 	if( m_pModelInstance->materials != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	cmp	DWORD PTR [edx+11448], 0
	je	SHORT $L72069

; 340  : 		Mem_Free( m_pModelInstance->materials );

	movsx	eax, WORD PTR ?__LINE__Var@?1??UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::UpdateInstanceMaterials'::`2'::__LINE__Var
	add	eax, 6
	push	eax
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR [edx+11448]
	push	eax
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+220
	add	esp, 12					; 0000000cH
$L72069:

; 341  : 
; 342  : 	// create a local copy of all the model material for cache uber-shaders
; 343  : 	m_pModelInstance->materials = (mstudiomaterial_t *)Mem_Alloc( sizeof( mstudiomaterial_t ) * m_pStudioHeader->numtextures );

	movsx	ecx, WORD PTR ?__LINE__Var@?1??UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::UpdateInstanceMaterials'::`2'::__LINE__Var
	add	ecx, 9
	push	ecx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR [eax+180]
	imul	ecx, 28					; 0000001cH
	push	ecx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+216
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	mov	DWORD PTR [ecx+11448], eax

; 344  : 	memcpy( m_pModelInstance->materials, m_pRenderModel->materials, sizeof( mstudiomaterial_t ) * m_pStudioHeader->numtextures );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR [eax+180]
	imul	ecx, 28					; 0000001cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	mov	ecx, DWORD PTR [eax+384]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [eax+11448]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 345  : 
; 346  : 	// invalidate sequences when a new instance was created
; 347  : 	for( int i = 0; i < m_pStudioHeader->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72074
$L72075:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L72074:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+180]
	jge	SHORT $L72076

; 349  : 		m_pModelInstance->materials[i].glsl_sequence = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR [ecx+11448]
	mov	WORD PTR [eax+edx+20], 65535		; 0000ffffH

; 350  : 		m_pModelInstance->materials[i].glsl_sequence_omni = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR [edx+11448]
	mov	WORD PTR [ecx+eax+22], 65535		; 0000ffffH

; 351  : 		m_pModelInstance->materials[i].glsl_sequence_proj[0] = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR [eax+11448]
	mov	WORD PTR [edx+ecx+24], 65535		; 0000ffffH

; 352  : 		m_pModelInstance->materials[i].glsl_sequence_proj[1] = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR [ecx+11448]
	mov	WORD PTR [eax+edx+26], 65535		; 0000ffffH

; 353  : 	}

	jmp	$L72075
$L72076:

; 354  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateInstanceMaterials@CStudioModelRenderer@@EAEXXZ ENDP ; CStudioModelRenderer::UpdateInstanceMaterials
_TEXT	ENDS
PUBLIC	??Bmatrix3x4@@QAEPAMXZ				; matrix3x4::operator float *
PUBLIC	?SetOrigin@matrix3x4@@QAEXABVVector@@@Z		; matrix3x4::SetOrigin
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
EXTRN	?Identity@matrix3x4@@QAEXXZ:NEAR		; matrix3x4::Identity
EXTRN	?Q_strncpy@@YAIPADPBDI@Z:NEAR			; Q_strncpy
EXTRN	?ClearBounds@@YAXAAVVector@@0@Z:NEAR		; ClearBounds
EXTRN	?CalcDefaultPoseParameters@CStudioBoneSetup@@QAEXQAM@Z:NEAR ; CStudioBoneSetup::CalcDefaultPoseParameters
EXTRN	_memset:NEAR
EXTRN	?tr@@3Uref_globals_t@@A:BYTE			; tr
;	COMDAT ?ClearInstanceData@CStudioModelRenderer@@EAEX_N@Z
_TEXT	SEGMENT
$T76001 = -24
$T76002 = -28
_create$ = 8
_this$ = -4
_pattachment$ = -8
_att$ = -12
_i$ = -16
_map$ = -20
?ClearInstanceData@CStudioModelRenderer@@EAEX_N@Z PROC NEAR ; CStudioModelRenderer::ClearInstanceData, COMDAT

; 357  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 358  : 	if( create )

	mov	eax, DWORD PTR _create$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L72081

; 360  : 		m_pModelInstance->m_pJiggleBones = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	DWORD PTR [edx+7304], 0

; 361  : 		m_pModelInstance->materials = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	DWORD PTR [ecx+11448], 0

; 363  : 	else

	jmp	SHORT $L72082
$L72081:

; 365  : 		DestroyDecalList( m_pModelInstance->m_DecalHandle );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	cx, WORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DestroyDecalList@CStudioModelRenderer@@AAEXG@Z ; CStudioModelRenderer::DestroyDecalList

; 366  : 		if( m_pModelInstance->m_pJiggleBones != NULL )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	cmp	DWORD PTR [eax+7304], 0
	je	SHORT $L76004

; 367  : 			delete m_pModelInstance->m_pJiggleBones;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR [edx+7304]
	mov	DWORD PTR $T76002[ebp], eax
	mov	ecx, DWORD PTR $T76002[ebp]
	mov	DWORD PTR $T76001[ebp], ecx
	cmp	DWORD PTR $T76001[ebp], 0
	je	SHORT $L76003
	push	1
	mov	ecx, DWORD PTR $T76001[ebp]
	call	??_GCJiggleBones@@QAEPAXI@Z		; CJiggleBones::`scalar deleting destructor'
	mov	DWORD PTR -32+[ebp], eax
	jmp	SHORT $L76004
$L76003:
	mov	DWORD PTR -32+[ebp], 0
$L76004:

; 368  : 		m_pModelInstance->m_pJiggleBones = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	DWORD PTR [eax+7304], 0
$L72082:

; 370  : 
; 371  : 	m_pModelInstance->m_pEntity = m_pCurrentEntity;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	DWORD PTR [edx], ecx

; 372  : 	m_pModelInstance->m_pModel = m_pRenderModel;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	DWORD PTR [eax+4], edx

; 373  : 	m_pModelInstance->m_DecalHandle = INVALID_HANDLE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	WORD PTR [ecx+8], 65535			; 0000ffffH

; 374  : 	m_pModelInstance->m_VlCache = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	DWORD PTR [eax+20], 0

; 375  : 	m_pModelInstance->m_DecalCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	DWORD PTR [edx+12], 0

; 376  : 	m_pModelInstance->cached_frame = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	DWORD PTR [ecx+34084], -1

; 377  : 	m_pModelInstance->visframe = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	DWORD PTR [eax+34088], -1

; 378  : 	m_pModelInstance->radius = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	DWORD PTR [edx+180], 0

; 379  : 	m_pModelInstance->info_flags = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	DWORD PTR [ecx+16], 0

; 380  : 
; 381  : 	ClearBounds( m_pModelInstance->absmin, m_pModelInstance->absmax );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 168				; 000000a8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 156				; 0000009cH
	push	edx
	call	?ClearBounds@@YAXAAVVector@@0@Z		; ClearBounds
	add	esp, 8

; 382  : 	memset( &m_pModelInstance->bonecache, 0, sizeof( BoneCache_t ));

	push	168					; 000000a8H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 184				; 000000b8H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 383  : 	memset( m_pModelInstance->m_protationmatrix, 0, sizeof( matrix3x4 ));

	push	48					; 00000030H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	add	ecx, 11452				; 00002cbcH
	call	??Bmatrix3x4@@QAEPAMXZ			; matrix3x4::operator float *
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 384  : 	memset( m_pModelInstance->m_pbones, 0, sizeof( matrix3x4 ) * MAXSTUDIOBONES );

	push	6144					; 00001800H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 11548				; 00002d1cH
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 385  : 	memset( m_pModelInstance->m_pwpnbones, 0, sizeof( matrix3x4 ) * MAXSTUDIOBONES );

	push	6144					; 00001800H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 17692				; 0000451cH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 386  : 	memset( m_pModelInstance->attachment, 0, sizeof( StudioAttachment_t ) * MAXSTUDIOATTACHMENTS );

	push	6656					; 00001a00H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 352				; 00000160H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 387  : 	memset( m_pModelInstance->m_studioquat, 0, sizeof( Vector4D ) * MAXSTUDIOBONES );

	push	2048					; 00000800H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 26916				; 00006924H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 388  : 	memset( m_pModelInstance->m_studiopos, 0, sizeof( Vector ) * MAXSTUDIOBONES );

	push	1536					; 00000600H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 28964				; 00007124H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 389  : 	memset( m_pModelInstance->m_weaponquat, 0, sizeof( Vector4D ) * MAXSTUDIOBONES );

	push	2048					; 00000800H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 30500				; 00007724H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 390  : 	memset( m_pModelInstance->m_weaponpos, 0, sizeof( Vector ) * MAXSTUDIOBONES );

	push	1536					; 00000600H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 32548				; 00007f24H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 391  : 	memset( &m_pModelInstance->lighting, 0, sizeof( mstudiolight_t ));

	push	32					; 00000020H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 28					; 0000001cH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 392  : 
; 393  : 	memset( &m_pModelInstance->lerp, 0, sizeof( mstudiolerp_t ));

	push	24					; 00000018H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 7280				; 00001c70H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 394  : 	memset( &m_pModelInstance->m_controller, 0, sizeof( m_pModelInstance->m_controller ));

	push	8
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 7012				; 00001b64H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 395  : 	memset( &m_pModelInstance->m_seqblend, 0, sizeof( m_pModelInstance->m_seqblend ));

	push	160					; 000000a0H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 7116				; 00001bccH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 396  : 	m_pModelInstance->m_bProceduralBones = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	BYTE PTR [edx+26908], 0

; 397  : 	m_pModelInstance->m_current_seqblend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	DWORD PTR [ecx+7276], 0

; 398  : 	m_pModelInstance->lerp.stairoldz = m_pCurrentEntity->origin[2];

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19104]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+7300], eax

; 399  : 	m_pModelInstance->lerp.stairtime = tr.time;

	fld	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fst	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	fstp	DWORD PTR [edx+7296]

; 400  : 	m_pModelInstance->m_DecalHandle = INVALID_HANDLE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	WORD PTR [ecx+8], 65535			; 0000ffffH

; 401  : 	m_pModelInstance->m_pModel = m_pRenderModel;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	DWORD PTR [eax+4], edx

; 402  : 	m_pModelInstance->m_flLastBoneUpdate = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	DWORD PTR [ecx+26912], 0

; 403  : 	m_pModelInstance->m_pJiggleBones = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	DWORD PTR [eax+7304], 0

; 404  : 	m_pModelInstance->cached_frame = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	DWORD PTR [edx+34084], -1

; 405  : 	m_pModelInstance->m_DecalCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	DWORD PTR [ecx+12], 0

; 406  : 	m_pModelInstance->visframe = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	DWORD PTR [eax+34088], -1

; 407  : 	m_pModelInstance->radius = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	DWORD PTR [edx+180], 0

; 408  : 	m_pModelInstance->info_flags = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	DWORD PTR [ecx+16], 0

; 409  : 
; 410  : 	m_boneSetup.SetStudioPointers( m_pStudioHeader, m_pModelInstance->m_poseparameter );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 7020				; 00001b6cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?SetStudioPointers@CStudioBoneSetup@@QAEXPAUstudiohdr_t@@PBM@Z ; CStudioBoneSetup::SetStudioPointers

; 411  : 
; 412  : 	// set poseparam sliders to their default values
; 413  : 	m_boneSetup.CalcDefaultPoseParameters( m_pModelInstance->m_poseparameter );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 7020				; 00001b6cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?CalcDefaultPoseParameters@CStudioBoneSetup@@QAEXQAM@Z ; CStudioBoneSetup::CalcDefaultPoseParameters

; 414  : 
; 415  : 	// refresh the materials list
; 416  : 	UpdateInstanceMaterials();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+216]

; 417  : 
; 418  : 	// copy attachments names
; 419  : 	mstudioattachment_t *pattachment = (mstudioattachment_t *)((byte *)m_pStudioHeader + m_pStudioHeader->attachmentindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+216]
	mov	DWORD PTR _pattachment$[ebp], ecx

; 420  : 	StudioAttachment_t *att = m_pModelInstance->attachment;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 352				; 00000160H
	mov	DWORD PTR _att$[ebp], eax

; 421  : 
; 422  : 	// setup attachment names
; 423  : 	for( int i = 0; i < Q_min( MAXSTUDIOATTACHMENTS, m_pStudioHeader->numattachments ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72102
$L72103:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L72102:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	cmp	DWORD PTR [eax+212], 64			; 00000040H
	jle	SHORT $L76005
	mov	DWORD PTR -40+[ebp], 64			; 00000040H
	jmp	SHORT $L76006
$L76005:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR [edx+212]
	mov	DWORD PTR -40+[ebp], eax
$L76006:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR -40+[ebp]
	jge	SHORT $L72104

; 425  : 		Q_strncpy( att[i].name, pattachment[i].name, sizeof( att[0].name ));

	push	32					; 00000020H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _pattachment$[ebp]
	add	eax, edx
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 104				; 00000068H
	mov	edx, DWORD PTR _att$[ebp]
	add	edx, ecx
	push	edx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 426  : 		att[i].local.Identity();

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR _att$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+32]
	call	?Identity@matrix3x4@@QAEXXZ		; matrix3x4::Identity

; 427  : 		att[i].local.SetOrigin( pattachment[i].org );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _pattachment$[ebp]
	lea	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 104				; 00000068H
	mov	eax, DWORD PTR _att$[ebp]
	lea	ecx, DWORD PTR [eax+edx+32]
	call	?SetOrigin@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetOrigin

; 428  : 	}

	jmp	$L72103
$L72104:

; 429  : 	m_pModelInstance->numattachments = m_pStudioHeader->numattachments;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR [edx+212]
	mov	DWORD PTR [ecx+7008], edx

; 430  : 
; 431  : 	for( int map = 0; map < MAXLIGHTMAPS; map++ )

	mov	DWORD PTR _map$[ebp], 0
	jmp	SHORT $L72106
$L72107:
	mov	eax, DWORD PTR _map$[ebp]
	add	eax, 1
	mov	DWORD PTR _map$[ebp], eax
$L72106:
	cmp	DWORD PTR _map$[ebp], 4
	jge	SHORT $L72108

; 432  : 		m_pModelInstance->styles[map] = 255;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _map$[ebp]
	mov	BYTE PTR [edx+eax+24], 255		; 000000ffH
	jmp	SHORT $L72107
$L72108:

; 433  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearInstanceData@CStudioModelRenderer@@EAEX_N@Z ENDP	; CStudioModelRenderer::ClearInstanceData
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
;	COMDAT ??Bmatrix3x4@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??Bmatrix3x4@@QAEPAMXZ PROC NEAR			; matrix3x4::operator float *, COMDAT

; 499  : 	operator float *() { return (float *)&mat[0][0]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??Bmatrix3x4@@QAEPAMXZ ENDP				; matrix3x4::operator float *
_TEXT	ENDS
;	COMDAT ?SetOrigin@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_vOrigin$ = 8
_this$ = -4
?SetOrigin@matrix3x4@@QAEXABVVector@@@Z PROC NEAR	; matrix3x4::SetOrigin, COMDAT

; 530  : 	void	SetOrigin( const Vector &vOrigin ) { mat[3] = vOrigin; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _vOrigin$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetOrigin@matrix3x4@@QAEXABVVector@@@Z ENDP		; matrix3x4::SetOrigin
_TEXT	ENDS
PUBLIC	?ProcessUserData@CStudioModelRenderer@@QAEXPAUmodel_s@@HPBE@Z ; CStudioModelRenderer::ProcessUserData
;	COMDAT ?ProcessUserData@CStudioModelRenderer@@QAEXPAUmodel_s@@HPBE@Z
_TEXT	SEGMENT
_mod$ = 8
_create$ = 12
_buffer$ = 16
_this$ = -4
_src$72118 = -8
_start$72120 = -16
_end$72121 = -24
?ProcessUserData@CStudioModelRenderer@@QAEXPAUmodel_s@@HPBE@Z PROC NEAR ; CStudioModelRenderer::ProcessUserData, COMDAT

; 436  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 437  : 	m_pRenderModel = mod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+19108], ecx

; 438  : 
; 439  : 	if( !( m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel )))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	push	eax
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19124], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+19124], 0
	jne	SHORT $L72116

; 440  : 		return;

	jmp	$L72114
$L72116:

; 441  : 
; 442  : 	IEngineStudio.StudioSetHeader( m_pStudioHeader );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+140
	add	esp, 4

; 443  : 	IEngineStudio.SetRenderModel( m_pRenderModel );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	push	eax
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+144
	add	esp, 4

; 444  : 
; 445  : 	if( create )

	cmp	DWORD PTR _create$[ebp], 0
	je	SHORT $L72117

; 447  : 		// compute model CRC to verify vertexlighting data
; 448  : 		// NOTE: source buffer is not equal to Mod_Extradata!
; 449  : 		studiohdr_t *src = (studiohdr_t *)buffer;

	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _src$72118[ebp], ecx

; 450  : 		m_pRenderModel->modelCRC = FILE_CRC32( buffer, src->length );

	mov	edx, DWORD PTR _src$72118[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+228
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19108]
	mov	DWORD PTR [ecx+112], eax

; 451  : 		double start = Sys_DoubleTime();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+500
	fstp	QWORD PTR _start$72120[ebp]

; 452  : 		m_pRenderModel->studiocache = CreateMeshCache();

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+196]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	DWORD PTR [edx+380], eax

; 453  : 		double end = Sys_DoubleTime();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+500
	fst	QWORD PTR _end$72121[ebp]

; 454  : 		tr.buildtime += (end - start);

	fsub	QWORD PTR _start$72120[ebp]
	fadd	QWORD PTR ?tr@@3Uref_globals_t@@A+1417184
	fstp	QWORD PTR ?tr@@3Uref_globals_t@@A+1417184

; 456  : 	else

	jmp	SHORT $L72122
$L72117:

; 458  : 		DestroyMeshCache();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
$L72122:
$L72114:

; 460  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ProcessUserData@CStudioModelRenderer@@QAEXPAUmodel_s@@HPBE@Z ENDP ; CStudioModelRenderer::ProcessUserData
_TEXT	ENDS
PUBLIC	??8matrix3x4@@QBEHABV0@@Z			; matrix3x4::operator==
EXTRN	_memcmp:NEAR
;	COMDAT ?CheckBoneCache@CStudioModelRenderer@@EAE_NM@Z
_TEXT	SEGMENT
_f$ = 8
_this$ = -4
_cache$ = -8
_e$ = -12
_pos_valid$ = -16
_param_valid$ = -20
?CheckBoneCache@CStudioModelRenderer@@EAE_NM@Z PROC NEAR ; CStudioModelRenderer::CheckBoneCache, COMDAT

; 463  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 464  : 	if( m_fShootDecal || !m_pModelInstance )

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+92]
	test	ecx, ecx
	jne	SHORT $L72128
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+19112], 0
	jne	SHORT $L72127
$L72128:

; 465  : 		return false;

	xor	al, al
	jmp	$L72126
$L72127:

; 466  : 
; 467  : 	if( m_pModelInstance->m_bProceduralBones )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+26908]
	test	edx, edx
	je	SHORT $L72129

; 468  : 		return false; // need to be updated every frame

	xor	al, al
	jmp	$L72126
$L72129:

; 469  : 
; 470  : 	BoneCache_t *cache = &m_pModelInstance->bonecache;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 184				; 000000b8H
	mov	DWORD PTR _cache$[ebp], ecx

; 471  : 	cl_entity_t *e = m_pCurrentEntity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	DWORD PTR _e$[ebp], eax

; 472  : 
; 473  : 	bool pos_valid = (cache->transform == m_pModelInstance->m_protationmatrix) ? true : false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 11452				; 00002cbcH
	push	edx
	mov	ecx, DWORD PTR _cache$[ebp]
	add	ecx, 16					; 00000010H
	call	??8matrix3x4@@QBEHABV0@@Z		; matrix3x4::operator==
	test	eax, eax
	setne	al
	mov	BYTE PTR _pos_valid$[ebp], al

; 474  : 	bool param_valid = !memcmp( cache->poseparam, m_pModelInstance->m_poseparameter, sizeof( float ) * MAXSTUDIOPOSEPARAM );

	push	96					; 00000060H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 7020				; 00001b6cH
	push	edx
	mov	eax, DWORD PTR _cache$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	BYTE PTR _param_valid$[ebp], al

; 478  : 	&& !memcmp( cache->controller, e->curstate.controller, 4 ) && cache->mouthopen == e->mouth.mouthopen && param_valid )

	mov	ecx, DWORD PTR _cache$[ebp]
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR _f$[ebp]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	$L72138
	mov	edx, DWORD PTR _cache$[ebp]
	movsx	eax, WORD PTR [edx+4]
	mov	ecx, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR [ecx+732]
	jne	$L72138
	mov	edx, DWORD PTR _pos_valid$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	$L72138
	push	2
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 796				; 0000031cH
	push	eax
	mov	ecx, DWORD PTR _cache$[ebp]
	add	ecx, 6
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$L72138
	push	4
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 792				; 00000318H
	push	edx
	mov	eax, DWORD PTR _cache$[ebp]
	add	eax, 8
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L72138
	mov	ecx, DWORD PTR _cache$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+12]
	mov	eax, DWORD PTR _e$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+2824]
	cmp	edx, ecx
	jne	SHORT $L72138
	mov	edx, DWORD PTR _param_valid$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72138

; 480  : 		if( m_pPlayerInfo )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+19116], 0
	je	SHORT $L72136

; 482  : 			if( cache->gaitsequence == m_pPlayerInfo->gaitsequence && cache->gaitframe == m_pPlayerInfo->gaitframe )

	mov	ecx, DWORD PTR _cache$[ebp]
	movsx	edx, WORD PTR [ecx+160]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19116]
	cmp	edx, DWORD PTR [ecx+380]
	jne	SHORT $L72137
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19116]
	mov	ecx, DWORD PTR _cache$[ebp]
	fld	DWORD PTR [ecx+164]
	fcomp	DWORD PTR [eax+384]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L72137

; 483  : 				return true;

	mov	al, 1
	jmp	$L72126
$L72137:

; 485  : 		else

	jmp	SHORT $L72138
$L72136:

; 487  : 			// cache are valid
; 488  : 			return true;

	mov	al, 1
	jmp	$L72126
$L72138:

; 491  : 
; 492  : 	// update bonecache
; 493  : 	cache->frame = f;

	mov	edx, DWORD PTR _cache$[ebp]
	mov	eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR [edx], eax

; 494  : 	cache->mouthopen = e->mouth.mouthopen;

	mov	ecx, DWORD PTR _cache$[ebp]
	mov	edx, DWORD PTR _e$[ebp]
	mov	al, BYTE PTR [edx+2824]
	mov	BYTE PTR [ecx+12], al

; 495  : 	cache->sequence = e->curstate.sequence;

	mov	ecx, DWORD PTR _cache$[ebp]
	mov	edx, DWORD PTR _e$[ebp]
	mov	ax, WORD PTR [edx+732]
	mov	WORD PTR [ecx+4], ax

; 496  : 	cache->transform = m_pModelInstance->m_protationmatrix;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+19112]
	add	esi, 11452				; 00002cbcH
	mov	edi, DWORD PTR _cache$[ebp]
	add	edi, 16					; 00000010H
	mov	ecx, 12					; 0000000cH
	rep movsd

; 497  : 	memcpy( cache->blending, e->curstate.blending, 2 );

	push	2
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 796				; 0000031cH
	push	edx
	mov	eax, DWORD PTR _cache$[ebp]
	add	eax, 6
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 498  : 	memcpy( cache->controller, e->curstate.controller, 4 );

	push	4
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 792				; 00000318H
	push	ecx
	mov	edx, DWORD PTR _cache$[ebp]
	add	edx, 8
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 499  : 	memcpy( cache->poseparam, m_pModelInstance->m_poseparameter, sizeof( float ) * MAXSTUDIOPOSEPARAM );

	push	96					; 00000060H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 7020				; 00001b6cH
	push	ecx
	mov	edx, DWORD PTR _cache$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 500  : 
; 501  : 	if( m_pPlayerInfo )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+19116], 0
	je	SHORT $L72140

; 503  : 		cache->gaitsequence = m_pPlayerInfo->gaitsequence;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19116]
	mov	eax, DWORD PTR _cache$[ebp]
	mov	cx, WORD PTR [edx+380]
	mov	WORD PTR [eax+160], cx

; 504  : 		cache->gaitframe = m_pPlayerInfo->gaitframe;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19116]
	mov	ecx, DWORD PTR _cache$[ebp]
	mov	edx, DWORD PTR [eax+384]
	mov	DWORD PTR [ecx+164], edx
$L72140:

; 506  : 
; 507  : 	return false;

	xor	al, al
$L72126:

; 508  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CheckBoneCache@CStudioModelRenderer@@EAE_NM@Z ENDP	; CStudioModelRenderer::CheckBoneCache
_TEXT	ENDS
PUBLIC	??Amatrix3x4@@QBEPBMH@Z				; matrix3x4::operator[]
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT
_mat2$ = 8
_this$ = -4
??8matrix3x4@@QBEHABV0@@Z PROC NEAR			; matrix3x4::operator==, COMDAT

; 503  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 504  : 		if( mat[0][0] != mat2[0][0] || mat[0][1] != mat2[0][1] || mat[0][2] != mat2[0][2] )

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	push	0
	mov	ecx, DWORD PTR _mat2$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR [esi]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L55443
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	push	0
	mov	ecx, DWORD PTR _mat2$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR [esi+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L55443
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	push	0
	mov	ecx, DWORD PTR _mat2$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR [esi+8]
	fcomp	DWORD PTR [eax+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L55442
$L55443:

; 505  : 			return false;

	xor	eax, eax
	jmp	$L55441
$L55442:

; 506  : 		if( mat[1][0] != mat2[1][0] || mat[1][1] != mat2[1][1] || mat[1][2] != mat2[1][2] )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	push	1
	mov	ecx, DWORD PTR _mat2$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR [esi]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L55445
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	push	1
	mov	ecx, DWORD PTR _mat2$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR [esi+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L55445
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	push	1
	mov	ecx, DWORD PTR _mat2$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR [esi+8]
	fcomp	DWORD PTR [eax+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L55444
$L55445:

; 507  : 			return false;

	xor	eax, eax
	jmp	$L55441
$L55444:

; 508  : 		if( mat[2][0] != mat2[2][0] || mat[2][1] != mat2[2][1] || mat[2][2] != mat2[2][2] )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	push	2
	mov	ecx, DWORD PTR _mat2$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR [esi]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L55447
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	push	2
	mov	ecx, DWORD PTR _mat2$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR [esi+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L55447
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	push	2
	mov	ecx, DWORD PTR _mat2$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR [esi+8]
	fcomp	DWORD PTR [eax+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L55446
$L55447:

; 509  : 			return false;

	xor	eax, eax
	jmp	SHORT $L55441
$L55446:

; 510  : 		if( mat[3][0] != mat2[3][0] || mat[3][1] != mat2[3][1] || mat[3][2] != mat2[3][2] )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	push	3
	mov	ecx, DWORD PTR _mat2$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR [esi]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L55449
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	push	3
	mov	ecx, DWORD PTR _mat2$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR [esi+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L55449
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	push	3
	mov	ecx, DWORD PTR _mat2$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR [esi+8]
	fcomp	DWORD PTR [eax+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L55448
$L55449:

; 511  : 			return false;

	xor	eax, eax
	jmp	SHORT $L55441
$L55448:

; 512  : 		return true;

	mov	eax, 1
$L55441:

; 513  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8matrix3x4@@QBEHABV0@@Z ENDP				; matrix3x4::operator==
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??Amatrix3x4@@QBEPBMH@Z PROC NEAR			; matrix3x4::operator[], COMDAT

; 498  : 	float const* operator[]( int i ) const { return mat[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, eax
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??Amatrix3x4@@QBEPBMH@Z ENDP				; matrix3x4::operator[]
_TEXT	ENDS
PUBLIC	??Amatrix3x4@@QAEPAMH@Z				; matrix3x4::operator[]
PUBLIC	?LoadLocalMatrix@CStudioModelRenderer@@QAEXHPAUmstudioboneinfo_t@@@Z ; CStudioModelRenderer::LoadLocalMatrix
;	COMDAT ?LoadLocalMatrix@CStudioModelRenderer@@QAEXHPAUmstudioboneinfo_t@@@Z
_TEXT	SEGMENT
_bone$ = 8
_boneinfo$ = 12
_this$ = -4
_m$ = -8
?LoadLocalMatrix@CStudioModelRenderer@@QAEXHPAUmstudioboneinfo_t@@@Z PROC NEAR ; CStudioModelRenderer::LoadLocalMatrix, COMDAT

; 511  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 512  : 	mposetobone_t *m = m_pRenderModel->poseToBone;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	edx, DWORD PTR [ecx+376]
	mov	DWORD PTR _m$[ebp], edx

; 513  : 
; 514  : 	// transform Valve matrix to Xash matrix
; 515  : 	m->posetobone[bone][0][0] = boneinfo->poseToBone[0][0];

	push	0
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, eax
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _boneinfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 516  : 	m->posetobone[bone][0][1] = boneinfo->poseToBone[1][0];

	push	0
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, eax
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _boneinfo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+4], edx

; 517  : 	m->posetobone[bone][0][2] = boneinfo->poseToBone[2][0];

	push	0
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, eax
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _boneinfo$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+8], edx

; 518  : 
; 519  : 	m->posetobone[bone][1][0] = boneinfo->poseToBone[0][1];

	push	1
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, eax
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _boneinfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 520  : 	m->posetobone[bone][1][1] = boneinfo->poseToBone[1][1];

	push	1
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, eax
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _boneinfo$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+4], edx

; 521  : 	m->posetobone[bone][1][2] = boneinfo->poseToBone[2][1];

	push	1
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, eax
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _boneinfo$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+8], edx

; 522  : 
; 523  : 	m->posetobone[bone][2][0] = boneinfo->poseToBone[0][2];

	push	2
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, eax
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _boneinfo$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 524  : 	m->posetobone[bone][2][1] = boneinfo->poseToBone[1][2];

	push	2
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, eax
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _boneinfo$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+4], edx

; 525  : 	m->posetobone[bone][2][2] = boneinfo->poseToBone[2][2];

	push	2
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, eax
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _boneinfo$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+8], edx

; 526  : 
; 527  : 	m->posetobone[bone][3][0] = boneinfo->poseToBone[0][3];

	push	3
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, eax
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _boneinfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx

; 528  : 	m->posetobone[bone][3][1] = boneinfo->poseToBone[1][3];

	push	3
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, eax
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _boneinfo$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+4], edx

; 529  : 	m->posetobone[bone][3][2] = boneinfo->poseToBone[2][3];

	push	3
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, eax
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR _boneinfo$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+8], edx

; 530  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?LoadLocalMatrix@CStudioModelRenderer@@QAEXHPAUmstudioboneinfo_t@@@Z ENDP ; CStudioModelRenderer::LoadLocalMatrix
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QAEPAMH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??Amatrix3x4@@QAEPAMH@Z PROC NEAR			; matrix3x4::operator[], COMDAT

; 497  : 	float* operator[]( int i ) { return mat[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, eax
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??Amatrix3x4@@QAEPAMH@Z ENDP				; matrix3x4::operator[]
_TEXT	ENDS
PUBLIC	__real@4@4006ff00000000000000
PUBLIC	__real@4@3fff8000000000000000
;	COMDAT __real@4@4006ff00000000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@4@4006ff00000000000000 DD 0437f0000r	; 255
CONST	ENDS
;	COMDAT __real@4@3fff8000000000000000
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT ?ComputeSkinMatrix@CStudioModelRenderer@@EAEXPAUmstudioboneweight_t@@QBVmatrix3x4@@AAV3@@Z
_TEXT	SEGMENT
_boneweights$ = 8
_worldtransform$ = 12
_result$ = 16
_this$ = -4
_flWeight0$ = -8
_flWeight1$ = -12
_flWeight2$ = -16
_flWeight3$ = -20
_numbones$ = -24
_flTotal$ = -28
_i$ = -32
_boneMat0$72165 = -36
_boneMat1$72166 = -40
_boneMat2$72167 = -44
_boneMat3$72168 = -48
_boneMat0$72172 = -52
_boneMat1$72173 = -56
_boneMat2$72174 = -60
_boneMat0$72178 = -64
_boneMat1$72179 = -68
?ComputeSkinMatrix@CStudioModelRenderer@@EAEXPAUmstudioboneweight_t@@QBVmatrix3x4@@AAV3@@Z PROC NEAR ; CStudioModelRenderer::ComputeSkinMatrix, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 600				; 00000258H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	float	flWeight0, flWeight1, flWeight2, flWeight3;
; 535  : 	int	numbones = 0;

	mov	DWORD PTR _numbones$[ebp], 0

; 536  : 	float	flTotal;
; 537  : 
; 538  : 	for( int i = 0; i < MAXSTUDIOBONEWEIGHTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72160
$L72161:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L72160:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L72162

; 540  : 		if( boneweights->bone[i] != -1 )

	mov	ecx, DWORD PTR _boneweights$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, -1
	je	SHORT $L72163

; 541  : 			numbones++;

	mov	eax, DWORD PTR _numbones$[ebp]
	add	eax, 1
	mov	DWORD PTR _numbones$[ebp], eax
$L72163:

; 542  : 	}

	jmp	SHORT $L72161
$L72162:

; 543  : 
; 544  : 	if( numbones == 4 )

	cmp	DWORD PTR _numbones$[ebp], 4
	jne	$L72164

; 546  : 		const matrix3x4 &boneMat0 = worldtransform[boneweights->bone[0]];

	mov	ecx, DWORD PTR _boneweights$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _worldtransform$[ebp]
	add	eax, edx
	mov	DWORD PTR _boneMat0$72165[ebp], eax

; 547  : 		const matrix3x4 &boneMat1 = worldtransform[boneweights->bone[1]];

	mov	ecx, DWORD PTR _boneweights$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _worldtransform$[ebp]
	add	eax, edx
	mov	DWORD PTR _boneMat1$72166[ebp], eax

; 548  : 		const matrix3x4 &boneMat2 = worldtransform[boneweights->bone[2]];

	mov	ecx, DWORD PTR _boneweights$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _worldtransform$[ebp]
	add	eax, edx
	mov	DWORD PTR _boneMat2$72167[ebp], eax

; 549  : 		const matrix3x4 &boneMat3 = worldtransform[boneweights->bone[3]];

	mov	ecx, DWORD PTR _boneweights$[ebp]
	movsx	edx, BYTE PTR [ecx+7]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _worldtransform$[ebp]
	add	eax, edx
	mov	DWORD PTR _boneMat3$72168[ebp], eax

; 550  : 		flWeight0 = boneweights->weight[0] / 255.0f;

	mov	ecx, DWORD PTR _boneweights$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx]
	mov	DWORD PTR -72+[ebp], edx
	fild	DWORD PTR -72+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR _flWeight0$[ebp]

; 551  : 		flWeight1 = boneweights->weight[1] / 255.0f;

	mov	eax, DWORD PTR _boneweights$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1]
	mov	DWORD PTR -76+[ebp], ecx
	fild	DWORD PTR -76+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR _flWeight1$[ebp]

; 552  : 		flWeight2 = boneweights->weight[2] / 255.0f;

	mov	edx, DWORD PTR _boneweights$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+2]
	mov	DWORD PTR -80+[ebp], eax
	fild	DWORD PTR -80+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR _flWeight2$[ebp]

; 553  : 		flWeight3 = boneweights->weight[3] / 255.0f;

	mov	ecx, DWORD PTR _boneweights$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+3]
	mov	DWORD PTR -84+[ebp], edx
	fild	DWORD PTR -84+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR _flWeight3$[ebp]

; 554  : 		flTotal = flWeight0 + flWeight1 + flWeight2 + flWeight3;

	fld	DWORD PTR _flWeight0$[ebp]
	fadd	DWORD PTR _flWeight1$[ebp]
	fadd	DWORD PTR _flWeight2$[ebp]
	fadd	DWORD PTR _flWeight3$[ebp]
	fstp	DWORD PTR _flTotal$[ebp]

; 555  : 
; 556  : 		if( flTotal < 1.0f ) flWeight0 += 1.0f - flTotal;	// compensate rounding error

	fld	DWORD PTR _flTotal$[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72169
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _flTotal$[ebp]
	fadd	DWORD PTR _flWeight0$[ebp]
	fstp	DWORD PTR _flWeight0$[ebp]
$L72169:

; 557  : 
; 558  : 		result[0][0] = boneMat0[0][0] * flWeight0 + boneMat1[0][0] * flWeight1 + boneMat2[0][0] * flWeight2 + boneMat3[0][0] * flWeight3;

	push	0
	mov	ecx, DWORD PTR _boneMat0$72165[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -88+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat1$72166[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -88+[ebp]
	fstp	DWORD PTR -92+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat2$72167[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -92+[ebp]
	fstp	DWORD PTR -96+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat3$72168[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight3$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -96+[ebp]
	fstp	DWORD PTR -100+[ebp]
	push	0
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -100+[ebp]
	mov	DWORD PTR [eax], ecx

; 559  : 		result[0][1] = boneMat0[0][1] * flWeight0 + boneMat1[0][1] * flWeight1 + boneMat2[0][1] * flWeight2 + boneMat3[0][1] * flWeight3;

	push	0
	mov	ecx, DWORD PTR _boneMat0$72165[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -104+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat1$72166[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -104+[ebp]
	fstp	DWORD PTR -108+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat2$72167[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -108+[ebp]
	fstp	DWORD PTR -112+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat3$72168[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight3$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -112+[ebp]
	fstp	DWORD PTR -116+[ebp]
	push	0
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -116+[ebp]
	mov	DWORD PTR [eax+4], edx

; 560  : 		result[0][2] = boneMat0[0][2] * flWeight0 + boneMat1[0][2] * flWeight1 + boneMat2[0][2] * flWeight2 + boneMat3[0][2] * flWeight3;

	push	0
	mov	ecx, DWORD PTR _boneMat0$72165[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -120+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat1$72166[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -120+[ebp]
	fstp	DWORD PTR -124+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat2$72167[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -124+[ebp]
	fstp	DWORD PTR -128+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat3$72168[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight3$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -128+[ebp]
	fstp	DWORD PTR -132+[ebp]
	push	0
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -132+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 561  : 		result[1][0] = boneMat0[1][0] * flWeight0 + boneMat1[1][0] * flWeight1 + boneMat2[1][0] * flWeight2 + boneMat3[1][0] * flWeight3;

	push	1
	mov	ecx, DWORD PTR _boneMat0$72165[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -136+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat1$72166[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -136+[ebp]
	fstp	DWORD PTR -140+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat2$72167[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -140+[ebp]
	fstp	DWORD PTR -144+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat3$72168[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight3$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -144+[ebp]
	fstp	DWORD PTR -148+[ebp]
	push	1
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -148+[ebp]
	mov	DWORD PTR [eax], edx

; 562  : 		result[1][1] = boneMat0[1][1] * flWeight0 + boneMat1[1][1] * flWeight1 + boneMat2[1][1] * flWeight2 + boneMat3[1][1] * flWeight3;

	push	1
	mov	ecx, DWORD PTR _boneMat0$72165[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -152+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat1$72166[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -152+[ebp]
	fstp	DWORD PTR -156+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat2$72167[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -156+[ebp]
	fstp	DWORD PTR -160+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat3$72168[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight3$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -160+[ebp]
	fstp	DWORD PTR -164+[ebp]
	push	1
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -164+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 563  : 		result[1][2] = boneMat0[1][2] * flWeight0 + boneMat1[1][2] * flWeight1 + boneMat2[1][2] * flWeight2 + boneMat3[1][2] * flWeight3;

	push	1
	mov	ecx, DWORD PTR _boneMat0$72165[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -168+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat1$72166[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -168+[ebp]
	fstp	DWORD PTR -172+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat2$72167[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -172+[ebp]
	fstp	DWORD PTR -176+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat3$72168[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight3$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -176+[ebp]
	fstp	DWORD PTR -180+[ebp]
	push	1
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -180+[ebp]
	mov	DWORD PTR [eax+8], edx

; 564  : 		result[2][0] = boneMat0[2][0] * flWeight0 + boneMat1[2][0] * flWeight1 + boneMat2[2][0] * flWeight2 + boneMat3[2][0] * flWeight3;

	push	2
	mov	ecx, DWORD PTR _boneMat0$72165[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -184+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat1$72166[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -184+[ebp]
	fstp	DWORD PTR -188+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat2$72167[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -188+[ebp]
	fstp	DWORD PTR -192+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat3$72168[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight3$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -192+[ebp]
	fstp	DWORD PTR -196+[ebp]
	push	2
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -196+[ebp]
	mov	DWORD PTR [eax], ecx

; 565  : 		result[2][1] = boneMat0[2][1] * flWeight0 + boneMat1[2][1] * flWeight1 + boneMat2[2][1] * flWeight2 + boneMat3[2][1] * flWeight3;

	push	2
	mov	ecx, DWORD PTR _boneMat0$72165[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -200+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat1$72166[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -200+[ebp]
	fstp	DWORD PTR -204+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat2$72167[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -204+[ebp]
	fstp	DWORD PTR -208+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat3$72168[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight3$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -208+[ebp]
	fstp	DWORD PTR -212+[ebp]
	push	2
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -212+[ebp]
	mov	DWORD PTR [eax+4], edx

; 566  : 		result[2][2] = boneMat0[2][2] * flWeight0 + boneMat1[2][2] * flWeight1 + boneMat2[2][2] * flWeight2 + boneMat3[2][2] * flWeight3;

	push	2
	mov	ecx, DWORD PTR _boneMat0$72165[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -216+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat1$72166[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -216+[ebp]
	fstp	DWORD PTR -220+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat2$72167[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -220+[ebp]
	fstp	DWORD PTR -224+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat3$72168[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight3$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -224+[ebp]
	fstp	DWORD PTR -228+[ebp]
	push	2
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -228+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 567  : 		result[3][0] = boneMat0[3][0] * flWeight0 + boneMat1[3][0] * flWeight1 + boneMat2[3][0] * flWeight2 + boneMat3[3][0] * flWeight3;

	push	3
	mov	ecx, DWORD PTR _boneMat0$72165[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -232+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat1$72166[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -232+[ebp]
	fstp	DWORD PTR -236+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat2$72167[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -236+[ebp]
	fstp	DWORD PTR -240+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat3$72168[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight3$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -240+[ebp]
	fstp	DWORD PTR -244+[ebp]
	push	3
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -244+[ebp]
	mov	DWORD PTR [eax], edx

; 568  : 		result[3][1] = boneMat0[3][1] * flWeight0 + boneMat1[3][1] * flWeight1 + boneMat2[3][1] * flWeight2 + boneMat3[3][1] * flWeight3;

	push	3
	mov	ecx, DWORD PTR _boneMat0$72165[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -248+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat1$72166[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -248+[ebp]
	fstp	DWORD PTR -252+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat2$72167[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -252+[ebp]
	fstp	DWORD PTR -256+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat3$72168[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight3$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -256+[ebp]
	fstp	DWORD PTR -260+[ebp]
	push	3
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -260+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 569  : 		result[3][2] = boneMat0[3][2] * flWeight0 + boneMat1[3][2] * flWeight1 + boneMat2[3][2] * flWeight2 + boneMat3[3][2] * flWeight3;

	push	3
	mov	ecx, DWORD PTR _boneMat0$72165[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -264+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat1$72166[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -264+[ebp]
	fstp	DWORD PTR -268+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat2$72167[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -268+[ebp]
	fstp	DWORD PTR -272+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat3$72168[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight3$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -272+[ebp]
	fstp	DWORD PTR -276+[ebp]
	push	3
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -276+[ebp]
	mov	DWORD PTR [eax+8], edx

; 571  : 	else if( numbones == 3 )

	jmp	$L72181
$L72164:
	cmp	DWORD PTR _numbones$[ebp], 3
	jne	$L72171

; 573  : 		const matrix3x4 &boneMat0 = worldtransform[boneweights->bone[0]];

	mov	eax, DWORD PTR _boneweights$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _worldtransform$[ebp]
	add	edx, ecx
	mov	DWORD PTR _boneMat0$72172[ebp], edx

; 574  : 		const matrix3x4 &boneMat1 = worldtransform[boneweights->bone[1]];

	mov	eax, DWORD PTR _boneweights$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _worldtransform$[ebp]
	add	edx, ecx
	mov	DWORD PTR _boneMat1$72173[ebp], edx

; 575  : 		const matrix3x4 &boneMat2 = worldtransform[boneweights->bone[2]];

	mov	eax, DWORD PTR _boneweights$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _worldtransform$[ebp]
	add	edx, ecx
	mov	DWORD PTR _boneMat2$72174[ebp], edx

; 576  : 		flWeight0 = boneweights->weight[0] / 255.0f;

	mov	eax, DWORD PTR _boneweights$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax]
	mov	DWORD PTR -280+[ebp], ecx
	fild	DWORD PTR -280+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR _flWeight0$[ebp]

; 577  : 		flWeight1 = boneweights->weight[1] / 255.0f;

	mov	edx, DWORD PTR _boneweights$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+1]
	mov	DWORD PTR -284+[ebp], eax
	fild	DWORD PTR -284+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR _flWeight1$[ebp]

; 578  : 		flWeight2 = boneweights->weight[2] / 255.0f;

	mov	ecx, DWORD PTR _boneweights$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+2]
	mov	DWORD PTR -288+[ebp], edx
	fild	DWORD PTR -288+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR _flWeight2$[ebp]

; 579  : 		flTotal = flWeight0 + flWeight1 + flWeight2;

	fld	DWORD PTR _flWeight0$[ebp]
	fadd	DWORD PTR _flWeight1$[ebp]
	fadd	DWORD PTR _flWeight2$[ebp]
	fstp	DWORD PTR _flTotal$[ebp]

; 580  : 
; 581  : 		if( flTotal < 1.0f ) flWeight0 += 1.0f - flTotal;	// compensate rounding error

	fld	DWORD PTR _flTotal$[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72175
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _flTotal$[ebp]
	fadd	DWORD PTR _flWeight0$[ebp]
	fstp	DWORD PTR _flWeight0$[ebp]
$L72175:

; 582  : 
; 583  : 		result[0][0] = boneMat0[0][0] * flWeight0 + boneMat1[0][0] * flWeight1 + boneMat2[0][0] * flWeight2;

	push	0
	mov	ecx, DWORD PTR _boneMat0$72172[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -292+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat1$72173[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -292+[ebp]
	fstp	DWORD PTR -296+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat2$72174[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -296+[ebp]
	fstp	DWORD PTR -300+[ebp]
	push	0
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -300+[ebp]
	mov	DWORD PTR [eax], ecx

; 584  : 		result[0][1] = boneMat0[0][1] * flWeight0 + boneMat1[0][1] * flWeight1 + boneMat2[0][1] * flWeight2;

	push	0
	mov	ecx, DWORD PTR _boneMat0$72172[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -304+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat1$72173[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -304+[ebp]
	fstp	DWORD PTR -308+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat2$72174[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -308+[ebp]
	fstp	DWORD PTR -312+[ebp]
	push	0
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -312+[ebp]
	mov	DWORD PTR [eax+4], edx

; 585  : 		result[0][2] = boneMat0[0][2] * flWeight0 + boneMat1[0][2] * flWeight1 + boneMat2[0][2] * flWeight2;

	push	0
	mov	ecx, DWORD PTR _boneMat0$72172[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -316+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat1$72173[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -316+[ebp]
	fstp	DWORD PTR -320+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat2$72174[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -320+[ebp]
	fstp	DWORD PTR -324+[ebp]
	push	0
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -324+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 586  : 		result[1][0] = boneMat0[1][0] * flWeight0 + boneMat1[1][0] * flWeight1 + boneMat2[1][0] * flWeight2;

	push	1
	mov	ecx, DWORD PTR _boneMat0$72172[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -328+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat1$72173[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -328+[ebp]
	fstp	DWORD PTR -332+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat2$72174[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -332+[ebp]
	fstp	DWORD PTR -336+[ebp]
	push	1
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -336+[ebp]
	mov	DWORD PTR [eax], edx

; 587  : 		result[1][1] = boneMat0[1][1] * flWeight0 + boneMat1[1][1] * flWeight1 + boneMat2[1][1] * flWeight2;

	push	1
	mov	ecx, DWORD PTR _boneMat0$72172[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -340+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat1$72173[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -340+[ebp]
	fstp	DWORD PTR -344+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat2$72174[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -344+[ebp]
	fstp	DWORD PTR -348+[ebp]
	push	1
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -348+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 588  : 		result[1][2] = boneMat0[1][2] * flWeight0 + boneMat1[1][2] * flWeight1 + boneMat2[1][2] * flWeight2;

	push	1
	mov	ecx, DWORD PTR _boneMat0$72172[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -352+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat1$72173[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -352+[ebp]
	fstp	DWORD PTR -356+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat2$72174[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -356+[ebp]
	fstp	DWORD PTR -360+[ebp]
	push	1
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -360+[ebp]
	mov	DWORD PTR [eax+8], edx

; 589  : 		result[2][0] = boneMat0[2][0] * flWeight0 + boneMat1[2][0] * flWeight1 + boneMat2[2][0] * flWeight2;

	push	2
	mov	ecx, DWORD PTR _boneMat0$72172[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -364+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat1$72173[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -364+[ebp]
	fstp	DWORD PTR -368+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat2$72174[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -368+[ebp]
	fstp	DWORD PTR -372+[ebp]
	push	2
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -372+[ebp]
	mov	DWORD PTR [eax], ecx

; 590  : 		result[2][1] = boneMat0[2][1] * flWeight0 + boneMat1[2][1] * flWeight1 + boneMat2[2][1] * flWeight2;

	push	2
	mov	ecx, DWORD PTR _boneMat0$72172[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -376+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat1$72173[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -376+[ebp]
	fstp	DWORD PTR -380+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat2$72174[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -380+[ebp]
	fstp	DWORD PTR -384+[ebp]
	push	2
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -384+[ebp]
	mov	DWORD PTR [eax+4], edx

; 591  : 		result[2][2] = boneMat0[2][2] * flWeight0 + boneMat1[2][2] * flWeight1 + boneMat2[2][2] * flWeight2;

	push	2
	mov	ecx, DWORD PTR _boneMat0$72172[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -388+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat1$72173[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -388+[ebp]
	fstp	DWORD PTR -392+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat2$72174[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -392+[ebp]
	fstp	DWORD PTR -396+[ebp]
	push	2
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -396+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 592  : 		result[3][0] = boneMat0[3][0] * flWeight0 + boneMat1[3][0] * flWeight1 + boneMat2[3][0] * flWeight2;

	push	3
	mov	ecx, DWORD PTR _boneMat0$72172[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -400+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat1$72173[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -400+[ebp]
	fstp	DWORD PTR -404+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat2$72174[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -404+[ebp]
	fstp	DWORD PTR -408+[ebp]
	push	3
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -408+[ebp]
	mov	DWORD PTR [eax], edx

; 593  : 		result[3][1] = boneMat0[3][1] * flWeight0 + boneMat1[3][1] * flWeight1 + boneMat2[3][1] * flWeight2;

	push	3
	mov	ecx, DWORD PTR _boneMat0$72172[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -412+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat1$72173[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -412+[ebp]
	fstp	DWORD PTR -416+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat2$72174[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -416+[ebp]
	fstp	DWORD PTR -420+[ebp]
	push	3
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -420+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 594  : 		result[3][2] = boneMat0[3][2] * flWeight0 + boneMat1[3][2] * flWeight1 + boneMat2[3][2] * flWeight2;

	push	3
	mov	ecx, DWORD PTR _boneMat0$72172[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -424+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat1$72173[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -424+[ebp]
	fstp	DWORD PTR -428+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat2$72174[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight2$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -428+[ebp]
	fstp	DWORD PTR -432+[ebp]
	push	3
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -432+[ebp]
	mov	DWORD PTR [eax+8], edx

; 596  : 	else if( numbones == 2 )

	jmp	$L72181
$L72171:
	cmp	DWORD PTR _numbones$[ebp], 2
	jne	$L72177

; 598  : 		const matrix3x4 &boneMat0 = worldtransform[boneweights->bone[0]];

	mov	eax, DWORD PTR _boneweights$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _worldtransform$[ebp]
	add	edx, ecx
	mov	DWORD PTR _boneMat0$72178[ebp], edx

; 599  : 		const matrix3x4 &boneMat1 = worldtransform[boneweights->bone[1]];

	mov	eax, DWORD PTR _boneweights$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _worldtransform$[ebp]
	add	edx, ecx
	mov	DWORD PTR _boneMat1$72179[ebp], edx

; 600  : 		flWeight0 = boneweights->weight[0] / 255.0f;

	mov	eax, DWORD PTR _boneweights$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax]
	mov	DWORD PTR -436+[ebp], ecx
	fild	DWORD PTR -436+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR _flWeight0$[ebp]

; 601  : 		flWeight1 = boneweights->weight[1] / 255.0f;

	mov	edx, DWORD PTR _boneweights$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+1]
	mov	DWORD PTR -440+[ebp], eax
	fild	DWORD PTR -440+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR _flWeight1$[ebp]

; 602  : 		flTotal = flWeight0 + flWeight1;

	fld	DWORD PTR _flWeight0$[ebp]
	fadd	DWORD PTR _flWeight1$[ebp]
	fstp	DWORD PTR _flTotal$[ebp]

; 603  : 
; 604  : 		if( flTotal < 1.0f ) flWeight0 += 1.0f - flTotal;	// compensate rounding error

	fld	DWORD PTR _flTotal$[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72180
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _flTotal$[ebp]
	fadd	DWORD PTR _flWeight0$[ebp]
	fstp	DWORD PTR _flWeight0$[ebp]
$L72180:

; 605  : 
; 606  : 		// NOTE: Inlining here seems to make a fair amount of difference
; 607  : 		result[0][0] = boneMat0[0][0] * flWeight0 + boneMat1[0][0] * flWeight1;

	push	0
	mov	ecx, DWORD PTR _boneMat0$72178[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -444+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat1$72179[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -444+[ebp]
	fstp	DWORD PTR -448+[ebp]
	push	0
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -448+[ebp]
	mov	DWORD PTR [eax], ecx

; 608  : 		result[0][1] = boneMat0[0][1] * flWeight0 + boneMat1[0][1] * flWeight1;

	push	0
	mov	ecx, DWORD PTR _boneMat0$72178[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -452+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat1$72179[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -452+[ebp]
	fstp	DWORD PTR -456+[ebp]
	push	0
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -456+[ebp]
	mov	DWORD PTR [eax+4], edx

; 609  : 		result[0][2] = boneMat0[0][2] * flWeight0 + boneMat1[0][2] * flWeight1;

	push	0
	mov	ecx, DWORD PTR _boneMat0$72178[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -460+[ebp]
	push	0
	mov	ecx, DWORD PTR _boneMat1$72179[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -460+[ebp]
	fstp	DWORD PTR -464+[ebp]
	push	0
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -464+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 610  : 		result[1][0] = boneMat0[1][0] * flWeight0 + boneMat1[1][0] * flWeight1;

	push	1
	mov	ecx, DWORD PTR _boneMat0$72178[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -468+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat1$72179[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -468+[ebp]
	fstp	DWORD PTR -472+[ebp]
	push	1
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -472+[ebp]
	mov	DWORD PTR [eax], edx

; 611  : 		result[1][1] = boneMat0[1][1] * flWeight0 + boneMat1[1][1] * flWeight1;

	push	1
	mov	ecx, DWORD PTR _boneMat0$72178[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -476+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat1$72179[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -476+[ebp]
	fstp	DWORD PTR -480+[ebp]
	push	1
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -480+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 612  : 		result[1][2] = boneMat0[1][2] * flWeight0 + boneMat1[1][2] * flWeight1;

	push	1
	mov	ecx, DWORD PTR _boneMat0$72178[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -484+[ebp]
	push	1
	mov	ecx, DWORD PTR _boneMat1$72179[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -484+[ebp]
	fstp	DWORD PTR -488+[ebp]
	push	1
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -488+[ebp]
	mov	DWORD PTR [eax+8], edx

; 613  : 		result[2][0] = boneMat0[2][0] * flWeight0 + boneMat1[2][0] * flWeight1;

	push	2
	mov	ecx, DWORD PTR _boneMat0$72178[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -492+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat1$72179[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -492+[ebp]
	fstp	DWORD PTR -496+[ebp]
	push	2
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -496+[ebp]
	mov	DWORD PTR [eax], ecx

; 614  : 		result[2][1] = boneMat0[2][1] * flWeight0 + boneMat1[2][1] * flWeight1;

	push	2
	mov	ecx, DWORD PTR _boneMat0$72178[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -500+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat1$72179[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -500+[ebp]
	fstp	DWORD PTR -504+[ebp]
	push	2
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -504+[ebp]
	mov	DWORD PTR [eax+4], edx

; 615  : 		result[2][2] = boneMat0[2][2] * flWeight0 + boneMat1[2][2] * flWeight1;

	push	2
	mov	ecx, DWORD PTR _boneMat0$72178[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -508+[ebp]
	push	2
	mov	ecx, DWORD PTR _boneMat1$72179[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -508+[ebp]
	fstp	DWORD PTR -512+[ebp]
	push	2
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -512+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 616  : 		result[3][0] = boneMat0[3][0] * flWeight0 + boneMat1[3][0] * flWeight1;

	push	3
	mov	ecx, DWORD PTR _boneMat0$72178[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -516+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat1$72179[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -516+[ebp]
	fstp	DWORD PTR -520+[ebp]
	push	3
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -520+[ebp]
	mov	DWORD PTR [eax], edx

; 617  : 		result[3][1] = boneMat0[3][1] * flWeight0 + boneMat1[3][1] * flWeight1;

	push	3
	mov	ecx, DWORD PTR _boneMat0$72178[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -524+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat1$72179[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -524+[ebp]
	fstp	DWORD PTR -528+[ebp]
	push	3
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, DWORD PTR -528+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 618  : 		result[3][2] = boneMat0[3][2] * flWeight0 + boneMat1[3][2] * flWeight1;

	push	3
	mov	ecx, DWORD PTR _boneMat0$72178[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight0$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -532+[ebp]
	push	3
	mov	ecx, DWORD PTR _boneMat1$72179[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	fld	DWORD PTR _flWeight1$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -532+[ebp]
	fstp	DWORD PTR -536+[ebp]
	push	3
	mov	ecx, DWORD PTR _result$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	edx, DWORD PTR -536+[ebp]
	mov	DWORD PTR [eax+8], edx

; 620  : 	else

	jmp	SHORT $L72181
$L72177:

; 622  : 		result = worldtransform[boneweights->bone[0]];

	mov	eax, DWORD PTR _boneweights$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	imul	ecx, 48					; 00000030H
	mov	esi, DWORD PTR _worldtransform$[ebp]
	add	esi, ecx
	mov	ecx, 12					; 0000000cH
	mov	edi, DWORD PTR _result$[ebp]
	rep movsd
$L72181:

; 624  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ComputeSkinMatrix@CStudioModelRenderer@@EAEXPAUmstudioboneweight_t@@QBVmatrix3x4@@AAV3@@Z ENDP ; CStudioModelRenderer::ComputeSkinMatrix
_TEXT	ENDS
PUBLIC	?UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z ; CStudioModelRenderer::UploadBufferBase
PUBLIC	??0svert_v0_t@@QAE@XZ				; svert_v0_t::svert_v0_t
EXTRN	?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA:DWORD ; pglVertexAttribPointerARB
EXTRN	?pglEnableVertexAttribArrayARB@@3P6GXI@ZA:DWORD	; pglEnableVertexAttribArrayARB
EXTRN	?pglBindBufferARB@@3P6GXII@ZA:DWORD		; pglBindBufferARB
EXTRN	?pglBufferDataARB@@3P6GXIHPBXI@ZA:DWORD		; pglBufferDataARB
_BSS	SEGMENT
_?arraysvert@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v0_t@@A DB 0200000H DUP (?)
_?$S16@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z
_TEXT	SEGMENT
_pOut$ = 8
_arrayxvert$ = 12
_this$ = -4
_i$ = -8
?UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z PROC NEAR ; CStudioModelRenderer::UploadBufferBase, COMDAT

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 	static svert_v0_t	arraysvert[MAXARRAYVERTS];

	xor	eax, eax
	mov	al, BYTE PTR _?$S16@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L72191
	mov	cl, BYTE PTR _?$S16@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S16@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4EA, cl
	push	OFFSET FLAT:??0svert_v0_t@@QAE@XZ	; svert_v0_t::svert_v0_t
	push	65536					; 00010000H
	push	32					; 00000020H
	push	OFFSET FLAT:_?arraysvert@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v0_t@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E17
	call	_atexit
	add	esp, 4
$L72191:

; 629  : 
; 630  : 	// convert to GLSL-compacted array
; 631  : 	for( int i = 0; i <m_nNumArrayVerts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72195
$L72196:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L72195:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+5344988]
	jge	$L72197

; 633  : 		arraysvert[i].vertex = arrayxvert[i].vertex;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	add	eax, edx
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, OFFSET FLAT:_?arraysvert@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v0_t@@A
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 634  : 		arraysvert[i].normal = arrayxvert[i].normal;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	lea	eax, DWORD PTR [edx+ecx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, OFFSET FLAT:_?arraysvert@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v0_t@@A+12
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 635  : 		arraysvert[i].stcoord[0] = arrayxvert[i].stcoord[0];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	mov	cx, WORD PTR [eax+ecx+24]
	mov	WORD PTR _?arraysvert@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v0_t@@A[edx+24], cx

; 636  : 		arraysvert[i].stcoord[1] = arrayxvert[i].stcoord[1];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _arrayxvert$[ebp]
	mov	dx, WORD PTR [ecx+edx+26]
	mov	WORD PTR _?arraysvert@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v0_t@@A[eax+26], dx

; 637  : 		arraysvert[i].boneid[0] = arrayxvert[i].boneid[0];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	mov	al, BYTE PTR [edx+eax+28]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v0_t@@A[ecx+28], al

; 638  : 		arraysvert[i].boneid[1] = arrayxvert[i].boneid[1];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	mov	cl, BYTE PTR [eax+ecx+29]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v0_t@@A[edx+29], cl

; 639  : 		arraysvert[i].boneid[2] = arrayxvert[i].boneid[2];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _arrayxvert$[ebp]
	mov	dl, BYTE PTR [ecx+edx+30]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v0_t@@A[eax+30], dl

; 640  : 		arraysvert[i].boneid[3] = arrayxvert[i].boneid[3];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	mov	al, BYTE PTR [edx+eax+31]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v0_t@@A[ecx+31], al

; 641  : 	}

	jmp	$L72196
$L72197:

; 642  : 
; 643  : 	pglBindBufferARB( GL_ARRAY_BUFFER_ARB, pOut->vbo );

	mov	ecx, DWORD PTR _pOut$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	34962					; 00008892H
	call	DWORD PTR ?pglBindBufferARB@@3P6GXII@ZA	; pglBindBufferARB

; 644  : 	pglBufferDataARB( GL_ARRAY_BUFFER_ARB, m_nNumArrayVerts * sizeof( svert_v0_t ), &arraysvert[0], GL_STATIC_DRAW_ARB );

	push	35044					; 000088e4H
	push	OFFSET FLAT:_?arraysvert@?1??UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v0_t@@A
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	shl	ecx, 5
	push	ecx
	push	34962					; 00008892H
	call	DWORD PTR ?pglBufferDataARB@@3P6GXIHPBXI@ZA ; pglBufferDataARB

; 645  : 
; 646  : 	pglVertexAttribPointerARB( ATTR_INDEX_POSITION, 3, GL_FLOAT, GL_FALSE, sizeof( svert_v0_t ), (void *)offsetof( svert_v0_t, vertex ));

	push	0
	push	32					; 00000020H
	push	0
	push	5126					; 00001406H
	push	3
	push	0
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 647  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_POSITION );

	push	0
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 648  : 
; 649  : 	pglVertexAttribPointerARB( ATTR_INDEX_TEXCOORD0, 2, GL_HALF_FLOAT_ARB, GL_FALSE, sizeof( svert_v0_t ), (void *)offsetof( svert_v0_t, stcoord ));

	push	24					; 00000018H
	push	32					; 00000020H
	push	0
	push	5131					; 0000140bH
	push	2
	push	2
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 650  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_TEXCOORD0 );

	push	2
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 651  : 
; 652  : 	pglVertexAttribPointerARB( ATTR_INDEX_NORMAL, 3, GL_FLOAT, GL_FALSE, sizeof( svert_v0_t ), (void *)offsetof( svert_v0_t, normal ));

	push	12					; 0000000cH
	push	32					; 00000020H
	push	0
	push	5126					; 00001406H
	push	3
	push	1
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 653  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_NORMAL );

	push	1
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 654  : 
; 655  : 	pglVertexAttribPointerARB( ATTR_INDEX_BONE_INDEXES, 4, GL_BYTE, GL_FALSE, sizeof( svert_v0_t ), (void *)offsetof( svert_v0_t, boneid )); 

	push	28					; 0000001cH
	push	32					; 00000020H
	push	0
	push	5120					; 00001400H
	push	4
	push	5
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 656  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_BONE_INDEXES );

	push	5
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 657  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z ENDP ; CStudioModelRenderer::UploadBufferBase
_TEXT	ENDS
;	COMDAT _$E17
_TEXT	SEGMENT
_$E17	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E17	ENDP
_TEXT	ENDS
;	COMDAT ??0svert_v0_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0svert_v0_t@@QAE@XZ PROC NEAR				; svert_v0_t::svert_v0_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0svert_v0_t@@QAE@XZ ENDP				; svert_v0_t::svert_v0_t
_TEXT	ENDS
PUBLIC	??0svert_v1_t@@QAE@XZ				; svert_v1_t::svert_v1_t
PUBLIC	?UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z ; CStudioModelRenderer::UploadBufferVLight
_BSS	SEGMENT
	ALIGN	4

_?arraysvert@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v1_t@@A DB 02c0000H DUP (?)
_?$S18@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z
_TEXT	SEGMENT
_pOut$ = 8
_arrayxvert$ = 12
_this$ = -4
_i$ = -8
?UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z PROC NEAR ; CStudioModelRenderer::UploadBufferVLight, COMDAT

; 660  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 	static svert_v1_t	arraysvert[MAXARRAYVERTS];

	xor	eax, eax
	mov	al, BYTE PTR _?$S18@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L72227
	mov	cl, BYTE PTR _?$S18@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S18@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4EA, cl
	push	OFFSET FLAT:??0svert_v1_t@@QAE@XZ	; svert_v1_t::svert_v1_t
	push	65536					; 00010000H
	push	44					; 0000002cH
	push	OFFSET FLAT:_?arraysvert@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v1_t@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E19
	call	_atexit
	add	esp, 4
$L72227:

; 662  : 
; 663  : 	// convert to GLSL-compacted array
; 664  : 	for( int i = 0; i < m_nNumArrayVerts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72231
$L72232:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L72231:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+5344988]
	jge	$L72233

; 666  : 		arraysvert[i].vertex = arrayxvert[i].vertex;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	add	eax, edx
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 44					; 0000002cH
	add	ecx, OFFSET FLAT:_?arraysvert@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v1_t@@A
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 667  : 		arraysvert[i].normal = arrayxvert[i].normal;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	lea	eax, DWORD PTR [edx+ecx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 44					; 0000002cH
	add	ecx, OFFSET FLAT:_?arraysvert@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v1_t@@A+12
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 668  : 		arraysvert[i].stcoord[0] = arrayxvert[i].stcoord[0];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	mov	cx, WORD PTR [eax+ecx+24]
	mov	WORD PTR _?arraysvert@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v1_t@@A[edx+24], cx

; 669  : 		arraysvert[i].stcoord[1] = arrayxvert[i].stcoord[1];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _arrayxvert$[ebp]
	mov	dx, WORD PTR [ecx+edx+26]
	mov	WORD PTR _?arraysvert@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v1_t@@A[eax+26], dx

; 670  : 		arraysvert[i].light[0] = arrayxvert[i].light[0];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _?arraysvert@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v1_t@@A[ecx+28], eax

; 671  : 		arraysvert[i].light[1] = arrayxvert[i].light[1];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+40]
	mov	DWORD PTR _?arraysvert@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v1_t@@A[edx+32], ecx

; 672  : 		arraysvert[i].light[2] = arrayxvert[i].light[2];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _arrayxvert$[ebp]
	mov	edx, DWORD PTR [ecx+edx+44]
	mov	DWORD PTR _?arraysvert@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v1_t@@A[eax+36], edx

; 673  : 		arraysvert[i].light[3] = arrayxvert[i].light[3];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	mov	eax, DWORD PTR [edx+eax+48]
	mov	DWORD PTR _?arraysvert@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v1_t@@A[ecx+40], eax

; 674  : 	}

	jmp	$L72232
$L72233:

; 675  : 
; 676  : 	pglBindBufferARB( GL_ARRAY_BUFFER_ARB, pOut->vbo );

	mov	ecx, DWORD PTR _pOut$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	34962					; 00008892H
	call	DWORD PTR ?pglBindBufferARB@@3P6GXII@ZA	; pglBindBufferARB

; 677  : 	pglBufferDataARB( GL_ARRAY_BUFFER_ARB, m_nNumArrayVerts * sizeof( svert_v1_t ), &arraysvert[0], GL_STATIC_DRAW_ARB );

	push	35044					; 000088e4H
	push	OFFSET FLAT:_?arraysvert@?1??UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v1_t@@A
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	imul	ecx, 44					; 0000002cH
	push	ecx
	push	34962					; 00008892H
	call	DWORD PTR ?pglBufferDataARB@@3P6GXIHPBXI@ZA ; pglBufferDataARB

; 678  : 
; 679  : 	pglVertexAttribPointerARB( ATTR_INDEX_POSITION, 3, GL_FLOAT, GL_FALSE, sizeof( svert_v1_t ), (void *)offsetof( svert_v1_t, vertex ));

	push	0
	push	44					; 0000002cH
	push	0
	push	5126					; 00001406H
	push	3
	push	0
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 680  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_POSITION );

	push	0
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 681  : 
; 682  : 	pglVertexAttribPointerARB( ATTR_INDEX_TEXCOORD0, 2, GL_HALF_FLOAT_ARB, GL_FALSE, sizeof( svert_v1_t ), (void *)offsetof( svert_v1_t, stcoord ));

	push	24					; 00000018H
	push	44					; 0000002cH
	push	0
	push	5131					; 0000140bH
	push	2
	push	2
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 683  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_TEXCOORD0 );

	push	2
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 684  : 
; 685  : 	pglVertexAttribPointerARB( ATTR_INDEX_NORMAL, 3, GL_FLOAT, GL_FALSE, sizeof( svert_v1_t ), (void *)offsetof( svert_v1_t, normal ));

	push	12					; 0000000cH
	push	44					; 0000002cH
	push	0
	push	5126					; 00001406H
	push	3
	push	1
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 686  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_NORMAL );

	push	1
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 687  : 
; 688  : 	pglVertexAttribPointerARB( ATTR_INDEX_LIGHT_COLOR, 4, GL_FLOAT, GL_FALSE, sizeof( svert_v1_t ), (void *)offsetof( svert_v1_t, light )); 

	push	28					; 0000001cH
	push	44					; 0000002cH
	push	0
	push	5126					; 00001406H
	push	4
	push	8
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 689  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_LIGHT_COLOR );

	push	8
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 690  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z ENDP ; CStudioModelRenderer::UploadBufferVLight
_TEXT	ENDS
;	COMDAT _$E19
_TEXT	SEGMENT
_$E19	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E19	ENDP
_TEXT	ENDS
;	COMDAT ??0svert_v1_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0svert_v1_t@@QAE@XZ PROC NEAR				; svert_v1_t::svert_v1_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0svert_v1_t@@QAE@XZ ENDP				; svert_v1_t::svert_v1_t
_TEXT	ENDS
PUBLIC	??0svert_v2_t@@QAE@XZ				; svert_v2_t::svert_v2_t
PUBLIC	?UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z ; CStudioModelRenderer::UploadBufferWeight
_BSS	SEGMENT
	ALIGN	4

_?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A DB 0240000H DUP (?)
_?$S20@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z
_TEXT	SEGMENT
_pOut$ = 8
_arrayxvert$ = 12
_this$ = -4
_i$ = -8
?UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z PROC NEAR ; CStudioModelRenderer::UploadBufferWeight, COMDAT

; 693  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 694  : 	static svert_v2_t	arraysvert[MAXARRAYVERTS];

	xor	eax, eax
	mov	al, BYTE PTR _?$S20@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L72263
	mov	cl, BYTE PTR _?$S20@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S20@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4EA, cl
	push	OFFSET FLAT:??0svert_v2_t@@QAE@XZ	; svert_v2_t::svert_v2_t
	push	65536					; 00010000H
	push	36					; 00000024H
	push	OFFSET FLAT:_?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E21
	call	_atexit
	add	esp, 4
$L72263:

; 695  : 
; 696  : 	// convert to GLSL-compacted array
; 697  : 	for( int i = 0; i < m_nNumArrayVerts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72267
$L72268:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L72267:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+5344988]
	jge	$L72269

; 699  : 		arraysvert[i].vertex = arrayxvert[i].vertex;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	add	eax, edx
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	add	ecx, OFFSET FLAT:_?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 700  : 		arraysvert[i].normal = arrayxvert[i].normal;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	lea	eax, DWORD PTR [edx+ecx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	add	ecx, OFFSET FLAT:_?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A+12
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 701  : 		arraysvert[i].stcoord[0] = arrayxvert[i].stcoord[0];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	mov	cx, WORD PTR [eax+ecx+24]
	mov	WORD PTR _?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A[edx+24], cx

; 702  : 		arraysvert[i].stcoord[1] = arrayxvert[i].stcoord[1];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _arrayxvert$[ebp]
	mov	dx, WORD PTR [ecx+edx+26]
	mov	WORD PTR _?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A[eax+26], dx

; 703  : 		arraysvert[i].boneid[0] = arrayxvert[i].boneid[0];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	mov	al, BYTE PTR [edx+eax+28]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A[ecx+28], al

; 704  : 		arraysvert[i].boneid[1] = arrayxvert[i].boneid[1];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	mov	cl, BYTE PTR [eax+ecx+29]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A[edx+29], cl

; 705  : 		arraysvert[i].boneid[2] = arrayxvert[i].boneid[2];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _arrayxvert$[ebp]
	mov	dl, BYTE PTR [ecx+edx+30]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A[eax+30], dl

; 706  : 		arraysvert[i].boneid[3] = arrayxvert[i].boneid[3];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	mov	al, BYTE PTR [edx+eax+31]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A[ecx+31], al

; 707  : 		arraysvert[i].weight[0] = arrayxvert[i].weight[0];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	mov	cl, BYTE PTR [eax+ecx+32]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A[edx+32], cl

; 708  : 		arraysvert[i].weight[1] = arrayxvert[i].weight[1];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _arrayxvert$[ebp]
	mov	dl, BYTE PTR [ecx+edx+33]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A[eax+33], dl

; 709  : 		arraysvert[i].weight[2] = arrayxvert[i].weight[2];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	mov	al, BYTE PTR [edx+eax+34]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A[ecx+34], al

; 710  : 		arraysvert[i].weight[3] = arrayxvert[i].weight[3];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	mov	cl, BYTE PTR [eax+ecx+35]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A[edx+35], cl

; 711  : 	}

	jmp	$L72268
$L72269:

; 712  : 
; 713  : 	pglBindBufferARB( GL_ARRAY_BUFFER_ARB, pOut->vbo );

	mov	edx, DWORD PTR _pOut$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR ?pglBindBufferARB@@3P6GXII@ZA	; pglBindBufferARB

; 714  : 	pglBufferDataARB( GL_ARRAY_BUFFER_ARB, m_nNumArrayVerts * sizeof( svert_v2_t ), &arraysvert[0], GL_STATIC_DRAW_ARB );

	push	35044					; 000088e4H
	push	OFFSET FLAT:_?arraysvert@?1??UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z@4PAUsvert_v2_t@@A
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	imul	edx, 36					; 00000024H
	push	edx
	push	34962					; 00008892H
	call	DWORD PTR ?pglBufferDataARB@@3P6GXIHPBXI@ZA ; pglBufferDataARB

; 715  : 
; 716  : 	pglVertexAttribPointerARB( ATTR_INDEX_POSITION, 3, GL_FLOAT, GL_FALSE, sizeof( svert_v2_t ), (void *)offsetof( svert_v2_t, vertex ));

	push	0
	push	36					; 00000024H
	push	0
	push	5126					; 00001406H
	push	3
	push	0
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 717  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_POSITION );

	push	0
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 718  : 
; 719  : 	pglVertexAttribPointerARB( ATTR_INDEX_TEXCOORD0, 2, GL_HALF_FLOAT_ARB, GL_FALSE, sizeof( svert_v2_t ), (void *)offsetof( svert_v2_t, stcoord ));

	push	24					; 00000018H
	push	36					; 00000024H
	push	0
	push	5131					; 0000140bH
	push	2
	push	2
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 720  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_TEXCOORD0 );

	push	2
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 721  : 
; 722  : 	pglVertexAttribPointerARB( ATTR_INDEX_NORMAL, 3, GL_FLOAT, GL_FALSE, sizeof( svert_v2_t ), (void *)offsetof( svert_v2_t, normal ));

	push	12					; 0000000cH
	push	36					; 00000024H
	push	0
	push	5126					; 00001406H
	push	3
	push	1
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 723  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_NORMAL );

	push	1
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 724  : 
; 725  : 	pglVertexAttribPointerARB( ATTR_INDEX_BONE_INDEXES, 4, GL_BYTE, GL_FALSE, sizeof( svert_v2_t ), (void *)offsetof( svert_v2_t, boneid )); 

	push	28					; 0000001cH
	push	36					; 00000024H
	push	0
	push	5120					; 00001400H
	push	4
	push	5
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 726  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_BONE_INDEXES );

	push	5
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 727  : 
; 728  : 	pglVertexAttribPointerARB( ATTR_INDEX_BONE_WEIGHTS, 4, GL_UNSIGNED_BYTE, GL_FALSE, sizeof( svert_v2_t ), (void *)offsetof( svert_v2_t, weight )); 

	push	32					; 00000020H
	push	36					; 00000024H
	push	0
	push	5121					; 00001401H
	push	4
	push	6
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 729  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_BONE_WEIGHTS );

	push	6
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 730  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z ENDP ; CStudioModelRenderer::UploadBufferWeight
_TEXT	ENDS
;	COMDAT _$E21
_TEXT	SEGMENT
_$E21	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E21	ENDP
_TEXT	ENDS
;	COMDAT ??0svert_v2_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0svert_v2_t@@QAE@XZ PROC NEAR				; svert_v2_t::svert_v2_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0svert_v2_t@@QAE@XZ ENDP				; svert_v2_t::svert_v2_t
_TEXT	ENDS
PUBLIC	??0svert_v3_t@@QAE@XZ				; svert_v3_t::svert_v3_t
PUBLIC	?UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z ; CStudioModelRenderer::UploadBufferGeneric
EXTRN	?FloatToHalf@@YAGM@Z:NEAR			; FloatToHalf
_BSS	SEGMENT
	ALIGN	4

_?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A DB 0340000H DUP (?)
_?$S22@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z
_TEXT	SEGMENT
_pOut$ = 8
_arrayxvert$ = 12
_vertex_light$ = 16
_this$ = -4
_i$ = -8
?UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z PROC NEAR ; CStudioModelRenderer::UploadBufferGeneric, COMDAT

; 733  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 734  : 	static svert_v3_t	arraysvert[MAXARRAYVERTS];

	xor	eax, eax
	mov	al, BYTE PTR _?$S22@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L72304
	mov	cl, BYTE PTR _?$S22@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S22@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4EA, cl
	push	OFFSET FLAT:??0svert_v3_t@@QAE@XZ	; svert_v3_t::svert_v3_t
	push	65536					; 00010000H
	push	52					; 00000034H
	push	OFFSET FLAT:_?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E23
	call	_atexit
	add	esp, 4
$L72304:

; 735  : 
; 736  : 	// convert to GLSL-compacted array
; 737  : 	for( int i = 0; i < m_nNumArrayVerts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72308
$L72309:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L72308:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+5344988]
	jge	$L72310

; 739  : 		arraysvert[i].vertex = arrayxvert[i].vertex;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	add	eax, edx
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	add	ecx, OFFSET FLAT:_?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 740  : 		arraysvert[i].normal[0] = FloatToHalf( arrayxvert[i].normal[0] );

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+12]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?FloatToHalf@@YAGM@Z			; FloatToHalf
	add	esp, 4
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR -12+[ebp], eax
	fild	DWORD PTR -12+[ebp]
	fstp	DWORD PTR -16+[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	add	ecx, OFFSET FLAT:_?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A+12
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -16+[ebp]
	mov	DWORD PTR [eax], ecx

; 741  : 		arraysvert[i].normal[1] = FloatToHalf( arrayxvert[i].normal[1] );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	lea	ecx, DWORD PTR [eax+edx+12]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FloatToHalf@@YAGM@Z			; FloatToHalf
	add	esp, 4
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR -20+[ebp], eax
	fild	DWORD PTR -20+[ebp]
	fstp	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	add	ecx, OFFSET FLAT:_?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A+12
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -24+[ebp]
	mov	DWORD PTR [eax+4], edx

; 742  : 		arraysvert[i].normal[2] = FloatToHalf( arrayxvert[i].normal[2] );

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _arrayxvert$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+12]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax+8]
	push	edx
	call	?FloatToHalf@@YAGM@Z			; FloatToHalf
	add	esp, 4
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR -28+[ebp], eax
	fild	DWORD PTR -28+[ebp]
	fstp	DWORD PTR -32+[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	add	ecx, OFFSET FLAT:_?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A+12
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -32+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 743  : 		arraysvert[i].stcoord[0] = arrayxvert[i].stcoord[0];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _arrayxvert$[ebp]
	mov	dx, WORD PTR [ecx+edx+24]
	mov	WORD PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[eax+24], dx

; 744  : 		arraysvert[i].stcoord[1] = arrayxvert[i].stcoord[1];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	mov	ax, WORD PTR [edx+eax+26]
	mov	WORD PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[ecx+26], ax

; 745  : 		arraysvert[i].boneid[0] = arrayxvert[i].boneid[0];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	mov	cl, BYTE PTR [eax+ecx+28]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[edx+28], cl

; 746  : 		arraysvert[i].boneid[1] = arrayxvert[i].boneid[1];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _arrayxvert$[ebp]
	mov	dl, BYTE PTR [ecx+edx+29]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[eax+29], dl

; 747  : 		arraysvert[i].boneid[2] = arrayxvert[i].boneid[2];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	mov	al, BYTE PTR [edx+eax+30]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[ecx+30], al

; 748  : 		arraysvert[i].boneid[3] = arrayxvert[i].boneid[3];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	mov	cl, BYTE PTR [eax+ecx+31]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[edx+31], cl

; 749  : 		arraysvert[i].weight[0] = arrayxvert[i].weight[0];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _arrayxvert$[ebp]
	mov	dl, BYTE PTR [ecx+edx+32]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[eax+32], dl

; 750  : 		arraysvert[i].weight[1] = arrayxvert[i].weight[1];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	mov	al, BYTE PTR [edx+eax+33]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[ecx+33], al

; 751  : 		arraysvert[i].weight[2] = arrayxvert[i].weight[2];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	mov	cl, BYTE PTR [eax+ecx+34]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[edx+34], cl

; 752  : 		arraysvert[i].weight[3] = arrayxvert[i].weight[3];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _arrayxvert$[ebp]
	mov	dl, BYTE PTR [ecx+edx+35]
	mov	BYTE PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[eax+35], dl

; 753  : 		arraysvert[i].light[0] = arrayxvert[i].light[0];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[ecx+36], eax

; 754  : 		arraysvert[i].light[1] = arrayxvert[i].light[1];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _arrayxvert$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+40]
	mov	DWORD PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[edx+40], ecx

; 755  : 		arraysvert[i].light[2] = arrayxvert[i].light[2];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _arrayxvert$[ebp]
	mov	edx, DWORD PTR [ecx+edx+44]
	mov	DWORD PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[eax+44], edx

; 756  : 		arraysvert[i].light[3] = arrayxvert[i].light[3];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _arrayxvert$[ebp]
	mov	eax, DWORD PTR [edx+eax+48]
	mov	DWORD PTR _?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A[ecx+48], eax

; 757  : 	}

	jmp	$L72309
$L72310:

; 758  : 
; 759  : 	pglBindBufferARB( GL_ARRAY_BUFFER_ARB, pOut->vbo );

	mov	ecx, DWORD PTR _pOut$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	34962					; 00008892H
	call	DWORD PTR ?pglBindBufferARB@@3P6GXII@ZA	; pglBindBufferARB

; 760  : 	pglBufferDataARB( GL_ARRAY_BUFFER_ARB, m_nNumArrayVerts * sizeof( svert_v3_t ), &arraysvert[0], GL_STATIC_DRAW_ARB );

	push	35044					; 000088e4H
	push	OFFSET FLAT:_?arraysvert@?1??UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z@4PAUsvert_v3_t@@A
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	imul	ecx, 52					; 00000034H
	push	ecx
	push	34962					; 00008892H
	call	DWORD PTR ?pglBufferDataARB@@3P6GXIHPBXI@ZA ; pglBufferDataARB

; 761  : 
; 762  : 	pglVertexAttribPointerARB( ATTR_INDEX_POSITION, 3, GL_FLOAT, GL_FALSE, sizeof( svert_v3_t ), (void *)offsetof( svert_v3_t, vertex ));

	push	0
	push	52					; 00000034H
	push	0
	push	5126					; 00001406H
	push	3
	push	0
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 763  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_POSITION );

	push	0
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 764  : 
; 765  : 	pglVertexAttribPointerARB( ATTR_INDEX_TEXCOORD0, 2, GL_HALF_FLOAT_ARB, GL_FALSE, sizeof( svert_v3_t ), (void *)offsetof( svert_v3_t, stcoord ));

	push	24					; 00000018H
	push	52					; 00000034H
	push	0
	push	5131					; 0000140bH
	push	2
	push	2
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 766  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_TEXCOORD0 );

	push	2
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 767  : 
; 768  : 	pglVertexAttribPointerARB( ATTR_INDEX_NORMAL, 3, GL_FLOAT, GL_FALSE, sizeof( svert_v3_t ), (void *)offsetof( svert_v3_t, normal ));

	push	12					; 0000000cH
	push	52					; 00000034H
	push	0
	push	5126					; 00001406H
	push	3
	push	1
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 769  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_NORMAL );

	push	1
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 770  : 
; 771  : 	pglVertexAttribPointerARB( ATTR_INDEX_BONE_INDEXES, 4, GL_BYTE, GL_FALSE, sizeof( svert_v3_t ), (void *)offsetof( svert_v3_t, boneid )); 

	push	28					; 0000001cH
	push	52					; 00000034H
	push	0
	push	5120					; 00001400H
	push	4
	push	5
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 772  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_BONE_INDEXES );

	push	5
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 773  : 
; 774  : 	pglVertexAttribPointerARB( ATTR_INDEX_BONE_WEIGHTS, 4, GL_UNSIGNED_BYTE, GL_FALSE, sizeof( svert_v3_t ), (void *)offsetof( svert_v3_t, weight )); 

	push	32					; 00000020H
	push	52					; 00000034H
	push	0
	push	5121					; 00001401H
	push	4
	push	6
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 775  : 	pglEnableVertexAttribArrayARB( ATTR_INDEX_BONE_WEIGHTS );

	push	6
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB

; 776  : 
; 777  : 	if( vertex_light )

	mov	edx, DWORD PTR _vertex_light$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72332

; 779  : 		pglVertexAttribPointerARB( ATTR_INDEX_LIGHT_COLOR, 4, GL_FLOAT, GL_FALSE, sizeof( svert_v3_t ), (void *)offsetof( svert_v3_t, light )); 

	push	36					; 00000024H
	push	52					; 00000034H
	push	0
	push	5126					; 00001406H
	push	4
	push	8
	call	DWORD PTR ?pglVertexAttribPointerARB@@3P6GXIHIEHPBX@ZA ; pglVertexAttribPointerARB

; 780  : 		pglEnableVertexAttribArrayARB( ATTR_INDEX_LIGHT_COLOR );

	push	8
	call	DWORD PTR ?pglEnableVertexAttribArrayARB@@3P6GXI@ZA ; pglEnableVertexAttribArrayARB
$L72332:

; 782  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z ENDP ; CStudioModelRenderer::UploadBufferGeneric
_TEXT	ENDS
;	COMDAT _$E23
_TEXT	SEGMENT
_$E23	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E23	ENDP
_TEXT	ENDS
;	COMDAT ??0svert_v3_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0svert_v3_t@@QAE@XZ PROC NEAR				; svert_v3_t::svert_v3_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0svert_v3_t@@QAE@XZ ENDP				; svert_v3_t::svert_v3_t
_TEXT	ENDS
PUBLIC	?MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z ; CStudioModelRenderer::MeshCreateBuffer
PUBLIC	__real@8@40178000000000000000
PUBLIC	??_C@_0BP@HEGK@?$CFs?5static?5model?5have?5skeleton?6?$AA@ ; `string'
PUBLIC	??0xvert_s@@QAE@XZ				; xvert_s::xvert_s
EXTRN	?pglGenBuffersARB@@3P6GXHPAI@ZA:DWORD		; pglGenBuffersARB
EXTRN	?pglBindVertexArray@@3P6GXI@ZA:DWORD		; pglBindVertexArray
EXTRN	?pglGenVertexArrays@@3P6GXHPBI@ZA:DWORD		; pglGenVertexArrays
_BSS	SEGMENT
	ALIGN	4

_?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A DB 0340000H DUP (?)
_?$S24@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BP@HEGK@?$CFs?5static?5model?5have?5skeleton?6?$AA@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_C@_0BP@HEGK@?$CFs?5static?5model?5have?5skeleton?6?$AA@ DB '%s static '
	DB	'model have skeleton', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@8@40178000000000000000
CONST	SEGMENT
__real@8@40178000000000000000 DQ 04170000000000000r ; 1.67772e+007
CONST	ENDS
;	COMDAT ?MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z
_TEXT	SEGMENT
_pOut$ = 8
_pMesh$ = 12
_pSubModel$ = 16
_dml$ = 24
_this$ = -4
_pskinref$ = -8
_ptexture$ = -12
_pmaterial$ = -16
_pbones$ = -20
_ptricmds$ = -24
_pstudioverts$ = -28
_pstudionorms$ = -32
_pvertbone$ = -36
_pnormbone$ = -40
_pvertweight$ = -44
_pnormweight$ = -48
_has_boneweights$ = -52
_has_vertexlight$ = -56
_skinMat$ = -104
_i$ = -108
_s$ = -112
_t$ = -116
_strip$72396 = -120
_vertexState$72397 = -124
_vl$72409 = -128
_map$72410 = -132
_r$72414 = -136
_g$72415 = -140
_b$72416 = -144
_packDirect$72417 = -148
_pCurWeight$72426 = -152
?MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z PROC NEAR ; CStudioModelRenderer::MeshCreateBuffer, COMDAT

; 785  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 786  : 	// FIXME: if various skinfamilies has different sizes then our texcoords probably will be invalid for pev->skin != 0
; 787  : 	short		*pskinref = (short *)((byte *)m_pStudioHeader + m_pStudioHeader->skinindex); // setup skinref for skin == 0

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+200]
	mov	DWORD PTR _pskinref$[ebp], eax

; 788  : 	mstudiotexture_t	*ptexture = (mstudiotexture_t *)((byte *)m_pStudioHeader + m_pStudioHeader->textureindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+184]
	mov	DWORD PTR _ptexture$[ebp], ecx

; 789  : 	mstudiomaterial_t	*pmaterial = (mstudiomaterial_t *)m_pRenderModel->materials;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	mov	ecx, DWORD PTR [eax+384]
	mov	DWORD PTR _pmaterial$[ebp], ecx

; 790  : 	ptexture = &ptexture[pskinref[pMesh->skinref]];

	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _pskinref$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	imul	edx, 80					; 00000050H
	mov	eax, DWORD PTR _ptexture$[ebp]
	add	eax, edx
	mov	DWORD PTR _ptexture$[ebp], eax

; 791  : 	pmaterial = &pmaterial[pskinref[pMesh->skinref]];

	mov	ecx, DWORD PTR _pMesh$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _pskinref$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _pmaterial$[ebp]
	add	edx, ecx
	mov	DWORD PTR _pmaterial$[ebp], edx

; 792  : 
; 793  : 	mstudiobone_t	*pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+144]
	mov	DWORD PTR _pbones$[ebp], eax

; 794  : 	short		*ptricmds = (short *)((byte *)m_pStudioHeader + pMesh->triindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _pMesh$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _ptricmds$[ebp], edx

; 795  : 	Vector		*pstudioverts = (Vector *)((byte *)m_pStudioHeader + pSubModel->vertindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _pSubModel$[ebp]
	add	edx, DWORD PTR [eax+88]
	mov	DWORD PTR _pstudioverts$[ebp], edx

; 796  : 	Vector		*pstudionorms = (Vector *)((byte *)m_pStudioHeader + pSubModel->normindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _pSubModel$[ebp]
	add	edx, DWORD PTR [eax+100]
	mov	DWORD PTR _pstudionorms$[ebp], edx

; 797  : 	byte		*pvertbone = ((byte *)m_pStudioHeader + pSubModel->vertinfoindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _pSubModel$[ebp]
	add	edx, DWORD PTR [eax+84]
	mov	DWORD PTR _pvertbone$[ebp], edx

; 798  : 	byte		*pnormbone = ((byte *)m_pStudioHeader + pSubModel->norminfoindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _pSubModel$[ebp]
	add	edx, DWORD PTR [eax+96]
	mov	DWORD PTR _pnormbone$[ebp], edx

; 799  : 
; 800  : 	// if weights was missed their offsets just equal to 0
; 801  : 	mstudioboneweight_t	*pvertweight = (mstudioboneweight_t *)((byte *)m_pStudioHeader + pSubModel->blendvertinfoindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _pSubModel$[ebp]
	add	edx, DWORD PTR [eax+104]
	mov	DWORD PTR _pvertweight$[ebp], edx

; 802  : 	mstudioboneweight_t	*pnormweight = (mstudioboneweight_t *)((byte *)m_pStudioHeader + pSubModel->blendnorminfoindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _pSubModel$[ebp]
	add	edx, DWORD PTR [eax+108]
	mov	DWORD PTR _pnormweight$[ebp], edx

; 803  : 	bool 		has_boneweights = ( m_pRenderModel->poseToBone != NULL ) ? true : false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	cmp	DWORD PTR [edx+376], 0
	setne	al
	mov	BYTE PTR _has_boneweights$[ebp], al

; 804  : 	bool		has_vertexlight = ( dml != NULL && dml->numverts > 0 ) ? true : false;

	cmp	DWORD PTR _dml$[ebp], 0
	je	SHORT $L76057
	mov	ecx, DWORD PTR _dml$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jle	SHORT $L76057
	mov	BYTE PTR -153+[ebp], 1
	jmp	SHORT $L76058
$L76057:
	mov	BYTE PTR -153+[ebp], 0
$L76058:
	mov	dl, BYTE PTR -153+[ebp]
	mov	BYTE PTR _has_vertexlight$[ebp], dl

; 805  : 	static svert_t	arrayxvert[MAXARRAYVERTS];

	xor	eax, eax
	mov	al, BYTE PTR _?$S24@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L72384
	mov	cl, BYTE PTR _?$S24@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S24@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4EA, cl
	push	OFFSET FLAT:??0xvert_s@@QAE@XZ		; xvert_s::xvert_s
	push	65536					; 00010000H
	push	52					; 00000034H
	push	OFFSET FLAT:_?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E25
	call	_atexit
	add	esp, 4
$L72384:

; 806  : 	matrix3x4		skinMat;

	lea	ecx, DWORD PTR _skinMat$[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 807  : 	int		i;
; 808  : 
; 809  : 	float s = 1.0f / (float)ptexture->width;

	mov	edx, DWORD PTR _ptexture$[ebp]
	fild	DWORD PTR [edx+68]
	fdivr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _s$[ebp]

; 810  : 	float t = 1.0f / (float)ptexture->height;

	mov	eax, DWORD PTR _ptexture$[ebp]
	fild	DWORD PTR [eax+72]
	fdivr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _t$[ebp]

; 811  : 
; 812  : 	pOut->skinref = pMesh->skinref;

	mov	ecx, DWORD PTR _pOut$[ebp]
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 813  : 
; 814  : 	// init temporare arrays
; 815  : 	m_nNumArrayVerts = m_nNumArrayElems = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344992], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+5344988], 0
$L72394:

; 816  : 
; 817  : 	// first create trifan array from studiomodel mesh
; 818  : 	while( i = *( ptricmds++ ))

	mov	eax, DWORD PTR _ptricmds$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _ptricmds$[ebp]
	add	eax, 2
	mov	DWORD PTR _ptricmds$[ebp], eax
	test	edx, edx
	je	$L72395

; 820  : 		bool	strip = ( i < 0 ) ? false : true;

	cmp	DWORD PTR _i$[ebp], 0
	setge	cl
	mov	BYTE PTR _strip$72396[ebp], cl

; 821  : 		int	vertexState = 0;

	mov	DWORD PTR _vertexState$72397[ebp], 0

; 822  : 
; 823  : 		if( i < 0 ) i = -i;

	cmp	DWORD PTR _i$[ebp], 0
	jge	SHORT $L72398
	mov	edx, DWORD PTR _i$[ebp]
	neg	edx
	mov	DWORD PTR _i$[ebp], edx
$L72398:

; 824  : 
; 825  : 		for( ; i > 0; i--, ptricmds += 4 )

	jmp	SHORT $L72399
$L72400:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ptricmds$[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptricmds$[ebp], ecx
$L72399:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$L72401

; 827  : 			if( vertexState++ < 3 )

	mov	edx, DWORD PTR _vertexState$72397[ebp]
	mov	eax, DWORD PTR _vertexState$72397[ebp]
	add	eax, 1
	mov	DWORD PTR _vertexState$72397[ebp], eax
	cmp	edx, 3
	jge	SHORT $L72402

; 829  : 				m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+5344988]
	mov	DWORD PTR [eax+edx*4+3772124], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344992], eax

; 831  : 			else if( strip )

	jmp	$L72407
$L72402:
	mov	edx, DWORD PTR _strip$72396[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	$L72404

; 833  : 				// flip triangles between clockwise and counter clockwise
; 834  : 				if( vertexState & 1 )

	mov	eax, DWORD PTR _vertexState$72397[ebp]
	and	eax, 1
	test	eax, eax
	je	$L72405

; 836  : 					// draw triangle [n-2 n-1 n]
; 837  : 					m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts - 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	sub	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+ecx*4+3772124], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5344992], edx

; 838  : 					m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+ecx*4+3772124], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5344992], edx

; 839  : 					m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+5344988]
	mov	DWORD PTR [eax+edx*4+3772124], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344992], eax

; 841  : 				else

	jmp	$L72406
$L72405:

; 843  : 					// draw triangle [n-1 n-2 n]
; 844  : 					m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts - 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+3772124], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344992], eax

; 845  : 					m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts - 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	sub	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+3772124], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344992], eax

; 846  : 					m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+5344988]
	mov	DWORD PTR [ecx+eax*4+3772124], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+5344992], ecx
$L72406:

; 849  : 			else

	jmp	$L72407
$L72404:

; 851  : 				// draw triangle fan [0 n-1 n]
; 852  : 				m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts - ( vertexState - 1 );

	mov	eax, DWORD PTR _vertexState$72397[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+ecx*4+3772124], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5344992], edx

; 853  : 				m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+ecx*4+3772124], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5344992], edx

; 854  : 				m_arrayelems[m_nNumArrayElems++] = m_nNumArrayVerts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+5344988]
	mov	DWORD PTR [eax+edx*4+3772124], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344992]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344992], eax
$L72407:

; 856  : 
; 857  : 			// don't concat by matrix here - it's should be done on GPU
; 858  : 			arrayxvert[m_nNumArrayVerts].vertex = pstudioverts[ptricmds[0]];

	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pstudioverts$[ebp]
	add	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	imul	eax, 52					; 00000034H
	add	eax, OFFSET FLAT:_?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 859  : 			arrayxvert[m_nNumArrayVerts].normal = pstudionorms[ptricmds[1]];

	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx+2]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pstudionorms$[ebp]
	add	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	imul	eax, 52					; 00000034H
	add	eax, OFFSET FLAT:_?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A+12
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 860  : 
; 861  : 			if( dml != NULL && dml->numverts > 0 )

	cmp	DWORD PTR _dml$[ebp], 0
	je	$L72413
	mov	edx, DWORD PTR _dml$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jle	$L72413

; 863  : 				dvertlight_t	*vl = &dml->verts[m_nNumLightVerts++];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344996]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _dml$[ebp]
	lea	eax, DWORD PTR [edx+ecx+268]
	mov	DWORD PTR _vl$72409[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344996]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5344996], edx

; 864  : 
; 865  : 				// pack lightvalues into single float
; 866  : 				for( int map = 0; map < MAXLIGHTMAPS; map++ )

	mov	DWORD PTR _map$72410[ebp], 0
	jmp	SHORT $L72411
$L72412:
	mov	ecx, DWORD PTR _map$72410[ebp]
	add	ecx, 1
	mov	DWORD PTR _map$72410[ebp], ecx
$L72411:
	cmp	DWORD PTR _map$72410[ebp], 4
	jge	$L72413

; 868  : 					byte r = vl->light[map][0], g = vl->light[map][1], b = vl->light[map][2];

	mov	edx, DWORD PTR _map$72410[ebp]
	imul	edx, 3
	mov	eax, DWORD PTR _vl$72409[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR _r$72414[ebp], cl
	mov	edx, DWORD PTR _map$72410[ebp]
	imul	edx, 3
	mov	eax, DWORD PTR _vl$72409[ebp]
	mov	cl, BYTE PTR [eax+edx+1]
	mov	BYTE PTR _g$72415[ebp], cl
	mov	edx, DWORD PTR _map$72410[ebp]
	imul	edx, 3
	mov	eax, DWORD PTR _vl$72409[ebp]
	mov	cl, BYTE PTR [eax+edx+2]
	mov	BYTE PTR _b$72416[ebp], cl

; 869  : 					float packDirect = (float)((double)((r << 16) | (g << 8) | b) / (double)(1 << 24));

	mov	edx, DWORD PTR _r$72414[ebp]
	and	edx, 255				; 000000ffH
	shl	edx, 16					; 00000010H
	mov	eax, DWORD PTR _g$72415[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 8
	or	edx, eax
	mov	ecx, DWORD PTR _b$72416[ebp]
	and	ecx, 255				; 000000ffH
	or	edx, ecx
	mov	DWORD PTR -160+[ebp], edx
	fild	DWORD PTR -160+[ebp]
	fdiv	QWORD PTR __real@8@40178000000000000000
	fstp	DWORD PTR _packDirect$72417[ebp]

; 870  : 					arrayxvert[m_nNumArrayVerts].light[map] = packDirect;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _map$72410[ebp]
	mov	edx, DWORD PTR _packDirect$72417[ebp]
	mov	DWORD PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[eax+ecx*4+36], edx

; 871  : 				}

	jmp	$L72412
$L72413:

; 873  : 
; 874  : 			if( FBitSet( ptexture->flags, STUDIO_NF_CHROME ))

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L72421

; 876  : 				// probably always equal 64 (see studiomdl.c for details)
; 877  : 				arrayxvert[m_nNumArrayVerts].stcoord[0] = FloatToHalf( s );

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?FloatToHalf@@YAGM@Z			; FloatToHalf
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	imul	edx, 52					; 00000034H
	mov	WORD PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[edx+24], ax

; 878  : 				arrayxvert[m_nNumArrayVerts].stcoord[1] = FloatToHalf( t );

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?FloatToHalf@@YAGM@Z			; FloatToHalf
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	imul	edx, 52					; 00000034H
	mov	WORD PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[edx+26], ax

; 880  : 			else if( FBitSet( ptexture->flags, STUDIO_NF_UV_COORDS ))

	jmp	$L72424
$L72421:
	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	and	ecx, -2147483648			; 80000000H
	test	ecx, ecx
	je	SHORT $L72423

; 882  : 				arrayxvert[m_nNumArrayVerts].stcoord[0] = ptricmds[2];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _ptricmds$[ebp]
	mov	dx, WORD PTR [ecx+4]
	mov	WORD PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[eax+24], dx

; 883  : 				arrayxvert[m_nNumArrayVerts].stcoord[1] = ptricmds[3];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _ptricmds$[ebp]
	mov	ax, WORD PTR [edx+6]
	mov	WORD PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[ecx+26], ax

; 885  : 			else

	jmp	SHORT $L72424
$L72423:

; 887  : 				arrayxvert[m_nNumArrayVerts].stcoord[0] = FloatToHalf( ptricmds[2] * s );

	mov	ecx, DWORD PTR _ptricmds$[ebp]
	movsx	edx, WORD PTR [ecx+4]
	mov	DWORD PTR -164+[ebp], edx
	fild	DWORD PTR -164+[ebp]
	fmul	DWORD PTR _s$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?FloatToHalf@@YAGM@Z			; FloatToHalf
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	imul	edx, 52					; 00000034H
	mov	WORD PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[edx+24], ax

; 888  : 				arrayxvert[m_nNumArrayVerts].stcoord[1] = FloatToHalf( ptricmds[3] * t );

	mov	eax, DWORD PTR _ptricmds$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	mov	DWORD PTR -168+[ebp], ecx
	fild	DWORD PTR -168+[ebp]
	fmul	DWORD PTR _t$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?FloatToHalf@@YAGM@Z			; FloatToHalf
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+5344988]
	imul	ecx, 52					; 00000034H
	mov	WORD PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[ecx+26], ax
$L72424:

; 890  : 
; 891  : 			if( m_pRenderModel->poseToBone != NULL )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	cmp	DWORD PTR [eax+376], 0
	je	$L72425

; 893  : 				mstudioboneweight_t	*pCurWeight = &pvertweight[ptricmds[0]];

	mov	ecx, DWORD PTR _ptricmds$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	eax, DWORD PTR _pvertweight$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _pCurWeight$72426[ebp], ecx

; 894  : 
; 895  : 				arrayxvert[m_nNumArrayVerts].boneid[0] = pCurWeight->bone[0];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _pCurWeight$72426[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[eax+28], dl

; 896  : 				arrayxvert[m_nNumArrayVerts].boneid[1] = pCurWeight->bone[1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _pCurWeight$72426[ebp]
	mov	al, BYTE PTR [edx+5]
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[ecx+29], al

; 897  : 				arrayxvert[m_nNumArrayVerts].boneid[2] = pCurWeight->bone[2];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _pCurWeight$72426[ebp]
	mov	cl, BYTE PTR [eax+6]
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[edx+30], cl

; 898  : 				arrayxvert[m_nNumArrayVerts].boneid[3] = pCurWeight->bone[3];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _pCurWeight$72426[ebp]
	mov	dl, BYTE PTR [ecx+7]
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[eax+31], dl

; 899  : 				arrayxvert[m_nNumArrayVerts].weight[0] = pCurWeight->weight[0];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _pCurWeight$72426[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[ecx+32], al

; 900  : 				arrayxvert[m_nNumArrayVerts].weight[1] = pCurWeight->weight[1];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _pCurWeight$72426[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[edx+33], cl

; 901  : 				arrayxvert[m_nNumArrayVerts].weight[2] = pCurWeight->weight[2];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _pCurWeight$72426[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[eax+34], dl

; 902  : 				arrayxvert[m_nNumArrayVerts].weight[3] = pCurWeight->weight[3];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _pCurWeight$72426[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[ecx+35], al

; 904  : 			else

	jmp	$L72427
$L72425:

; 906  : 				arrayxvert[m_nNumArrayVerts].boneid[0] = pvertbone[ptricmds[0]];

	mov	ecx, DWORD PTR _ptricmds$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	imul	ecx, 52					; 00000034H
	mov	eax, DWORD PTR _pvertbone$[ebp]
	mov	dl, BYTE PTR [eax+edx]
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[ecx+28], dl

; 907  : 				arrayxvert[m_nNumArrayVerts].boneid[1] = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	imul	ecx, 52					; 00000034H
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[ecx+29], -1

; 908  : 				arrayxvert[m_nNumArrayVerts].boneid[2] = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	imul	eax, 52					; 00000034H
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[eax+30], -1

; 909  : 				arrayxvert[m_nNumArrayVerts].boneid[3] = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	imul	edx, 52					; 00000034H
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[edx+31], -1

; 910  : 				arrayxvert[m_nNumArrayVerts].weight[0] = 255;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	imul	ecx, 52					; 00000034H
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[ecx+32], 255 ; 000000ffH

; 911  : 				arrayxvert[m_nNumArrayVerts].weight[1] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	imul	eax, 52					; 00000034H
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[eax+33], 0

; 912  : 				arrayxvert[m_nNumArrayVerts].weight[2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5344988]
	imul	edx, 52					; 00000034H
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[edx+34], 0

; 913  : 				arrayxvert[m_nNumArrayVerts].weight[3] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344988]
	imul	ecx, 52					; 00000034H
	mov	BYTE PTR _?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A[ecx+35], 0
$L72427:

; 915  : 
; 916  : 			m_nNumArrayVerts++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344988]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344988], eax

; 917  : 		}

	jmp	$L72400
$L72401:

; 918  : 	}

	jmp	$L72394
$L72395:

; 919  : 
; 920  : 	pOut->numVerts = m_nNumArrayVerts;

	mov	edx, DWORD PTR _pOut$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+5344988]
	mov	WORD PTR [edx+4], cx

; 921  : 	pOut->numElems = m_nNumArrayElems;

	mov	edx, DWORD PTR _pOut$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	mov	DWORD PTR [edx+8], ecx

; 922  : 
; 923  : 	// create GPU static buffer
; 924  : 	pglGenBuffersARB( 1, &pOut->vbo );

	mov	edx, DWORD PTR _pOut$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	push	1
	call	DWORD PTR ?pglGenBuffersARB@@3P6GXHPAI@ZA ; pglGenBuffersARB

; 925  : 	pglGenVertexArrays( 1, &pOut->vao );

	mov	eax, DWORD PTR _pOut$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	push	1
	call	DWORD PTR ?pglGenVertexArrays@@3P6GXHPBI@ZA ; pglGenVertexArrays

; 926  : 
; 927  : 	// create vertex array object
; 928  : 	pglBindVertexArray( pOut->vao );

	mov	ecx, DWORD PTR _pOut$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	DWORD PTR ?pglBindVertexArray@@3P6GXI@ZA ; pglBindVertexArray

; 929  : 
; 930  : 	if( m_pStudioHeader->numbones <= 1 && has_vertexlight )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	cmp	DWORD PTR [ecx+140], 1
	jg	SHORT $L72428
	mov	edx, DWORD PTR _has_vertexlight$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72428

; 932  : 		// special case for single bone vertex lighting
; 933  : 		UploadBufferVLight( pOut, arrayxvert );

	push	OFFSET FLAT:_?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A
	mov	eax, DWORD PTR _pOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UploadBufferVLight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z ; CStudioModelRenderer::UploadBufferVLight

; 935  : 	else if( !has_boneweights && !has_vertexlight )

	jmp	$L72433
$L72428:
	mov	ecx, DWORD PTR _has_boneweights$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L72430
	mov	edx, DWORD PTR _has_vertexlight$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L72430

; 937  : 		// typical GoldSrc models without weights
; 938  : 		UploadBufferBase( pOut, arrayxvert );

	push	OFFSET FLAT:_?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A
	mov	eax, DWORD PTR _pOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UploadBufferBase@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z ; CStudioModelRenderer::UploadBufferBase

; 940  : 	else if( has_boneweights && !has_vertexlight )

	jmp	SHORT $L72433
$L72430:
	mov	ecx, DWORD PTR _has_boneweights$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L72432
	mov	edx, DWORD PTR _has_vertexlight$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L72432

; 942  : 		// extended Xash3D models with boneweights
; 943  : 		UploadBufferWeight( pOut, arrayxvert );

	push	OFFSET FLAT:_?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A
	mov	eax, DWORD PTR _pOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UploadBufferWeight@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@@Z ; CStudioModelRenderer::UploadBufferWeight

; 945  : 	else

	jmp	SHORT $L72433
$L72432:

; 947  : 		// all other cases
; 948  : 		if( m_pStudioHeader->numbones > 1 && has_vertexlight )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	cmp	DWORD PTR [edx+140], 1
	jle	SHORT $L72434
	mov	eax, DWORD PTR _has_vertexlight$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L72434

; 949  : 			ALERT( at_aiconsole, "%s static model have skeleton\n", m_pRenderModel->name );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	push	edx
	push	OFFSET FLAT:??_C@_0BP@HEGK@?$CFs?5static?5model?5have?5skeleton?6?$AA@ ; `string'
	push	2
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH
$L72434:

; 950  : 		UploadBufferGeneric( pOut, arrayxvert, has_vertexlight );

	mov	al, BYTE PTR _has_vertexlight$[ebp]
	push	eax
	push	OFFSET FLAT:_?arrayxvert@?1??MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z@4PAUxvert_s@@A
	mov	ecx, DWORD PTR _pOut$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UploadBufferGeneric@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PAUxvert_s@@_N@Z ; CStudioModelRenderer::UploadBufferGeneric
$L72433:

; 952  : 
; 953  : 	// create index array buffer
; 954  : 	pglGenBuffersARB( 1, &pOut->ibo );

	mov	edx, DWORD PTR _pOut$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	push	1
	call	DWORD PTR ?pglGenBuffersARB@@3P6GXHPAI@ZA ; pglGenBuffersARB

; 955  : 	pglBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, pOut->ibo );

	mov	eax, DWORD PTR _pOut$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	34963					; 00008893H
	call	DWORD PTR ?pglBindBufferARB@@3P6GXII@ZA	; pglBindBufferARB

; 956  : 	pglBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, m_nNumArrayElems * sizeof( unsigned int ), &m_arrayelems[0], GL_STATIC_DRAW_ARB );

	push	35044					; 000088e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 3772124				; 00398edcH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344992]
	shl	ecx, 2
	push	ecx
	push	34963					; 00008893H
	call	DWORD PTR ?pglBufferDataARB@@3P6GXIHPBXI@ZA ; pglBufferDataARB

; 957  : 
; 958  : 	// don't forget to unbind them
; 959  : 	pglBindVertexArray( GL_FALSE );

	push	0
	call	DWORD PTR ?pglBindVertexArray@@3P6GXI@ZA ; pglBindVertexArray

; 960  : 	pglBindBufferARB( GL_ARRAY_BUFFER_ARB, 0 );

	push	0
	push	34962					; 00008892H
	call	DWORD PTR ?pglBindBufferARB@@3P6GXII@ZA	; pglBindBufferARB

; 961  : 	pglBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, 0 );

	push	0
	push	34963					; 00008893H
	call	DWORD PTR ?pglBindBufferARB@@3P6GXII@ZA	; pglBindBufferARB

; 962  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z ENDP ; CStudioModelRenderer::MeshCreateBuffer
_TEXT	ENDS
;	COMDAT _$E25
_TEXT	SEGMENT
_$E25	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E25	ENDP
_TEXT	ENDS
;	COMDAT ??0xvert_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0xvert_s@@QAE@XZ PROC NEAR				; xvert_s::xvert_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0xvert_s@@QAE@XZ ENDP					; xvert_s::xvert_s
_TEXT	ENDS
PUBLIC	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z	; matrix3x4::matrix3x4
PUBLIC	??0matrix3x4@@QAE@ABV0@@Z			; matrix3x4::matrix3x4
PUBLIC	?__LINE__Var@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4FA ; `CStudioModelRenderer::CreateMeshCache'::`2'::__LINE__Var
PUBLIC	??_C@_0CL@FINL@Couldn?8t?5find?5submodel?5?$CFs?5for?5bo@ ; `string'
PUBLIC	??_C@_0CI@PKOH@CreateMeshCache?3?5memory?5buffer?5o@ ; `string'
PUBLIC	??_C@_0CJ@BJFC@CreateMeshCache?3?5memory?5buffer?5u@ ; `string'
EXTRN	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z:NEAR	; matrix3x4::ConcatTransforms
EXTRN	?Q_strnicmp@@YAHPBD0H@Z:NEAR			; Q_strnicmp
EXTRN	?InitPose@CStudioBoneSetup@@QAEXQAVVector@@QAVVector4D@@@Z:NEAR ; CStudioBoneSetup::InitPose
_BSS	SEGMENT
	ALIGN	4

_?bones@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVmatrix3x4@@A DB 01800H DUP (?)
_?$S26@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4EA DB 01H DUP (?)
	ALIGN	4

_?pos@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVVector@@A DB 0600H DUP (?)
_?q@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVVector4D@@A DB 0800H DUP (?)
_BSS	ENDS
;	COMDAT ?__LINE__Var@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4FA DW 03c5H ; `CStudioModelRenderer::CreateMeshCache'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CL@FINL@Couldn?8t?5find?5submodel?5?$CFs?5for?5bo@
CONST	SEGMENT
??_C@_0CL@FINL@Couldn?8t?5find?5submodel?5?$CFs?5for?5bo@ DB 'Couldn''t f'
	DB	'ind submodel %s for bodypart %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PKOH@CreateMeshCache?3?5memory?5buffer?5o@
CONST	SEGMENT
??_C@_0CI@PKOH@CreateMeshCache?3?5memory?5buffer?5o@ DB 'CreateMeshCache:'
	DB	' memory buffer overrun', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BJFC@CreateMeshCache?3?5memory?5buffer?5u@
CONST	SEGMENT
??_C@_0CJ@BJFC@CreateMeshCache?3?5memory?5buffer?5u@ DB 'CreateMeshCache:'
	DB	' memory buffer underrun', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z
_TEXT	SEGMENT
$T76067 = -2428
$T76069 = -2480
$T76070 = -2528
$T76072 = -2580
_dml$ = 8
_this$ = -4
_unique_model$ = -8
_submodel$ = -2312
_i$ = -2316
_j$ = -2320
_k$ = -2324
_bufSize$ = -2328
_num_submodels$ = -2332
_buffer$ = -2336
_bufend$ = -2340
_studiocache$ = -2344
_pbodypart$ = -2348
_psubmodel$ = -2352
_pModel$ = -2356
_pbones$ = -2360
_boneinfo$72479 = -2364
_offset$72540 = -2368
_pSrc$72552 = -2372
_pDst$72555 = -2376
_pBodyPart$72561 = -2380
?CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z PROC NEAR ; CStudioModelRenderer::CreateMeshCache, COMDAT

; 965  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2644				; 00000a54H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 	bool		unique_model = (dml == NULL);	// just for more readable code

	xor	eax, eax
	cmp	DWORD PTR _dml$[ebp], 0
	sete	al
	mov	BYTE PTR _unique_model$[ebp], al

; 967  : 	TmpModel_t	submodel[MAXSTUDIOMODELS];	// list of unique models
; 968  : 	static matrix3x4	bones[MAXSTUDIOBONES];

	xor	ecx, ecx
	mov	cl, BYTE PTR _?$S26@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4EA
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L72450
	mov	dl, BYTE PTR _?$S26@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4EA
	or	dl, 1
	mov	BYTE PTR _?$S26@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4EA, dl
	push	OFFSET FLAT:??0matrix3x4@@QAE@XZ	; matrix3x4::matrix3x4
	push	128					; 00000080H
	push	48					; 00000030H
	push	OFFSET FLAT:_?bones@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVmatrix3x4@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E27
	call	_atexit
	add	esp, 4
$L72450:

; 969  : 	static Vector	pos[MAXSTUDIOBONES];

	xor	eax, eax
	mov	al, BYTE PTR _?$S26@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4EA
	and	eax, 2
	test	eax, eax
	jne	SHORT $L72455
	mov	cl, BYTE PTR _?$S26@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4EA
	or	cl, 2
	mov	BYTE PTR _?$S26@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4EA, cl
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	128					; 00000080H
	push	12					; 0000000cH
	push	OFFSET FLAT:_?pos@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVVector@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E28
	call	_atexit
	add	esp, 4
$L72455:

; 970  : 	static Vector4D	q[MAXSTUDIOBONES];

	xor	edx, edx
	mov	dl, BYTE PTR _?$S26@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4EA
	and	edx, 4
	test	edx, edx
	jne	SHORT $L72460
	mov	al, BYTE PTR _?$S26@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4EA
	or	al, 4
	mov	BYTE PTR _?$S26@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4EA, al
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	128					; 00000080H
	push	16					; 00000010H
	push	OFFSET FLAT:_?q@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVVector4D@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E29
	call	_atexit
	add	esp, 4
$L72460:

; 971  : 	int		i, j, k, bufSize = 0;

	mov	DWORD PTR _bufSize$[ebp], 0

; 972  : 	int		num_submodels = 0;

	mov	DWORD PTR _num_submodels$[ebp], 0

; 973  : 	byte		*buffer, *bufend;		// simple bounds check
; 974  : 	mvbocache_t	*studiocache;
; 975  : 	mstudiobodyparts_t	*pbodypart;
; 976  : 	mstudiomodel_t	*psubmodel;
; 977  : 	msubmodel_t	*pModel;
; 978  : 	mstudiobone_t	*pbones;
; 979  : 
; 980  : 	// materials goes first to determine bump
; 981  : 	if( unique_model ) LoadStudioMaterials ();

	mov	ecx, DWORD PTR _unique_model$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L72475
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+208]
$L72475:

; 982  : 
; 983  : 	// build default pose to build seamless TBN-space
; 984  : 	pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+144]
	mov	DWORD PTR _pbones$[ebp], ecx

; 985  : 
; 986  : 	m_boneSetup.SetStudioPointers( m_pStudioHeader, m_pModelInstance->m_poseparameter );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 7020				; 00001b6cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?SetStudioPointers@CStudioBoneSetup@@QAEXPAUstudiohdr_t@@PBM@Z ; CStudioBoneSetup::SetStudioPointers

; 987  : 
; 988  : 	// setup local bone matrices
; 989  : 	if( unique_model && FBitSet( m_pStudioHeader->flags, STUDIO_HAS_BONEINFO ))

	mov	eax, DWORD PTR _unique_model$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L72488
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR [edx+136]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	$L72488

; 991  : 		// NOTE: extended boneinfo goes immediately after bones
; 992  : 		mstudioboneinfo_t *boneinfo = (mstudioboneinfo_t *)((byte *)pbones + m_pStudioHeader->numbones * sizeof( mstudiobone_t ));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR [edx+140]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _pbones$[ebp]
	add	ecx, eax
	mov	DWORD PTR _boneinfo$72479[ebp], ecx

; 993  : 
; 994  : 		// alloc storage for bone array
; 995  : 		m_pRenderModel->poseToBone = (mposetobone_t *)Mem_Alloc( sizeof( mposetobone_t ));

	movsx	edx, WORD PTR ?__LINE__Var@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4FA ; `CStudioModelRenderer::CreateMeshCache'::`2'::__LINE__Var
	add	edx, 30					; 0000001eH
	push	edx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	6144					; 00001800H
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+216
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	DWORD PTR [edx+376], eax

; 996  : 
; 997  : 		for( j = 0; j < m_pStudioHeader->numbones; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L72486
$L72487:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L72486:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+140]
	jge	SHORT $L72488

; 998  : 			LoadLocalMatrix( j, &boneinfo[j] );

	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _boneinfo$72479[ebp]
	add	edx, ecx
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LoadLocalMatrix@CStudioModelRenderer@@QAEXHPAUmstudioboneinfo_t@@@Z ; CStudioModelRenderer::LoadLocalMatrix
	jmp	SHORT $L72487
$L72488:

; 1000 : 
; 1001 : 	// compute default pose with no anim
; 1002 : 	m_boneSetup.InitPose( pos, q );

	push	OFFSET FLAT:_?q@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVVector4D@@A
	push	OFFSET FLAT:_?pos@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVVector@@A
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?InitPose@CStudioBoneSetup@@QAEXQAVVector@@QAVVector4D@@@Z ; CStudioBoneSetup::InitPose

; 1003 : 
; 1004 : 	for( i = 0; i < m_pStudioHeader->numbones; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72489
$L72490:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L72489:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	$L72491

; 1006 : 		if( pbones[i].parent == -1 ) bones[i] = matrix3x4( pos[i], q[i] );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _pbones$[ebp]
	cmp	DWORD PTR [eax+edx+32], -1
	jne	SHORT $L72492
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, OFFSET FLAT:_?q@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVVector4D@@A
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, OFFSET FLAT:_?pos@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVVector@@A
	push	edx
	lea	ecx, DWORD PTR $T76067[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	mov	esi, eax
	mov	edi, DWORD PTR _i$[ebp]
	imul	edi, 48					; 00000030H
	add	edi, OFFSET FLAT:_?bones@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVmatrix3x4@@A
	mov	ecx, 12					; 0000000cH
	rep movsd

; 1007 : 		else bones[i] = bones[pbones[i].parent].ConcatTransforms( matrix3x4( pos[i], q[i] ));

	jmp	SHORT $L72494
$L72492:
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET FLAT:_?q@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVVector4D@@A
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, OFFSET FLAT:_?pos@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVVector@@A
	push	ecx
	lea	ecx, DWORD PTR $T76069[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	sub	esp, 48					; 00000030H
	mov	ecx, esp
	push	eax
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	edx, DWORD PTR $T76070[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _pbones$[ebp]
	mov	ecx, DWORD PTR [ecx+eax+32]
	imul	ecx, 48					; 00000030H
	add	ecx, OFFSET FLAT:_?bones@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVmatrix3x4@@A
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	esi, eax
	mov	edi, DWORD PTR _i$[ebp]
	imul	edi, 48					; 00000030H
	add	edi, OFFSET FLAT:_?bones@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVmatrix3x4@@A
	mov	ecx, 12					; 0000000cH
	rep movsd
$L72494:

; 1008 : 	}

	jmp	$L72490
$L72491:

; 1009 : 
; 1010 : 	if( m_pRenderModel->poseToBone != NULL )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	cmp	DWORD PTR [eax+376], 0
	je	$L72501

; 1012 : 		// convert bones into worldtransform
; 1013 : 		for( i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72499
$L72500:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L72499:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $L72501

; 1014 : 			bones[i] = bones[i].ConcatTransforms( m_pRenderModel->poseToBone->posetobone[i] );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR [eax+376]
	add	edx, ecx
	sub	esp, 48					; 00000030H
	mov	ecx, esp
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	eax, DWORD PTR $T76072[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	add	ecx, OFFSET FLAT:_?bones@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVmatrix3x4@@A
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	esi, eax
	mov	edi, DWORD PTR _i$[ebp]
	imul	edi, 48					; 00000030H
	add	edi, OFFSET FLAT:_?bones@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVmatrix3x4@@A
	mov	ecx, 12					; 0000000cH
	rep movsd
	jmp	SHORT $L72500
$L72501:

; 1016 : 
; 1017 : 	memset( submodel, 0, sizeof( submodel ));

	push	2304					; 00000900H
	push	0
	lea	ecx, DWORD PTR _submodel$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1018 : 	num_submodels = 0;

	mov	DWORD PTR _num_submodels$[ebp], 0

; 1019 : 
; 1020 : 	// build list of unique submodels (by name)
; 1021 : 	for( i = 0; i < m_pStudioHeader->numbodyparts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72504
$L72505:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L72504:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+204]
	jge	$L72506

; 1023 : 		pbodypart = (mstudiobodyparts_t *)((byte *)m_pStudioHeader + m_pStudioHeader->bodypartindex) + i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+208]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 76					; 0000004cH
	add	eax, ecx
	mov	DWORD PTR _pbodypart$[ebp], eax

; 1024 : 
; 1025 : 		for( j = 0; j < pbodypart->nummodels; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L72509
$L72510:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L72509:
	mov	eax, DWORD PTR _pbodypart$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	jge	$L72511

; 1027 : 			psubmodel = (mstudiomodel_t *)((byte *)m_pStudioHeader + pbodypart->modelindex) + j;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _pbodypart$[ebp]
	add	eax, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 112				; 00000070H
	add	eax, edx
	mov	DWORD PTR _psubmodel$[ebp], eax

; 1028 : 			if( !psubmodel->nummesh ) continue; // blank submodel, ignore it

	mov	eax, DWORD PTR _psubmodel$[ebp]
	cmp	DWORD PTR [eax+72], 0
	jne	SHORT $L72514
	jmp	SHORT $L72510
$L72514:

; 1029 : 
; 1030 : 			for( k = 0; k < num_submodels; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L72515
$L72516:
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$L72515:
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _num_submodels$[ebp]
	jge	SHORT $L72517

; 1032 : 				if( !Q_stricmp( submodel[k].name, psubmodel->name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _psubmodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	imul	ecx, 72					; 00000048H
	lea	edx, DWORD PTR _submodel$[ebp+ecx]
	push	edx
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L72518

; 1033 : 					break;

	jmp	SHORT $L72517
$L72518:

; 1034 : 			}

	jmp	SHORT $L72516
$L72517:

; 1035 : 
; 1036 : 			// add new one
; 1037 : 			if( k == num_submodels )

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _num_submodels$[ebp]
	jne	SHORT $L72519

; 1039 : 				Q_strncpy( submodel[k].name, psubmodel->name, sizeof( submodel[k].name ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _psubmodel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	imul	edx, 72					; 00000048H
	lea	eax, DWORD PTR _submodel$[ebp+edx]
	push	eax
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1040 : 				submodel[k].pmodel = psubmodel;

	mov	ecx, DWORD PTR _k$[ebp]
	imul	ecx, 72					; 00000048H
	mov	edx, DWORD PTR _psubmodel$[ebp]
	mov	DWORD PTR _submodel$[ebp+ecx+64], edx

; 1041 : 				num_submodels++;

	mov	eax, DWORD PTR _num_submodels$[ebp]
	add	eax, 1
	mov	DWORD PTR _num_submodels$[ebp], eax
$L72519:

; 1043 : 		}

	jmp	$L72510
$L72511:

; 1044 : 	}

	jmp	$L72505
$L72506:

; 1045 : 
; 1046 : 	// compute cache size (include individual meshes)
; 1047 : 	bufSize = sizeof( mvbocache_t ) + sizeof( mbodypart_t ) * m_pStudioHeader->numbodyparts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR [edx+204]
	imul	eax, 136				; 00000088H
	add	eax, 8
	mov	DWORD PTR _bufSize$[ebp], eax

; 1048 : 
; 1049 : 	for( i = 0; i < num_submodels; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72522
$L72523:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L72522:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _num_submodels$[ebp]
	jge	SHORT $L72524

; 1050 : 		bufSize += sizeof( msubmodel_t ) + sizeof( vbomesh_t ) * submodel[i].pmodel->nummesh;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _submodel$[ebp+eax+64]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _bufSize$[ebp]
	lea	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _bufSize$[ebp], ecx
	jmp	SHORT $L72523
$L72524:

; 1051 : 
; 1052 : 	buffer = (byte *)Mem_Alloc( bufSize );

	movsx	edx, WORD PTR ?__LINE__Var@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4FA ; `CStudioModelRenderer::CreateMeshCache'::`2'::__LINE__Var
	add	edx, 87					; 00000057H
	push	edx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	mov	eax, DWORD PTR _bufSize$[ebp]
	push	eax
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+216
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buffer$[ebp], eax

; 1053 : 	bufend = buffer + bufSize;

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _bufSize$[ebp]
	mov	DWORD PTR _bufend$[ebp], ecx

; 1054 : 
; 1055 : 	// setup pointers
; 1056 : 	studiocache = (mvbocache_t *)buffer;

	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _studiocache$[ebp], edx

; 1057 : 	buffer += sizeof( mvbocache_t );

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, 8
	mov	DWORD PTR _buffer$[ebp], eax

; 1058 : 	studiocache->bodyparts = (mbodypart_t *)buffer;

	mov	ecx, DWORD PTR _studiocache$[ebp]
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [ecx], edx

; 1059 : 	buffer += sizeof( mbodypart_t ) * m_pStudioHeader->numbodyparts;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR [ecx+204]
	imul	edx, 136				; 00000088H
	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, edx
	mov	DWORD PTR _buffer$[ebp], eax

; 1060 : 	studiocache->numbodyparts = m_pStudioHeader->numbodyparts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _studiocache$[ebp]
	mov	ecx, DWORD PTR [edx+204]
	mov	DWORD PTR [eax+4], ecx

; 1061 : 
; 1062 : 	// begin to building submodels
; 1063 : 	for( i = 0; i < num_submodels; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72532
$L72533:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L72532:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num_submodels$[ebp]
	jge	$L72534

; 1065 : 		psubmodel = submodel[i].pmodel;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 72					; 00000048H
	mov	edx, DWORD PTR _submodel$[ebp+ecx+64]
	mov	DWORD PTR _psubmodel$[ebp], edx

; 1066 : 		pModel = (msubmodel_t *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pModel$[ebp], eax

; 1067 : 		buffer += sizeof( msubmodel_t );

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, 8
	mov	DWORD PTR _buffer$[ebp], ecx

; 1068 : 		pModel->nummesh = psubmodel->nummesh;

	mov	edx, DWORD PTR _pModel$[ebp]
	mov	eax, DWORD PTR _psubmodel$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR [edx+4], ecx

; 1069 : 
; 1070 : 		// setup meshes
; 1071 : 		pModel->meshes = (vbomesh_t *)buffer;

	mov	edx, DWORD PTR _pModel$[ebp]
	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [edx], eax

; 1072 : 		buffer += sizeof( vbomesh_t ) * psubmodel->nummesh;

	mov	ecx, DWORD PTR _psubmodel$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, edx
	mov	DWORD PTR _buffer$[ebp], eax

; 1073 : 
; 1074 : 		// sanity check
; 1075 : 		if( dml != NULL && dml->numverts > 0 )

	cmp	DWORD PTR _dml$[ebp], 0
	je	$L72548
	mov	ecx, DWORD PTR _dml$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jle	$L72548

; 1077 : 			// search for submodel offset
; 1078 : 			int	offset = (byte *)psubmodel - (byte *)m_pStudioHeader;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _psubmodel$[ebp]
	sub	eax, DWORD PTR [edx+19124]
	mov	DWORD PTR _offset$72540[ebp], eax

; 1079 : 
; 1080 : 			for( j = 0; j < MAXSTUDIOMODELS; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L72543
$L72544:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L72543:
	cmp	DWORD PTR _j$[ebp], 32			; 00000020H
	jge	SHORT $L72545

; 1082 : 				if( dml->submodels[j].submodel_offset == offset )

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _dml$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+12]
	cmp	ecx, DWORD PTR _offset$72540[ebp]
	jne	SHORT $L72546

; 1083 : 					break;			

	jmp	SHORT $L72545
$L72546:

; 1084 : 			}

	jmp	SHORT $L72544
$L72545:

; 1085 : 
; 1086 : 			ASSERT( j != MAXSTUDIOMODELS );

	cmp	DWORD PTR _j$[ebp], 32			; 00000020H
	jne	SHORT $L72547
	movsx	edx, WORD PTR ?__LINE__Var@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4FA ; `CStudioModelRenderer::CreateMeshCache'::`2'::__LINE__Var
	add	edx, 121				; 00000079H
	push	edx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72547:

; 1087 : 			ASSERT( m_nNumLightVerts == dml->submodels[j].vertex_offset );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _dml$[ebp]
	mov	eax, DWORD PTR [eax+5344996]
	cmp	eax, DWORD PTR [edx+ecx*8+16]
	je	SHORT $L72548
	movsx	ecx, WORD PTR ?__LINE__Var@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4FA ; `CStudioModelRenderer::CreateMeshCache'::`2'::__LINE__Var
	add	ecx, 122				; 0000007aH
	push	ecx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72548:

; 1089 : 
; 1090 : 		for( j = 0; j < psubmodel->nummesh; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L72549
$L72550:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L72549:
	mov	eax, DWORD PTR _psubmodel$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jge	SHORT $L72551

; 1092 : 			mstudiomesh_t *pSrc = (mstudiomesh_t *)((byte *)m_pStudioHeader + psubmodel->meshindex) + j;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _psubmodel$[ebp]
	add	eax, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 20					; 00000014H
	add	eax, edx
	mov	DWORD PTR _pSrc$72552[ebp], eax

; 1093 : 			vbomesh_t *pDst = &pModel->meshes[j];

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _pModel$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	DWORD PTR _pDst$72555[ebp], edx

; 1094 : 
; 1095 : 			MeshCreateBuffer( pDst, pSrc, psubmodel, bones, dml );

	mov	eax, DWORD PTR _dml$[ebp]
	push	eax
	push	OFFSET FLAT:_?bones@?1??CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z@4PAVmatrix3x4@@A
	mov	ecx, DWORD PTR _psubmodel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSrc$72552[ebp]
	push	edx
	mov	eax, DWORD PTR _pDst$72555[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MeshCreateBuffer@CStudioModelRenderer@@AAEXPAUvbomesh_s@@PBUmstudiomesh_t@@PBUmstudiomodel_t@@QBVmatrix3x4@@PAUdmodellight_t@@@Z ; CStudioModelRenderer::MeshCreateBuffer

; 1096 : 		}

	jmp	$L72550
$L72551:

; 1097 : 		submodel[i].pout = pModel; // store unique submodel

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 72					; 00000048H
	mov	edx, DWORD PTR _pModel$[ebp]
	mov	DWORD PTR _submodel$[ebp+ecx+68], edx

; 1098 : 	}

	jmp	$L72533
$L72534:

; 1099 : 
; 1100 : 	// and finally setup bodyparts
; 1101 : 	for( i = 0; i < m_pStudioHeader->numbodyparts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72556
$L72557:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L72556:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+204]
	jge	$L72558

; 1103 : 		pbodypart = (mstudiobodyparts_t *)((byte *)m_pStudioHeader + m_pStudioHeader->bodypartindex) + i;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+208]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 76					; 0000004cH
	add	ecx, edx
	mov	DWORD PTR _pbodypart$[ebp], ecx

; 1104 : 		mbodypart_t *pBodyPart = &studiocache->bodyparts[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	ecx, DWORD PTR _studiocache$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	DWORD PTR _pBodyPart$72561[ebp], edx

; 1105 : 
; 1106 : 		pBodyPart->base = pbodypart->base;

	mov	eax, DWORD PTR _pBodyPart$72561[ebp]
	mov	ecx, DWORD PTR _pbodypart$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax], edx

; 1107 : 		pBodyPart->nummodels = pbodypart->nummodels;

	mov	eax, DWORD PTR _pBodyPart$72561[ebp]
	mov	ecx, DWORD PTR _pbodypart$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+132], edx

; 1108 : 
; 1109 : 		// setup pointers to unique models	
; 1110 : 		for( j = 0; j < pBodyPart->nummodels; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L72562
$L72563:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L72562:
	mov	ecx, DWORD PTR _pBodyPart$72561[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [ecx+132]
	jge	$L72564

; 1112 : 			psubmodel = (mstudiomodel_t *)((byte *)m_pStudioHeader + pbodypart->modelindex) + j;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _pbodypart$[ebp]
	add	ecx, DWORD PTR [edx+72]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 112				; 00000070H
	add	ecx, eax
	mov	DWORD PTR _psubmodel$[ebp], ecx

; 1113 : 			if( !psubmodel->nummesh ) continue; // blank submodel, leave null pointer

	mov	ecx, DWORD PTR _psubmodel$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	jne	SHORT $L72567
	jmp	SHORT $L72563
$L72567:

; 1114 : 
; 1115 : 			// find supposed model
; 1116 : 			for( k = 0; k < num_submodels; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L72568
$L72569:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$L72568:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _num_submodels$[ebp]
	jge	SHORT $L72570

; 1118 : 				if( !Q_stricmp( submodel[k].name, psubmodel->name ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _psubmodel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	imul	edx, 72					; 00000048H
	lea	eax, DWORD PTR _submodel$[ebp+edx]
	push	eax
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L72571

; 1120 : 					pBodyPart->models[j] = submodel[k].pout;

	mov	ecx, DWORD PTR _k$[ebp]
	imul	ecx, 72					; 00000048H
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _pBodyPart$72561[ebp]
	mov	ecx, DWORD PTR _submodel$[ebp+ecx+68]
	mov	DWORD PTR [eax+edx*4+4], ecx

; 1121 : 					break;

	jmp	SHORT $L72570
$L72571:

; 1123 : 			}

	jmp	SHORT $L72569
$L72570:

; 1124 : 
; 1125 : 			if( k == num_submodels )

	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _num_submodels$[ebp]
	jne	SHORT $L72572

; 1126 : 				ALERT( at_error, "Couldn't find submodel %s for bodypart %i\n", psubmodel->name, i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psubmodel$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CL@FINL@Couldn?8t?5find?5submodel?5?$CFs?5for?5bo@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 16					; 00000010H
$L72572:

; 1127 : 		}

	jmp	$L72563
$L72564:

; 1128 : 	}

	jmp	$L72557
$L72558:

; 1129 : 
; 1130 : 	// bounds checking
; 1131 : 	if( buffer != bufend )

	mov	edx, DWORD PTR _buffer$[ebp]
	cmp	edx, DWORD PTR _bufend$[ebp]
	je	SHORT $L72577

; 1133 : 		if( buffer > bufend )

	mov	eax, DWORD PTR _buffer$[ebp]
	cmp	eax, DWORD PTR _bufend$[ebp]
	jbe	SHORT $L72575

; 1134 : 			ALERT( at_error, "CreateMeshCache: memory buffer overrun\n" );

	push	OFFSET FLAT:??_C@_0CI@PKOH@CreateMeshCache?3?5memory?5buffer?5o@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 8

; 1135 : 		else ALERT( at_error, "CreateMeshCache: memory buffer underrun\n" );

	jmp	SHORT $L72577
$L72575:
	push	OFFSET FLAT:??_C@_0CJ@BJFC@CreateMeshCache?3?5memory?5buffer?5u@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 8
$L72577:

; 1137 : 
; 1138 : 	return studiocache;

	mov	eax, DWORD PTR _studiocache$[ebp]

; 1139 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CreateMeshCache@CStudioModelRenderer@@EAEPAUmvbocache_s@@PAUdmodellight_t@@@Z ENDP ; CStudioModelRenderer::CreateMeshCache
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z
_TEXT	SEGMENT
_this$ = -4
_origin$ = 8
_quaternion$ = 12
??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z PROC NEAR	; matrix3x4::matrix3x4, COMDAT

; 461  : 	_forceinline matrix3x4( const Vector &origin, const Vector4D &quaternion )

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 462  : 	{
; 463  : 		mat[0][0] = 1.0f - 2.0f * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);

	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fsubr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR [eax], edx

; 464  : 		mat[1][0] = 2.0f * (quaternion.x * quaternion.y - quaternion.z * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR -12+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -12+[ebp]
	mov	DWORD PTR [eax], ecx

; 465  : 		mat[2][0] = 2.0f * (quaternion.x * quaternion.z + quaternion.y * quaternion.w);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR [edx+12]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR -16+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -16+[ebp]
	mov	DWORD PTR [eax], ecx

; 466  : 		mat[3][0] = origin[0];

	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx

; 467  : 		mat[0][1] = 2.0f * (quaternion.x * quaternion.y + quaternion.z * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR -20+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -20+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 468  : 		mat[1][1] = 1.0f - 2.0f * (quaternion.x * quaternion.x + quaternion.z * quaternion.z);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fsubr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 469  : 		mat[2][1] = 2.0f * (quaternion.y * quaternion.z - quaternion.x * quaternion.w);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [edx+12]
	fsubp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR -28+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -28+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 470  : 		mat[3][1] = origin[1];

	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx

; 471  : 		mat[0][2] = 2.0f * (quaternion.x * quaternion.z - quaternion.y * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR -32+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -32+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 472  : 		mat[1][2] = 2.0f * (quaternion.y * quaternion.z + quaternion.x * quaternion.w);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [edx+12]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 473  : 		mat[2][2] = 1.0f - 2.0f * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR [edx+4]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fsubr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 474  : 		mat[3][2] = origin[2];

	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx

; 475  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ENDP	; matrix3x4::matrix3x4
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
_$S4$ = -8
_$S5$ = -12
_$S6$ = -16
??0matrix3x4@@QAE@ABV0@@Z PROC NEAR			; matrix3x4::matrix3x4, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S4$[ebp], 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _$S5$[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR _$S6$[ebp], ecx
$L55527:
	mov	edx, DWORD PTR _$S6$[ebp]
	push	edx
	mov	ecx, DWORD PTR _$S5$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR _$S5$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _$S5$[ebp], eax
	mov	ecx, DWORD PTR _$S6$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _$S6$[ebp], ecx
	mov	edx, DWORD PTR _$S4$[ebp]
	sub	edx, 1
	mov	DWORD PTR _$S4$[ebp], edx
	cmp	DWORD PTR _$S4$[ebp], 0
	ja	SHORT $L55527
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix3x4@@QAE@ABV0@@Z ENDP				; matrix3x4::matrix3x4
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT _$E29
_TEXT	SEGMENT
_$E29	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E29	ENDP
_TEXT	ENDS
;	COMDAT _$E28
_TEXT	SEGMENT
_$E28	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E28	ENDP
_TEXT	ENDS
;	COMDAT _$E27
_TEXT	SEGMENT
_$E27	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E27	ENDP
_TEXT	ENDS
PUBLIC	?CreateMeshCacheVL@CStudioModelRenderer@@QAEXPBDH@Z ; CStudioModelRenderer::CreateMeshCacheVL
PUBLIC	??_C@_0DM@IMPB@vertexlit?5instance?5created?0?5mode@ ; `string'
PUBLIC	??_C@_0DG@FGLG@failed?5to?5create?5vertex?5lighting@ ; `string'
PUBLIC	??_C@_0EE@GFNN@failed?5to?5create?5vertex?5lighting@ ; `string'
EXTRN	?world@@3PAUgl_world_t@@A:DWORD			; world
;	COMDAT ??_C@_0DM@IMPB@vertexlit?5instance?5created?0?5mode@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_C@_0DM@IMPB@vertexlit?5instance?5created?0?5mode@ DB 'vertexlit instan'
	DB	'ce created, model verts %i, total verts %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FGLG@failed?5to?5create?5vertex?5lighting@
CONST	SEGMENT
??_C@_0DG@FGLG@failed?5to?5create?5vertex?5lighting@ DB 'failed to create'
	DB	' vertex lighting: model CRC %p != %p', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@GFNN@failed?5to?5create?5vertex?5lighting@
CONST	SEGMENT
??_C@_0EE@GFNN@failed?5to?5create?5vertex?5lighting@ DB 'failed to create'
	DB	' vertex lighting: model verts %i != total verts %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?CreateMeshCacheVL@CStudioModelRenderer@@QAEXPBDH@Z
_TEXT	SEGMENT
_modelname$ = 8
_cacheID$ = 12
_this$ = -4
_vl$ = -8
_dml$72593 = -12
_start$72597 = -20
_end$72598 = -28
?CreateMeshCacheVL@CStudioModelRenderer@@QAEXPBDH@Z PROC NEAR ; CStudioModelRenderer::CreateMeshCacheVL, COMDAT

; 1145 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 	dvlightlump_t	*vl = world->vertex_lighting;

	mov	eax, DWORD PTR ?world@@3PAUgl_world_t@@A ; world
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _vl$[ebp], ecx

; 1147 : 
; 1148 : 	// first we need throw previous mesh
; 1149 : 	ReleaseVBOCache( &tr.vertex_light_cache[cacheID] );

	mov	edx, DWORD PTR _cacheID$[ebp]
	lea	eax, DWORD PTR ?tr@@3Uref_globals_t@@A[edx*4+1417216]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]

; 1150 : 
; 1151 : 	if( world->vertex_lighting == NULL )

	mov	eax, DWORD PTR ?world@@3PAUgl_world_t@@A ; world
	cmp	DWORD PTR [eax+120], 0
	jne	SHORT $L72588

; 1152 : 		return; // for some reasons we missed this lump

	jmp	$L72586
$L72588:

; 1153 : 
; 1154 : 	m_pRenderModel = IEngineStudio.Mod_ForName( modelname, false );

	push	0
	mov	ecx, DWORD PTR _modelname$[ebp]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+12
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+19108], eax

; 1155 : 	m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+19124], eax

; 1156 : 
; 1157 : 	if( !m_pRenderModel || !m_pStudioHeader )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+19108], 0
	je	SHORT $L72591
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+19124], 0
	jne	SHORT $L72590
$L72591:

; 1158 : 		return; // download in progress?

	jmp	$L72586
$L72590:

; 1159 : 
; 1160 : 	// first initialization
; 1161 : 	if( cacheID < vl->nummodels && vl->dataofs[cacheID] != -1 )

	mov	edx, DWORD PTR _vl$[ebp]
	mov	eax, DWORD PTR _cacheID$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jge	$L72592
	mov	ecx, DWORD PTR _cacheID$[ebp]
	mov	edx, DWORD PTR _vl$[ebp]
	cmp	DWORD PTR [edx+ecx*4+12], -1
	je	$L72592

; 1163 : 		dmodellight_t	*dml = (dmodellight_t *)((byte *)vl + vl->dataofs[cacheID]);

	mov	eax, DWORD PTR _cacheID$[ebp]
	mov	ecx, DWORD PTR _vl$[ebp]
	mov	edx, DWORD PTR _vl$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+12]
	mov	DWORD PTR _dml$72593[ebp], edx

; 1164 : 
; 1165 : 		m_nNumLightVerts = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5344996], 0

; 1166 : 
; 1167 : 		if( m_pRenderModel->modelCRC == dml->modelCRC )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	eax, DWORD PTR _dml$72593[ebp]
	mov	ecx, DWORD PTR [edx+112]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $L72596

; 1169 : 			double start = Sys_DoubleTime();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+500
	fstp	QWORD PTR _start$72597[ebp]

; 1170 : 			// now create mesh per entity with instanced vertex lighting
; 1171 : 			tr.vertex_light_cache[cacheID] = CreateMeshCache( dml );

	mov	edx, DWORD PTR _dml$72593[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+196]
	mov	ecx, DWORD PTR _cacheID$[ebp]
	mov	DWORD PTR ?tr@@3Uref_globals_t@@A[ecx*4+1417216], eax

; 1172 : 			double end = Sys_DoubleTime();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+500
	fst	QWORD PTR _end$72598[ebp]

; 1173 : 			tr.buildtime += (end - start);

	fsub	QWORD PTR _start$72597[ebp]
	fadd	QWORD PTR ?tr@@3Uref_globals_t@@A+1417184
	fstp	QWORD PTR ?tr@@3Uref_globals_t@@A+1417184
$L72596:

; 1175 : 
; 1176 : 		if( dml->numverts == m_nNumLightVerts )

	mov	edx, DWORD PTR _dml$72593[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+5344996]
	jne	SHORT $L72599

; 1177 : 			ALERT( at_aiconsole, "vertexlit instance created, model verts %i, total verts %i\n", dml->numverts, m_nNumLightVerts );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5344996]
	push	eax
	mov	ecx, DWORD PTR _dml$72593[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET FLAT:??_C@_0DM@IMPB@vertexlit?5instance?5created?0?5mode@ ; `string'
	push	2
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 16					; 00000010H

; 1178 : 		else if( m_pRenderModel->modelCRC != dml->modelCRC )

	jmp	SHORT $L72604
$L72599:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	edx, DWORD PTR _dml$72593[ebp]
	mov	eax, DWORD PTR [ecx+112]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $L72602

; 1179 : 			ALERT( at_error, "failed to create vertex lighting: model CRC %p != %p\n", m_pRenderModel->modelCRC, dml->modelCRC );

	mov	ecx, DWORD PTR _dml$72593[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	edx, DWORD PTR [ecx+112]
	push	edx
	push	OFFSET FLAT:??_C@_0DG@FGLG@failed?5to?5create?5vertex?5lighting@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 16					; 00000010H

; 1180 : 		else ALERT( at_error, "failed to create vertex lighting: model verts %i != total verts %i\n", dml->numverts, m_nNumLightVerts );

	jmp	SHORT $L72604
$L72602:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5344996]
	push	ecx
	mov	edx, DWORD PTR _dml$72593[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET FLAT:??_C@_0EE@GFNN@failed?5to?5create?5vertex?5lighting@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 16					; 00000010H
$L72604:

; 1181 : 		m_nNumLightVerts = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5344996], 0
$L72592:
$L72586:

; 1183 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CreateMeshCacheVL@CStudioModelRenderer@@QAEXPBDH@Z ENDP ; CStudioModelRenderer::CreateMeshCacheVL
_TEXT	ENDS
PUBLIC	?FreeMeshCacheVL@CStudioModelRenderer@@QAEXXZ	; CStudioModelRenderer::FreeMeshCacheVL
;	COMDAT ?FreeMeshCacheVL@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?FreeMeshCacheVL@CStudioModelRenderer@@QAEXXZ PROC NEAR	; CStudioModelRenderer::FreeMeshCacheVL, COMDAT

; 1189 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1190 : 	for( int i = 0; i < MAX_LIGHTCACHE; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72611
$L72612:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L72611:
	cmp	DWORD PTR _i$[ebp], 2048		; 00000800H
	jge	SHORT $L72613

; 1191 : 		ReleaseVBOCache( &tr.vertex_light_cache[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR ?tr@@3Uref_globals_t@@A[ecx*4+1417216]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	jmp	SHORT $L72612
$L72613:

; 1192 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeMeshCacheVL@CStudioModelRenderer@@QAEXXZ ENDP	; CStudioModelRenderer::FreeMeshCacheVL
_TEXT	ENDS
PUBLIC	??_C@_0CJ@CLLM@failed?5to?5create?5vertex?5lighting@ ; `string'
;	COMDAT ??_C@_0CJ@CLLM@failed?5to?5create?5vertex?5lighting@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_C@_0CJ@CLLM@failed?5to?5create?5vertex?5lighting@ DB 'failed to create'
	DB	' vertex lighting for %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?CreateMeshCacheVL@CStudioModelRenderer@@EAEXPAUdmodellight_t@@H@Z
_TEXT	SEGMENT
_dml$ = 8
_cacheID$ = 12
_this$ = -4
_map$72621 = -8
_i$72625 = -12
_mat$72629 = -16
?CreateMeshCacheVL@CStudioModelRenderer@@EAEXPAUdmodellight_t@@H@Z PROC NEAR ; CStudioModelRenderer::CreateMeshCacheVL, COMDAT

; 1195 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1196 : 	if( m_pRenderModel->modelCRC == dml->modelCRC )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	edx, DWORD PTR _dml$[ebp]
	mov	eax, DWORD PTR [ecx+112]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $L72619

; 1198 : 		// get lighting cache
; 1199 : 		m_pModelInstance->m_VlCache = tr.vertex_light_cache[cacheID];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _cacheID$[ebp]
	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A[eax*4+1417216]
	mov	DWORD PTR [edx+20], ecx
$L72619:

; 1201 : 
; 1202 : 	if( m_pModelInstance->m_VlCache != NULL )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	cmp	DWORD PTR [eax+20], 0
	je	$L72620

; 1204 : 		SetBits( m_pModelInstance->info_flags, MF_VERTEX_LIGHTING );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR [edx+16]
	or	al, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	DWORD PTR [edx+16], eax

; 1205 : 
; 1206 : 		for( int map = 0; map < MAXLIGHTMAPS; map++ )

	mov	DWORD PTR _map$72621[ebp], 0
	jmp	SHORT $L72622
$L72623:
	mov	eax, DWORD PTR _map$72621[ebp]
	add	eax, 1
	mov	DWORD PTR _map$72621[ebp], eax
$L72622:
	cmp	DWORD PTR _map$72621[ebp], 4
	jge	SHORT $L72624

; 1207 : 			m_pModelInstance->styles[map] = dml->styles[map];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _dml$[ebp]
	add	eax, DWORD PTR _map$72621[ebp]
	mov	ecx, DWORD PTR _map$72621[ebp]
	mov	al, BYTE PTR [eax+8]
	mov	BYTE PTR [edx+ecx+24], al
	jmp	SHORT $L72623
$L72624:

; 1208 : 
; 1209 : 		for( int i = 0; i < m_pStudioHeader->numtextures; i++ )

	mov	DWORD PTR _i$72625[ebp], 0
	jmp	SHORT $L72626
$L72627:
	mov	ecx, DWORD PTR _i$72625[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$72625[ebp], ecx
$L72626:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _i$72625[ebp]
	cmp	ecx, DWORD PTR [eax+180]
	jge	SHORT $L72628

; 1211 : 			mstudiomaterial_t *mat = &m_pModelInstance->materials[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$72625[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR [eax+11448]
	add	edx, ecx
	mov	DWORD PTR _mat$72629[ebp], edx

; 1212 : 			mat->glsl_sequence = 0; // refresh shaders

	mov	eax, DWORD PTR _mat$72629[ebp]
	mov	WORD PTR [eax+20], 0

; 1213 : 		}

	jmp	SHORT $L72627
$L72628:

; 1215 : 	else

	jmp	SHORT $L72630
$L72620:

; 1217 : 		ALERT( at_warning, "failed to create vertex lighting for %s\n", m_pRenderModel->name );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	push	edx
	push	OFFSET FLAT:??_C@_0CJ@CLLM@failed?5to?5create?5vertex?5lighting@ ; `string'
	push	3
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH

; 1218 : 		SetBits( m_pModelInstance->info_flags, MF_VL_BAD_CACHE );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR [ecx+16]
	or	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	DWORD PTR [ecx+16], edx
$L72630:

; 1220 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CreateMeshCacheVL@CStudioModelRenderer@@EAEXPAUdmodellight_t@@H@Z ENDP ; CStudioModelRenderer::CreateMeshCacheVL
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??ReleaseVBOCache@CStudioModelRenderer@@EAEXPAPAUmvbocache_s@@@Z@4FA ; `CStudioModelRenderer::ReleaseVBOCache'::`2'::__LINE__Var
EXTRN	?pglDeleteBuffersARB@@3P6GXHPBI@ZA:DWORD	; pglDeleteBuffersARB
EXTRN	?pglDeleteVertexArrays@@3P6GXHPBI@ZA:DWORD	; pglDeleteVertexArrays
;	COMDAT ?__LINE__Var@?1??ReleaseVBOCache@CStudioModelRenderer@@EAEXPAPAUmvbocache_s@@@Z@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??ReleaseVBOCache@CStudioModelRenderer@@EAEXPAPAUmvbocache_s@@@Z@4FA DW 04c7H ; `CStudioModelRenderer::ReleaseVBOCache'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?ReleaseVBOCache@CStudioModelRenderer@@EAEXPAPAUmvbocache_s@@@Z
_TEXT	SEGMENT
_ppvbocache$ = 8
_this$ = -4
_pvbocache$ = -8
_i$ = -12
_pBodyPart$72644 = -16
_j$72645 = -20
_pSubModel$72649 = -24
_k$72652 = -28
_pMesh$72656 = -32
?ReleaseVBOCache@CStudioModelRenderer@@EAEXPAPAUmvbocache_s@@@Z PROC NEAR ; CStudioModelRenderer::ReleaseVBOCache, COMDAT

; 1223 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1224 : 	ASSERT( ppvbocache != NULL );

	cmp	DWORD PTR _ppvbocache$[ebp], 0
	jne	SHORT $L72637
	movsx	eax, WORD PTR ?__LINE__Var@?1??ReleaseVBOCache@CStudioModelRenderer@@EAEXPAPAUmvbocache_s@@@Z@4FA ; `CStudioModelRenderer::ReleaseVBOCache'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72637:

; 1225 : 
; 1226 : 	mvbocache_t *pvbocache = *ppvbocache;

	mov	ecx, DWORD PTR _ppvbocache$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pvbocache$[ebp], edx

; 1227 : 	if( !pvbocache ) return;

	cmp	DWORD PTR _pvbocache$[ebp], 0
	jne	SHORT $L72639
	jmp	$L72635
$L72639:

; 1228 : 
; 1229 : 	for( int i = 0; i < pvbocache->numbodyparts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72641
$L72642:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L72641:
	mov	ecx, DWORD PTR _pvbocache$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jge	$L72643

; 1231 : 		mbodypart_t *pBodyPart = &pvbocache->bodyparts[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	ecx, DWORD PTR _pvbocache$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	DWORD PTR _pBodyPart$72644[ebp], edx

; 1232 : 
; 1233 : 		for( int j = 0; j < pBodyPart->nummodels; j++ )

	mov	DWORD PTR _j$72645[ebp], 0
	jmp	SHORT $L72646
$L72647:
	mov	eax, DWORD PTR _j$72645[ebp]
	add	eax, 1
	mov	DWORD PTR _j$72645[ebp], eax
$L72646:
	mov	ecx, DWORD PTR _pBodyPart$72644[ebp]
	mov	edx, DWORD PTR _j$72645[ebp]
	cmp	edx, DWORD PTR [ecx+132]
	jge	$L72648

; 1235 : 			msubmodel_t *pSubModel = pBodyPart->models[j];

	mov	eax, DWORD PTR _j$72645[ebp]
	mov	ecx, DWORD PTR _pBodyPart$72644[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR _pSubModel$72649[ebp], edx

; 1236 : 
; 1237 : 			if( !pSubModel || pSubModel->nummesh <= 0 )

	cmp	DWORD PTR _pSubModel$72649[ebp], 0
	je	SHORT $L72651
	mov	eax, DWORD PTR _pSubModel$72649[ebp]
	cmp	DWORD PTR [eax+4], 0
	jg	SHORT $L72650
$L72651:

; 1238 : 				continue; // blank submodel

	jmp	SHORT $L72647
$L72650:

; 1239 : 
; 1240 : 			for( int k = 0; k < pSubModel->nummesh; k++ )

	mov	DWORD PTR _k$72652[ebp], 0
	jmp	SHORT $L72653
$L72654:
	mov	ecx, DWORD PTR _k$72652[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$72652[ebp], ecx
$L72653:
	mov	edx, DWORD PTR _pSubModel$72649[ebp]
	mov	eax, DWORD PTR _k$72652[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	SHORT $L72655

; 1242 : 				vbomesh_t *pMesh = &pSubModel->meshes[k];

	mov	ecx, DWORD PTR _k$72652[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pSubModel$72649[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	DWORD PTR _pMesh$72656[ebp], eax

; 1243 : 
; 1244 : 				// purge all GPU data
; 1245 : 				if( pMesh->vao ) pglDeleteVertexArrays( 1, &pMesh->vao );

	mov	ecx, DWORD PTR _pMesh$72656[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L72657
	mov	edx, DWORD PTR _pMesh$72656[ebp]
	add	edx, 16					; 00000010H
	push	edx
	push	1
	call	DWORD PTR ?pglDeleteVertexArrays@@3P6GXHPBI@ZA ; pglDeleteVertexArrays
$L72657:

; 1246 : 				if( pMesh->vbo ) pglDeleteBuffersARB( 1, &pMesh->vbo );

	mov	eax, DWORD PTR _pMesh$72656[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L72658
	mov	ecx, DWORD PTR _pMesh$72656[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	push	1
	call	DWORD PTR ?pglDeleteBuffersARB@@3P6GXHPBI@ZA ; pglDeleteBuffersARB
$L72658:

; 1247 : 				if( pMesh->ibo ) pglDeleteBuffersARB( 1, &pMesh->ibo );

	mov	edx, DWORD PTR _pMesh$72656[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $L72659
	mov	eax, DWORD PTR _pMesh$72656[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	1
	call	DWORD PTR ?pglDeleteBuffersARB@@3P6GXHPBI@ZA ; pglDeleteBuffersARB
$L72659:

; 1248 : 			}

	jmp	SHORT $L72654
$L72655:

; 1249 : 		}

	jmp	$L72647
$L72648:

; 1250 : 	}

	jmp	$L72642
$L72643:

; 1251 : 
; 1252 : 	if( pvbocache != NULL )

	cmp	DWORD PTR _pvbocache$[ebp], 0
	je	SHORT $L72660

; 1253 : 		Mem_Free( pvbocache );

	movsx	ecx, WORD PTR ?__LINE__Var@?1??ReleaseVBOCache@CStudioModelRenderer@@EAEXPAPAUmvbocache_s@@@Z@4FA ; `CStudioModelRenderer::ReleaseVBOCache'::`2'::__LINE__Var
	add	ecx, 30					; 0000001eH
	push	ecx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	mov	edx, DWORD PTR _pvbocache$[ebp]
	push	edx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+220
	add	esp, 12					; 0000000cH
$L72660:

; 1254 : 	*ppvbocache = NULL;

	mov	eax, DWORD PTR _ppvbocache$[ebp]
	mov	DWORD PTR [eax], 0
$L72635:

; 1255 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ReleaseVBOCache@CStudioModelRenderer@@EAEXPAPAUmvbocache_s@@@Z ENDP ; CStudioModelRenderer::ReleaseVBOCache
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DestroyMeshCache@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::DestroyMeshCache'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??DestroyMeshCache@CStudioModelRenderer@@EAEXXZ@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DestroyMeshCache@CStudioModelRenderer@@EAEXXZ@4FA DW 04eaH ; `CStudioModelRenderer::DestroyMeshCache'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?DestroyMeshCache@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DestroyMeshCache@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::DestroyMeshCache, COMDAT

; 1258 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1259 : 	FreeStudioMaterials ();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+212]

; 1260 : 
; 1261 : 	ReleaseVBOCache( &m_pRenderModel->studiocache );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	add	ecx, 380				; 0000017cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+200]

; 1262 : 
; 1263 : 	if( m_pRenderModel->poseToBone != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	cmp	DWORD PTR [edx+376], 0
	je	SHORT $L72665

; 1264 : 		Mem_Free( m_pRenderModel->poseToBone );

	movsx	eax, WORD PTR ?__LINE__Var@?1??DestroyMeshCache@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::DestroyMeshCache'::`2'::__LINE__Var
	add	eax, 6
	push	eax
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	eax, DWORD PTR [edx+376]
	push	eax
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+220
	add	esp, 12					; 0000000cH
$L72665:

; 1265 : 	m_pRenderModel->poseToBone = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	DWORD PTR [edx+376], 0

; 1266 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DestroyMeshCache@CStudioModelRenderer@@EAEXXZ ENDP	; CStudioModelRenderer::DestroyMeshCache
_TEXT	ENDS
PUBLIC	?FILE_EXISTS@@YA_NPBD@Z				; FILE_EXISTS
PUBLIC	?__LINE__Var@?1??LoadStudioMaterials@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::LoadStudioMaterials'::`2'::__LINE__Var
PUBLIC	??_C@_0P@IPNL@textures?1?$CFs?1?$CFs?$AA@	; `string'
PUBLIC	??_C@_06CKIE@?$CFs?4tga?$AA@			; `string'
PUBLIC	??_C@_06MMEP@?$CFs?4dds?$AA@			; `string'
EXTRN	?GL_UberShaderForSolidStudio@@YAGPAUmstudiomat_s@@_N11H@Z:NEAR ; GL_UberShaderForSolidStudio
EXTRN	?Q_snprintf@@YAHPADIPBDZZ:NEAR			; Q_snprintf
EXTRN	?va@@YAPADPBDZZ:NEAR				; va
EXTRN	?COM_FileBase@@YAXPBDPAD@Z:NEAR			; COM_FileBase
;	COMDAT ?__LINE__Var@?1??LoadStudioMaterials@CStudioModelRenderer@@EAEXXZ@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??LoadStudioMaterials@CStudioModelRenderer@@EAEXXZ@4FA DW 04f5H ; `CStudioModelRenderer::LoadStudioMaterials'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0P@IPNL@textures?1?$CFs?1?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@IPNL@textures?1?$CFs?1?$CFs?$AA@ DB 'textures/%s/%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKIE@?$CFs?4tga?$AA@
CONST	SEGMENT
??_C@_06CKIE@?$CFs?4tga?$AA@ DB '%s.tga', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MMEP@?$CFs?4dds?$AA@
CONST	SEGMENT
??_C@_06MMEP@?$CFs?4dds?$AA@ DB '%s.dds', 00H		; `string'
CONST	ENDS
;	COMDAT ?LoadStudioMaterials@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
_ptexture$ = -8
_bone_weights$ = -12
_pmaterial$ = -16
_diffuse$ = -80
_texname$ = -144
_mdlname$ = -208
_i$ = -212
_texture_ext$72692 = -216
_encodeType$72693 = -220
?LoadStudioMaterials@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::LoadStudioMaterials, COMDAT

; 1269 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1270 : 	// first we need alloc copy of all the materials to prevent modify mstudiotexture_t
; 1271 : 	m_pRenderModel->materials = (mstudiomaterial_t *)Mem_Alloc( sizeof( mstudiomaterial_t ) * m_pStudioHeader->numtextures );

	movsx	eax, WORD PTR ?__LINE__Var@?1??LoadStudioMaterials@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::LoadStudioMaterials'::`2'::__LINE__Var
	add	eax, 2
	push	eax
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR [edx+180]
	imul	eax, 28					; 0000001cH
	push	eax
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+216
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	DWORD PTR [edx+384], eax

; 1272 : 
; 1273 : 	mstudiotexture_t	*ptexture = (mstudiotexture_t *)((byte *)m_pStudioHeader + m_pStudioHeader->textureindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+184]
	mov	DWORD PTR _ptexture$[ebp], eax

; 1274 : 	bool		bone_weights = FBitSet( m_pStudioHeader->flags, STUDIO_HAS_BONEWEIGHTS ) ? true : false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR [edx+136]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	setne	cl
	mov	BYTE PTR _bone_weights$[ebp], cl

; 1275 : 	mstudiomaterial_t	*pmaterial = (mstudiomaterial_t *)m_pRenderModel->materials;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	mov	ecx, DWORD PTR [eax+384]
	mov	DWORD PTR _pmaterial$[ebp], ecx

; 1276 : 	char		diffuse[64], texname[64], mdlname[64];
; 1277 : 	int		i;
; 1278 : 
; 1279 : 	COM_FileBase( m_pRenderModel->name, mdlname );

	lea	edx, DWORD PTR _mdlname$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	push	ecx
	call	?COM_FileBase@@YAXPBDPAD@Z		; COM_FileBase
	add	esp, 8

; 1280 : 
; 1281 : 	// loading studio materials from studio textures
; 1282 : 	for( i = 0; i < m_pStudioHeader->numtextures; i++, ptexture++, pmaterial++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72684
$L72685:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _ptexture$[ebp]
	add	eax, 80					; 00000050H
	mov	DWORD PTR _ptexture$[ebp], eax
	mov	ecx, DWORD PTR _pmaterial$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _pmaterial$[ebp], ecx
$L72684:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+180]
	jge	$L72686

; 1284 : 		COM_FileBase( ptexture->name, texname );

	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptexture$[ebp]
	push	eax
	call	?COM_FileBase@@YAXPBDPAD@Z		; COM_FileBase
	add	esp, 8

; 1285 : 
; 1286 : 		// build material names
; 1287 : 		Q_snprintf( diffuse, sizeof( diffuse ), "textures/%s/%s", mdlname, texname );

	lea	ecx, DWORD PTR _texname$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mdlname$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0P@IPNL@textures?1?$CFs?1?$CFs?$AA@ ; `string'
	push	64					; 00000040H
	lea	eax, DWORD PTR _diffuse$[ebp]
	push	eax
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 20					; 00000014H

; 1288 : 
; 1289 : 		pmaterial->pSource = ptexture;

	mov	ecx, DWORD PTR _pmaterial$[ebp]
	mov	edx, DWORD PTR _ptexture$[ebp]
	mov	DWORD PTR [ecx], edx

; 1290 : 		pmaterial->flags = ptexture->flags;

	mov	eax, DWORD PTR _pmaterial$[ebp]
	mov	ecx, DWORD PTR _ptexture$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+8], edx

; 1291 : 
; 1292 : 		if( IMAGE_EXISTS( diffuse ) && !FBitSet( ptexture->flags, STUDIO_NF_COLORMAP ))

	lea	eax, DWORD PTR _diffuse$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_06CKIE@?$CFs?4tga?$AA@ ; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 8
	push	eax
	call	?FILE_EXISTS@@YA_NPBD@Z			; FILE_EXISTS
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L72689
	lea	ecx, DWORD PTR _diffuse$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_06MMEP@?$CFs?4dds?$AA@ ; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 8
	push	eax
	call	?FILE_EXISTS@@YA_NPBD@Z			; FILE_EXISTS
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L72698
$L72689:
	mov	edx, DWORD PTR _ptexture$[ebp]
	mov	eax, DWORD PTR [edx+64]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	jne	$L72698

; 1294 : 			int	texture_ext = LOAD_TEXTURE( diffuse, NULL, 0, 0 );

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _diffuse$[ebp]
	push	ecx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+60
	add	esp, 16					; 00000010H
	mov	DWORD PTR _texture_ext$72692[ebp], eax

; 1295 : 			int	encodeType = RENDER_GET_PARM( PARM_TEX_ENCODE, texture_ext );

	mov	edx, DWORD PTR _texture_ext$72692[ebp]
	push	edx
	push	14					; 0000000eH
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A
	add	esp, 8
	mov	DWORD PTR _encodeType$72693[ebp], eax

; 1296 : 
; 1297 : 			// NOTE: default renderer can't unpack encoded textures
; 1298 : 			// so keep lowres copies for this case
; 1299 : 			if( encodeType == DXT_ENCODE_DEFAULT )

	cmp	DWORD PTR _encodeType$72693[ebp], 0
	jne	$L72694

; 1301 : 				pmaterial->gl_diffuse_id = texture_ext;

	mov	eax, DWORD PTR _pmaterial$[ebp]
	mov	cx, WORD PTR _texture_ext$72692[ebp]
	mov	WORD PTR [eax+4], cx

; 1302 : 
; 1303 : 				// semi-transparent textures must have additive flag to invoke renderer insert supposed mesh into translist
; 1304 : 				if( FBitSet( pmaterial->flags, STUDIO_NF_ADDITIVE ))

	mov	edx, DWORD PTR _pmaterial$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $L72696

; 1306 : 					if( RENDER_GET_PARM( PARM_TEX_FLAGS, pmaterial->gl_diffuse_id ) & TF_HAS_ALPHA )

	mov	ecx, DWORD PTR _pmaterial$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+4]
	push	edx
	push	10					; 0000000aH
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A
	add	esp, 8
	and	eax, 65536				; 00010000H
	test	eax, eax
	je	SHORT $L72696

; 1307 : 						pmaterial->flags |= STUDIO_NF_HAS_ALPHA;

	mov	eax, DWORD PTR _pmaterial$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 524288				; 00080000H
	mov	edx, DWORD PTR _pmaterial$[ebp]
	mov	DWORD PTR [edx+8], ecx
$L72696:

; 1309 : 
; 1310 : 				if( RENDER_GET_PARM( PARM_TEX_FLAGS, pmaterial->gl_diffuse_id ) & TF_HAS_ALPHA )

	mov	eax, DWORD PTR _pmaterial$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+4]
	push	ecx
	push	10					; 0000000aH
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A
	add	esp, 8
	and	eax, 65536				; 00010000H
	test	eax, eax
	je	SHORT $L72697

; 1312 : 					ptexture->flags |= STUDIO_NF_MASKED;

	mov	edx, DWORD PTR _ptexture$[ebp]
	mov	eax, DWORD PTR [edx+64]
	or	al, 64					; 00000040H
	mov	ecx, DWORD PTR _ptexture$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 1313 : 					pmaterial->flags |= STUDIO_NF_MASKED;

	mov	edx, DWORD PTR _pmaterial$[ebp]
	mov	eax, DWORD PTR [edx+8]
	or	al, 64					; 00000040H
	mov	ecx, DWORD PTR _pmaterial$[ebp]
	mov	DWORD PTR [ecx+8], eax
$L72697:

; 1316 : 			else

	jmp	SHORT $L72698
$L72694:

; 1318 : 				// can't use encoded textures
; 1319 : 				FREE_TEXTURE( texture_ext );

	mov	edx, DWORD PTR _texture_ext$72692[ebp]
	push	edx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+76
	add	esp, 4
$L72698:

; 1322 : 
; 1323 : 		if( pmaterial->gl_diffuse_id != 0 )

	mov	eax, DWORD PTR _pmaterial$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $L72699

; 1325 : 			// so engine can be draw HQ image for gl_renderer 0
; 1326 : 			FREE_TEXTURE( ptexture->index );

	mov	edx, DWORD PTR _ptexture$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+76
	add	esp, 4

; 1327 : 			ptexture->index = pmaterial->gl_diffuse_id;

	mov	ecx, DWORD PTR _pmaterial$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	DWORD PTR [eax+76], edx

; 1329 : 		else

	jmp	SHORT $L72700
$L72699:

; 1331 : 			// reuse original texture
; 1332 : 			pmaterial->gl_diffuse_id = ptexture->index;

	mov	ecx, DWORD PTR _pmaterial$[ebp]
	mov	edx, DWORD PTR _ptexture$[ebp]
	mov	ax, WORD PTR [edx+76]
	mov	WORD PTR [ecx+4], ax
$L72700:

; 1334 : 
; 1335 : 		// precache as many shaders as possible
; 1336 : 		GL_UberShaderForSolidStudio( pmaterial, false, bone_weights, false, m_pStudioHeader->numbones );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	push	0
	mov	cl, BYTE PTR _bone_weights$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _pmaterial$[ebp]
	push	edx
	call	?GL_UberShaderForSolidStudio@@YAGPAUmstudiomat_s@@_N11H@Z ; GL_UberShaderForSolidStudio
	add	esp, 20					; 00000014H

; 1337 : 	}

	jmp	$L72685
$L72686:

; 1338 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadStudioMaterials@CStudioModelRenderer@@EAEXXZ ENDP	; CStudioModelRenderer::LoadStudioMaterials
_TEXT	ENDS
;	COMDAT ?FILE_EXISTS@@YA_NPBD@Z
_TEXT	SEGMENT
_filename$ = 8
_iCompare$ = -4
?FILE_EXISTS@@YA_NPBD@Z PROC NEAR			; FILE_EXISTS, COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 151  : 	int iCompare;
; 152  : 
; 153  : 	// verify file exists
; 154  : 	// g-cont. idea! use COMPARE_FILE_TIME instead of COM_LoadFile
; 155  : 	if( COMPARE_FILE_TIME( filename, filename, &iCompare ))

	lea	eax, DWORD PTR _iCompare$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+232
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L57700

; 156  : 		return true;

	mov	al, 1
	jmp	SHORT $L57698
$L57700:

; 157  : 	return false;

	xor	al, al
$L57698:

; 158  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FILE_EXISTS@@YA_NPBD@Z ENDP				; FILE_EXISTS
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??FreeStudioMaterials@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::FreeStudioMaterials'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??FreeStudioMaterials@CStudioModelRenderer@@EAEXXZ@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??FreeStudioMaterials@CStudioModelRenderer@@EAEXXZ@4FA DW 053dH ; `CStudioModelRenderer::FreeStudioMaterials'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?FreeStudioMaterials@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_pmaterial$ = -8
_i$ = -12
_this$ = -4
?FreeStudioMaterials@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::FreeStudioMaterials, COMDAT

; 1341 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1342 : 	if( !m_pRenderModel->materials ) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	cmp	DWORD PTR [ecx+384], 0
	jne	SHORT $L72705
	jmp	$L72704
$L72705:

; 1343 : 
; 1344 : 	mstudiomaterial_t	*pmaterial = (mstudiomaterial_t *)m_pRenderModel->materials;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	mov	ecx, DWORD PTR [eax+384]
	mov	DWORD PTR _pmaterial$[ebp], ecx

; 1345 : 
; 1346 : 	// release textures for current model
; 1347 : 	for( int i = 0; i < m_pStudioHeader->numtextures; i++, pmaterial++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72709
$L72710:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _pmaterial$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _pmaterial$[ebp], eax
$L72709:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+180]
	jge	SHORT $L72711

; 1349 : 		if( pmaterial->pSource->index != pmaterial->gl_diffuse_id )

	mov	ecx, DWORD PTR _pmaterial$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pmaterial$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+4]
	cmp	DWORD PTR [edx+76], ecx
	je	SHORT $L72712

; 1350 : 			FREE_TEXTURE( pmaterial->gl_diffuse_id );

	mov	edx, DWORD PTR _pmaterial$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+4]
	push	eax
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+76
	add	esp, 4
$L72712:

; 1351 : 	}

	jmp	SHORT $L72710
$L72711:

; 1352 : 
; 1353 : 	Mem_Free( m_pRenderModel->materials );

	movsx	ecx, WORD PTR ?__LINE__Var@?1??FreeStudioMaterials@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::FreeStudioMaterials'::`2'::__LINE__Var
	add	ecx, 12					; 0000000cH
	push	ecx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	mov	ecx, DWORD PTR [eax+384]
	push	ecx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+220
	add	esp, 12					; 0000000cH

; 1354 : 	m_pRenderModel->materials = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	mov	DWORD PTR [eax+384], 0
$L72704:

; 1355 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeStudioMaterials@CStudioModelRenderer@@EAEXXZ ENDP	; CStudioModelRenderer::FreeStudioMaterials
_TEXT	ENDS
PUBLIC	?DestroyAllModelInstances@CStudioModelRenderer@@QAEXXZ ; CStudioModelRenderer::DestroyAllModelInstances
PUBLIC	?RemoveAll@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::RemoveAll
PUBLIC	?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Count
;	COMDAT ?DestroyAllModelInstances@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?DestroyAllModelInstances@CStudioModelRenderer@@QAEXXZ PROC NEAR ; CStudioModelRenderer::DestroyAllModelInstances, COMDAT

; 1358 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1359 : 	// NOTE: should destroy in reverse-order because it's linked list not array!
; 1360 : 	for( int i = m_ModelInstances.Count(); --i >= 0; )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Count
	mov	DWORD PTR _i$[ebp], eax
$L72720:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L72721

; 1362 : 		DestroyInstance( i );

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+148]

; 1363 : 	}

	jmp	SHORT $L72720
$L72721:

; 1364 : 
; 1365 : 	m_DecalMaterial.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?RemoveAll@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::RemoveAll

; 1366 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DestroyAllModelInstances@CStudioModelRenderer@@QAEXXZ ENDP ; CStudioModelRenderer::DestroyAllModelInstances
_TEXT	ENDS
PUBLIC	?GetEntityRenderMode@CStudioModelRenderer@@QAEHPAUcl_entity_s@@@Z ; CStudioModelRenderer::GetEntityRenderMode
;	COMDAT ?GetEntityRenderMode@CStudioModelRenderer@@QAEHPAUcl_entity_s@@@Z
_TEXT	SEGMENT
_ent$ = 8
_this$ = -4
_oldent$ = -8
_i$ = -12
_opaque$ = -16
_trans$ = -20
_ptexture$ = -24
_model$ = -28
_phdr$ = -32
?GetEntityRenderMode@CStudioModelRenderer@@QAEHPAUcl_entity_s@@@Z PROC NEAR ; CStudioModelRenderer::GetEntityRenderMode, COMDAT

; 1463 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1464 : 	cl_entity_t	*oldent = IEngineStudio.GetCurrentEntity();

	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+24
	mov	DWORD PTR _oldent$[ebp], eax

; 1465 : 	int		i, opaque, trans;
; 1466 : 	mstudiotexture_t	*ptexture;
; 1467 : 	model_t		*model;
; 1468 : 	studiohdr_t	*phdr;
; 1469 : 
; 1470 : 	SET_CURRENT_ENTITY( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+32
	add	esp, 4

; 1471 : 
; 1472 : 	if( ent->player ) // check it for real playermodel

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L72773

; 1473 : 		model = IEngineStudio.SetupPlayerModel( ent->curstate.number - 1 );

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+692]
	sub	eax, 1
	push	eax
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+124
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 1474 : 	else if( ent->curstate.renderfx == kRenderFxDeadPlayer )

	jmp	SHORT $L72776
$L72773:
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+772], 17			; 00000011H
	jne	SHORT $L72775

; 1475 : 		model = IEngineStudio.SetupPlayerModel( ent->curstate.renderamt - 1 );

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+764]
	sub	eax, 1
	push	eax
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+124
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 1476 : 	else model = ent->model;

	jmp	SHORT $L72776
$L72775:
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	mov	DWORD PTR _model$[ebp], edx
$L72776:

; 1477 : 
; 1478 : 	SET_CURRENT_ENTITY( oldent );

	mov	eax, DWORD PTR _oldent$[ebp]
	push	eax
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+32
	add	esp, 4

; 1479 : 
; 1480 : 	if(( phdr = (studiohdr_t *)IEngineStudio.Mod_Extradata( model )) == NULL )

	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	DWORD PTR _phdr$[ebp], eax
	cmp	DWORD PTR _phdr$[ebp], 0
	jne	SHORT $L72778

; 1482 : 		if( R_ModelOpaque( ent->curstate.rendermode ))

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+760], 0
	jne	SHORT $L72780

; 1484 : 			// forcing to choose right sorting type
; 1485 : 			if(( model && model->type == mod_brush ) && FBitSet( model->flags, MODEL_TRANSPARENT ))

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $L72780
	mov	eax, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [eax+68], 0
	jne	SHORT $L72780
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 8
	test	edx, edx
	je	SHORT $L72780

; 1486 : 				return kRenderTransAlpha;

	mov	eax, 4
	jmp	$L72765
$L72780:

; 1488 : 		return ent->curstate.rendermode;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [eax+760]
	jmp	$L72765
$L72778:

; 1490 : 	ptexture = (mstudiotexture_t *)((byte *)phdr + phdr->textureindex);

	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR _phdr$[ebp]
	add	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR _ptexture$[ebp], edx

; 1491 : 
; 1492 : 	for( opaque = trans = i = 0; i < phdr->numtextures; i++, ptexture++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _trans$[ebp], eax
	mov	ecx, DWORD PTR _trans$[ebp]
	mov	DWORD PTR _opaque$[ebp], ecx
	jmp	SHORT $L72783
$L72784:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _ptexture$[ebp]
	add	eax, 80					; 00000050H
	mov	DWORD PTR _ptexture$[ebp], eax
$L72783:
	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+180]
	jge	SHORT $L72785

; 1494 : 		// ignore chrome & additive it's just a specular-like effect
; 1495 : 		if( FBitSet( ptexture->flags, STUDIO_NF_ADDITIVE ) && !FBitSet( ptexture->flags, STUDIO_NF_CHROME ))

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	and	ecx, 32					; 00000020H
	test	ecx, ecx
	je	SHORT $L72786
	mov	edx, DWORD PTR _ptexture$[ebp]
	mov	eax, DWORD PTR [edx+64]
	and	eax, 2
	test	eax, eax
	jne	SHORT $L72786

; 1496 : 			trans++;

	mov	ecx, DWORD PTR _trans$[ebp]
	add	ecx, 1
	mov	DWORD PTR _trans$[ebp], ecx

; 1497 : 		else opaque++;

	jmp	SHORT $L72787
$L72786:
	mov	edx, DWORD PTR _opaque$[ebp]
	add	edx, 1
	mov	DWORD PTR _opaque$[ebp], edx
$L72787:

; 1498 : 	}

	jmp	SHORT $L72784
$L72785:

; 1499 : 
; 1500 : 	// if model is more additive than opaque
; 1501 : 	if( trans > opaque )

	mov	eax, DWORD PTR _trans$[ebp]
	cmp	eax, DWORD PTR _opaque$[ebp]
	jle	SHORT $L72788

; 1502 : 		return kRenderTransAdd;

	mov	eax, 5
	jmp	SHORT $L72765
$L72788:

; 1503 : 	return ent->curstate.rendermode;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [ecx+760]
$L72765:

; 1504 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetEntityRenderMode@CStudioModelRenderer@@QAEHPAUcl_entity_s@@@Z ENDP ; CStudioModelRenderer::GetEntityRenderMode
_TEXT	ENDS
;	COMDAT ?StudioExtractBbox@CStudioModelRenderer@@EAEHPAUcl_entity_s@@PAUstudiohdr_t@@HAAVVector@@2@Z
_TEXT	SEGMENT
_phdr$ = 12
_sequence$ = 16
_mins$ = 20
_maxs$ = 24
_this$ = -4
_pseqdesc$ = -8
?StudioExtractBbox@CStudioModelRenderer@@EAEHPAUcl_entity_s@@PAUstudiohdr_t@@HAAVVector@@2@Z PROC NEAR ; CStudioModelRenderer::StudioExtractBbox, COMDAT

; 1514 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1515 : 	if( !phdr || sequence < 0 || sequence >= phdr->numseq )

	cmp	DWORD PTR _phdr$[ebp], 0
	je	SHORT $L72798
	cmp	DWORD PTR _sequence$[ebp], 0
	jl	SHORT $L72798
	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _sequence$[ebp]
	cmp	ecx, DWORD PTR [eax+164]
	jl	SHORT $L72797
$L72798:

; 1516 : 		return 0;

	xor	eax, eax
	jmp	SHORT $L72796
$L72797:

; 1517 : 
; 1518 : 	mstudioseqdesc_t *pseqdesc = (mstudioseqdesc_t *)((byte *)phdr + phdr->seqindex);

	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	add	eax, DWORD PTR [edx+168]
	mov	DWORD PTR _pseqdesc$[ebp], eax

; 1519 : 	mins = pseqdesc[sequence].bbmin;

	mov	ecx, DWORD PTR _sequence$[ebp]
	imul	ecx, 176				; 000000b0H
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	lea	eax, DWORD PTR [edx+ecx+96]
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1520 : 	maxs = pseqdesc[sequence].bbmax;

	mov	ecx, DWORD PTR _sequence$[ebp]
	imul	ecx, 176				; 000000b0H
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	lea	eax, DWORD PTR [edx+ecx+108]
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1521 : 
; 1522 : 	return 1;

	mov	eax, 1
$L72796:

; 1523 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?StudioExtractBbox@CStudioModelRenderer@@EAEHPAUcl_entity_s@@PAUstudiohdr_t@@HAAVVector@@2@Z ENDP ; CStudioModelRenderer::StudioExtractBbox
_TEXT	ENDS
PUBLIC	??0matrix4x4@@QAE@ABVmatrix3x4@@@Z		; matrix4x4::matrix4x4
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	__real@4@40038000000000000000
PUBLIC	??0matrix3x4@@QAE@ABVVector@@00@Z		; matrix3x4::matrix3x4
EXTRN	?TransformAABB@@YAXABVmatrix4x4@@ABVVector@@1AAV2@2@Z:NEAR ; TransformAABB
EXTRN	?RadiusFromBounds@@YAMABVVector@@0@Z:NEAR	; RadiusFromBounds
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
;	COMDAT __real@4@40038000000000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@4@40038000000000000000 DD 041800000r	; 16
CONST	ENDS
;	COMDAT ?StudioComputeBBox@CStudioModelRenderer@@EAEHPAUcl_entity_s@@@Z
_TEXT	SEGMENT
_e$ = 8
_this$ = -4
_scale$ = -16
_angles$ = -28
_mins$ = -40
_maxs$ = -52
_transform$ = -100
$T76111 = -112
$T76112 = -124
$T76113 = -172
$T76114 = -236
$T76115 = -248
$T76116 = -260
?StudioComputeBBox@CStudioModelRenderer@@EAEHPAUcl_entity_s@@@Z PROC NEAR ; CStudioModelRenderer::StudioComputeBBox, COMDAT

; 1533 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1534 : 	Vector scale = Vector( 1.0f, 1.0f, 1.0f );

	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR $T76111[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _scale$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1535 : 	Vector angles, mins, maxs;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _mins$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _maxs$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1536 : 
; 1537 : 	if( FBitSet( m_pModelInstance->info_flags, MF_STATIC_BOUNDS ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 1
	test	edx, edx
	je	SHORT $L72811

; 1538 : 		return true; // bounds already computed

	mov	eax, 1
	jmp	$L72805
$L72811:

; 1539 : 
; 1540 : 	if( !StudioExtractBbox( e, m_pStudioHeader, e->curstate.sequence, mins, maxs ))

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+732]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+12]
	test	eax, eax
	jne	SHORT $L72812

; 1541 : 		return false;

	xor	eax, eax
	jmp	$L72805
$L72812:

; 1542 : 
; 1543 : 	if( m_pModelInstance->m_bProceduralBones )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+26908]
	test	edx, edx
	je	SHORT $L72813

; 1545 : 		mins = e->curstate.mins;

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 812				; 0000032cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mins$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mins$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _mins$[ebp+8], eax

; 1546 : 		maxs = e->curstate.maxs;

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 824				; 00000338H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _maxs$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _maxs$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _maxs$[ebp+8], ecx
$L72813:

; 1548 : 
; 1549 : 	// prevent to compute env_static bounds every frame
; 1550 : 	if( FBitSet( e->curstate.iuser1, CF_STATIC_ENTITY ))

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+948]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $L72814

; 1551 : 		SetBits( m_pModelInstance->info_flags, MF_STATIC_BOUNDS );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR [edx+16]
	or	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	DWORD PTR [edx+16], eax
$L72814:

; 1552 : 
; 1553 : 	if( FBitSet( e->curstate.iuser1, CF_STATIC_ENTITY ))

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+948]
	and	ecx, 64					; 00000040H
	test	ecx, ecx
	je	SHORT $L72815

; 1555 : 		if( e->curstate.startpos != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 916				; 00000394H
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L72816

; 1556 : 			scale = e->curstate.startpos;

	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 916				; 00000394H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _scale$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _scale$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _scale$[ebp+8], edx
$L72816:

; 1558 : 	else if( e->curstate.scale > 0.0f && e->curstate.scale <= 16.0f )

	jmp	SHORT $L72818
$L72815:
	mov	eax, DWORD PTR _e$[ebp]
	fld	DWORD PTR [eax+752]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L72818
	mov	ecx, DWORD PTR _e$[ebp]
	fld	DWORD PTR [ecx+752]
	fcomp	DWORD PTR __real@4@40038000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L72818

; 1560 : 		// apply studiomodel scale (clamp scale to prevent too big sizes on some HL maps)
; 1561 : 		scale = Vector( e->curstate.scale, e->curstate.scale, e->curstate.scale );

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+752]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+752]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+752]
	push	ecx
	lea	ecx, DWORD PTR $T76112[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _scale$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _scale$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _scale$[ebp+8], edx
$L72818:

; 1563 : 
; 1564 : 	// rotate the bounding box
; 1565 : 	angles = e->angles;

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 2900				; 00000b54H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _angles$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _angles$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _angles$[ebp+8], eax

; 1566 : 
; 1567 : 	// don't rotate player model, only aim
; 1568 : 	if( e->player ) angles[PITCH] = 0;

	mov	ecx, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L72820
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0
$L72820:

; 1569 : 
; 1570 : 	matrix3x4 transform = matrix3x4( g_vecZero, angles, scale );

	lea	edx, DWORD PTR _scale$[ebp]
	push	edx
	lea	eax, DWORD PTR _angles$[ebp]
	push	eax
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR $T76113[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@00@Z	; matrix3x4::matrix3x4
	push	eax
	lea	ecx, DWORD PTR _transform$[ebp]
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4

; 1571 : 
; 1572 : 	// rotate and scale bbox for env_static
; 1573 : 	TransformAABB( transform, mins, maxs, mins, maxs );

	lea	ecx, DWORD PTR _transform$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T76114[ebp]
	call	??0matrix4x4@@QAE@ABVmatrix3x4@@@Z	; matrix4x4::matrix4x4
	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	lea	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mins$[ebp]
	push	edx
	lea	eax, DWORD PTR $T76114[ebp]
	push	eax
	call	?TransformAABB@@YAXABVmatrix4x4@@ABVVector@@1AAV2@2@Z ; TransformAABB
	add	esp, 20					; 00000014H

; 1574 : 
; 1575 : 	// compute abs box
; 1576 : 	m_pModelInstance->absmin = mins + e->origin;

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 2888				; 00000b48H
	push	ecx
	lea	edx, DWORD PTR $T76115[ebp]
	push	edx
	lea	ecx, DWORD PTR _mins$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 156				; 0000009cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1577 : 	m_pModelInstance->absmax = maxs + e->origin;

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 2888				; 00000b48H
	push	ecx
	lea	edx, DWORD PTR $T76116[ebp]
	push	edx
	lea	ecx, DWORD PTR _maxs$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1578 : 	m_pModelInstance->radius = RadiusFromBounds( mins, maxs );

	lea	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mins$[ebp]
	push	edx
	call	?RadiusFromBounds@@YAMABVVector@@0@Z	; RadiusFromBounds
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	fstp	DWORD PTR [ecx+180]

; 1579 : 
; 1580 : 	return true;

	mov	eax, 1
$L72805:

; 1581 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StudioComputeBBox@CStudioModelRenderer@@EAEHPAUcl_entity_s@@@Z ENDP ; CStudioModelRenderer::StudioComputeBBox
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L76125
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L76125
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L76125
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L76126
$L76125:
	mov	DWORD PTR -8+[ebp], 0
$L76126:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
$T76129 = -16
___$ReturnUdt$ = 8
_this$ = -4
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T76129[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
PUBLIC	?SinCos@@YAXMPAM0@Z				; SinCos
PUBLIC	__real@8@3ff98efa351294e9c800
;	COMDAT __real@8@3ff98efa351294e9c800
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@8@3ff98efa351294e9c800 DQ 03f91df46a2529d39r ; 0.0174533
CONST	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@00@Z
_TEXT	SEGMENT
_this$ = -4
_angle$ = -8
_sr$ = -12
_sp$ = -16
_sy$ = -20
_cr$ = -24
_cp$ = -28
_cy$ = -32
_origin$ = 8
_angles$ = 12
_scale$ = 16
??0matrix3x4@@QAE@ABVVector@@00@Z PROC NEAR		; matrix3x4::matrix3x4, COMDAT

; 273  : 	_forceinline matrix3x4( const Vector &origin, const Vector &angles, const Vector &scale )

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 274  : 	{
; 275  : 		float	angle, sr, sp, sy, cr, cp, cy;
; 276  : 
; 277  : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L55392

; 279  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 280  : 			SinCos( angle, &sy, &cy );

	lea	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 281  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 282  : 			SinCos( angle, &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 283  : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 284  : 			SinCos( angle, &sr, &cr );

	lea	ecx, DWORD PTR _cr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sr$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 285  : 
; 286  : 			mat[0][0] = (cp*cy) * scale.x;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	mov	ecx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax], edx

; 287  : 			mat[1][0] = (sr*sp*cy+cr*-sy) * scale.y;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _cr$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax], ecx

; 288  : 			mat[2][0] = (cr*sp*cy+-sr*-sy) * scale.z;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR [eax], ecx

; 289  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 290  : 			mat[0][1] = (cp*sy) * scale.x;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 291  : 			mat[1][1] = (sr*sp*sy+cr*cy) * scale.y;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+4]
	fstp	DWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 292  : 			mat[2][1] = (cr*sp*sy+-sr*cy) * scale.z;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 293  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 294  : 			mat[0][2] = (-sp) * scale.x;

	fld	DWORD PTR _sp$[ebp]
	fchs
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 295  : 			mat[1][2] = (sr*cp) * scale.y;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+4]
	fstp	DWORD PTR -64+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 			mat[2][2] = (cr*cp) * scale.z;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 297  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 299  : 		else if( angles[PITCH] )

	jmp	$L55397
$L55392:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L55394

; 301  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 302  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 303  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 304  : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 305  : 
; 306  : 			mat[0][0] = (cp*cy) * scale.x;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -72+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -72+[ebp]
	mov	DWORD PTR [eax], ecx

; 307  : 			mat[1][0] = (-sy) * scale.y;

	fld	DWORD PTR _sy$[ebp]
	fchs
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+4]
	fstp	DWORD PTR -76+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -76+[ebp]
	mov	DWORD PTR [eax], ecx

; 308  : 			mat[2][0] = (sp*cy) * scale.z;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR -80+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -80+[ebp]
	mov	DWORD PTR [eax], ecx

; 309  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 310  : 			mat[0][1] = (cp*sy) * scale.x;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -84+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -84+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 311  : 			mat[1][1] = (cy) * scale.y;

	mov	edx, DWORD PTR _scale$[ebp]
	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR [edx+4]
	fstp	DWORD PTR -88+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -88+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 312  : 			mat[2][1] = (sp*sy) * scale.z;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR -92+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -92+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 313  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 314  : 			mat[0][2] = (-sp) * scale.x;

	fld	DWORD PTR _sp$[ebp]
	fchs
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -96+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -96+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 315  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 316  : 			mat[2][2] = (cp) * scale.z;

	mov	edx, DWORD PTR _scale$[ebp]
	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR -100+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -100+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 317  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 319  : 		else if( angles[YAW] )

	jmp	$L55397
$L55394:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L55396

; 321  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 322  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 323  : 
; 324  : 			mat[0][0] = (cy) * scale.x;

	mov	edx, DWORD PTR _scale$[ebp]
	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -104+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -104+[ebp]
	mov	DWORD PTR [eax], ecx

; 325  : 			mat[1][0] = (-sy) * scale.y;

	fld	DWORD PTR _sy$[ebp]
	fchs
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+4]
	fstp	DWORD PTR -108+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -108+[ebp]
	mov	DWORD PTR [eax], ecx

; 326  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 327  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 328  : 			mat[0][1] = (sy) * scale.x;

	mov	edx, DWORD PTR _scale$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -112+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -112+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 329  : 			mat[1][1] = (cy) * scale.y;

	mov	edx, DWORD PTR _scale$[ebp]
	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR [edx+4]
	fstp	DWORD PTR -116+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -116+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 330  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 331  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 332  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 333  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 334  : 			mat[2][2] = scale.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 335  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 337  : 		else

	jmp	$L55397
$L55396:

; 339  : 			mat[0][0] = scale.x;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 340  : 			mat[1][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 341  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 342  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 343  : 			mat[0][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 344  : 			mat[1][1] = scale.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 345  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 346  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 347  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 348  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 349  : 			mat[2][2] = scale.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 350  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
$L55397:

; 352  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0matrix3x4@@QAE@ABVVector@@00@Z ENDP			; matrix3x4::matrix3x4
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT
_angle$ = 8
_sine$ = 12
_cosine$ = 16
?SinCos@@YAXMPAM0@Z PROC NEAR				; SinCos, COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 37   : 	__asm
; 38   : 	{
; 39   : 		push	ecx

	push	ecx

; 40   : 		fld	dword ptr angle

	fld	DWORD PTR _angle$[ebp]

; 41   : 		fsincos

	fsincos

; 42   : 		mov	ecx, dword ptr[cosine]

	mov	ecx, DWORD PTR _cosine$[ebp]

; 43   : 		fstp      dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 44   : 		mov 	ecx, dword ptr[sine]

	mov	ecx, DWORD PTR _sine$[ebp]

; 45   : 		fstp	dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 46   : 		pop	ecx

	pop	ecx

; 47   : 	}
; 48   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SinCos@@YAXMPAM0@Z ENDP				; SinCos
_TEXT	ENDS
PUBLIC	??BVector4D@@QAEPAMXZ				; Vector4D::operator float *
;	COMDAT ??0matrix4x4@@QAE@ABVmatrix3x4@@@Z
_TEXT	SEGMENT
_in$ = 8
_this$ = -4
??0matrix4x4@@QAE@ABVmatrix3x4@@@Z PROC NEAR		; matrix4x4::matrix4x4, COMDAT

; 918  : 	_forceinline matrix4x4( const matrix3x4 &in )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 919  : 	{
; 920  : 		mat[0][0] = in[0][0];

	push	0
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 921  : 		mat[0][1] = in[0][1];

	push	0
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx

; 922  : 		mat[0][2] = in[0][2];

	push	0
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx

; 923  : 		mat[1][0] = in[1][0];

	push	1
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx

; 924  : 		mat[1][1] = in[1][1];

	push	1
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx

; 925  : 		mat[1][2] = in[1][2];

	push	1
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx

; 926  : 		mat[2][0] = in[2][0];

	push	2
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 927  : 		mat[2][1] = in[2][1];

	push	2
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx

; 928  : 		mat[2][2] = in[2][2];

	push	2
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx

; 929  : 		mat[3][0] = in[3][0];

	push	3
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx

; 930  : 		mat[3][1] = in[3][1];

	push	3
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx

; 931  : 		mat[3][2] = in[3][2];

	push	3
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx

; 932  : 		mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 933  : 		mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 934  : 		mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 935  : 		mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 936  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix4x4@@QAE@ABVmatrix3x4@@@Z ENDP			; matrix4x4::matrix4x4
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector4D@@QAEPAMXZ PROC NEAR				; Vector4D::operator float *, COMDAT

; 325  : 	operator float *()					{ return &x; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector4D@@QAEPAMXZ ENDP				; Vector4D::operator float *
_TEXT	ENDS
PUBLIC	__real@4@4000c000000000000000
PUBLIC	__real@4@3ffbcccccd0000000000
EXTRN	__ftol:NEAR
;	COMDAT __real@4@4000c000000000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@4@4000c000000000000000 DD 040400000r	; 3
CONST	ENDS
;	COMDAT __real@4@3ffbcccccd0000000000
CONST	SEGMENT
__real@4@3ffbcccccd0000000000 DD 03dcccccdr	; 0.1
CONST	ENDS
;	COMDAT ?StudioPlayerBlend@CStudioModelRenderer@@EAEXPAUmstudioseqdesc_t@@AAHAAM@Z
_TEXT	SEGMENT
_pseqdesc$ = 8
_pBlend$ = 12
_pPitch$ = 16
_this$ = -4
?StudioPlayerBlend@CStudioModelRenderer@@EAEXPAUmstudioseqdesc_t@@AAHAAM@Z PROC NEAR ; CStudioModelRenderer::StudioPlayerBlend, COMDAT

; 1590 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1591 : 	pBlend = (pPitch * 3.0f);

	mov	eax, DWORD PTR _pPitch$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR __real@4@4000c000000000000000
	call	__ftol
	mov	ecx, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [ecx], eax

; 1592 : 
; 1593 : 	if( pBlend < pseqdesc->blendstart[0] )

	mov	edx, DWORD PTR _pBlend$[ebp]
	fild	DWORD PTR [edx]
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	fcomp	DWORD PTR [eax+136]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72832

; 1595 : 		pPitch -= pseqdesc->blendstart[0] / 3.0f;

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	fld	DWORD PTR [ecx+136]
	fdiv	DWORD PTR __real@4@4000c000000000000000
	mov	edx, DWORD PTR _pPitch$[ebp]
	fsubr	DWORD PTR [edx]
	mov	eax, DWORD PTR _pPitch$[ebp]
	fstp	DWORD PTR [eax]

; 1596 : 		pBlend = 0;

	mov	ecx, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [ecx], 0

; 1598 : 	else if( pBlend > pseqdesc->blendend[0] )

	jmp	$L72835
$L72832:
	mov	edx, DWORD PTR _pBlend$[ebp]
	fild	DWORD PTR [edx]
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	fcomp	DWORD PTR [eax+144]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L72834

; 1600 : 		pPitch -= pseqdesc->blendend[0] / 3.0f;

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	fld	DWORD PTR [ecx+144]
	fdiv	DWORD PTR __real@4@4000c000000000000000
	mov	edx, DWORD PTR _pPitch$[ebp]
	fsubr	DWORD PTR [edx]
	mov	eax, DWORD PTR _pPitch$[ebp]
	fstp	DWORD PTR [eax]

; 1601 : 		pBlend = 255;

	mov	ecx, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [ecx], 255			; 000000ffH

; 1603 : 	else

	jmp	SHORT $L72835
$L72834:

; 1605 : 		if( pseqdesc->blendend[0] - pseqdesc->blendstart[0] < 0.1f ) // catch qc error

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	fld	DWORD PTR [edx+144]
	fsub	DWORD PTR [eax+136]
	fcomp	DWORD PTR __real@4@3ffbcccccd0000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72836

; 1606 : 			pBlend = 127;

	mov	ecx, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [ecx], 127			; 0000007fH

; 1607 : 		else pBlend = 255 * (pBlend - pseqdesc->blendstart[0]) / (pseqdesc->blendend[0] - pseqdesc->blendstart[0]);

	jmp	SHORT $L72837
$L72836:
	mov	edx, DWORD PTR _pBlend$[ebp]
	fild	DWORD PTR [edx]
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	fsub	DWORD PTR [eax+136]
	fmul	DWORD PTR __real@4@4006ff00000000000000
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	fld	DWORD PTR [ecx+144]
	fsub	DWORD PTR [edx+136]
	fdivp	ST(1), ST(0)
	call	__ftol
	mov	ecx, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [ecx], eax
$L72837:

; 1608 : 
; 1609 : 		pPitch = 0;

	mov	edx, DWORD PTR _pPitch$[ebp]
	mov	DWORD PTR [edx], 0
$L72835:

; 1611 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StudioPlayerBlend@CStudioModelRenderer@@EAEXPAUmstudioseqdesc_t@@AAHAAM@Z ENDP ; CStudioModelRenderer::StudioPlayerBlend
_TEXT	ENDS
PUBLIC	__real@4@4005c800000000000000
EXTRN	?LocalMaxFrame@CStudioBoneSetup@@QAEHH@Z:NEAR	; CStudioBoneSetup::LocalMaxFrame
;	COMDAT __real@4@4005c800000000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@4@4005c800000000000000 DD 042c80000r	; 100
CONST	ENDS
;	COMDAT ?AddBlendSequence@CStudioModelRenderer@@EAEXHHM_N@Z
_TEXT	SEGMENT
_oldseq$ = 8
_newseq$ = 12
_prevframe$ = 16
_gaitseq$ = 20
_this$ = -4
_poldseqdesc$ = -8
_pnewseqdesc$ = -12
_pseqblending$72852 = -16
?AddBlendSequence@CStudioModelRenderer@@EAEXHHM_N@Z PROC NEAR ; CStudioModelRenderer::AddBlendSequence, COMDAT

; 1614 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1615 : 	mstudioseqdesc_t *poldseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + oldseq;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+168]
	mov	ecx, DWORD PTR _oldseq$[ebp]
	imul	ecx, 176				; 000000b0H
	add	eax, ecx
	mov	DWORD PTR _poldseqdesc$[ebp], eax

; 1616 : 	mstudioseqdesc_t *pnewseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + newseq;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	add	edx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR _newseq$[ebp]
	imul	eax, 176				; 000000b0H
	add	edx, eax
	mov	DWORD PTR _pnewseqdesc$[ebp], edx

; 1617 : 
; 1618 : 	// sequence has changed, hold the previous sequence info
; 1619 : 	if( oldseq != newseq && !FBitSet( pnewseqdesc->flags, STUDIO_SNAP ))

	mov	ecx, DWORD PTR _oldseq$[ebp]
	cmp	ecx, DWORD PTR _newseq$[ebp]
	je	$L72853
	mov	edx, DWORD PTR _pnewseqdesc$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 2
	test	eax, eax
	jne	$L72853

; 1621 : 		mstudioblendseq_t	*pseqblending;
; 1622 : 
; 1623 : 		// move current sequence into circular buffer
; 1624 : 		m_pModelInstance->m_current_seqblend = (m_pModelInstance->m_current_seqblend + 1) & MASK_SEQBLENDS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR [edx+7276]
	add	eax, 1
	and	eax, 7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	DWORD PTR [edx+7276], eax

; 1625 : 
; 1626 : 		pseqblending = &m_pModelInstance->m_seqblend[m_pModelInstance->m_current_seqblend];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	edx, DWORD PTR [eax+7276]
	imul	edx, 20					; 00000014H
	lea	eax, DWORD PTR [ecx+edx+7116]
	mov	DWORD PTR _pseqblending$72852[ebp], eax

; 1627 : 
; 1628 : 		pseqblending->blendtime = tr.time;

	fld	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	mov	ecx, DWORD PTR _pseqblending$72852[ebp]
	fstp	DWORD PTR [ecx]

; 1629 : 		pseqblending->sequence = oldseq;

	mov	edx, DWORD PTR _pseqblending$72852[ebp]
	mov	eax, DWORD PTR _oldseq$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1630 : 		pseqblending->cycle = prevframe / m_boneSetup.LocalMaxFrame( oldseq );

	mov	ecx, DWORD PTR _oldseq$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?LocalMaxFrame@CStudioBoneSetup@@QAEHH@Z ; CStudioBoneSetup::LocalMaxFrame
	mov	DWORD PTR -20+[ebp], eax
	fild	DWORD PTR -20+[ebp]
	fdivr	DWORD PTR _prevframe$[ebp]
	mov	edx, DWORD PTR _pseqblending$72852[ebp]
	fstp	DWORD PTR [edx+8]

; 1631 : 		pseqblending->gaitseq = gaitseq;

	mov	eax, DWORD PTR _pseqblending$72852[ebp]
	mov	cl, BYTE PTR _gaitseq$[ebp]
	mov	BYTE PTR [eax+16], cl

; 1632 : 		pseqblending->fadeout = Q_min( poldseqdesc->fadeouttime / 100.0f, pnewseqdesc->fadeintime / 100.0f );

	mov	edx, DWORD PTR _poldseqdesc$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+171]
	mov	DWORD PTR -24+[ebp], eax
	fild	DWORD PTR -24+[ebp]
	fdiv	DWORD PTR __real@4@4005c800000000000000
	mov	ecx, DWORD PTR _pnewseqdesc$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+170]
	mov	DWORD PTR -28+[ebp], edx
	fild	DWORD PTR -28+[ebp]
	fdiv	DWORD PTR __real@4@4005c800000000000000
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76149
	mov	eax, DWORD PTR _poldseqdesc$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+171]
	mov	DWORD PTR -32+[ebp], ecx
	fild	DWORD PTR -32+[ebp]
	fdiv	DWORD PTR __real@4@4005c800000000000000
	fstp	DWORD PTR -36+[ebp]
	jmp	SHORT $L76150
$L76149:
	mov	edx, DWORD PTR _pnewseqdesc$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+170]
	mov	DWORD PTR -40+[ebp], eax
	fild	DWORD PTR -40+[ebp]
	fdiv	DWORD PTR __real@4@4005c800000000000000
	fstp	DWORD PTR -36+[ebp]
$L76150:
	mov	ecx, DWORD PTR _pseqblending$72852[ebp]
	mov	edx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [ecx+12], edx

; 1633 : 		if( pseqblending->fadeout <= 0.0f )

	mov	eax, DWORD PTR _pseqblending$72852[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L72853

; 1634 : 			pseqblending->fadeout = 0.2f; // force to default

	mov	ecx, DWORD PTR _pseqblending$72852[ebp]
	mov	DWORD PTR [ecx+12], 1045220557		; 3e4ccccdH
$L72853:

; 1636 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddBlendSequence@CStudioModelRenderer@@EAEXHHM_N@Z ENDP ; CStudioModelRenderer::AddBlendSequence
_TEXT	ENDS
PUBLIC	?CalcStairSmoothValue@CStudioModelRenderer@@AAEMMMMM@Z ; CStudioModelRenderer::CalcStairSmoothValue
;	COMDAT ?CalcStairSmoothValue@CStudioModelRenderer@@AAEMMMMM@Z
_TEXT	SEGMENT
_oldz$ = 8
_newz$ = 12
_smoothtime$ = 16
_smoothvalue$ = 20
_this$ = -4
?CalcStairSmoothValue@CStudioModelRenderer@@AAEMMMMM@Z PROC NEAR ; CStudioModelRenderer::CalcStairSmoothValue, COMDAT

; 1639 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1640 : 	if( oldz < newz )

	fld	DWORD PTR _oldz$[ebp]
	fcomp	DWORD PTR _newz$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72861

; 1641 : 		return bound( newz - tr.movevars->stepsize, oldz + smoothtime * smoothvalue, newz );

	fld	DWORD PTR _smoothtime$[ebp]
	fmul	DWORD PTR _smoothvalue$[ebp]
	fadd	DWORD PTR _oldz$[ebp]
	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+1411952
	fld	DWORD PTR _newz$[ebp]
	fsub	DWORD PTR [eax+48]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L76157
	fld	DWORD PTR _smoothtime$[ebp]
	fmul	DWORD PTR _smoothvalue$[ebp]
	fadd	DWORD PTR _oldz$[ebp]
	fcomp	DWORD PTR _newz$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L76155
	fld	DWORD PTR _smoothtime$[ebp]
	fmul	DWORD PTR _smoothvalue$[ebp]
	fadd	DWORD PTR _oldz$[ebp]
	fstp	DWORD PTR -8+[ebp]
	jmp	SHORT $L76156
$L76155:
	mov	ecx, DWORD PTR _newz$[ebp]
	mov	DWORD PTR -8+[ebp], ecx
$L76156:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR -12+[ebp], edx
	jmp	SHORT $L76158
$L76157:
	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+1411952
	fld	DWORD PTR _newz$[ebp]
	fsub	DWORD PTR [eax+48]
	fstp	DWORD PTR -12+[ebp]
$L76158:
	fld	DWORD PTR -12+[ebp]
	jmp	SHORT $L72860
$L72861:

; 1642 : 	if( oldz > newz )

	fld	DWORD PTR _oldz$[ebp]
	fcomp	DWORD PTR _newz$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L72862

; 1643 : 		return bound( newz, oldz - smoothtime * smoothvalue, newz + tr.movevars->stepsize );

	fld	DWORD PTR _smoothtime$[ebp]
	fmul	DWORD PTR _smoothvalue$[ebp]
	fsubr	DWORD PTR _oldz$[ebp]
	fcomp	DWORD PTR _newz$[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L76161
	fld	DWORD PTR _smoothtime$[ebp]
	fmul	DWORD PTR _smoothvalue$[ebp]
	fsubr	DWORD PTR _oldz$[ebp]
	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1411952
	fld	DWORD PTR _newz$[ebp]
	fadd	DWORD PTR [ecx+48]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76159
	fld	DWORD PTR _smoothtime$[ebp]
	fmul	DWORD PTR _smoothvalue$[ebp]
	fsubr	DWORD PTR _oldz$[ebp]
	fstp	DWORD PTR -16+[ebp]
	jmp	SHORT $L76160
$L76159:
	mov	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1411952
	fld	DWORD PTR _newz$[ebp]
	fadd	DWORD PTR [edx+48]
	fstp	DWORD PTR -16+[ebp]
$L76160:
	mov	eax, DWORD PTR -16+[ebp]
	mov	DWORD PTR -20+[ebp], eax
	jmp	SHORT $L76162
$L76161:
	mov	ecx, DWORD PTR _newz$[ebp]
	mov	DWORD PTR -20+[ebp], ecx
$L76162:
	fld	DWORD PTR -20+[ebp]
	jmp	SHORT $L72860
$L72862:

; 1644 : 	return 0.0f;

	fld	DWORD PTR __real@4@00000000000000000000
$L72860:

; 1645 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CalcStairSmoothValue@CStudioModelRenderer@@AAEMMMMM@Z ENDP ; CStudioModelRenderer::CalcStairSmoothValue
_TEXT	ENDS
PUBLIC	??_C@_09DLNN@studioLOD?$AA@			; `string'
;	COMDAT ??_C@_09DLNN@studioLOD?$AA@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_C@_09DLNN@studioLOD?$AA@ DB 'studioLOD', 00H		; `string'
CONST	ENDS
;	COMDAT ?StudioCheckLOD@CStudioModelRenderer@@EAEHXZ
_TEXT	SEGMENT
_this$ = -4
_m_pBodyPart$ = -8
_i$ = -12
?StudioCheckLOD@CStudioModelRenderer@@EAEHXZ PROC NEAR	; CStudioModelRenderer::StudioCheckLOD, COMDAT

; 1648 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1649 : 	mstudiobodyparts_t    *m_pBodyPart;
; 1650 :     
; 1651 : 	for( int i = 0; i < m_pStudioHeader->numbodyparts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72869
$L72870:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L72869:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+204]
	jge	SHORT $L72871

; 1653 : 		m_pBodyPart = (mstudiobodyparts_t *)((byte *)m_pStudioHeader + m_pStudioHeader->bodypartindex) + i;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+208]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 76					; 0000004cH
	add	ecx, edx
	mov	DWORD PTR _m_pBodyPart$[ebp], ecx

; 1654 :         
; 1655 : 		if( !Q_stricmp( m_pBodyPart->name, "studioLOD" ))

	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_09DLNN@studioLOD?$AA@	; `string'
	mov	eax, DWORD PTR _m_pBodyPart$[ebp]
	push	eax
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L72874

; 1656 : 			return m_pBodyPart->nummodels;

	mov	ecx, DWORD PTR _m_pBodyPart$[ebp]
	mov	eax, DWORD PTR [ecx+64]
	jmp	SHORT $L72866
$L72874:

; 1657 : 	}

	jmp	SHORT $L72870
$L72871:

; 1658 : 
; 1659 : 	return 0; // no lod-levels for this model

	xor	eax, eax
$L72866:

; 1660 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioCheckLOD@CStudioModelRenderer@@EAEHXZ ENDP	; CStudioModelRenderer::StudioCheckLOD
_TEXT	ENDS
PUBLIC	?GetRight@matrix3x4@@QBE?AVVector@@XZ		; matrix3x4::GetRight
PUBLIC	?SetRight@matrix3x4@@QAEXABVVector@@@Z		; matrix3x4::SetRight
PUBLIC	??GVector@@QBE?AV0@XZ				; Vector::operator-
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	__real@8@00000000000000000000
PUBLIC	__real@8@3ffbcccccd0000000000
EXTRN	_fabs:NEAR
;	COMDAT __real@8@00000000000000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@8@00000000000000000000 DQ 00000000000000000r ; 0
CONST	ENDS
;	COMDAT __real@8@3ffbcccccd0000000000
CONST	SEGMENT
__real@8@3ffbcccccd0000000000 DQ 03fb99999a0000000r ; 0.1
CONST	ENDS
;	COMDAT ?StudioSetUpTransform@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
_e$ = -8
_disable_smooth$ = -12
_step$ = -16
_smoothtime$ = -20
_origin$ = -32
_angles$ = -44
_scale$ = -56
_lodDist$ = -60
_radius$ = -64
_lodnum$ = -68
_numLods$ = -72
_iBlend$72908 = -76
_m_iGaitSequence$72909 = -80
_pseqdesc$72910 = -84
$T76171 = -96
$T76172 = -108
$T76181 = -120
$T76182 = -168
$T76185 = -180
$T76186 = -192
?StudioSetUpTransform@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::StudioSetUpTransform, COMDAT

; 1669 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1670 : 	cl_entity_t	*e = m_pCurrentEntity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	DWORD PTR _e$[ebp], ecx

; 1671 : 	qboolean		disable_smooth = false;

	mov	DWORD PTR _disable_smooth$[ebp], 0

; 1672 : 	float		step, smoothtime;
; 1673 : 
; 1674 : 	if( !m_fShootDecal && m_pCurrentEntity->curstate.renderfx != kRenderFxDeadPlayer )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+92]
	test	eax, eax
	jne	$L72891
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	cmp	DWORD PTR [edx+772], 17			; 00000011H
	je	$L72891

; 1676 : 		// calculate how much time has passed since the last V_CalcRefdef
; 1677 : 		smoothtime = bound( 0.0f, tr.time - m_pModelInstance->lerp.stairtime, 0.1f );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	fld	DWORD PTR [ecx+7296]
	fsubr	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L76169
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	fld	DWORD PTR [eax+7296]
	fsubr	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fcomp	QWORD PTR __real@8@3ffbcccccd0000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L76167
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	fld	DWORD PTR [edx+7296]
	fsubr	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fstp	QWORD PTR -200+[ebp]
	jmp	SHORT $L76168
$L76167:
	mov	DWORD PTR -200+[ebp], -1610612736	; a0000000H
	mov	DWORD PTR -200+[ebp+4], 1069128089	; 3fb99999H
$L76168:
	mov	eax, DWORD PTR -200+[ebp]
	mov	DWORD PTR -208+[ebp], eax
	mov	ecx, DWORD PTR -200+[ebp+4]
	mov	DWORD PTR -208+[ebp+4], ecx
	jmp	SHORT $L76170
$L76169:
	mov	DWORD PTR -208+[ebp], 0
	mov	DWORD PTR -208+[ebp+4], 0
$L76170:
	fld	QWORD PTR -208+[ebp]
	fstp	DWORD PTR _smoothtime$[ebp]

; 1678 : 		m_pModelInstance->lerp.stairtime = tr.time;

	fld	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fst	DWORD PTR -212+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	fstp	DWORD PTR [eax+7296]

; 1679 : 
; 1680 : 		if( e->curstate.onground == -1 || FBitSet( e->curstate.effects, EF_NOINTERP ))

	mov	ecx, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [ecx+896], -1
	je	SHORT $L72886
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+748]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $L72885
$L72886:

; 1681 : 			disable_smooth = true;

	mov	DWORD PTR _disable_smooth$[ebp], 1
$L72885:

; 1682 : 
; 1683 : 		if( e->curstate.movetype != MOVETYPE_STEP && e->curstate.movetype != MOVETYPE_WALK )

	mov	ecx, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [ecx+776], 4
	je	SHORT $L72887
	mov	edx, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [edx+776], 3
	je	SHORT $L72887

; 1684 : 			disable_smooth = true;

	mov	DWORD PTR _disable_smooth$[ebp], 1
$L72887:

; 1685 : 
; 1686 : 		if( !FBitSet( m_pModelInstance->info_flags, MF_INIT_SMOOTHSTAIRS ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 8
	test	edx, edx
	jne	SHORT $L72888

; 1688 : 			SetBits( m_pModelInstance->info_flags, MF_INIT_SMOOTHSTAIRS );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR [ecx+16]
	or	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	DWORD PTR [ecx+16], edx

; 1689 : 			disable_smooth = true;

	mov	DWORD PTR _disable_smooth$[ebp], 1
$L72888:

; 1691 : 
; 1692 : 		if( disable_smooth )

	cmp	DWORD PTR _disable_smooth$[ebp], 0
	je	SHORT $L72889

; 1694 : 			m_pModelInstance->lerp.stairoldz = e->origin[2];

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+7300], edx

; 1696 : 		else

	jmp	SHORT $L72891
$L72889:

; 1698 : 			step = CalcStairSmoothValue( m_pModelInstance->lerp.stairoldz, e->origin[2], smoothtime, STAIR_INTERP_TIME );

	push	1120403456				; 42c80000H
	mov	eax, DWORD PTR _smoothtime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [eax+7300]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcStairSmoothValue@CStudioModelRenderer@@AAEMMMMM@Z ; CStudioModelRenderer::CalcStairSmoothValue
	fstp	DWORD PTR _step$[ebp]

; 1699 : 			if( step ) m_pModelInstance->lerp.stairoldz = e->origin[2] = step;

	fld	DWORD PTR _step$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72891
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _step$[ebp]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR _step$[ebp]
	mov	DWORD PTR [ecx+7300], edx
$L72891:

; 1702 : 
; 1703 : 	Vector origin = m_pCurrentEntity->origin;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	add	ecx, 2888				; 00000b48H
	push	ecx
	lea	ecx, DWORD PTR _origin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1704 : 	Vector angles = m_pCurrentEntity->angles;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	add	eax, 2900				; 00000b54H
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1705 : 	Vector scale = Vector( 1.0f, 1.0f, 1.0f );

	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR $T76171[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _scale$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1706 : 
; 1707 : 	float lodDist = (origin - RI->vieworg).Length() * tr.lodScale;

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	ecx, 204				; 000000ccH
	push	ecx
	lea	edx, DWORD PTR $T76172[ebp]
	push	edx
	lea	ecx, DWORD PTR _origin$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fmul	DWORD PTR ?tr@@3Uref_globals_t@@A+1411980
	fstp	DWORD PTR _lodDist$[ebp]

; 1708 : 	float  radius = Q_max( m_pModelInstance->radius, 1.0f ); // to avoid division by zero

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	fld	DWORD PTR [ecx+180]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76173
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	fld	DWORD PTR [eax+180]
	fstp	DWORD PTR -216+[ebp]
	jmp	SHORT $L76174
$L76173:
	mov	DWORD PTR -216+[ebp], 1065353216	; 3f800000H
$L76174:
	mov	ecx, DWORD PTR -216+[ebp]
	mov	DWORD PTR _radius$[ebp], ecx

; 1709 : 	int lodnum = (int)( lodDist / radius );

	fld	DWORD PTR _lodDist$[ebp]
	fdiv	DWORD PTR _radius$[ebp]
	call	__ftol
	mov	DWORD PTR _lodnum$[ebp], eax

; 1710 : 	int numLods;
; 1711 : 
; 1712 : 	if( CVAR_TO_BOOL( m_pCvarLodScale ))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+124], 0
	je	SHORT $L76175
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76175
	mov	BYTE PTR -220+[ebp], 1
	jmp	SHORT $L76176
$L76175:
	mov	BYTE PTR -220+[ebp], 0
$L76176:
	mov	edx, DWORD PTR -220+[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72902

; 1713 : 		lodnum /= (int)fabs( m_pCvarLodScale->value );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	fld	DWORD PTR [ecx+12]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	call	__ftol
	mov	ecx, eax
	mov	eax, DWORD PTR _lodnum$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _lodnum$[ebp], eax
$L72902:

; 1714 : 	if( CVAR_TO_BOOL( m_pCvarLodBias ))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+128], 0
	je	SHORT $L76177
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76177
	mov	BYTE PTR -224+[ebp], 1
	jmp	SHORT $L76178
$L76177:
	mov	BYTE PTR -224+[ebp], 0
$L76178:
	mov	edx, DWORD PTR -224+[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72904

; 1715 : 		lodnum += (int)fabs( m_pCvarLodBias->value );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	fld	DWORD PTR [ecx+12]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	call	__ftol
	mov	edx, DWORD PTR _lodnum$[ebp]
	add	edx, eax
	mov	DWORD PTR _lodnum$[ebp], edx
$L72904:

; 1716 : 
; 1717 : 	// apply lodnum to model
; 1718 : 	if(( numLods = StudioCheckLOD( )) != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+164]
	mov	DWORD PTR _numLods$[ebp], eax
	cmp	DWORD PTR _numLods$[ebp], 0
	je	SHORT $L72906

; 1720 : 		// set derived LOD
; 1721 : 		e->curstate.body = Q_min( lodnum, numLods - 1 );

	mov	eax, DWORD PTR _numLods$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _lodnum$[ebp], eax
	jge	SHORT $L76179
	mov	ecx, DWORD PTR _lodnum$[ebp]
	mov	DWORD PTR -228+[ebp], ecx
	jmp	SHORT $L76180
$L76179:
	mov	edx, DWORD PTR _numLods$[ebp]
	sub	edx, 1
	mov	DWORD PTR -228+[ebp], edx
$L76180:
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR -228+[ebp]
	mov	DWORD PTR [eax+788], ecx
$L72906:

; 1723 : 
; 1724 : 	if( m_pPlayerInfo )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+19116], 0
	je	$L72907

; 1726 : 		int		iBlend, m_iGaitSequence = 0;

	mov	DWORD PTR _m_iGaitSequence$72909[ebp], 0

; 1727 : 		mstudioseqdesc_t	*pseqdesc;
; 1728 : 
; 1729 : 		if( m_pCurrentEntity->curstate.renderfx != kRenderFxDeadPlayer )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx+772], 17			; 00000011H
	je	SHORT $L72911

; 1730 : 			m_iGaitSequence = IEngineStudio.GetPlayerState( m_nPlayerIndex )->gaitsequence;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19120]
	push	eax
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+32
	add	esp, 4
	mov	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR _m_iGaitSequence$72909[ebp], ecx
$L72911:

; 1731 : 
; 1732 : 		if( m_iGaitSequence )

	cmp	DWORD PTR _m_iGaitSequence$72909[ebp], 0
	je	$L72912

; 1734 : 			pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->curstate.sequence;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	add	edx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	eax, DWORD PTR [ecx+732]
	imul	eax, 176				; 000000b0H
	add	edx, eax
	mov	DWORD PTR _pseqdesc$72910[ebp], edx

; 1735 : 
; 1736 : 			// calc blend (FXIME: move to the server)
; 1737 : 			StudioPlayerBlend( pseqdesc, iBlend, angles[PITCH] );

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _iBlend$72908[ebp]
	push	ecx
	mov	edx, DWORD PTR _pseqdesc$72910[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+100]

; 1738 : 			m_pCurrentEntity->curstate.blending[0] = iBlend;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	dl, BYTE PTR _iBlend$72908[ebp]
	mov	BYTE PTR [ecx+796], dl

; 1739 : 			m_pCurrentEntity->latched.prevblending[0] = iBlend;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	dl, BYTE PTR _iBlend$72908[ebp]
	mov	BYTE PTR [ecx+2880], dl

; 1740 : 			m_pPlayerInfo->gaitsequence = m_iGaitSequence;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19116]
	mov	edx, DWORD PTR _m_iGaitSequence$72909[ebp]
	mov	DWORD PTR [ecx+380], edx

; 1742 : 		else

	jmp	SHORT $L72915
$L72912:

; 1744 : 			m_pPlayerInfo->gaitsequence = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19116]
	mov	DWORD PTR [ecx+380], 0
$L72915:

; 1746 : 
; 1747 : 		// don't rotate clients, only aim
; 1748 : 		angles[PITCH] = 0.0f;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 1749 : 
; 1750 : 		if( m_pPlayerInfo->gaitsequence != m_pModelInstance->lerp.gaitsequence )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19116]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR [eax+380]
	cmp	eax, DWORD PTR [edx+7292]
	je	SHORT $L72916

; 1752 : 			AddBlendSequence( m_pModelInstance->lerp.gaitsequence, m_pPlayerInfo->gaitsequence, m_pModelInstance->lerp.gaitframe, true );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR [edx+7288]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19116]
	mov	eax, DWORD PTR [edx+380]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR [edx+7292]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+36]

; 1753 : 			m_pModelInstance->lerp.gaitsequence = m_pPlayerInfo->gaitsequence;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19116]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [ecx+380]
	mov	DWORD PTR [eax+7292], ecx
$L72916:

; 1755 : 		m_pModelInstance->lerp.gaitframe = m_pPlayerInfo->gaitframe;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19116]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR [eax+384]
	mov	DWORD PTR [edx+7288], eax
$L72907:

; 1757 : 
; 1758 : 	if( FBitSet( m_pCurrentEntity->curstate.effects, EF_NOINTERP ) || ( tr.realframecount - m_pModelInstance->cached_frame ) > 1 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	eax, DWORD PTR [edx+748]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $L72918
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+1411992
	sub	eax, DWORD PTR [edx+34084]
	cmp	eax, 1
	jle	SHORT $L72917
$L72918:

; 1760 : 		m_pModelInstance->lerp.sequence = m_pCurrentEntity->curstate.sequence;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR [edx+732]
	mov	DWORD PTR [ecx+7284], edx

; 1762 : 	else if( m_pCurrentEntity->curstate.sequence != m_pModelInstance->lerp.sequence )

	jmp	SHORT $L72920
$L72917:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [ecx+732]
	cmp	ecx, DWORD PTR [eax+7284]
	je	SHORT $L72920

; 1764 : 		AddBlendSequence( m_pModelInstance->lerp.sequence, m_pCurrentEntity->curstate.sequence, m_pModelInstance->lerp.frame );

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [eax+7280]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	ecx, DWORD PTR [eax+732]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [eax+7284]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+36]

; 1765 : 		m_pModelInstance->lerp.sequence = m_pCurrentEntity->curstate.sequence;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR [edx+732]
	mov	DWORD PTR [ecx+7284], edx
$L72920:

; 1767 : 
; 1768 : 	// don't blend sequences for a dead player or a viewmodel
; 1769 : 	if( m_fDrawViewModel || m_pCurrentEntity->curstate.renderfx == kRenderFxDeadPlayer )

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+93]
	test	ecx, ecx
	jne	SHORT $L72922
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	cmp	DWORD PTR [eax+772], 17			; 00000011H
	jne	SHORT $L72921
$L72922:

; 1770 : 		memset( &m_pModelInstance->m_seqblend, 0, sizeof( m_pModelInstance->m_seqblend ));

	push	160					; 000000a0H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 7116				; 00001bccH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$L72921:

; 1771 : 
; 1772 : 	if( m_pCurrentEntity->curstate.startpos != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	add	ecx, 916				; 00000394H
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L72923

; 1774 : 		scale = m_pCurrentEntity->curstate.startpos;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	add	edx, 916				; 00000394H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _scale$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _scale$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _scale$[ebp+8], edx

; 1776 : 	else if( m_pCurrentEntity->curstate.scale > 0.0f && m_pCurrentEntity->curstate.scale <= 16.0f )

	jmp	$L72925
$L72923:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	fld	DWORD PTR [ecx+752]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L72925
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	fld	DWORD PTR [eax+752]
	fcomp	DWORD PTR __real@4@40038000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L72925

; 1778 : 		// apply studiomodel scale (clamp scale to prevent too big sizes on some HL maps)
; 1779 : 		scale = Vector( m_pCurrentEntity->curstate.scale, m_pCurrentEntity->curstate.scale, m_pCurrentEntity->curstate.scale );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	eax, DWORD PTR [edx+752]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	eax, DWORD PTR [edx+752]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	eax, DWORD PTR [edx+752]
	push	eax
	lea	ecx, DWORD PTR $T76181[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _scale$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _scale$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _scale$[ebp+8], eax
$L72925:

; 1781 : 
; 1782 : 	// build the rotation matrix
; 1783 : 	m_pModelInstance->m_protationmatrix = matrix3x4( origin, angles, scale );

	lea	ecx, DWORD PTR _scale$[ebp]
	push	ecx
	lea	edx, DWORD PTR _angles$[ebp]
	push	edx
	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76182[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@00@Z	; matrix3x4::matrix3x4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR [ecx+19112]
	add	edi, 11452				; 00002cbcH
	mov	ecx, 12					; 0000000cH
	rep movsd

; 1784 : 	m_pModelInstance->m_plightmatrix = m_pModelInstance->m_protationmatrix;

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+19112]
	add	esi, 11452				; 00002cbcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR [eax+19112]
	add	edi, 11500				; 00002cecH
	mov	ecx, 12					; 0000000cH
	rep movsd

; 1785 : 
; 1786 : 	if( m_pCurrentEntity == GET_VIEWMODEL() && CVAR_TO_BOOL( m_pCvarHand ))

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+208
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+19104], eax
	jne	SHORT $L72928
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+108], 0
	je	SHORT $L76183
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76183
	mov	BYTE PTR -232+[ebp], 1
	jmp	SHORT $L76184
$L76183:
	mov	BYTE PTR -232+[ebp], 0
$L76184:
	mov	edx, DWORD PTR -232+[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72928

; 1788 : 		// inverse the right vector
; 1789 : 		m_pModelInstance->m_protationmatrix.SetRight( -m_pModelInstance->m_protationmatrix.GetRight() );

	lea	eax, DWORD PTR $T76186[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76185[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	add	ecx, 11452				; 00002cbcH
	call	?GetRight@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetRight
	mov	ecx, eax
	call	??GVector@@QBE?AV0@XZ			; Vector::operator-
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 11452				; 00002cbcH
	call	?SetRight@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetRight
$L72928:

; 1791 : 
; 1792 : 	StudioFxTransform( e, m_pModelInstance->m_protationmatrix );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 11452				; 00002cbcH
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+76]

; 1793 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioSetUpTransform@CStudioModelRenderer@@EAEXXZ ENDP	; CStudioModelRenderer::StudioSetUpTransform
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T76193 = -16
??GVector@@QBE?AV0@XZ PROC NEAR				; Vector::operator-, COMDAT

; 146  : 	inline Vector operator-(void) const		{ return Vector(-x,-y,-z);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T76193[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??GVector@@QBE?AV0@XZ ENDP				; Vector::operator-
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T76196 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T76196[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
EXTRN	_sqrt:NEAR
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
;	COMDAT ?GetRight@matrix3x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
?GetRight@matrix3x4@@QBE?AVVector@@XZ PROC NEAR		; matrix3x4::GetRight, COMDAT

; 521  : 	Vector	GetRight() const { return mat[1]; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetRight@matrix3x4@@QBE?AVVector@@XZ ENDP		; matrix3x4::GetRight
_TEXT	ENDS
;	COMDAT ?SetRight@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_vRight$ = 8
_this$ = -4
?SetRight@matrix3x4@@QAEXABVVector@@@Z PROC NEAR	; matrix3x4::SetRight, COMDAT

; 527  : 	void	SetRight( const Vector &vRight ) { mat[1] = vRight; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _vRight$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetRight@matrix3x4@@QAEXABVVector@@@Z ENDP		; matrix3x4::SetRight
_TEXT	ENDS
PUBLIC	__real@8@40078000000000000000
PUBLIC	__real@8@3fff8020c49ba5e35000
;	COMDAT __real@8@40078000000000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@8@40078000000000000000 DQ 04070000000000000r ; 256
CONST	ENDS
;	COMDAT __real@8@3fff8020c49ba5e35000
CONST	SEGMENT
__real@8@3fff8020c49ba5e35000 DQ 03ff004189374bc6ar ; 1.001
CONST	ENDS
;	COMDAT ?StudioEstimateFrame@CStudioModelRenderer@@EAEMPAUmstudioseqdesc_t@@@Z
_TEXT	SEGMENT
_pseqdesc$ = 8
_this$ = -4
_dfdt$ = -12
_f$ = -20
?StudioEstimateFrame@CStudioModelRenderer@@EAEMPAUmstudioseqdesc_t@@@Z PROC NEAR ; CStudioModelRenderer::StudioEstimateFrame, COMDAT

; 1802 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1803 : 	double dfdt = 0, f = 0;

	mov	DWORD PTR _dfdt$[ebp], 0
	mov	DWORD PTR _dfdt$[ebp+4], 0
	mov	DWORD PTR _f$[ebp], 0
	mov	DWORD PTR _f$[ebp+4], 0

; 1804 : 
; 1805 : 	if( m_fDoInterp && tr.time >= m_pCurrentEntity->curstate.animtime )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $L72937
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	fld	DWORD PTR [edx+780]
	fcomp	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L72937

; 1806 : 		dfdt = (tr.time - m_pCurrentEntity->curstate.animtime) * m_pCurrentEntity->curstate.framerate * pseqdesc->fps;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	fld	DWORD PTR [ecx+780]
	fsubr	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	fmul	DWORD PTR [eax+784]
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	fmul	DWORD PTR [ecx+32]
	fstp	QWORD PTR _dfdt$[ebp]
$L72937:

; 1807 : 
; 1808 : 	if( pseqdesc->numframes > 1 )

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [edx+56], 1
	jle	SHORT $L72938

; 1809 : 		f = (m_pCurrentEntity->curstate.frame * (pseqdesc->numframes - 1)) / 256.0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	mov	eax, DWORD PTR [edx+56]
	sub	eax, 1
	mov	DWORD PTR -24+[ebp], eax
	fild	DWORD PTR -24+[ebp]
	fmul	DWORD PTR [ecx+736]
	fdiv	QWORD PTR __real@8@40078000000000000000
	fstp	QWORD PTR _f$[ebp]
$L72938:

; 1810 : 
; 1811 : 	f += dfdt;

	fld	QWORD PTR _f$[ebp]
	fadd	QWORD PTR _dfdt$[ebp]
	fstp	QWORD PTR _f$[ebp]

; 1812 : 
; 1813 : 	if( pseqdesc->flags & STUDIO_LOOPING ) 

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 1
	test	edx, edx
	je	SHORT $L72939

; 1815 : 		if( pseqdesc->numframes > 1 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+56], 1
	jle	SHORT $L72940

; 1817 : 			f -= (int)(f / (pseqdesc->numframes - 1)) *  (pseqdesc->numframes - 1);

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	sub	edx, 1
	mov	DWORD PTR -28+[ebp], edx
	fild	DWORD PTR -28+[ebp]
	fdivr	QWORD PTR _f$[ebp]
	call	__ftol
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	sub	edx, 1
	imul	eax, edx
	mov	DWORD PTR -32+[ebp], eax
	fild	DWORD PTR -32+[ebp]
	fsubr	QWORD PTR _f$[ebp]
	fstp	QWORD PTR _f$[ebp]
$L72940:

; 1819 : 
; 1820 : 		if( f < 0.0 ) 

	fld	QWORD PTR _f$[ebp]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72942

; 1822 : 			f += (pseqdesc->numframes - 1);

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	sub	ecx, 1
	mov	DWORD PTR -36+[ebp], ecx
	fild	DWORD PTR -36+[ebp]
	fadd	QWORD PTR _f$[ebp]
	fstp	QWORD PTR _f$[ebp]
$L72942:

; 1825 : 	else 

	jmp	SHORT $L72945
$L72939:

; 1827 : 		if( f >= pseqdesc->numframes - 1.001 ) 

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	fild	DWORD PTR [edx+56]
	fsub	QWORD PTR __real@8@3fff8020c49ba5e35000
	fcomp	QWORD PTR _f$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L72944

; 1829 : 			f = pseqdesc->numframes - 1.001;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	fild	DWORD PTR [eax+56]
	fsub	QWORD PTR __real@8@3fff8020c49ba5e35000
	fstp	QWORD PTR _f$[ebp]
$L72944:

; 1831 : 
; 1832 : 		if( f < 0.0 ) 

	fld	QWORD PTR _f$[ebp]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72945

; 1834 : 			f = 0.0;

	mov	DWORD PTR _f$[ebp], 0
	mov	DWORD PTR _f$[ebp+4], 0
$L72945:

; 1837 : 
; 1838 : 	return f;

	fld	QWORD PTR _f$[ebp]
	fst	DWORD PTR -40+[ebp]

; 1839 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StudioEstimateFrame@CStudioModelRenderer@@EAEMPAUmstudioseqdesc_t@@@Z ENDP ; CStudioModelRenderer::StudioEstimateFrame
_TEXT	ENDS
;	COMDAT ?StudioEstimateGaitFrame@CStudioModelRenderer@@EAEMPAUmstudioseqdesc_t@@@Z
_TEXT	SEGMENT
_pseqdesc$ = 8
_this$ = -4
_dfdt$ = -12
_f$ = -20
?StudioEstimateGaitFrame@CStudioModelRenderer@@EAEMPAUmstudioseqdesc_t@@@Z PROC NEAR ; CStudioModelRenderer::StudioEstimateGaitFrame, COMDAT

; 1848 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1849 : 	double dfdt = 0, f = 0;

	mov	DWORD PTR _dfdt$[ebp], 0
	mov	DWORD PTR _dfdt$[ebp+4], 0
	mov	DWORD PTR _f$[ebp], 0
	mov	DWORD PTR _f$[ebp+4], 0

; 1850 : 
; 1851 : 	if( m_fDoInterp && tr.time >= m_pCurrentEntity->curstate.animtime )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $L72952
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	fld	DWORD PTR [edx+780]
	fcomp	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L72952

; 1853 : 		dfdt = (tr.time - m_pCurrentEntity->curstate.animtime) / 0.1f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	fld	DWORD PTR [ecx+780]
	fsubr	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fdiv	QWORD PTR __real@8@3ffbcccccd0000000000
	fstp	QWORD PTR _dfdt$[ebp]
$L72952:

; 1855 : 
; 1856 : 	if( pseqdesc->numframes > 1)

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [edx+56], 1
	jle	SHORT $L72953

; 1857 : 		f = m_pCurrentEntity->curstate.fuser1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	fld	DWORD PTR [ecx+964]
	fstp	QWORD PTR _f$[ebp]
$L72953:

; 1858 : 
; 1859 : 	f += dfdt;

	fld	QWORD PTR _f$[ebp]
	fadd	QWORD PTR _dfdt$[ebp]
	fstp	QWORD PTR _f$[ebp]

; 1860 : 
; 1861 : 	if( pseqdesc->flags & STUDIO_LOOPING ) 

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 1
	test	eax, eax
	je	SHORT $L72954

; 1863 : 		if( pseqdesc->numframes > 1 )

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [ecx+56], 1
	jle	SHORT $L72955

; 1865 : 			f -= (int)(f / (pseqdesc->numframes - 1)) *  (pseqdesc->numframes - 1);

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	mov	eax, DWORD PTR [edx+56]
	sub	eax, 1
	mov	DWORD PTR -24+[ebp], eax
	fild	DWORD PTR -24+[ebp]
	fdivr	QWORD PTR _f$[ebp]
	call	__ftol
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	sub	edx, 1
	imul	eax, edx
	mov	DWORD PTR -28+[ebp], eax
	fild	DWORD PTR -28+[ebp]
	fsubr	QWORD PTR _f$[ebp]
	fstp	QWORD PTR _f$[ebp]
$L72955:

; 1867 : 
; 1868 : 		if( f < 0.0 ) 

	fld	QWORD PTR _f$[ebp]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72957

; 1870 : 			f += (pseqdesc->numframes - 1);

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	sub	ecx, 1
	mov	DWORD PTR -32+[ebp], ecx
	fild	DWORD PTR -32+[ebp]
	fadd	QWORD PTR _f$[ebp]
	fstp	QWORD PTR _f$[ebp]
$L72957:

; 1873 : 	else 

	jmp	SHORT $L72960
$L72954:

; 1875 : 		if( f >= pseqdesc->numframes - 1.001 ) 

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	fild	DWORD PTR [edx+56]
	fsub	QWORD PTR __real@8@3fff8020c49ba5e35000
	fcomp	QWORD PTR _f$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L72959

; 1877 : 			f = pseqdesc->numframes - 1.001;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	fild	DWORD PTR [eax+56]
	fsub	QWORD PTR __real@8@3fff8020c49ba5e35000
	fstp	QWORD PTR _f$[ebp]
$L72959:

; 1879 : 
; 1880 : 		if( f < 0.0 ) 

	fld	QWORD PTR _f$[ebp]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72960

; 1882 : 			f = 0.0;

	mov	DWORD PTR _f$[ebp], 0
	mov	DWORD PTR _f$[ebp+4], 0
$L72960:

; 1885 : 
; 1886 : 	return f;

	fld	QWORD PTR _f$[ebp]
	fst	DWORD PTR -36+[ebp]

; 1887 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StudioEstimateGaitFrame@CStudioModelRenderer@@EAEMPAUmstudioseqdesc_t@@@Z ENDP ; CStudioModelRenderer::StudioEstimateGaitFrame
_TEXT	ENDS
PUBLIC	__real@4@40008000000000000000
PUBLIC	__real@4@3ff8a3d70a0000000000
;	COMDAT __real@4@40008000000000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@4@40008000000000000000 DD 040000000r	; 2
CONST	ENDS
;	COMDAT __real@4@3ff8a3d70a0000000000
CONST	SEGMENT
__real@4@3ff8a3d70a0000000000 DD 03c23d70ar	; 0.01
CONST	ENDS
;	COMDAT ?StudioEstimateInterpolant@CStudioModelRenderer@@EAEMXZ
_TEXT	SEGMENT
_this$ = -4
_dadt$ = -8
?StudioEstimateInterpolant@CStudioModelRenderer@@EAEMXZ PROC NEAR ; CStudioModelRenderer::StudioEstimateInterpolant, COMDAT

; 1896 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1897 : 	float dadt = 1.0;

	mov	DWORD PTR _dadt$[ebp], 1065353216	; 3f800000H

; 1898 : 
; 1899 : 	if( m_fDoInterp && ( m_pCurrentEntity->curstate.animtime >= m_pCurrentEntity->latched.prevanimtime + 0.01f ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $L72967
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	fld	DWORD PTR [ecx+2832]
	fadd	DWORD PTR __real@4@3ff8a3d70a0000000000
	fcomp	DWORD PTR [edx+780]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L72967

; 1901 : 		dadt = (tr.time - m_pCurrentEntity->curstate.animtime) / 0.1f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	fld	DWORD PTR [eax+780]
	fsubr	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fdiv	QWORD PTR __real@8@3ffbcccccd0000000000
	fstp	DWORD PTR _dadt$[ebp]

; 1902 : 
; 1903 : 		if( dadt > 2.0f )

	fld	DWORD PTR _dadt$[ebp]
	fcomp	DWORD PTR __real@4@40008000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L72967

; 1905 : 			dadt = 2.0f;

	mov	DWORD PTR _dadt$[ebp], 1073741824	; 40000000H
$L72967:

; 1908 : 	return dadt;

	fld	DWORD PTR _dadt$[ebp]

; 1909 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioEstimateInterpolant@CStudioModelRenderer@@EAEMXZ ENDP ; CStudioModelRenderer::StudioEstimateInterpolant
_TEXT	ENDS
PUBLIC	?CountPoseParameters@CStudioBoneSetup@@QAEHXZ	; CStudioBoneSetup::CountPoseParameters
;	COMDAT ?StudioInterpolatePoseParams@CStudioModelRenderer@@EAEXPAUcl_entity_s@@M@Z
_TEXT	SEGMENT
_e$ = 8
_dadt$ = 12
_this$ = -4
?StudioInterpolatePoseParams@CStudioModelRenderer@@EAEXPAUcl_entity_s@@M@Z PROC NEAR ; CStudioModelRenderer::StudioInterpolatePoseParams, COMDAT

; 1918 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1919 : 	if( !m_boneSetup.CountPoseParameters( ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?CountPoseParameters@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::CountPoseParameters
	test	eax, eax
	jne	$L72973

; 1921 : 		// interpolate blends
; 1922 : 		m_pModelInstance->m_poseparameter[0] = (e->curstate.blending[0] * dadt + e->latched.prevblending[0] * (1.0f - dadt)) / 255.0f;

	mov	eax, DWORD PTR _e$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+796]
	mov	DWORD PTR -8+[ebp], ecx
	fild	DWORD PTR -8+[ebp]
	fmul	DWORD PTR _dadt$[ebp]
	mov	edx, DWORD PTR _e$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+2880]
	mov	DWORD PTR -12+[ebp], eax
	fild	DWORD PTR -12+[ebp]
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	fstp	DWORD PTR [edx+7020]

; 1923 : 		m_pModelInstance->m_poseparameter[1] = (e->curstate.blending[1] * dadt + e->latched.prevblending[1] * (1.0f - dadt)) / 255.0f;

	mov	eax, DWORD PTR _e$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+797]
	mov	DWORD PTR -16+[ebp], ecx
	fild	DWORD PTR -16+[ebp]
	fmul	DWORD PTR _dadt$[ebp]
	mov	edx, DWORD PTR _e$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+2881]
	mov	DWORD PTR -20+[ebp], eax
	fild	DWORD PTR -20+[ebp]
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	fstp	DWORD PTR [edx+7024]

; 1925 : 	else

	jmp	$L72974
$L72973:

; 1927 : 		m_pModelInstance->m_poseparameter[0] = (e->curstate.vuser1[0] * dadt + e->prevstate.vuser1[0] * (1.0f - dadt));

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 980				; 000003d4H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 640				; 00000280H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -24+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	fstp	DWORD PTR [ecx+7020]

; 1928 : 		m_pModelInstance->m_poseparameter[1] = (e->curstate.vuser1[1] * dadt + e->prevstate.vuser1[1] * (1.0f - dadt));

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 980				; 000003d4H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -28+[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 640				; 00000280H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -28+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	fstp	DWORD PTR [eax+7024]

; 1929 : 		m_pModelInstance->m_poseparameter[2] = (e->curstate.vuser1[2] * dadt + e->prevstate.vuser1[2] * (1.0f - dadt));

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 980				; 000003d4H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -32+[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 640				; 00000280H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -32+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	fstp	DWORD PTR [edx+7028]

; 1930 : 
; 1931 : 		m_pModelInstance->m_poseparameter[3] = (e->curstate.vuser2[0] * dadt + e->prevstate.vuser2[0] * (1.0f - dadt));

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 992				; 000003e0H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 652				; 0000028cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -36+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	fstp	DWORD PTR [ecx+7032]

; 1932 : 		m_pModelInstance->m_poseparameter[4] = (e->curstate.vuser2[1] * dadt + e->prevstate.vuser2[1] * (1.0f - dadt));

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 992				; 000003e0H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 652				; 0000028cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -40+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	fstp	DWORD PTR [eax+7036]

; 1933 : 		m_pModelInstance->m_poseparameter[5] = (e->curstate.vuser2[2] * dadt + e->prevstate.vuser2[2] * (1.0f - dadt));

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 992				; 000003e0H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 652				; 0000028cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	fstp	DWORD PTR [edx+7040]

; 1934 : 
; 1935 : 		m_pModelInstance->m_poseparameter[6] = (e->curstate.vuser3[0] * dadt + e->prevstate.vuser3[0] * (1.0f - dadt));

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 1004				; 000003ecH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 664				; 00000298H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -48+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	fstp	DWORD PTR [ecx+7044]

; 1936 : 		m_pModelInstance->m_poseparameter[7] = (e->curstate.vuser3[1] * dadt + e->prevstate.vuser3[1] * (1.0f - dadt));

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 1004				; 000003ecH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 664				; 00000298H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -52+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	fstp	DWORD PTR [eax+7048]

; 1937 : 		m_pModelInstance->m_poseparameter[8] = (e->curstate.vuser3[2] * dadt + e->prevstate.vuser3[2] * (1.0f - dadt));

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 1004				; 000003ecH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 664				; 00000298H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	fstp	DWORD PTR [edx+7052]

; 1938 : 
; 1939 : 		m_pModelInstance->m_poseparameter[ 9] = (e->curstate.vuser4[0] * dadt + e->prevstate.vuser4[0] * (1.0f - dadt));

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 1016				; 000003f8H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 676				; 000002a4H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR -60+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	fstp	DWORD PTR [ecx+7056]

; 1940 : 		m_pModelInstance->m_poseparameter[10] = (e->curstate.vuser4[1] * dadt + e->prevstate.vuser4[1] * (1.0f - dadt));

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 1016				; 000003f8H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -64+[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 676				; 000002a4H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -64+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	fstp	DWORD PTR [eax+7060]

; 1941 : 		m_pModelInstance->m_poseparameter[11] = (e->curstate.vuser4[2] * dadt + e->prevstate.vuser4[2] * (1.0f - dadt));

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 1016				; 000003f8H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 676				; 000002a4H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	fstp	DWORD PTR [edx+7064]
$L72974:

; 1943 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?StudioInterpolatePoseParams@CStudioModelRenderer@@EAEXPAUcl_entity_s@@M@Z ENDP ; CStudioModelRenderer::StudioInterpolatePoseParams
_TEXT	ENDS
;	COMDAT ?CountPoseParameters@CStudioBoneSetup@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_phdr2$ = -8
?CountPoseParameters@CStudioBoneSetup@@QAEHXZ PROC NEAR	; CStudioBoneSetup::CountPoseParameters, COMDAT

; 210  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 211  : 		studiohdr2_t *phdr2 = NULL;

	mov	DWORD PTR _phdr2$[ebp], 0

; 212  : 
; 213  : 		if( m_pStudioHeader->studiohdr2index > 0 && m_pStudioHeader->studiohdr2index < m_pStudioHeader->length )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	cmp	DWORD PTR [ecx+220], 0
	jle	SHORT $L66471
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+18968]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR [eax+220]
	cmp	eax, DWORD PTR [edx+72]
	jge	SHORT $L66471

; 214  : 			phdr2 = (studiohdr2_t *)((byte *)m_pStudioHeader + m_pStudioHeader->studiohdr2index);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	add	ecx, DWORD PTR [edx+220]
	mov	DWORD PTR _phdr2$[ebp], ecx
$L66471:

; 215  : 
; 216  : 		if( phdr2 && phdr2->numposeparameters > 0 )

	cmp	DWORD PTR _phdr2$[ebp], 0
	je	SHORT $L66474
	mov	edx, DWORD PTR _phdr2$[ebp]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $L66474

; 217  : 			return phdr2->numposeparameters;

	mov	eax, DWORD PTR _phdr2$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $L66469
$L66474:

; 218  : 		return 0; // poseparams is missed

	xor	eax, eax
$L66469:

; 219  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CountPoseParameters@CStudioBoneSetup@@QAEHXZ ENDP	; CStudioBoneSetup::CountPoseParameters
_TEXT	ENDS
PUBLIC	__real@4@40068000000000000000
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	__real@4@3ffe8000000000000000
EXTRN	_abs:NEAR
;	COMDAT __real@4@40068000000000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@4@40068000000000000000 DD 043000000r	; 128
CONST	ENDS
;	COMDAT __real@8@3fff8000000000000000
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT __real@4@3ffe8000000000000000
CONST	SEGMENT
__real@4@3ffe8000000000000000 DD 03f000000r	; 0.5
CONST	ENDS
;	COMDAT ?StudioInterpolateBlends@CStudioModelRenderer@@EAEXPAUcl_entity_s@@M@Z
_TEXT	SEGMENT
_e$ = 8
_dadt$ = 12
_this$ = -4
_pbonecontroller$ = -8
_j$ = -12
_i$72987 = -16
_value$72988 = -20
_a$72992 = -24
_b$72993 = -28
?StudioInterpolateBlends@CStudioModelRenderer@@EAEXPAUcl_entity_s@@M@Z PROC NEAR ; CStudioModelRenderer::StudioInterpolateBlends, COMDAT

; 1952 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1953 : 	mstudiobonecontroller_t *pbonecontroller = (mstudiobonecontroller_t *)((byte *)m_pStudioHeader + m_pStudioHeader->bonecontrollerindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+152]
	mov	DWORD PTR _pbonecontroller$[ebp], eax

; 1954 : 
; 1955 : 	// interpolate controllers
; 1956 : 	for( int j = 0; j < m_pStudioHeader->numbonecontrollers; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L72984
$L72985:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L72984:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+148]
	jge	$L72986

; 1958 : 		int i = pbonecontroller[j].index;

	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pbonecontroller$[ebp]
	mov	ecx, DWORD PTR [eax+edx+20]
	mov	DWORD PTR _i$72987[ebp], ecx

; 1959 : 		float value;
; 1960 : 
; 1961 : 		if( i <= 3 )

	cmp	DWORD PTR _i$72987[ebp], 3
	jg	$L72989

; 1963 : 			// check for 360% wrapping
; 1964 : 			if( FBitSet( pbonecontroller[j].type, STUDIO_RLOOP ))

	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pbonecontroller$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	and	ecx, 32768				; 00008000H
	test	ecx, ecx
	je	$L72990

; 1966 : 				if( abs( e->curstate.controller[i] - e->latched.prevcontroller[i] ) > 128 )

	mov	edx, DWORD PTR _e$[ebp]
	add	edx, DWORD PTR _i$72987[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+792]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, DWORD PTR _i$72987[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+2876]
	sub	eax, edx
	push	eax
	call	_abs
	add	esp, 4
	cmp	eax, 128				; 00000080H
	jle	SHORT $L72991

; 1968 : 					int a = (e->curstate.controller[j] + 128) % 256;

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+792]
	add	ecx, 128				; 00000080H
	and	ecx, -2147483393			; 800000ffH
	jns	SHORT $L76237
	dec	ecx
	or	ecx, -256				; ffffff00H
	inc	ecx
$L76237:
	mov	DWORD PTR _a$72992[ebp], ecx

; 1969 : 					int b = (e->latched.prevcontroller[j] + 128) % 256;

	mov	edx, DWORD PTR _e$[ebp]
	add	edx, DWORD PTR _j$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+2876]
	add	eax, 128				; 00000080H
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $L76238
	dec	eax
	or	eax, -256				; ffffff00H
	inc	eax
$L76238:
	mov	DWORD PTR _b$72993[ebp], eax

; 1970 : 					value = ((a * dadt) + (b * (1.0f - dadt)) - 128);

	fild	DWORD PTR _a$72992[ebp]
	fmul	DWORD PTR _dadt$[ebp]
	fild	DWORD PTR _b$72993[ebp]
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fsub	DWORD PTR __real@4@40068000000000000000
	fstp	DWORD PTR _value$72988[ebp]

; 1972 : 				else 

	jmp	SHORT $L72994
$L72991:

; 1974 : 					value = ((e->curstate.controller[i] * dadt + (e->latched.prevcontroller[i]) * (1.0f - dadt)));

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, DWORD PTR _i$72987[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+792]
	mov	DWORD PTR -32+[ebp], edx
	fild	DWORD PTR -32+[ebp]
	fmul	DWORD PTR _dadt$[ebp]
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, DWORD PTR _i$72987[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+2876]
	mov	DWORD PTR -36+[ebp], ecx
	fild	DWORD PTR -36+[ebp]
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _dadt$[ebp]
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _value$72988[ebp]
$L72994:

; 1977 : 			else 

	jmp	SHORT $L72995
$L72990:

; 1979 : 				value = (e->curstate.controller[i] * dadt + e->latched.prevcontroller[i] * (1.0 - dadt));

	mov	edx, DWORD PTR _e$[ebp]
	add	edx, DWORD PTR _i$72987[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+792]
	mov	DWORD PTR -40+[ebp], eax
	fild	DWORD PTR -40+[ebp]
	fmul	DWORD PTR _dadt$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, DWORD PTR _i$72987[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+2876]
	mov	DWORD PTR -44+[ebp], edx
	fild	DWORD PTR -44+[ebp]
	fld	DWORD PTR _dadt$[ebp]
	fsubr	QWORD PTR __real@8@3fff8000000000000000
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _value$72988[ebp]
$L72995:

; 1981 : 			m_pModelInstance->m_controller[i] = bound( 0, Q_rint( value ), 255 );

	fld	DWORD PTR _value$72988[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L76221
	fld	DWORD PTR _value$72988[ebp]
	fsub	DWORD PTR __real@4@3ffe8000000000000000
	call	__ftol
	mov	DWORD PTR -48+[ebp], eax
	jmp	SHORT $L76222
$L76221:
	fld	DWORD PTR _value$72988[ebp]
	fadd	DWORD PTR __real@4@3ffe8000000000000000
	call	__ftol
	mov	DWORD PTR -48+[ebp], eax
$L76222:
	cmp	DWORD PTR -48+[ebp], 0
	jl	$L76229
	fld	DWORD PTR _value$72988[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L76223
	fld	DWORD PTR _value$72988[ebp]
	fsub	DWORD PTR __real@4@3ffe8000000000000000
	call	__ftol
	mov	DWORD PTR -52+[ebp], eax
	jmp	SHORT $L76224
$L76223:
	fld	DWORD PTR _value$72988[ebp]
	fadd	DWORD PTR __real@4@3ffe8000000000000000
	call	__ftol
	mov	DWORD PTR -52+[ebp], eax
$L76224:
	cmp	DWORD PTR -52+[ebp], 255		; 000000ffH
	jge	SHORT $L76227
	fld	DWORD PTR _value$72988[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L76225
	fld	DWORD PTR _value$72988[ebp]
	fsub	DWORD PTR __real@4@3ffe8000000000000000
	call	__ftol
	mov	DWORD PTR -56+[ebp], eax
	jmp	SHORT $L76226
$L76225:
	fld	DWORD PTR _value$72988[ebp]
	fadd	DWORD PTR __real@4@3ffe8000000000000000
	call	__ftol
	mov	DWORD PTR -56+[ebp], eax
$L76226:
	mov	eax, DWORD PTR -56+[ebp]
	mov	DWORD PTR -60+[ebp], eax
	jmp	SHORT $L76228
$L76227:
	mov	DWORD PTR -60+[ebp], 255		; 000000ffH
$L76228:
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR -64+[ebp], ecx
	jmp	SHORT $L76230
$L76229:
	mov	DWORD PTR -64+[ebp], 0
$L76230:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$72987[ebp]
	mov	dl, BYTE PTR -64+[ebp]
	mov	BYTE PTR [eax+ecx+7012], dl
$L72989:

; 1983 : 	}

	jmp	$L72985
$L72986:

; 1984 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?StudioInterpolateBlends@CStudioModelRenderer@@EAEXPAUcl_entity_s@@M@Z ENDP ; CStudioModelRenderer::StudioInterpolateBlends
_TEXT	ENDS
PUBLIC	??_C@_0O@FCKL@?$CFs?1?$CFs?$CFi?$CFi?4mdl?$AA@	; `string'
PUBLIC	??_C@_0N@DENN@loading?3?5?$CFs?6?$AA@		; `string'
EXTRN	?COM_ExtractFilePath@@YAXPBDPAD@Z:NEAR		; COM_ExtractFilePath
;	COMDAT ??_C@_0O@FCKL@?$CFs?1?$CFs?$CFi?$CFi?4mdl?$AA@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_C@_0O@FCKL@?$CFs?1?$CFs?$CFi?$CFi?4mdl?$AA@ DB '%s/%s%i%i.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DENN@loading?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0N@DENN@loading?3?5?$CFs?6?$AA@ DB 'loading: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?StudioGetAnim@CStudioModelRenderer@@QAEPAUmstudioanim_t@@PAUmodel_s@@PAUmstudioseqdesc_t@@@Z
_TEXT	SEGMENT
_m_pSubModel$ = 8
_pseqdesc$ = 12
_this$ = -4
_pseqgroup$ = -8
_paSequences$ = -12
_filepath$73021 = -140
_modelpath$73022 = -268
_modelname$73023 = -332
?StudioGetAnim@CStudioModelRenderer@@QAEPAUmstudioanim_t@@PAUmodel_s@@PAUmstudioseqdesc_t@@@Z PROC NEAR ; CStudioModelRenderer::StudioGetAnim, COMDAT

; 1993 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 396				; 0000018cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1994 : 	mstudioseqgroup_t *pseqgroup;
; 1995 : 	cache_user_t *paSequences;
; 1996 : 
; 1997 : 	pseqgroup = (mstudioseqgroup_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqgroupindex) + pseqdesc->seqgroup;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+176]
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	imul	edx, 104				; 00000068H
	add	eax, edx
	mov	DWORD PTR _pseqgroup$[ebp], eax

; 1998 : 
; 1999 : 	if( pseqdesc->seqgroup == 0 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+156], 0
	jne	SHORT $L73011

; 2000 : 		return (mstudioanim_t *)((byte *)m_pStudioHeader + pseqgroup->data + pseqdesc->animindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+19124]
	mov	edx, DWORD PTR _pseqgroup$[ebp]
	add	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	add	eax, DWORD PTR [ecx+124]
	jmp	$L73006
$L73011:

; 2001 : 
; 2002 : 	paSequences = (cache_user_t *)m_pSubModel->submodels;

	mov	edx, DWORD PTR _m_pSubModel$[ebp]
	mov	eax, DWORD PTR [edx+124]
	mov	DWORD PTR _paSequences$[ebp], eax

; 2003 : 
; 2004 : 	if( paSequences == NULL )

	cmp	DWORD PTR _paSequences$[ebp], 0
	jne	SHORT $L73015

; 2006 : 		paSequences = (cache_user_t *)IEngineStudio.Mem_Calloc( MAXSTUDIOGROUPS, sizeof( cache_user_t ));

	push	4
	push	16					; 00000010H
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A
	add	esp, 8
	mov	DWORD PTR _paSequences$[ebp], eax

; 2007 : 		m_pSubModel->submodels = (dmodel_t *)paSequences;

	mov	ecx, DWORD PTR _m_pSubModel$[ebp]
	mov	edx, DWORD PTR _paSequences$[ebp]
	mov	DWORD PTR [ecx+124], edx
$L73015:

; 2009 : 
; 2010 : 	// check for already loaded
; 2011 : 	if( !IEngineStudio.Cache_Check(( struct cache_user_s *)&(paSequences[pseqdesc->seqgroup] )))

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _paSequences$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+4
	add	esp, 4
	test	eax, eax
	jne	$L73020

; 2013 : 		char filepath[128], modelpath[128], modelname[64];
; 2014 : 
; 2015 : 		COM_FileBase( m_pSubModel->name, modelname );

	lea	ecx, DWORD PTR _modelname$73023[ebp]
	push	ecx
	mov	edx, DWORD PTR _m_pSubModel$[ebp]
	push	edx
	call	?COM_FileBase@@YAXPBDPAD@Z		; COM_FileBase
	add	esp, 8

; 2016 : 		COM_ExtractFilePath( m_pSubModel->name, modelpath );

	lea	eax, DWORD PTR _modelpath$73022[ebp]
	push	eax
	mov	ecx, DWORD PTR _m_pSubModel$[ebp]
	push	ecx
	call	?COM_ExtractFilePath@@YAXPBDPAD@Z	; COM_ExtractFilePath
	add	esp, 8

; 2017 : 
; 2018 : 		// NOTE: here we build real sub-animation filename because stupid user may rename model without recompile
; 2019 : 		Q_snprintf( filepath, sizeof( filepath ), "%s/%s%i%i.mdl", modelpath, modelname, pseqdesc->seqgroup / 10, pseqdesc->seqgroup % 10 );

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	mov	eax, DWORD PTR [edx+156]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	edx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	mov	eax, DWORD PTR [edx+156]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	eax
	lea	edx, DWORD PTR _modelname$73023[ebp]
	push	edx
	lea	eax, DWORD PTR _modelpath$73022[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0O@FCKL@?$CFs?1?$CFs?$CFi?$CFi?4mdl?$AA@ ; `string'
	push	128					; 00000080H
	lea	ecx, DWORD PTR _filepath$73021[ebp]
	push	ecx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 28					; 0000001cH

; 2020 : 
; 2021 : 		ALERT( at_console, "loading: %s\n", filepath );

	lea	edx, DWORD PTR _filepath$73021[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0N@DENN@loading?3?5?$CFs?6?$AA@ ; `string'
	push	1
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH

; 2022 : 		IEngineStudio.LoadCacheFile( filepath, (struct cache_user_s *)&paSequences[pseqdesc->seqgroup] );			

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _paSequences$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	lea	ecx, DWORD PTR _filepath$73021[ebp]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+8
	add	esp, 8
$L73020:

; 2024 : 
; 2025 : 	return (mstudioanim_t *)((byte *)paSequences[pseqdesc->seqgroup].data + pseqdesc->animindex);

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR _paSequences$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	add	eax, DWORD PTR [edx+124]
$L73006:

; 2026 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?StudioGetAnim@CStudioModelRenderer@@QAEPAUmstudioanim_t@@PAUmodel_s@@PAUmstudioseqdesc_t@@@Z ENDP ; CStudioModelRenderer::StudioGetAnim
_TEXT	ENDS
PUBLIC	?GetForward@matrix3x4@@QBE?AVVector@@XZ		; matrix3x4::GetForward
PUBLIC	?GetUp@matrix3x4@@QBE?AVVector@@XZ		; matrix3x4::GetUp
PUBLIC	?SetForward@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetForward
PUBLIC	?SetUp@matrix3x4@@QAEXABVVector@@@Z		; matrix3x4::SetUp
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	__real@8@4002a000000000000000
;	COMDAT __real@8@4002a000000000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@8@4002a000000000000000 DQ 04024000000000000r ; 10
CONST	ENDS
;	COMDAT ?StudioFxTransform@CStudioModelRenderer@@EAEXPAUcl_entity_s@@AAVmatrix3x4@@@Z
_TEXT	SEGMENT
_ent$ = 8
_transform$ = 12
_this$ = -4
_scale$73053 = -8
$T76243 = -20
$T76244 = -32
$T76245 = -44
$T76246 = -56
$T76247 = -68
$T76248 = -80
?StudioFxTransform@CStudioModelRenderer@@EAEXPAUcl_entity_s@@AAVmatrix3x4@@@Z PROC NEAR ; CStudioModelRenderer::StudioFxTransform, COMDAT

; 2035 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2037 : 	{

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+772]
	mov	DWORD PTR -84+[ebp], ecx
	cmp	DWORD PTR -84+[ebp], 15			; 0000000fH
	jl	$L73035
	cmp	DWORD PTR -84+[ebp], 16			; 00000010H
	jle	SHORT $L73038
	cmp	DWORD PTR -84+[ebp], 18			; 00000012H
	je	$L73052
	jmp	$L73035
$L73038:

; 2038 : 	case kRenderFxDistort:
; 2039 : 	case kRenderFxHologram:
; 2040 : 		if( RANDOM_LONG( 0, 49 ) == 0 )

	push	49					; 00000031H
	push	0
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+272
	add	esp, 8
	test	eax, eax
	jne	$L73039

; 2044 : 			{

	push	1
	push	0
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+272
	add	esp, 8
	mov	DWORD PTR -88+[ebp], eax
	cmp	DWORD PTR -88+[ebp], 0
	je	SHORT $L73044
	cmp	DWORD PTR -88+[ebp], 1
	je	SHORT $L73047
	jmp	SHORT $L73041
$L73044:

; 2045 : 			case 0:
; 2046 : 				transform.SetForward( transform.GetForward() * RANDOM_FLOAT( 1.0f, 1.484f ));

	push	1069413302				; 3fbdf3b6H
	push	1065353216				; 3f800000H
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+268
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR $T76244[ebp]
	push	edx
	lea	eax, DWORD PTR $T76243[ebp]
	push	eax
	mov	ecx, DWORD PTR _transform$[ebp]
	call	?GetForward@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetForward
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _transform$[ebp]
	call	?SetForward@matrix3x4@@QAEXABVVector@@@Z ; matrix3x4::SetForward

; 2047 : 				break; 

	jmp	SHORT $L73041
$L73047:

; 2048 : 			case 1:
; 2049 : 				transform.SetUp( transform.GetUp() * RANDOM_FLOAT( 1.0f, 1.484f ));

	push	1069413302				; 3fbdf3b6H
	push	1065353216				; 3f800000H
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+268
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T76246[ebp]
	push	ecx
	lea	edx, DWORD PTR $T76245[ebp]
	push	edx
	mov	ecx, DWORD PTR _transform$[ebp]
	call	?GetUp@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetUp
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _transform$[ebp]
	call	?SetUp@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetUp
$L73041:

; 2053 : 		else if( RANDOM_LONG( 0, 49 ) == 0 )

	jmp	SHORT $L73051
$L73039:
	push	49					; 00000031H
	push	0
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+272
	add	esp, 8
	test	eax, eax
	jne	SHORT $L73051

; 2055 : 			transform[3][RANDOM_LONG( 0, 2 )] += RANDOM_FLOAT( -10.0f, 10.0f );

	push	3
	mov	ecx, DWORD PTR _transform$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	push	2
	push	0
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+272
	add	esp, 8
	lea	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR -92+[ebp], eax
	push	1092616192				; 41200000H
	push	-1054867456				; c1200000H
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+268
	add	esp, 8
	mov	ecx, DWORD PTR -92+[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR -92+[ebp]
	fstp	DWORD PTR [edx]
$L73051:

; 2057 : 		break;

	jmp	SHORT $L73035
$L73052:

; 2060 : 			float scale = 1.0f + ( tr.time - ent->curstate.animtime ) * 10.0f;

	mov	eax, DWORD PTR _ent$[ebp]
	fld	DWORD PTR [eax+780]
	fsubr	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fmul	QWORD PTR __real@8@4002a000000000000000
	fadd	QWORD PTR __real@8@3fff8000000000000000
	fstp	DWORD PTR _scale$73053[ebp]

; 2061 : 			if( scale > 2 ) scale = 2; // don't blow up more than 200%

	fld	DWORD PTR _scale$73053[ebp]
	fcomp	DWORD PTR __real@4@40008000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L73054
	mov	DWORD PTR _scale$73053[ebp], 1073741824	; 40000000H
$L73054:

; 2062 : 			transform.SetRight( transform.GetRight() * scale );

	mov	ecx, DWORD PTR _scale$73053[ebp]
	push	ecx
	lea	edx, DWORD PTR $T76248[ebp]
	push	edx
	lea	eax, DWORD PTR $T76247[ebp]
	push	eax
	mov	ecx, DWORD PTR _transform$[ebp]
	call	?GetRight@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetRight
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _transform$[ebp]
	call	?SetRight@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetRight
$L73035:

; 2066 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?StudioFxTransform@CStudioModelRenderer@@EAEXPAUcl_entity_s@@AAVmatrix3x4@@@Z ENDP ; CStudioModelRenderer::StudioFxTransform
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T76253 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T76253[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
;	COMDAT ?GetForward@matrix3x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
?GetForward@matrix3x4@@QBE?AVVector@@XZ PROC NEAR	; matrix3x4::GetForward, COMDAT

; 520  : 	Vector	GetForward() const { return mat[0]; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetForward@matrix3x4@@QBE?AVVector@@XZ ENDP		; matrix3x4::GetForward
_TEXT	ENDS
;	COMDAT ?GetUp@matrix3x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
?GetUp@matrix3x4@@QBE?AVVector@@XZ PROC NEAR		; matrix3x4::GetUp, COMDAT

; 522  : 	Vector	GetUp() const { return mat[2]; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUp@matrix3x4@@QBE?AVVector@@XZ ENDP			; matrix3x4::GetUp
_TEXT	ENDS
;	COMDAT ?SetForward@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_vForward$ = 8
_this$ = -4
?SetForward@matrix3x4@@QAEXABVVector@@@Z PROC NEAR	; matrix3x4::SetForward, COMDAT

; 526  : 	void	SetForward( const Vector &vForward ) { mat[0] = vForward; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _vForward$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetForward@matrix3x4@@QAEXABVVector@@@Z ENDP		; matrix3x4::SetForward
_TEXT	ENDS
;	COMDAT ?SetUp@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_vUp$ = 8
_this$ = -4
?SetUp@matrix3x4@@QAEXABVVector@@@Z PROC NEAR		; matrix3x4::SetUp, COMDAT

; 528  : 	void	SetUp( const Vector &vUp ) { mat[2] = vUp; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _vUp$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUp@matrix3x4@@QAEXABVVector@@@Z ENDP		; matrix3x4::SetUp
_TEXT	ENDS
PUBLIC	??_C@_0M@FJMP@Bip01?5Spine?$AA@			; `string'
PUBLIC	??_C@_0N@EAIO@Bip01?5Pelvis?$AA@		; `string'
PUBLIC	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ	; CStudioBoneSetup::GetNumIKChains
PUBLIC	?SetBoneWeights@CStudioBoneSetup@@QAEXPAM@Z	; CStudioBoneSetup::SetBoneWeights
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
EXTRN	?AccumulatePose@CStudioBoneSetup@@QAEXPAVCIKContext@@QAVVector@@QAVVector4D@@HMM@Z:NEAR ; CStudioBoneSetup::AccumulatePose
;	COMDAT ??_C@_0M@FJMP@Bip01?5Spine?$AA@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_C@_0M@FJMP@Bip01?5Spine?$AA@ DB 'Bip01 Spine', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EAIO@Bip01?5Pelvis?$AA@
CONST	SEGMENT
??_C@_0N@EAIO@Bip01?5Pelvis?$AA@ DB 'Bip01 Pelvis', 00H	; `string'
CONST	ENDS
;	COMDAT ?BlendSequence@CStudioModelRenderer@@EAEXQAVVector@@QAVVector4D@@PAUmstudioblendseq_t@@@Z
_TEXT	SEGMENT
_pos$ = 8
_q$ = 12
_pseqblend$ = 16
_this$ = -4
_pIK$ = -8
_s$73067 = -12
_pbones$73072 = -16
_m_flGaitBoneWeights$73075 = -528
_copy$73076 = -532
_i$73077 = -536
?BlendSequence@CStudioModelRenderer@@EAEXQAVVector@@QAVVector4D@@PAUmstudioblendseq_t@@@Z PROC NEAR ; CStudioModelRenderer::BlendSequence, COMDAT

; 2069 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 604				; 0000025cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2070 : 	CIKContext	*pIK = NULL;

	mov	DWORD PTR _pIK$[ebp], 0

; 2071 : 
; 2072 : 	// to prevent division by zero
; 2073 : 	if( pseqblend->fadeout <= 0.0f )

	mov	eax, DWORD PTR _pseqblend$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L73064

; 2074 : 		pseqblend->fadeout = 0.2f;

	mov	ecx, DWORD PTR _pseqblend$[ebp]
	mov	DWORD PTR [ecx+12], 1045220557		; 3e4ccccdH
$L73064:

; 2075 : 
; 2076 : 	if( m_boneSetup.GetNumIKChains( ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	test	eax, eax
	je	SHORT $L73065

; 2077 : 		pIK = &m_pModelInstance->m_ik;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 7308				; 00001c8cH
	mov	DWORD PTR _pIK$[ebp], eax
$L73065:

; 2078 : 
; 2079 : 	if( pseqblend->blendtime && ( pseqblend->blendtime + pseqblend->fadeout > tr.time ) && ( pseqblend->sequence < m_pStudioHeader->numseq ))

	mov	ecx, DWORD PTR _pseqblend$[ebp]
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L73066
	mov	edx, DWORD PTR _pseqblend$[ebp]
	mov	eax, DWORD PTR _pseqblend$[ebp]
	fld	DWORD PTR [edx]
	fadd	DWORD PTR [eax+12]
	fcomp	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L73066
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _pseqblend$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [edx+164]
	jge	$L73066

; 2081 : 		float	s = 1.0f - (tr.time - pseqblend->blendtime) / pseqblend->fadeout;

	mov	edx, DWORD PTR _pseqblend$[ebp]
	fld	DWORD PTR [edx]
	fsubr	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	mov	eax, DWORD PTR _pseqblend$[ebp]
	fdiv	DWORD PTR [eax+12]
	fsubr	QWORD PTR __real@8@3fff8000000000000000
	fstp	DWORD PTR _s$73067[ebp]

; 2082 : 
; 2083 : 		if( s > 0 && s <= 1.0 )

	fld	DWORD PTR _s$73067[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L73068
	fld	DWORD PTR _s$73067[ebp]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L73068

; 2085 : 			// do a nice spline curve
; 2086 : 			s = 3.0f * s * s - 2.0f * s * s * s;

	fld	DWORD PTR __real@4@4000c000000000000000
	fmul	DWORD PTR _s$73067[ebp]
	fmul	DWORD PTR _s$73067[ebp]
	fld	DWORD PTR __real@4@40008000000000000000
	fmul	DWORD PTR _s$73067[ebp]
	fmul	DWORD PTR _s$73067[ebp]
	fmul	DWORD PTR _s$73067[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _s$73067[ebp]

; 2088 : 		else if( s > 1.0f )

	jmp	SHORT $L73070
$L73068:
	fld	DWORD PTR _s$73067[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L73070

; 2090 : 			// Shouldn't happen, but maybe curtime is behind animtime?
; 2091 : 			s = 1.0f;

	mov	DWORD PTR _s$73067[ebp], 1065353216	; 3f800000H
$L73070:

; 2093 : 
; 2094 : 		if( pseqblend->gaitseq )

	mov	ecx, DWORD PTR _pseqblend$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+16]
	test	edx, edx
	je	$L73071

; 2096 : 			mstudiobone_t *pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+144]
	mov	DWORD PTR _pbones$73072[ebp], eax

; 2097 : 			float m_flGaitBoneWeights[MAXSTUDIOBONES];
; 2098 : 			bool copy = true;

	mov	BYTE PTR _copy$73076[ebp], 1

; 2099 : 
; 2100 : 			for( int i = 0; i < m_pStudioHeader->numbones; i++)

	mov	DWORD PTR _i$73077[ebp], 0
	jmp	SHORT $L73078
$L73079:
	mov	ecx, DWORD PTR _i$73077[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$73077[ebp], ecx
$L73078:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _i$73077[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	$L73080

; 2102 : 				if( !Q_strcmp( pbones[i].name, "Bip01 Spine" ))

	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0M@FJMP@Bip01?5Spine?$AA@ ; `string'
	mov	edx, DWORD PTR _i$73077[ebp]
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _pbones$73072[ebp]
	add	eax, edx
	push	eax
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L73081

; 2103 : 					copy = false;

	mov	BYTE PTR _copy$73076[ebp], 0

; 2104 : 				else if( !Q_strcmp( pbones[pbones[i].parent].name, "Bip01 Pelvis" ))

	jmp	SHORT $L73084
$L73081:
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0N@EAIO@Bip01?5Pelvis?$AA@ ; `string'
	mov	ecx, DWORD PTR _i$73077[ebp]
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _pbones$73072[ebp]
	mov	eax, DWORD PTR [edx+ecx+32]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _pbones$73072[ebp]
	add	ecx, eax
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L73084

; 2105 : 					copy = true;

	mov	BYTE PTR _copy$73076[ebp], 1
$L73084:

; 2106 : 				m_flGaitBoneWeights[i] = (copy) ? 1.0f : 0.0f;

	mov	edx, DWORD PTR _copy$73076[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L76264
	mov	DWORD PTR -540+[ebp], 1065353216	; 3f800000H
	jmp	SHORT $L76265
$L76264:
	mov	DWORD PTR -540+[ebp], 0
$L76265:
	mov	eax, DWORD PTR _i$73077[ebp]
	mov	ecx, DWORD PTR -540+[ebp]
	mov	DWORD PTR _m_flGaitBoneWeights$73075[ebp+eax*4], ecx

; 2107 : 			}

	jmp	$L73079
$L73080:

; 2108 : 
; 2109 : 			m_boneSetup.SetBoneWeights( m_flGaitBoneWeights ); // install weightlist for gait sequence

	lea	edx, DWORD PTR _m_flGaitBoneWeights$73075[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?SetBoneWeights@CStudioBoneSetup@@QAEXPAM@Z ; CStudioBoneSetup::SetBoneWeights
$L73071:

; 2111 : 
; 2112 : 		m_boneSetup.AccumulatePose( pIK, pos, q, pseqblend->sequence, pseqblend->cycle, s );

	mov	eax, DWORD PTR _s$73067[ebp]
	push	eax
	mov	ecx, DWORD PTR _pseqblend$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _pseqblend$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _q$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pIK$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?AccumulatePose@CStudioBoneSetup@@QAEXPAVCIKContext@@QAVVector@@QAVVector4D@@HMM@Z ; CStudioBoneSetup::AccumulatePose

; 2113 : 		m_boneSetup.SetBoneWeights( NULL ); // back to default rules

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?SetBoneWeights@CStudioBoneSetup@@QAEXPAM@Z ; CStudioBoneSetup::SetBoneWeights
$L73066:

; 2115 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?BlendSequence@CStudioModelRenderer@@EAEXQAVVector@@QAVVector4D@@PAUmstudioblendseq_t@@@Z ENDP ; CStudioModelRenderer::BlendSequence
_TEXT	ENDS
;	COMDAT ?GetNumIKChains@CStudioBoneSetup@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_phdr2$ = -8
?GetNumIKChains@CStudioBoneSetup@@QAEHXZ PROC NEAR	; CStudioBoneSetup::GetNumIKChains, COMDAT

; 222  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 223  : 		studiohdr2_t *phdr2 = NULL;

	mov	DWORD PTR _phdr2$[ebp], 0

; 224  : 
; 225  : 		if( m_pStudioHeader->studiohdr2index > 0 && m_pStudioHeader->studiohdr2index < m_pStudioHeader->length )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	cmp	DWORD PTR [ecx+220], 0
	jle	SHORT $L66478
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+18968]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR [eax+220]
	cmp	eax, DWORD PTR [edx+72]
	jge	SHORT $L66478

; 226  : 			phdr2 = (studiohdr2_t *)((byte *)m_pStudioHeader + m_pStudioHeader->studiohdr2index);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	add	ecx, DWORD PTR [edx+220]
	mov	DWORD PTR _phdr2$[ebp], ecx
$L66478:

; 227  : 
; 228  : 		if( phdr2 && phdr2->numikchains > 0 )

	cmp	DWORD PTR _phdr2$[ebp], 0
	je	SHORT $L66481
	mov	edx, DWORD PTR _phdr2$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jle	SHORT $L66481

; 229  : 			return phdr2->numikchains;

	mov	eax, DWORD PTR _phdr2$[ebp]
	mov	eax, DWORD PTR [eax+16]
	jmp	SHORT $L66476
$L66481:

; 230  : 		return 0; // no IK chains

	xor	eax, eax
$L66476:

; 231  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ENDP		; CStudioBoneSetup::GetNumIKChains
_TEXT	ENDS
;	COMDAT ?SetBoneWeights@CStudioBoneSetup@@QAEXPAM@Z
_TEXT	SEGMENT
_pNewList$ = 8
_this$ = -4
?SetBoneWeights@CStudioBoneSetup@@QAEXPAM@Z PROC NEAR	; CStudioBoneSetup::SetBoneWeights, COMDAT

; 349  : 	void SetBoneWeights( float *pNewList ) { m_flCustomBoneWeight = pNewList; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pNewList$[ebp]
	mov	DWORD PTR [eax+516], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBoneWeights@CStudioBoneSetup@@QAEXPAM@Z ENDP	; CStudioBoneSetup::SetBoneWeights
_TEXT	ENDS
PUBLIC	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
PUBLIC	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
EXTRN	?IsActive@CIKTarget@@QAE_NXZ:NEAR		; CIKTarget::IsActive
EXTRN	?GetOwner@CIKTarget@@QAEHXZ:NEAR		; CIKTarget::GetOwner
EXTRN	?UpdateOwner@CIKTarget@@QAEXHABVVector@@0@Z:NEAR ; CIKTarget::UpdateOwner
;	COMDAT ?UpdateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z
_TEXT	SEGMENT
_pIK$ = 8
_this$ = -4
_targetCount$ = -8
_i$ = -12
_pTarget$73097 = -16
_pOwner$73100 = -20
?UpdateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z PROC NEAR ; CStudioModelRenderer::UpdateIKLocks, COMDAT

; 2121 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2122 : 	if( !pIK ) return;

	cmp	DWORD PTR _pIK$[ebp], 0
	jne	SHORT $L73090
	jmp	$L73089
$L73090:

; 2123 : 
; 2124 : 	int targetCount = pIK->m_target.Count();

	mov	ecx, DWORD PTR _pIK$[ebp]
	call	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
	mov	DWORD PTR _targetCount$[ebp], eax

; 2125 : 
; 2126 : 	if( targetCount == 0 )

	cmp	DWORD PTR _targetCount$[ebp], 0
	jne	SHORT $L73092

; 2127 : 		return;

	jmp	$L73089
$L73092:

; 2128 : 
; 2129 : 	for( int i = 0; i < targetCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73094
$L73095:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L73094:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _targetCount$[ebp]
	jge	SHORT $L73096

; 2131 : 		CIKTarget *pTarget = &pIK->m_target[i];

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pIK$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	mov	DWORD PTR _pTarget$73097[ebp], eax

; 2132 : 
; 2133 : 		if( !pTarget->IsActive( ))

	mov	ecx, DWORD PTR _pTarget$73097[ebp]
	call	?IsActive@CIKTarget@@QAE_NXZ		; CIKTarget::IsActive
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L73098

; 2134 : 			continue;

	jmp	SHORT $L73095
$L73098:

; 2135 : 
; 2136 : 		if( pTarget->GetOwner() != -1 )

	mov	ecx, DWORD PTR _pTarget$73097[ebp]
	call	?GetOwner@CIKTarget@@QAEHXZ		; CIKTarget::GetOwner
	cmp	eax, -1
	je	SHORT $L73101

; 2138 : 			cl_entity_t *pOwner = GET_ENTITY( pTarget->GetOwner() );

	mov	ecx, DWORD PTR _pTarget$73097[ebp]
	call	?GetOwner@CIKTarget@@QAEHXZ		; CIKTarget::GetOwner
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR _pOwner$73100[ebp], eax

; 2139 : 
; 2140 : 			if( pOwner != NULL )

	cmp	DWORD PTR _pOwner$73100[ebp], 0
	je	SHORT $L73101

; 2142 : 				pTarget->UpdateOwner( pOwner->index, pOwner->origin, pOwner->angles );

	mov	eax, DWORD PTR _pOwner$73100[ebp]
	add	eax, 2900				; 00000b54H
	push	eax
	mov	ecx, DWORD PTR _pOwner$73100[ebp]
	add	ecx, 2888				; 00000b48H
	push	ecx
	mov	edx, DWORD PTR _pOwner$73100[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTarget$73097[ebp]
	call	?UpdateOwner@CIKTarget@@QAEXHABVVector@@0@Z ; CIKTarget::UpdateOwner
$L73101:

; 2145 : 	}

	jmp	SHORT $L73095
$L73096:
$L73089:

; 2146 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z ENDP ; CStudioModelRenderer::UpdateIKLocks
_TEXT	ENDS
PUBLIC	??DVector@@QBE?AV0@ABV0@@Z			; Vector::operator*
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	?__LINE__Var@?1??CalculateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z@4FA ; `CStudioModelRenderer::CalculateIKLocks'::`2'::__LINE__Var
PUBLIC	??D@YA?AVVector@@MABV0@@Z			; operator*
PUBLIC	?DotProduct@@YAMABVVector@@0@Z			; DotProduct
EXTRN	?SetOnWorld@CIKTarget@@QAEX_N@Z:NEAR		; CIKTarget::SetOnWorld
EXTRN	?IKFailed@CIKTarget@@QAEXXZ:NEAR		; CIKTarget::IKFailed
EXTRN	?SetOwner@CIKTarget@@QAEXHABVVector@@0@Z:NEAR	; CIKTarget::SetOwner
EXTRN	?ClearOwner@CIKTarget@@QAEXXZ:NEAR		; CIKTarget::ClearOwner
EXTRN	?SetPos@CIKTarget@@QAEXABVVector@@@Z:NEAR	; CIKTarget::SetPos
EXTRN	?SetAngles@CIKTarget@@QAEXABVVector@@@Z:NEAR	; CIKTarget::SetAngles
EXTRN	?SetNormal@CIKTarget@@QAEXABVVector@@@Z:NEAR	; CIKTarget::SetNormal
EXTRN	?SetPosWithNormalOffset@CIKTarget@@QAEXABVVector@@0@Z:NEAR ; CIKTarget::SetPosWithNormalOffset
;	COMDAT ?__LINE__Var@?1??CalculateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??CalculateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z@4FA DW 0868H ; `CStudioModelRenderer::CalculateIKLocks'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?CalculateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z
_TEXT	SEGMENT
_pIK$ = 8
_this$ = -4
_targetCount$ = -8
_up$ = -20
_minHeight$ = -24
_maxHeight$ = -28
_i$ = -32
_j$ = -36
_trace$73118 = -40
_pTarget$73119 = -44
_flDist$73120 = -48
_estGround$73127 = -60
_p1$73128 = -72
_p2$73129 = -84
_r$73141 = -88
_mins$73142 = -100
_maxs$73144 = -112
_ve$73146 = -116
_m_pGround$73147 = -120
_tmp$73151 = -132
_limit$73163 = -136
_dot$73164 = -140
_diff$73168 = -152
_d$73171 = -156
_offset$73176 = -160
_offset$73182 = -164
_m_pEntity$73193 = -168
_flRadius$73194 = -172
_inst$73197 = -176
_distSquared$73198 = -180
_eorg$73199 = -184
_k$73200 = -188
$T76274 = -228
$T76275 = -240
$T76276 = -252
$T76277 = -264
$T76278 = -276
$T76279 = -288
$T76280 = -300
$T76281 = -312
$T76282 = -324
_origin$73210 = -200
$T76283 = -336
_angles$73211 = -212
$T76284 = -348
_d$73212 = -216
$T76287 = -360
$T76288 = -372
$T76291 = -384
$T76292 = -396
$T76293 = -408
$T76294 = -420
$T76295 = -432
$T76296 = -444
$T76299 = -456
$T76300 = -468
$T76303 = -480
$T76304 = -492
$T76305 = -504
$T76306 = -516
$T76307 = -528
$T76308 = -540
?CalculateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z PROC NEAR ; CStudioModelRenderer::CalculateIKLocks, COMDAT

; 2152 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 628				; 00000274H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2153 : 	if( !pIK ) return;

	cmp	DWORD PTR _pIK$[ebp], 0
	jne	SHORT $L73106
	jmp	$L73105
$L73106:

; 2154 : 
; 2155 : 	int targetCount = pIK->m_target.Count();

	mov	ecx, DWORD PTR _pIK$[ebp]
	call	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
	mov	DWORD PTR _targetCount$[ebp], eax

; 2156 : 
; 2157 : 	if( targetCount == 0 )

	cmp	DWORD PTR _targetCount$[ebp], 0
	jne	SHORT $L73108

; 2158 : 		return;

	jmp	$L73105
$L73108:

; 2159 : 
; 2160 : 	// FIXME: trace based on gravity or trace based on angles?
; 2161 : 	Vector up;

	lea	ecx, DWORD PTR _up$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2162 : 	AngleVectors( m_pCurrentEntity->angles, NULL, NULL, (float *)&up );

	lea	eax, DWORD PTR _up$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+19104]
	add	ecx, 2900				; 00000b54H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+96
	add	esp, 16					; 00000010H

; 2163 : 
; 2164 : 	// FIXME: check number of slots?
; 2165 : 	float minHeight = FLT_MAX;

	mov	DWORD PTR _minHeight$[ebp], 2139095039	; 7f7fffffH

; 2166 : 	float maxHeight = -FLT_MAX;

	mov	DWORD PTR _maxHeight$[ebp], -8388609	; ff7fffffH

; 2167 : 
; 2168 : 	for( int i = 0, j = 0; i < targetCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L73115
$L73116:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L73115:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _targetCount$[ebp]
	jge	$L73117

; 2170 : 		pmtrace_t *trace;
; 2171 : 		CIKTarget *pTarget = &pIK->m_target[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pIK$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	mov	DWORD PTR _pTarget$73119[ebp], eax

; 2172 : 		float flDist = pTarget->est.radius;

	mov	edx, DWORD PTR _pTarget$73119[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR _flDist$73120[ebp], eax

; 2173 : 
; 2174 : 		if( !pTarget->IsActive( ))

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?IsActive@CIKTarget@@QAE_NXZ		; CIKTarget::IsActive
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L73121

; 2175 : 			continue;

	jmp	SHORT $L73116
$L73121:

; 2178 : 		{

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR -544+[ebp], edx
	cmp	DWORD PTR -544+[ebp], 3
	je	SHORT $L73126
	cmp	DWORD PTR -544+[ebp], 5
	je	$L73189
	jmp	$L73123
$L73126:

; 2181 : 				Vector estGround;

	lea	ecx, DWORD PTR _estGround$73127[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2182 : 				Vector p1, p2;

	lea	ecx, DWORD PTR _p1$73128[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _p2$73129[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2183 : 
; 2184 : 				// adjust ground to original ground position
; 2185 : 				estGround = (pTarget->est.pos - m_pCurrentEntity->origin);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	add	ecx, 2888				; 00000b48H
	push	ecx
	lea	edx, DWORD PTR $T76274[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	add	ecx, 92					; 0000005cH
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _estGround$73127[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _estGround$73127[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _estGround$73127[ebp+8], eax

; 2186 : 				estGround = estGround - (estGround * up) * up;

	lea	ecx, DWORD PTR _up$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T76276[ebp]
	push	edx
	lea	eax, DWORD PTR _up$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76275[ebp]
	push	ecx
	lea	ecx, DWORD PTR _estGround$73127[ebp]
	call	??DVector@@QBE?AV0@ABV0@@Z		; Vector::operator*
	mov	ecx, eax
	call	??DVector@@QBE?AV0@ABV0@@Z		; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T76277[ebp]
	push	edx
	lea	ecx, DWORD PTR _estGround$73127[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _estGround$73127[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _estGround$73127[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _estGround$73127[ebp+8], eax

; 2187 : 				estGround = m_pCurrentEntity->origin + estGround + pTarget->est.floor * up;

	lea	ecx, DWORD PTR _up$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTarget$73119[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	lea	ecx, DWORD PTR $T76279[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T76280[ebp]
	push	edx
	lea	eax, DWORD PTR _estGround$73127[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76278[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19104]
	add	ecx, 2888				; 00000b48H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _estGround$73127[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _estGround$73127[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _estGround$73127[ebp+8], eax

; 2188 : 
; 2189 : 				p1 = estGround + up * pTarget->est.height;

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	lea	eax, DWORD PTR $T76281[ebp]
	push	eax
	lea	ecx, DWORD PTR _up$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T76282[ebp]
	push	ecx
	lea	ecx, DWORD PTR _estGround$73127[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _p1$73128[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _p1$73128[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _p1$73128[ebp+8], edx

; 2190 : 				p2 = estGround - up * pTarget->est.height;

	mov	eax, DWORD PTR _pTarget$73119[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	lea	edx, DWORD PTR $T76283[ebp]
	push	edx
	lea	ecx, DWORD PTR _up$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T76284[ebp]
	push	eax
	lea	ecx, DWORD PTR _estGround$73127[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p2$73129[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _p2$73129[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _p2$73129[ebp+8], eax

; 2191 : 				float r = Q_max( pTarget->est.radius, 1 );

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	fld	DWORD PTR [ecx+84]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76285
	mov	edx, DWORD PTR _pTarget$73119[ebp]
	fld	DWORD PTR [edx+84]
	fstp	DWORD PTR -548+[ebp]
	jmp	SHORT $L76286
$L76285:
	mov	DWORD PTR -548+[ebp], 1065353216	; 3f800000H
$L76286:
	mov	eax, DWORD PTR -548+[ebp]
	mov	DWORD PTR _r$73141[ebp], eax

; 2192 : 
; 2193 : 				Vector mins = Vector( -r, -r, 0.0f );

	push	0
	fld	DWORD PTR _r$73141[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _r$73141[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T76287[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _mins$73142[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2194 : 				Vector maxs = Vector(  r,  r, r * 2.0f );

	fld	DWORD PTR _r$73141[ebp]
	fadd	ST(0), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _r$73141[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$73141[ebp]
	push	edx
	lea	ecx, DWORD PTR $T76288[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _maxs$73144[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2195 : 
; 2196 : 				// don't IK to other characters
; 2197 : 				gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );

	push	2
	mov	eax, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+336
	call	DWORD PTR [eax+56]
	add	esp, 4

; 2198 : 				gEngfuncs.pEventAPI->EV_PushTraceBounds( 2, mins, maxs );

	lea	ecx, DWORD PTR _maxs$73144[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _mins$73142[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	push	2
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+336
	call	DWORD PTR [ecx+116]
	add	esp, 12					; 0000000cH

; 2199 : 				trace = gEngfuncs.pEventAPI->EV_VisTraceLine( p1, p2, PM_STUDIO_IGNORE );

	push	1
	lea	ecx, DWORD PTR _p2$73129[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _p1$73128[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	edx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+336
	call	DWORD PTR [edx+104]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _trace$73118[ebp], eax

; 2200 : 				physent_t *ve = gEngfuncs.pEventAPI->EV_GetVisent( trace->ent );

	mov	eax, DWORD PTR _trace$73118[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+336
	call	DWORD PTR [edx+108]
	add	esp, 4
	mov	DWORD PTR _ve$73146[ebp], eax

; 2201 : 				cl_entity_t *m_pGround = (ve) ? GET_ENTITY( ve->info ) : NULL;

	cmp	DWORD PTR _ve$73146[ebp], 0
	je	SHORT $L76289
	mov	eax, DWORD PTR _ve$73146[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR -552+[ebp], eax
	jmp	SHORT $L76290
$L76289:
	mov	DWORD PTR -552+[ebp], 0
$L76290:
	mov	edx, DWORD PTR -552+[ebp]
	mov	DWORD PTR _m_pGround$73147[ebp], edx

; 2202 : 				gEngfuncs.pEventAPI->EV_PopTraceBounds();

	mov	eax, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+336
	call	DWORD PTR [eax+120]

; 2203 : 
; 2204 : 				if( m_pGround != NULL && m_pGround->curstate.movetype == MOVETYPE_PUSH )

	cmp	DWORD PTR _m_pGround$73147[ebp], 0
	je	SHORT $L73148
	mov	ecx, DWORD PTR _m_pGround$73147[ebp]
	cmp	DWORD PTR [ecx+776], 7
	jne	SHORT $L73148

; 2206 : 					pTarget->SetOwner( m_pGround->index, m_pGround->origin, m_pGround->angles );

	mov	edx, DWORD PTR _m_pGround$73147[ebp]
	add	edx, 2900				; 00000b54H
	push	edx
	mov	eax, DWORD PTR _m_pGround$73147[ebp]
	add	eax, 2888				; 00000b48H
	push	eax
	mov	ecx, DWORD PTR _m_pGround$73147[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?SetOwner@CIKTarget@@QAEXHABVVector@@0@Z ; CIKTarget::SetOwner

; 2208 : 				else

	jmp	SHORT $L73149
$L73148:

; 2210 : 					pTarget->ClearOwner();

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?ClearOwner@CIKTarget@@QAEXXZ		; CIKTarget::ClearOwner
$L73149:

; 2212 : 
; 2213 : 				if( trace->startsolid )

	mov	eax, DWORD PTR _trace$73118[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$L73158

; 2215 : 					// trace from back towards hip
; 2216 : 					Vector tmp = (estGround - pTarget->trace.closest).Normalize();

	lea	ecx, DWORD PTR $T76292[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTarget$73119[ebp]
	add	edx, 148				; 00000094H
	push	edx
	lea	eax, DWORD PTR $T76291[ebp]
	push	eax
	lea	ecx, DWORD PTR _estGround$73127[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	push	eax
	lea	ecx, DWORD PTR _tmp$73151[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2217 : 
; 2218 : 					p1 = estGround - tmp * pTarget->est.height;

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	lea	eax, DWORD PTR $T76293[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmp$73151[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T76294[ebp]
	push	ecx
	lea	ecx, DWORD PTR _estGround$73127[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _p1$73128[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _p1$73128[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _p1$73128[ebp+8], edx

; 2219 : 					p2 = estGround;

	mov	eax, DWORD PTR _estGround$73127[ebp]
	mov	DWORD PTR _p2$73129[ebp], eax
	mov	ecx, DWORD PTR _estGround$73127[ebp+4]
	mov	DWORD PTR _p2$73129[ebp+4], ecx
	mov	edx, DWORD PTR _estGround$73127[ebp+8]
	mov	DWORD PTR _p2$73129[ebp+8], edx

; 2220 : 					mins = Vector( -r, -r, 0.0f );

	push	0
	fld	DWORD PTR _r$73141[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _r$73141[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T76295[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mins$73142[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mins$73142[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _mins$73142[ebp+8], eax

; 2221 : 					maxs = Vector(  r,  r, 1.0f );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _r$73141[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$73141[ebp]
	push	edx
	lea	ecx, DWORD PTR $T76296[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _maxs$73144[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _maxs$73144[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _maxs$73144[ebp+8], eax

; 2222 : 
; 2223 : 					gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );

	push	2
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+336
	call	DWORD PTR [ecx+56]
	add	esp, 4

; 2224 : 					gEngfuncs.pEventAPI->EV_PushTraceBounds( 2, mins, maxs );

	lea	ecx, DWORD PTR _maxs$73144[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _mins$73142[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	push	2
	mov	edx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+336
	call	DWORD PTR [edx+116]
	add	esp, 12					; 0000000cH

; 2225 : 					trace = gEngfuncs.pEventAPI->EV_VisTraceLine( p1, p2, PM_STUDIO_IGNORE );

	push	1
	lea	ecx, DWORD PTR _p2$73129[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _p1$73128[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	eax, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+336
	call	DWORD PTR [eax+104]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _trace$73118[ebp], eax

; 2226 : 					ve = gEngfuncs.pEventAPI->EV_GetVisent( trace->ent );

	mov	ecx, DWORD PTR _trace$73118[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+336
	call	DWORD PTR [eax+108]
	add	esp, 4
	mov	DWORD PTR _ve$73146[ebp], eax

; 2227 : 					m_pGround = (ve) ? GET_ENTITY( ve->info ) : NULL;

	cmp	DWORD PTR _ve$73146[ebp], 0
	je	SHORT $L76297
	mov	ecx, DWORD PTR _ve$73146[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR -556+[ebp], eax
	jmp	SHORT $L76298
$L76297:
	mov	DWORD PTR -556+[ebp], 0
$L76298:
	mov	eax, DWORD PTR -556+[ebp]
	mov	DWORD PTR _m_pGround$73147[ebp], eax

; 2228 : 					gEngfuncs.pEventAPI->EV_PopTraceBounds();

	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+336
	call	DWORD PTR [ecx+120]

; 2229 : 
; 2230 : 					if( !trace->startsolid )

	mov	edx, DWORD PTR _trace$73118[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	$L73158

; 2232 : 						p1 = trace->endpos;

	mov	eax, DWORD PTR _trace$73118[ebp]
	add	eax, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p1$73128[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _p1$73128[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _p1$73128[ebp+8], eax

; 2233 : 						p2 = p1 - up * pTarget->est.height;

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	lea	eax, DWORD PTR $T76299[ebp]
	push	eax
	lea	ecx, DWORD PTR _up$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T76300[ebp]
	push	ecx
	lea	ecx, DWORD PTR _p1$73128[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _p2$73129[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _p2$73129[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _p2$73129[ebp+8], edx

; 2234 : 
; 2235 : 						gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );

	push	2
	mov	eax, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+336
	call	DWORD PTR [eax+56]
	add	esp, 4

; 2236 : 						trace = gEngfuncs.pEventAPI->EV_VisTraceLine( p1, p2, PM_STUDIO_IGNORE );

	push	1
	lea	ecx, DWORD PTR _p2$73129[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _p1$73128[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+336
	call	DWORD PTR [ecx+104]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _trace$73118[ebp], eax

; 2237 : 						ve = gEngfuncs.pEventAPI->EV_GetVisent( trace->ent );

	mov	edx, DWORD PTR _trace$73118[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+336
	call	DWORD PTR [ecx+108]
	add	esp, 4
	mov	DWORD PTR _ve$73146[ebp], eax

; 2238 : 						m_pGround = (ve) ? GET_ENTITY( ve->info ) : NULL;

	cmp	DWORD PTR _ve$73146[ebp], 0
	je	SHORT $L76301
	mov	edx, DWORD PTR _ve$73146[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR -560+[ebp], eax
	jmp	SHORT $L76302
$L76301:
	mov	DWORD PTR -560+[ebp], 0
$L76302:
	mov	ecx, DWORD PTR -560+[ebp]
	mov	DWORD PTR _m_pGround$73147[ebp], ecx
$L73158:

; 2241 : 
; 2242 : 				if( !trace->startsolid )

	mov	edx, DWORD PTR _trace$73118[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	$L73161

; 2244 : 					if( m_pGround == GET_ENTITY( 0 ))

	push	0
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	cmp	DWORD PTR _m_pGround$73147[ebp], eax
	jne	$L73162

; 2246 : 						// clamp normal to 33 degrees
; 2247 : 						const float limit = 0.832;

	mov	DWORD PTR _limit$73163[ebp], 1062534644	; 3f54fdf4H

; 2248 : 						float dot = DotProduct( trace->plane.normal, up );

	lea	eax, DWORD PTR _up$[ebp]
	push	eax
	mov	ecx, DWORD PTR _trace$73118[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _dot$73164[ebp]

; 2249 : 
; 2250 : 						if( dot < limit )

	fld	DWORD PTR _dot$73164[ebp]
	fcomp	DWORD PTR _limit$73163[ebp]
	fnstsw	ax
	test	ah, 1
	je	$L73165

; 2252 : 							ASSERT( dot >= 0 );

	fld	DWORD PTR _dot$73164[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L73167
	movsx	edx, WORD PTR ?__LINE__Var@?1??CalculateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z@4FA ; `CStudioModelRenderer::CalculateIKLocks'::`2'::__LINE__Var
	add	edx, 100				; 00000064H
	push	edx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L73167:

; 2253 : 							// subtract out up component
; 2254 : 							Vector diff = trace->plane.normal - up * dot;

	mov	eax, DWORD PTR _dot$73164[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76303[ebp]
	push	ecx
	lea	ecx, DWORD PTR _up$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T76304[ebp]
	push	edx
	mov	ecx, DWORD PTR _trace$73118[ebp]
	add	ecx, 32					; 00000020H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _diff$73168[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2255 : 							// scale remainder such that it and the up vector are a unit vector
; 2256 : 							float d = sqrt(( 1.0f - limit * limit ) / DotProduct( diff, diff ) );

	fld	DWORD PTR _limit$73163[ebp]
	fmul	DWORD PTR _limit$73163[ebp]
	fsubr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR -564+[ebp]
	lea	eax, DWORD PTR _diff$73168[ebp]
	push	eax
	lea	ecx, DWORD PTR _diff$73168[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fdivr	DWORD PTR -564+[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _d$73171[ebp]

; 2257 : 							trace->plane.normal = up * limit + d * diff;

	lea	edx, DWORD PTR _diff$73168[ebp]
	push	edx
	mov	eax, DWORD PTR _d$73171[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76306[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T76307[ebp]
	push	edx
	mov	eax, DWORD PTR _limit$73163[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76305[ebp]
	push	ecx
	lea	ecx, DWORD PTR _up$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _trace$73118[ebp]
	add	edx, 32					; 00000020H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L73165:

; 2259 : 
; 2260 : 						// FIXME: this is wrong with respect to contact position and actual ankle offset
; 2261 : 						pTarget->SetPosWithNormalOffset( trace->endpos, trace->plane.normal );

	mov	ecx, DWORD PTR _trace$73118[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _trace$73118[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?SetPosWithNormalOffset@CIKTarget@@QAEXABVVector@@0@Z ; CIKTarget::SetPosWithNormalOffset

; 2262 : 						pTarget->SetNormal( trace->plane.normal );

	mov	eax, DWORD PTR _trace$73118[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?SetNormal@CIKTarget@@QAEXABVVector@@@Z	; CIKTarget::SetNormal

; 2263 : 						pTarget->SetOnWorld( true );

	push	1
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?SetOnWorld@CIKTarget@@QAEX_N@Z		; CIKTarget::SetOnWorld

; 2264 : 
; 2265 : 						// only do this on forward tracking or commited IK ground rules
; 2266 : 						if( pTarget->est.release < 0.1f )

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	fld	DWORD PTR [ecx+72]
	fcomp	DWORD PTR __real@4@3ffbcccccd0000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L73178

; 2268 : 							// keep track of ground height
; 2269 : 							float offset = DotProduct( pTarget->est.pos, up );

	lea	edx, DWORD PTR _up$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTarget$73119[ebp]
	add	eax, 92					; 0000005cH
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _offset$73176[ebp]

; 2270 : 
; 2271 : 							if( minHeight > offset )

	fld	DWORD PTR _minHeight$[ebp]
	fcomp	DWORD PTR _offset$73176[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L73177

; 2272 : 								minHeight = offset;

	mov	ecx, DWORD PTR _offset$73176[ebp]
	mov	DWORD PTR _minHeight$[ebp], ecx
$L73177:

; 2273 : 							if( maxHeight < offset )

	fld	DWORD PTR _maxHeight$[ebp]
	fcomp	DWORD PTR _offset$73176[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L73178

; 2274 : 								maxHeight = offset;

	mov	edx, DWORD PTR _offset$73176[ebp]
	mov	DWORD PTR _maxHeight$[ebp], edx
$L73178:

; 2284 : 					else if( m_pGround != NULL )

	jmp	$L73185
$L73162:
	cmp	DWORD PTR _m_pGround$73147[ebp], 0
	je	$L73180

; 2286 : 						pTarget->SetPos( trace->endpos );

	mov	eax, DWORD PTR _trace$73118[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?SetPos@CIKTarget@@QAEXABVVector@@@Z	; CIKTarget::SetPos

; 2287 : 						pTarget->SetAngles( m_pCurrentEntity->angles );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	add	edx, 2900				; 00000b54H
	push	edx
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?SetAngles@CIKTarget@@QAEXABVVector@@@Z	; CIKTarget::SetAngles

; 2288 : 
; 2289 : 						// only do this on forward tracking or commited IK ground rules
; 2290 : 						if( pTarget->est.release < 0.1f )

	mov	eax, DWORD PTR _pTarget$73119[ebp]
	fld	DWORD PTR [eax+72]
	fcomp	DWORD PTR __real@4@3ffbcccccd0000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L73184

; 2292 : 							float offset = DotProduct( pTarget->est.pos, up );

	lea	ecx, DWORD PTR _up$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTarget$73119[ebp]
	add	edx, 92					; 0000005cH
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _offset$73182[ebp]

; 2293 : 
; 2294 : 							if( minHeight > offset )

	fld	DWORD PTR _minHeight$[ebp]
	fcomp	DWORD PTR _offset$73182[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L73183

; 2295 : 								minHeight = offset;

	mov	eax, DWORD PTR _offset$73182[ebp]
	mov	DWORD PTR _minHeight$[ebp], eax
$L73183:

; 2296 : 
; 2297 : 							if( maxHeight < offset )

	fld	DWORD PTR _maxHeight$[ebp]
	fcomp	DWORD PTR _offset$73182[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L73184

; 2298 : 								maxHeight = offset;

	mov	ecx, DWORD PTR _offset$73182[ebp]
	mov	DWORD PTR _maxHeight$[ebp], ecx
$L73184:

; 2308 : 					else

	jmp	SHORT $L73185
$L73180:

; 2310 : 						pTarget->IKFailed();

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?IKFailed@CIKTarget@@QAEXXZ		; CIKTarget::IKFailed
$L73185:

; 2313 : 				else

	jmp	SHORT $L73188
$L73161:

; 2315 : 					if( m_pGround != GET_ENTITY( 0 ))

	push	0
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	cmp	DWORD PTR _m_pGround$73147[ebp], eax
	je	SHORT $L73187

; 2317 : 						pTarget->IKFailed( );

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?IKFailed@CIKTarget@@QAEXXZ		; CIKTarget::IKFailed

; 2319 : 					else

	jmp	SHORT $L73188
$L73187:

; 2321 : 						pTarget->SetPos( trace->endpos );

	mov	edx, DWORD PTR _trace$73118[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?SetPos@CIKTarget@@QAEXABVVector@@@Z	; CIKTarget::SetPos

; 2322 : 						pTarget->SetAngles( m_pCurrentEntity->angles );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	add	ecx, 2900				; 00000b54H
	push	ecx
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?SetAngles@CIKTarget@@QAEXABVVector@@@Z	; CIKTarget::SetAngles

; 2323 : 						pTarget->SetOnWorld( true );

	push	1
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?SetOnWorld@CIKTarget@@QAEX_N@Z		; CIKTarget::SetOnWorld
$L73188:

; 2327 : 			break;

	jmp	$L73123
$L73189:

; 2328 : 		case IK_ATTACHMENT:
; 2329 : 			flDist = pTarget->est.radius;

	mov	edx, DWORD PTR _pTarget$73119[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR _flDist$73120[ebp], eax

; 2330 : 			for( j = 1; j < RENDER_GET_PARM( PARM_MAX_ENTITIES, 0 ); j++ )

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $L73190
$L73191:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L73190:
	push	0
	push	20					; 00000014H
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A
	add	esp, 8
	cmp	DWORD PTR _j$[ebp], eax
	jge	$L73192

; 2332 : 				cl_entity_t *m_pEntity = GET_ENTITY( j );

	mov	edx, DWORD PTR _j$[ebp]
	push	edx
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR _m_pEntity$73193[ebp], eax

; 2333 : 				float flRadius = 4096.0f; // (64.0f * 64.0f)

	mov	DWORD PTR _flRadius$73194[ebp], 1166016512 ; 45800000H

; 2334 : 
; 2335 : 				if( !m_pEntity || m_pEntity->modelhandle == INVALID_HANDLE )

	cmp	DWORD PTR _m_pEntity$73193[ebp], 0
	je	SHORT $L73196
	mov	eax, DWORD PTR _m_pEntity$73193[ebp]
	cmp	DWORD PTR [eax+2960], 65535		; 0000ffffH
	jne	SHORT $L73195
$L73196:

; 2336 : 					continue;	// not a studiomodel or not in PVS

	jmp	SHORT $L73191
$L73195:

; 2337 : 
; 2338 : 				ModelInstance_t *inst = &m_ModelInstances[m_pEntity->modelhandle];

	mov	ecx, DWORD PTR _m_pEntity$73193[ebp]
	mov	dx, WORD PTR [ecx+2960]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	DWORD PTR _inst$73197[ebp], eax

; 2339 : 				float distSquared = 0.0f, eorg;

	mov	DWORD PTR _distSquared$73198[ebp], 0

; 2340 : 
; 2341 : 				for( int k = 0; k < 3 && distSquared <= flRadius; k++ )

	mov	DWORD PTR _k$73200[ebp], 0
	jmp	SHORT $L73201
$L73202:
	mov	eax, DWORD PTR _k$73200[ebp]
	add	eax, 1
	mov	DWORD PTR _k$73200[ebp], eax
$L73201:
	cmp	DWORD PTR _k$73200[ebp], 3
	jge	$L73203
	fld	DWORD PTR _distSquared$73198[ebp]
	fcomp	DWORD PTR _flRadius$73194[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L73203

; 2343 : 					if( pTarget->est.pos[j] < inst->absmin[j] )

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _inst$73197[ebp]
	add	ecx, 156				; 0000009cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [esi+ecx*4]
	fcomp	DWORD PTR [eax+edx*4]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L73204

; 2344 : 						eorg = pTarget->est.pos[j] - inst->absmin[j];

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _inst$73197[ebp]
	add	ecx, 156				; 0000009cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [esi+ecx*4]
	fsub	DWORD PTR [eax+edx*4]
	fstp	DWORD PTR _eorg$73199[ebp]

; 2345 : 					else if( pTarget->est.pos[j] > inst->absmax[j] )

	jmp	SHORT $L73207
$L73204:
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _inst$73197[ebp]
	add	ecx, 168				; 000000a8H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [esi+ecx*4]
	fcomp	DWORD PTR [eax+edx*4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L73206

; 2346 : 						eorg = pTarget->est.pos[j] - inst->absmax[j];

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _inst$73197[ebp]
	add	ecx, 168				; 000000a8H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [esi+ecx*4]
	fsub	DWORD PTR [eax+edx*4]
	fstp	DWORD PTR _eorg$73199[ebp]

; 2347 : 					else eorg = 0.0f;

	jmp	SHORT $L73207
$L73206:
	mov	DWORD PTR _eorg$73199[ebp], 0
$L73207:

; 2348 : 
; 2349 : 					distSquared += eorg * eorg;

	fld	DWORD PTR _eorg$73199[ebp]
	fmul	DWORD PTR _eorg$73199[ebp]
	fadd	DWORD PTR _distSquared$73198[ebp]
	fstp	DWORD PTR _distSquared$73198[ebp]

; 2350 : 				}

	jmp	$L73202
$L73203:

; 2351 : 
; 2352 : 				if( distSquared >= flRadius )

	fld	DWORD PTR _distSquared$73198[ebp]
	fcomp	DWORD PTR _flRadius$73194[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L73208

; 2353 : 					continue;	// not in radius

	jmp	$L73191
$L73208:

; 2354 : 
; 2355 : 				// Extract the bone index from the name
; 2356 : 				if( pTarget->offset.attachmentIndex >= inst->numattachments )

	mov	eax, DWORD PTR _pTarget$73119[ebp]
	mov	ecx, DWORD PTR _inst$73197[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+7008]
	jl	SHORT $L73209

; 2357 : 					continue;

	jmp	$L73191
$L73209:

; 2358 : 
; 2359 : 				// FIXME: how to validate a index?
; 2360 : 				Vector origin = inst->attachment[pTarget->offset.attachmentIndex].origin;

	mov	eax, DWORD PTR _pTarget$73119[ebp]
	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, 104				; 00000068H
	mov	edx, DWORD PTR _inst$73197[ebp]
	lea	eax, DWORD PTR [edx+ecx+432]
	push	eax
	lea	ecx, DWORD PTR _origin$73210[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2361 : 				Vector angles = inst->attachment[pTarget->offset.attachmentIndex].angles;

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	mov	edx, DWORD PTR [ecx+8]
	imul	edx, 104				; 00000068H
	mov	eax, DWORD PTR _inst$73197[ebp]
	lea	ecx, DWORD PTR [eax+edx+444]
	push	ecx
	lea	ecx, DWORD PTR _angles$73211[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2362 : 				float d = (pTarget->est.pos - origin).Length();

	lea	edx, DWORD PTR _origin$73210[ebp]
	push	edx
	lea	eax, DWORD PTR $T76308[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	add	ecx, 92					; 0000005cH
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _d$73212[ebp]

; 2363 : 
; 2364 : 				if( d >= flDist )

	fld	DWORD PTR _d$73212[ebp]
	fcomp	DWORD PTR _flDist$73120[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L73214

; 2365 : 					continue;

	jmp	$L73191
$L73214:

; 2366 : 				flDist = d;

	mov	ecx, DWORD PTR _d$73212[ebp]
	mov	DWORD PTR _flDist$73120[ebp], ecx

; 2367 : 				pTarget->SetPos( origin );

	lea	edx, DWORD PTR _origin$73210[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?SetPos@CIKTarget@@QAEXABVVector@@@Z	; CIKTarget::SetPos

; 2368 : 				pTarget->SetAngles( angles );

	lea	eax, DWORD PTR _angles$73211[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?SetAngles@CIKTarget@@QAEXABVVector@@@Z	; CIKTarget::SetAngles

; 2369 : 			}

	jmp	$L73191
$L73192:

; 2370 : 
; 2371 : 			if( flDist >= pTarget->est.radius )

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	fld	DWORD PTR _flDist$73120[ebp]
	fcomp	DWORD PTR [ecx+84]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L73215

; 2373 : 				// no solution, disable ik rule
; 2374 : 				pTarget->IKFailed( );

	mov	ecx, DWORD PTR _pTarget$73119[ebp]
	call	?IKFailed@CIKTarget@@QAEXXZ		; CIKTarget::IKFailed
$L73215:
$L73123:

; 2378 : 	}

	jmp	$L73116
$L73117:
$L73105:

; 2379 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CalculateIKLocks@CStudioModelRenderer@@EAEXPAVCIKContext@@@Z ENDP ; CStudioModelRenderer::CalculateIKLocks
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T76311 = -16
??DVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator*, COMDAT

; 155  : 	inline Vector operator*(const Vector& v) const	{ return Vector(x*v.x, y*v.y, z*v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T76311[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator*
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_flLen$ = -8
$T76314 = -20
?Normalize@Vector@@QBE?AV1@XZ PROC NEAR			; Vector::Normalize, COMDAT

; 232  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 234  : 
; 235  : 		if( flLen )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L54765

; 237  : 			flLen = 1.0f / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 238  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T76314[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L54763
$L54765:

; 240  : 
; 241  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L54763:

; 242  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT
_fl$ = 12
_v$ = 16
___$ReturnUdt$ = 8
$T76317 = -12
??D@YA?AVVector@@MABV0@@Z PROC NEAR			; operator*, COMDAT

; 288  : inline Vector operator* ( float fl, const Vector& v ) { return v * fl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76317[ebp]
	push	ecx
	mov	ecx, DWORD PTR _v$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??D@YA?AVVector@@MABV0@@Z ENDP				; operator*
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProduct@@YAMABVVector@@0@Z PROC NEAR		; DotProduct, COMDAT

; 289  : inline float DotProduct(const Vector& a, const Vector& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector@@0@Z ENDP			; DotProduct
_TEXT	ENDS
PUBLIC	?StudioSetBonesExternal@CStudioModelRenderer@@QAEXPBUcl_entity_s@@QBVVector@@QBVRadian@@@Z ; CStudioModelRenderer::StudioSetBonesExternal
;	COMDAT ?StudioSetBonesExternal@CStudioModelRenderer@@QAEXPBUcl_entity_s@@QBVVector@@QBVRadian@@@Z
_TEXT	SEGMENT
_ent$ = 8
_pos$ = 12
_ang$ = 16
_this$ = -4
_i$ = -8
?StudioSetBonesExternal@CStudioModelRenderer@@QAEXPBUcl_entity_s@@QBVVector@@QBVRadian@@@Z PROC NEAR ; CStudioModelRenderer::StudioSetBonesExternal, COMDAT

; 2382 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2383 : 	m_pCurrentEntity = (cl_entity_t *)ent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+19104], ecx

; 2384 : 	m_pRenderModel = ent->model;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	mov	DWORD PTR [edx+19108], ecx

; 2385 : 
; 2386 : 	if( m_pRenderModel == NULL )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+19108], 0
	jne	SHORT $L73223

; 2387 : 		return;

	jmp	$L73221
$L73223:

; 2388 : 
; 2389 : 	// setup global pointers
; 2390 : 	m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+19124], eax

; 2391 : 
; 2392 : 	// aliasmodel instead of studio?
; 2393 : 	if( m_pStudioHeader == NULL )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+19124], 0
	jne	SHORT $L73225

; 2394 : 		return;

	jmp	$L73221
$L73225:

; 2395 : 
; 2396 : 	if( m_pCurrentEntity->modelhandle == INVALID_HANDLE )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	cmp	DWORD PTR [edx+2960], 65535		; 0000ffffH
	jne	SHORT $L73226

; 2397 : 		return; // out of memory ?

	jmp	$L73221
$L73226:

; 2398 : 
; 2399 : 	m_pModelInstance = &m_ModelInstances[m_pCurrentEntity->modelhandle];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	dx, WORD PTR [ecx+2960]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19112], eax

; 2400 : 
; 2401 : 	for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73228
$L73229:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L73228:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+140]
	jge	SHORT $L73230

; 2403 : 		m_pModelInstance->m_procangles[i] = ang[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ang$[ebp]
	add	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	lea	eax, DWORD PTR [eax+edx+23836]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 2404 : 		m_pModelInstance->m_procorigin[i] = pos[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR [edx+ecx+25372]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 2405 : 	}

	jmp	$L73229
$L73230:

; 2406 : 
; 2407 : 	m_pModelInstance->m_flLastBoneUpdate = tr.time + 0.1f;

	fld	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fadd	QWORD PTR __real@8@3ffbcccccd0000000000
	fst	DWORD PTR -12+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	fstp	DWORD PTR [edx+26912]

; 2408 : 	m_pModelInstance->m_bProceduralBones = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	BYTE PTR [ecx+26908], 1
$L73221:

; 2409 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StudioSetBonesExternal@CStudioModelRenderer@@QAEXPBUcl_entity_s@@QBVVector@@QBVRadian@@@Z ENDP ; CStudioModelRenderer::StudioSetBonesExternal
_TEXT	ENDS
PUBLIC	??0Vector4D@@QAE@ABVRadian@@@Z			; Vector4D::Vector4D
;	COMDAT ?StudioCalcBonesProcedural@CStudioModelRenderer@@EAEXQAVVector@@QAVVector4D@@@Z
_TEXT	SEGMENT
_pos$ = 8
_q$ = 12
_this$ = -4
_i$ = -8
$T76324 = -24
?StudioCalcBonesProcedural@CStudioModelRenderer@@EAEXQAVVector@@QAVVector4D@@@Z PROC NEAR ; CStudioModelRenderer::StudioCalcBonesProcedural, COMDAT

; 2412 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2413 : 	if( !m_pModelInstance->m_bProceduralBones )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+26908]
	test	edx, edx
	jne	SHORT $L73236

; 2414 : 		return;

	jmp	$L73235
$L73236:

; 2415 : 
; 2416 : 	for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73238
$L73239:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L73238:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+140]
	jge	SHORT $L73240

; 2418 : 		q[i] = m_pModelInstance->m_procangles[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR [edx+eax+23836]
	push	ecx
	lea	ecx, DWORD PTR $T76324[ebp]
	call	??0Vector4D@@QAE@ABVRadian@@@Z		; Vector4D::Vector4D
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _q$[ebp]
	add	eax, edx
	mov	ecx, DWORD PTR $T76324[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T76324[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T76324[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR $T76324[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 2419 : 		pos[i] = m_pModelInstance->m_procorigin[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	lea	eax, DWORD PTR [ecx+edx+25372]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _pos$[ebp]
	add	edx, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 2420 : 	}

	jmp	$L73239
$L73240:

; 2421 : 
; 2422 : 	// update is expired
; 2423 : 	if( tr.time > m_pModelInstance->m_flLastBoneUpdate )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	fld	DWORD PTR [edx+26912]
	fcomp	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fnstsw	ax
	test	ah, 1
	je	SHORT $L73242

; 2424 : 		m_pModelInstance->m_bProceduralBones = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	BYTE PTR [ecx+26908], 0
$L73242:
$L73235:

; 2425 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?StudioCalcBonesProcedural@CStudioModelRenderer@@EAEXQAVVector@@QAVVector4D@@@Z ENDP ; CStudioModelRenderer::StudioCalcBonesProcedural
_TEXT	ENDS
EXTRN	?AngleQuaternion@@YAXABVRadian@@AAVVector4D@@@Z:NEAR ; AngleQuaternion
;	COMDAT ??0Vector4D@@QAE@ABVRadian@@@Z
_TEXT	SEGMENT
_angle$ = 8
_this$ = -4
??0Vector4D@@QAE@ABVRadian@@@Z PROC NEAR		; Vector4D::Vector4D, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 431  : 	AngleQuaternion( angle, *this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?AngleQuaternion@@YAXABVRadian@@AAVVector4D@@@Z ; AngleQuaternion
	add	esp, 8

; 432  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector4D@@QAE@ABVRadian@@@Z ENDP			; Vector4D::Vector4D
_TEXT	ENDS
PUBLIC	??0CJiggleBones@@QAE@XZ				; CJiggleBones::CJiggleBones
PUBLIC	??_C@_0DM@EGCF@StudioSetupBones?3?5sequence?5?$CFi?1?$CFi@ ; `string'
PUBLIC	?UpdateRealTime@CStudioBoneSetup@@QAEXM@Z	; CStudioBoneSetup::UpdateRealTime
PUBLIC	??1CIKContext@@QAE@XZ				; CIKContext::~CIKContext
EXTRN	??0CIKContext@@QAE@XZ:NEAR			; CIKContext::CIKContext
EXTRN	?Init@CIKContext@@QAEXPBVCStudioBoneSetup@@ABVVector@@1MH@Z:NEAR ; CIKContext::Init
EXTRN	?ClearTargets@CIKContext@@QAEXXZ:NEAR		; CIKContext::ClearTargets
EXTRN	?UpdateTargets@CIKContext@@QAEXQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z:NEAR ; CIKContext::UpdateTargets
EXTRN	?SolveDependencies@CIKContext@@QAEXQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z:NEAR ; CIKContext::SolveDependencies
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	?BuildJiggleTransformations@CJiggleBones@@QAEXHMPBUmstudiojigglebone_t@@ABVmatrix3x4@@AAV3@@Z:NEAR ; CJiggleBones::BuildJiggleTransformations
EXTRN	?CalcProceduralBone@@YA_NPBUstudiohdr_t@@HPAVmatrix3x4@@@Z:NEAR ; CalcProceduralBone
EXTRN	__chkstk:NEAR
EXTRN	?CalcBoneAdj@CStudioBoneSetup@@QAEXQAVVector@@QAVVector4D@@QBEE@Z:NEAR ; CStudioBoneSetup::CalcBoneAdj
EXTRN	?CalcBoneAdj@CStudioBoneSetup@@QAEXQAMQBEE@Z:NEAR ; CStudioBoneSetup::CalcBoneAdj
EXTRN	?CalcAutoplaySequences@CStudioBoneSetup@@QAEXPAVCIKContext@@QAVVector@@QAVVector4D@@@Z:NEAR ; CStudioBoneSetup::CalcAutoplaySequences
_BSS	SEGMENT
_?pos@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector@@A DB 0600H DUP (?)
_?$S30@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4EA DB 01H DUP (?)
	ALIGN	4

_?q@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector4D@@A DB 0800H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DM@EGCF@StudioSetupBones?3?5sequence?5?$CFi?1?$CFi@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_C@_0DM@EGCF@StudioSetupBones?3?5sequence?5?$CFi?1?$CFi@ DB 'StudioSetu'
	DB	'pBones: sequence %i/%i out of range for model %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?StudioSetupBones@CStudioModelRenderer@@EAEXXZ DD 019930520H
	DD	02H
	DD	FLAT:__unwindtable$?StudioSetupBones@CStudioModelRenderer@@EAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?StudioSetupBones@CStudioModelRenderer@@EAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?StudioSetupBones@CStudioModelRenderer@@EAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?StudioSetupBones@CStudioModelRenderer@@EAEXXZ$1
xdata$x	ENDS
;	COMDAT ?StudioSetupBones@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_this$ = -16
_adj$ = -48
_e$ = -52
_pIK$ = -56
_pboneinfo$ = -60
_pseqdesc$ = -64
_bonematrix$ = -112
_pbones$ = -116
_i$ = -120
$T76335 = -5024
$T76336 = -5028
$T76337 = -5076
$T76338 = -5080
$T76339 = -5084
_sequence$73269 = -124
$T76342 = -5088
$T76343 = -5136
__$EHRec$ = -12
_f$ = -128
_dadt$ = -132
_cycle$ = -136
_m_flGaitBoneWeights$73289 = -648
_copy$73290 = -652
_i$73291 = -656
_auto_ik$ = -4796
_boneComputed$ = -4924
_goalMX$73313 = -4972
_jiggleInfo$73318 = -4976
?StudioSetupBones@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::StudioSetupBones, COMDAT

; 2434 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?StudioSetupBones@CStudioModelRenderer@@EAEXXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	mov	eax, 5224				; 00001468H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2435 : 	float		adj[MAXSTUDIOCONTROLLERS];
; 2436 : 	cl_entity_t	*e = m_pCurrentEntity;	// for more readability

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	DWORD PTR _e$[ebp], ecx

; 2437 : 	CIKContext	*pIK = NULL;

	mov	DWORD PTR _pIK$[ebp], 0

; 2438 : 	mstudioboneinfo_t	*pboneinfo;
; 2439 : 	mstudioseqdesc_t	*pseqdesc;
; 2440 : 	matrix3x4		bonematrix;

	lea	ecx, DWORD PTR _bonematrix$[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 2441 : 	mstudiobone_t	*pbones;
; 2442 : 	int		i;
; 2443 : 
; 2444 : 	static Vector	pos[MAXSTUDIOBONES];

	xor	edx, edx
	mov	dl, BYTE PTR _?$S30@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4EA
	and	edx, 1
	test	edx, edx
	jne	SHORT $L73259
	mov	al, BYTE PTR _?$S30@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4EA
	or	al, 1
	mov	BYTE PTR _?$S30@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4EA, al
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	128					; 00000080H
	push	12					; 0000000cH
	push	OFFSET FLAT:_?pos@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E31
	call	_atexit
	add	esp, 4
$L73259:

; 2445 : 	static Vector4D	q[MAXSTUDIOBONES];

	xor	ecx, ecx
	mov	cl, BYTE PTR _?$S30@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4EA
	and	ecx, 2
	test	ecx, ecx
	jne	SHORT $L73264
	mov	dl, BYTE PTR _?$S30@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4EA
	or	dl, 2
	mov	BYTE PTR _?$S30@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4EA, dl
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	128					; 00000080H
	push	16					; 00000010H
	push	OFFSET FLAT:_?q@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector4D@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E32
	call	_atexit
	add	esp, 4
$L73264:

; 2446 : 
; 2447 : 	if( e->curstate.sequence < 0 || e->curstate.sequence >= m_pStudioHeader->numseq ) 

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+732], 0
	jl	SHORT $L73268
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+732]
	cmp	ecx, DWORD PTR [edx+164]
	jl	SHORT $L73267
$L73268:

; 2449 : 		int sequence = (short)e->curstate.sequence;

	mov	edx, DWORD PTR _e$[ebp]
	movsx	eax, WORD PTR [edx+732]
	mov	DWORD PTR _sequence$73269[ebp], eax

; 2450 : 		ALERT( at_warning, "StudioSetupBones: sequence %i/%i out of range for model %s\n", sequence, m_pStudioHeader->numseq, m_pRenderModel->name );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	mov	eax, DWORD PTR _sequence$73269[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0DM@EGCF@StudioSetupBones?3?5sequence?5?$CFi?1?$CFi@ ; `string'
	push	3
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 20					; 00000014H

; 2451 : 		e->curstate.sequence = 0;

	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [ecx+732], 0
$L73267:

; 2453 : 
; 2454 : 	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + e->curstate.sequence;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	add	edx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+732]
	imul	ecx, 176				; 000000b0H
	add	edx, ecx
	mov	DWORD PTR _pseqdesc$[ebp], edx

; 2455 : 	float f = StudioEstimateFrame( pseqdesc );

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+64]
	fstp	DWORD PTR _f$[ebp]

; 2456 : 	float dadt = StudioEstimateInterpolant();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+56]
	fstp	DWORD PTR _dadt$[ebp]

; 2457 : 	
; 2458 : 	StudioInterpolatePoseParams( e, dadt );

	mov	eax, DWORD PTR _dadt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+72]

; 2459 : 
; 2460 : 	if( CheckBoneCache( f )) return; // using a cached bones no need transformations

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+176]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L73276
	jmp	$L73246
$L73276:

; 2461 : 
; 2462 : 	if( m_boneSetup.GetNumIKChains( ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	test	eax, eax
	je	SHORT $L73277

; 2464 : 		if( FBitSet( e->curstate.effects, EF_NOINTERP ))

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+748]
	and	edx, 32					; 00000020H
	test	edx, edx
	je	SHORT $L73278

; 2465 : 			m_pModelInstance->m_ik.ClearTargets();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 7308				; 00001c8cH
	call	?ClearTargets@CIKContext@@QAEXXZ	; CIKContext::ClearTargets
$L73278:

; 2466 : 		m_pModelInstance->m_ik.Init( &m_boneSetup, e->angles, e->origin, tr.time, tr.realframecount );

	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1411992
	push	ecx
	fld	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fst	DWORD PTR -5140+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 2888				; 00000b48H
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 2900				; 00000b54H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	add	ecx, 7308				; 00001c8cH
	call	?Init@CIKContext@@QAEXPBVCStudioBoneSetup@@ABVVector@@1MH@Z ; CIKContext::Init

; 2467 : 		pIK = &m_pModelInstance->m_ik;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 7308				; 00001c8cH
	mov	DWORD PTR _pIK$[ebp], ecx
$L73277:

; 2469 : 
; 2470 : 	float cycle = f / m_boneSetup.LocalMaxFrame( e->curstate.sequence );

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+732]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?LocalMaxFrame@CStudioBoneSetup@@QAEHH@Z ; CStudioBoneSetup::LocalMaxFrame
	mov	DWORD PTR -5144+[ebp], eax
	fild	DWORD PTR -5144+[ebp]
	fdivr	DWORD PTR _f$[ebp]
	fstp	DWORD PTR _cycle$[ebp]

; 2471 : 	StudioInterpolateBlends( e, dadt );

	mov	ecx, DWORD PTR _dadt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+68]

; 2472 : 
; 2473 : 	m_boneSetup.InitPose( pos, q );

	push	OFFSET FLAT:_?q@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector4D@@A
	push	OFFSET FLAT:_?pos@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector@@A
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?InitPose@CStudioBoneSetup@@QAEXQAVVector@@QAVVector4D@@@Z ; CStudioBoneSetup::InitPose

; 2474 : 	m_boneSetup.UpdateRealTime( tr.time );

	fld	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fst	DWORD PTR -5148+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?UpdateRealTime@CStudioBoneSetup@@QAEXM@Z ; CStudioBoneSetup::UpdateRealTime

; 2475 : 	if( CVAR_TO_BOOL( m_pCvarCompatible ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+120], 0
	je	SHORT $L76329
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76329
	mov	BYTE PTR -5152+[ebp], 1
	jmp	SHORT $L76330
$L76329:
	mov	BYTE PTR -5152+[ebp], 0
$L76330:
	mov	eax, DWORD PTR -5152+[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L73280

; 2476 : 		m_boneSetup.CalcBoneAdj( adj, m_pModelInstance->m_controller, e->mouth.mouthopen );

	mov	ecx, DWORD PTR _e$[ebp]
	mov	dl, BYTE PTR [ecx+2824]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 7012				; 00001b64H
	push	ecx
	lea	edx, DWORD PTR _adj$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?CalcBoneAdj@CStudioBoneSetup@@QAEXQAMQBEE@Z ; CStudioBoneSetup::CalcBoneAdj
$L73280:

; 2477 : 	m_boneSetup.AccumulatePose( pIK, pos, q, e->curstate.sequence, cycle, 1.0 );

	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _cycle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+732]
	push	edx
	push	OFFSET FLAT:_?q@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector4D@@A
	push	OFFSET FLAT:_?pos@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector@@A
	mov	eax, DWORD PTR _pIK$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?AccumulatePose@CStudioBoneSetup@@QAEXPAVCIKContext@@QAVVector@@QAVVector4D@@HMM@Z ; CStudioBoneSetup::AccumulatePose

; 2478 : 	m_pModelInstance->lerp.frame = f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR [edx+7280], eax

; 2479 : 
; 2480 : 	pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+144]
	mov	DWORD PTR _pbones$[ebp], ecx

; 2481 : 	pboneinfo = (mstudioboneinfo_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex + m_pStudioHeader->numbones * sizeof( mstudiobone_t ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	add	edx, DWORD PTR [eax+144]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	eax, DWORD PTR [ecx+140]
	imul	eax, 112				; 00000070H
	add	edx, eax
	mov	DWORD PTR _pboneinfo$[ebp], edx

; 2482 : 
; 2483 : 	if( m_pPlayerInfo && ( m_pPlayerInfo->gaitsequence < 0 || m_pPlayerInfo->gaitsequence >= m_pStudioHeader->numseq )) 

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+19116], 0
	je	SHORT $L73286
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19116]
	cmp	DWORD PTR [eax+380], 0
	jl	SHORT $L73287
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19116]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR [edx+380]
	cmp	edx, DWORD PTR [ecx+164]
	jl	SHORT $L73286
$L73287:

; 2484 : 		m_pPlayerInfo->gaitsequence = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19116]
	mov	DWORD PTR [ecx+380], 0
$L73286:

; 2485 : 
; 2486 : 	// calc gait animation
; 2487 : 	if( m_pPlayerInfo && m_pPlayerInfo->gaitsequence != 0 )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+19116], 0
	je	$L73288
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19116]
	cmp	DWORD PTR [ecx+380], 0
	je	$L73288

; 2489 : 		float m_flGaitBoneWeights[MAXSTUDIOBONES];
; 2490 : 		bool copy = true;

	mov	BYTE PTR _copy$73290[ebp], 1

; 2491 : 
; 2492 : 		for( int i = 0; i < m_pStudioHeader->numbones; i++)

	mov	DWORD PTR _i$73291[ebp], 0
	jmp	SHORT $L73292
$L73293:
	mov	edx, DWORD PTR _i$73291[ebp]
	add	edx, 1
	mov	DWORD PTR _i$73291[ebp], edx
$L73292:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _i$73291[ebp]
	cmp	edx, DWORD PTR [ecx+140]
	jge	$L73294

; 2494 : 			if( !Q_strcmp( pbones[i].name, "Bip01 Spine" ))

	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0M@FJMP@Bip01?5Spine?$AA@ ; `string'
	mov	eax, DWORD PTR _i$73291[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _pbones$[ebp]
	add	ecx, eax
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L73295

; 2495 : 				copy = false;

	mov	BYTE PTR _copy$73290[ebp], 0

; 2496 : 			else if( !Q_strcmp( pbones[pbones[i].parent].name, "Bip01 Pelvis" ))

	jmp	SHORT $L73297
$L73295:
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0N@EAIO@Bip01?5Pelvis?$AA@ ; `string'
	mov	edx, DWORD PTR _i$73291[ebp]
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _pbones$[ebp]
	mov	ecx, DWORD PTR [eax+edx+32]
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _pbones$[ebp]
	add	edx, ecx
	push	edx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L73297

; 2497 : 				copy = true;

	mov	BYTE PTR _copy$73290[ebp], 1
$L73297:

; 2498 : 			m_flGaitBoneWeights[i] = (copy) ? 1.0f : 0.0f;

	mov	eax, DWORD PTR _copy$73290[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L76331
	mov	DWORD PTR -5156+[ebp], 1065353216	; 3f800000H
	jmp	SHORT $L76332
$L76331:
	mov	DWORD PTR -5156+[ebp], 0
$L76332:
	mov	ecx, DWORD PTR _i$73291[ebp]
	mov	edx, DWORD PTR -5156+[ebp]
	mov	DWORD PTR _m_flGaitBoneWeights$73289[ebp+ecx*4], edx

; 2499 : 		}

	jmp	$L73293
$L73294:

; 2500 : 
; 2501 : 		pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pPlayerInfo->gaitsequence;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+168]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19116]
	mov	ecx, DWORD PTR [edx+380]
	imul	ecx, 176				; 000000b0H
	add	eax, ecx
	mov	DWORD PTR _pseqdesc$[ebp], eax

; 2502 : 		f = StudioEstimateGaitFrame( pseqdesc );

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+60]
	fstp	DWORD PTR _f$[ebp]

; 2503 : 
; 2504 : 		// convert gaitframe to cycle
; 2505 : 		cycle = f / m_boneSetup.LocalMaxFrame( m_pPlayerInfo->gaitsequence );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19116]
	mov	edx, DWORD PTR [ecx+380]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?LocalMaxFrame@CStudioBoneSetup@@QAEHH@Z ; CStudioBoneSetup::LocalMaxFrame
	mov	DWORD PTR -5160+[ebp], eax
	fild	DWORD PTR -5160+[ebp]
	fdivr	DWORD PTR _f$[ebp]
	fstp	DWORD PTR _cycle$[ebp]

; 2506 : 
; 2507 : 		m_boneSetup.SetBoneWeights( m_flGaitBoneWeights ); // install weightlist for gait sequence

	lea	eax, DWORD PTR _m_flGaitBoneWeights$73289[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?SetBoneWeights@CStudioBoneSetup@@QAEXPAM@Z ; CStudioBoneSetup::SetBoneWeights

; 2508 : 		m_boneSetup.AccumulatePose( pIK, pos, q, m_pPlayerInfo->gaitsequence, cycle, 1.0 );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _cycle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19116]
	mov	ecx, DWORD PTR [eax+380]
	push	ecx
	push	OFFSET FLAT:_?q@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector4D@@A
	push	OFFSET FLAT:_?pos@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector@@A
	mov	edx, DWORD PTR _pIK$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?AccumulatePose@CStudioBoneSetup@@QAEXPAVCIKContext@@QAVVector@@QAVVector4D@@HMM@Z ; CStudioBoneSetup::AccumulatePose

; 2509 : 		m_boneSetup.SetBoneWeights( NULL ); // back to default rules

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?SetBoneWeights@CStudioBoneSetup@@QAEXPAM@Z ; CStudioBoneSetup::SetBoneWeights

; 2510 : 		m_pPlayerInfo->gaitframe = f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19116]
	mov	edx, DWORD PTR _f$[ebp]
	mov	DWORD PTR [ecx+384], edx
$L73288:

; 2512 : 
; 2513 : 	// blends from previous sequences
; 2514 : 	for( i = 0; i < MAX_SEQBLENDS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73300
$L73301:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L73300:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $L73302

; 2515 : 		BlendSequence( pos, q, &m_pModelInstance->m_seqblend[i] );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	lea	ecx, DWORD PTR [edx+eax+7116]
	push	ecx
	push	OFFSET FLAT:_?q@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector4D@@A
	push	OFFSET FLAT:_?pos@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector@@A
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+40]
	jmp	SHORT $L73301
$L73302:

; 2516 : 
; 2517 : 	CIKContext auto_ik;

	lea	ecx, DWORD PTR _auto_ik$[ebp]
	call	??0CIKContext@@QAE@XZ			; CIKContext::CIKContext
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2518 : 	auto_ik.Init( &m_boneSetup, e->angles, e->origin, 0.0f, 0 );

	push	0
	push	0
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 2888				; 00000b48H
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 2900				; 00000b54H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 132				; 00000084H
	push	eax
	lea	ecx, DWORD PTR _auto_ik$[ebp]
	call	?Init@CIKContext@@QAEXPBVCStudioBoneSetup@@ABVVector@@1MH@Z ; CIKContext::Init

; 2519 : 	m_boneSetup.CalcAutoplaySequences( &auto_ik, pos, q );

	push	OFFSET FLAT:_?q@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector4D@@A
	push	OFFSET FLAT:_?pos@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector@@A
	lea	ecx, DWORD PTR _auto_ik$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?CalcAutoplaySequences@CStudioBoneSetup@@QAEXPAVCIKContext@@QAVVector@@QAVVector4D@@@Z ; CStudioBoneSetup::CalcAutoplaySequences

; 2520 : 	if( !CVAR_TO_BOOL( m_pCvarCompatible ))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+120], 0
	je	SHORT $L76333
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76333
	mov	BYTE PTR -5164+[ebp], 1
	jmp	SHORT $L76334
$L76333:
	mov	BYTE PTR -5164+[ebp], 0
$L76334:
	mov	edx, DWORD PTR -5164+[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L73304

; 2521 : 		m_boneSetup.CalcBoneAdj( pos, q, m_pModelInstance->m_controller, e->mouth.mouthopen );

	mov	eax, DWORD PTR _e$[ebp]
	mov	cl, BYTE PTR [eax+2824]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 7012				; 00001b64H
	push	eax
	push	OFFSET FLAT:_?q@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector4D@@A
	push	OFFSET FLAT:_?pos@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector@@A
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?CalcBoneAdj@CStudioBoneSetup@@QAEXQAVVector@@QAVVector4D@@QBEE@Z ; CStudioBoneSetup::CalcBoneAdj
$L73304:

; 2524 : 
; 2525 : 	memset( boneComputed, 0, sizeof( boneComputed ));

	push	128					; 00000080H
	push	0
	lea	ecx, DWORD PTR _boneComputed$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2526 : 
; 2527 : 	// don't calculate IK on ragdolls
; 2528 : 	if( pIK != NULL )

	cmp	DWORD PTR _pIK$[ebp], 0
	je	SHORT $L73306

; 2530 : 		UpdateIKLocks( pIK );

	mov	edx, DWORD PTR _pIK$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+44]

; 2531 : 		pIK->UpdateTargets( pos, q, m_pModelInstance->m_pbones, boneComputed );

	lea	eax, DWORD PTR _boneComputed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 11548				; 00002d1cH
	push	edx
	push	OFFSET FLAT:_?q@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector4D@@A
	push	OFFSET FLAT:_?pos@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector@@A
	mov	ecx, DWORD PTR _pIK$[ebp]
	call	?UpdateTargets@CIKContext@@QAEXQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z ; CIKContext::UpdateTargets

; 2532 : 		CalculateIKLocks( pIK );

	mov	eax, DWORD PTR _pIK$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+48]

; 2533 : 		pIK->SolveDependencies( pos, q, m_pModelInstance->m_pbones, boneComputed );

	lea	eax, DWORD PTR _boneComputed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 11548				; 00002d1cH
	push	edx
	push	OFFSET FLAT:_?q@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector4D@@A
	push	OFFSET FLAT:_?pos@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector@@A
	mov	ecx, DWORD PTR _pIK$[ebp]
	call	?SolveDependencies@CIKContext@@QAEXQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z ; CIKContext::SolveDependencies
$L73306:

; 2535 : 
; 2536 : 	StudioCalcBonesProcedural( pos, q );

	push	OFFSET FLAT:_?q@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector4D@@A
	push	OFFSET FLAT:_?pos@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector@@A
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+28]

; 2537 : 
; 2538 : 	for( i = 0; i < m_pStudioHeader->numbones; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73307
$L73308:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L73307:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+140]
	jge	$L73309

; 2540 : 		// animate all non-simulated bones
; 2541 : 		if( CalcProceduralBone( m_pStudioHeader, i, m_pModelInstance->m_pbones ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 11548				; 00002d1cH
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	push	edx
	call	?CalcProceduralBone@@YA_NPBUstudiohdr_t@@HPAVmatrix3x4@@@Z ; CalcProceduralBone
	add	esp, 12					; 0000000cH
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L73310

; 2542 : 			continue;

	jmp	SHORT $L73308
$L73310:

; 2543 : 
; 2544 : 		// initialize bonematrix
; 2545 : 		bonematrix = matrix3x4( pos[i], q[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET FLAT:_?q@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector4D@@A
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, OFFSET FLAT:_?pos@?1??StudioSetupBones@CStudioModelRenderer@@EAEXXZ@4PAVVector@@A
	push	ecx
	lea	ecx, DWORD PTR $T76335[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	mov	esi, eax
	mov	ecx, 12					; 0000000cH
	lea	edi, DWORD PTR _bonematrix$[ebp]
	rep movsd

; 2546 : 
; 2547 : 		if( FBitSet( pbones[i].flags, BONE_JIGGLE_PROCEDURAL ) && FBitSet( m_pStudioHeader->flags, STUDIO_HAS_BONEINFO ))

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _pbones$[ebp]
	mov	ecx, DWORD PTR [eax+edx+36]
	and	ecx, 8
	test	ecx, ecx
	je	$L73312
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR [eax+136]
	and	ecx, 1073741824				; 40000000H
	test	ecx, ecx
	je	$L73312

; 2549 : 			// Physics-based "jiggle" bone
; 2550 : 			// Bone is assumed to be along the Z axis
; 2551 : 			// Pitch around X, yaw around Y
; 2552 : 
; 2553 : 			// compute desired bone orientation
; 2554 : 			matrix3x4 goalMX;

	lea	ecx, DWORD PTR _goalMX$73313[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 2555 : 
; 2556 : 			if( pbones[i].parent == -1 ) goalMX = bonematrix;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _pbones$[ebp]
	cmp	DWORD PTR [eax+edx+32], -1
	jne	SHORT $L73314
	mov	ecx, 12					; 0000000cH
	lea	esi, DWORD PTR _bonematrix$[ebp]
	lea	edi, DWORD PTR _goalMX$73313[ebp]
	rep movsd

; 2557 : 			else goalMX = m_pModelInstance->m_pbones[pbones[i].parent].ConcatTransforms( bonematrix );

	jmp	SHORT $L73315
$L73314:
	sub	esp, 48					; 00000030H
	mov	ecx, esp
	mov	DWORD PTR $T76336[ebp], esp
	lea	edx, DWORD PTR _bonematrix$[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	eax, DWORD PTR $T76337[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _pbones$[ebp]
	mov	eax, DWORD PTR [ecx+eax+32]
	imul	eax, 48					; 00000030H
	lea	ecx, DWORD PTR [edx+eax+11548]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	esi, eax
	mov	ecx, 12					; 0000000cH
	lea	edi, DWORD PTR _goalMX$73313[ebp]
	rep movsd
$L73315:

; 2558 : 
; 2559 : 			// get jiggle properties from QC data
; 2560 : 			mstudiojigglebone_t *jiggleInfo = (mstudiojigglebone_t *)((byte *)m_pStudioHeader + pboneinfo[i].procindex);

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	edx, DWORD PTR _pboneinfo$[ebp]
	add	eax, DWORD PTR [edx+ecx+68]
	mov	DWORD PTR _jiggleInfo$73318[ebp], eax

; 2561 : 			if( !m_pModelInstance->m_pJiggleBones ) m_pModelInstance->m_pJiggleBones = new CJiggleBones;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	cmp	DWORD PTR [ecx+7304], 0
	jne	SHORT $L73321
	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T76339[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T76339[ebp], 0
	je	SHORT $L76340
	mov	ecx, DWORD PTR $T76339[ebp]
	call	??0CJiggleBones@@QAE@XZ			; CJiggleBones::CJiggleBones
	mov	DWORD PTR -5168+[ebp], eax
	jmp	SHORT $L76341
$L76340:
	mov	DWORD PTR -5168+[ebp], 0
$L76341:
	mov	edx, DWORD PTR -5168+[ebp]
	mov	DWORD PTR $T76338[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR $T76338[ebp]
	mov	DWORD PTR [ecx+7304], edx
$L73321:

; 2562 : 
; 2563 : 			// do jiggle physics
; 2564 : 			if( pboneinfo[i].proctype == STUDIO_PROC_JIGGLE )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	mov	ecx, DWORD PTR _pboneinfo$[ebp]
	cmp	DWORD PTR [ecx+eax+64], 5
	jne	SHORT $L73326

; 2565 : 				m_pModelInstance->m_pJiggleBones->BuildJiggleTransformations( i, tr.time, jiggleInfo, goalMX, m_pModelInstance->m_pbones[i] );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	lea	edx, DWORD PTR [eax+ecx+11548]
	push	edx
	lea	eax, DWORD PTR _goalMX$73313[ebp]
	push	eax
	mov	ecx, DWORD PTR _jiggleInfo$73318[ebp]
	push	ecx
	fld	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fst	DWORD PTR -5172+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	ecx, DWORD PTR [ecx+7304]
	call	?BuildJiggleTransformations@CJiggleBones@@QAEXHMPBUmstudiojigglebone_t@@ABVmatrix3x4@@AAV3@@Z ; CJiggleBones::BuildJiggleTransformations

; 2566 : 			else m_pModelInstance->m_pbones[i] = goalMX; // fallback

	jmp	SHORT $L73327
$L73326:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	lea	edi, DWORD PTR [eax+ecx+11548]
	mov	ecx, 12					; 0000000cH
	lea	esi, DWORD PTR _goalMX$73313[ebp]
	rep movsd
$L73327:

; 2568 : 		else

	jmp	$L73330
$L73312:

; 2570 : 			if( pbones[i].parent == -1 ) m_pModelInstance->m_pbones[i] = bonematrix;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _pbones$[ebp]
	cmp	DWORD PTR [eax+edx+32], -1
	jne	SHORT $L73329
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	lea	edi, DWORD PTR [edx+eax+11548]
	mov	ecx, 12					; 0000000cH
	lea	esi, DWORD PTR _bonematrix$[ebp]
	rep movsd

; 2571 : 			else m_pModelInstance->m_pbones[i] = m_pModelInstance->m_pbones[pbones[i].parent].ConcatTransforms( bonematrix );

	jmp	SHORT $L73330
$L73329:
	sub	esp, 48					; 00000030H
	mov	ecx, esp
	mov	DWORD PTR $T76342[ebp], esp
	lea	edx, DWORD PTR _bonematrix$[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	eax, DWORD PTR $T76343[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _pbones$[ebp]
	mov	eax, DWORD PTR [ecx+eax+32]
	imul	eax, 48					; 00000030H
	lea	ecx, DWORD PTR [edx+eax+11548]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	lea	edi, DWORD PTR [edx+eax+11548]
	mov	ecx, 12					; 0000000cH
	rep movsd
$L73330:

; 2573 : 	}

	jmp	$L73308
$L73309:

; 2574 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _auto_ik$[ebp]
	call	??1CIKContext@@QAE@XZ			; CIKContext::~CIKContext
$L73246:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?StudioSetupBones@CStudioModelRenderer@@EAEXXZ$0:
	lea	ecx, DWORD PTR _auto_ik$[ebp]
	call	??1CIKContext@@QAE@XZ			; CIKContext::~CIKContext
	ret	0
__unwindfunclet$?StudioSetupBones@CStudioModelRenderer@@EAEXXZ$1:
	mov	eax, DWORD PTR $T76339[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?StudioSetupBones@CStudioModelRenderer@@EAEXXZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?StudioSetupBones@CStudioModelRenderer@@EAEXXZ
	jmp	___CxxFrameHandler
text$x	ENDS
?StudioSetupBones@CStudioModelRenderer@@EAEXXZ ENDP	; CStudioModelRenderer::StudioSetupBones
PUBLIC	??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z	; CUtlLinkedList<JiggleData,unsigned short>::CUtlLinkedList<JiggleData,unsigned short>
;	COMDAT ??0CJiggleBones@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CJiggleBones@@QAE@XZ PROC NEAR			; CJiggleBones::CJiggleBones, COMDAT

; 70   : 	CJiggleBones() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z ; CUtlLinkedList<JiggleData,unsigned short>::CUtlLinkedList<JiggleData,unsigned short>
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CJiggleBones@@QAE@XZ ENDP				; CJiggleBones::CJiggleBones
_TEXT	ENDS
;	COMDAT ?UpdateRealTime@CStudioBoneSetup@@QAEXM@Z
_TEXT	SEGMENT
_flTime$ = 8
_this$ = -4
?UpdateRealTime@CStudioBoneSetup@@QAEXM@Z PROC NEAR	; CStudioBoneSetup::UpdateRealTime, COMDAT

; 351  : 	void UpdateRealTime( float flTime ) { m_flTime = flTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flTime$[ebp]
	mov	DWORD PTR [eax+532], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateRealTime@CStudioBoneSetup@@QAEXM@Z ENDP		; CStudioBoneSetup::UpdateRealTime
_TEXT	ENDS
;	COMDAT _$E32
_TEXT	SEGMENT
_$E32	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E32	ENDP
_TEXT	ENDS
;	COMDAT _$E31
_TEXT	SEGMENT
_$E31	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E31	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@XZ	; CUtlArrayFixed<CIKTarget,12>::~CUtlArrayFixed<CIKTarget,12>
PUBLIC	??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::~CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >
PUBLIC	??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::~CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CIKContext@@QAE@XZ DD 019930520H
	DD	02H
	DD	FLAT:__unwindtable$??1CIKContext@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CIKContext@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CIKContext@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CIKContext@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT ??1CIKContext@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1CIKContext@@QAE@XZ PROC NEAR				; CIKContext::~CIKContext, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CIKContext@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::~CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::~CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@XZ ; CUtlArrayFixed<CIKTarget,12>::~CUtlArrayFixed<CIKTarget,12>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CIKContext@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@XZ ; CUtlArrayFixed<CIKTarget,12>::~CUtlArrayFixed<CIKTarget,12>
	ret	0
__unwindfunclet$??1CIKContext@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::~CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >
	ret	0
__ehhandler$??1CIKContext@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CIKContext@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CIKContext@@QAE@XZ ENDP				; CIKContext::~CIKContext
PUBLIC	??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::~CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >
;	COMDAT ??1?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@XZ PROC NEAR	; CUtlArrayFixed<CIKTarget,12>::~CUtlArrayFixed<CIKTarget,12>, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::~CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@XZ ENDP	; CUtlArrayFixed<CIKTarget,12>::~CUtlArrayFixed<CIKTarget,12>
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4FA ; `CStudioModelRenderer::StudioMergeBones'::`2'::__LINE__Var
_BSS	SEGMENT
_?pos@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4PAVVector@@A DB 0600H DUP (?)
_?$S33@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4EA DB 01H DUP (?)
	ALIGN	4

_?q@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4PAVVector4D@@A DB 0800H DUP (?)
_BSS	ENDS
;	COMDAT ?__LINE__Var@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4FA DW 0a18H ; `CStudioModelRenderer::StudioMergeBones'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z
_TEXT	SEGMENT
$T76378 = -240
$T76380 = -292
_bones$ = 8
_cached_bones$ = 12
_pModel$ = 16
_pParentModel$ = 20
_this$ = -4
_bonematrix$ = -52
_poseparams$ = -148
_sequence$ = -152
_oldmodel$ = -156
_oldheader$ = -160
_pseqdesc$ = -164
_f$ = -168
_cycle$ = -172
_m_pParentHeader$ = -176
_pchildbones$ = -180
_pparentbones$ = -184
_i$ = -188
_j$73389 = -192
?StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z PROC NEAR ; CStudioModelRenderer::StudioMergeBones, COMDAT

; 2584 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2585 : 	matrix3x4		bonematrix;

	lea	ecx, DWORD PTR _bonematrix$[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 2586 : 	static Vector	pos[MAXSTUDIOBONES];

	xor	eax, eax
	mov	al, BYTE PTR _?$S33@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L73351
	mov	cl, BYTE PTR _?$S33@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S33@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4EA, cl
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	128					; 00000080H
	push	12					; 0000000cH
	push	OFFSET FLAT:_?pos@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4PAVVector@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E34
	call	_atexit
	add	esp, 4
$L73351:

; 2587 : 	static Vector4D	q[MAXSTUDIOBONES];

	xor	edx, edx
	mov	dl, BYTE PTR _?$S33@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	SHORT $L73356
	mov	al, BYTE PTR _?$S33@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S33@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4EA, al
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	128					; 00000080H
	push	16					; 00000010H
	push	OFFSET FLAT:_?q@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4PAVVector4D@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E35
	call	_atexit
	add	esp, 4
$L73356:

; 2588 : 	float		poseparams[MAXSTUDIOPOSEPARAM];
; 2589 : 	int		sequence = m_pCurrentEntity->curstate.sequence;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	eax, DWORD PTR [edx+732]
	mov	DWORD PTR _sequence$[ebp], eax

; 2590 : 	model_t		*oldmodel = m_pRenderModel;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	DWORD PTR _oldmodel$[ebp], edx

; 2591 : 	studiohdr_t	*oldheader = m_pStudioHeader;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	DWORD PTR _oldheader$[ebp], ecx

; 2592 : 
; 2593 : 	ASSERT( pModel != NULL && pModel->type == mod_studio );

	cmp	DWORD PTR _pModel$[ebp], 0
	je	SHORT $L73365
	mov	edx, DWORD PTR _pModel$[ebp]
	cmp	DWORD PTR [edx+68], 3
	je	SHORT $L73364
$L73365:
	movsx	eax, WORD PTR ?__LINE__Var@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4FA ; `CStudioModelRenderer::StudioMergeBones'::`2'::__LINE__Var
	add	eax, 9
	push	eax
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L73364:

; 2594 : 	ASSERT( pParentModel != NULL && pParentModel->type == mod_studio );

	cmp	DWORD PTR _pParentModel$[ebp], 0
	je	SHORT $L73367
	mov	ecx, DWORD PTR _pParentModel$[ebp]
	cmp	DWORD PTR [ecx+68], 3
	je	SHORT $L73366
$L73367:
	movsx	edx, WORD PTR ?__LINE__Var@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4FA ; `CStudioModelRenderer::StudioMergeBones'::`2'::__LINE__Var
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L73366:

; 2595 : 
; 2596 : 	RI->currentmodel = m_pRenderModel = pModel;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pModel$[ebp]
	mov	DWORD PTR [eax+19108], ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR _pModel$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2597 : 	m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	push	edx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19124], eax

; 2598 : 
; 2599 : 	// tell the bonesetup about current model
; 2600 : 	m_boneSetup.SetStudioPointers( m_pStudioHeader, poseparams ); // don't touch original parameters

	lea	edx, DWORD PTR _poseparams$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?SetStudioPointers@CStudioBoneSetup@@QAEXPAUstudiohdr_t@@PBM@Z ; CStudioBoneSetup::SetStudioPointers

; 2601 : 
; 2602 : 	if( sequence < 0 || sequence >= m_pStudioHeader->numseq ) 

	cmp	DWORD PTR _sequence$[ebp], 0
	jl	SHORT $L73370
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _sequence$[ebp]
	cmp	ecx, DWORD PTR [eax+164]
	jl	SHORT $L73369
$L73370:

; 2603 : 		sequence = 0;

	mov	DWORD PTR _sequence$[ebp], 0
$L73369:

; 2604 : 
; 2605 : 	mstudioseqdesc_t *pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + sequence;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	add	edx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR _sequence$[ebp]
	imul	eax, 176				; 000000b0H
	add	edx, eax
	mov	DWORD PTR _pseqdesc$[ebp], edx

; 2606 : 	float f = StudioEstimateFrame( pseqdesc );

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+64]
	fstp	DWORD PTR _f$[ebp]

; 2607 : 	float cycle = f / m_boneSetup.LocalMaxFrame( sequence );

	mov	ecx, DWORD PTR _sequence$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?LocalMaxFrame@CStudioBoneSetup@@QAEHH@Z ; CStudioBoneSetup::LocalMaxFrame
	mov	DWORD PTR -296+[ebp], eax
	fild	DWORD PTR -296+[ebp]
	fdivr	DWORD PTR _f$[ebp]
	fstp	DWORD PTR _cycle$[ebp]

; 2608 : 
; 2609 : 	m_boneSetup.InitPose( pos, q );

	push	OFFSET FLAT:_?q@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4PAVVector4D@@A
	push	OFFSET FLAT:_?pos@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4PAVVector@@A
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?InitPose@CStudioBoneSetup@@QAEXQAVVector@@QAVVector4D@@@Z ; CStudioBoneSetup::InitPose

; 2610 : 	m_boneSetup.AccumulatePose( NULL, pos, q, sequence, cycle, 1.0 );

	push	1065353216				; 3f800000H
	mov	edx, DWORD PTR _cycle$[ebp]
	push	edx
	mov	eax, DWORD PTR _sequence$[ebp]
	push	eax
	push	OFFSET FLAT:_?q@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4PAVVector4D@@A
	push	OFFSET FLAT:_?pos@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4PAVVector@@A
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?AccumulatePose@CStudioBoneSetup@@QAEXPAVCIKContext@@QAVVector@@QAVVector4D@@HMM@Z ; CStudioBoneSetup::AccumulatePose

; 2611 : 
; 2612 : 	studiohdr_t *m_pParentHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( pParentModel );

	mov	ecx, DWORD PTR _pParentModel$[ebp]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	DWORD PTR _m_pParentHeader$[ebp], eax

; 2613 : 
; 2614 : 	ASSERT( m_pParentHeader != NULL );

	cmp	DWORD PTR _m_pParentHeader$[ebp], 0
	jne	SHORT $L73378
	movsx	edx, WORD PTR ?__LINE__Var@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4FA ; `CStudioModelRenderer::StudioMergeBones'::`2'::__LINE__Var
	add	edx, 30					; 0000001eH
	push	edx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L73378:

; 2615 : 
; 2616 : 	mstudiobone_t *pchildbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+144]
	mov	DWORD PTR _pchildbones$[ebp], eax

; 2617 : 	mstudiobone_t *pparentbones = (mstudiobone_t *)((byte *)m_pParentHeader + m_pParentHeader->boneindex);

	mov	ecx, DWORD PTR _m_pParentHeader$[ebp]
	mov	edx, DWORD PTR _m_pParentHeader$[ebp]
	add	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR _pparentbones$[ebp], edx

; 2618 : 
; 2619 : 	for( int i = 0; i < m_pStudioHeader->numbones; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73386
$L73387:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L73386:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+140]
	jge	$L73388

; 2621 : 		for( int j = 0; j < m_pParentHeader->numbones; j++ )

	mov	DWORD PTR _j$73389[ebp], 0
	jmp	SHORT $L73390
$L73391:
	mov	ecx, DWORD PTR _j$73389[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$73389[ebp], ecx
$L73390:
	mov	edx, DWORD PTR _m_pParentHeader$[ebp]
	mov	eax, DWORD PTR _j$73389[ebp]
	cmp	eax, DWORD PTR [edx+140]
	jge	SHORT $L73392

; 2623 : 			if( !Q_stricmp( pchildbones[i].name, pparentbones[j].name ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _j$73389[ebp]
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _pparentbones$[ebp]
	add	edx, ecx
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _pchildbones$[ebp]
	add	ecx, eax
	push	ecx
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L73393

; 2625 : 				bones[i] = cached_bones[j];

	mov	edx, DWORD PTR _j$73389[ebp]
	imul	edx, 48					; 00000030H
	mov	esi, DWORD PTR _cached_bones$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	edi, DWORD PTR _bones$[ebp]
	add	edi, eax
	mov	ecx, 12					; 0000000cH
	rep movsd

; 2626 : 				break;

	jmp	SHORT $L73392
$L73393:

; 2628 : 		}

	jmp	SHORT $L73391
$L73392:

; 2629 : 
; 2630 : 		if( j >= m_pParentHeader->numbones )

	mov	ecx, DWORD PTR _m_pParentHeader$[ebp]
	mov	edx, DWORD PTR _j$73389[ebp]
	cmp	edx, DWORD PTR [ecx+140]
	jl	$L73397

; 2632 : 			// initialize bonematrix
; 2633 : 			bonematrix = matrix3x4( pos[i], q[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET FLAT:_?q@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4PAVVector4D@@A
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, OFFSET FLAT:_?pos@?1??StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z@4PAVVector@@A
	push	ecx
	lea	ecx, DWORD PTR $T76378[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	mov	esi, eax
	mov	ecx, 12					; 0000000cH
	lea	edi, DWORD PTR _bonematrix$[ebp]
	rep movsd

; 2634 : 			if( pchildbones[i].parent == -1 ) bones[i] = bonematrix;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _pchildbones$[ebp]
	cmp	DWORD PTR [eax+edx+32], -1
	jne	SHORT $L73396
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edi, DWORD PTR _bones$[ebp]
	add	edi, ecx
	mov	ecx, 12					; 0000000cH
	lea	esi, DWORD PTR _bonematrix$[ebp]
	rep movsd

; 2635 : 			else bones[i] = bones[pchildbones[i].parent].ConcatTransforms( bonematrix );

	jmp	SHORT $L73397
$L73396:
	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	edx, DWORD PTR _bonematrix$[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	eax, DWORD PTR $T76380[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _pchildbones$[ebp]
	mov	eax, DWORD PTR [edx+ecx+32]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _bones$[ebp]
	add	ecx, eax
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	esi, eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edi, DWORD PTR _bones$[ebp]
	add	edi, ecx
	mov	ecx, 12					; 0000000cH
	rep movsd
$L73397:

; 2637 : 	}

	jmp	$L73387
$L73388:

; 2638 : 
; 2639 : 	RI->currentmodel = m_pRenderModel = oldmodel;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _oldmodel$[ebp]
	mov	DWORD PTR [edx+19108], eax
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR _oldmodel$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 2640 : 	m_pStudioHeader = oldheader;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _oldheader$[ebp]
	mov	DWORD PTR [eax+19124], ecx

; 2641 : 
; 2642 : 	// restore the bonesetup pointers
; 2643 : 	m_boneSetup.SetStudioPointers( m_pStudioHeader, m_pModelInstance->m_poseparameter );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 7020				; 00001b6cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?SetStudioPointers@CStudioBoneSetup@@QAEXPAUstudiohdr_t@@PBM@Z ; CStudioBoneSetup::SetStudioPointers

; 2644 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?StudioMergeBones@CStudioModelRenderer@@EAEXQAVmatrix3x4@@0PAUmodel_s@@1@Z ENDP ; CStudioModelRenderer::StudioMergeBones
_TEXT	ENDS
;	COMDAT _$E35
_TEXT	SEGMENT
_$E35	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E35	ENDP
_TEXT	ENDS
;	COMDAT _$E34
_TEXT	SEGMENT
_$E34	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E34	ENDP
_TEXT	ENDS
PUBLIC	__real@8@400afa00000000000000
PUBLIC	__real@8@3ffda8f5c30000000000
PUBLIC	?__LINE__Var@?1??StudioBuildNormalTable@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::StudioBuildNormalTable'::`2'::__LINE__Var
EXTRN	_cos:NEAR
EXTRN	_sin:NEAR
;	COMDAT ?__LINE__Var@?1??StudioBuildNormalTable@CStudioModelRenderer@@EAEXXZ@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??StudioBuildNormalTable@CStudioModelRenderer@@EAEXXZ@4FA DW 0a5eH ; `CStudioModelRenderer::StudioBuildNormalTable'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT __real@8@400afa00000000000000
CONST	SEGMENT
__real@8@400afa00000000000000 DQ 040af400000000000r ; 4000
CONST	ENDS
;	COMDAT __real@8@3ffda8f5c30000000000
CONST	SEGMENT
__real@8@3ffda8f5c30000000000 DQ 03fd51eb860000000r ; 0.33
CONST	ENDS
;	COMDAT ?StudioBuildNormalTable@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
_e$ = -8
_pmesh$ = -12
_i$ = -16
_j$ = -20
_ptricmds$73421 = -24
?StudioBuildNormalTable@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::StudioBuildNormalTable, COMDAT

; 2654 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2655 : 	cl_entity_t	*e = m_pCurrentEntity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	DWORD PTR _e$[ebp], ecx

; 2656 : 	mstudiomesh_t	*pmesh;
; 2657 : 	int		i, j;
; 2658 : 
; 2659 : 	ASSERT( m_pSubModel != NULL );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+19132], 0
	jne	SHORT $L73411
	movsx	eax, WORD PTR ?__LINE__Var@?1??StudioBuildNormalTable@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::StudioBuildNormalTable'::`2'::__LINE__Var
	add	eax, 5
	push	eax
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L73411:

; 2660 : 
; 2661 : 	// reset chrome cache
; 2662 : 	for( i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73412
$L73413:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L73412:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $L73414

; 2663 : 		m_chromeAge[i] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+19160], 0
	jmp	SHORT $L73413
$L73414:

; 2664 : 
; 2665 : 	for( i = 0; i < m_pSubModel->numverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73415
$L73416:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L73415:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19132]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	jge	SHORT $L73417

; 2666 : 		m_normaltable[i] = -1;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+153816], -1
	jmp	SHORT $L73416
$L73417:

; 2667 : 
; 2668 : 	for( j = 0; j < m_pSubModel->nummesh; j++ ) 

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L73418
$L73419:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L73418:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19132]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jge	$L73420

; 2670 : 		short	*ptricmds;
; 2671 : 
; 2672 : 		pmesh = (mstudiomesh_t *)((byte *)m_pStudioHeader + m_pSubModel->meshindex) + j;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19132]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	add	edx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 20					; 00000014H
	add	edx, eax
	mov	DWORD PTR _pmesh$[ebp], edx

; 2673 : 		ptricmds = (short *)((byte *)m_pStudioHeader + pmesh->triindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _pmesh$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _ptricmds$73421[ebp], edx
$L73427:

; 2674 : 
; 2675 : 		while( i = *( ptricmds++ ))

	mov	ecx, DWORD PTR _ptricmds$73421[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ptricmds$73421[ebp]
	add	ecx, 2
	mov	DWORD PTR _ptricmds$73421[ebp], ecx
	test	eax, eax
	je	SHORT $L73428

; 2677 : 			if( i < 0 ) i = -i;

	cmp	DWORD PTR _i$[ebp], 0
	jge	SHORT $L73429
	mov	edx, DWORD PTR _i$[ebp]
	neg	edx
	mov	DWORD PTR _i$[ebp], edx
$L73429:

; 2678 : 
; 2679 : 			for( ; i > 0; i--, ptricmds += 4 )

	jmp	SHORT $L73430
$L73431:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ptricmds$73421[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptricmds$73421[ebp], ecx
$L73430:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $L73432

; 2681 : 				if( m_normaltable[ptricmds[0]] < 0 )

	mov	edx, DWORD PTR _ptricmds$73421[ebp]
	movsx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+153816], 0
	jge	SHORT $L73433

; 2682 : 					m_normaltable[ptricmds[0]] = ptricmds[1];

	mov	edx, DWORD PTR _ptricmds$73421[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	ecx, DWORD PTR _ptricmds$73421[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+153816], eax
$L73433:

; 2683 : 			}

	jmp	SHORT $L73431
$L73432:

; 2684 : 		}

	jmp	SHORT $L73427
$L73428:

; 2685 : 	}

	jmp	$L73419
$L73420:

; 2686 : 
; 2687 : 	m_chromeOrigin.x = cos( m_pCvarGlowShellFreq->value * tr.time ) * 4000.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	fld	DWORD PTR [eax+12]
	fmul	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_cos
	add	esp, 8
	fmul	QWORD PTR __real@8@400afa00000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+19148]

; 2688 : 	m_chromeOrigin.y = sin( m_pCvarGlowShellFreq->value * tr.time ) * 4000.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	fld	DWORD PTR [eax+12]
	fmul	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sin
	add	esp, 8
	fmul	QWORD PTR __real@8@400afa00000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+19152]

; 2689 : 	m_chromeOrigin.z = cos( m_pCvarGlowShellFreq->value * tr.time * 0.33f ) * 4000.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	fld	DWORD PTR [eax+12]
	fmul	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fmul	QWORD PTR __real@8@3ffda8f5c30000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_cos
	add	esp, 8
	fmul	QWORD PTR __real@8@400afa00000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+19156]

; 2690 : 
; 2691 : 	if( e->curstate.rendercolor.r || e->curstate.rendercolor.g || e->curstate.rendercolor.b )

	mov	edx, DWORD PTR _e$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+768]
	test	eax, eax
	jne	SHORT $L73435
	mov	ecx, DWORD PTR _e$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+769]
	test	edx, edx
	jne	SHORT $L73435
	mov	eax, DWORD PTR _e$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+770]
	test	ecx, ecx
	je	SHORT $L73434
$L73435:

; 2692 : 		gEngfuncs.pTriAPI->Color4ub( e->curstate.rendercolor.r, e->curstate.rendercolor.g, e->curstate.rendercolor.b, 255 );

	push	255					; 000000ffH
	mov	edx, DWORD PTR _e$[ebp]
	mov	al, BYTE PTR [edx+770]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	mov	dl, BYTE PTR [ecx+769]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	mov	cl, BYTE PTR [eax+768]
	push	ecx
	mov	edx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [edx+20]
	add	esp, 16					; 00000010H

; 2693 : 	else gEngfuncs.pTriAPI->Color4ub( 255, 255, 255, 255 );

	jmp	SHORT $L73436
$L73434:
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	mov	eax, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [eax+20]
	add	esp, 16					; 00000010H
$L73436:

; 2694 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioBuildNormalTable@CStudioModelRenderer@@EAEXXZ ENDP ; CStudioModelRenderer::StudioBuildNormalTable
_TEXT	ENDS
PUBLIC	??YVector@@QAEAAV0@ABV0@@Z			; Vector::operator+=
PUBLIC	?CrossProduct@@YA?AVVector@@ABV1@0@Z		; CrossProduct
PUBLIC	?__LINE__Var@?1??StudioGenerateNormals@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::StudioGenerateNormals'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??StudioGenerateNormals@CStudioModelRenderer@@EAEXXZ@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??StudioGenerateNormals@CStudioModelRenderer@@EAEXXZ@4FA DW 0a91H ; `CStudioModelRenderer::StudioGenerateNormals'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?StudioGenerateNormals@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
$T76393 = -84
$T76394 = -96
$T76395 = -108
$T76396 = -120
$T76397 = -132
$T76398 = -144
$T76399 = -156
_this$ = -4
_e0$ = -16
_e1$ = -28
_norm$ = -40
_v0$ = -44
_v1$ = -48
_v2$ = -52
_pmesh$ = -56
_i$ = -60
_j$ = -64
_ptricmds$73458 = -68
_odd$73477 = -72
?StudioGenerateNormals@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::StudioGenerateNormals, COMDAT

; 2705 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2706 : 	Vector		e0, e1, norm;

	lea	ecx, DWORD PTR _e0$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _e1$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _norm$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2707 : 	int		v0, v1, v2;
; 2708 : 	mstudiomesh_t	*pmesh;
; 2709 : 	int		i, j;
; 2710 : 
; 2711 : 	ASSERT( m_pSubModel != NULL );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+19132], 0
	jne	SHORT $L73451
	movsx	ecx, WORD PTR ?__LINE__Var@?1??StudioGenerateNormals@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::StudioGenerateNormals'::`2'::__LINE__Var
	add	ecx, 6
	push	ecx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L73451:

; 2712 : 
; 2713 : 	for( i = 0; i < m_pSubModel->numverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73452
$L73453:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L73452:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19132]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+80]
	jge	SHORT $L73454

; 2714 : 		m_norms[i] = g_vecZero;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1478364]
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $L73453
$L73454:

; 2715 : 
; 2716 : 	for( j = 0; j < m_pSubModel->nummesh; j++ ) 

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L73455
$L73456:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L73455:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19132]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jge	$L73457

; 2718 : 		short	*ptricmds;
; 2719 : 
; 2720 : 		pmesh = (mstudiomesh_t *)((byte *)m_pStudioHeader + m_pSubModel->meshindex) + j;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19132]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	add	edx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 20					; 00000014H
	add	edx, eax
	mov	DWORD PTR _pmesh$[ebp], edx

; 2721 : 		ptricmds = (short *)((byte *)m_pStudioHeader + pmesh->triindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _pmesh$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _ptricmds$73458[ebp], edx
$L73464:

; 2722 : 
; 2723 : 		while( i = *( ptricmds++ ))

	mov	ecx, DWORD PTR _ptricmds$73458[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ptricmds$73458[ebp]
	add	ecx, 2
	mov	DWORD PTR _ptricmds$73458[ebp], ecx
	test	eax, eax
	je	$L73465

; 2725 : 			if( i < 0 )

	cmp	DWORD PTR _i$[ebp], 0
	jge	$L73466

; 2727 : 				i = -i;

	mov	edx, DWORD PTR _i$[ebp]
	neg	edx
	mov	DWORD PTR _i$[ebp], edx

; 2728 : 
; 2729 : 				if( i > 2 )

	cmp	DWORD PTR _i$[ebp], 2
	jle	$L73467

; 2731 : 					v0 = ptricmds[0]; ptricmds += 4;

	mov	eax, DWORD PTR _ptricmds$73458[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _v0$[ebp], ecx
	mov	edx, DWORD PTR _ptricmds$73458[ebp]
	add	edx, 8
	mov	DWORD PTR _ptricmds$73458[ebp], edx

; 2732 : 					v1 = ptricmds[0]; ptricmds += 4;

	mov	eax, DWORD PTR _ptricmds$73458[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _v1$[ebp], ecx
	mov	edx, DWORD PTR _ptricmds$73458[ebp]
	add	edx, 8
	mov	DWORD PTR _ptricmds$73458[ebp], edx

; 2733 : 
; 2734 : 					for( i -= 2; i > 0; i--, ptricmds += 4 )

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 2
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L73468
$L73469:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _ptricmds$73458[ebp]
	add	edx, 8
	mov	DWORD PTR _ptricmds$73458[ebp], edx
$L73468:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$L73470

; 2736 : 						v2 = ptricmds[0];

	mov	eax, DWORD PTR _ptricmds$73458[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _v2$[ebp], ecx

; 2737 : 
; 2738 : 						e0 = m_verts[v1] - m_verts[v0];

	mov	edx, DWORD PTR _v0$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1281756]
	push	ecx
	lea	edx, DWORD PTR $T76393[ebp]
	push	edx
	mov	eax, DWORD PTR _v1$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+1281756]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _e0$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _e0$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _e0$[ebp+8], edx

; 2739 : 						e1 = m_verts[v2] - m_verts[v0];

	mov	eax, DWORD PTR _v0$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1281756]
	push	edx
	lea	eax, DWORD PTR $T76394[ebp]
	push	eax
	mov	ecx, DWORD PTR _v2$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+1281756]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _e1$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _e1$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _e1$[ebp+8], eax

; 2740 : 						norm = CrossProduct( e1, e0 );

	lea	ecx, DWORD PTR _e0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _e1$[ebp]
	push	edx
	lea	eax, DWORD PTR $T76395[ebp]
	push	eax
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _norm$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _norm$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _norm$[ebp+8], eax

; 2741 : 
; 2742 : 						m_norms[v0] += norm;

	lea	ecx, DWORD PTR _norm$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v0$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1478364]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2743 : 						m_norms[v1] += norm;

	lea	ecx, DWORD PTR _norm$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v1$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1478364]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2744 : 						m_norms[v2] += norm;

	lea	ecx, DWORD PTR _norm$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v2$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1478364]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2745 : 
; 2746 : 						v1 = v2;

	mov	ecx, DWORD PTR _v2$[ebp]
	mov	DWORD PTR _v1$[ebp], ecx

; 2747 : 					}

	jmp	$L73469
$L73470:

; 2749 : 				else

	jmp	SHORT $L73474
$L73467:

; 2751 : 					ptricmds += i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _ptricmds$73458[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _ptricmds$73458[ebp], ecx
$L73474:

; 2754 : 			else

	jmp	$L73486
$L73466:

; 2756 : 				if( i > 2 )

	cmp	DWORD PTR _i$[ebp], 2
	jle	$L73476

; 2758 : 					qboolean	odd = false;

	mov	DWORD PTR _odd$73477[ebp], 0

; 2759 : 
; 2760 : 					v0 = ptricmds[0]; ptricmds += 4;

	mov	edx, DWORD PTR _ptricmds$73458[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR _v0$[ebp], eax
	mov	ecx, DWORD PTR _ptricmds$73458[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptricmds$73458[ebp], ecx

; 2761 : 					v1 = ptricmds[0]; ptricmds += 4;

	mov	edx, DWORD PTR _ptricmds$73458[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR _v1$[ebp], eax
	mov	ecx, DWORD PTR _ptricmds$73458[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptricmds$73458[ebp], ecx

; 2762 : 
; 2763 : 					for( i -= 2; i > 0; i--, ptricmds += 4 )

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 2
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $L73478
$L73479:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ptricmds$73458[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptricmds$73458[ebp], ecx
$L73478:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$L73480

; 2765 : 						v2 = ptricmds[0];

	mov	edx, DWORD PTR _ptricmds$73458[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR _v2$[ebp], eax

; 2766 : 
; 2767 : 						e0 = m_verts[v1] - m_verts[v0];

	mov	ecx, DWORD PTR _v0$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1281756]
	push	eax
	lea	ecx, DWORD PTR $T76396[ebp]
	push	ecx
	mov	edx, DWORD PTR _v1$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1281756]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _e0$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _e0$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _e0$[ebp+8], eax

; 2768 : 						e1 = m_verts[v2] - m_verts[v0];

	mov	ecx, DWORD PTR _v0$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1281756]
	push	eax
	lea	ecx, DWORD PTR $T76397[ebp]
	push	ecx
	mov	edx, DWORD PTR _v2$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1281756]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _e1$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _e1$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _e1$[ebp+8], eax

; 2769 : 						norm = CrossProduct( e1, e0 );

	lea	ecx, DWORD PTR _e0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _e1$[ebp]
	push	edx
	lea	eax, DWORD PTR $T76398[ebp]
	push	eax
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _norm$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _norm$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _norm$[ebp+8], eax

; 2770 : 
; 2771 : 						m_norms[v0] += norm;

	lea	ecx, DWORD PTR _norm$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v0$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1478364]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2772 : 						m_norms[v1] += norm;

	lea	ecx, DWORD PTR _norm$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v1$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1478364]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2773 : 						m_norms[v2] += norm;

	lea	ecx, DWORD PTR _norm$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v2$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1478364]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2774 : 
; 2775 : 						if( odd ) v1 = v2;

	cmp	DWORD PTR _odd$73477[ebp], 0
	je	SHORT $L73484
	mov	ecx, DWORD PTR _v2$[ebp]
	mov	DWORD PTR _v1$[ebp], ecx

; 2776 : 						else v0 = v2;

	jmp	SHORT $L73485
$L73484:
	mov	edx, DWORD PTR _v2$[ebp]
	mov	DWORD PTR _v0$[ebp], edx
$L73485:

; 2777 : 
; 2778 : 						odd = !odd;

	xor	eax, eax
	cmp	DWORD PTR _odd$73477[ebp], 0
	sete	al
	mov	DWORD PTR _odd$73477[ebp], eax

; 2779 : 					}

	jmp	$L73479
$L73480:

; 2781 : 				else

	jmp	SHORT $L73486
$L73476:

; 2783 : 					ptricmds += i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _ptricmds$73458[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _ptricmds$73458[ebp], eax
$L73486:

; 2786 : 		}

	jmp	$L73464
$L73465:

; 2787 : 	}

	jmp	$L73456
$L73457:

; 2788 : 
; 2789 : 	for( i = 0; i < m_pSubModel->numverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73487
$L73488:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L73487:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19132]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	jge	SHORT $L73489

; 2790 : 		m_norms[i] = m_norms[i].Normalize();

	lea	edx, DWORD PTR $T76399[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+1478364]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+edx+1478364]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $L73488
$L73489:

; 2791 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioGenerateNormals@CStudioModelRenderer@@EAEXXZ ENDP ; CStudioModelRenderer::StudioGenerateNormals
_TEXT	ENDS
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??YVector@@QAEAAV0@ABV0@@Z PROC NEAR			; Vector::operator+=, COMDAT

; 159  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		x+=v.x; y+=v.y; z += v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 161  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 162  : 	}			

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??YVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator+=
_TEXT	ENDS
;	COMDAT ?CrossProduct@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT
_a$ = 12
_b$ = 16
___$ReturnUdt$ = 8
$T76404 = -12
?CrossProduct@@YA?AVVector@@ABV1@0@Z PROC NEAR		; CrossProduct, COMDAT

; 291  : inline Vector CrossProduct( const Vector& a, const Vector& b ) { return Vector( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+4]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T76404[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CrossProduct@@YA?AVVector@@ABV1@0@Z ENDP		; CrossProduct
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@QAM@Z				; Vector::Vector
PUBLIC	__real@4@40048000000000000000
EXTRN	?VectorIRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix3x4::VectorIRotate
;	COMDAT __real@4@40048000000000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@4@40048000000000000000 DD 042000000r	; 32
CONST	ENDS
;	COMDAT ?StudioSetupChrome@CStudioModelRenderer@@EAEXPAMHABVVector@@@Z
_TEXT	SEGMENT
$T76407 = -56
$T76408 = -68
$T76409 = -80
$T76410 = -92
$T76411 = -104
$T76412 = -116
$T76413 = -128
$T76414 = -140
$T76415 = -152
$T76416 = -164
_pchrome$ = 8
_bone$ = 12
_normal$ = 16
_this$ = -4
_n$ = -8
_chromeupvec$73499 = -20
_chromerightvec$73500 = -32
_tmp$73501 = -44
?StudioSetupChrome@CStudioModelRenderer@@EAEXPAMHABVVector@@@Z PROC NEAR ; CStudioModelRenderer::StudioSetupChrome, COMDAT

; 2800 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2801 : 	float	n;
; 2802 : 
; 2803 : 	if( m_chromeAge[bone] != m_chromeCount )

	mov	eax, DWORD PTR _bone$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+19160]
	cmp	eax, DWORD PTR [edx+219352]
	je	$L73498

; 2805 : 		// calculate vectors from the viewer to the bone. This roughly adjusts for position
; 2806 : 		Vector	chromeupvec;	// g_chrome t vector in world reference frame

	lea	ecx, DWORD PTR _chromeupvec$73499[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2807 : 		Vector	chromerightvec;	// g_chrome s vector in world reference frame

	lea	ecx, DWORD PTR _chromerightvec$73500[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2808 : 		Vector	tmp;		// vector pointing at bone in world reference frame

	lea	ecx, DWORD PTR _tmp$73501[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2809 : 
; 2810 : 		tmp = (-m_chromeOrigin + m_pworldtransform[bone][3]).Normalize();

	push	3
	mov	ecx, DWORD PTR _bone$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+1274076]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	push	eax
	lea	ecx, DWORD PTR $T76408[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	lea	eax, DWORD PTR $T76410[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76408[ebp]
	push	ecx
	lea	edx, DWORD PTR $T76409[ebp]
	push	edx
	lea	eax, DWORD PTR $T76407[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 19148				; 00004accH
	call	??GVector@@QBE?AV0@XZ			; Vector::operator-
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tmp$73501[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _tmp$73501[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _tmp$73501[ebp+8], eax

; 2811 : 		chromeupvec = CrossProduct( tmp, RI->vright ).Normalize();

	lea	ecx, DWORD PTR $T76412[ebp]
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	edx, 228				; 000000e4H
	push	edx
	lea	eax, DWORD PTR _tmp$73501[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76411[ebp]
	push	ecx
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _chromeupvec$73499[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _chromeupvec$73499[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _chromeupvec$73499[ebp+8], edx

; 2812 : 		chromerightvec = CrossProduct( tmp, chromeupvec ).Normalize();

	lea	eax, DWORD PTR $T76414[ebp]
	push	eax
	lea	ecx, DWORD PTR _chromeupvec$73499[ebp]
	push	ecx
	lea	edx, DWORD PTR _tmp$73501[ebp]
	push	edx
	lea	eax, DWORD PTR $T76413[ebp]
	push	eax
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _chromerightvec$73500[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _chromerightvec$73500[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _chromerightvec$73500[ebp+8], eax

; 2813 : 		m_chromeUp[bone] = m_pworldtransform[bone].VectorIRotate( chromeupvec );

	lea	ecx, DWORD PTR _chromeupvec$73499[ebp]
	push	ecx
	lea	edx, DWORD PTR $T76415[ebp]
	push	edx
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+1274076]
	call	?VectorIRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorIRotate
	mov	edx, DWORD PTR _bone$[ebp]
	imul	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+edx+152280]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 2814 : 		m_chromeRight[bone] = m_pworldtransform[bone].VectorIRotate( chromerightvec );

	lea	ecx, DWORD PTR _chromerightvec$73500[ebp]
	push	ecx
	lea	edx, DWORD PTR $T76416[ebp]
	push	edx
	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+1274076]
	call	?VectorIRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorIRotate
	mov	edx, DWORD PTR _bone$[ebp]
	imul	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+edx+150744]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 2815 : 		m_chromeAge[bone] = m_chromeCount;

	mov	ecx, DWORD PTR _bone$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+219352]
	mov	DWORD PTR [edx+ecx*4+19160], eax
$L73498:

; 2817 : 
; 2818 : 	// calc s coord
; 2819 : 	n = DotProduct( normal, m_chromeRight[bone] );

	mov	ecx, DWORD PTR _bone$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+150744]
	push	eax
	mov	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fst	DWORD PTR _n$[ebp]

; 2820 : 	pchrome[0] = (n + 1.0f) * 32.0f;

	fadd	DWORD PTR __real@4@3fff8000000000000000
	fmul	DWORD PTR __real@4@40048000000000000000
	mov	edx, DWORD PTR _pchrome$[ebp]
	fstp	DWORD PTR [edx]

; 2821 : 
; 2822 : 	// calc t coord
; 2823 : 	n = DotProduct( normal, m_chromeUp[bone] );

	mov	eax, DWORD PTR _bone$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+152280]
	push	edx
	mov	eax, DWORD PTR _normal$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fst	DWORD PTR _n$[ebp]

; 2824 : 	pchrome[1] = (n + 1.0f) * 32.0f;

	fadd	DWORD PTR __real@4@3fff8000000000000000
	fmul	DWORD PTR __real@4@40048000000000000000
	mov	ecx, DWORD PTR _pchrome$[ebp]
	fstp	DWORD PTR [ecx+4]

; 2825 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StudioSetupChrome@CStudioModelRenderer@@EAEXPAMHABVVector@@@Z ENDP ; CStudioModelRenderer::StudioSetupChrome
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@QAM@Z
_TEXT	SEGMENT
_rgfl$ = 8
_this$ = -4
??0Vector@@QAE@QAM@Z PROC NEAR				; Vector::Vector, COMDAT

; 138  : 	inline Vector(float rgfl[3])			{ x = rgfl[0]; y = rgfl[1]; z = rgfl[2];   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@QAM@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ		; matrix3x4::GetOrigin
PUBLIC	?GetAngles@matrix3x4@@QAE?AVVector@@XZ		; matrix3x4::GetAngles
PUBLIC	??_C@_0BM@KMAD@Too?5many?5attachments?5on?5?$CFs?6?$AA@ ; `string'
;	COMDAT ??_C@_0BM@KMAD@Too?5many?5attachments?5on?5?$CFs?6?$AA@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_C@_0BM@KMAD@Too?5many?5attachments?5on?5?$CFs?6?$AA@ DB 'Too many atta'
	DB	'chments on %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?StudioCalcAttachments@CStudioModelRenderer@@EAEXQAVmatrix3x4@@H@Z
_TEXT	SEGMENT
$T76424 = -124
$T76426 = -176
$T76427 = -188
$T76428 = -200
_bones$ = 8
_local_space$ = 12
_this$ = -4
_att$ = -8
_pattachment$ = -12
_e$ = -16
_i$73525 = -20
_i$ = -24
_world$73539 = -72
?StudioCalcAttachments@CStudioModelRenderer@@EAEXQAVmatrix3x4@@H@Z PROC NEAR ; CStudioModelRenderer::StudioCalcAttachments, COMDAT

; 2834 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2835 : 	if( m_pCurrentEntity->modelhandle == INVALID_HANDLE || !m_pModelInstance )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx+2960], 65535		; 0000ffffH
	je	SHORT $L73518
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+19112], 0
	jne	SHORT $L73517
$L73518:

; 2836 : 		return; // too early ?

	jmp	$L73516
$L73517:

; 2837 : 
; 2838 : 	if( FBitSet( m_pModelInstance->info_flags, MF_ATTACHMENTS_DONE ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 16					; 00000010H
	test	edx, edx
	je	SHORT $L73519

; 2839 : 		return; // already computed

	jmp	$L73516
$L73519:

; 2840 : 
; 2841 : 	StudioAttachment_t *att = m_pModelInstance->attachment;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 352				; 00000160H
	mov	DWORD PTR _att$[ebp], ecx

; 2842 : 	mstudioattachment_t *pattachment;
; 2843 : 	cl_entity_t *e = m_pCurrentEntity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	DWORD PTR _e$[ebp], eax

; 2844 : 
; 2845 : 	// prevent to compute env_static bounds every frame
; 2846 : 	if( FBitSet( e->curstate.iuser1, CF_STATIC_ENTITY ))

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+948]
	and	edx, 64					; 00000040H
	test	edx, edx
	je	SHORT $L73523

; 2847 : 		SetBits( m_pModelInstance->info_flags, MF_ATTACHMENTS_DONE );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR [ecx+16]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	DWORD PTR [ecx+16], edx
$L73523:

; 2848 : 
; 2849 : 	if( m_pStudioHeader->numattachments <= 0 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	cmp	DWORD PTR [eax+212], 0
	jg	$L73524

; 2851 : 		// clear attachments
; 2852 : 		for( int i = 0; i < MAXSTUDIOATTACHMENTS; i++ )

	mov	DWORD PTR _i$73525[ebp], 0
	jmp	SHORT $L73526
$L73527:
	mov	ecx, DWORD PTR _i$73525[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$73525[ebp], ecx
$L73526:
	cmp	DWORD PTR _i$73525[ebp], 64		; 00000040H
	jge	$L73528

; 2854 : 			att[i].angles = e->angles;

	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 2900				; 00000b54H
	mov	eax, DWORD PTR _i$73525[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR _att$[ebp]
	lea	eax, DWORD PTR [ecx+eax+92]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 2855 : 			att[i].origin = e->origin;

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 2888				; 00000b48H
	mov	ecx, DWORD PTR _i$73525[ebp]
	imul	ecx, 104				; 00000068H
	mov	edx, DWORD PTR _att$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+80]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 2856 : 			if( i < 4 ) e->attachment[i] = att[i].origin;

	cmp	DWORD PTR _i$73525[ebp], 4
	jge	SHORT $L73529
	mov	ecx, DWORD PTR _i$73525[ebp]
	imul	ecx, 104				; 00000068H
	mov	edx, DWORD PTR _att$[ebp]
	lea	eax, DWORD PTR [edx+ecx+80]
	mov	ecx, DWORD PTR _i$73525[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _e$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+2912]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L73529:

; 2857 : 		}

	jmp	$L73527
$L73528:

; 2858 : 		return;

	jmp	$L73516
$L73524:

; 2860 : 	else if( m_pStudioHeader->numattachments > MAXSTUDIOATTACHMENTS )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	cmp	DWORD PTR [edx+212], 64			; 00000040H
	jle	SHORT $L73531

; 2862 : 		m_pStudioHeader->numattachments = MAXSTUDIOATTACHMENTS; // reduce it

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	DWORD PTR [ecx+212], 64			; 00000040H

; 2863 : 		ALERT( at_error, "Too many attachments on %s\n", e->model->name );

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	push	eax
	push	OFFSET FLAT:??_C@_0BM@KMAD@Too?5many?5attachments?5on?5?$CFs?6?$AA@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH
$L73531:

; 2865 : 
; 2866 : 	// calculate attachment points
; 2867 : 	pattachment = (mstudioattachment_t *)((byte *)m_pStudioHeader + m_pStudioHeader->attachmentindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+216]
	mov	DWORD PTR _pattachment$[ebp], ecx

; 2868 : 
; 2869 : 	for( int i = 0; i < m_pStudioHeader->numattachments; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73536
$L73537:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L73536:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+212]
	jge	$L73538

; 2871 : 		matrix3x4 world = bones[pattachment[i].bone].ConcatTransforms( att[i].local );

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR _att$[ebp]
	lea	edx, DWORD PTR [ecx+eax+32]
	sub	esp, 48					; 00000030H
	mov	ecx, esp
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	eax, DWORD PTR $T76424[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _pattachment$[ebp]
	mov	eax, DWORD PTR [edx+ecx+36]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _bones$[ebp]
	add	ecx, eax
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	push	eax
	lea	ecx, DWORD PTR _world$73539[ebp]
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4

; 2872 : 
; 2873 : 		if( !local_space )

	cmp	DWORD PTR _local_space$[ebp], 0
	jne	SHORT $L73542

; 2875 : 			// turn back to worldspace
; 2876 : 			world = m_pModelInstance->m_protationmatrix.ConcatTransforms( world );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	edx, DWORD PTR _world$73539[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	eax, DWORD PTR $T76426[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+19112]
	add	ecx, 11452				; 00002cbcH
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	esi, eax
	mov	ecx, 12					; 0000000cH
	lea	edi, DWORD PTR _world$73539[ebp]
	rep movsd
$L73542:

; 2878 : 
; 2879 : 		att[i].origin = world.GetOrigin();

	lea	edx, DWORD PTR $T76427[ebp]
	push	edx
	lea	ecx, DWORD PTR _world$73539[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 104				; 00000068H
	mov	edx, DWORD PTR _att$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+80]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 2880 : 		att[i].angles = world.GetAngles();

	lea	ecx, DWORD PTR $T76428[ebp]
	push	ecx
	lea	ecx, DWORD PTR _world$73539[ebp]
	call	?GetAngles@matrix3x4@@QAE?AVVector@@XZ	; matrix3x4::GetAngles
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 104				; 00000068H
	mov	ecx, DWORD PTR _att$[ebp]
	lea	edx, DWORD PTR [ecx+edx+92]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 2881 : 		if( i < 4 ) e->attachment[i] = att[i].origin;

	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L73547
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 104				; 00000068H
	mov	edx, DWORD PTR _att$[ebp]
	lea	eax, DWORD PTR [edx+ecx+80]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _e$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+2912]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L73547:

; 2882 : 	}

	jmp	$L73537
$L73538:
$L73516:

; 2883 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?StudioCalcAttachments@CStudioModelRenderer@@EAEXQAVmatrix3x4@@H@Z ENDP ; CStudioModelRenderer::StudioCalcAttachments
_TEXT	ENDS
;	COMDAT ?GetOrigin@matrix3x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
?GetOrigin@matrix3x4@@QBE?AVVector@@XZ PROC NEAR	; matrix3x4::GetOrigin, COMDAT

; 524  : 	Vector	GetOrigin() const { return mat[3]; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetOrigin@matrix3x4@@QBE?AVVector@@XZ ENDP		; matrix3x4::GetOrigin
_TEXT	ENDS
PUBLIC	__real@4@3ff583126f0000000000
PUBLIC	__real@4@4004e52ee10000000000
EXTRN	_atan2:NEAR
;	COMDAT __real@4@3ff583126f0000000000
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@4@3ff583126f0000000000 DD 03a83126fr	; 0.001
CONST	ENDS
;	COMDAT __real@4@4004e52ee10000000000
CONST	SEGMENT
__real@4@4004e52ee10000000000 DD 042652ee1r	; 57.2958
CONST	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_xyDist$ = -8
_angles$ = -20
?GetAngles@matrix3x4@@QAE?AVVector@@XZ PROC NEAR	; matrix3x4::GetAngles, COMDAT

; 534  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 535  : 		float xyDist = sqrt( mat[0][0] * mat[0][0] + mat[0][1] * mat[0][1] );

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi+4]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -24+[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _xyDist$[ebp]

; 536  : 		Vector angles;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 537  : 
; 538  : 		// enough here to get angles?
; 539  : 		if( xyDist > 0.001f )

	fld	DWORD PTR _xyDist$[ebp]
	fcomp	DWORD PTR __real@4@3ff583126f0000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L55482

; 541  : 			angles[0] = RAD2DEG( atan2( -mat[0][2], xyDist ) );

	fld	DWORD PTR _xyDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -28+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -32+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -32+[ebp]
	mov	DWORD PTR [eax], ecx

; 542  : 			angles[1] = RAD2DEG( atan2( mat[0][1], mat[0][0] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -36+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -40+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax+4], edx

; 543  : 			angles[2] = RAD2DEG( atan2( mat[1][2], mat[2][2] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -44+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -48+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 545  : 		else	// forward is mostly Z, gimbal lock

	jmp	$L55489
$L55482:

; 547  : 			angles[0] = RAD2DEG( atan2( -mat[0][2], xyDist ) );

	fld	DWORD PTR _xyDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -52+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -56+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax], edx

; 548  : 			angles[1] = RAD2DEG( atan2( -mat[1][0], mat[1][1] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -60+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -64+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 549  : 			angles[2] = 0.0f;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0
$L55489:

; 551  : 
; 552  : 		return angles;

	lea	edx, DWORD PTR _angles$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 553  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAngles@matrix3x4@@QAE?AVVector@@XZ ENDP		; matrix3x4::GetAngles
_TEXT	ENDS
PUBLIC	?StudioGetAttachment@CStudioModelRenderer@@QAEXPBUcl_entity_s@@HPAVVector@@1H@Z ; CStudioModelRenderer::StudioGetAttachment
;	COMDAT ?StudioGetAttachment@CStudioModelRenderer@@QAEXPBUcl_entity_s@@HPAVVector@@1H@Z
_TEXT	SEGMENT
_ent$ = 8
_iAttachment$ = 12
_origin$ = 16
_angles$ = 20
_flags$ = 24
_this$ = -4
_studio_flags$ = -8
_inst$ = -12
?StudioGetAttachment@CStudioModelRenderer@@QAEXPBUcl_entity_s@@HPAVVector@@1H@Z PROC NEAR ; CStudioModelRenderer::StudioGetAttachment, COMDAT

; 2892 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2893 : 	int	studio_flags = STUDIO_EVENTS;

	mov	DWORD PTR _studio_flags$[ebp], 2

; 2894 : 
; 2895 : 	if( FBitSet( flags, AF_FORCE_RECALC ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L73557

; 2896 : 		SetBits( studio_flags, STUDIO_FORCE );

	mov	ecx, DWORD PTR _studio_flags$[ebp]
	or	ecx, 4
	mov	DWORD PTR _studio_flags$[ebp], ecx
$L73557:

; 2897 : 
; 2898 : 	if( FBitSet( flags, AF_LOCAL_SPACE ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 2
	test	edx, edx
	je	SHORT $L73558

; 2899 : 		SetBits( studio_flags, STUDIO_LOCAL_SPACE );

	mov	eax, DWORD PTR _studio_flags$[ebp]
	or	al, 8
	mov	DWORD PTR _studio_flags$[ebp], eax
$L73558:

; 2900 : 
; 2901 : 	if( !ent || !ent->model || ( !origin && !angles  ))

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $L73560
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+2964], 0
	je	SHORT $L73560
	cmp	DWORD PTR _origin$[ebp], 0
	jne	SHORT $L73559
	cmp	DWORD PTR _angles$[ebp], 0
	jne	SHORT $L73559
$L73560:

; 2902 : 		return;

	jmp	$L73555
$L73559:

; 2903 : 
; 2904 : 	RI->currententity = (cl_entity_t *)ent;

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+16], eax

; 2905 : 	RI->currentmodel = ent->model;

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	mov	DWORD PTR [ecx+20], eax

; 2906 : 	if( !RI->currentmodel ) return;

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $L73562
	jmp	$L73555
$L73562:

; 2907 : 
; 2908 : 	// force to compute attachments
; 2909 : 	SET_CURRENT_ENTITY( RI->currententity );

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+32
	add	esp, 4

; 2910 : 	StudioDrawModel( studio_flags );

	mov	ecx, DWORD PTR _studio_flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+4]

; 2911 : 
; 2912 : 	SET_CURRENT_ENTITY( NULL );

	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+32
	add	esp, 4

; 2913 : 	RI->currententity = NULL;

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	DWORD PTR [ecx+16], 0

; 2914 : 	RI->currentmodel = NULL;

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	DWORD PTR [edx+20], 0

; 2915 : 
; 2916 : 	if( ent->modelhandle == INVALID_HANDLE )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+2960], 65535		; 0000ffffH
	jne	SHORT $L73563

; 2917 : 		return; // too early ?

	jmp	$L73555
$L73563:

; 2918 : 
; 2919 : 	ModelInstance_t *inst = &m_ModelInstances[ent->modelhandle];

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	dx, WORD PTR [ecx+2960]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	DWORD PTR _inst$[ebp], eax

; 2920 : 
; 2921 : 	// make sure we not overflow
; 2922 : 	iAttachment = bound( 0, iAttachment, inst->numattachments - 1 );

	cmp	DWORD PTR _iAttachment$[ebp], 0
	jl	SHORT $L76441
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR [eax+7008]
	sub	ecx, 1
	cmp	DWORD PTR _iAttachment$[ebp], ecx
	jge	SHORT $L76439
	mov	edx, DWORD PTR _iAttachment$[ebp]
	mov	DWORD PTR -16+[ebp], edx
	jmp	SHORT $L76440
$L76439:
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR [eax+7008]
	sub	ecx, 1
	mov	DWORD PTR -16+[ebp], ecx
$L76440:
	mov	edx, DWORD PTR -16+[ebp]
	mov	DWORD PTR -20+[ebp], edx
	jmp	SHORT $L76442
$L76441:
	mov	DWORD PTR -20+[ebp], 0
$L76442:
	mov	eax, DWORD PTR -20+[ebp]
	mov	DWORD PTR _iAttachment$[ebp], eax

; 2923 : 
; 2924 : 	if( origin ) *origin = inst->attachment[iAttachment].origin;

	cmp	DWORD PTR _origin$[ebp], 0
	je	SHORT $L73565
	mov	ecx, DWORD PTR _iAttachment$[ebp]
	imul	ecx, 104				; 00000068H
	mov	edx, DWORD PTR _inst$[ebp]
	lea	eax, DWORD PTR [edx+ecx+432]
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L73565:

; 2925 : 	if( angles ) *angles = inst->attachment[iAttachment].angles;

	cmp	DWORD PTR _angles$[ebp], 0
	je	SHORT $L73566
	mov	ecx, DWORD PTR _iAttachment$[ebp]
	imul	ecx, 104				; 00000068H
	mov	edx, DWORD PTR _inst$[ebp]
	lea	eax, DWORD PTR [edx+ecx+444]
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L73566:
$L73555:

; 2926 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?StudioGetAttachment@CStudioModelRenderer@@QAEXPBUcl_entity_s@@HPAVVector@@1H@Z ENDP ; CStudioModelRenderer::StudioGetAttachment
_TEXT	ENDS
PUBLIC	?StudioGetAttachmentNumber@CStudioModelRenderer@@QAEHPBUcl_entity_s@@PBD@Z ; CStudioModelRenderer::StudioGetAttachmentNumber
;	COMDAT ?StudioGetAttachmentNumber@CStudioModelRenderer@@QAEHPBUcl_entity_s@@PBD@Z
_TEXT	SEGMENT
_ent$ = 8
_attachment$ = 12
_this$ = -4
_inst$ = -8
_i$ = -12
_att$73579 = -16
?StudioGetAttachmentNumber@CStudioModelRenderer@@QAEHPBUcl_entity_s@@PBD@Z PROC NEAR ; CStudioModelRenderer::StudioGetAttachmentNumber, COMDAT

; 2935 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2936 : 	if( !ent || ent->modelhandle == INVALID_HANDLE )

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $L73573
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+2960], 65535		; 0000ffffH
	jne	SHORT $L73572
$L73573:

; 2937 : 		return -1;

	or	eax, -1
	jmp	SHORT $L73571
$L73572:

; 2938 : 
; 2939 : 	ModelInstance_t *inst = &m_ModelInstances[ent->modelhandle];

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	dx, WORD PTR [ecx+2960]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	DWORD PTR _inst$[ebp], eax

; 2940 : 
; 2941 : 	for( int i = 0; i < inst->numattachments; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73576
$L73577:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L73576:
	mov	ecx, DWORD PTR _inst$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+7008]
	jge	SHORT $L73578

; 2943 : 		StudioAttachment_t *att = &inst->attachment[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR _inst$[ebp]
	lea	edx, DWORD PTR [ecx+eax+352]
	mov	DWORD PTR _att$73579[ebp], edx

; 2944 : 		if( !Q_stricmp( att->name, attachment ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _attachment$[ebp]
	push	eax
	mov	ecx, DWORD PTR _att$73579[ebp]
	push	ecx
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L73580

; 2945 : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $L73571
$L73580:

; 2946 : 	}

	jmp	SHORT $L73577
$L73578:

; 2947 : 
; 2948 : 	return -1;

	or	eax, -1
$L73571:

; 2949 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?StudioGetAttachmentNumber@CStudioModelRenderer@@QAEHPBUcl_entity_s@@PBD@Z ENDP ; CStudioModelRenderer::StudioGetAttachmentNumber
_TEXT	ENDS
PUBLIC	?StudioSequenceDuration@CStudioModelRenderer@@QAEMPBUcl_entity_s@@H@Z ; CStudioModelRenderer::StudioSequenceDuration
EXTRN	?LocalDuration@CStudioBoneSetup@@QAEMH@Z:NEAR	; CStudioBoneSetup::LocalDuration
;	COMDAT ?StudioSequenceDuration@CStudioModelRenderer@@QAEMPBUcl_entity_s@@H@Z
_TEXT	SEGMENT
_ent$ = 8
_sequence$ = 12
_this$ = -4
?StudioSequenceDuration@CStudioModelRenderer@@QAEMPBUcl_entity_s@@H@Z PROC NEAR ; CStudioModelRenderer::StudioSequenceDuration, COMDAT

; 2952 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2953 : 	if( !StudioSetEntity( (cl_entity_t *)ent ))

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUcl_entity_s@@@Z ; CStudioModelRenderer::StudioSetEntity
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L73587

; 2954 : 		return 0.0f;

	fld	DWORD PTR __real@4@00000000000000000000
	jmp	SHORT $L73585
$L73587:

; 2955 : 	return m_boneSetup.LocalDuration( sequence );

	mov	ecx, DWORD PTR _sequence$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?LocalDuration@CStudioBoneSetup@@QAEMH@Z ; CStudioBoneSetup::LocalDuration
$L73585:

; 2956 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?StudioSequenceDuration@CStudioModelRenderer@@QAEMPBUcl_entity_s@@H@Z ENDP ; CStudioModelRenderer::StudioSequenceDuration
_TEXT	ENDS
;	COMDAT ?StudioSetupModel@CStudioModelRenderer@@EAEHHPAPAX0@Z
_TEXT	SEGMENT
_bodypart$ = 8
_ppbodypart$ = 12
_ppsubmodel$ = 16
_this$ = -4
_pbodypart$ = -8
_psubmodel$ = -12
_index$ = -16
?StudioSetupModel@CStudioModelRenderer@@EAEHHPAPAX0@Z PROC NEAR ; CStudioModelRenderer::StudioSetupModel, COMDAT

; 2966 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2967 : 	mstudiobodyparts_t *pbodypart;
; 2968 : 	mstudiomodel_t *psubmodel;
; 2969 : 	int index;
; 2970 : 
; 2971 : 	if( bodypart > m_pStudioHeader->numbodyparts )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _bodypart$[ebp]
	cmp	edx, DWORD PTR [ecx+204]
	jle	SHORT $L73597

; 2972 : 		bodypart = 0;

	mov	DWORD PTR _bodypart$[ebp], 0
$L73597:

; 2973 : 	pbodypart = (mstudiobodyparts_t *)((byte *)m_pStudioHeader + m_pStudioHeader->bodypartindex) + bodypart;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+208]
	mov	ecx, DWORD PTR _bodypart$[ebp]
	imul	ecx, 76					; 0000004cH
	add	eax, ecx
	mov	DWORD PTR _pbodypart$[ebp], eax

; 2974 : 
; 2975 : 	index = m_pCurrentEntity->curstate.body / pbodypart->base;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	ecx, DWORD PTR _pbodypart$[ebp]
	mov	eax, DWORD PTR [eax+788]
	cdq
	idiv	DWORD PTR [ecx+68]
	mov	DWORD PTR _index$[ebp], eax

; 2976 : 	index = index % pbodypart->nummodels;

	mov	ecx, DWORD PTR _pbodypart$[ebp]
	mov	eax, DWORD PTR _index$[ebp]
	cdq
	idiv	DWORD PTR [ecx+64]
	mov	DWORD PTR _index$[ebp], edx

; 2977 : 
; 2978 : 	psubmodel = (mstudiomodel_t *)((byte *)m_pStudioHeader + pbodypart->modelindex) + index;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _pbodypart$[ebp]
	add	eax, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _index$[ebp]
	imul	edx, 112				; 00000070H
	add	eax, edx
	mov	DWORD PTR _psubmodel$[ebp], eax

; 2979 : 
; 2980 : 	*ppbodypart = pbodypart;

	mov	eax, DWORD PTR _ppbodypart$[ebp]
	mov	ecx, DWORD PTR _pbodypart$[ebp]
	mov	DWORD PTR [eax], ecx

; 2981 : 	*ppsubmodel = psubmodel;

	mov	edx, DWORD PTR _ppsubmodel$[ebp]
	mov	eax, DWORD PTR _psubmodel$[ebp]
	mov	DWORD PTR [edx], eax

; 2982 : 
; 2983 : 	return index;

	mov	eax, DWORD PTR _index$[ebp]

; 2984 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StudioSetupModel@CStudioModelRenderer@@EAEHHPAPAX0@Z ENDP ; CStudioModelRenderer::StudioSetupModel
_TEXT	ENDS
PUBLIC	__real@4@3ffecccccd0000000000
PUBLIC	__real@4@3ffdfd70a40000000000
PUBLIC	__real@4@3fffbf5c290000000000
PUBLIC	__real@4@3ff78080810000000000
EXTRN	?r_fullbright@@3PAUcvar_s@@A:DWORD		; r_fullbright
EXTRN	?worldmodel@@3PAUmodel_s@@A:DWORD		; worldmodel
;	COMDAT __real@4@3ffecccccd0000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@4@3ffecccccd0000000000 DD 03f4ccccdr	; 0.8
CONST	ENDS
;	COMDAT __real@4@3ffdfd70a40000000000
CONST	SEGMENT
__real@4@3ffdfd70a40000000000 DD 03efd70a4r	; 0.495
CONST	ENDS
;	COMDAT __real@4@3fffbf5c290000000000
CONST	SEGMENT
__real@4@3fffbf5c290000000000 DD 03fbf5c29r	; 1.495
CONST	ENDS
;	COMDAT __real@4@3ff78080810000000000
CONST	SEGMENT
__real@4@3ff78080810000000000 DD 03b808081r	; 0.00392157
CONST	ENDS
;	COMDAT ?StudioLighting@CStudioModelRenderer@@EAEXPAMHHABVVector@@@Z
_TEXT	SEGMENT
_lv$ = 8
_bone$ = 12
_flags$ = 16
_normal$ = 20
_this$ = -4
_light$ = -8
_illum$ = -12
_lightcos$73616 = -16
?StudioLighting@CStudioModelRenderer@@EAEXPAMHHABVVector@@@Z PROC NEAR ; CStudioModelRenderer::StudioLighting, COMDAT

; 2994 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2995 : 	mstudiolight_t	*light = &m_pModelInstance->lighting;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _light$[ebp], ecx

; 2996 : 
; 2997 : 	if( FBitSet( flags, STUDIO_NF_FULLBRIGHT ) || FBitSet( m_pCurrentEntity->curstate.effects, EF_FULLBRIGHT ) || R_FullBright( ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4
	test	edx, edx
	jne	SHORT $L73612
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	edx, DWORD PTR [ecx+748]
	and	edx, 134217728				; 08000000H
	test	edx, edx
	jne	SHORT $L73612
	cmp	DWORD PTR ?r_fullbright@@3PAUcvar_s@@A, 0 ; r_fullbright
	je	SHORT $L76451
	mov	eax, DWORD PTR ?r_fullbright@@3PAUcvar_s@@A ; r_fullbright
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76451
	mov	BYTE PTR -20+[ebp], 1
	jmp	SHORT $L76452
$L76451:
	mov	BYTE PTR -20+[ebp], 0
$L76452:
	mov	ecx, DWORD PTR -20+[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L73612
	mov	edx, DWORD PTR ?worldmodel@@3PAUmodel_s@@A ; worldmodel
	cmp	DWORD PTR [edx+380], 0
	jne	SHORT $L73610
$L73612:

; 2999 : 		*lv = 1.0f;

	mov	eax, DWORD PTR _lv$[ebp]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 3000 : 		return;

	jmp	$L73608
$L73610:

; 3002 : 
; 3003 : 	float	illum = light->ambientlight;

	mov	ecx, DWORD PTR _light$[ebp]
	fild	DWORD PTR [ecx]
	fstp	DWORD PTR _illum$[ebp]

; 3004 : 
; 3005 : 	if( FBitSet( flags, STUDIO_NF_FLATSHADE ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 1
	test	edx, edx
	je	SHORT $L73614

; 3007 : 		illum += light->shadelight * 0.8f;

	mov	eax, DWORD PTR _light$[ebp]
	fild	DWORD PTR [eax+4]
	fmul	DWORD PTR __real@4@3ffecccccd0000000000
	fadd	DWORD PTR _illum$[ebp]
	fstp	DWORD PTR _illum$[ebp]

; 3009 :           else

	jmp	$L73615
$L73614:

; 3011 : 		float	lightcos;
; 3012 : 
; 3013 : 		if( bone != -1 ) lightcos = DotProduct( normal, m_bonelightvecs[bone] );

	cmp	DWORD PTR _bone$[ebp], -1
	je	SHORT $L73617
	mov	ecx, DWORD PTR _bone$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1280220]
	push	eax
	mov	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _lightcos$73616[ebp]

; 3014 : 		else lightcos = DotProduct( normal, light->plightvec ); // -1 colinear, 1 opposite

	jmp	SHORT $L73618
$L73617:
	mov	edx, DWORD PTR _light$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	eax, DWORD PTR _normal$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _lightcos$73616[ebp]
$L73618:

; 3015 : 		if( lightcos > 1.0f ) lightcos = 1.0f;

	fld	DWORD PTR _lightcos$73616[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L73619
	mov	DWORD PTR _lightcos$73616[ebp], 1065353216 ; 3f800000H
$L73619:

; 3016 : 
; 3017 : 		illum += light->shadelight;

	mov	ecx, DWORD PTR _light$[ebp]
	fild	DWORD PTR [ecx+4]
	fadd	DWORD PTR _illum$[ebp]
	fstp	DWORD PTR _illum$[ebp]

; 3018 : 
; 3019 :  		// do modified hemispherical lighting
; 3020 : 		lightcos = (lightcos + ( SHADE_LAMBERT - 1.0f )) / SHADE_LAMBERT;

	fld	DWORD PTR _lightcos$73616[ebp]
	fadd	DWORD PTR __real@4@3ffdfd70a40000000000
	fdiv	DWORD PTR __real@4@3fffbf5c290000000000
	fstp	DWORD PTR _lightcos$73616[ebp]

; 3021 : 		if( lightcos > 0.0f )

	fld	DWORD PTR _lightcos$73616[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L73620

; 3022 : 			illum -= light->shadelight * lightcos; 

	mov	edx, DWORD PTR _light$[ebp]
	fild	DWORD PTR [edx+4]
	fmul	DWORD PTR _lightcos$73616[ebp]
	fsubr	DWORD PTR _illum$[ebp]
	fstp	DWORD PTR _illum$[ebp]
$L73620:

; 3023 : 		illum = Q_max( illum, 0.0f );

	fld	DWORD PTR _illum$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76453
	mov	eax, DWORD PTR _illum$[ebp]
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L76454
$L76453:
	mov	DWORD PTR -24+[ebp], 0
$L76454:
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR _illum$[ebp], ecx
$L73615:

; 3025 : 
; 3026 : 	illum = Q_min( illum, 255.0f );

	fld	DWORD PTR _illum$[ebp]
	fcomp	DWORD PTR __real@4@4006ff00000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L76455
	mov	edx, DWORD PTR _illum$[ebp]
	mov	DWORD PTR -28+[ebp], edx
	jmp	SHORT $L76456
$L76455:
	mov	DWORD PTR -28+[ebp], 1132396544		; 437f0000H
$L76456:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR _illum$[ebp], eax

; 3027 : 	*lv = illum * (1.0f / 255.0f);

	fld	DWORD PTR _illum$[ebp]
	fmul	DWORD PTR __real@4@3ff78080810000000000
	mov	ecx, DWORD PTR _lv$[ebp]
	fstp	DWORD PTR [ecx]
$L73608:

; 3028 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?StudioLighting@CStudioModelRenderer@@EAEXPAMHHABVVector@@@Z ENDP ; CStudioModelRenderer::StudioLighting
_TEXT	ENDS
PUBLIC	??0alight_s@@QAE@XZ				; alight_s::alight_s
EXTRN	?r_dynamic@@3PAUcvar_s@@A:DWORD			; r_dynamic
;	COMDAT ?StudioStaticLight@CStudioModelRenderer@@EAEXPAUcl_entity_s@@@Z
_TEXT	SEGMENT
$T76467 = -64
$T76468 = -76
_ent$ = 8
_this$ = -4
_cacheID$73626 = -8
_vl$73627 = -12
_dynamic$73635 = -16
_lighting$73636 = -40
_dir$73637 = -52
?StudioStaticLight@CStudioModelRenderer@@EAEXPAUcl_entity_s@@@Z PROC NEAR ; CStudioModelRenderer::StudioStaticLight, COMDAT

; 3037 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3038 : 	// setup advanced vertexlighting for env_static entities
; 3039 : 	if(( ent->curstate.iuser3 > 0 ) && world->vertex_lighting != NULL )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+956], 0
	jle	$L73631
	mov	ecx, DWORD PTR ?world@@3PAUgl_world_t@@A ; world
	cmp	DWORD PTR [ecx+120], 0
	je	SHORT $L73631

; 3041 : 		int		cacheID = ent->curstate.iuser3 - 1;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+956]
	sub	eax, 1
	mov	DWORD PTR _cacheID$73626[ebp], eax

; 3042 : 		dvlightlump_t	*vl = world->vertex_lighting;

	mov	ecx, DWORD PTR ?world@@3PAUgl_world_t@@A ; world
	mov	edx, DWORD PTR [ecx+120]
	mov	DWORD PTR _vl$73627[ebp], edx

; 3043 : 
; 3044 : 		if( FBitSet( m_pModelInstance->info_flags, MF_VERTEX_LIGHTING ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 2
	test	edx, edx
	je	SHORT $L73628

; 3048 : 		else if( !FBitSet( m_pModelInstance->info_flags, MF_VL_BAD_CACHE ))

	jmp	SHORT $L73631
$L73628:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 4
	test	edx, edx
	jne	SHORT $L73631

; 3050 : 			// first initialization
; 3051 : 			if( cacheID < vl->nummodels && vl->dataofs[cacheID] != -1 )

	mov	eax, DWORD PTR _vl$73627[ebp]
	mov	ecx, DWORD PTR _cacheID$73626[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $L73631
	mov	edx, DWORD PTR _cacheID$73626[ebp]
	mov	eax, DWORD PTR _vl$73627[ebp]
	cmp	DWORD PTR [eax+edx*4+12], -1
	je	SHORT $L73631

; 3053 : 				// we have ID of vertex light cache and cache is present
; 3054 : 				CreateMeshCacheVL( (dmodellight_t *)((byte *)world->vertex_lighting + vl->dataofs[cacheID]), cacheID );

	mov	ecx, DWORD PTR _cacheID$73626[ebp]
	push	ecx
	mov	edx, DWORD PTR ?world@@3PAUgl_world_t@@A ; world
	mov	eax, DWORD PTR [edx+120]
	mov	ecx, DWORD PTR _cacheID$73626[ebp]
	mov	edx, DWORD PTR _vl$73627[ebp]
	add	eax, DWORD PTR [edx+ecx*4+12]
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]
$L73631:

; 3058 : 
; 3059 : 	if( !FBitSet( m_pModelInstance->info_flags, MF_VERTEX_LIGHTING ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 2
	test	edx, edx
	jne	$L73634

; 3061 : 		float	dynamic = r_dynamic->value;

	mov	eax, DWORD PTR ?r_dynamic@@3PAUcvar_s@@A ; r_dynamic
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _dynamic$73635[ebp], ecx

; 3062 : 		alight_t	lighting;

	lea	ecx, DWORD PTR _lighting$73636[ebp]
	call	??0alight_s@@QAE@XZ			; alight_s::alight_s

; 3063 : 		Vector	dir;

	lea	ecx, DWORD PTR _dir$73637[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 3064 : 
; 3065 : 		lighting.plightvec = dir;

	lea	ecx, DWORD PTR _dir$73637[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR _lighting$73636[ebp+20], eax

; 3066 : 
; 3067 : 		// setup classic Half-Life lighting
; 3068 : 		r_dynamic->value = 0.0f; // ignore dlights

	mov	edx, DWORD PTR ?r_dynamic@@3PAUcvar_s@@A ; r_dynamic
	mov	DWORD PTR [edx+12], 0

; 3069 : 		IEngineStudio.StudioDynamicLight( ent, &lighting );

	lea	eax, DWORD PTR _lighting$73636[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+88
	add	esp, 8

; 3070 : 		r_dynamic->value = dynamic;

	mov	edx, DWORD PTR ?r_dynamic@@3PAUcvar_s@@A ; r_dynamic
	mov	eax, DWORD PTR _dynamic$73635[ebp]
	mov	DWORD PTR [edx+12], eax

; 3071 : 
; 3072 : 		m_pModelInstance->lighting.ambientlight = lighting.ambientlight;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _lighting$73636[ebp]
	mov	DWORD PTR [edx+28], eax

; 3073 : 		m_pModelInstance->lighting.shadelight = lighting.shadelight;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _lighting$73636[ebp+4]
	mov	DWORD PTR [edx+32], eax

; 3074 : 		m_pModelInstance->lighting.color = lighting.color;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 36					; 00000024H
	mov	eax, DWORD PTR _lighting$73636[ebp+8]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _lighting$73636[ebp+12]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _lighting$73636[ebp+16]
	mov	DWORD PTR [edx+8], eax

; 3075 : 		m_pModelInstance->lighting.plightvec = m_pModelInstance->m_plightmatrix.VectorIRotate( lighting.plightvec ); // turn back to model space

	mov	ecx, DWORD PTR _lighting$73636[ebp+20]
	push	ecx
	lea	ecx, DWORD PTR $T76467[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	lea	edx, DWORD PTR $T76467[ebp]
	push	edx
	lea	eax, DWORD PTR $T76468[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+19112]
	add	ecx, 11500				; 00002cecH
	call	?VectorIRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorIRotate
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	add	ecx, 48					; 00000030H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L73634:

; 3077 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StudioStaticLight@CStudioModelRenderer@@EAEXPAUcl_entity_s@@@Z ENDP ; CStudioModelRenderer::StudioStaticLight
_TEXT	ENDS
;	COMDAT ??0alight_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0alight_s@@QAE@XZ PROC NEAR				; alight_s::alight_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0alight_s@@QAE@XZ ENDP				; alight_s::alight_s
_TEXT	ENDS
EXTRN	?HUD_StudioEvent@@YAXPBUmstudioevent_s@@PBUcl_entity_s@@@Z:NEAR ; HUD_StudioEvent
;	COMDAT ?StudioClientEvents@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pseqdesc$ = -8
_pevent$ = -12
_f$ = -16
_start$ = -20
_i$ = -24
?StudioClientEvents@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::StudioClientEvents, COMDAT

; 3086 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3087 : 	mstudioseqdesc_t	*pseqdesc;
; 3088 : 	mstudioevent_t	*pevent;
; 3089 : 
; 3090 : 	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->curstate.sequence;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+168]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	ecx, DWORD PTR [edx+732]
	imul	ecx, 176				; 000000b0H
	add	eax, ecx
	mov	DWORD PTR _pseqdesc$[ebp], eax

; 3091 : 	pevent = (mstudioevent_t *)((byte *)m_pStudioHeader + pseqdesc->eventindex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	add	eax, DWORD PTR [ecx+52]
	mov	DWORD PTR _pevent$[ebp], eax

; 3092 : 
; 3093 : 	// no events for this animation or gamepaused
; 3094 : 	if( pseqdesc->numevents == 0 || tr.time == tr.oldtime )

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $L73653
	fld	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fcomp	QWORD PTR ?tr@@3Uref_globals_t@@A+16
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L73652
$L73653:

; 3095 : 		return;

	jmp	$L73645
$L73652:

; 3096 : 
; 3097 : 	float f = StudioEstimateFrame( pseqdesc ) + 0.01f; // get start offset

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+64]
	fadd	DWORD PTR __real@4@3ff8a3d70a0000000000
	fst	DWORD PTR _f$[ebp]

; 3098 : 	float start = f - m_pCurrentEntity->curstate.framerate * (tr.time - tr.oldtime) * pseqdesc->fps;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	fld	DWORD PTR [ecx+784]
	fld	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fsub	QWORD PTR ?tr@@3Uref_globals_t@@A+16
	fmulp	ST(1), ST(0)
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	fmul	DWORD PTR [edx+32]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _start$[ebp]

; 3099 : 
; 3100 : 	for( int i = 0; i < pseqdesc->numevents; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73657
$L73658:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L73657:
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+48]
	jge	SHORT $L73659

; 3102 : 		// ignore all non-client-side events
; 3103 : 		if( pevent[i].event < EVENT_CLIENT )

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _pevent$[ebp]
	cmp	DWORD PTR [ecx+eax+4], 5000		; 00001388H
	jge	SHORT $L73660

; 3104 : 			continue;

	jmp	SHORT $L73658
$L73660:

; 3105 : 
; 3106 : 		if( (float)pevent[i].frame > start && f >= (float)pevent[i].frame )

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR _pevent$[ebp]
	fild	DWORD PTR [eax+edx]
	fcomp	DWORD PTR _start$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L73663
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _pevent$[ebp]
	fild	DWORD PTR [edx+ecx]
	fcomp	DWORD PTR _f$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L73663

; 3107 : 			HUD_StudioEvent( &pevent[i], m_pCurrentEntity );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR _pevent$[ebp]
	add	eax, edx
	push	eax
	call	?HUD_StudioEvent@@YAXPBUmstudioevent_s@@PBUcl_entity_s@@@Z ; HUD_StudioEvent
	add	esp, 8
$L73663:

; 3108 : 	}

	jmp	SHORT $L73658
$L73659:
$L73645:

; 3109 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioClientEvents@CStudioModelRenderer@@EAEXXZ ENDP	; CStudioModelRenderer::StudioClientEvents
_TEXT	ENDS
EXTRN	?pglBlendFunc@@3P6GXII@ZA:DWORD			; pglBlendFunc
EXTRN	?pglColor4f@@3P6GXMMMM@ZA:DWORD			; pglColor4f
EXTRN	?pglEnable@@3P6GXI@ZA:DWORD			; pglEnable
EXTRN	?pglTexEnvf@@3P6GXIIM@ZA:DWORD			; pglTexEnvf
EXTRN	?GL_DepthMask@@YAXH@Z:NEAR			; GL_DepthMask
EXTRN	?pglTexEnvi@@3P6GXIIH@ZA:DWORD			; pglTexEnvi
;	COMDAT ?StudioSetRenderMode@CStudioModelRenderer@@EAEXH@Z
_TEXT	SEGMENT
_rendermode$ = 8
_this$ = -4
?StudioSetRenderMode@CStudioModelRenderer@@EAEXH@Z PROC NEAR ; CStudioModelRenderer::StudioSetRenderMode, COMDAT

; 3118 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3119 : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR ?pglDisable@@3P6GXI@ZA	; pglDisable

; 3122 : 	{

	mov	eax, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 0
	je	SHORT $L73672
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L73673
	cmp	DWORD PTR -8+[ebp], 5
	je	SHORT $L73674
	jmp	$L73675
$L73672:

; 3123 : 	case kRenderNormal:
; 3124 : 		break;

	jmp	$L73669
$L73673:

; 3125 : 	case kRenderTransColor:
; 3126 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR ?pglBlendFunc@@3P6GXII@ZA	; pglBlendFunc

; 3127 : 		pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR ?pglTexEnvi@@3P6GXIIH@ZA	; pglTexEnvi

; 3128 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR ?pglEnable@@3P6GXI@ZA		; pglEnable

; 3129 : 		break;

	jmp	$L73669
$L73674:

; 3130 : 	case kRenderTransAdd:
; 3131 : 		pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	1174667264				; 46040000H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR ?pglTexEnvf@@3P6GXIIM@ZA	; pglTexEnvf

; 3132 : 		pglColor4f( tr.blend, tr.blend, tr.blend, 1.0f );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1411976
	push	ecx
	mov	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1411976
	push	edx
	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+1411976
	push	eax
	call	DWORD PTR ?pglColor4f@@3P6GXMMMM@ZA	; pglColor4f

; 3133 : 		pglBlendFunc( GL_ONE, GL_ONE );

	push	1
	push	1
	call	DWORD PTR ?pglBlendFunc@@3P6GXII@ZA	; pglBlendFunc

; 3134 : 		GL_DepthMask( GL_FALSE );

	push	0
	call	?GL_DepthMask@@YAXH@Z			; GL_DepthMask
	add	esp, 4

; 3135 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR ?pglEnable@@3P6GXI@ZA		; pglEnable

; 3136 : 		break;

	jmp	SHORT $L73669
$L73675:

; 3137 : 	default:
; 3138 : 		pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	1174667264				; 46040000H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR ?pglTexEnvf@@3P6GXIIM@ZA	; pglTexEnvf

; 3139 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR ?pglBlendFunc@@3P6GXII@ZA	; pglBlendFunc

; 3140 : 		pglColor4f( 1.0f, 1.0f, 1.0f, tr.blend );

	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1411976
	push	ecx
	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	call	DWORD PTR ?pglColor4f@@3P6GXMMMM@ZA	; pglColor4f

; 3141 : 		GL_DepthMask( GL_TRUE );

	push	1
	call	?GL_DepthMask@@YAXH@Z			; GL_DepthMask
	add	esp, 4

; 3142 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR ?pglEnable@@3P6GXI@ZA		; pglEnable
$L73669:

; 3145 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StudioSetRenderMode@CStudioModelRenderer@@EAEXH@Z ENDP	; CStudioModelRenderer::StudioSetRenderMode
_TEXT	ENDS
PUBLIC	?StudioDrawMeshChrome@CStudioModelRenderer@@AAEXPAFMMM@Z ; CStudioModelRenderer::StudioDrawMeshChrome
PUBLIC	__real@4@3ff88000000000000000
PUBLIC	?__LINE__Var@?1??StudioDrawPoints@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::StudioDrawPoints'::`2'::__LINE__Var
EXTRN	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix3x4::VectorTransform
;	COMDAT ?__LINE__Var@?1??StudioDrawPoints@CStudioModelRenderer@@EAEXXZ@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??StudioDrawPoints@CStudioModelRenderer@@EAEXXZ@4FA DW 0c71H ; `CStudioModelRenderer::StudioDrawPoints'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT __real@4@3ff88000000000000000
CONST	SEGMENT
__real@4@3ff88000000000000000 DD 03c000000r	; 0.0078125
CONST	ENDS
;	COMDAT ?StudioDrawPoints@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_pvertbone$73731 = -100
_i$73733 = -104
_pstudionorms$ = -108
_pnormbone$ = -112
_ptricmds$73754 = -116
_s$73757 = -120
_t$73759 = -124
$T76481 = -136
$T76482 = -148
$T76485 = -160
_this$ = -4
_shellscale$ = -8
_i$ = -12
_j$ = -16
_k$ = -20
_ptexture$ = -24
_pstudioverts$ = -28
_pmesh$ = -32
_m_skinnum$ = -36
_pskinref$ = -40
_pvertweight$73721 = -44
_skinMat$73724 = -92
_i$73725 = -96
?StudioDrawPoints@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::StudioDrawPoints, COMDAT

; 3185 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3186 : 	float	shellscale = 0.0f;

	mov	DWORD PTR _shellscale$[ebp], 0

; 3187 : 	int	i, j, k;
; 3188 : 
; 3189 : 	ASSERT( m_pStudioHeader != NULL );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+19124], 0
	jne	SHORT $L73705
	movsx	ecx, WORD PTR ?__LINE__Var@?1??StudioDrawPoints@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::StudioDrawPoints'::`2'::__LINE__Var
	add	ecx, 4
	push	ecx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L73705:

; 3190 : 
; 3191 : 
; 3192 : 	// grab the model textures array (with remap infos)
; 3193 : 	mstudiotexture_t *ptexture = (mstudiotexture_t *)((byte *)m_pStudioHeader + m_pStudioHeader->textureindex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	add	edx, DWORD PTR [eax+184]
	mov	DWORD PTR _ptexture$[ebp], edx

; 3194 : 	Vector *pstudioverts = (Vector *)((byte *)m_pStudioHeader + m_pSubModel->vertindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+88]
	mov	DWORD PTR _pstudioverts$[ebp], eax

; 3195 : 	mstudiomesh_t *pmesh = (mstudiomesh_t *)((byte *)m_pStudioHeader + m_pSubModel->meshindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+76]
	mov	DWORD PTR _pmesh$[ebp], ecx

; 3196 : 	int m_skinnum = bound( 0, m_pCurrentEntity->curstate.skin, MAXSTUDIOSKINS - 1 );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	movsx	ecx, WORD PTR [eax+744]
	test	ecx, ecx
	jl	SHORT $L76479
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	movsx	ecx, WORD PTR [eax+744]
	cmp	ecx, 255				; 000000ffH
	jge	SHORT $L76477
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	movsx	ecx, WORD PTR [eax+744]
	mov	DWORD PTR -164+[ebp], ecx
	jmp	SHORT $L76478
$L76477:
	mov	DWORD PTR -164+[ebp], 255		; 000000ffH
$L76478:
	mov	edx, DWORD PTR -164+[ebp]
	mov	DWORD PTR -168+[ebp], edx
	jmp	SHORT $L76480
$L76479:
	mov	DWORD PTR -168+[ebp], 0
$L76480:
	mov	eax, DWORD PTR -168+[ebp]
	mov	DWORD PTR _m_skinnum$[ebp], eax

; 3197 : 	short *pskinref = (short *)((byte *)m_pStudioHeader + m_pStudioHeader->skinindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+200]
	mov	DWORD PTR _pskinref$[ebp], ecx

; 3198 : 	if( m_skinnum != 0 && m_skinnum < m_pStudioHeader->numskinfamilies )

	cmp	DWORD PTR _m_skinnum$[ebp], 0
	je	SHORT $L73719
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _m_skinnum$[ebp]
	cmp	ecx, DWORD PTR [eax+196]
	jge	SHORT $L73719

; 3199 : 		pskinref += (m_skinnum * m_pStudioHeader->numskinref);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _m_skinnum$[ebp]
	imul	ecx, DWORD PTR [eax+192]
	mov	edx, DWORD PTR _pskinref$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pskinref$[ebp], eax
$L73719:

; 3200 : 	m_chromeCount++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+219352]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+219352], edx

; 3201 : 
; 3202 : 	if( FBitSet( m_pStudioHeader->flags, STUDIO_HAS_BONEWEIGHTS ) && m_pSubModel->blendvertinfoindex != 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR [edx+136]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	je	$L73720
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19132]
	cmp	DWORD PTR [edx+104], 0
	je	$L73720

; 3204 : 		mstudioboneweight_t	*pvertweight = (mstudioboneweight_t *)((byte *)m_pStudioHeader + m_pSubModel->blendvertinfoindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+104]
	mov	DWORD PTR _pvertweight$73721[ebp], eax

; 3205 : 		matrix3x4 skinMat;

	lea	ecx, DWORD PTR _skinMat$73724[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 3206 : 
; 3207 : 		// compute weighted vertexes
; 3208 : 		for( int i = 0; i < m_pSubModel->numverts; i++ )

	mov	DWORD PTR _i$73725[ebp], 0
	jmp	SHORT $L73726
$L73727:
	mov	ecx, DWORD PTR _i$73725[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$73725[ebp], ecx
$L73726:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19132]
	mov	ecx, DWORD PTR _i$73725[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	jge	SHORT $L73728

; 3210 : 			ComputeSkinMatrix( &pvertweight[i], m_pworldtransform, skinMat );

	lea	edx, DWORD PTR _skinMat$73724[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1274076				; 001370dcH
	push	eax
	mov	ecx, DWORD PTR _i$73725[ebp]
	mov	edx, DWORD PTR _pvertweight$73721[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 3211 : 			m_verts[i] = skinMat.VectorTransform( pstudioverts[i] );

	mov	eax, DWORD PTR _i$73725[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pstudioverts$[ebp]
	add	ecx, eax
	push	ecx
	lea	edx, DWORD PTR $T76481[ebp]
	push	edx
	lea	ecx, DWORD PTR _skinMat$73724[ebp]
	call	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorTransform
	mov	ecx, DWORD PTR _i$73725[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+1281756]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 3212 : 		}

	jmp	SHORT $L73727
$L73728:

; 3214 : 	else

	jmp	$L73736
$L73720:

; 3216 : 		byte *pvertbone = ((byte *)m_pStudioHeader + m_pSubModel->vertinfoindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+84]
	mov	DWORD PTR _pvertbone$73731[ebp], ecx

; 3217 : 
; 3218 : 		// compute unweighted vertexes
; 3219 : 		for( int i = 0; i < m_pSubModel->numverts; i++ )

	mov	DWORD PTR _i$73733[ebp], 0
	jmp	SHORT $L73734
$L73735:
	mov	edx, DWORD PTR _i$73733[ebp]
	add	edx, 1
	mov	DWORD PTR _i$73733[ebp], edx
$L73734:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19132]
	mov	edx, DWORD PTR _i$73733[ebp]
	cmp	edx, DWORD PTR [ecx+80]
	jge	SHORT $L73736

; 3220 : 			m_verts[i] = m_pworldtransform[pvertbone[i]].VectorTransform( pstudioverts[i] );

	mov	eax, DWORD PTR _i$73733[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pstudioverts$[ebp]
	add	ecx, eax
	push	ecx
	lea	edx, DWORD PTR $T76482[ebp]
	push	edx
	mov	eax, DWORD PTR _pvertbone$73731[ebp]
	add	eax, DWORD PTR _i$73733[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+1274076]
	call	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorTransform
	mov	ecx, DWORD PTR _i$73733[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+1281756]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $L73735
$L73736:

; 3222 : 
; 3223 : 	// generate shared normals for properly scaling glowing shell
; 3224 : 	shellscale = Q_max( GLOWSHELL_FACTOR, RI->currententity->curstate.renderamt * GLOWSHELL_FACTOR );

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx+16]
	fild	DWORD PTR [edx+764]
	fmul	DWORD PTR __real@4@3ff88000000000000000
	fcomp	DWORD PTR __real@4@3ff88000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L76483
	mov	DWORD PTR -172+[ebp], 1006632960	; 3c000000H
	jmp	SHORT $L76484
$L76483:
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+16]
	fild	DWORD PTR [ecx+764]
	fmul	DWORD PTR __real@4@3ff88000000000000000
	fstp	DWORD PTR -172+[ebp]
$L76484:
	mov	edx, DWORD PTR -172+[ebp]
	mov	DWORD PTR _shellscale$[ebp], edx

; 3225 : 	StudioBuildNormalTable();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+168]

; 3226 : 	StudioGenerateNormals();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+172]

; 3227 : 
; 3228 : 	Vector *pstudionorms = (Vector *)((byte *)m_pStudioHeader + m_pSubModel->normindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+100]
	mov	DWORD PTR _pstudionorms$[ebp], eax

; 3229 : 	byte *pnormbone = ((byte *)m_pStudioHeader + m_pSubModel->norminfoindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+96]
	mov	DWORD PTR _pnormbone$[ebp], ecx

; 3230 : 
; 3231 : 	for( j = k = 0; j < m_pSubModel->nummesh; j++ ) 

	mov	DWORD PTR _k$[ebp], 0
	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _j$[ebp], edx
	jmp	SHORT $L73743
$L73744:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L73743:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19132]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+72]
	jge	SHORT $L73745

; 3233 : 		for( i = 0; i < pmesh[j].numnorms; i++, k++, pstudionorms++, pnormbone++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73746
$L73747:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
	mov	eax, DWORD PTR _pstudionorms$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pstudionorms$[ebp], eax
	mov	ecx, DWORD PTR _pnormbone$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pnormbone$[ebp], ecx
$L73746:
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _pmesh$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+12]
	jge	SHORT $L73748

; 3234 : 			StudioSetupChrome( m_chrome[k], *pnormbone, (float *)pstudionorms );

	mov	edx, DWORD PTR _pstudionorms$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T76485[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	lea	eax, DWORD PTR $T76485[ebp]
	push	eax
	mov	ecx, DWORD PTR _pnormbone$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8+19672]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+84]
	jmp	SHORT $L73747
$L73748:

; 3235 : 	}

	jmp	$L73744
$L73745:

; 3236 : 
; 3237 : 	for( j = 0; j < m_pSubModel->nummesh; j++ ) 

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L73751
$L73752:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L73751:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19132]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+72]
	jge	SHORT $L73753

; 3239 : 		short	*ptricmds = (short *)((byte *)m_pStudioHeader + pmesh[j].triindex);

	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	edx, DWORD PTR _pmesh$[ebp]
	add	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _ptricmds$73754[ebp], eax

; 3240 : 		float	s = 1.0f / (float)ptexture[pskinref[pmesh->skinref]].width;

	mov	eax, DWORD PTR _pmesh$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _pskinref$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR _ptexture$[ebp]
	fild	DWORD PTR [ecx+eax+68]
	fdivr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _s$73757[ebp]

; 3241 : 		float	t = 1.0f / (float)ptexture[pskinref[pmesh->skinref]].height;

	mov	edx, DWORD PTR _pmesh$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _pskinref$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	imul	edx, 80					; 00000050H
	mov	eax, DWORD PTR _ptexture$[ebp]
	fild	DWORD PTR [eax+edx+72]
	fdivr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _t$73759[ebp]

; 3242 : 
; 3243 : 		StudioDrawMeshChrome( ptricmds, s, t, shellscale );

	mov	ecx, DWORD PTR _shellscale$[ebp]
	push	ecx
	mov	edx, DWORD PTR _t$73759[ebp]
	push	edx
	mov	eax, DWORD PTR _s$73757[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptricmds$73754[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioDrawMeshChrome@CStudioModelRenderer@@AAEXPAFMMM@Z ; CStudioModelRenderer::StudioDrawMeshChrome

; 3244 : 	}

	jmp	$L73752
$L73753:

; 3245 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioDrawPoints@CStudioModelRenderer@@EAEXXZ ENDP	; CStudioModelRenderer::StudioDrawPoints
_TEXT	ENDS
EXTRN	?pglTexCoord2f@@3P6GXMM@ZA:DWORD		; pglTexCoord2f
;	COMDAT ?StudioDrawMeshChrome@CStudioModelRenderer@@AAEXPAFMMM@Z
_TEXT	SEGMENT
$T76490 = -36
$T76491 = -48
_ptricmds$ = 8
_s$ = 12
_t$ = 16
_scale$ = 20
_this$ = -4
_i$ = -8
_idx$73692 = -12
_v$73693 = -24
?StudioDrawMeshChrome@CStudioModelRenderer@@AAEXPAFMMM@Z PROC NEAR ; CStudioModelRenderer::StudioDrawMeshChrome, COMDAT

; 3154 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
$L73685:

; 3155 : 	int	i;
; 3156 : 
; 3157 : 	while( i = *( ptricmds++ ))

	mov	eax, DWORD PTR _ptricmds$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _ptricmds$[ebp]
	add	eax, 2
	mov	DWORD PTR _ptricmds$[ebp], eax
	test	edx, edx
	je	$L73686

; 3159 : 		if( i < 0 )

	cmp	DWORD PTR _i$[ebp], 0
	jge	SHORT $L73687

; 3161 : 			pglBegin( GL_TRIANGLE_FAN );

	push	6
	call	DWORD PTR ?pglBegin@@3P6GXI@ZA		; pglBegin

; 3162 : 			i = -i;

	mov	ecx, DWORD PTR _i$[ebp]
	neg	ecx
	mov	DWORD PTR _i$[ebp], ecx

; 3164 : 		else pglBegin( GL_TRIANGLE_STRIP );

	jmp	SHORT $L73688
$L73687:
	push	5
	call	DWORD PTR ?pglBegin@@3P6GXI@ZA		; pglBegin
$L73688:

; 3165 : 
; 3166 : 		for( ; i > 0; i--, ptricmds += 4 )

	jmp	SHORT $L73689
$L73690:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _ptricmds$[ebp]
	add	eax, 8
	mov	DWORD PTR _ptricmds$[ebp], eax
$L73689:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$L73691

; 3168 : 			int idx = m_normaltable[ptricmds[0]];

	mov	ecx, DWORD PTR _ptricmds$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+153816]
	mov	DWORD PTR _idx$73692[ebp], ecx

; 3169 : 			Vector v = m_verts[ptricmds[0]] + m_norms[ptricmds[0]] * scale;

	mov	edx, DWORD PTR _scale$[ebp]
	push	edx
	lea	eax, DWORD PTR $T76490[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptricmds$[ebp]
	movsx	edx, WORD PTR [ecx]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1478364]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T76491[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+1281756]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _v$73693[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 3170 : 			pglTexCoord2f( m_chrome[idx][0] * s, m_chrome[idx][1] * t );

	mov	edx, DWORD PTR _idx$73692[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR [eax+edx*8+19676]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _idx$73692[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [edx+ecx*8+19672]
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR ?pglTexCoord2f@@3P6GXMM@ZA	; pglTexCoord2f

; 3171 : 			pglVertex3fv( v );

	lea	ecx, DWORD PTR _v$73693[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 3172 : 		}

	jmp	$L73690
$L73691:

; 3173 : 
; 3174 : 		pglEnd();

	call	DWORD PTR ?pglEnd@@3P6GXXZA		; pglEnd

; 3175 : 	}

	jmp	$L73685
$L73686:

; 3176 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?StudioDrawMeshChrome@CStudioModelRenderer@@AAEXPAFMMM@Z ENDP ; CStudioModelRenderer::StudioDrawMeshChrome
_TEXT	ENDS
;	COMDAT ?StudioDrawShell@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$73768 = -8
_i$73775 = -12
_i$ = -16
_pweaponmodel$ = -20
$T76495 = -72
?StudioDrawShell@CStudioModelRenderer@@EAEXXZ PROC NEAR	; CStudioModelRenderer::StudioDrawShell, COMDAT

; 3254 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3255 : 	if( FBitSet( RI->params, RP_SHADOWVIEW ))

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	je	SHORT $L73765

; 3256 : 		return;

	jmp	$L73764
$L73765:

; 3257 : 
; 3258 : 	if( m_pCurrentEntity->curstate.renderfx != kRenderFxGlowShell )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	cmp	DWORD PTR [eax+772], 19			; 00000013H
	je	SHORT $L73766

; 3259 : 		return;

	jmp	$L73764
$L73766:

; 3260 : 
; 3261 : 	// setup worldtransform array
; 3262 : 	if( m_pRenderModel->poseToBone != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	cmp	DWORD PTR [edx+376], 0
	je	$L73767

; 3264 : 		for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$73768[ebp], 0
	jmp	SHORT $L73769
$L73770:
	mov	eax, DWORD PTR _i$73768[ebp]
	add	eax, 1
	mov	DWORD PTR _i$73768[ebp], eax
$L73769:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$73768[ebp]
	cmp	eax, DWORD PTR [edx+140]
	jge	SHORT $L73771

; 3265 : 			m_pworldtransform[i] = m_pModelInstance->m_pbones[i].ConcatTransforms( m_pRenderModel->poseToBone->posetobone[i] );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	eax, DWORD PTR _i$73768[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR [edx+376]
	add	ecx, eax
	sub	esp, 48					; 00000030H
	mov	edx, esp
	push	ecx
	mov	ecx, edx
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	eax, DWORD PTR $T76495[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$73768[ebp]
	imul	eax, 48					; 00000030H
	lea	ecx, DWORD PTR [edx+eax+11548]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	esi, eax
	mov	ecx, DWORD PTR _i$73768[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [edx+ecx+1274076]
	mov	ecx, 12					; 0000000cH
	rep movsd
	jmp	SHORT $L73770
$L73771:

; 3267 : 	else

	jmp	SHORT $L73778
$L73767:

; 3269 : 		// no pose to bone just copy the bones
; 3270 : 		for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$73775[ebp], 0
	jmp	SHORT $L73776
$L73777:
	mov	eax, DWORD PTR _i$73775[ebp]
	add	eax, 1
	mov	DWORD PTR _i$73775[ebp], eax
$L73776:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$73775[ebp]
	cmp	eax, DWORD PTR [edx+140]
	jge	SHORT $L73778

; 3271 : 			m_pworldtransform[i] = m_pModelInstance->m_pbones[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$73775[ebp]
	imul	eax, 48					; 00000030H
	lea	esi, DWORD PTR [edx+eax+11548]
	mov	ecx, DWORD PTR _i$73775[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [edx+ecx+1274076]
	mov	ecx, 12					; 0000000cH
	rep movsd
	jmp	SHORT $L73777
$L73778:

; 3273 : 
; 3274 : 	gEngfuncs.pTriAPI->SpriteTexture( m_pChromeSprite, 0 );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19144]
	push	ecx
	mov	edx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [edx+44]
	add	esp, 8

; 3275 : 
; 3276 : 	for( int i = 0; i < m_pStudioHeader->numbodyparts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73780
$L73781:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L73780:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+204]
	jge	SHORT $L73782

; 3278 : 		StudioSetupModel( i, (void **)&m_pBodyPart, (void **)&m_pSubModel );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 19132				; 00004abcH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 19128				; 00004ab8H
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+92]

; 3279 : 		IEngineStudio.GL_SetRenderMode( kRenderTransAdd );

	push	5
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+168
	add	esp, 4

; 3280 : 		StudioDrawPoints();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+112]

; 3281 : 	}

	jmp	SHORT $L73781
$L73782:

; 3282 : 
; 3283 : 	model_t *pweaponmodel = NULL;

	mov	DWORD PTR _pweaponmodel$[ebp], 0

; 3284 : 
; 3285 : 	if( m_pCurrentEntity->curstate.weaponmodel )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx+868], 0
	je	SHORT $L73786

; 3286 : 		pweaponmodel = IEngineStudio.GetModelByIndex( m_pCurrentEntity->curstate.weaponmodel );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	ecx, DWORD PTR [eax+868]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+20
	add	esp, 4
	mov	DWORD PTR _pweaponmodel$[ebp], eax
$L73786:

; 3287 : 
; 3288 : 	if( pweaponmodel )

	cmp	DWORD PTR _pweaponmodel$[ebp], 0
	je	$L73787

; 3290 : 		m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( pweaponmodel );

	mov	edx, DWORD PTR _pweaponmodel$[ebp]
	push	edx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19124], eax

; 3291 : 
; 3292 : 		// FIXME: allow boneweights for weaponmodel?
; 3293 : 		for( i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73789
$L73790:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L73789:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+140]
	jge	SHORT $L73791

; 3294 : 			m_pworldtransform[i] = m_pModelInstance->m_pwpnbones[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	lea	esi, DWORD PTR [ecx+edx+17692]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [ecx+eax+1274076]
	mov	ecx, 12					; 0000000cH
	rep movsd
	jmp	SHORT $L73790
$L73791:

; 3295 : 
; 3296 : 		for( i = 0; i < m_pStudioHeader->numbodyparts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73792
$L73793:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L73792:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+204]
	jge	SHORT $L73794

; 3298 : 			StudioSetupModel( i, (void **)&m_pBodyPart, (void **)&m_pSubModel );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 19132				; 00004abcH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 19128				; 00004ab8H
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+92]

; 3299 : 			IEngineStudio.GL_SetRenderMode( kRenderTransAdd );

	push	5
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+168
	add	esp, 4

; 3300 : 			StudioDrawPoints();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+112]

; 3301 : 		}

	jmp	SHORT $L73793
$L73794:

; 3302 : 
; 3303 : 		m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+19124], eax
$L73787:
$L73764:

; 3305 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioDrawShell@CStudioModelRenderer@@EAEXXZ ENDP	; CStudioModelRenderer::StudioDrawShell
_TEXT	ENDS
PUBLIC	?StudioDrawHulls@CStudioModelRenderer@@AAEXXZ	; CStudioModelRenderer::StudioDrawHulls
PUBLIC	__real@4@40018000000000000000
EXTRN	?R_TransformForEntity@@YAXABVmatrix4x4@@@Z:NEAR	; R_TransformForEntity
EXTRN	?g_hullcolor@@3PAY02MA:BYTE			; g_hullcolor
EXTRN	?g_boxpnt@@3PAY03HA:BYTE			; g_boxpnt
EXTRN	?r_drawentities@@3PAUcvar_s@@A:DWORD		; r_drawentities
;	COMDAT __real@4@40018000000000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@4@40018000000000000000 DD 040800000r	; 4
CONST	ENDS
;	COMDAT ?StudioDrawHulls@CStudioModelRenderer@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4
_alpha$ = -8
_lv$ = -12
_i$ = -16
_j$ = -20
_pbbox$73816 = -24
_tmp$73819 = -36
_p$73820 = -132
$T76498 = -196
$T76499 = -208
$T76506 = -220
?StudioDrawHulls@CStudioModelRenderer@@AAEXXZ PROC NEAR	; CStudioModelRenderer::StudioDrawHulls, COMDAT

; 3314 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3315 : 	float	alpha, lv;
; 3316 : 	int	i, j;
; 3317 : 
; 3318 : 	if( r_drawentities->value == 4 )

	mov	eax, DWORD PTR ?r_drawentities@@3PAUcvar_s@@A ; r_drawentities
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@40018000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L73806

; 3319 : 		alpha = 0.5f;

	mov	DWORD PTR _alpha$[ebp], 1056964608	; 3f000000H

; 3320 : 	else alpha = 1.0f;

	jmp	SHORT $L73807
$L73806:
	mov	DWORD PTR _alpha$[ebp], 1065353216	; 3f800000H
$L73807:

; 3321 : 
; 3322 : 	R_TransformForEntity( m_pModelInstance->m_protationmatrix );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 11452				; 00002cbcH
	push	edx
	lea	ecx, DWORD PTR $T76498[ebp]
	call	??0matrix4x4@@QAE@ABVmatrix3x4@@@Z	; matrix4x4::matrix4x4
	lea	eax, DWORD PTR $T76498[ebp]
	push	eax
	call	?R_TransformForEntity@@YAXABVmatrix4x4@@@Z ; R_TransformForEntity
	add	esp, 4

; 3323 : 
; 3324 : 	// setup bone lighting
; 3325 : 	for( i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73809
$L73810:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L73809:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $L73811

; 3326 : 		m_bonelightvecs[i] = m_pModelInstance->m_pbones[i].VectorIRotate( m_pModelInstance->lighting.plightvec );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 48					; 00000030H
	push	eax
	lea	ecx, DWORD PTR $T76499[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	lea	ecx, DWORD PTR [eax+ecx+11548]
	call	?VectorIRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorIRotate
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+edx+1280220]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $L73810
$L73811:

; 3327 : 
; 3328 : 	GL_Bind( GL_TEXTURE0, tr.whiteTexture );

	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+32
	push	ecx
	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+132
	add	esp, 8

; 3329 : 	pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	1174667264				; 46040000H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR ?pglTexEnvf@@3P6GXIIM@ZA	; pglTexEnvf

; 3330 : 
; 3331 : 	for( i = 0; i < m_pStudioHeader->numhitboxes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73813
$L73814:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L73813:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+156]
	jge	$L73815

; 3333 : 		mstudiobbox_t	*pbbox = (mstudiobbox_t *)((byte *)m_pStudioHeader + m_pStudioHeader->hitboxindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+160]
	mov	DWORD PTR _pbbox$73816[ebp], eax

; 3334 : 		vec3_t		tmp, p[8];

	lea	ecx, DWORD PTR _tmp$73819[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	8
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _p$73820[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 3335 : 
; 3336 : 		for( j = 0; j < 8; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L73822
$L73823:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L73822:
	cmp	DWORD PTR _j$[ebp], 8
	jge	$L73824

; 3338 : 			tmp[0] = (j & 1) ? pbbox[i].bbmin[0] : pbbox[i].bbmax[0];

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L76500
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _pbbox$73816[ebp]
	lea	ecx, DWORD PTR [edx+ecx+8]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR -224+[ebp], eax
	jmp	SHORT $L76501
$L76500:
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _pbbox$73816[ebp]
	lea	ecx, DWORD PTR [edx+ecx+20]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR -224+[ebp], eax
$L76501:
	lea	ecx, DWORD PTR _tmp$73819[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -224+[ebp]
	mov	DWORD PTR [eax], ecx

; 3339 : 			tmp[1] = (j & 2) ? pbbox[i].bbmin[1] : pbbox[i].bbmax[1];

	mov	edx, DWORD PTR _j$[ebp]
	and	edx, 2
	test	edx, edx
	je	SHORT $L76502
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _pbbox$73816[ebp]
	lea	ecx, DWORD PTR [ecx+eax+8]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR -228+[ebp], edx
	jmp	SHORT $L76503
$L76502:
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _pbbox$73816[ebp]
	lea	ecx, DWORD PTR [ecx+eax+20]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR -228+[ebp], edx
$L76503:
	lea	ecx, DWORD PTR _tmp$73819[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -228+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 3340 : 			tmp[2] = (j & 4) ? pbbox[i].bbmin[2] : pbbox[i].bbmax[2];

	mov	edx, DWORD PTR _j$[ebp]
	and	edx, 4
	test	edx, edx
	je	SHORT $L76504
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _pbbox$73816[ebp]
	lea	ecx, DWORD PTR [ecx+eax+8]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR -232+[ebp], edx
	jmp	SHORT $L76505
$L76504:
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _pbbox$73816[ebp]
	lea	ecx, DWORD PTR [ecx+eax+20]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR -232+[ebp], edx
$L76505:
	lea	ecx, DWORD PTR _tmp$73819[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -232+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 3341 : 			p[j] = m_pModelInstance->m_pbones[pbbox[i].bone].VectorTransform( tmp );

	lea	edx, DWORD PTR _tmp$73819[ebp]
	push	edx
	lea	eax, DWORD PTR $T76506[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _pbbox$73816[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	imul	eax, 48					; 00000030H
	lea	ecx, DWORD PTR [edx+eax+11548]
	call	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorTransform
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR _p$73820[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 3342 : 		}

	jmp	$L73823
$L73824:

; 3343 : 
; 3344 : 		j = (pbbox[i].group % ARRAYSIZE( g_hullcolor ));

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _pbbox$73816[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	mov	DWORD PTR _j$[ebp], edx

; 3345 : 
; 3346 : 		gEngfuncs.pTriAPI->Begin( TRI_QUADS );

	push	2
	mov	edx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [edx+8]
	add	esp, 4

; 3347 : 		gEngfuncs.pTriAPI->Color4f( g_hullcolor[j][0], g_hullcolor[j][1], g_hullcolor[j][2], alpha );

	mov	eax, DWORD PTR _alpha$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?g_hullcolor@@3PAY02MA[ecx+8]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?g_hullcolor@@3PAY02MA[eax+4]
	push	ecx
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?g_hullcolor@@3PAY02MA[edx]
	push	eax
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [ecx+16]
	add	esp, 16					; 00000010H

; 3348 : 
; 3349 : 		for( j = 0; j < 6; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L73826
$L73827:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L73826:
	cmp	DWORD PTR _j$[ebp], 6
	jge	$L73828

; 3351 : 			tmp = g_vecZero;

	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR _tmp$73819[ebp], eax
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR _tmp$73819[ebp+4], ecx
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR _tmp$73819[ebp+8], edx

; 3352 : 			tmp[j % 3] = (j < 3) ? 1.0f : -1.0f;

	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $L76507
	mov	DWORD PTR -236+[ebp], 1065353216	; 3f800000H
	jmp	SHORT $L76508
$L76507:
	mov	DWORD PTR -236+[ebp], -1082130432	; bf800000H
$L76508:
	lea	ecx, DWORD PTR _tmp$73819[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, eax
	mov	eax, DWORD PTR _j$[ebp]
	cdq
	mov	esi, 3
	idiv	esi
	mov	eax, DWORD PTR -236+[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 3353 : 			StudioLighting( &lv, pbbox[i].bone, 0, tmp );

	lea	ecx, DWORD PTR _tmp$73819[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _pbbox$73816[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	lea	edx, DWORD PTR _lv$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+108]

; 3354 : 
; 3355 : 			gEngfuncs.pTriAPI->Brightness( lv );

	mov	eax, DWORD PTR _lv$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [ecx+36]
	add	esp, 4

; 3356 : 			gEngfuncs.pTriAPI->Vertex3fv( p[g_boxpnt[j][0]] );

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?g_boxpnt@@3PAY03HA[edx]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _p$73820[ebp+eax]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [ecx+28]
	add	esp, 4

; 3357 : 			gEngfuncs.pTriAPI->Vertex3fv( p[g_boxpnt[j][1]] );

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?g_boxpnt@@3PAY03HA[edx+4]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _p$73820[ebp+eax]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [ecx+28]
	add	esp, 4

; 3358 : 			gEngfuncs.pTriAPI->Vertex3fv( p[g_boxpnt[j][2]] );

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?g_boxpnt@@3PAY03HA[edx+8]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _p$73820[ebp+eax]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [ecx+28]
	add	esp, 4

; 3359 : 			gEngfuncs.pTriAPI->Vertex3fv( p[g_boxpnt[j][3]] );

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?g_boxpnt@@3PAY03HA[edx+12]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _p$73820[ebp+eax]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [ecx+28]
	add	esp, 4

; 3360 : 		}

	jmp	$L73827
$L73828:

; 3361 : 		gEngfuncs.pTriAPI->End();

	mov	edx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [edx+12]

; 3362 : 	}

	jmp	$L73814
$L73815:

; 3363 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioDrawHulls@CStudioModelRenderer@@AAEXXZ ENDP	; CStudioModelRenderer::StudioDrawHulls
_TEXT	ENDS
PUBLIC	?StudioDrawAbsBBox@CStudioModelRenderer@@AAEXXZ	; CStudioModelRenderer::StudioDrawAbsBBox
EXTRN	?R_LoadIdentity@@YAXXZ:NEAR			; R_LoadIdentity
;	COMDAT ?StudioDrawAbsBBox@CStudioModelRenderer@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4
_p$ = -100
_tmp$ = -112
_lv$ = -116
_i$ = -120
?StudioDrawAbsBBox@CStudioModelRenderer@@AAEXXZ PROC NEAR ; CStudioModelRenderer::StudioDrawAbsBBox, COMDAT

; 3372 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3373 : 	Vector p[8], tmp;

	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	8
	push	12					; 0000000cH
	lea	eax, DWORD PTR _p$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 3374 : 	float lv;
; 3375 : 	int i;
; 3376 : 
; 3377 : 	// looks ugly, skip
; 3378 : 	if( m_pCurrentEntity == GET_VIEWMODEL( ))

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+208
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+19104], eax
	jne	SHORT $L73838

; 3379 : 		return;

	jmp	$L73832
$L73838:

; 3380 : 
; 3381 : 	R_LoadIdentity();

	call	?R_LoadIdentity@@YAXXZ			; R_LoadIdentity

; 3382 : 
; 3383 : 	// compute a full bounding box
; 3384 : 	for( i = 0; i < 8; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73839
$L73840:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L73839:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$L73841

; 3386 :   		p[i][0] = ( i & 1 ) ? m_pModelInstance->absmin[0] : m_pModelInstance->absmax[0];

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L76513
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+19112]
	add	ecx, 156				; 0000009cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR -124+[ebp], edx
	jmp	SHORT $L76514
$L76513:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 168				; 000000a8H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR -124+[ebp], ecx
$L76514:
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	lea	ecx, DWORD PTR _p$[ebp+edx]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -124+[ebp]
	mov	DWORD PTR [eax], ecx

; 3387 :   		p[i][1] = ( i & 2 ) ? m_pModelInstance->absmin[1] : m_pModelInstance->absmax[1];

	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 2
	test	edx, edx
	je	SHORT $L76515
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 156				; 0000009cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR -128+[ebp], ecx
	jmp	SHORT $L76516
$L76515:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	add	ecx, 168				; 000000a8H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR -128+[ebp], eax
$L76516:
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	lea	ecx, DWORD PTR _p$[ebp+ecx]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -128+[ebp]
	mov	DWORD PTR [eax+4], edx

; 3388 :   		p[i][2] = ( i & 4 ) ? m_pModelInstance->absmin[2] : m_pModelInstance->absmax[2];

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 4
	test	eax, eax
	je	SHORT $L76517
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+19112]
	add	ecx, 156				; 0000009cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR -132+[ebp], edx
	jmp	SHORT $L76518
$L76517:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 168				; 000000a8H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR -132+[ebp], ecx
$L76518:
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	lea	ecx, DWORD PTR _p$[ebp+edx]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -132+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 3389 : 	}

	jmp	$L73840
$L73841:

; 3390 : 
; 3391 : 	GL_Bind( GL_TEXTURE0, tr.whiteTexture );

	mov	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+32
	push	edx
	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+132
	add	esp, 8

; 3392 : 	gEngfuncs.pTriAPI->Color4f( 0.5f, 0.5f, 1.0f, 0.5f );

	push	1056964608				; 3f000000H
	push	1065353216				; 3f800000H
	push	1056964608				; 3f000000H
	push	1056964608				; 3f000000H
	mov	eax, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [eax+16]
	add	esp, 16					; 00000010H

; 3393 : 	gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );

	push	5
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [ecx+4]
	add	esp, 4

; 3394 : 
; 3395 : 	gEngfuncs.pTriAPI->Begin( TRI_QUADS );

	push	2
	mov	edx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [edx+8]
	add	esp, 4

; 3396 : 
; 3397 : 	for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73842
$L73843:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L73842:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$L73844

; 3399 : 		tmp = g_vecZero;

	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR _tmp$[ebp], ecx
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR _tmp$[ebp+4], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR _tmp$[ebp+8], eax

; 3400 : 		tmp[i % 3] = (i < 3) ? 1.0f : -1.0f;

	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $L76519
	mov	DWORD PTR -136+[ebp], 1065353216	; 3f800000H
	jmp	SHORT $L76520
$L76519:
	mov	DWORD PTR -136+[ebp], -1082130432	; bf800000H
$L76520:
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, eax
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	esi, 3
	idiv	esi
	mov	eax, DWORD PTR -136+[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 3401 : 		StudioLighting( &lv, -1, 0, tmp );

	lea	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	push	0
	push	-1
	lea	edx, DWORD PTR _lv$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+108]

; 3402 : 
; 3403 : 		gEngfuncs.pTriAPI->Brightness( lv );

	mov	eax, DWORD PTR _lv$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [ecx+36]
	add	esp, 4

; 3404 : 		gEngfuncs.pTriAPI->Vertex3fv( p[g_boxpnt[i][0]] );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?g_boxpnt@@3PAY03HA[edx]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _p$[ebp+eax]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [ecx+28]
	add	esp, 4

; 3405 : 		gEngfuncs.pTriAPI->Vertex3fv( p[g_boxpnt[i][1]] );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?g_boxpnt@@3PAY03HA[edx+4]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _p$[ebp+eax]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [ecx+28]
	add	esp, 4

; 3406 : 		gEngfuncs.pTriAPI->Vertex3fv( p[g_boxpnt[i][2]] );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?g_boxpnt@@3PAY03HA[edx+8]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _p$[ebp+eax]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [ecx+28]
	add	esp, 4

; 3407 : 		gEngfuncs.pTriAPI->Vertex3fv( p[g_boxpnt[i][3]] );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?g_boxpnt@@3PAY03HA[edx+12]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _p$[ebp+eax]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [ecx+28]
	add	esp, 4

; 3408 : 	}

	jmp	$L73843
$L73844:

; 3409 : 
; 3410 : 	gEngfuncs.pTriAPI->End();

	mov	edx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [edx+12]
$L73832:

; 3411 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioDrawAbsBBox@CStudioModelRenderer@@AAEXXZ ENDP	; CStudioModelRenderer::StudioDrawAbsBBox
_TEXT	ENDS
PUBLIC	?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z		; matrix3x4::GetOrigin
PUBLIC	?StudioDrawBones@CStudioModelRenderer@@AAEXXZ	; CStudioModelRenderer::StudioDrawBones
EXTRN	?pglColor3f@@3P6GXMMM@ZA:DWORD			; pglColor3f
EXTRN	?pglPointSize@@3P6GXM@ZA:DWORD			; pglPointSize
;	COMDAT ?StudioDrawBones@CStudioModelRenderer@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pbones$ = -8
_point$ = -20
_i$ = -24
$T76523 = -88
?StudioDrawBones@CStudioModelRenderer@@AAEXXZ PROC NEAR	; CStudioModelRenderer::StudioDrawBones, COMDAT

; 3420 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3421 : 	mstudiobone_t	*pbones = (mstudiobone_t *) ((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	add	eax, DWORD PTR [ecx+144]
	mov	DWORD PTR _pbones$[ebp], eax

; 3422 : 	Vector		point;

	lea	ecx, DWORD PTR _point$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 3423 : 
; 3424 : 	R_TransformForEntity( m_pModelInstance->m_protationmatrix );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 11452				; 00002cbcH
	push	edx
	lea	ecx, DWORD PTR $T76523[ebp]
	call	??0matrix4x4@@QAE@ABVmatrix3x4@@@Z	; matrix4x4::matrix4x4
	lea	eax, DWORD PTR $T76523[ebp]
	push	eax
	call	?R_TransformForEntity@@YAXABVmatrix4x4@@@Z ; R_TransformForEntity
	add	esp, 4

; 3425 : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR ?pglDisable@@3P6GXI@ZA	; pglDisable

; 3426 : 
; 3427 : 	for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73855
$L73856:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L73855:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	$L73857

; 3429 : 		if( pbones[i].parent >= 0 )

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _pbones$[ebp]
	cmp	DWORD PTR [eax+edx+32], 0
	jl	$L73858

; 3431 : 			pglPointSize( 3.0f );

	push	1077936128				; 40400000H
	call	DWORD PTR ?pglPointSize@@3P6GXM@ZA	; pglPointSize

; 3432 : 			pglColor3f( 1, 0.7f, 0 );

	push	0
	push	1060320051				; 3f333333H
	push	1065353216				; 3f800000H
	call	DWORD PTR ?pglColor3f@@3P6GXMMM@ZA	; pglColor3f

; 3433 : 			pglBegin( GL_LINES );

	push	1
	call	DWORD PTR ?pglBegin@@3P6GXI@ZA		; pglBegin

; 3434 : 			
; 3435 : 			m_pModelInstance->m_pbones[pbones[i].parent].GetOrigin( point );

	lea	ecx, DWORD PTR _point$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _pbones$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+32]
	imul	ecx, 48					; 00000030H
	lea	ecx, DWORD PTR [eax+ecx+11548]
	call	?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z	; matrix3x4::GetOrigin

; 3436 : 			pglVertex3fv( point );

	lea	ecx, DWORD PTR _point$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 3437 : 
; 3438 : 			m_pModelInstance->m_pbones[i].GetOrigin( point );

	lea	edx, DWORD PTR _point$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	lea	ecx, DWORD PTR [ecx+edx+11548]
	call	?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z	; matrix3x4::GetOrigin

; 3439 : 			pglVertex3fv( point );

	lea	ecx, DWORD PTR _point$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 3440 : 			
; 3441 : 			pglEnd();

	call	DWORD PTR ?pglEnd@@3P6GXXZA		; pglEnd

; 3442 : 
; 3443 : 			pglColor3f( 0, 0, 0.8f );

	push	1061997773				; 3f4ccccdH
	push	0
	push	0
	call	DWORD PTR ?pglColor3f@@3P6GXMMM@ZA	; pglColor3f

; 3444 : 			pglBegin( GL_POINTS );

	push	0
	call	DWORD PTR ?pglBegin@@3P6GXI@ZA		; pglBegin

; 3445 : 
; 3446 : 			if( pbones[pbones[i].parent].parent != -1 )

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _pbones$[ebp]
	mov	edx, DWORD PTR [ecx+eax+32]
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _pbones$[ebp]
	cmp	DWORD PTR [eax+edx+32], -1
	je	SHORT $L73859

; 3448 : 				m_pModelInstance->m_pbones[pbones[i].parent].GetOrigin( point );

	lea	ecx, DWORD PTR _point$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _pbones$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+32]
	imul	ecx, 48					; 00000030H
	lea	ecx, DWORD PTR [eax+ecx+11548]
	call	?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z	; matrix3x4::GetOrigin

; 3449 : 				pglVertex3fv( point );

	lea	ecx, DWORD PTR _point$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv
$L73859:

; 3451 : 
; 3452 : 			m_pModelInstance->m_pbones[i].GetOrigin( point );

	lea	edx, DWORD PTR _point$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	lea	ecx, DWORD PTR [ecx+edx+11548]
	call	?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z	; matrix3x4::GetOrigin

; 3453 : 			pglVertex3fv( point );

	lea	ecx, DWORD PTR _point$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 3454 : 			pglEnd();

	call	DWORD PTR ?pglEnd@@3P6GXXZA		; pglEnd

; 3456 : 		else

	jmp	SHORT $L73860
$L73858:

; 3458 : 			// draw parent bone node
; 3459 : 			pglPointSize( 5.0f );

	push	1084227584				; 40a00000H
	call	DWORD PTR ?pglPointSize@@3P6GXM@ZA	; pglPointSize

; 3460 : 			pglColor3f( 0.8f, 0, 0 );

	push	0
	push	0
	push	1061997773				; 3f4ccccdH
	call	DWORD PTR ?pglColor3f@@3P6GXMMM@ZA	; pglColor3f

; 3461 : 			pglBegin( GL_POINTS );

	push	0
	call	DWORD PTR ?pglBegin@@3P6GXI@ZA		; pglBegin

; 3462 : 
; 3463 : 			m_pModelInstance->m_pbones[i].GetOrigin( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	lea	ecx, DWORD PTR [edx+eax+11548]
	call	?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z	; matrix3x4::GetOrigin

; 3464 : 			pglVertex3fv( point );

	lea	ecx, DWORD PTR _point$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 3465 : 			pglEnd();

	call	DWORD PTR ?pglEnd@@3P6GXXZA		; pglEnd
$L73860:

; 3467 : 	}

	jmp	$L73856
$L73857:

; 3468 : 
; 3469 : 	pglPointSize( 1.0f );

	push	1065353216				; 3f800000H
	call	DWORD PTR ?pglPointSize@@3P6GXM@ZA	; pglPointSize

; 3470 : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR ?pglEnable@@3P6GXI@ZA		; pglEnable

; 3471 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioDrawBones@CStudioModelRenderer@@AAEXXZ ENDP	; CStudioModelRenderer::StudioDrawBones
_TEXT	ENDS
;	COMDAT ?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z
_TEXT	SEGMENT
_vOrigin$ = 8
_this$ = -4
?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z PROC NEAR	; matrix3x4::GetOrigin, COMDAT

; 531  : 	void	GetOrigin( Vector &vOrigin ) { vOrigin = mat[3]; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _vOrigin$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z ENDP		; matrix3x4::GetOrigin
_TEXT	ENDS
PUBLIC	?StudioDrawAttachments@CStudioModelRenderer@@AAEXXZ ; CStudioModelRenderer::StudioDrawAttachments
;	COMDAT ?StudioDrawAttachments@CStudioModelRenderer@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
_pattachments$73869 = -12
_v$73870 = -60
$T76528 = -72
$T76529 = -84
$T76530 = -96
$T76531 = -108
?StudioDrawAttachments@CStudioModelRenderer@@AAEXXZ PROC NEAR ; CStudioModelRenderer::StudioDrawAttachments, COMDAT

; 3474 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3475 : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR ?pglDisable@@3P6GXI@ZA	; pglDisable

; 3476 : 	pglDisable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR ?pglDisable@@3P6GXI@ZA	; pglDisable

; 3477 : 	
; 3478 : 	for( int i = 0; i < m_pStudioHeader->numattachments; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L73866
$L73867:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L73866:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+212]
	jge	$L73868

; 3480 : 		mstudioattachment_t	*pattachments;
; 3481 : 		Vector v[4];

	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _v$73870[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 3482 : 
; 3483 : 		pattachments = (mstudioattachment_t *) ((byte *)m_pStudioHeader + m_pStudioHeader->attachmentindex);		

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	add	edx, DWORD PTR [eax+216]
	mov	DWORD PTR _pattachments$73869[ebp], edx

; 3484 : 		v[0] = m_pModelInstance->m_pbones[pattachments[i].bone].VectorTransform( pattachments[i].org );

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _pattachments$73869[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	push	edx
	lea	eax, DWORD PTR $T76528[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _pattachments$73869[ebp]
	mov	eax, DWORD PTR [ecx+eax+36]
	imul	eax, 48					; 00000030H
	lea	ecx, DWORD PTR [edx+eax+11548]
	call	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorTransform
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _v$73870[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _v$73870[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _v$73870[ebp+8], eax

; 3485 : 		v[1] = m_pModelInstance->m_pbones[pattachments[i].bone].VectorTransform( pattachments[i].vectors[0] );

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _pattachments$73869[ebp]
	lea	eax, DWORD PTR [edx+ecx+52]
	push	eax
	lea	ecx, DWORD PTR $T76529[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _pattachments$73869[ebp]
	mov	ecx, DWORD PTR [edx+ecx+36]
	imul	ecx, 48					; 00000030H
	lea	ecx, DWORD PTR [eax+ecx+11548]
	call	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorTransform
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _v$73870[ebp+12], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _v$73870[ebp+16], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _v$73870[ebp+20], edx

; 3486 : 		v[2] = m_pModelInstance->m_pbones[pattachments[i].bone].VectorTransform( pattachments[i].vectors[1] );

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _pattachments$73869[ebp]
	lea	edx, DWORD PTR [ecx+eax+64]
	push	edx
	lea	eax, DWORD PTR $T76530[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _pattachments$73869[ebp]
	mov	eax, DWORD PTR [ecx+eax+36]
	imul	eax, 48					; 00000030H
	lea	ecx, DWORD PTR [edx+eax+11548]
	call	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorTransform
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _v$73870[ebp+24], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _v$73870[ebp+28], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _v$73870[ebp+32], eax

; 3487 : 		v[3] = m_pModelInstance->m_pbones[pattachments[i].bone].VectorTransform( pattachments[i].vectors[2] );

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _pattachments$73869[ebp]
	lea	eax, DWORD PTR [edx+ecx+76]
	push	eax
	lea	ecx, DWORD PTR $T76531[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _pattachments$73869[ebp]
	mov	ecx, DWORD PTR [edx+ecx+36]
	imul	ecx, 48					; 00000030H
	lea	ecx, DWORD PTR [eax+ecx+11548]
	call	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorTransform
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _v$73870[ebp+36], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _v$73870[ebp+40], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _v$73870[ebp+44], edx

; 3488 : 		
; 3489 : 		pglBegin( GL_LINES );

	push	1
	call	DWORD PTR ?pglBegin@@3P6GXI@ZA		; pglBegin

; 3490 : 		pglColor3f( 1, 0, 0 );

	push	0
	push	0
	push	1065353216				; 3f800000H
	call	DWORD PTR ?pglColor3f@@3P6GXMMM@ZA	; pglColor3f

; 3491 : 		pglVertex3fv( v[0] );

	lea	ecx, DWORD PTR _v$73870[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 3492 : 		pglColor3f( 1, 1, 1 );

	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	call	DWORD PTR ?pglColor3f@@3P6GXMMM@ZA	; pglColor3f

; 3493 : 		pglVertex3fv (v[1] );

	lea	ecx, DWORD PTR _v$73870[ebp+12]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 3494 : 		pglColor3f( 1, 0, 0 );

	push	0
	push	0
	push	1065353216				; 3f800000H
	call	DWORD PTR ?pglColor3f@@3P6GXMMM@ZA	; pglColor3f

; 3495 : 		pglVertex3fv (v[0] );

	lea	ecx, DWORD PTR _v$73870[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 3496 : 		pglColor3f( 1, 1, 1 );

	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	call	DWORD PTR ?pglColor3f@@3P6GXMMM@ZA	; pglColor3f

; 3497 : 		pglVertex3fv (v[2] );

	lea	ecx, DWORD PTR _v$73870[ebp+24]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 3498 : 		pglColor3f( 1, 0, 0 );

	push	0
	push	0
	push	1065353216				; 3f800000H
	call	DWORD PTR ?pglColor3f@@3P6GXMMM@ZA	; pglColor3f

; 3499 : 		pglVertex3fv (v[0] );

	lea	ecx, DWORD PTR _v$73870[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 3500 : 		pglColor3f( 1, 1, 1 );

	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	call	DWORD PTR ?pglColor3f@@3P6GXMMM@ZA	; pglColor3f

; 3501 : 		pglVertex3fv( v[3] );

	lea	ecx, DWORD PTR _v$73870[ebp+36]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 3502 : 		pglEnd();

	call	DWORD PTR ?pglEnd@@3P6GXXZA		; pglEnd

; 3503 : 
; 3504 : 		pglPointSize( 5.0f );

	push	1084227584				; 40a00000H
	call	DWORD PTR ?pglPointSize@@3P6GXM@ZA	; pglPointSize

; 3505 : 		pglColor3f( 0, 1, 0 );

	push	0
	push	1065353216				; 3f800000H
	push	0
	call	DWORD PTR ?pglColor3f@@3P6GXMMM@ZA	; pglColor3f

; 3506 : 		pglBegin( GL_POINTS );

	push	0
	call	DWORD PTR ?pglBegin@@3P6GXI@ZA		; pglBegin

; 3507 : 		pglVertex3fv( v[0] );

	lea	ecx, DWORD PTR _v$73870[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?pglVertex3fv@@3P6GXPBM@ZA	; pglVertex3fv

; 3508 : 		pglEnd();

	call	DWORD PTR ?pglEnd@@3P6GXXZA		; pglEnd

; 3509 : 		pglPointSize( 1.0f );

	push	1065353216				; 3f800000H
	call	DWORD PTR ?pglPointSize@@3P6GXM@ZA	; pglPointSize

; 3510 : 	}

	jmp	$L73867
$L73868:

; 3511 : 
; 3512 : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR ?pglEnable@@3P6GXI@ZA		; pglEnable

; 3513 : 	pglEnable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR ?pglEnable@@3P6GXI@ZA		; pglEnable

; 3514 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioDrawAttachments@CStudioModelRenderer@@AAEXXZ ENDP ; CStudioModelRenderer::StudioDrawAttachments
_TEXT	ENDS
EXTRN	?pglShadeModel@@3P6GXI@ZA:DWORD			; pglShadeModel
;	COMDAT ?StudioSetupRenderer@CStudioModelRenderer@@EAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?StudioSetupRenderer@CStudioModelRenderer@@EAEXH@Z PROC NEAR ; CStudioModelRenderer::StudioSetupRenderer, COMDAT

; 3523 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3524 : 	pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	1174667264				; 46040000H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR ?pglTexEnvf@@3P6GXIIM@ZA	; pglTexEnvf

; 3525 : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR ?pglDisable@@3P6GXI@ZA	; pglDisable

; 3526 : 	pglShadeModel( GL_SMOOTH );

	push	7425					; 00001d01H
	call	DWORD PTR ?pglShadeModel@@3P6GXI@ZA	; pglShadeModel

; 3527 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StudioSetupRenderer@CStudioModelRenderer@@EAEXH@Z ENDP	; CStudioModelRenderer::StudioSetupRenderer
_TEXT	ENDS
EXTRN	?GL_Blend@@YAXH@Z:NEAR				; GL_Blend
;	COMDAT ?StudioRestoreRenderer@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StudioRestoreRenderer@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::StudioRestoreRenderer, COMDAT

; 3536 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3537 : 	pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );

	push	1173358592				; 45f00800H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR ?pglTexEnvf@@3P6GXIIM@ZA	; pglTexEnvf

; 3538 : 	pglShadeModel( GL_FLAT );

	push	7424					; 00001d00H
	call	DWORD PTR ?pglShadeModel@@3P6GXI@ZA	; pglShadeModel

; 3539 : 	GL_Blend( GL_FALSE );

	push	0
	call	?GL_Blend@@YAXH@Z			; GL_Blend
	add	esp, 4

; 3540 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioRestoreRenderer@CStudioModelRenderer@@EAEXXZ ENDP ; CStudioModelRenderer::StudioRestoreRenderer
_TEXT	ENDS
PUBLIC	__real@4@4001a000000000000000
PUBLIC	__real@4@4001c000000000000000
EXTRN	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z:NEAR	; GL_BindShader
;	COMDAT __real@4@4001a000000000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@4@4001a000000000000000 DD 040a00000r	; 5
CONST	ENDS
;	COMDAT __real@4@4001c000000000000000
CONST	SEGMENT
__real@4@4001c000000000000000 DD 040c00000r	; 6
CONST	ENDS
;	COMDAT ?StudioRenderModel@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StudioRenderModel@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::StudioRenderModel, COMDAT

; 3549 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3550 : #if 0
; 3551 : 	m_pCurrentEntity->curstate.renderfx = kRenderFxGlowShell;
; 3552 : 	m_pCurrentEntity->curstate.renderamt = 255;
; 3553 : #endif
; 3554 : 	StudioSetupRenderer( m_pCurrentEntity->curstate.rendermode );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	edx, DWORD PTR [ecx+760]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+136]

; 3555 : 	
; 3556 : 	if( r_drawentities->value == 2 )

	mov	eax, DWORD PTR ?r_drawentities@@3PAUcvar_s@@A ; r_drawentities
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@40008000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L73890

; 3558 : 		StudioDrawBones ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioDrawBones@CStudioModelRenderer@@AAEXXZ ; CStudioModelRenderer::StudioDrawBones

; 3560 : 	else if( r_drawentities->value == 3 )

	jmp	$L73898
$L73890:
	mov	ecx, DWORD PTR ?r_drawentities@@3PAUcvar_s@@A ; r_drawentities
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@4000c000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L73892

; 3562 : 		StudioDrawHulls ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioDrawHulls@CStudioModelRenderer@@AAEXXZ ; CStudioModelRenderer::StudioDrawHulls

; 3564 : 	else

	jmp	$L73898
$L73892:

; 3566 : 		DrawStudioMeshes ();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+152]

; 3567 : 		GL_BindShader( NULL );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 3568 : 		StudioDrawShell ();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+160]

; 3569 : 
; 3570 : 		if( r_drawentities->value == 4 )

	mov	eax, DWORD PTR ?r_drawentities@@3PAUcvar_s@@A ; r_drawentities
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@40018000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L73894

; 3572 : 			gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );

	push	5
	mov	ecx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [ecx+4]
	add	esp, 4

; 3573 : 			StudioDrawHulls ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioDrawHulls@CStudioModelRenderer@@AAEXXZ ; CStudioModelRenderer::StudioDrawHulls

; 3574 : 			gEngfuncs.pTriAPI->RenderMode( kRenderNormal );

	push	0
	mov	edx, DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+328
	call	DWORD PTR [edx+4]
	add	esp, 4

; 3576 : 		else if( r_drawentities->value == 5 )

	jmp	SHORT $L73898
$L73894:
	mov	eax, DWORD PTR ?r_drawentities@@3PAUcvar_s@@A ; r_drawentities
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@4001a000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L73896

; 3578 : 			StudioDrawAbsBBox( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioDrawAbsBBox@CStudioModelRenderer@@AAEXXZ ; CStudioModelRenderer::StudioDrawAbsBBox

; 3580 : 		else if( r_drawentities->value == 6 )

	jmp	SHORT $L73898
$L73896:
	mov	ecx, DWORD PTR ?r_drawentities@@3PAUcvar_s@@A ; r_drawentities
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@4001c000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L73898

; 3582 : 			StudioDrawAttachments( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioDrawAttachments@CStudioModelRenderer@@AAEXXZ ; CStudioModelRenderer::StudioDrawAttachments
$L73898:

; 3585 : 
; 3586 : 	StudioRestoreRenderer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+140]

; 3587 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StudioRenderModel@CStudioModelRenderer@@EAEXXZ ENDP	; CStudioModelRenderer::StudioRenderModel
_TEXT	ENDS
PUBLIC	??_C@_0DD@BPHA@FollowEntity?3?5?$CFi?5with?5model?5?$CFs?5h@ ; `string'
EXTRN	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ:NEAR ; matrix3x4::GetQuaternion
EXTRN	?Mod_CheckBoxVisible@@YA_NABVVector@@0@Z:NEAR	; Mod_CheckBoxVisible
EXTRN	?r_stats@@3Uref_stats_t@@A:BYTE			; r_stats
EXTRN	?R_CullModel@@YA_NPAUcl_entity_s@@ABVVector@@1@Z:NEAR ; R_CullModel
;	COMDAT ??_C@_0DD@BPHA@FollowEntity?3?5?$CFi?5with?5model?5?$CFs?5h@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_C@_0DD@BPHA@FollowEntity?3?5?$CFi?5with?5model?5?$CFs?5h@ DB 'FollowEn'
	DB	'tity: %i with model %s has missed parent!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?StudioDrawModel@CStudioModelRenderer@@UAEHH@Z
_TEXT	SEGMENT
_flags$ = 8
_this$ = -4
_lighting$ = -28
_dir$ = -40
_parent$73916 = -44
_inst$73918 = -48
_i$73923 = -52
_out$73927 = -100
_i$73933 = -104
_pweaponmodel$73939 = -108
_i$73944 = -112
_out$73948 = -160
_i$73954 = -164
_ent$73963 = -168
_pbodyparts$73966 = -172
_pweaponmodel$73967 = -176
_i$73973 = -180
_i$73980 = -184
$T76545 = -236
$T76546 = -252
$T76547 = -264
$T76548 = -280
$T76549 = -292
$T76551 = -344
$T76552 = -360
$T76553 = -372
$T76554 = -388
$T76555 = -400
?StudioDrawModel@CStudioModelRenderer@@UAEHH@Z PROC NEAR ; CStudioModelRenderer::StudioDrawModel, COMDAT

; 3596 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 480				; 000001e0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3597 : 	alight_t lighting;

	lea	ecx, DWORD PTR _lighting$[ebp]
	call	??0alight_s@@QAE@XZ			; alight_s::alight_s

; 3598 : 	Vector dir;

	lea	ecx, DWORD PTR _dir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 3599 : 
; 3600 : 	if( !StudioSetEntity( IEngineStudio.GetCurrentEntity( )))

	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+24
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioSetEntity@CStudioModelRenderer@@AAE_NPAUcl_entity_s@@@Z ; CStudioModelRenderer::StudioSetEntity
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L73905

; 3601 : 		return 0;

	xor	eax, eax
	jmp	$L73902
$L73905:

; 3602 : 
; 3603 : 	if( FBitSet( flags, STUDIO_RENDER ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	$L73910

; 3605 : 		if( !StudioComputeBBox( m_pCurrentEntity ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+16]
	test	eax, eax
	jne	SHORT $L73907

; 3606 : 			return 0; // invalid sequence

	xor	eax, eax
	jmp	$L73902
$L73907:

; 3607 : 
; 3608 : 		if( !Mod_CheckBoxVisible( m_pModelInstance->absmin, m_pModelInstance->absmax ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 168				; 000000a8H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 156				; 0000009cH
	push	eax
	call	?Mod_CheckBoxVisible@@YA_NABVVector@@0@Z ; Mod_CheckBoxVisible
	add	esp, 8
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L73908

; 3609 : 			return 0;

	xor	eax, eax
	jmp	$L73902
$L73908:

; 3610 : 
; 3611 : 		// see if the bounding box lets us trivially reject, also sets
; 3612 : 		if( R_CullModel( m_pCurrentEntity, m_pModelInstance->absmin, m_pModelInstance->absmax ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 168				; 000000a8H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 156				; 0000009cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	push	eax
	call	?R_CullModel@@YA_NPAUcl_entity_s@@ABVVector@@1@Z ; R_CullModel
	add	esp, 12					; 0000000cH
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L73909

; 3613 : 			return 0;

	xor	eax, eax
	jmp	$L73902
$L73909:

; 3614 : 
; 3615 : 		m_pModelInstance->visframe = tr.realframecount; // visible

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+1411992
	mov	DWORD PTR [edx+34088], eax

; 3616 : 
; 3617 : 		r_stats.c_studio_models_drawn++; // render data cache cookie

	mov	ecx, DWORD PTR ?r_stats@@3Uref_stats_t@@A+24
	add	ecx, 1
	mov	DWORD PTR ?r_stats@@3Uref_stats_t@@A+24, ecx

; 3618 : 
; 3619 : 		if( m_pStudioHeader->numbodyparts == 0 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	cmp	DWORD PTR [eax+204], 0
	jne	SHORT $L73910

; 3620 : 			return 1;

	mov	eax, 1
	jmp	$L73902
$L73910:

; 3622 : 
; 3623 : 	if( FBitSet( flags, STUDIO_FORCE ) || ( m_pModelInstance->cached_frame != tr.realframecount ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 4
	test	ecx, ecx
	jne	SHORT $L73912
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [eax+34084]
	cmp	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1411992
	je	$L73911
$L73912:

; 3625 : 		if( m_pCurrentEntity->player || m_pCurrentEntity->curstate.renderfx == kRenderFxDeadPlayer )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L73914
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	cmp	DWORD PTR [edx+772], 17			; 00000011H
	jne	SHORT $L73913
$L73914:

; 3626 : 			m_pPlayerInfo = IEngineStudio.PlayerInfo( m_nPlayerIndex );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19120]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+28
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+19116], eax
$L73913:

; 3627 : 
; 3628 : 		StudioSetUpTransform ();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+20]

; 3629 : 
; 3630 : 		if( m_pCurrentEntity->curstate.movetype == MOVETYPE_FOLLOW && m_pCurrentEntity->curstate.aiment > 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx+776], 12			; 0000000cH
	jne	$L73915
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	cmp	DWORD PTR [eax+836], 0
	jle	$L73915

; 3632 : 			cl_entity_t *parent = gEngfuncs.GetEntityByIndex( m_pCurrentEntity->curstate.aiment );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	eax, DWORD PTR [edx+836]
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR _parent$73916[ebp], eax

; 3633 : 			if( parent != NULL && parent->modelhandle != INVALID_HANDLE )

	cmp	DWORD PTR _parent$73916[ebp], 0
	je	SHORT $L73917
	mov	ecx, DWORD PTR _parent$73916[ebp]
	cmp	DWORD PTR [ecx+2960], 65535		; 0000ffffH
	je	SHORT $L73917

; 3635 : 				ModelInstance_t *inst = &m_ModelInstances[parent->modelhandle];

	mov	edx, DWORD PTR _parent$73916[ebp]
	mov	ax, WORD PTR [edx+2960]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	DWORD PTR _inst$73918[ebp], eax

; 3636 : 				StudioMergeBones( m_pModelInstance->m_pbones, inst->m_pbones, m_pRenderModel, parent->model );

	mov	ecx, DWORD PTR _parent$73916[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	push	ecx
	mov	edx, DWORD PTR _inst$73918[ebp]
	add	edx, 11548				; 00002d1cH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 11548				; 00002d1cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+52]

; 3638 : 			else

	jmp	SHORT $L73919
$L73917:

; 3640 : 				ALERT( at_error, "FollowEntity: %i with model %s has missed parent!\n", m_pCurrentEntity->index, m_pRenderModel->name );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET FLAT:??_C@_0DD@BPHA@FollowEntity?3?5?$CFi?5with?5model?5?$CFs?5h@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 16					; 00000010H

; 3641 : 				return 0;

	xor	eax, eax
	jmp	$L73902
$L73919:

; 3644 : 		else StudioSetupBones ( );

	jmp	SHORT $L73921
$L73915:
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+24]
$L73921:

; 3645 : 
; 3646 : 		m_pPlayerInfo = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+19116], 0

; 3647 : 
; 3648 : 		// grab the static lighting from world
; 3649 : 		StudioStaticLight( m_pCurrentEntity );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+116]

; 3650 : 
; 3651 : 		// convert bones into compacted GLSL array
; 3652 : 		if( m_pRenderModel->poseToBone != NULL )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	cmp	DWORD PTR [ecx+376], 0
	je	$L73922

; 3654 : 			for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$73923[ebp], 0
	jmp	SHORT $L73924
$L73925:
	mov	edx, DWORD PTR _i$73923[ebp]
	add	edx, 1
	mov	DWORD PTR _i$73923[ebp], edx
$L73924:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _i$73923[ebp]
	cmp	edx, DWORD PTR [ecx+140]
	jge	$L73926

; 3656 : 				matrix3x4 out = m_pModelInstance->m_pbones[i].ConcatTransforms( m_pRenderModel->poseToBone->posetobone[i] );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	edx, DWORD PTR _i$73923[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR [ecx+376]
	add	eax, edx
	sub	esp, 48					; 00000030H
	mov	ecx, esp
	push	eax
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	ecx, DWORD PTR $T76545[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$73923[ebp]
	imul	ecx, 48					; 00000030H
	lea	ecx, DWORD PTR [eax+ecx+11548]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	push	eax
	lea	ecx, DWORD PTR _out$73927[ebp]
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4

; 3657 : 				m_pModelInstance->m_studioquat[i] = out.GetQuaternion();

	lea	edx, DWORD PTR $T76546[ebp]
	push	edx
	lea	ecx, DWORD PTR _out$73927[ebp]
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	ecx, DWORD PTR _i$73923[ebp]
	shl	ecx, 4
	lea	edx, DWORD PTR [edx+ecx+26916]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 3658 : 				m_pModelInstance->m_studiopos[i] = out.GetOrigin();

	lea	ecx, DWORD PTR $T76547[ebp]
	push	ecx
	lea	ecx, DWORD PTR _out$73927[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	mov	edx, DWORD PTR _i$73923[ebp]
	imul	edx, 12					; 0000000cH
	lea	ecx, DWORD PTR [ecx+edx+28964]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 3659 : 			}

	jmp	$L73925
$L73926:

; 3661 : 		else

	jmp	$L73936
$L73922:

; 3663 : 			for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$73933[ebp], 0
	jmp	SHORT $L73934
$L73935:
	mov	ecx, DWORD PTR _i$73933[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$73933[ebp], ecx
$L73934:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _i$73933[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	$L73936

; 3665 : 				m_pModelInstance->m_studioquat[i] = m_pModelInstance->m_pbones[i].GetQuaternion();

	lea	edx, DWORD PTR $T76548[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR _i$73933[ebp]
	imul	edx, 48					; 00000030H
	lea	ecx, DWORD PTR [ecx+edx+11548]
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	ecx, DWORD PTR _i$73933[ebp]
	shl	ecx, 4
	lea	edx, DWORD PTR [edx+ecx+26916]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 3666 : 				m_pModelInstance->m_studiopos[i] = m_pModelInstance->m_pbones[i].GetOrigin();

	lea	ecx, DWORD PTR $T76549[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$73933[ebp]
	imul	ecx, 48					; 00000030H
	lea	ecx, DWORD PTR [eax+ecx+11548]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	mov	edx, DWORD PTR _i$73933[ebp]
	imul	edx, 12					; 0000000cH
	lea	ecx, DWORD PTR [ecx+edx+28964]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 3667 : 			}

	jmp	$L73935
$L73936:

; 3669 : 
; 3670 : 		model_t *pweaponmodel = NULL;

	mov	DWORD PTR _pweaponmodel$73939[ebp], 0

; 3671 : 
; 3672 : 		if( m_pCurrentEntity->curstate.weaponmodel )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	cmp	DWORD PTR [edx+868], 0
	je	SHORT $L73940

; 3673 : 			pweaponmodel = IEngineStudio.GetModelByIndex( m_pCurrentEntity->curstate.weaponmodel );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	edx, DWORD PTR [ecx+868]
	push	edx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+20
	add	esp, 4
	mov	DWORD PTR _pweaponmodel$73939[ebp], eax
$L73940:

; 3674 : 
; 3675 : 		// compute weaponmodel matrices too
; 3676 : 		if( pweaponmodel )

	cmp	DWORD PTR _pweaponmodel$73939[ebp], 0
	je	$L73941

; 3678 : 			StudioMergeBones( m_pModelInstance->m_pwpnbones, m_pModelInstance->m_pbones, pweaponmodel, m_pRenderModel );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	push	ecx
	mov	edx, DWORD PTR _pweaponmodel$73939[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 11548				; 00002d1cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 17692				; 0000451cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+52]

; 3679 : 
; 3680 : 			m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( pweaponmodel );

	mov	eax, DWORD PTR _pweaponmodel$73939[ebp]
	push	eax
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19124], eax

; 3681 : 
; 3682 : 			// convert weapon bones into compacted GLSL array
; 3683 : 			if( pweaponmodel->poseToBone != NULL )

	mov	edx, DWORD PTR _pweaponmodel$73939[ebp]
	cmp	DWORD PTR [edx+376], 0
	je	$L73943

; 3685 : 				for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$73944[ebp], 0
	jmp	SHORT $L73945
$L73946:
	mov	eax, DWORD PTR _i$73944[ebp]
	add	eax, 1
	mov	DWORD PTR _i$73944[ebp], eax
$L73945:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$73944[ebp]
	cmp	eax, DWORD PTR [edx+140]
	jge	$L73947

; 3687 : 					matrix3x4 out = m_pModelInstance->m_pwpnbones[i].ConcatTransforms( pweaponmodel->poseToBone->posetobone[i] );

	mov	ecx, DWORD PTR _i$73944[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _pweaponmodel$73939[ebp]
	mov	eax, DWORD PTR [edx+376]
	add	eax, ecx
	sub	esp, 48					; 00000030H
	mov	ecx, esp
	push	eax
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	ecx, DWORD PTR $T76551[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$73944[ebp]
	imul	ecx, 48					; 00000030H
	lea	ecx, DWORD PTR [eax+ecx+17692]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	push	eax
	lea	ecx, DWORD PTR _out$73948[ebp]
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4

; 3688 : 					m_pModelInstance->m_weaponquat[i] = out.GetQuaternion();

	lea	edx, DWORD PTR $T76552[ebp]
	push	edx
	lea	ecx, DWORD PTR _out$73948[ebp]
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	ecx, DWORD PTR _i$73944[ebp]
	shl	ecx, 4
	lea	edx, DWORD PTR [edx+ecx+30500]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 3689 : 					m_pModelInstance->m_weaponpos[i] = out.GetOrigin();

	lea	ecx, DWORD PTR $T76553[ebp]
	push	ecx
	lea	ecx, DWORD PTR _out$73948[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	mov	edx, DWORD PTR _i$73944[ebp]
	imul	edx, 12					; 0000000cH
	lea	ecx, DWORD PTR [ecx+edx+32548]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 3690 : 				}

	jmp	$L73946
$L73947:

; 3692 : 			else

	jmp	$L73957
$L73943:

; 3694 : 				for( int i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$73954[ebp], 0
	jmp	SHORT $L73955
$L73956:
	mov	ecx, DWORD PTR _i$73954[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$73954[ebp], ecx
$L73955:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _i$73954[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	$L73957

; 3696 : 					m_pModelInstance->m_weaponquat[i] = m_pModelInstance->m_pwpnbones[i].GetQuaternion();

	lea	edx, DWORD PTR $T76554[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR _i$73954[ebp]
	imul	edx, 48					; 00000030H
	lea	ecx, DWORD PTR [ecx+edx+17692]
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	ecx, DWORD PTR _i$73954[ebp]
	shl	ecx, 4
	lea	edx, DWORD PTR [edx+ecx+30500]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 3697 : 					m_pModelInstance->m_weaponpos[i] = m_pModelInstance->m_pwpnbones[i].GetOrigin();

	lea	ecx, DWORD PTR $T76555[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _i$73954[ebp]
	imul	ecx, 48					; 00000030H
	lea	ecx, DWORD PTR [eax+ecx+17692]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	mov	edx, DWORD PTR _i$73954[ebp]
	imul	edx, 12					; 0000000cH
	lea	ecx, DWORD PTR [ecx+edx+32548]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 3698 : 				}

	jmp	$L73956
$L73957:

; 3700 : 
; 3701 : 			// restore right header
; 3702 : 			m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	push	edx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19124], eax
$L73941:

; 3704 : 
; 3705 : 		// now this frame cached
; 3706 : 		m_pModelInstance->cached_frame = tr.realframecount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1411992
	mov	DWORD PTR [eax+34084], ecx
$L73911:

; 3708 : 
; 3709 : 	if( FBitSet( flags, STUDIO_EVENTS ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 2
	test	edx, edx
	je	SHORT $L73962

; 3711 : 		// calc attachments only once per frame
; 3712 : 		StudioCalcAttachments( m_pModelInstance->m_pbones, FBitSet( flags, STUDIO_LOCAL_SPACE ));

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 11548				; 00002d1cH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+32]

; 3713 : 		StudioClientEvents( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+104]

; 3714 : 
; 3715 : 		// copy attachments into global entity array
; 3716 : 		// g-cont: share client attachments with viewmodel
; 3717 : 		if( m_pCurrentEntity->index > 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $L73962

; 3719 : 			cl_entity_t *ent = GET_ENTITY( m_pCurrentEntity->index );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR _ent$73963[ebp], eax

; 3720 : 			memcpy( ent->attachment, m_pCurrentEntity->attachment, sizeof( Vector ) * 4 );

	push	48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	add	eax, 2912				; 00000b60H
	push	eax
	mov	ecx, DWORD PTR _ent$73963[ebp]
	add	ecx, 2912				; 00000b60H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$L73962:

; 3723 : 
; 3724 : 	if( FBitSet( flags, STUDIO_RENDER ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 1
	test	edx, edx
	je	$L73965

; 3726 : 		mbodypart_t *pbodyparts = NULL;

	mov	DWORD PTR _pbodyparts$73966[ebp], 0

; 3727 : 		model_t *pweaponmodel = NULL;

	mov	DWORD PTR _pweaponmodel$73967[ebp], 0

; 3728 : 
; 3729 : 		if( !FBitSet( RI->params, RP_SHADOWVIEW ))

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	jne	$L73968

; 3731 : 			if( m_pCurrentEntity->player )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L73969

; 3732 : 				m_pPlayerInfo = IEngineStudio.PlayerInfo( m_nPlayerIndex );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19120]
	push	edx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+28
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19116], eax
$L73969:

; 3733 : 
; 3734 : 			// get remap colors
; 3735 : 			if( m_pPlayerInfo != NULL )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+19116], 0
	je	$L73970

; 3737 : 				m_nTopColor = bound( 0, m_pPlayerInfo->topcolor, 360 );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19116]
	cmp	DWORD PTR [ecx+368], 0
	jl	SHORT $L76558
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19116]
	cmp	DWORD PTR [eax+368], 360		; 00000168H
	jge	SHORT $L76556
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19116]
	mov	eax, DWORD PTR [edx+368]
	mov	DWORD PTR -404+[ebp], eax
	jmp	SHORT $L76557
$L76556:
	mov	DWORD PTR -404+[ebp], 360		; 00000168H
$L76557:
	mov	ecx, DWORD PTR -404+[ebp]
	mov	DWORD PTR -408+[ebp], ecx
	jmp	SHORT $L76559
$L76558:
	mov	DWORD PTR -408+[ebp], 0
$L76559:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR -408+[ebp]
	mov	DWORD PTR [edx+19136], eax

; 3738 : 				m_nBottomColor = bound( 0, m_pPlayerInfo->bottomcolor, 360 );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19116]
	cmp	DWORD PTR [edx+372], 0
	jl	SHORT $L76562
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19116]
	cmp	DWORD PTR [ecx+372], 360		; 00000168H
	jge	SHORT $L76560
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19116]
	mov	ecx, DWORD PTR [eax+372]
	mov	DWORD PTR -412+[ebp], ecx
	jmp	SHORT $L76561
$L76560:
	mov	DWORD PTR -412+[ebp], 360		; 00000168H
$L76561:
	mov	edx, DWORD PTR -412+[ebp]
	mov	DWORD PTR -416+[ebp], edx
	jmp	SHORT $L76563
$L76562:
	mov	DWORD PTR -416+[ebp], 0
$L76563:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR -416+[ebp]
	mov	DWORD PTR [eax+19140], ecx

; 3740 : 			else

	jmp	SHORT $L73971
$L73970:

; 3742 : 				m_nTopColor = m_pCurrentEntity->curstate.colormap & 0xFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	ecx, DWORD PTR [eax+740]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+19136], ecx

; 3743 : 				m_nBottomColor = (m_pCurrentEntity->curstate.colormap & 0xFF00) >> 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	edx, DWORD PTR [ecx+740]
	and	edx, 65280				; 0000ff00H
	sar	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+19140], edx
$L73971:

; 3745 : 
; 3746 : 			IEngineStudio.StudioSetRemapColors( m_nTopColor, m_nBottomColor );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19140]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19136]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+120
	add	esp, 8
$L73968:

; 3748 : 
; 3749 : 		m_nNumDrawMeshes = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+5365480], 0

; 3750 : 
; 3751 : 		// change shared model with instanced model for this entity (it has personal vertex light cache)
; 3752 : 		if( m_pModelInstance->m_VlCache != NULL )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $L73972

; 3753 : 			pbodyparts = m_pModelInstance->m_VlCache->bodyparts;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pbodyparts$73966[ebp], edx
$L73972:

; 3754 : 
; 3755 : 		for( int i = 0 ; i < m_pStudioHeader->numbodyparts; i++ )

	mov	DWORD PTR _i$73973[ebp], 0
	jmp	SHORT $L73974
$L73975:
	mov	eax, DWORD PTR _i$73973[ebp]
	add	eax, 1
	mov	DWORD PTR _i$73973[ebp], eax
$L73974:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$73973[ebp]
	cmp	eax, DWORD PTR [edx+204]
	jge	SHORT $L73976

; 3756 : 			AddBodyPartToDrawList( m_pStudioHeader, pbodyparts, i, ( RI->currentlight != NULL ), true );

	push	1
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	xor	edx, edx
	cmp	DWORD PTR [ecx+24], 0
	setne	dl
	push	edx
	mov	eax, DWORD PTR _i$73973[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbodyparts$73966[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+132]
	jmp	SHORT $L73975
$L73976:

; 3757 : 
; 3758 : 		if( m_pCurrentEntity->curstate.weaponmodel )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx+868], 0
	je	SHORT $L73977

; 3759 : 			pweaponmodel = IEngineStudio.GetModelByIndex( m_pCurrentEntity->curstate.weaponmodel );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	ecx, DWORD PTR [eax+868]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+20
	add	esp, 4
	mov	DWORD PTR _pweaponmodel$73967[ebp], eax
$L73977:

; 3760 : 
; 3761 : 		if( pweaponmodel )

	cmp	DWORD PTR _pweaponmodel$73967[ebp], 0
	je	$L73978

; 3763 : 			m_pRenderModel = RI->currentmodel = pweaponmodel;

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR _pweaponmodel$73967[ebp]
	mov	DWORD PTR [edx+20], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pweaponmodel$73967[ebp]
	mov	DWORD PTR [ecx+19108], edx

; 3764 : 			m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+19124], eax

; 3765 : 
; 3766 : 			// add weaponmodel parts (weaponmodel can't cache materials because doesn't has instance)
; 3767 : 			for( int i = 0 ; i < m_pStudioHeader->numbodyparts; i++ )

	mov	DWORD PTR _i$73980[ebp], 0
	jmp	SHORT $L73981
$L73982:
	mov	eax, DWORD PTR _i$73980[ebp]
	add	eax, 1
	mov	DWORD PTR _i$73980[ebp], eax
$L73981:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$73980[ebp]
	cmp	eax, DWORD PTR [edx+204]
	jge	SHORT $L73983

; 3768 : 				AddBodyPartToDrawList( m_pStudioHeader, NULL, i, ( RI->currentlight != NULL ), false );

	push	0
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	xor	edx, edx
	cmp	DWORD PTR [ecx+24], 0
	setne	dl
	push	edx
	mov	eax, DWORD PTR _i$73980[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+132]
	jmp	SHORT $L73982
$L73983:

; 3769 : 
; 3770 : 			m_pRenderModel = RI->currentmodel = m_pModelInstance->m_pModel;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+20], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+19108], eax

; 3771 : 			m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	push	edx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19124], eax

; 3772 : 
; 3773 : 			r_stats.c_studio_models_drawn++;

	mov	edx, DWORD PTR ?r_stats@@3Uref_stats_t@@A+24
	add	edx, 1
	mov	DWORD PTR ?r_stats@@3Uref_stats_t@@A+24, edx
$L73978:

; 3775 : 
; 3776 : 		StudioRenderModel( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
$L73965:

; 3778 : 
; 3779 : 	return 1;

	mov	eax, 1
$L73902:

; 3780 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StudioDrawModel@CStudioModelRenderer@@UAEHH@Z ENDP	; CStudioModelRenderer::StudioDrawModel
_TEXT	ENDS
PUBLIC	__real@8@4000c90fdaa22168c000
PUBLIC	__real@8@4007b400000000000000
EXTRN	_tan:NEAR
;	COMDAT __real@8@4000c90fdaa22168c000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@8@4000c90fdaa22168c000 DQ 0400921fb54442d18r ; 3.14159
CONST	ENDS
;	COMDAT __real@8@4007b400000000000000
CONST	SEGMENT
__real@8@4007b400000000000000 DQ 04076800000000000r ; 360
CONST	ENDS
;	COMDAT ?StudioFormatAttachment@CStudioModelRenderer@@EAEXAAVVector@@@Z
_TEXT	SEGMENT
_point$ = 8
_this$ = -4
_worldx$ = -8
_viewx$ = -12
_factor$ = -16
_tmp$ = -28
_vTransformed$ = -40
_vOut$ = -52
$T76566 = -64
$T76567 = -76
$T76568 = -88
$T76569 = -100
$T76570 = -112
$T76571 = -124
$T76572 = -136
?StudioFormatAttachment@CStudioModelRenderer@@EAEXAAVVector@@@Z PROC NEAR ; CStudioModelRenderer::StudioFormatAttachment, COMDAT

; 3789 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3790 : 	float worldx = tan( (float)RI->fov_x * M_PI / 360.0 );

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@8@4000c90fdaa22168c000
	fdiv	QWORD PTR __real@8@4007b400000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_tan
	add	esp, 8
	fstp	DWORD PTR _worldx$[ebp]

; 3791 : 	float viewx = tan( m_flViewmodelFov * M_PI / 360.0 );

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+96]
	fmul	QWORD PTR __real@8@4000c90fdaa22168c000
	fdiv	QWORD PTR __real@8@4007b400000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_tan
	add	esp, 8
	fstp	DWORD PTR _viewx$[ebp]

; 3792 : 
; 3793 : 	// BUGBUG: workaround
; 3794 : 	if( viewx == 0.0f ) viewx = 1.0f;

	fld	DWORD PTR _viewx$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L73992
	mov	DWORD PTR _viewx$[ebp], 1065353216	; 3f800000H
$L73992:

; 3795 : 
; 3796 : 	// aspect ratio cancels out, so only need one factor
; 3797 : 	// the difference between the screen coordinates of the 2 systems is the ratio
; 3798 : 	// of the coefficients of the projection matrices (tan (fov/2) is that coefficient)
; 3799 : 	float factor = worldx / viewx;

	fld	DWORD PTR _worldx$[ebp]
	fdiv	DWORD PTR _viewx$[ebp]
	fstp	DWORD PTR _factor$[ebp]

; 3800 : 
; 3801 : 	// get the coordinates in the viewer's space.
; 3802 : 	Vector tmp = point - RI->vieworg;

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	edx, 204				; 000000ccH
	push	edx
	lea	eax, DWORD PTR $T76566[ebp]
	push	eax
	mov	ecx, DWORD PTR _point$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 3803 : 	Vector vTransformed;

	lea	ecx, DWORD PTR _vTransformed$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 3804 : 
; 3805 : 	vTransformed.x = DotProduct( RI->vright, tmp );

	lea	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	edx, 228				; 000000e4H
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _vTransformed$[ebp]

; 3806 : 	vTransformed.y = DotProduct( RI->vup, tmp );

	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	ecx, 240				; 000000f0H
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _vTransformed$[ebp+4]

; 3807 : 	vTransformed.z = DotProduct( RI->vforward, tmp );

	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	eax, 216				; 000000d8H
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _vTransformed$[ebp+8]

; 3808 : 	vTransformed.x *= factor;

	fld	DWORD PTR _vTransformed$[ebp]
	fmul	DWORD PTR _factor$[ebp]
	fstp	DWORD PTR _vTransformed$[ebp]

; 3809 : 	vTransformed.y *= factor;

	fld	DWORD PTR _vTransformed$[ebp+4]
	fmul	DWORD PTR _factor$[ebp]
	fstp	DWORD PTR _vTransformed$[ebp+4]

; 3810 : 
; 3811 : 	// Transform back to world space.
; 3812 : 	Vector vOut = (RI->vright * vTransformed.x) + (RI->vup * vTransformed.y) + (RI->vforward * vTransformed.z);

	mov	ecx, DWORD PTR _vTransformed$[ebp+8]
	push	ecx
	lea	edx, DWORD PTR $T76570[ebp]
	push	edx
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	ecx, 216				; 000000d8H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T76571[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTransformed$[ebp+4]
	push	ecx
	lea	edx, DWORD PTR $T76568[ebp]
	push	edx
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	ecx, 240				; 000000f0H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T76569[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTransformed$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T76567[ebp]
	push	edx
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	ecx, 228				; 000000e4H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vOut$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 3813 : 	point = RI->vieworg + vOut;

	lea	eax, DWORD PTR _vOut$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76572[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	ecx, 204				; 000000ccH
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _point$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 3814 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StudioFormatAttachment@CStudioModelRenderer@@EAEXAAVVector@@@Z ENDP ; CStudioModelRenderer::StudioFormatAttachment
_TEXT	ENDS
PUBLIC	?DrawStudioModelInternal@CStudioModelRenderer@@QAEXPAUcl_entity_s@@@Z ; CStudioModelRenderer::DrawStudioModelInternal
;	COMDAT ?DrawStudioModelInternal@CStudioModelRenderer@@QAEXPAUcl_entity_s@@@Z
_TEXT	SEGMENT
_e$ = 8
_this$ = -4
_parent$74012 = -8
?DrawStudioModelInternal@CStudioModelRenderer@@QAEXPAUcl_entity_s@@@Z PROC NEAR ; CStudioModelRenderer::DrawStudioModelInternal, COMDAT

; 3822 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3823 : 	if( RI->params & RP_ENVVIEW )

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L74008

; 3824 : 		return;

	jmp	$L74007
$L74008:

; 3825 : 
; 3826 : 	if( e->player )

	mov	edx, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L74009

; 3828 : 		StudioDrawModel( STUDIO_RENDER|STUDIO_EVENTS );

	push	3
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]

; 3830 : 	else

	jmp	$L74010
$L74009:

; 3832 : 		if( e->curstate.movetype == MOVETYPE_FOLLOW && e->curstate.aiment > 0 )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+776], 12			; 0000000cH
	jne	$L74013
	mov	ecx, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [ecx+836], 0
	jle	$L74013

; 3834 : 			cl_entity_t *parent = GET_ENTITY( e->curstate.aiment );

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+836]
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR _parent$74012[ebp], eax

; 3835 : 
; 3836 : 			if( parent && parent->model && parent->model->type == mod_studio )

	cmp	DWORD PTR _parent$74012[ebp], 0
	je	$L74013
	mov	ecx, DWORD PTR _parent$74012[ebp]
	cmp	DWORD PTR [ecx+2964], 0
	je	SHORT $L74013
	mov	edx, DWORD PTR _parent$74012[ebp]
	mov	eax, DWORD PTR [edx+2964]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $L74013

; 3838 : 				RI->currententity = parent;

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR _parent$74012[ebp]
	mov	DWORD PTR [ecx+16], edx

; 3839 : 				StudioDrawModel( 0 );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]

; 3840 : 				e->curstate.origin = parent->curstate.origin;

	mov	eax, DWORD PTR _parent$74012[ebp]
	add	eax, 704				; 000002c0H
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 704				; 000002c0H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 3841 : 				e->origin = parent->origin;

	mov	ecx, DWORD PTR _parent$74012[ebp]
	add	ecx, 2888				; 00000b48H
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 2888				; 00000b48H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 3842 : 				RI->currententity = e;

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [edx+16], eax
$L74013:

; 3845 : 
; 3846 : 		StudioDrawModel( STUDIO_RENDER|STUDIO_EVENTS );

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]
$L74010:
$L74007:

; 3848 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DrawStudioModelInternal@CStudioModelRenderer@@QAEXPAUcl_entity_s@@@Z ENDP ; CStudioModelRenderer::DrawStudioModelInternal
_TEXT	ENDS
EXTRN	?glsl_programs@@3PAUglsl_prog_s@@A:BYTE		; glsl_programs
EXTRN	?glsl@@3Uref_shaders_t@@A:BYTE			; glsl
EXTRN	?GL_UberShaderForDlightStudio@@YAGPBUplight_s@@PAUmstudiomat_s@@_NH@Z:NEAR ; GL_UberShaderForDlightStudio
;	COMDAT ?ChooseStudioProgram@CStudioModelRenderer@@EAEGPAUstudiohdr_t@@PAUmstudiomat_s@@_N@Z
_TEXT	SEGMENT
_phdr$ = 8
_mat$ = 12
_lightpass$ = 16
_this$ = -4
_vertex_lighting$ = -8
_bone_weighting$ = -12
_fullbright$ = -16
?ChooseStudioProgram@CStudioModelRenderer@@EAEGPAUstudiohdr_t@@PAUmstudiomat_s@@_N@Z PROC NEAR ; CStudioModelRenderer::ChooseStudioProgram, COMDAT

; 3858 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3859 : 	bool vertex_lighting = FBitSet( m_pModelInstance->info_flags, MF_VERTEX_LIGHTING ) ? true : false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 2
	test	edx, edx
	setne	al
	mov	BYTE PTR _vertex_lighting$[ebp], al

; 3860 : 	bool bone_weighting = (m_pRenderModel->poseToBone != NULL) ? true : false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	cmp	DWORD PTR [edx+376], 0
	setne	al
	mov	BYTE PTR _bone_weighting$[ebp], al

; 3861 : 	bool fullbright = false;

	mov	BYTE PTR _fullbright$[ebp], 0

; 3862 : 
; 3863 : 	if( FBitSet( RI->params, RP_SHADOWVIEW ))

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx]
	and	edx, 256				; 00000100H
	test	edx, edx
	je	SHORT $L74023

; 3864 : 		return (glsl.studioDepthFill[bone_weighting] - glsl_programs);

	mov	eax, DWORD PTR _bone_weighting$[ebp]
	and	eax, 255				; 000000ffH
	mov	eax, DWORD PTR ?glsl@@3Uref_shaders_t@@A[eax*4+28]
	sub	eax, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	cdq
	mov	ecx, 876				; 0000036cH
	idiv	ecx
	jmp	SHORT $L74019
$L74023:

; 3867 : 	{

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	ecx, DWORD PTR [eax+760]
	mov	DWORD PTR -20+[ebp], ecx
	cmp	DWORD PTR -20+[ebp], 5
	je	SHORT $L74028
	jmp	SHORT $L74025
$L74028:

; 3868 : 	case kRenderTransAdd: 
; 3869 : 		fullbright = true;

	mov	BYTE PTR _fullbright$[ebp], 1
$L74025:

; 3872 : 
; 3873 : 	if( lightpass )

	mov	edx, DWORD PTR _lightpass$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L74029

; 3874 : 		return GL_UberShaderForDlightStudio( RI->currentlight, mat, bone_weighting, phdr->numbones );

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	mov	dl, BYTE PTR _bone_weighting$[ebp]
	push	edx
	mov	eax, DWORD PTR _mat$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?GL_UberShaderForDlightStudio@@YAGPBUplight_s@@PAUmstudiomat_s@@_NH@Z ; GL_UberShaderForDlightStudio
	add	esp, 16					; 00000010H
	jmp	SHORT $L74019
$L74029:

; 3875 : 	return GL_UberShaderForSolidStudio( mat, vertex_lighting, bone_weighting, fullbright, phdr->numbones );

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	mov	dl, BYTE PTR _fullbright$[ebp]
	push	edx
	mov	al, BYTE PTR _bone_weighting$[ebp]
	push	eax
	mov	cl, BYTE PTR _vertex_lighting$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?GL_UberShaderForSolidStudio@@YAGPAUmstudiomat_s@@_N11H@Z ; GL_UberShaderForSolidStudio
	add	esp, 20					; 00000014H
$L74019:

; 3876 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ChooseStudioProgram@CStudioModelRenderer@@EAEGPAUstudiohdr_t@@PAUmstudiomat_s@@_N@Z ENDP ; CStudioModelRenderer::ChooseStudioProgram
_TEXT	ENDS
PUBLIC	??_C@_0CK@PBGN@R_AddMeshToLightList?3?5light?5list@ ; `string'
PUBLIC	??_C@_0CN@KGMD@R_AddMeshToDrawList?3?5mesh?5draw?5l@ ; `string'
;	COMDAT ??_C@_0CK@PBGN@R_AddMeshToLightList?3?5light?5list@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_C@_0CK@PBGN@R_AddMeshToLightList?3?5light?5list@ DB 'R_AddMeshToLightL'
	DB	'ist: light list is full', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KGMD@R_AddMeshToDrawList?3?5mesh?5draw?5l@
CONST	SEGMENT
??_C@_0CN@KGMD@R_AddMeshToDrawList?3?5mesh?5draw?5l@ DB 'R_AddMeshToDrawL'
	DB	'ist: mesh draw list is full', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?AddMeshToDrawList@CStudioModelRenderer@@EAEXPAUstudiohdr_t@@PBUvbomesh_s@@_N2@Z
_TEXT	SEGMENT
_phdr$ = 8
_mesh$ = 12
_lightpass$ = 16
_cached_materials$ = 20
_this$ = -4
_m_skinnum$ = -8
_pskinref$ = -12
_mat$ = -16
_entry$ = -20
_hProgram$ = -24
?AddMeshToDrawList@CStudioModelRenderer@@EAEXPAUstudiohdr_t@@PBUvbomesh_s@@_N2@Z PROC NEAR ; CStudioModelRenderer::AddMeshToDrawList, COMDAT

; 3885 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3886 : 	int m_skinnum = bound( 0, m_pCurrentEntity->curstate.skin, phdr->numskinfamilies - 1 );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	movsx	edx, WORD PTR [ecx+744]
	test	edx, edx
	jl	SHORT $L76585
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	movsx	edx, WORD PTR [ecx+744]
	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	sub	ecx, 1
	cmp	edx, ecx
	jge	SHORT $L76583
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	movsx	ecx, WORD PTR [eax+744]
	mov	DWORD PTR -28+[ebp], ecx
	jmp	SHORT $L76584
$L76583:
	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [edx+196]
	sub	eax, 1
	mov	DWORD PTR -28+[ebp], eax
$L76584:
	mov	ecx, DWORD PTR -28+[ebp]
	mov	DWORD PTR -32+[ebp], ecx
	jmp	SHORT $L76586
$L76585:
	mov	DWORD PTR -32+[ebp], 0
$L76586:
	mov	edx, DWORD PTR -32+[ebp]
	mov	DWORD PTR _m_skinnum$[ebp], edx

; 3887 : 	short *pskinref = (short *)((byte *)phdr + phdr->skinindex);

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+200]
	mov	DWORD PTR _pskinref$[ebp], ecx

; 3888 : 	pskinref += (m_skinnum * phdr->numskinref);

	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR _m_skinnum$[ebp]
	imul	eax, DWORD PTR [edx+192]
	mov	ecx, DWORD PTR _pskinref$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _pskinref$[ebp], edx

; 3889 : 
; 3890 : 	mstudiomaterial_t *mat = NULL;

	mov	DWORD PTR _mat$[ebp], 0

; 3891 : 	if( cached_materials )

	mov	eax, DWORD PTR _cached_materials$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74042

; 3892 : 		mat = &m_pModelInstance->materials[pskinref[mesh->skinref]]; // NOTE: use local copy for right cache shadernums

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _mesh$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _pskinref$[ebp]
	movsx	ecx, WORD PTR [eax+ecx*2]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR [edx+11448]
	add	edx, ecx
	mov	DWORD PTR _mat$[ebp], edx

; 3893 : 	else mat = &m_pRenderModel->materials[pskinref[mesh->skinref]];

	jmp	SHORT $L74043
$L74042:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	edx, DWORD PTR _mesh$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _pskinref$[ebp]
	movsx	eax, WORD PTR [edx+eax*2]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR [ecx+384]
	add	ecx, eax
	mov	DWORD PTR _mat$[ebp], ecx
$L74043:

; 3894 : 
; 3895 : 	// goes into regular arrays
; 3896 : 	if( FBitSet( RI->params, RP_SHADOWVIEW ))

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $L74044

; 3897 : 		lightpass = false;

	mov	BYTE PTR _lightpass$[ebp], 0
$L74044:

; 3898 : 
; 3899 : 	if( lightpass )

	mov	ecx, DWORD PTR _lightpass$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L74045

; 3901 : 		if( FBitSet( mat->flags, STUDIO_NF_FULLBRIGHT ))

	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 4
	test	eax, eax
	je	SHORT $L74046

; 3902 : 			return; // can't light fullbrights

	jmp	$L74036
$L74046:

; 3903 : 
; 3904 : 		if( FBitSet( mat->flags, STUDIO_NF_NODLIGHT ))

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L74047

; 3905 : 			return; // shader was failed to compile

	jmp	$L74036
$L74047:

; 3906 : 
; 3907 : 		if( m_nNumLightMeshes >= MAX_MODEL_MESHES )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+5385964], 1024		; 00000400H
	jl	SHORT $L74048

; 3909 : 			ALERT( at_error, "R_AddMeshToLightList: light list is full\n" );

	push	OFFSET FLAT:??_C@_0CK@PBGN@R_AddMeshToLightList?3?5light?5list@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 8

; 3910 : 			return;

	jmp	$L74036
$L74048:

; 3913 : 	else

	jmp	SHORT $L74052
$L74045:

; 3915 : 		if( FBitSet( mat->flags, STUDIO_NF_NODRAW ))

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 65536				; 00010000H
	test	edx, edx
	je	SHORT $L74051

; 3916 : 			return; // shader was failed to compile

	jmp	$L74036
$L74051:

; 3917 : 
; 3918 : 		if( m_nNumDrawMeshes >= MAX_MODEL_MESHES )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+5365480], 1024		; 00000400H
	jl	SHORT $L74052

; 3920 : 			ALERT( at_error, "R_AddMeshToDrawList: mesh draw list is full\n" );

	push	OFFSET FLAT:??_C@_0CN@KGMD@R_AddMeshToDrawList?3?5mesh?5draw?5l@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 8

; 3921 : 			return;

	jmp	$L74036
$L74052:

; 3924 : 	gl_studiomesh_t *entry = NULL;

	mov	DWORD PTR _entry$[ebp], 0

; 3925 : 	word hProgram = 0;

	mov	WORD PTR _hProgram$[ebp], 0

; 3926 : 
; 3927 : 	if( !( hProgram = ChooseStudioProgram( phdr, mat, lightpass )))

	mov	cl, BYTE PTR _lightpass$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mat$[ebp]
	push	edx
	mov	eax, DWORD PTR _phdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+124]
	mov	WORD PTR _hProgram$[ebp], ax
	mov	eax, DWORD PTR _hProgram$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jne	SHORT $L74056

; 3928 : 		return; // failed to build shader, don't draw this surface

	jmp	$L74036
$L74056:

; 3929 : 
; 3930 : 	if( lightpass ) entry = &m_LightMeshes[m_nNumLightMeshes++];

	mov	ecx, DWORD PTR _lightpass$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L74057
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5385964]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+5365484]
	mov	DWORD PTR _entry$[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5385964]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+5385964], ecx

; 3931 : 	else entry = &m_DrawMeshes[m_nNumDrawMeshes++];

	jmp	SHORT $L74058
$L74057:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5365480]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+5345000]
	mov	DWORD PTR _entry$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5365480]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5365480], edx
$L74058:

; 3932 : 
; 3933 : 	entry->mesh = (vbomesh_t *)mesh;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _mesh$[ebp]
	mov	DWORD PTR [ecx], edx

; 3934 : 	entry->hProgram = hProgram;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	cx, WORD PTR _hProgram$[ebp]
	mov	WORD PTR [eax+4], cx

; 3935 : 	entry->parent = m_pCurrentEntity;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	DWORD PTR [edx+8], ecx

; 3936 : 	entry->model = m_pRenderModel;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	DWORD PTR [edx+12], ecx

; 3937 : 	entry->additive = FBitSet( mat->flags, STUDIO_NF_ADDITIVE ) ? true : false;

	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 32					; 00000020H
	test	eax, eax
	setne	cl
	mov	edx, DWORD PTR _entry$[ebp]
	mov	BYTE PTR [edx+16], cl
$L74036:

; 3938 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddMeshToDrawList@CStudioModelRenderer@@EAEXPAUstudiohdr_t@@PBUvbomesh_s@@_N2@Z ENDP ; CStudioModelRenderer::AddMeshToDrawList
_TEXT	ENDS
PUBLIC	??_C@_0BB@PPBK@?$CFs?5missed?5cache?6?$AA@	; `string'
;	COMDAT ??_C@_0BB@PPBK@?$CFs?5missed?5cache?6?$AA@
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
??_C@_0BB@PPBK@?$CFs?5missed?5cache?6?$AA@ DB '%s missed cache', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?AddBodyPartToDrawList@CStudioModelRenderer@@EAEXPAUstudiohdr_t@@PAUmbodypart_s@@H_N2@Z
_TEXT	SEGMENT
_phdr$ = 8
_bodyparts$ = 12
_bodypart$ = 16
_lightpass$ = 20
_cached_materials$ = 24
_this$ = -4
_pBodyPart$ = -8
_index$ = -12
_pSubModel$ = -16
_i$ = -20
?AddBodyPartToDrawList@CStudioModelRenderer@@EAEXPAUstudiohdr_t@@PAUmbodypart_s@@H_N2@Z PROC NEAR ; CStudioModelRenderer::AddBodyPartToDrawList, COMDAT

; 3947 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3948 : 	if( !bodyparts ) bodyparts = m_pRenderModel->studiocache->bodyparts;

	cmp	DWORD PTR _bodyparts$[ebp], 0
	jne	SHORT $L74068
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	edx, DWORD PTR [ecx+380]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _bodyparts$[ebp], eax
$L74068:

; 3949 : 	if( !bodyparts ) HOST_ERROR( "%s missed cache\n", m_pCurrentEntity->model->name );

	cmp	DWORD PTR _bodyparts$[ebp], 0
	jne	SHORT $L74069
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	eax, DWORD PTR [edx+2964]
	push	eax
	push	OFFSET FLAT:??_C@_0BB@PPBK@?$CFs?5missed?5cache?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 8
$L74069:

; 3950 : 
; 3951 : 	bodypart = bound( 0, bodypart, phdr->numbodyparts );

	cmp	DWORD PTR _bodypart$[ebp], 0
	jl	SHORT $L76591
	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR _bodypart$[ebp]
	cmp	edx, DWORD PTR [ecx+204]
	jge	SHORT $L76589
	mov	eax, DWORD PTR _bodypart$[ebp]
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L76590
$L76589:
	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	mov	DWORD PTR -24+[ebp], edx
$L76590:
	mov	eax, DWORD PTR -24+[ebp]
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L76592
$L76591:
	mov	DWORD PTR -28+[ebp], 0
$L76592:
	mov	ecx, DWORD PTR -28+[ebp]
	mov	DWORD PTR _bodypart$[ebp], ecx

; 3952 : 	mbodypart_t *pBodyPart = &bodyparts[bodypart];

	mov	edx, DWORD PTR _bodypart$[ebp]
	imul	edx, 136				; 00000088H
	mov	eax, DWORD PTR _bodyparts$[ebp]
	add	eax, edx
	mov	DWORD PTR _pBodyPart$[ebp], eax

; 3953 : 	int index = m_pCurrentEntity->curstate.body / pBodyPart->base;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	ecx, DWORD PTR _pBodyPart$[ebp]
	mov	eax, DWORD PTR [edx+788]
	cdq
	idiv	DWORD PTR [ecx]
	mov	DWORD PTR _index$[ebp], eax

; 3954 : 	index = index % pBodyPart->nummodels;

	mov	ecx, DWORD PTR _pBodyPart$[ebp]
	mov	eax, DWORD PTR _index$[ebp]
	cdq
	idiv	DWORD PTR [ecx+132]
	mov	DWORD PTR _index$[ebp], edx

; 3955 : 
; 3956 : 	msubmodel_t *pSubModel = pBodyPart->models[index];

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _pBodyPart$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR _pSubModel$[ebp], ecx

; 3957 : 	if( !pSubModel ) return; // blank submodel, just ignore

	cmp	DWORD PTR _pSubModel$[ebp], 0
	jne	SHORT $L74074
	jmp	SHORT $L74067
$L74074:

; 3958 : 
; 3959 : 	for( int i = 0; i < pSubModel->nummesh; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74076
$L74077:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L74076:
	mov	eax, DWORD PTR _pSubModel$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L74078

; 3960 : 		AddMeshToDrawList( phdr, &pSubModel->meshes[i], lightpass, cached_materials );

	mov	dl, BYTE PTR _cached_materials$[ebp]
	push	edx
	mov	al, BYTE PTR _lightpass$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pSubModel$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _phdr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+128]
	jmp	SHORT $L74077
$L74078:
$L74067:

; 3961 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?AddBodyPartToDrawList@CStudioModelRenderer@@EAEXPAUstudiohdr_t@@PAUmbodypart_s@@H_N2@Z ENDP ; CStudioModelRenderer::AddBodyPartToDrawList
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??AddStudioToLightList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z@4FA ; `CStudioModelRenderer::AddStudioToLightList'::`2'::__LINE__Var
EXTRN	?CullBox@CFrustum@@QAE_NABVVector@@0H@Z:NEAR	; CFrustum::CullBox
;	COMDAT ?__LINE__Var@?1??AddStudioToLightList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??AddStudioToLightList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z@4FA DW 0f89H ; `CStudioModelRenderer::AddStudioToLightList'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?AddStudioToLightList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z
_TEXT	SEGMENT
_pl$ = 8
_this$ = -4
_pbodyparts$ = -8
_pweaponmodel$ = -12
_modelpos$ = -24
_dist$ = -28
_i$ = -32
_i$74111 = -36
$T76595 = -48
$T76596 = -60
?AddStudioToLightList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z PROC NEAR ; CStudioModelRenderer::AddStudioToLightList, COMDAT

; 3977 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3978 : 	mbodypart_t *pbodyparts = NULL;

	mov	DWORD PTR _pbodyparts$[ebp], 0

; 3979 : 	model_t *pweaponmodel = NULL;

	mov	DWORD PTR _pweaponmodel$[ebp], 0

; 3980 : 
; 3981 : 	if( FBitSet( m_pCurrentEntity->curstate.effects, EF_FULLBRIGHT ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	edx, DWORD PTR [ecx+748]
	and	edx, 134217728				; 08000000H
	test	edx, edx
	je	SHORT $L74091

; 3982 : 		return;

	jmp	$L74088
$L74091:

; 3983 : 
; 3984 : 	ASSERT( m_pModelInstance != NULL );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+19112], 0
	jne	SHORT $L74093
	movsx	ecx, WORD PTR ?__LINE__Var@?1??AddStudioToLightList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z@4FA ; `CStudioModelRenderer::AddStudioToLightList'::`2'::__LINE__Var
	add	ecx, 7
	push	ecx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L74093:

; 3985 : 
; 3986 : 	if( m_pModelInstance->visframe != tr.realframecount )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [eax+34088]
	cmp	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1411992
	je	SHORT $L74094

; 3987 : 		return;

	jmp	$L74088
$L74094:

; 3988 : 
; 3989 : 	RI->currentmodel = m_pRenderModel = m_pModelInstance->m_pModel;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+19108], edx
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	DWORD PTR [eax+20], edx

; 3990 : 	m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+19124], eax

; 3991 : 
; 3992 : 	Vector modelpos = m_pModelInstance->m_protationmatrix.GetOrigin();

	lea	eax, DWORD PTR $T76595[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+19112]
	add	ecx, 11452				; 00002cbcH
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	push	eax
	lea	ecx, DWORD PTR _modelpos$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 3993 : 	float dist = (pl->origin - modelpos).Length();

	lea	edx, DWORD PTR _modelpos$[ebp]
	push	edx
	lea	eax, DWORD PTR $T76596[ebp]
	push	eax
	mov	ecx, DWORD PTR _pl$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _dist$[ebp]

; 3994 : 
; 3995 : 	if( !dist || dist > ( pl->radius + m_pModelInstance->radius ))

	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L74101
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR _pl$[ebp]
	fld	DWORD PTR [eax+24]
	fadd	DWORD PTR [edx+180]
	fcomp	DWORD PTR _dist$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L74100
$L74101:

; 3996 : 		return;

	jmp	$L74088
$L74100:

; 3997 : 
; 3998 : 	if( pl->frustum.CullBox( m_pModelInstance->absmin, m_pModelInstance->absmax ))

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	add	edx, 168				; 000000a8H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 156				; 0000009cH
	push	ecx
	mov	ecx, DWORD PTR _pl$[ebp]
	add	ecx, 264				; 00000108H
	call	?CullBox@CFrustum@@QAE_NABVVector@@0H@Z	; CFrustum::CullBox
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74102

; 3999 : 		return;

	jmp	$L74088
$L74102:

; 4000 : 
; 4001 : 	// change shared model with instanced model for this entity (it has personal vertex light cache)
; 4002 : 	if( m_pModelInstance->m_VlCache != NULL )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $L74103

; 4003 : 		pbodyparts = m_pModelInstance->m_VlCache->bodyparts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19112]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pbodyparts$[ebp], ecx
$L74103:

; 4004 : 
; 4005 : 	// all checks are passed, now all the model meshes will lighted
; 4006 : 	for( int i = 0 ; i < m_pStudioHeader->numbodyparts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74105
$L74106:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L74105:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+204]
	jge	SHORT $L74107

; 4007 : 		AddBodyPartToDrawList( m_pStudioHeader, pbodyparts, i, true, true );

	push	1
	push	1
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbodyparts$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+132]
	jmp	SHORT $L74106
$L74107:

; 4008 : 
; 4009 : 	if( m_pCurrentEntity->curstate.weaponmodel )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx+868], 0
	je	SHORT $L74108

; 4010 : 		pweaponmodel = IEngineStudio.GetModelByIndex( m_pCurrentEntity->curstate.weaponmodel );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	ecx, DWORD PTR [eax+868]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+20
	add	esp, 4
	mov	DWORD PTR _pweaponmodel$[ebp], eax
$L74108:

; 4011 : 
; 4012 : 	if( pweaponmodel )

	cmp	DWORD PTR _pweaponmodel$[ebp], 0
	je	$L74109

; 4014 : 		m_pRenderModel = RI->currentmodel = pweaponmodel;

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR _pweaponmodel$[ebp]
	mov	DWORD PTR [edx+20], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pweaponmodel$[ebp]
	mov	DWORD PTR [ecx+19108], edx

; 4015 : 		m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+19124], eax

; 4016 : 
; 4017 : 		// add weaponmodel parts (weaponmodel can't cache materials because doesn't has instance)
; 4018 : 		for( int i = 0 ; i < m_pStudioHeader->numbodyparts; i++ )

	mov	DWORD PTR _i$74111[ebp], 0
	jmp	SHORT $L74112
$L74113:
	mov	eax, DWORD PTR _i$74111[ebp]
	add	eax, 1
	mov	DWORD PTR _i$74111[ebp], eax
$L74112:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _i$74111[ebp]
	cmp	eax, DWORD PTR [edx+204]
	jge	SHORT $L74114

; 4019 : 			AddBodyPartToDrawList( m_pStudioHeader, NULL, i, true, false );

	push	0
	push	1
	mov	ecx, DWORD PTR _i$74111[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+132]
	jmp	SHORT $L74113
$L74114:

; 4020 : 
; 4021 : 		m_pRenderModel = RI->currentmodel = m_pModelInstance->m_pModel;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+20], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+19108], eax

; 4022 : 		m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	push	edx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19124], eax
$L74109:
$L74088:

; 4024 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddStudioToLightList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z ENDP ; CStudioModelRenderer::AddStudioToLightList
_TEXT	ENDS
;	COMDAT ?BuildMeshListForLight@CStudioModelRenderer@@EAEXPAUplight_s@@@Z
_TEXT	SEGMENT
_pl$ = 8
_this$ = -4
?BuildMeshListForLight@CStudioModelRenderer@@EAEXPAUplight_s@@@Z PROC NEAR ; CStudioModelRenderer::BuildMeshListForLight, COMDAT

; 4027 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4028 : 	m_nNumLightMeshes = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5385964], 0

; 4029 : 	tr.modelorg = pl->origin;

	mov	ecx, DWORD PTR _pl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR ?tr@@3Uref_globals_t@@A+1425408, edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR ?tr@@3Uref_globals_t@@A+1425412, eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR ?tr@@3Uref_globals_t@@A+1425416, ecx

; 4030 : 
; 4031 : 	AddStudioToLightList( pl );

	mov	edx, DWORD PTR _pl$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+184]

; 4032 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?BuildMeshListForLight@CStudioModelRenderer@@EAEXPAUplight_s@@@Z ENDP ; CStudioModelRenderer::BuildMeshListForLight
_TEXT	ENDS
PUBLIC	?DrawMeshFromBuffer@CStudioModelRenderer@@AAEXPBUvbomesh_s@@@Z ; CStudioModelRenderer::DrawMeshFromBuffer
PUBLIC	?QSortStudioMeshes@CStudioModelRenderer@@AAEXPAUgl_studiomesh_t@@HH@Z ; CStudioModelRenderer::QSortStudioMeshes
PUBLIC	??Amatrix4x4@@QAEPAMH@Z				; matrix4x4::operator[]
PUBLIC	?CopyToArray@matrix4x4@@QBEXPAM@Z		; matrix4x4::CopyToArray
PUBLIC	?__LINE__Var@?1??DrawLightForMeshList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z@4FA ; `CStudioModelRenderer::DrawLightForMeshList'::`2'::__LINE__Var
PUBLIC	??0matrix4x4@@QAE@ABV0@@Z			; matrix4x4::matrix4x4
PUBLIC	?GetPlane@CFrustum@@QBEPBUmplane_s@@H@Z		; CFrustum::GetPlane
EXTRN	?VectorITransform@matrix3x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix3x4::VectorITransform
EXTRN	?pglUniform3fARB@@3P6GXHMMM@ZA:DWORD		; pglUniform3fARB
EXTRN	?pglUniform4fARB@@3P6GXHMMMM@ZA:DWORD		; pglUniform4fARB
EXTRN	?pglUniform3fvARB@@3P6GXHHPBM@ZA:DWORD		; pglUniform3fvARB
EXTRN	?pglUniform4fvARB@@3P6GXHHPBM@ZA:DWORD		; pglUniform4fvARB
EXTRN	?pglUniformMatrix4fvARB@@3P6GXHHEPBM@ZA:DWORD	; pglUniformMatrix4fvARB
EXTRN	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z:NEAR	; matrix4x4::ConcatTransforms
EXTRN	?Concat@matrix4x4@@QAE?AV1@V1@@Z:NEAR		; matrix4x4::Concat
EXTRN	?r_nosort@@3PAUcvar_s@@A:DWORD			; r_nosort
EXTRN	?r_lightmap@@3PAUcvar_s@@A:DWORD		; r_lightmap
EXTRN	?pglScissor@@3P6GXHHHH@ZA:DWORD			; pglScissor
EXTRN	?glConfig@@3UglConfig_t@@A:BYTE			; glConfig
EXTRN	?GL_Cull@@YAXI@Z:NEAR				; GL_Cull
;	COMDAT ?__LINE__Var@?1??DrawLightForMeshList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DrawLightForMeshList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z@4FA DW 0fc3H ; `CStudioModelRenderer::DrawLightForMeshList'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?DrawLightForMeshList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z
_TEXT	SEGMENT
_pl$ = 8
_this$ = -4
_cached_material$ = -8
_cached_model$ = -12
_gl_lightViewProjMatrix$ = -76
_y2$ = -80
_right$ = -92
_lightorg$ = -104
_lightdir$ = -116
_lightView$ = -180
_projectionView$ = -244
_i$ = -248
_entry$74147 = -252
_m_skinnum$74149 = -256
_pMesh$74150 = -260
_pskinref$74151 = -264
_mat$74154 = -268
_shadowWidth$74159 = -272
_shadowHeight$74161 = -276
_num_bones$74164 = -280
$T76603 = -292
$T76604 = -304
$T76605 = -316
$T76606 = -328
$T76608 = -396
$T76610 = -464
?DrawLightForMeshList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z PROC NEAR ; CStudioModelRenderer::DrawLightForMeshList, COMDAT

; 4035 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 572				; 0000023cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4036 : 	mstudiomaterial_t	*cached_material = NULL;

	mov	DWORD PTR _cached_material$[ebp], 0

; 4037 : 	model_t		*cached_model = NULL;

	mov	DWORD PTR _cached_model$[ebp], 0

; 4038 : 	GLfloat		gl_lightViewProjMatrix[16];
; 4039 : 
; 4040 : 	float y2 = (float)RI->viewport[3] - pl->h - pl->y;

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	fild	DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _pl$[ebp]
	fsub	DWORD PTR [ecx+420]
	mov	edx, DWORD PTR _pl$[ebp]
	fsub	DWORD PTR [edx+412]
	fstp	DWORD PTR _y2$[ebp]

; 4041 : 	pglScissor( pl->x, y2, pl->w, pl->h );

	mov	eax, DWORD PTR _pl$[ebp]
	fld	DWORD PTR [eax+420]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _pl$[ebp]
	fld	DWORD PTR [ecx+416]
	call	__ftol
	push	eax
	fld	DWORD PTR _y2$[ebp]
	call	__ftol
	push	eax
	mov	edx, DWORD PTR _pl$[ebp]
	fld	DWORD PTR [edx+408]
	call	__ftol
	push	eax
	call	DWORD PTR ?pglScissor@@3P6GXHHHH@ZA	; pglScissor

; 4042 : 
; 4043 : 	// sorting list to reduce shader switches
; 4044 : 	if( !CVAR_TO_BOOL( r_nosort )) QSortStudioMeshes( m_LightMeshes, 0, m_nNumLightMeshes - 1 );

	cmp	DWORD PTR ?r_nosort@@3PAUcvar_s@@A, 0	; r_nosort
	je	SHORT $L76601
	mov	eax, DWORD PTR ?r_nosort@@3PAUcvar_s@@A	; r_nosort
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76601
	mov	BYTE PTR -468+[ebp], 1
	jmp	SHORT $L76602
$L76601:
	mov	BYTE PTR -468+[ebp], 0
$L76602:
	mov	ecx, DWORD PTR -468+[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L74129
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5385964]
	sub	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5365484				; 0051deecH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?QSortStudioMeshes@CStudioModelRenderer@@AAEXPAUgl_studiomesh_t@@HH@Z ; CStudioModelRenderer::QSortStudioMeshes
$L74129:

; 4045 : 
; 4046 : 	tr.modelorg = m_pModelInstance->m_protationmatrix.VectorITransform( RI->vieworg );

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	edx, 204				; 000000ccH
	push	edx
	lea	eax, DWORD PTR $T76603[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+19112]
	add	ecx, 11452				; 00002cbcH
	call	?VectorITransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorITransform
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR ?tr@@3Uref_globals_t@@A+1425408, edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR ?tr@@3Uref_globals_t@@A+1425412, ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR ?tr@@3Uref_globals_t@@A+1425416, edx

; 4047 : 	Vector right = m_pModelInstance->m_plightmatrix.VectorIRotate( RI->vright );

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	eax, 228				; 000000e4H
	push	eax
	lea	ecx, DWORD PTR $T76604[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	add	ecx, 11500				; 00002cecH
	call	?VectorIRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorIRotate
	push	eax
	lea	ecx, DWORD PTR _right$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 4048 : 	Vector lightorg = m_pModelInstance->m_protationmatrix.VectorITransform( pl->origin );

	mov	eax, DWORD PTR _pl$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76605[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	add	ecx, 11452				; 00002cbcH
	call	?VectorITransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorITransform
	push	eax
	lea	ecx, DWORD PTR _lightorg$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 4049 : 	Vector lightdir = m_pModelInstance->m_plightmatrix.VectorIRotate( pl->frustum.GetPlane( FRUSTUM_FAR )->normal );

	push	4
	mov	ecx, DWORD PTR _pl$[ebp]
	add	ecx, 264				; 00000108H
	call	?GetPlane@CFrustum@@QBEPBUmplane_s@@H@Z	; CFrustum::GetPlane
	push	eax
	lea	eax, DWORD PTR $T76606[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+19112]
	add	ecx, 11500				; 00002cecH
	call	?VectorIRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorIRotate
	push	eax
	lea	ecx, DWORD PTR _lightdir$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 4050 : 
; 4051 : 	matrix4x4 lightView = pl->modelviewMatrix.ConcatTransforms( m_pModelInstance->m_protationmatrix );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 11452				; 00002cbcH
	sub	esp, 64					; 00000040H
	mov	ecx, esp
	push	eax
	call	??0matrix4x4@@QAE@ABVmatrix3x4@@@Z	; matrix4x4::matrix4x4
	lea	ecx, DWORD PTR $T76608[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pl$[ebp]
	add	ecx, 112				; 00000070H
	call	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z ; matrix4x4::ConcatTransforms
	push	eax
	lea	ecx, DWORD PTR _lightView$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 4052 : 	matrix4x4 projectionView = pl->projectionMatrix.Concat( lightView );

	sub	esp, 64					; 00000040H
	mov	ecx, esp
	lea	edx, DWORD PTR _lightView$[ebp]
	push	edx
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	lea	eax, DWORD PTR $T76610[ebp]
	push	eax
	mov	ecx, DWORD PTR _pl$[ebp]
	add	ecx, 48					; 00000030H
	call	?Concat@matrix4x4@@QAE?AV1@V1@@Z	; matrix4x4::Concat
	push	eax
	lea	ecx, DWORD PTR _projectionView$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 4053 : 	projectionView.CopyToArray( gl_lightViewProjMatrix );

	lea	ecx, DWORD PTR _gl_lightViewProjMatrix$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _projectionView$[ebp]
	call	?CopyToArray@matrix4x4@@QBEXPAM@Z	; matrix4x4::CopyToArray

; 4054 : 
; 4055 : 	// sorting list to reduce shader switches
; 4056 : 	for( int i = 0; i < m_nNumLightMeshes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74144
$L74145:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L74144:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+5385964]
	jge	$L74146

; 4058 : 		gl_studiomesh_t *entry = &m_LightMeshes[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+5365484]
	mov	DWORD PTR _entry$74147[ebp], ecx

; 4059 : 		RI->currentmodel = m_pRenderModel = entry->model;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _entry$74147[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+19108], ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	DWORD PTR [edx+20], ecx

; 4060 : 		m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	push	eax
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19124], eax

; 4061 : 		int m_skinnum = bound( 0, m_pCurrentEntity->curstate.skin, m_pStudioHeader->numskinfamilies - 1 );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	movsx	ecx, WORD PTR [eax+744]
	test	ecx, ecx
	jl	SHORT $L76613
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	movsx	ecx, WORD PTR [eax+744]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	edx, DWORD PTR [eax+196]
	sub	edx, 1
	cmp	ecx, edx
	jge	SHORT $L76611
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	movsx	edx, WORD PTR [ecx+744]
	mov	DWORD PTR -472+[ebp], edx
	jmp	SHORT $L76612
$L76611:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR [ecx+196]
	sub	edx, 1
	mov	DWORD PTR -472+[ebp], edx
$L76612:
	mov	eax, DWORD PTR -472+[ebp]
	mov	DWORD PTR -476+[ebp], eax
	jmp	SHORT $L76614
$L76613:
	mov	DWORD PTR -476+[ebp], 0
$L76614:
	mov	ecx, DWORD PTR -476+[ebp]
	mov	DWORD PTR _m_skinnum$74149[ebp], ecx

; 4062 : 		vbomesh_t *pMesh = entry->mesh;

	mov	edx, DWORD PTR _entry$74147[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pMesh$74150[ebp], eax

; 4063 : 
; 4064 : 		short *pskinref = (short *)((byte *)m_pStudioHeader + m_pStudioHeader->skinindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+200]
	mov	DWORD PTR _pskinref$74151[ebp], ecx

; 4065 : 		pskinref += (m_skinnum * m_pStudioHeader->numskinref);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _m_skinnum$74149[ebp]
	imul	ecx, DWORD PTR [eax+192]
	mov	edx, DWORD PTR _pskinref$74151[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pskinref$74151[ebp], eax

; 4066 : 
; 4067 : 		mstudiomaterial_t *mat = &m_pRenderModel->materials[pskinref[pMesh->skinref]];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	eax, DWORD PTR _pMesh$74150[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _pskinref$74151[ebp]
	movsx	ecx, WORD PTR [eax+ecx*2]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR [edx+384]
	add	edx, ecx
	mov	DWORD PTR _mat$74154[ebp], edx

; 4068 : 
; 4069 : 		// begin draw the sorted list
; 4070 : 		if(( i == 0 ) || ( RI->currentshader != &glsl_programs[entry->hProgram] ))

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $L74156
	mov	eax, DWORD PTR _entry$74147[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+4]
	imul	ecx, 876				; 0000036cH
	add	ecx, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [edx+28], ecx
	je	$L74155
$L74156:

; 4072 : 			GL_BindShader( &glsl_programs[entry->hProgram] );			

	mov	eax, DWORD PTR _entry$74147[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+4]
	imul	ecx, 876				; 0000036cH
	add	ecx, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	push	ecx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 4073 : 
; 4074 : 			ASSERT( RI->currentshader != NULL );

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $L74158
	movsx	eax, WORD PTR ?__LINE__Var@?1??DrawLightForMeshList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z@4FA ; `CStudioModelRenderer::DrawLightForMeshList'::`2'::__LINE__Var
	add	eax, 39					; 00000027H
	push	eax
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L74158:

; 4075 : 
; 4076 : 			// write constants
; 4077 : 			pglUniformMatrix4fvARB( RI->currentshader->u_LightViewProjectionMatrix, 1, GL_FALSE, &gl_lightViewProjMatrix[0] );

	lea	ecx, DWORD PTR _gl_lightViewProjMatrix$[ebp]
	push	ecx
	push	0
	push	1
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+676]
	push	ecx
	call	DWORD PTR ?pglUniformMatrix4fvARB@@3P6GXHHEPBM@ZA ; pglUniformMatrix4fvARB

; 4078 : 			float shadowWidth = 1.0f / (float)RENDER_GET_PARM( PARM_TEX_WIDTH, pl->shadowTexture );

	mov	edx, DWORD PTR _pl$[ebp]
	mov	eax, DWORD PTR [edx+404]
	push	eax
	push	1
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A
	add	esp, 8
	mov	DWORD PTR -480+[ebp], eax
	fild	DWORD PTR -480+[ebp]
	fdivr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _shadowWidth$74159[ebp]

; 4079 : 			float shadowHeight = 1.0f / (float)RENDER_GET_PARM( PARM_TEX_HEIGHT, pl->shadowTexture );

	mov	ecx, DWORD PTR _pl$[ebp]
	mov	edx, DWORD PTR [ecx+404]
	push	edx
	push	2
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A
	add	esp, 8
	mov	DWORD PTR -484+[ebp], eax
	fild	DWORD PTR -484+[ebp]
	fdivr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _shadowHeight$74161[ebp]

; 4080 : 
; 4081 : 			// depth scale and bias and shadowmap resolution
; 4082 : 			pglUniform4fARB( RI->currentshader->u_LightDir, lightdir.x, lightdir.y, lightdir.z, pl->fov );

	mov	eax, DWORD PTR _pl$[ebp]
	mov	ecx, DWORD PTR [eax+432]
	push	ecx
	mov	edx, DWORD PTR _lightdir$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _lightdir$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _lightdir$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+724]
	push	ecx
	call	DWORD PTR ?pglUniform4fARB@@3P6GXHMMMM@ZA ; pglUniform4fARB

; 4083 : 			pglUniform4fARB( RI->currentshader->u_LightDiffuse, pl->color.r / 255.0f, pl->color.g / 255.0f, pl->color.b / 255.0f, pl->lightFalloff );

	mov	edx, DWORD PTR _pl$[ebp]
	mov	eax, DWORD PTR [edx+424]
	push	eax
	mov	ecx, DWORD PTR _pl$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+30]
	mov	DWORD PTR -488+[ebp], edx
	fild	DWORD PTR -488+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _pl$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+29]
	mov	DWORD PTR -492+[ebp], ecx
	fild	DWORD PTR -492+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _pl$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+28]
	mov	DWORD PTR -496+[ebp], eax
	fild	DWORD PTR -496+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+740]
	push	eax
	call	DWORD PTR ?pglUniform4fARB@@3P6GXHMMMM@ZA ; pglUniform4fARB

; 4084 : 			pglUniform4fARB( RI->currentshader->u_ShadowParams, shadowWidth, shadowHeight, -pl->projectionMatrix[2][2], pl->projectionMatrix[3][2] );

	push	3
	mov	ecx, DWORD PTR _pl$[ebp]
	add	ecx, 48					; 00000030H
	call	??Amatrix4x4@@QAEPAMH@Z			; matrix4x4::operator[]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	2
	mov	ecx, DWORD PTR _pl$[ebp]
	add	ecx, 48					; 00000030H
	call	??Amatrix4x4@@QAEPAMH@Z			; matrix4x4::operator[]
	fld	DWORD PTR [eax+8]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _shadowHeight$74161[ebp]
	push	edx
	mov	eax, DWORD PTR _shadowWidth$74159[ebp]
	push	eax
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+816]
	push	eax
	call	DWORD PTR ?pglUniform4fARB@@3P6GXHMMMM@ZA ; pglUniform4fARB

; 4085 : 			pglUniform4fARB( RI->currentshader->u_LightOrigin, lightorg.x, lightorg.y, lightorg.z, ( 1.0f / pl->radius ));

	mov	ecx, DWORD PTR _pl$[ebp]
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR [ecx+24]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _lightorg$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _lightorg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _lightorg$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+772]
	push	ecx
	call	DWORD PTR ?pglUniform4fARB@@3P6GXHMMMM@ZA ; pglUniform4fARB

; 4086 : 			pglUniform3fARB( RI->currentshader->u_ViewOrigin, tr.modelorg.x, tr.modelorg.y, tr.modelorg.z );

	mov	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1425416
	push	edx
	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+1425412
	push	eax
	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1425408
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+780]
	push	ecx
	call	DWORD PTR ?pglUniform3fARB@@3P6GXHMMM@ZA ; pglUniform3fARB

; 4087 : 			pglUniform3fARB( RI->currentshader->u_ViewRight, right.x, right.y, right.z );

	mov	edx, DWORD PTR _right$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _right$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _right$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+784]
	push	ecx
	call	DWORD PTR ?pglUniform3fARB@@3P6GXHMMM@ZA ; pglUniform3fARB

; 4088 : 			pglUniform4fARB( RI->currentshader->u_FogParams, tr.fogColor[0], tr.fogColor[1], tr.fogColor[2], tr.fogDensity );

	mov	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1411972
	push	edx
	mov	ecx, OFFSET FLAT:?tr@@3Uref_globals_t@@A+1411960
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, OFFSET FLAT:?tr@@3Uref_globals_t@@A+1411960
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, OFFSET FLAT:?tr@@3Uref_globals_t@@A+1411960
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+768]
	push	edx
	call	DWORD PTR ?pglUniform4fARB@@3P6GXHMMMM@ZA ; pglUniform4fARB

; 4089 : 
; 4090 : 			GL_Bind( GL_TEXTURE1, pl->projectionTexture );

	mov	eax, DWORD PTR _pl$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	push	ecx
	push	1
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+132
	add	esp, 8

; 4091 : 			GL_Bind( GL_TEXTURE2, pl->shadowTexture );

	mov	edx, DWORD PTR _pl$[ebp]
	mov	eax, DWORD PTR [edx+404]
	push	eax
	push	2
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+132
	add	esp, 8

; 4092 : 
; 4093 : 			// reset cache
; 4094 : 			cached_material = NULL;

	mov	DWORD PTR _cached_material$[ebp], 0

; 4095 : 			cached_model = NULL;

	mov	DWORD PTR _cached_model$[ebp], 0
$L74155:

; 4097 : 
; 4098 : 		if( cached_model != m_pRenderModel )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _cached_model$[ebp]
	cmp	edx, DWORD PTR [ecx+19108]
	je	$L74163

; 4100 : 			int num_bones = Q_min( m_pStudioHeader->numbones, glConfig.max_skinning_bones );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR [ecx+140]
	cmp	edx, DWORD PTR ?glConfig@@3UglConfig_t@@A+72
	jge	SHORT $L76615
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR -500+[ebp], edx
	jmp	SHORT $L76616
$L76615:
	mov	eax, DWORD PTR ?glConfig@@3UglConfig_t@@A+72
	mov	DWORD PTR -500+[ebp], eax
$L76616:
	mov	ecx, DWORD PTR -500+[ebp]
	mov	DWORD PTR _num_bones$74164[ebp], ecx

; 4101 : 
; 4102 : 			// update bones array
; 4103 : 			if( m_pRenderModel == IEngineStudio.GetModelByIndex( m_pCurrentEntity->curstate.weaponmodel ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	ecx, DWORD PTR [eax+868]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+20
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+19108], eax
	jne	SHORT $L74165

; 4105 : 				pglUniform4fvARB( RI->currentshader->u_BoneQuaternion, num_bones, &m_pModelInstance->m_weaponquat[0][0] );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 30500				; 00007724H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	push	eax
	mov	ecx, DWORD PTR _num_bones$74164[ebp]
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+652]
	push	ecx
	call	DWORD PTR ?pglUniform4fvARB@@3P6GXHHPBM@ZA ; pglUniform4fvARB

; 4106 : 				pglUniform3fvARB( RI->currentshader->u_BonePosition, num_bones, &m_pModelInstance->m_weaponpos[0][0] );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	add	ecx, 32548				; 00007f24H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	eax, DWORD PTR _num_bones$74164[ebp]
	push	eax
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+656]
	push	eax
	call	DWORD PTR ?pglUniform3fvARB@@3P6GXHHPBM@ZA ; pglUniform3fvARB

; 4108 : 			else

	jmp	SHORT $L74166
$L74165:

; 4110 : 				pglUniform4fvARB( RI->currentshader->u_BoneQuaternion, num_bones, &m_pModelInstance->m_studioquat[0][0] );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+19112]
	add	ecx, 26916				; 00006924H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	push	eax
	mov	edx, DWORD PTR _num_bones$74164[ebp]
	push	edx
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+652]
	push	edx
	call	DWORD PTR ?pglUniform4fvARB@@3P6GXHHPBM@ZA ; pglUniform4fvARB

; 4111 : 				pglUniform3fvARB( RI->currentshader->u_BonePosition, num_bones, &m_pModelInstance->m_studiopos[0][0] );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 28964				; 00007124H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _num_bones$74164[ebp]
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+656]
	push	ecx
	call	DWORD PTR ?pglUniform3fvARB@@3P6GXHHPBM@ZA ; pglUniform3fvARB
$L74166:

; 4113 : 
; 4114 : 			cached_model = m_pRenderModel;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	mov	DWORD PTR _cached_model$[ebp], eax
$L74163:

; 4116 : 
; 4117 : 		if( cached_material != mat )

	mov	ecx, DWORD PTR _cached_material$[ebp]
	cmp	ecx, DWORD PTR _mat$74154[ebp]
	je	$L74167

; 4119 : 			if( CVAR_TO_BOOL( r_lightmap ) && !CVAR_TO_BOOL( r_fullbright ))

	cmp	DWORD PTR ?r_lightmap@@3PAUcvar_s@@A, 0	; r_lightmap
	je	SHORT $L76617
	mov	edx, DWORD PTR ?r_lightmap@@3PAUcvar_s@@A ; r_lightmap
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76617
	mov	BYTE PTR -504+[ebp], 1
	jmp	SHORT $L76618
$L76617:
	mov	BYTE PTR -504+[ebp], 0
$L76618:
	mov	eax, DWORD PTR -504+[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74168
	cmp	DWORD PTR ?r_fullbright@@3PAUcvar_s@@A, 0 ; r_fullbright
	je	SHORT $L76619
	mov	ecx, DWORD PTR ?r_fullbright@@3PAUcvar_s@@A ; r_fullbright
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76619
	mov	BYTE PTR -508+[ebp], 1
	jmp	SHORT $L76620
$L76619:
	mov	BYTE PTR -508+[ebp], 0
$L76620:
	mov	edx, DWORD PTR -508+[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L74168

; 4120 : 				GL_Bind( GL_TEXTURE0, tr.whiteTexture );

	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+32
	push	eax
	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+132
	add	esp, 8

; 4121 : 			else GL_Bind( GL_TEXTURE0, mat->gl_diffuse_id );

	jmp	SHORT $L74169
$L74168:
	mov	ecx, DWORD PTR _mat$74154[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+4]
	push	edx
	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+132
	add	esp, 8
$L74169:

; 4122 : 
; 4123 : 			if( mat->flags & STUDIO_NF_TWOSIDE )

	mov	eax, DWORD PTR _mat$74154[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	test	ecx, ecx
	je	SHORT $L74170

; 4124 : 				GL_Cull( GL_NONE );

	push	0
	call	?GL_Cull@@YAXI@Z			; GL_Cull
	add	esp, 4

; 4125 : 			else GL_Cull( GL_FRONT );

	jmp	SHORT $L74171
$L74170:
	push	1028					; 00000404H
	call	?GL_Cull@@YAXI@Z			; GL_Cull
	add	esp, 4
$L74171:

; 4126 : 
; 4127 : 			cached_material = mat;

	mov	edx, DWORD PTR _mat$74154[ebp]
	mov	DWORD PTR _cached_material$[ebp], edx
$L74167:

; 4129 : 
; 4130 : 		DrawMeshFromBuffer( pMesh );

	mov	eax, DWORD PTR _pMesh$74150[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawMeshFromBuffer@CStudioModelRenderer@@AAEXPBUvbomesh_s@@@Z ; CStudioModelRenderer::DrawMeshFromBuffer

; 4131 : 	}

	jmp	$L74145
$L74146:

; 4132 : 
; 4133 : 	GL_Cull( GL_FRONT );

	push	1028					; 00000404H
	call	?GL_Cull@@YAXI@Z			; GL_Cull
	add	esp, 4

; 4134 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DrawLightForMeshList@CStudioModelRenderer@@EAEXPAUplight_s@@@Z ENDP ; CStudioModelRenderer::DrawLightForMeshList
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QAEPAMH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??Amatrix4x4@@QAEPAMH@Z PROC NEAR			; matrix4x4::operator[], COMDAT

; 952  : 	float* operator[]( int i ) { return mat[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, eax
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??Amatrix4x4@@QAEPAMH@Z ENDP				; matrix4x4::operator[]
_TEXT	ENDS
PUBLIC	??BVector4D@@QBEPBMXZ				; Vector4D::operator float const *
;	COMDAT ?CopyToArray@matrix4x4@@QBEXPAM@Z
_TEXT	SEGMENT
_rgfl$ = 8
_this$ = -4
?CopyToArray@matrix4x4@@QBEXPAM@Z PROC NEAR		; matrix4x4::CopyToArray, COMDAT

; 1055 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1056 : 		rgfl[ 0] = mat[0][0];

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 1057 : 		rgfl[ 1] = mat[0][1];

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 1058 : 		rgfl[ 2] = mat[0][2];

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx

; 1059 : 		rgfl[ 3] = mat[0][3];

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx

; 1060 : 		rgfl[ 4] = mat[1][0];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+16], edx

; 1061 : 		rgfl[ 5] = mat[1][1];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+20], edx

; 1062 : 		rgfl[ 6] = mat[1][2];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+24], edx

; 1063 : 		rgfl[ 7] = mat[1][3];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+28], edx

; 1064 : 		rgfl[ 8] = mat[2][0];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+32], edx

; 1065 : 		rgfl[ 9] = mat[2][1];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+36], edx

; 1066 : 		rgfl[10] = mat[2][2];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+40], edx

; 1067 : 		rgfl[11] = mat[2][3];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+44], edx

; 1068 : 		rgfl[12] = mat[3][0];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+48], edx

; 1069 : 		rgfl[13] = mat[3][1];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+52], edx

; 1070 : 		rgfl[14] = mat[3][2];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+56], edx

; 1071 : 		rgfl[15] = mat[3][3];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+60], edx

; 1072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CopyToArray@matrix4x4@@QBEXPAM@Z ENDP			; matrix4x4::CopyToArray
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector4D@@QBEPBMXZ PROC NEAR				; Vector4D::operator float const *, COMDAT

; 326  : 	operator const float *() const			{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector4D@@QBEPBMXZ ENDP				; Vector4D::operator float const *
_TEXT	ENDS
PUBLIC	??0Vector4D@@QAE@ABV0@@Z			; Vector4D::Vector4D
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
_$S7$ = -8
_$S8$ = -12
_$S9$ = -16
??0matrix4x4@@QAE@ABV0@@Z PROC NEAR			; matrix4x4::matrix4x4, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S7$[ebp], 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _$S8$[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR _$S9$[ebp], ecx
$L55903:
	mov	edx, DWORD PTR _$S9$[ebp]
	push	edx
	mov	ecx, DWORD PTR _$S8$[ebp]
	call	??0Vector4D@@QAE@ABV0@@Z		; Vector4D::Vector4D
	mov	eax, DWORD PTR _$S8$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _$S8$[ebp], eax
	mov	ecx, DWORD PTR _$S9$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _$S9$[ebp], ecx
	mov	edx, DWORD PTR _$S7$[ebp]
	sub	edx, 1
	mov	DWORD PTR _$S7$[ebp], edx
	cmp	DWORD PTR _$S7$[ebp], 0
	ja	SHORT $L55903
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix4x4@@QAE@ABV0@@Z ENDP				; matrix4x4::matrix4x4
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector4D@@QAE@ABV0@@Z PROC NEAR			; Vector4D::Vector4D, COMDAT

; 313  : 	inline Vector4D( const Vector4D& v ) { x = v.x; y = v.y; z = v.z, w = v.w; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector4D@@QAE@ABV0@@Z ENDP				; Vector4D::Vector4D
_TEXT	ENDS
;	COMDAT ?GetPlane@CFrustum@@QBEPBUmplane_s@@H@Z
_TEXT	SEGMENT
_side$ = 8
_this$ = -4
?GetPlane@CFrustum@@QBEPBUmplane_s@@H@Z PROC NEAR	; CFrustum::GetPlane, COMDAT

; 39   : 	const mplane_t *GetPlane( int side ) const { return &planes[side]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _side$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPlane@CFrustum@@QBEPBUmplane_s@@H@Z ENDP		; CFrustum::GetPlane
_TEXT	ENDS
;	COMDAT ?QSortStudioMeshes@CStudioModelRenderer@@AAEXPAUgl_studiomesh_t@@HH@Z
_TEXT	SEGMENT
_meshes$ = 8
_Li$ = 12
_Ri$ = 16
_this$ = -4
_lstack$ = -4100
_rstack$ = -8196
_li$ = -8200
_ri$ = -8204
_stackdepth$ = -8208
_total$ = -8212
_median$ = -8232
_tempbuf$ = -8252
?QSortStudioMeshes@CStudioModelRenderer@@AAEXPAUgl_studiomesh_t@@HH@Z PROC NEAR ; CStudioModelRenderer::QSortStudioMeshes, COMDAT

; 1376 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8316				; 0000207cH
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1377 : 	int lstack[QSORT_MAX_STACKDEPTH], rstack[QSORT_MAX_STACKDEPTH];
; 1378 : 	int li, ri, stackdepth = 0, total = Ri + 1;

	mov	DWORD PTR _stackdepth$[ebp], 0
	mov	eax, DWORD PTR _Ri$[ebp]
	add	eax, 1
	mov	DWORD PTR _total$[ebp], eax
$mark0$72736:

; 1379 : 	gl_studiomesh_t median, tempbuf;
; 1380 : mark0:
; 1381 : 	if( Ri - Li > 8 )

	mov	ecx, DWORD PTR _Ri$[ebp]
	sub	ecx, DWORD PTR _Li$[ebp]
	cmp	ecx, 8
	jle	$L72753

; 1383 : 		li = Li;

	mov	edx, DWORD PTR _Li$[ebp]
	mov	DWORD PTR _li$[ebp], edx

; 1384 : 		ri = Ri;

	mov	eax, DWORD PTR _Ri$[ebp]
	mov	DWORD PTR _ri$[ebp], eax

; 1385 : 
; 1386 : 		R_MeshCopy( meshes[( Li+Ri ) >> 1], median );

	mov	ecx, DWORD PTR _Li$[ebp]
	add	ecx, DWORD PTR _Ri$[ebp]
	sar	ecx, 1
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _median$[ebp], eax
	mov	ecx, DWORD PTR _Li$[ebp]
	add	ecx, DWORD PTR _Ri$[ebp]
	sar	ecx, 1
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	ax, WORD PTR [edx+ecx+4]
	mov	WORD PTR _median$[ebp+4], ax
	mov	ecx, DWORD PTR _Li$[ebp]
	add	ecx, DWORD PTR _Ri$[ebp]
	sar	ecx, 1
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _median$[ebp+8], eax
	mov	ecx, DWORD PTR _Li$[ebp]
	add	ecx, DWORD PTR _Ri$[ebp]
	sar	ecx, 1
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR _median$[ebp+12], eax
	mov	ecx, DWORD PTR _Li$[ebp]
	add	ecx, DWORD PTR _Ri$[ebp]
	sar	ecx, 1
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	al, BYTE PTR [edx+ecx+16]
	mov	BYTE PTR _median$[ebp+16], al

; 1387 : 
; 1388 : 		if( R_MeshCmp( meshes[Li], median ) )

	mov	ecx, DWORD PTR _Li$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+ecx+16]
	mov	ecx, DWORD PTR _median$[ebp+16]
	and	ecx, 255				; 000000ffH
	cmp	eax, ecx
	setg	dl
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	$L72738

; 1390 : 			if( R_MeshCmp( meshes[Ri], meshes[Li] ) )

	mov	eax, DWORD PTR _Ri$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+eax+16]
	mov	eax, DWORD PTR _Li$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	xor	ebx, ebx
	mov	bl, BYTE PTR [ecx+eax+16]
	cmp	edx, ebx
	setg	dl
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72739

; 1391 : 				R_MeshCopy( meshes[Li], median );

	mov	eax, DWORD PTR _Li$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _median$[ebp], edx
	mov	eax, DWORD PTR _Li$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	dx, WORD PTR [ecx+eax+4]
	mov	WORD PTR _median$[ebp+4], dx
	mov	eax, DWORD PTR _Li$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _median$[ebp+8], edx
	mov	eax, DWORD PTR _Li$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	edx, DWORD PTR [ecx+eax+12]
	mov	DWORD PTR _median$[ebp+12], edx
	mov	eax, DWORD PTR _Li$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	dl, BYTE PTR [ecx+eax+16]
	mov	BYTE PTR _median$[ebp+16], dl
$L72739:

; 1393 : 		else if( R_MeshCmp( median, meshes[Ri] ) )

	jmp	$L72741
$L72738:
	mov	eax, DWORD PTR _median$[ebp+16]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _Ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	xor	ebx, ebx
	mov	bl, BYTE PTR [edx+ecx+16]
	cmp	eax, ebx
	setg	al
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L72741

; 1395 : 			R_MeshCopy( meshes[Ri], median );

	mov	ecx, DWORD PTR _Ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _median$[ebp], eax
	mov	ecx, DWORD PTR _Ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	ax, WORD PTR [edx+ecx+4]
	mov	WORD PTR _median$[ebp+4], ax
	mov	ecx, DWORD PTR _Ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _median$[ebp+8], eax
	mov	ecx, DWORD PTR _Ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR _median$[ebp+12], eax
	mov	ecx, DWORD PTR _Ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	al, BYTE PTR [edx+ecx+16]
	mov	BYTE PTR _median$[ebp+16], al
$L72741:

; 1400 : 			while( R_MeshCmp( median, meshes[li] ) ) li++;

	mov	ecx, DWORD PTR _median$[ebp+16]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _li$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _meshes$[ebp]
	xor	ebx, ebx
	mov	bl, BYTE PTR [eax+edx+16]
	cmp	ecx, ebx
	setg	cl
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L72747
	mov	edx, DWORD PTR _li$[ebp]
	add	edx, 1
	mov	DWORD PTR _li$[ebp], edx
	jmp	SHORT $L72741
$L72747:

; 1401 : 			while( R_MeshCmp( meshes[ri], median ) ) ri--;

	mov	eax, DWORD PTR _ri$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+eax+16]
	mov	eax, DWORD PTR _median$[ebp+16]
	and	eax, 255				; 000000ffH
	cmp	edx, eax
	setg	cl
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L72750
	mov	edx, DWORD PTR _ri$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ri$[ebp], edx
	jmp	SHORT $L72747
$L72750:

; 1402 : 
; 1403 : 			if( li <= ri )

	mov	eax, DWORD PTR _li$[ebp]
	cmp	eax, DWORD PTR _ri$[ebp]
	jg	$L72751

; 1405 : 				R_MeshCopy( meshes[ri], tempbuf );

	mov	ecx, DWORD PTR _ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _tempbuf$[ebp], eax
	mov	ecx, DWORD PTR _ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	ax, WORD PTR [edx+ecx+4]
	mov	WORD PTR _tempbuf$[ebp+4], ax
	mov	ecx, DWORD PTR _ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _tempbuf$[ebp+8], eax
	mov	ecx, DWORD PTR _ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR _tempbuf$[ebp+12], eax
	mov	ecx, DWORD PTR _ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	al, BYTE PTR [edx+ecx+16]
	mov	BYTE PTR _tempbuf$[ebp+16], al

; 1406 : 				R_MeshCopy( meshes[li], meshes[ri] );

	mov	ecx, DWORD PTR _li$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _ri$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _meshes$[ebp]
	mov	esi, DWORD PTR _meshes$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, DWORD PTR _li$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _ri$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	esi, DWORD PTR _meshes$[ebp]
	mov	dx, WORD PTR [esi+edx+4]
	mov	WORD PTR [ecx+eax+4], dx
	mov	eax, DWORD PTR _li$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	esi, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [esi+eax+8]
	mov	DWORD PTR [edx+ecx+8], eax
	mov	ecx, DWORD PTR _li$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _ri$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _meshes$[ebp]
	mov	esi, DWORD PTR _meshes$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+12]
	mov	DWORD PTR [eax+edx+12], ecx
	mov	edx, DWORD PTR _li$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _ri$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	esi, DWORD PTR _meshes$[ebp]
	mov	dl, BYTE PTR [esi+edx+16]
	mov	BYTE PTR [ecx+eax+16], dl

; 1407 : 				R_MeshCopy( tempbuf, meshes[li] );

	mov	eax, DWORD PTR _li$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	edx, DWORD PTR _tempbuf$[ebp]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, DWORD PTR _li$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	dx, WORD PTR _tempbuf$[ebp+4]
	mov	WORD PTR [ecx+eax+4], dx
	mov	eax, DWORD PTR _li$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	edx, DWORD PTR _tempbuf$[ebp+8]
	mov	DWORD PTR [ecx+eax+8], edx
	mov	eax, DWORD PTR _li$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	edx, DWORD PTR _tempbuf$[ebp+12]
	mov	DWORD PTR [ecx+eax+12], edx
	mov	eax, DWORD PTR _li$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	dl, BYTE PTR _tempbuf$[ebp+16]
	mov	BYTE PTR [ecx+eax+16], dl

; 1408 : 
; 1409 : 				li++;

	mov	eax, DWORD PTR _li$[ebp]
	add	eax, 1
	mov	DWORD PTR _li$[ebp], eax

; 1410 : 				ri--;

	mov	ecx, DWORD PTR _ri$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ri$[ebp], ecx
$L72751:

; 1412 : 		} while( li < ri );

	mov	edx, DWORD PTR _li$[ebp]
	cmp	edx, DWORD PTR _ri$[ebp]
	jl	$L72741

; 1413 : 
; 1414 : 		if( ( Li < ri ) && ( stackdepth < QSORT_MAX_STACKDEPTH ) )

	mov	eax, DWORD PTR _Li$[ebp]
	cmp	eax, DWORD PTR _ri$[ebp]
	jge	SHORT $L72752
	cmp	DWORD PTR _stackdepth$[ebp], 1024	; 00000400H
	jge	SHORT $L72752

; 1416 : 			lstack[stackdepth] = li;

	mov	ecx, DWORD PTR _stackdepth$[ebp]
	mov	edx, DWORD PTR _li$[ebp]
	mov	DWORD PTR _lstack$[ebp+ecx*4], edx

; 1417 : 			rstack[stackdepth] = Ri;

	mov	eax, DWORD PTR _stackdepth$[ebp]
	mov	ecx, DWORD PTR _Ri$[ebp]
	mov	DWORD PTR _rstack$[ebp+eax*4], ecx

; 1418 : 			stackdepth++;

	mov	edx, DWORD PTR _stackdepth$[ebp]
	add	edx, 1
	mov	DWORD PTR _stackdepth$[ebp], edx

; 1419 : 			li = Li;

	mov	eax, DWORD PTR _Li$[ebp]
	mov	DWORD PTR _li$[ebp], eax

; 1420 : 			Ri = ri;

	mov	ecx, DWORD PTR _ri$[ebp]
	mov	DWORD PTR _Ri$[ebp], ecx

; 1421 : 			goto mark0;

	jmp	$mark0$72736
$L72752:

; 1423 : 
; 1424 : 		if( li < Ri )

	mov	edx, DWORD PTR _li$[ebp]
	cmp	edx, DWORD PTR _Ri$[ebp]
	jge	SHORT $L72753

; 1426 : 			Li = li;

	mov	eax, DWORD PTR _li$[ebp]
	mov	DWORD PTR _Li$[ebp], eax

; 1427 : 			goto mark0;

	jmp	$mark0$72736
$L72753:

; 1430 : 
; 1431 : 	if( stackdepth )

	cmp	DWORD PTR _stackdepth$[ebp], 0
	je	SHORT $L72754

; 1433 : 		--stackdepth;

	mov	ecx, DWORD PTR _stackdepth$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _stackdepth$[ebp], ecx

; 1434 : 		Ri = ri = rstack[stackdepth];

	mov	edx, DWORD PTR _stackdepth$[ebp]
	mov	eax, DWORD PTR _rstack$[ebp+edx*4]
	mov	DWORD PTR _ri$[ebp], eax
	mov	ecx, DWORD PTR _ri$[ebp]
	mov	DWORD PTR _Ri$[ebp], ecx

; 1435 : 		Li = li = lstack[stackdepth];

	mov	edx, DWORD PTR _stackdepth$[ebp]
	mov	eax, DWORD PTR _lstack$[ebp+edx*4]
	mov	DWORD PTR _li$[ebp], eax
	mov	ecx, DWORD PTR _li$[ebp]
	mov	DWORD PTR _Li$[ebp], ecx

; 1436 : 		goto mark0;

	jmp	$mark0$72736
$L72754:

; 1438 : 
; 1439 : 	for( li = 1; li < total; li++ )

	mov	DWORD PTR _li$[ebp], 1
	jmp	SHORT $L72755
$L72756:
	mov	edx, DWORD PTR _li$[ebp]
	add	edx, 1
	mov	DWORD PTR _li$[ebp], edx
$L72755:
	mov	eax, DWORD PTR _li$[ebp]
	cmp	eax, DWORD PTR _total$[ebp]
	jge	$L72757

; 1441 : 		R_MeshCopy( meshes[li], tempbuf );

	mov	ecx, DWORD PTR _li$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _tempbuf$[ebp], eax
	mov	ecx, DWORD PTR _li$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	ax, WORD PTR [edx+ecx+4]
	mov	WORD PTR _tempbuf$[ebp+4], ax
	mov	ecx, DWORD PTR _li$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _tempbuf$[ebp+8], eax
	mov	ecx, DWORD PTR _li$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR _tempbuf$[ebp+12], eax
	mov	ecx, DWORD PTR _li$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	al, BYTE PTR [edx+ecx+16]
	mov	BYTE PTR _tempbuf$[ebp+16], al

; 1442 : 		ri = li - 1;

	mov	ecx, DWORD PTR _li$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ri$[ebp], ecx
$L72759:

; 1443 : 
; 1444 : 		while( ( ri >= 0 ) && ( R_MeshCmp( meshes[ri], tempbuf ) ) )

	cmp	DWORD PTR _ri$[ebp], 0
	jl	$L72760
	mov	edx, DWORD PTR _ri$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _meshes$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+edx+16]
	mov	edx, DWORD PTR _tempbuf$[ebp+16]
	and	edx, 255				; 000000ffH
	cmp	ecx, edx
	setg	al
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L72760

; 1446 : 			R_MeshCopy( meshes[ri], meshes[ri+1] );

	mov	ecx, DWORD PTR _ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _ri$[ebp]
	add	edx, 1
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _meshes$[ebp]
	mov	esi, DWORD PTR _meshes$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, DWORD PTR _ri$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _ri$[ebp]
	add	eax, 1
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	esi, DWORD PTR _meshes$[ebp]
	mov	dx, WORD PTR [esi+edx+4]
	mov	WORD PTR [ecx+eax+4], dx
	mov	eax, DWORD PTR _ri$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _ri$[ebp]
	add	ecx, 1
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _meshes$[ebp]
	mov	esi, DWORD PTR _meshes$[ebp]
	mov	eax, DWORD PTR [esi+eax+8]
	mov	DWORD PTR [edx+ecx+8], eax
	mov	ecx, DWORD PTR _ri$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _ri$[ebp]
	add	edx, 1
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _meshes$[ebp]
	mov	esi, DWORD PTR _meshes$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+12]
	mov	DWORD PTR [eax+edx+12], ecx
	mov	edx, DWORD PTR _ri$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _ri$[ebp]
	add	eax, 1
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _meshes$[ebp]
	mov	esi, DWORD PTR _meshes$[ebp]
	mov	dl, BYTE PTR [esi+edx+16]
	mov	BYTE PTR [ecx+eax+16], dl

; 1447 : 			ri--;

	mov	eax, DWORD PTR _ri$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ri$[ebp], eax

; 1448 : 		}

	jmp	$L72759
$L72760:

; 1449 : 
; 1450 : 		if( li != ri+1 )

	mov	ecx, DWORD PTR _ri$[ebp]
	add	ecx, 1
	cmp	DWORD PTR _li$[ebp], ecx
	je	SHORT $L72761

; 1451 : 			R_MeshCopy( tempbuf, meshes[ri+1] );

	mov	edx, DWORD PTR _ri$[ebp]
	add	edx, 1
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _meshes$[ebp]
	mov	ecx, DWORD PTR _tempbuf$[ebp]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, DWORD PTR _ri$[ebp]
	add	edx, 1
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _meshes$[ebp]
	mov	cx, WORD PTR _tempbuf$[ebp+4]
	mov	WORD PTR [eax+edx+4], cx
	mov	edx, DWORD PTR _ri$[ebp]
	add	edx, 1
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _meshes$[ebp]
	mov	ecx, DWORD PTR _tempbuf$[ebp+8]
	mov	DWORD PTR [eax+edx+8], ecx
	mov	edx, DWORD PTR _ri$[ebp]
	add	edx, 1
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _meshes$[ebp]
	mov	ecx, DWORD PTR _tempbuf$[ebp+12]
	mov	DWORD PTR [eax+edx+12], ecx
	mov	edx, DWORD PTR _ri$[ebp]
	add	edx, 1
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _meshes$[ebp]
	mov	cl, BYTE PTR _tempbuf$[ebp+16]
	mov	BYTE PTR [eax+edx+16], cl
$L72761:

; 1452 : 	}

	jmp	$L72756
$L72757:

; 1453 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?QSortStudioMeshes@CStudioModelRenderer@@AAEXPAUgl_studiomesh_t@@HH@Z ENDP ; CStudioModelRenderer::QSortStudioMeshes
_TEXT	ENDS
EXTRN	?pglDrawRangeElementsEXT@@3P6GXIIIHIPBX@ZA:DWORD ; pglDrawRangeElementsEXT
EXTRN	?pglDrawElements@@3P6GXIHIPBX@ZA:DWORD		; pglDrawElements
EXTRN	?GL_Support@@YA_NH@Z:NEAR			; GL_Support
;	COMDAT ?DrawMeshFromBuffer@CStudioModelRenderer@@AAEXPBUvbomesh_s@@@Z
_TEXT	SEGMENT
_mesh$ = 8
_this$ = -4
?DrawMeshFromBuffer@CStudioModelRenderer@@AAEXPBUvbomesh_s@@@Z PROC NEAR ; CStudioModelRenderer::DrawMeshFromBuffer, COMDAT

; 3964 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3965 : 	pglBindVertexArray( mesh->vao );

	mov	eax, DWORD PTR _mesh$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR ?pglBindVertexArray@@3P6GXI@ZA ; pglBindVertexArray

; 3966 : 	pglBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mesh->ibo );

	mov	edx, DWORD PTR _mesh$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	push	34963					; 00008893H
	call	DWORD PTR ?pglBindBufferARB@@3P6GXII@ZA	; pglBindBufferARB

; 3967 : 
; 3968 : 	if( GL_Support( R_DRAW_RANGEELEMENTS_EXT ))

	push	9
	call	?GL_Support@@YA_NH@Z			; GL_Support
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74083

; 3969 : 		pglDrawRangeElementsEXT( GL_TRIANGLES, 0, mesh->numVerts - 1, mesh->numElems, GL_UNSIGNED_INT, 0 );

	push	0
	push	5125					; 00001405H
	mov	ecx, DWORD PTR _mesh$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _mesh$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+4]
	sub	ecx, 1
	push	ecx
	push	0
	push	4
	call	DWORD PTR ?pglDrawRangeElementsEXT@@3P6GXIIIHIPBX@ZA ; pglDrawRangeElementsEXT

; 3970 : 	else pglDrawElements( GL_TRIANGLES, mesh->numElems, GL_UNSIGNED_INT, 0 );

	jmp	SHORT $L74084
$L74083:
	push	0
	push	5125					; 00001405H
	mov	edx, DWORD PTR _mesh$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	4
	call	DWORD PTR ?pglDrawElements@@3P6GXIHIPBX@ZA ; pglDrawElements
$L74084:

; 3971 : 
; 3972 : 	r_stats.c_total_tris += (mesh->numElems / 3);

	mov	ecx, DWORD PTR _mesh$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR ?r_stats@@3Uref_stats_t@@A+52
	add	edx, eax
	mov	DWORD PTR ?r_stats@@3Uref_stats_t@@A+52, edx

; 3973 : 	r_stats.num_flushes++;

	mov	eax, DWORD PTR ?r_stats@@3Uref_stats_t@@A+76
	add	eax, 1
	mov	DWORD PTR ?r_stats@@3Uref_stats_t@@A+76, eax

; 3974 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DrawMeshFromBuffer@CStudioModelRenderer@@AAEXPBUvbomesh_s@@@Z ENDP ; CStudioModelRenderer::DrawMeshFromBuffer
_TEXT	ENDS
EXTRN	?R_CountPlights@@YAH_N@Z:NEAR			; R_CountPlights
EXTRN	?cl_plights@@3PAUplight_s@@A:BYTE		; cl_plights
EXTRN	?GL_AlphaTest@@YAXH@Z:NEAR			; GL_AlphaTest
;	COMDAT ?RenderDynLightList@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pl$ = -8
_i$ = -12
?RenderDynLightList@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::RenderDynLightList, COMDAT

; 4137 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4138 : 	if( FBitSet( RI->params, RP_ENVVIEW ))

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L74176

; 4139 : 		return;

	jmp	$L74175
$L74176:

; 4140 : 
; 4141 : 	if( !R_CountPlights( ))

	push	0
	call	?R_CountPlights@@YAH_N@Z		; R_CountPlights
	add	esp, 4
	test	eax, eax
	jne	SHORT $L74177

; 4142 : 		return;

	jmp	$L74175
$L74177:

; 4143 : 
; 4144 : 	GL_Blend( GL_TRUE );

	push	1
	call	?GL_Blend@@YAXH@Z			; GL_Blend
	add	esp, 4

; 4145 : 	GL_AlphaTest( GL_FALSE );

	push	0
	call	?GL_AlphaTest@@YAXH@Z			; GL_AlphaTest
	add	esp, 4

; 4146 : 	GL_DepthMask( GL_FALSE );

	push	0
	call	?GL_DepthMask@@YAXH@Z			; GL_DepthMask
	add	esp, 4

; 4147 : 	pglBlendFunc( GL_ONE, GL_ONE );

	push	1
	push	1
	call	DWORD PTR ?pglBlendFunc@@3P6GXII@ZA	; pglBlendFunc

; 4148 : 	pglEnable( GL_SCISSOR_TEST );

	push	3089					; 00000c11H
	call	DWORD PTR ?pglEnable@@3P6GXI@ZA		; pglEnable

; 4149 : 	plight_t *pl = cl_plights;

	mov	DWORD PTR _pl$[ebp], OFFSET FLAT:?cl_plights@@3PAUplight_s@@A ; cl_plights

; 4150 : 
; 4151 : 	for( int i = 0; i < MAX_PLIGHTS; i++, pl++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74180
$L74181:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _pl$[ebp]
	add	eax, 436				; 000001b4H
	mov	DWORD PTR _pl$[ebp], eax
$L74180:
	cmp	DWORD PTR _i$[ebp], 96			; 00000060H
	jge	$L74182

; 4153 : 		if( pl->die < tr.time || !pl->radius || pl->culled )

	mov	ecx, DWORD PTR _pl$[ebp]
	fld	DWORD PTR [ecx+32]
	fcomp	QWORD PTR ?tr@@3Uref_globals_t@@A+8
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L74184
	mov	edx, DWORD PTR _pl$[ebp]
	fld	DWORD PTR [edx+24]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L74184
	mov	eax, DWORD PTR _pl$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+46]
	test	ecx, ecx
	je	SHORT $L74183
$L74184:

; 4154 : 			continue;

	jmp	SHORT $L74181
$L74183:

; 4155 : 
; 4156 : 		RI->currentlight = pl;

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR _pl$[ebp]
	mov	DWORD PTR [edx+24], eax

; 4157 : 
; 4158 : 		if( !Mod_CheckBoxVisible( pl->absmin, pl->absmax ))

	mov	ecx, DWORD PTR _pl$[ebp]
	add	ecx, 252				; 000000fcH
	push	ecx
	mov	edx, DWORD PTR _pl$[ebp]
	add	edx, 240				; 000000f0H
	push	edx
	call	?Mod_CheckBoxVisible@@YA_NABVVector@@0@Z ; Mod_CheckBoxVisible
	add	esp, 8
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74185

; 4159 : 			continue;

	jmp	$L74181
$L74185:

; 4160 : 
; 4161 : 		if( R_CullBox( pl->absmin, pl->absmax ))

	push	0
	mov	eax, DWORD PTR _pl$[ebp]
	add	eax, 252				; 000000fcH
	push	eax
	mov	ecx, DWORD PTR _pl$[ebp]
	add	ecx, 240				; 000000f0H
	push	ecx
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	ecx, 48					; 00000030H
	call	?CullBox@CFrustum@@QAE_NABVVector@@0H@Z	; CFrustum::CullBox
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74186

; 4162 : 			continue;

	jmp	$L74181
$L74186:

; 4163 : 
; 4164 : 		// draw world from light position
; 4165 : 		BuildMeshListForLight( pl );

	mov	edx, DWORD PTR _pl$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+188]

; 4166 : 
; 4167 : 		if( !m_nNumLightMeshes )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+5385964], 0
	jne	SHORT $L74187

; 4168 : 			continue;	// no interaction with this light?

	jmp	$L74181
$L74187:

; 4169 : 
; 4170 : 		DrawLightForMeshList( pl );

	mov	ecx, DWORD PTR _pl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+192]

; 4171 : 	}

	jmp	$L74181
$L74182:

; 4172 : 
; 4173 : 	GL_SelectTexture( glConfig.max_texture_units - 1 ); // force to cleanup all the units

	mov	ecx, DWORD PTR ?glConfig@@3UglConfig_t@@A+40
	sub	ecx, 1
	push	ecx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+136
	add	esp, 4

; 4174 : 	pglDisable( GL_SCISSOR_TEST );

	push	3089					; 00000c11H
	call	DWORD PTR ?pglDisable@@3P6GXI@ZA	; pglDisable

; 4175 : 	GL_CleanUpTextureUnits( 0 );

	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+148
	add	esp, 4

; 4176 : 	RI->currentlight = NULL;

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	DWORD PTR [edx+24], 0
$L74175:

; 4177 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderDynLightList@CStudioModelRenderer@@EAEXXZ ENDP	; CStudioModelRenderer::RenderDynLightList
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DrawStudioMeshes@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::DrawStudioMeshes'::`2'::__LINE__Var
EXTRN	?DrawDecal@CStudioModelRenderer@@AAEXPAUcl_entity_s@@@Z:NEAR ; CStudioModelRenderer::DrawDecal
EXTRN	?pglAlphaFunc@@3P6GXIM@ZA:DWORD			; pglAlphaFunc
EXTRN	?R_SetRenderColor@@YAXPAUcl_entity_s@@@Z:NEAR	; R_SetRenderColor
EXTRN	?pglUniform1fARB@@3P6GXHM@ZA:DWORD		; pglUniform1fARB
;	COMDAT ?__LINE__Var@?1??DrawStudioMeshes@CStudioModelRenderer@@EAEXXZ@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DrawStudioMeshes@CStudioModelRenderer@@EAEXXZ@4FA DW 01054H ; `CStudioModelRenderer::DrawStudioMeshes'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?DrawStudioMeshes@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
_cached_material$ = -8
_cached_entity$ = -12
_cached_model$ = -16
_i$ = -20
_right$ = -32
_entry$74207 = -36
_m_skinnum$74209 = -40
_pMesh$74210 = -44
_pskinref$74211 = -48
_mat$74214 = -52
_light$74223 = -56
_num_bones$74224 = -60
_lightstyles$74225 = -76
_map$74226 = -80
$T76641 = -92
$T76642 = -104
$T76643 = -168
?DrawStudioMeshes@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::DrawStudioMeshes, COMDAT

; 4180 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4181 : 	mstudiomaterial_t	*cached_material = NULL;

	mov	DWORD PTR _cached_material$[ebp], 0

; 4182 : 	cl_entity_t	*cached_entity = NULL;

	mov	DWORD PTR _cached_entity$[ebp], 0

; 4183 : 	model_t		*cached_model = NULL;

	mov	DWORD PTR _cached_model$[ebp], 0

; 4184 : 	int		i;
; 4185 : 
; 4186 : 	if( FBitSet( RI->params, RP_SHADOWVIEW ))

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	je	SHORT $L74196

; 4188 : 		DrawStudioMeshesShadow();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+156]

; 4189 : 		return;

	jmp	$L74191
$L74196:

; 4191 : 
; 4192 : 	if( !m_nNumDrawMeshes )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+5365480], 0
	jne	SHORT $L74197

; 4193 : 		return;

	jmp	$L74191
$L74197:

; 4194 : 
; 4195 : 	if( m_pCurrentEntity->modelhandle == INVALID_HANDLE )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	cmp	DWORD PTR [eax+2960], 65535		; 0000ffffH
	jne	SHORT $L74198

; 4196 : 		return; // out of memory ?

	jmp	$L74191
$L74198:

; 4197 : 
; 4198 : 	m_pModelInstance = &m_ModelInstances[m_pCurrentEntity->modelhandle];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	ax, WORD PTR [edx+2960]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19112], eax

; 4199 : 	tr.modelorg = m_pModelInstance->m_protationmatrix.VectorITransform( RI->vieworg );

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	edx, 204				; 000000ccH
	push	edx
	lea	eax, DWORD PTR $T76641[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+19112]
	add	ecx, 11452				; 00002cbcH
	call	?VectorITransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorITransform
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR ?tr@@3Uref_globals_t@@A+1425408, edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR ?tr@@3Uref_globals_t@@A+1425412, ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR ?tr@@3Uref_globals_t@@A+1425416, edx

; 4200 : 	Vector right = m_pModelInstance->m_plightmatrix.VectorIRotate( RI->vright );

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	eax, 228				; 000000e4H
	push	eax
	lea	ecx, DWORD PTR $T76642[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	add	ecx, 11500				; 00002cecH
	call	?VectorIRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorIRotate
	push	eax
	lea	ecx, DWORD PTR _right$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 4201 : 
; 4202 : 	R_TransformForEntity( m_pModelInstance->m_protationmatrix );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 11452				; 00002cbcH
	push	ecx
	lea	ecx, DWORD PTR $T76643[ebp]
	call	??0matrix4x4@@QAE@ABVmatrix3x4@@@Z	; matrix4x4::matrix4x4
	lea	edx, DWORD PTR $T76643[ebp]
	push	edx
	call	?R_TransformForEntity@@YAXABVmatrix4x4@@@Z ; R_TransformForEntity
	add	esp, 4

; 4203 : //	R_LoadIdentity();
; 4204 : 	GL_Blend( GL_FALSE );

	push	0
	call	?GL_Blend@@YAXH@Z			; GL_Blend
	add	esp, 4

; 4205 : 	GL_AlphaTest( GL_FALSE );

	push	0
	call	?GL_AlphaTest@@YAXH@Z			; GL_AlphaTest
	add	esp, 4

; 4206 : 	GL_DepthMask( GL_TRUE );

	push	1
	call	?GL_DepthMask@@YAXH@Z			; GL_DepthMask
	add	esp, 4

; 4207 : 
; 4208 : 	// sorting list to reduce shader switches
; 4209 : 	if( !CVAR_TO_BOOL( r_nosort )) QSortStudioMeshes( m_DrawMeshes, 0, m_nNumDrawMeshes - 1 );

	cmp	DWORD PTR ?r_nosort@@3PAUcvar_s@@A, 0	; r_nosort
	je	SHORT $L76644
	mov	eax, DWORD PTR ?r_nosort@@3PAUcvar_s@@A	; r_nosort
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76644
	mov	BYTE PTR -172+[ebp], 1
	jmp	SHORT $L76645
$L76644:
	mov	BYTE PTR -172+[ebp], 0
$L76645:
	mov	ecx, DWORD PTR -172+[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L74203
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5365480]
	sub	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5345000				; 00518ee8H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?QSortStudioMeshes@CStudioModelRenderer@@AAEXPAUgl_studiomesh_t@@HH@Z ; CStudioModelRenderer::QSortStudioMeshes
$L74203:

; 4210 : 
; 4211 : 	// sorting list to reduce shader switches
; 4212 : 	for( i = 0; i < m_nNumDrawMeshes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74204
$L74205:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L74204:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+5365480]
	jge	$L74206

; 4214 : 		gl_studiomesh_t *entry = &m_DrawMeshes[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+5345000]
	mov	DWORD PTR _entry$74207[ebp], ecx

; 4215 : 		RI->currentmodel = m_pRenderModel = entry->model;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _entry$74207[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+19108], ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	DWORD PTR [edx+20], ecx

; 4216 : 		m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	push	eax
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19124], eax

; 4217 : 		int m_skinnum = bound( 0, m_pCurrentEntity->curstate.skin, m_pStudioHeader->numskinfamilies - 1 );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	movsx	ecx, WORD PTR [eax+744]
	test	ecx, ecx
	jl	SHORT $L76648
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	movsx	ecx, WORD PTR [eax+744]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	edx, DWORD PTR [eax+196]
	sub	edx, 1
	cmp	ecx, edx
	jge	SHORT $L76646
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	movsx	edx, WORD PTR [ecx+744]
	mov	DWORD PTR -176+[ebp], edx
	jmp	SHORT $L76647
$L76646:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR [ecx+196]
	sub	edx, 1
	mov	DWORD PTR -176+[ebp], edx
$L76647:
	mov	eax, DWORD PTR -176+[ebp]
	mov	DWORD PTR -180+[ebp], eax
	jmp	SHORT $L76649
$L76648:
	mov	DWORD PTR -180+[ebp], 0
$L76649:
	mov	ecx, DWORD PTR -180+[ebp]
	mov	DWORD PTR _m_skinnum$74209[ebp], ecx

; 4218 : 		vbomesh_t *pMesh = entry->mesh;

	mov	edx, DWORD PTR _entry$74207[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pMesh$74210[ebp], eax

; 4219 : 
; 4220 : 		short *pskinref = (short *)((byte *)m_pStudioHeader + m_pStudioHeader->skinindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+200]
	mov	DWORD PTR _pskinref$74211[ebp], ecx

; 4221 : 		pskinref += (m_skinnum * m_pStudioHeader->numskinref);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _m_skinnum$74209[ebp]
	imul	ecx, DWORD PTR [eax+192]
	mov	edx, DWORD PTR _pskinref$74211[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pskinref$74211[ebp], eax

; 4222 : 
; 4223 : 		mstudiomaterial_t *mat = &m_pRenderModel->materials[pskinref[pMesh->skinref]];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	eax, DWORD PTR _pMesh$74210[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _pskinref$74211[ebp]
	movsx	ecx, WORD PTR [eax+ecx*2]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR [edx+384]
	add	edx, ecx
	mov	DWORD PTR _mat$74214[ebp], edx

; 4224 : 
; 4225 : 		ASSERT( m_pCurrentEntity->modelhandle != INVALID_HANDLE );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx+2960], 65535		; 0000ffffH
	jne	SHORT $L74216
	movsx	edx, WORD PTR ?__LINE__Var@?1??DrawStudioMeshes@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::DrawStudioMeshes'::`2'::__LINE__Var
	add	edx, 45					; 0000002dH
	push	edx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L74216:

; 4226 : 
; 4227 : 		// begin draw the sorted list
; 4228 : 		if(( i == 0 ) || ( RI->currentshader != &glsl_programs[entry->hProgram] ))

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $L74218
	mov	eax, DWORD PTR _entry$74207[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+4]
	imul	ecx, 876				; 0000036cH
	add	ecx, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [edx+28], ecx
	je	$L74217
$L74218:

; 4230 : 			GL_BindShader( &glsl_programs[entry->hProgram] );			

	mov	eax, DWORD PTR _entry$74207[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+4]
	imul	ecx, 876				; 0000036cH
	add	ecx, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	push	ecx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 4231 : 
; 4232 : 			ASSERT( RI->currentshader != NULL );

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $L74219
	movsx	eax, WORD PTR ?__LINE__Var@?1??DrawStudioMeshes@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::DrawStudioMeshes'::`2'::__LINE__Var
	add	eax, 52					; 00000034H
	push	eax
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L74219:

; 4233 : 
; 4234 : 			// write constants
; 4235 : 			pglUniform3fARB( RI->currentshader->u_ViewOrigin, tr.modelorg.x, tr.modelorg.y, tr.modelorg.z );

	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1425416
	push	ecx
	mov	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1425412
	push	edx
	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+1425408
	push	eax
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+780]
	push	eax
	call	DWORD PTR ?pglUniform3fARB@@3P6GXHMMM@ZA ; pglUniform3fARB

; 4236 : 			pglUniform3fARB( RI->currentshader->u_ViewRight, right.x, right.y, right.z );

	mov	ecx, DWORD PTR _right$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _right$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _right$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+784]
	push	eax
	call	DWORD PTR ?pglUniform3fARB@@3P6GXHMMM@ZA ; pglUniform3fARB

; 4237 : 			pglUniform4fARB( RI->currentshader->u_FogParams, tr.fogColor[0], tr.fogColor[1], tr.fogColor[2], tr.fogDensity );

	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1411972
	push	ecx
	mov	ecx, OFFSET FLAT:?tr@@3Uref_globals_t@@A+1411960
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax+8]
	push	edx
	mov	ecx, OFFSET FLAT:?tr@@3Uref_globals_t@@A+1411960
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, OFFSET FLAT:?tr@@3Uref_globals_t@@A+1411960
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+768]
	push	ecx
	call	DWORD PTR ?pglUniform4fARB@@3P6GXHMMMM@ZA ; pglUniform4fARB

; 4238 : 
; 4239 : 			if( FBitSet( m_pModelInstance->info_flags, MF_VERTEX_LIGHTING ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L74220

; 4240 : 				pglUniform4fvARB( RI->currentshader->u_GammaTable, 64, &tr.gamma_table[0][0] );

	mov	ecx, OFFSET FLAT:?tr@@3Uref_globals_t@@A+1416136
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	push	eax
	push	64					; 00000040H
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+660]
	push	ecx
	call	DWORD PTR ?pglUniform4fvARB@@3P6GXHHPBM@ZA ; pglUniform4fvARB
$L74220:

; 4241 : 
; 4242 : 			// reset cache
; 4243 : 			cached_material = NULL;

	mov	DWORD PTR _cached_material$[ebp], 0

; 4244 : 			cached_entity = NULL;

	mov	DWORD PTR _cached_entity$[ebp], 0

; 4245 : 			cached_model = NULL;

	mov	DWORD PTR _cached_model$[ebp], 0
$L74217:

; 4247 : 
; 4248 : 		if( cached_entity != m_pCurrentEntity || ( cached_model != m_pRenderModel ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _cached_entity$[ebp]
	cmp	eax, DWORD PTR [edx+19104]
	jne	SHORT $L74222
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _cached_model$[ebp]
	cmp	edx, DWORD PTR [ecx+19108]
	je	$L74221
$L74222:

; 4250 : 			// update bones array
; 4251 : 			mstudiolight_t *light = &m_pModelInstance->lighting;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _light$74223[ebp], ecx

; 4252 : 			int num_bones = Q_min( m_pStudioHeader->numbones, glConfig.max_skinning_bones );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR [eax+140]
	cmp	ecx, DWORD PTR ?glConfig@@3UglConfig_t@@A+72
	jge	SHORT $L76650
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR -184+[ebp], ecx
	jmp	SHORT $L76651
$L76650:
	mov	edx, DWORD PTR ?glConfig@@3UglConfig_t@@A+72
	mov	DWORD PTR -184+[ebp], edx
$L76651:
	mov	eax, DWORD PTR -184+[ebp]
	mov	DWORD PTR _num_bones$74224[ebp], eax

; 4253 : 			Vector4D lightstyles;

	lea	ecx, DWORD PTR _lightstyles$74225[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 4254 : 
; 4255 : 			for( int map = 0; map < MAXLIGHTMAPS; map++ )

	mov	DWORD PTR _map$74226[ebp], 0
	jmp	SHORT $L74227
$L74228:
	mov	ecx, DWORD PTR _map$74226[ebp]
	add	ecx, 1
	mov	DWORD PTR _map$74226[ebp], ecx
$L74227:
	cmp	DWORD PTR _map$74226[ebp], 4
	jge	SHORT $L74229

; 4257 : 				if( m_pModelInstance->styles[map] != 255 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR _map$74226[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [eax+ecx+24]
	cmp	edx, 255				; 000000ffH
	je	SHORT $L74230

; 4258 : 					lightstyles[map] = tr.lightstyles[m_pModelInstance->styles[map]];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	mov	edx, DWORD PTR _map$74226[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+edx+24]
	mov	esi, eax
	lea	ecx, DWORD PTR _lightstyles$74225[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _map$74226[ebp]
	mov	edx, DWORD PTR ?tr@@3Uref_globals_t@@A[esi*4+72312]
	mov	DWORD PTR [eax+ecx*4], edx

; 4259 : 				else lightstyles[map] = 0.0f;

	jmp	SHORT $L74231
$L74230:
	lea	ecx, DWORD PTR _lightstyles$74225[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _map$74226[ebp]
	mov	DWORD PTR [eax+ecx*4], 0
$L74231:

; 4260 : 			}

	jmp	SHORT $L74228
$L74229:

; 4261 : 
; 4262 : 			if( m_pRenderModel == IEngineStudio.GetModelByIndex( m_pCurrentEntity->curstate.weaponmodel ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	ecx, DWORD PTR [eax+868]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+20
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+19108], eax
	jne	SHORT $L74232

; 4264 : 				pglUniform4fvARB( RI->currentshader->u_BoneQuaternion, num_bones, &m_pModelInstance->m_weaponquat[0][0] );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 30500				; 00007724H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	push	eax
	mov	ecx, DWORD PTR _num_bones$74224[ebp]
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+652]
	push	ecx
	call	DWORD PTR ?pglUniform4fvARB@@3P6GXHHPBM@ZA ; pglUniform4fvARB

; 4265 : 				pglUniform3fvARB( RI->currentshader->u_BonePosition, num_bones, &m_pModelInstance->m_weaponpos[0][0] );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	add	ecx, 32548				; 00007f24H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	eax, DWORD PTR _num_bones$74224[ebp]
	push	eax
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+656]
	push	eax
	call	DWORD PTR ?pglUniform3fvARB@@3P6GXHHPBM@ZA ; pglUniform3fvARB

; 4267 : 			else

	jmp	SHORT $L74233
$L74232:

; 4269 : 				pglUniform4fvARB( RI->currentshader->u_BoneQuaternion, num_bones, &m_pModelInstance->m_studioquat[0][0] );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+19112]
	add	ecx, 26916				; 00006924H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	push	eax
	mov	edx, DWORD PTR _num_bones$74224[ebp]
	push	edx
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+652]
	push	edx
	call	DWORD PTR ?pglUniform4fvARB@@3P6GXHHPBM@ZA ; pglUniform4fvARB

; 4270 : 				pglUniform3fvARB( RI->currentshader->u_BonePosition, num_bones, &m_pModelInstance->m_studiopos[0][0] );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 28964				; 00007124H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _num_bones$74224[ebp]
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+656]
	push	ecx
	call	DWORD PTR ?pglUniform3fvARB@@3P6GXHHPBM@ZA ; pglUniform3fvARB
$L74233:

; 4272 : 
; 4273 : 			if( FBitSet( m_pModelInstance->info_flags, MF_VERTEX_LIGHTING ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L74234

; 4275 : 				pglUniform4fARB( RI->currentshader->u_LightStyleValues, lightstyles.x, lightstyles.y, lightstyles.z, lightstyles.w );

	mov	edx, DWORD PTR _lightstyles$74225[ebp+12]
	push	edx
	mov	eax, DWORD PTR _lightstyles$74225[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _lightstyles$74225[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _lightstyles$74225[ebp]
	push	edx
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+748]
	push	edx
	call	DWORD PTR ?pglUniform4fARB@@3P6GXHMMMM@ZA ; pglUniform4fARB

; 4277 : 			else

	jmp	$L74235
$L74234:

; 4279 : 				pglUniform3fARB( RI->currentshader->u_LightColor, light->color.x, light->color.y, light->color.z );

	mov	eax, DWORD PTR _light$74223[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _light$74223[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _light$74223[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+728]
	push	edx
	call	DWORD PTR ?pglUniform3fARB@@3P6GXHMMM@ZA ; pglUniform3fARB

; 4280 : 				pglUniform3fARB( RI->currentshader->u_LightDir, light->plightvec[0], light->plightvec[1], light->plightvec[2] );

	mov	ecx, DWORD PTR _light$74223[ebp]
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR _light$74223[ebp]
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _light$74223[ebp]
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+724]
	push	edx
	call	DWORD PTR ?pglUniform3fARB@@3P6GXHMMM@ZA ; pglUniform3fARB

; 4281 : 				pglUniform1fARB( RI->currentshader->u_LightAmbient, light->ambientlight );

	mov	eax, DWORD PTR _light$74223[ebp]
	fild	DWORD PTR [eax]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+732]
	push	eax
	call	DWORD PTR ?pglUniform1fARB@@3P6GXHM@ZA	; pglUniform1fARB

; 4282 : 				pglUniform1fARB( RI->currentshader->u_LightShade, light->shadelight );

	mov	ecx, DWORD PTR _light$74223[ebp]
	fild	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+736]
	push	ecx
	call	DWORD PTR ?pglUniform1fARB@@3P6GXHM@ZA	; pglUniform1fARB
$L74235:

; 4284 : 
; 4285 : 			R_SetRenderColor( m_pCurrentEntity );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	push	eax
	call	?R_SetRenderColor@@YAXPAUcl_entity_s@@@Z ; R_SetRenderColor
	add	esp, 4

; 4286 : 			cached_entity = m_pCurrentEntity;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	DWORD PTR _cached_entity$[ebp], edx

; 4287 : 			cached_model = m_pRenderModel;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19108]
	mov	DWORD PTR _cached_model$[ebp], ecx
$L74221:

; 4289 : 
; 4290 : 		if( cached_material != mat )

	mov	edx, DWORD PTR _cached_material$[ebp]
	cmp	edx, DWORD PTR _mat$74214[ebp]
	je	$L74236

; 4292 : 			if( CVAR_TO_BOOL( r_lightmap ) && !CVAR_TO_BOOL( r_fullbright ))

	cmp	DWORD PTR ?r_lightmap@@3PAUcvar_s@@A, 0	; r_lightmap
	je	SHORT $L76652
	mov	eax, DWORD PTR ?r_lightmap@@3PAUcvar_s@@A ; r_lightmap
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76652
	mov	BYTE PTR -188+[ebp], 1
	jmp	SHORT $L76653
$L76652:
	mov	BYTE PTR -188+[ebp], 0
$L76653:
	mov	ecx, DWORD PTR -188+[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L74237
	cmp	DWORD PTR ?r_fullbright@@3PAUcvar_s@@A, 0 ; r_fullbright
	je	SHORT $L76654
	mov	edx, DWORD PTR ?r_fullbright@@3PAUcvar_s@@A ; r_fullbright
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76654
	mov	BYTE PTR -192+[ebp], 1
	jmp	SHORT $L76655
$L76654:
	mov	BYTE PTR -192+[ebp], 0
$L76655:
	mov	eax, DWORD PTR -192+[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74237

; 4293 : 				GL_Bind( GL_TEXTURE0, tr.whiteTexture );

	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+32
	push	ecx
	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+132
	add	esp, 8

; 4294 : 			else if( FBitSet( mat->flags, STUDIO_NF_COLORMAP ))

	jmp	SHORT $L74240
$L74237:
	mov	edx, DWORD PTR _mat$74214[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	SHORT $L74239

; 4295 : 				IEngineStudio.StudioSetupSkin( m_pStudioHeader, pskinref[pMesh->skinref] );

	mov	ecx, DWORD PTR _pMesh$74210[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pskinref$74211[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	push	eax
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+116
	add	esp, 8

; 4296 : 			else GL_Bind( GL_TEXTURE0, mat->gl_diffuse_id );

	jmp	SHORT $L74240
$L74239:
	mov	ecx, DWORD PTR _mat$74214[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+4]
	push	edx
	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+132
	add	esp, 8
$L74240:

; 4297 : 
; 4298 : 			if( mat->flags & STUDIO_NF_TWOSIDE )

	mov	eax, DWORD PTR _mat$74214[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	test	ecx, ecx
	je	SHORT $L74241

; 4299 : 				GL_Cull( GL_NONE );

	push	0
	call	?GL_Cull@@YAXI@Z			; GL_Cull
	add	esp, 4

; 4300 : 			else GL_Cull( GL_FRONT );

	jmp	SHORT $L74242
$L74241:
	push	1028					; 00000404H
	call	?GL_Cull@@YAXI@Z			; GL_Cull
	add	esp, 4
$L74242:

; 4301 : 
; 4302 : 			if( FBitSet( mat->flags, STUDIO_NF_MASKED|STUDIO_NF_HAS_ALPHA ))

	mov	edx, DWORD PTR _mat$74214[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 524352				; 00080040H
	test	eax, eax
	je	SHORT $L74243

; 4304 : 				pglAlphaFunc( GL_GREATER, 0.5f );

	push	1056964608				; 3f000000H
	push	516					; 00000204H
	call	DWORD PTR ?pglAlphaFunc@@3P6GXIM@ZA	; pglAlphaFunc

; 4305 : 				GL_AlphaTest( GL_TRUE );

	push	1
	call	?GL_AlphaTest@@YAXH@Z			; GL_AlphaTest
	add	esp, 4

; 4306 : 				GL_DepthMask( GL_TRUE );

	push	1
	call	?GL_DepthMask@@YAXH@Z			; GL_DepthMask
	add	esp, 4

; 4307 : 				GL_Blend( GL_FALSE );

	push	0
	call	?GL_Blend@@YAXH@Z			; GL_Blend
	add	esp, 4

; 4309 : 			else if( FBitSet( mat->flags, STUDIO_NF_ADDITIVE ))

	jmp	$L74248
$L74243:
	mov	ecx, DWORD PTR _mat$74214[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 32					; 00000020H
	test	edx, edx
	je	SHORT $L74245

; 4311 : 				if( R_ModelOpaque( RI->currententity->curstate.rendermode ))

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+760], 0
	jne	SHORT $L74246

; 4313 : 					pglBlendFunc( GL_SRC_ALPHA, GL_ONE );

	push	1
	push	770					; 00000302H
	call	DWORD PTR ?pglBlendFunc@@3P6GXII@ZA	; pglBlendFunc

; 4314 : 					GL_DepthMask( GL_FALSE );

	push	0
	call	?GL_DepthMask@@YAXH@Z			; GL_DepthMask
	add	esp, 4

; 4315 : 					GL_Blend( GL_TRUE );

	push	1
	call	?GL_Blend@@YAXH@Z			; GL_Blend
	add	esp, 4

; 4317 : 				else pglBlendFunc( GL_SRC_ALPHA, GL_ONE );

	jmp	SHORT $L74247
$L74246:
	push	1
	push	770					; 00000302H
	call	DWORD PTR ?pglBlendFunc@@3P6GXII@ZA	; pglBlendFunc
$L74247:

; 4319 : 			else

	jmp	SHORT $L74248
$L74245:

; 4321 : 				if( R_ModelOpaque( RI->currententity->curstate.rendermode ))

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+760], 0
	jne	SHORT $L74249

; 4323 : 					GL_DepthMask( GL_TRUE );

	push	1
	call	?GL_DepthMask@@YAXH@Z			; GL_DepthMask
	add	esp, 4

; 4324 : 					GL_Blend( GL_FALSE );

	push	0
	call	?GL_Blend@@YAXH@Z			; GL_Blend
	add	esp, 4
$L74249:

; 4326 : 				StudioSetRenderMode( m_pCurrentEntity->curstate.rendermode );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	mov	eax, DWORD PTR [edx+760]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+96]
$L74248:

; 4328 : 			cached_material = mat;

	mov	eax, DWORD PTR _mat$74214[ebp]
	mov	DWORD PTR _cached_material$[ebp], eax
$L74236:

; 4330 : 
; 4331 : 		r_stats.c_studio_polys += (pMesh->numElems / 3);

	mov	ecx, DWORD PTR _pMesh$74210[ebp]
	mov	eax, DWORD PTR [ecx+8]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR ?r_stats@@3Uref_stats_t@@A+4
	add	edx, eax
	mov	DWORD PTR ?r_stats@@3Uref_stats_t@@A+4, edx

; 4332 : 		DrawMeshFromBuffer( pMesh );

	mov	eax, DWORD PTR _pMesh$74210[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawMeshFromBuffer@CStudioModelRenderer@@AAEXPBUvbomesh_s@@@Z ; CStudioModelRenderer::DrawMeshFromBuffer

; 4333 : 	}

	jmp	$L74205
$L74206:

; 4334 : 
; 4335 : 	GL_SelectTexture( glConfig.max_texture_units - 1 ); // force to cleanup all the units

	mov	ecx, DWORD PTR ?glConfig@@3UglConfig_t@@A+40
	sub	ecx, 1
	push	ecx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+136
	add	esp, 4

; 4336 : 	GL_CleanUpTextureUnits( 0 );

	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+148
	add	esp, 4

; 4337 : 	GL_AlphaTest( GL_FALSE );

	push	0
	call	?GL_AlphaTest@@YAXH@Z			; GL_AlphaTest
	add	esp, 4

; 4338 : 	GL_Cull( GL_FRONT );

	push	1028					; 00000404H
	call	?GL_Cull@@YAXI@Z			; GL_Cull
	add	esp, 4

; 4339 : 
; 4340 : 	RenderDynLightList ();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+180]

; 4341 : 
; 4342 : 	pglBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, 0 );

	push	0
	push	34963					; 00008893H
	call	DWORD PTR ?pglBindBufferARB@@3P6GXII@ZA	; pglBindBufferARB

; 4343 : 	pglBindVertexArray( GL_FALSE );

	push	0
	call	DWORD PTR ?pglBindVertexArray@@3P6GXI@ZA ; pglBindVertexArray

; 4344 : 
; 4345 : 	DrawDecal( RI->currententity );

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawDecal@CStudioModelRenderer@@AAEXPAUcl_entity_s@@@Z ; CStudioModelRenderer::DrawDecal

; 4346 : 	m_nNumDrawMeshes = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5365480], 0
$L74191:

; 4347 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawStudioMeshes@CStudioModelRenderer@@EAEXXZ ENDP	; CStudioModelRenderer::DrawStudioMeshes
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DrawStudioMeshesShadow@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::DrawStudioMeshesShadow'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??DrawStudioMeshesShadow@CStudioModelRenderer@@EAEXXZ@4FA
; File z:\xashxtsrc\client\render\r_studio.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DrawStudioMeshesShadow@CStudioModelRenderer@@EAEXXZ@4FA DW 010feH ; `CStudioModelRenderer::DrawStudioMeshesShadow'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?DrawStudioMeshesShadow@CStudioModelRenderer@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
_cached_material$ = -8
_cached_model$ = -12
_i$ = -16
_entry$74264 = -20
_m_skinnum$74266 = -24
_bone_weighting$74267 = -28
_pMesh$74268 = -32
_pskinref$74269 = -36
_mat$74272 = -40
_num_bones$74279 = -44
$T76658 = -108
?DrawStudioMeshesShadow@CStudioModelRenderer@@EAEXXZ PROC NEAR ; CStudioModelRenderer::DrawStudioMeshesShadow, COMDAT

; 4350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4351 : 	mstudiomaterial_t	*cached_material = NULL;

	mov	DWORD PTR _cached_material$[ebp], 0

; 4352 : 	model_t		*cached_model = NULL;

	mov	DWORD PTR _cached_model$[ebp], 0

; 4353 : 	int		i;
; 4354 : 
; 4355 : 	if( !m_nNumDrawMeshes )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+5365480], 0
	jne	SHORT $L74257

; 4356 : 		return;

	jmp	$L74253
$L74257:

; 4357 : 
; 4358 : 	if( m_pCurrentEntity->modelhandle == INVALID_HANDLE )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19104]
	cmp	DWORD PTR [edx+2960], 65535		; 0000ffffH
	jne	SHORT $L74258

; 4359 : 		return; // out of memory ?

	jmp	$L74253
$L74258:

; 4360 : 
; 4361 : 	m_pModelInstance = &m_ModelInstances[m_pCurrentEntity->modelhandle];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	mov	dx, WORD PTR [ecx+2960]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19112], eax

; 4362 : 
; 4363 : 	R_TransformForEntity( m_pModelInstance->m_protationmatrix );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19112]
	add	eax, 11452				; 00002cbcH
	push	eax
	lea	ecx, DWORD PTR $T76658[ebp]
	call	??0matrix4x4@@QAE@ABVmatrix3x4@@@Z	; matrix4x4::matrix4x4
	lea	ecx, DWORD PTR $T76658[ebp]
	push	ecx
	call	?R_TransformForEntity@@YAXABVmatrix4x4@@@Z ; R_TransformForEntity
	add	esp, 4

; 4364 : //	R_LoadIdentity();
; 4365 : 	GL_Blend( GL_FALSE );

	push	0
	call	?GL_Blend@@YAXH@Z			; GL_Blend
	add	esp, 4

; 4366 : 	GL_AlphaTest( GL_FALSE );

	push	0
	call	?GL_AlphaTest@@YAXH@Z			; GL_AlphaTest
	add	esp, 4

; 4367 : 	GL_DepthMask( GL_TRUE );

	push	1
	call	?GL_DepthMask@@YAXH@Z			; GL_DepthMask
	add	esp, 4

; 4368 : 
; 4369 : 	// sorting list to reduce shader switches
; 4370 : 	if( !CVAR_TO_BOOL( r_nosort )) QSortStudioMeshes( m_DrawMeshes, 0, m_nNumDrawMeshes - 1 );

	cmp	DWORD PTR ?r_nosort@@3PAUcvar_s@@A, 0	; r_nosort
	je	SHORT $L76659
	mov	edx, DWORD PTR ?r_nosort@@3PAUcvar_s@@A	; r_nosort
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76659
	mov	BYTE PTR -112+[ebp], 1
	jmp	SHORT $L76660
$L76659:
	mov	BYTE PTR -112+[ebp], 0
$L76660:
	mov	eax, DWORD PTR -112+[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74260
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5365480]
	sub	edx, 1
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5345000				; 00518ee8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?QSortStudioMeshes@CStudioModelRenderer@@AAEXPAUgl_studiomesh_t@@HH@Z ; CStudioModelRenderer::QSortStudioMeshes
$L74260:

; 4371 : 
; 4372 : 	// sorting list to reduce shader switches
; 4373 : 	for( i = 0; i < m_nNumDrawMeshes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74261
$L74262:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L74261:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+5365480]
	jge	$L74263

; 4375 : 		gl_studiomesh_t *entry = &m_DrawMeshes[i];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+5345000]
	mov	DWORD PTR _entry$74264[ebp], eax

; 4376 : 		RI->currentmodel = m_pRenderModel = entry->model;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _entry$74264[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+19108], eax
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	mov	DWORD PTR [ecx+20], eax

; 4377 : 		m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata( m_pRenderModel );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	push	edx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+19124], eax

; 4378 : 		int m_skinnum = bound( 0, m_pCurrentEntity->curstate.skin, m_pStudioHeader->numskinfamilies - 1 );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	movsx	ecx, WORD PTR [eax+744]
	test	ecx, ecx
	jl	SHORT $L76663
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	movsx	ecx, WORD PTR [eax+744]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	edx, DWORD PTR [eax+196]
	sub	edx, 1
	cmp	ecx, edx
	jge	SHORT $L76661
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	movsx	edx, WORD PTR [ecx+744]
	mov	DWORD PTR -116+[ebp], edx
	jmp	SHORT $L76662
$L76661:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR [ecx+196]
	sub	edx, 1
	mov	DWORD PTR -116+[ebp], edx
$L76662:
	mov	eax, DWORD PTR -116+[ebp]
	mov	DWORD PTR -120+[ebp], eax
	jmp	SHORT $L76664
$L76663:
	mov	DWORD PTR -120+[ebp], 0
$L76664:
	mov	ecx, DWORD PTR -120+[ebp]
	mov	DWORD PTR _m_skinnum$74266[ebp], ecx

; 4379 : 		bool bone_weighting = (m_pRenderModel->poseToBone != NULL) ? true : false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	cmp	DWORD PTR [eax+376], 0
	setne	cl
	mov	BYTE PTR _bone_weighting$74267[ebp], cl

; 4380 : 		vbomesh_t *pMesh = entry->mesh;

	mov	edx, DWORD PTR _entry$74264[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pMesh$74268[ebp], eax

; 4381 : 
; 4382 : 		short *pskinref = (short *)((byte *)m_pStudioHeader + m_pStudioHeader->skinindex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	add	ecx, DWORD PTR [edx+200]
	mov	DWORD PTR _pskinref$74269[ebp], ecx

; 4383 : 		pskinref += (m_skinnum * m_pStudioHeader->numskinref);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19124]
	mov	ecx, DWORD PTR _m_skinnum$74266[ebp]
	imul	ecx, DWORD PTR [eax+192]
	mov	edx, DWORD PTR _pskinref$74269[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pskinref$74269[ebp], eax

; 4384 : 
; 4385 : 		mstudiomaterial_t *mat = &m_pRenderModel->materials[pskinref[pMesh->skinref]];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+19108]
	mov	eax, DWORD PTR _pMesh$74268[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _pskinref$74269[ebp]
	movsx	ecx, WORD PTR [eax+ecx*2]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR [edx+384]
	add	edx, ecx
	mov	DWORD PTR _mat$74272[ebp], edx

; 4386 : 
; 4387 : 		ASSERT( m_pCurrentEntity->modelhandle != INVALID_HANDLE );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19104]
	cmp	DWORD PTR [ecx+2960], 65535		; 0000ffffH
	jne	SHORT $L74274
	movsx	edx, WORD PTR ?__LINE__Var@?1??DrawStudioMeshesShadow@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::DrawStudioMeshesShadow'::`2'::__LINE__Var
	add	edx, 37					; 00000025H
	push	edx
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L74274:

; 4388 : 
; 4389 : 		// begin draw the sorted list
; 4390 : 		if(( i == 0 ) || ( RI->currentshader != &glsl_programs[entry->hProgram] ))

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $L74276
	mov	eax, DWORD PTR _entry$74264[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+4]
	imul	ecx, 876				; 0000036cH
	add	ecx, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [edx+28], ecx
	je	SHORT $L74275
$L74276:

; 4392 : 			GL_BindShader( &glsl_programs[entry->hProgram] );			

	mov	eax, DWORD PTR _entry$74264[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+4]
	imul	ecx, 876				; 0000036cH
	add	ecx, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	push	ecx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 4393 : 
; 4394 : 			ASSERT( RI->currentshader != NULL );

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $L74277
	movsx	eax, WORD PTR ?__LINE__Var@?1??DrawStudioMeshesShadow@CStudioModelRenderer@@EAEXXZ@4FA ; `CStudioModelRenderer::DrawStudioMeshesShadow'::`2'::__LINE__Var
	add	eax, 44					; 0000002cH
	push	eax
	push	OFFSET FLAT:??_C@_0CI@DLJC@z?3?2xashxtsrc?2client?2render?2r_stu@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L74277:

; 4395 : 
; 4396 : 			// reset cache
; 4397 : 			cached_material = NULL;

	mov	DWORD PTR _cached_material$[ebp], 0

; 4398 : 			cached_model = NULL;

	mov	DWORD PTR _cached_model$[ebp], 0
$L74275:

; 4400 : 
; 4401 : 		if( cached_model != m_pRenderModel )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _cached_model$[ebp]
	cmp	edx, DWORD PTR [ecx+19108]
	je	$L74278

; 4403 : 			// update bones array
; 4404 : 			int num_bones = Q_min( m_pStudioHeader->numbones, glConfig.max_skinning_bones );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR [ecx+140]
	cmp	edx, DWORD PTR ?glConfig@@3UglConfig_t@@A+72
	jge	SHORT $L76665
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19124]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR -124+[ebp], edx
	jmp	SHORT $L76666
$L76665:
	mov	eax, DWORD PTR ?glConfig@@3UglConfig_t@@A+72
	mov	DWORD PTR -124+[ebp], eax
$L76666:
	mov	ecx, DWORD PTR -124+[ebp]
	mov	DWORD PTR _num_bones$74279[ebp], ecx

; 4405 : 
; 4406 : 			if( m_pRenderModel == IEngineStudio.GetModelByIndex( m_pCurrentEntity->curstate.weaponmodel ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19104]
	mov	ecx, DWORD PTR [eax+868]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+20
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+19108], eax
	jne	SHORT $L74280

; 4408 : 				pglUniform4fvARB( RI->currentshader->u_BoneQuaternion, num_bones, &m_pModelInstance->m_weaponquat[0][0] );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 30500				; 00007724H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	push	eax
	mov	ecx, DWORD PTR _num_bones$74279[ebp]
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+652]
	push	ecx
	call	DWORD PTR ?pglUniform4fvARB@@3P6GXHHPBM@ZA ; pglUniform4fvARB

; 4409 : 				pglUniform3fvARB( RI->currentshader->u_BonePosition, num_bones, &m_pModelInstance->m_weaponpos[0][0] );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+19112]
	add	ecx, 32548				; 00007f24H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	eax, DWORD PTR _num_bones$74279[ebp]
	push	eax
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+656]
	push	eax
	call	DWORD PTR ?pglUniform3fvARB@@3P6GXHHPBM@ZA ; pglUniform3fvARB

; 4411 : 			else

	jmp	SHORT $L74281
$L74280:

; 4413 : 				pglUniform4fvARB( RI->currentshader->u_BoneQuaternion, num_bones, &m_pModelInstance->m_studioquat[0][0] );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+19112]
	add	ecx, 26916				; 00006924H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	push	eax
	mov	edx, DWORD PTR _num_bones$74279[ebp]
	push	edx
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+652]
	push	edx
	call	DWORD PTR ?pglUniform4fvARB@@3P6GXHHPBM@ZA ; pglUniform4fvARB

; 4414 : 				pglUniform3fvARB( RI->currentshader->u_BonePosition, num_bones, &m_pModelInstance->m_studiopos[0][0] );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+19112]
	add	ecx, 28964				; 00007124H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _num_bones$74279[ebp]
	push	ecx
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+656]
	push	ecx
	call	DWORD PTR ?pglUniform3fvARB@@3P6GXHHPBM@ZA ; pglUniform3fvARB
$L74281:

; 4416 : 			cached_model = m_pRenderModel;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+19108]
	mov	DWORD PTR _cached_model$[ebp], eax
$L74278:

; 4418 : 
; 4419 : 		if( cached_material != mat )

	mov	ecx, DWORD PTR _cached_material$[ebp]
	cmp	ecx, DWORD PTR _mat$74272[ebp]
	je	$L74282

; 4421 : 			if( FBitSet( mat->flags, STUDIO_NF_MASKED ))

	mov	edx, DWORD PTR _mat$74272[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $L74283

; 4422 : 				GL_Bind( GL_TEXTURE0, mat->gl_diffuse_id );

	mov	ecx, DWORD PTR _mat$74272[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+4]
	push	edx
	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+132
	add	esp, 8

; 4423 : 			else GL_Bind( GL_TEXTURE0, tr.whiteTexture );

	jmp	SHORT $L74284
$L74283:
	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+32
	push	eax
	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+132
	add	esp, 8
$L74284:

; 4424 : 
; 4425 : 			if( mat->flags & STUDIO_NF_TWOSIDE )

	mov	ecx, DWORD PTR _mat$74272[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 4096				; 00001000H
	test	edx, edx
	je	SHORT $L74285

; 4426 : 				GL_Cull( GL_NONE );

	push	0
	call	?GL_Cull@@YAXI@Z			; GL_Cull
	add	esp, 4

; 4427 : 			else GL_Cull( GL_FRONT );

	jmp	SHORT $L74286
$L74285:
	push	1028					; 00000404H
	call	?GL_Cull@@YAXI@Z			; GL_Cull
	add	esp, 4
$L74286:

; 4428 : 
; 4429 : 			if( FBitSet( mat->flags, STUDIO_NF_MASKED|STUDIO_NF_HAS_ALPHA ))

	mov	eax, DWORD PTR _mat$74272[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 524352				; 00080040H
	test	ecx, ecx
	je	SHORT $L74287

; 4431 : 				pglAlphaFunc( GL_GREATER, 0.5f );

	push	1056964608				; 3f000000H
	push	516					; 00000204H
	call	DWORD PTR ?pglAlphaFunc@@3P6GXIM@ZA	; pglAlphaFunc

; 4432 : 				GL_AlphaTest( GL_TRUE );

	push	1
	call	?GL_AlphaTest@@YAXH@Z			; GL_AlphaTest
	add	esp, 4

; 4434 : 			else

	jmp	SHORT $L74288
$L74287:

; 4436 : 				GL_AlphaTest( GL_FALSE );

	push	0
	call	?GL_AlphaTest@@YAXH@Z			; GL_AlphaTest
	add	esp, 4
$L74288:

; 4438 : 
; 4439 : 			cached_material = mat;

	mov	edx, DWORD PTR _mat$74272[ebp]
	mov	DWORD PTR _cached_material$[ebp], edx
$L74282:

; 4441 : 
; 4442 : 		DrawMeshFromBuffer( pMesh );

	mov	eax, DWORD PTR _pMesh$74268[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawMeshFromBuffer@CStudioModelRenderer@@AAEXPBUvbomesh_s@@@Z ; CStudioModelRenderer::DrawMeshFromBuffer

; 4443 : 	}

	jmp	$L74262
$L74263:

; 4444 : 
; 4445 : 	GL_SelectTexture( glConfig.max_texture_units - 1 ); // force to cleanup all the units

	mov	ecx, DWORD PTR ?glConfig@@3UglConfig_t@@A+40
	sub	ecx, 1
	push	ecx
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+136
	add	esp, 4

; 4446 : 	GL_CleanUpTextureUnits( 0 );

	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+148
	add	esp, 4

; 4447 : 	GL_AlphaTest( GL_FALSE );

	push	0
	call	?GL_AlphaTest@@YAXH@Z			; GL_AlphaTest
	add	esp, 4

; 4448 : 	GL_Cull( GL_FRONT );

	push	1028					; 00000404H
	call	?GL_Cull@@YAXI@Z			; GL_Cull
	add	esp, 4

; 4449 : 
; 4450 : 	pglBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, 0 );

	push	0
	push	34963					; 00008893H
	call	DWORD PTR ?pglBindBufferARB@@3P6GXII@ZA	; pglBindBufferARB

; 4451 : 	pglBindVertexArray( GL_FALSE );

	push	0
	call	DWORD PTR ?pglBindVertexArray@@3P6GXI@ZA ; pglBindVertexArray

; 4452 : 	m_nNumDrawMeshes = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+5365480], 0
$L74253:

; 4453 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawStudioMeshesShadow@CStudioModelRenderer@@EAEXXZ ENDP ; CStudioModelRenderer::DrawStudioMeshesShadow
_TEXT	ENDS
PUBLIC	?RunViewModelEvents@CStudioModelRenderer@@QAEXXZ ; CStudioModelRenderer::RunViewModelEvents
EXTRN	?CL_IsDead@@YAHXZ:NEAR				; CL_IsDead
;	COMDAT ?RunViewModelEvents@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RunViewModelEvents@CStudioModelRenderer@@QAEXXZ PROC NEAR ; CStudioModelRenderer::RunViewModelEvents, COMDAT

; 4462 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4463 : 	if( !CVAR_TO_BOOL( m_pCvarDrawViewModel ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $L76669
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76669
	mov	BYTE PTR -8+[ebp], 1
	jmp	SHORT $L76670
$L76669:
	mov	BYTE PTR -8+[ebp], 0
$L76670:
	mov	eax, DWORD PTR -8+[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74293

; 4464 : 		return;

	jmp	$L74292
$L74293:

; 4465 : 
; 4466 : 	// ignore in thirdperson, camera view or client is died
; 4467 : 	if( FBitSet( RI->params, RP_THIRDPERSON ) || CL_IsDead() || !UTIL_IsLocal( RI->viewentity ))

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx]
	and	edx, 8192				; 00002000H
	test	edx, edx
	jne	SHORT $L74295
	call	?CL_IsDead@@YAHXZ			; CL_IsDead
	test	eax, eax
	jne	SHORT $L74295
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UTIL_IsLocal@@YA_NH@Z			; UTIL_IsLocal
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74294
$L74295:

; 4468 : 		return;

	jmp	$L74292
$L74294:

; 4469 : 
; 4470 : 	if( RI->params & RP_NONVIEWERREF )

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx]
	and	eax, 483				; 000001e3H
	test	eax, eax
	je	SHORT $L74296

; 4471 : 		return;

	jmp	$L74292
$L74296:

; 4472 : 
; 4473 : 	RI->currententity = GET_VIEWMODEL();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+208
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	DWORD PTR [ecx+16], eax

; 4474 : 	RI->currentmodel = RI->currententity->model;

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [eax+2964]
	mov	DWORD PTR [ecx+20], edx

; 4475 : 	if( !RI->currentmodel ) return;

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $L74297
	jmp	SHORT $L74292
$L74297:

; 4476 : 
; 4477 : 	m_fDrawViewModel = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+93], 1

; 4478 : 
; 4479 : 	SET_CURRENT_ENTITY( RI->currententity );

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+32
	add	esp, 4

; 4480 : 	StudioDrawModel( STUDIO_EVENTS );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]

; 4481 : 
; 4482 : 	SET_CURRENT_ENTITY( NULL );

	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+32
	add	esp, 4

; 4483 : 	m_fDrawViewModel = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+93], 0

; 4484 : 	RI->currententity = NULL;

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	DWORD PTR [ecx+16], 0

; 4485 : 	RI->currentmodel = NULL;

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	DWORD PTR [edx+20], 0
$L74292:

; 4486 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RunViewModelEvents@CStudioModelRenderer@@QAEXXZ ENDP	; CStudioModelRenderer::RunViewModelEvents
_TEXT	ENDS
PUBLIC	?DrawViewModel@CStudioModelRenderer@@QAEXXZ	; CStudioModelRenderer::DrawViewModel
PUBLIC	__real@4@3ffd99999a0000000000
PUBLIC	__real@4@4004c800000000000000
PUBLIC	__real@4@40068200000000000000
PUBLIC	__real@4@4007b400000000000000
EXTRN	?R_SetupProjectionMatrix@@YAXMMAAVmatrix4x4@@@Z:NEAR ; R_SetupProjectionMatrix
EXTRN	?CL_FxBlend@@YAHPAUcl_entity_s@@@Z:NEAR		; CL_FxBlend
EXTRN	?gHUD@@3VCHud@@A:BYTE				; gHUD
EXTRN	?pglDepthRange@@3P6GXNN@ZA:DWORD		; pglDepthRange
EXTRN	_atan:NEAR
EXTRN	??4matrix4x4@@QAEAAV0@ABV0@@Z:NEAR		; matrix4x4::operator=
EXTRN	?pglMatrixMode@@3P6GXI@ZA:DWORD			; pglMatrixMode
EXTRN	?gldepthmin@@3MA:DWORD				; gldepthmin
EXTRN	?gldepthmax@@3MA:DWORD				; gldepthmax
EXTRN	?glState@@3UglState_t@@A:BYTE			; glState
EXTRN	?GL_LoadMatrix@@YAXVmatrix4x4@@@Z:NEAR		; GL_LoadMatrix
EXTRN	?GL_FrontFace@@YAXI@Z:NEAR			; GL_FrontFace
;	COMDAT __real@4@3ffd99999a0000000000
; File z:\xashxtsrc\client\render\r_studio.cpp
CONST	SEGMENT
__real@4@3ffd99999a0000000000 DD 03e99999ar	; 0.3
CONST	ENDS
;	COMDAT __real@4@4004c800000000000000
CONST	SEGMENT
__real@4@4004c800000000000000 DD 042480000r	; 50
CONST	ENDS
;	COMDAT __real@4@40068200000000000000
CONST	SEGMENT
__real@4@40068200000000000000 DD 043020000r	; 130
CONST	ENDS
;	COMDAT __real@4@4007b400000000000000
CONST	SEGMENT
__real@4@4007b400000000000000 DD 043b40000r	; 360
CONST	ENDS
;	COMDAT ?DrawViewModel@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_flFOVOffset$ = -8
_x$ = -12
_fov_x$ = -16
_fov_y$ = -20
_oldProjectionMatrix$74321 = -84
?DrawViewModel@CStudioModelRenderer@@QAEXXZ PROC NEAR	; CStudioModelRenderer::DrawViewModel, COMDAT

; 4495 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4496 : 	if( !CVAR_TO_BOOL( m_pCvarDrawViewModel ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $L76673
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76673
	mov	BYTE PTR -96+[ebp], 1
	jmp	SHORT $L76674
$L76673:
	mov	BYTE PTR -96+[ebp], 0
$L76674:
	mov	eax, DWORD PTR -96+[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74302

; 4497 : 		return;

	jmp	$L74301
$L74302:

; 4498 : 
; 4499 : 	// ignore in thirdperson, camera view or client is died
; 4500 : 	if( FBitSet( RI->params, RP_THIRDPERSON ) || CL_IsDead() || !UTIL_IsLocal( RI->viewentity ))

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx]
	and	edx, 8192				; 00002000H
	test	edx, edx
	jne	SHORT $L74304
	call	?CL_IsDead@@YAHXZ			; CL_IsDead
	test	eax, eax
	jne	SHORT $L74304
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UTIL_IsLocal@@YA_NH@Z			; UTIL_IsLocal
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74303
$L74304:

; 4501 : 		return;

	jmp	$L74301
$L74303:

; 4502 : 
; 4503 : 	if( RI->params & RP_NONVIEWERREF )

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx]
	and	eax, 483				; 000001e3H
	test	eax, eax
	je	SHORT $L74305

; 4504 : 		return;

	jmp	$L74301
$L74305:

; 4505 : 
; 4506 : 	if( !IEngineStudio.Mod_Extradata( GET_VIEWMODEL()->model ))

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+208
	mov	ecx, DWORD PTR [eax+2964]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	test	eax, eax
	jne	SHORT $L74306

; 4507 : 		return;

	jmp	$L74301
$L74306:

; 4508 : 
; 4509 : 	RI->currententity = GET_VIEWMODEL();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+208
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	DWORD PTR [edx+16], eax

; 4510 : 	RI->currentmodel = RI->currententity->model;

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [ecx+2964]
	mov	DWORD PTR [edx+20], eax

; 4511 : 	if( !RI->currentmodel ) return;

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $L74307
	jmp	$L74301
$L74307:

; 4512 : 
; 4513 : 	SET_CURRENT_ENTITY( RI->currententity );

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+32
	add	esp, 4

; 4514 : 
; 4515 : 	tr.blend = CL_FxBlend( RI->currententity ) / 255.0f;

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	?CL_FxBlend@@YAHPAUcl_entity_s@@@Z	; CL_FxBlend
	add	esp, 4
	mov	DWORD PTR -100+[ebp], eax
	fild	DWORD PTR -100+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR ?tr@@3Uref_globals_t@@A+1411976

; 4516 : 	if( !R_ModelOpaque( RI->currententity->curstate.rendermode ) && tr.blend <= 0.0f )

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+760], 0
	je	SHORT $L74308
	fld	DWORD PTR ?tr@@3Uref_globals_t@@A+1411976
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L74308

; 4517 : 		return; // invisible ?

	jmp	$L74301
$L74308:

; 4518 : 
; 4519 : 	// hack the depth range to prevent view model from poking into walls
; 4520 : 	pglDepthRange( gldepthmin, gldepthmin + 0.3f * ( gldepthmax - gldepthmin ));

	fld	DWORD PTR ?gldepthmax@@3MA		; gldepthmax
	fsub	DWORD PTR ?gldepthmin@@3MA		; gldepthmin
	fmul	DWORD PTR __real@4@3ffd99999a0000000000
	fadd	DWORD PTR ?gldepthmin@@3MA		; gldepthmin
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR ?gldepthmin@@3MA		; gldepthmin
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR ?pglDepthRange@@3P6GXNN@ZA	; pglDepthRange

; 4521 : 
; 4522 : 	// backface culling for left-handed weapons
; 4523 : 	if( CVAR_TO_BOOL( m_pCvarHand ))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+108], 0
	je	SHORT $L76675
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76675
	mov	BYTE PTR -104+[ebp], 1
	jmp	SHORT $L76676
$L76675:
	mov	BYTE PTR -104+[ebp], 0
$L76676:
	mov	edx, DWORD PTR -104+[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L74309

; 4524 : 		GL_FrontFace( !glState.frontFace );

	xor	eax, eax
	cmp	DWORD PTR ?glState@@3UglState_t@@A+20, 0
	sete	al
	push	eax
	call	?GL_FrontFace@@YAXI@Z			; GL_FrontFace
	add	esp, 4
$L74309:

; 4525 : 
; 4526 : 	m_fDrawViewModel = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+93], 1

; 4527 : 
; 4528 : 	// bound FOV values
; 4529 : 	if( m_pCvarViewmodelFov->value < 50 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@4004c800000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L74310

; 4530 : 		gEngfuncs.Cvar_SetValue( "cl_viewmodel_fov", 50 );

	push	1112014848				; 42480000H
	push	OFFSET FLAT:??_C@_0BB@LDK@cl_viewmodel_fov?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+148
	add	esp, 8

; 4531 : 	else if( m_pCvarViewmodelFov->value > 130 )

	jmp	SHORT $L74312
$L74310:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@40068200000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L74312

; 4532 : 		gEngfuncs.Cvar_SetValue( "cl_viewmodel_fov", 120 );

	push	1123024896				; 42f00000H
	push	OFFSET FLAT:??_C@_0BB@LDK@cl_viewmodel_fov?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+148
	add	esp, 8
$L74312:

; 4533 : 
; 4534 : 	// Find the offset our current FOV is from the default value
; 4535 : 	float flFOVOffset = gHUD.default_fov->value - (float)RI->fov_x;

	mov	eax, DWORD PTR ?gHUD@@3VCHud@@A+96
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _flFOVOffset$[ebp]

; 4536 : 
; 4537 : 	// Adjust the viewmodel's FOV to move with any FOV offsets on the viewer's end
; 4538 : 	m_flViewmodelFov = m_pCvarViewmodelFov->value - flFOVOffset;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR _flFOVOffset$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+96]

; 4539 : 
; 4540 : 	// calc local FOV
; 4541 : 	float x = (float)ScreenWidth / tan( m_flViewmodelFov / 360 * M_PI );

	fild	DWORD PTR ?gHUD@@3VCHud@@A+3268
	fstp	QWORD PTR -112+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+96]
	fdiv	DWORD PTR __real@4@4007b400000000000000
	fmul	QWORD PTR __real@8@4000c90fdaa22168c000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_tan
	add	esp, 8
	fdivr	QWORD PTR -112+[ebp]
	fstp	DWORD PTR _x$[ebp]

; 4542 : 
; 4543 : 	float fov_x = m_flViewmodelFov;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _fov_x$[ebp], ecx

; 4544 : 	float fov_y = atan( (float)ScreenHeight / x ) * 360 / M_PI;

	fild	DWORD PTR ?gHUD@@3VCHud@@A+3272
	fdiv	DWORD PTR _x$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan
	add	esp, 8
	fmul	QWORD PTR __real@8@4007b400000000000000
	fdiv	QWORD PTR __real@8@4000c90fdaa22168c000
	fstp	DWORD PTR _fov_y$[ebp]

; 4545 : 
; 4546 : 	if( fov_x != RI->fov_x )

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	fld	DWORD PTR _fov_x$[ebp]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L74320

; 4548 : 		matrix4x4	oldProjectionMatrix = RI->projectionMatrix;

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	eax, 544				; 00000220H
	push	eax
	lea	ecx, DWORD PTR _oldProjectionMatrix$74321[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 4549 : 		R_SetupProjectionMatrix( fov_x, fov_y, RI->projectionMatrix );

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	ecx, 544				; 00000220H
	push	ecx
	mov	edx, DWORD PTR _fov_y$[ebp]
	push	edx
	mov	eax, DWORD PTR _fov_x$[ebp]
	push	eax
	call	?R_SetupProjectionMatrix@@YAXMMAAVmatrix4x4@@@Z ; R_SetupProjectionMatrix
	add	esp, 12					; 0000000cH

; 4550 : 
; 4551 : 		pglMatrixMode( GL_PROJECTION );

	push	5889					; 00001701H
	call	DWORD PTR ?pglMatrixMode@@3P6GXI@ZA	; pglMatrixMode

; 4552 : 		GL_LoadMatrix( RI->projectionMatrix );

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	ecx, 544				; 00000220H
	sub	esp, 64					; 00000040H
	mov	edx, esp
	push	ecx
	mov	ecx, edx
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	call	?GL_LoadMatrix@@YAXVmatrix4x4@@@Z	; GL_LoadMatrix
	add	esp, 64					; 00000040H

; 4553 : 
; 4554 : 		StudioDrawModel( STUDIO_RENDER );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]

; 4555 : 
; 4556 : 		// restore original matrix
; 4557 : 		RI->projectionMatrix = oldProjectionMatrix;

	lea	eax, DWORD PTR _oldProjectionMatrix$74321[ebp]
	push	eax
	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	ecx, 544				; 00000220H
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 4558 : 
; 4559 : 		pglMatrixMode( GL_PROJECTION );

	push	5889					; 00001701H
	call	DWORD PTR ?pglMatrixMode@@3P6GXI@ZA	; pglMatrixMode

; 4560 : 		GL_LoadMatrix( RI->projectionMatrix );

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	add	ecx, 544				; 00000220H
	sub	esp, 64					; 00000040H
	mov	edx, esp
	push	ecx
	mov	ecx, edx
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	call	?GL_LoadMatrix@@YAXVmatrix4x4@@@Z	; GL_LoadMatrix
	add	esp, 64					; 00000040H

; 4562 : 	else

	jmp	SHORT $L74324
$L74320:

; 4564 : 		StudioDrawModel( STUDIO_RENDER );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]
$L74324:

; 4566 : 
; 4567 : 	// restore depth range
; 4568 : 	pglDepthRange( gldepthmin, gldepthmax );

	fld	DWORD PTR ?gldepthmax@@3MA		; gldepthmax
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR ?gldepthmin@@3MA		; gldepthmin
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR ?pglDepthRange@@3P6GXNN@ZA	; pglDepthRange

; 4569 : 
; 4570 : 	// backface culling for left-handed weapons
; 4571 : 	if( CVAR_TO_BOOL( m_pCvarHand ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+108], 0
	je	SHORT $L76679
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L76679
	mov	BYTE PTR -116+[ebp], 1
	jmp	SHORT $L76680
$L76679:
	mov	BYTE PTR -116+[ebp], 0
$L76680:
	mov	eax, DWORD PTR -116+[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74325

; 4572 : 		GL_FrontFace( !glState.frontFace );

	xor	ecx, ecx
	cmp	DWORD PTR ?glState@@3UglState_t@@A+20, 0
	sete	cl
	push	ecx
	call	?GL_FrontFace@@YAXI@Z			; GL_FrontFace
	add	esp, 4
$L74325:

; 4573 : 
; 4574 : 	SET_CURRENT_ENTITY( NULL );

	push	0
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+32
	add	esp, 4

; 4575 : 	m_fDrawViewModel = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+93], 0

; 4576 : 	RI->currententity = NULL;

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	DWORD PTR [eax+16], 0

; 4577 : 	RI->currentmodel = NULL;

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	DWORD PTR [ecx+20], 0
$L74301:

; 4578 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawViewModel@CStudioModelRenderer@@QAEXXZ ENDP	; CStudioModelRenderer::DrawViewModel
_TEXT	ENDS
PUBLIC	?ClearLightCache@CStudioModelRenderer@@QAEXXZ	; CStudioModelRenderer::ClearLightCache
;	COMDAT ?ClearLightCache@CStudioModelRenderer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
_inst$74334 = -12
?ClearLightCache@CStudioModelRenderer@@QAEXXZ PROC NEAR	; CStudioModelRenderer::ClearLightCache, COMDAT

; 4581 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4582 : 	// force to recalc static light again
; 4583 : 	for( int i = m_ModelInstances.Count(); --i >= 0; )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Count
	mov	DWORD PTR _i$[ebp], eax
$L74332:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L74333

; 4585 : 		ModelInstance_t *inst = &m_ModelInstances[i];

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
	mov	DWORD PTR _inst$74334[ebp], eax

; 4586 : 	}

	jmp	SHORT $L74332
$L74333:

; 4587 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearLightCache@CStudioModelRenderer@@QAEXXZ ENDP	; CStudioModelRenderer::ClearLightCache
_TEXT	ENDS
PUBLIC	?ConstructList@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ ; CUtlLinkedList<JiggleData,unsigned short>::ConstructList
PUBLIC	?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ ; CUtlLinkedList<JiggleData,unsigned short>::ResetDbgInfo
PUBLIC	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>
PUBLIC	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_this$ = -16
__$EHRec$ = -12
??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z PROC NEAR	; CUtlLinkedList<JiggleData,unsigned short>::CUtlLinkedList<JiggleData,unsigned short>, COMDAT

; 166  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 167  : 	ConstructList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConstructList@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ ; CUtlLinkedList<JiggleData,unsigned short>::ConstructList

; 168  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ ; CUtlLinkedList<JiggleData,unsigned short>::ResetDbgInfo

; 169  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z ENDP	; CUtlLinkedList<JiggleData,unsigned short>::CUtlLinkedList<JiggleData,unsigned short>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ PROC NEAR	; CUtlLinkedList<JiggleData,unsigned short>::~CUtlLinkedList<JiggleData,unsigned short>, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 182  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlLinkedList@UJiggleData@@G@@QAEXXZ ; CUtlLinkedList<JiggleData,unsigned short>::RemoveAll

; 183  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ ENDP		; CUtlLinkedList<JiggleData,unsigned short>::~CUtlLinkedList<JiggleData,unsigned short>
PUBLIC	?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::Element
PUBLIC	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
PUBLIC	?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ; CUtlLinkedList<JiggleData,unsigned short>::IsValidIndex
PUBLIC	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
PUBLIC	?Destruct@@YAXPAUJiggleData@@@Z			; Destruct
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UJiggleData@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_prev$ = -8
_i$ = -12
?RemoveAll@?$CUtlLinkedList@UJiggleData@@G@@QAEXXZ PROC NEAR ; CUtlLinkedList<JiggleData,unsigned short>::RemoveAll, COMDAT

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 524  : 	if (m_TotalElements == 0)

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $L74346

; 525  : 		return;

	jmp	$L74345
$L74346:

; 526  : 
; 527  : 	// Put everything into the free list
; 528  : 	I prev = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	mov	WORD PTR _prev$[ebp], ax

; 529  : 	for (int i = (int)m_TotalElements; --i >= 0; )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	DWORD PTR _i$[ebp], eax
$L74351:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L74352

; 531  : 		// Invoke the destructor
; 532  : 		if (IsValidIndex((I)i))

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ; CUtlLinkedList<JiggleData,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74354

; 533  : 			Destruct( &Element((I)i) );

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::Element
	push	eax
	call	?Destruct@@YAXPAUJiggleData@@@Z		; Destruct
	add	esp, 4
$L74354:

; 534  : 		
; 535  : 		// next points to the next free list item
; 536  : 		InternalElement((I)i).m_Next = prev;

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
	mov	dx, WORD PTR _prev$[ebp]
	mov	WORD PTR [eax+150], dx

; 537  : 		
; 538  : 		// Indicates it's in the free list
; 539  : 		InternalElement((I)i).m_Previous = (I)i;

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+148], cx

; 540  : 		prev = (I)i;

	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR _prev$[ebp], dx

; 541  : 	}

	jmp	SHORT $L74351
$L74352:

; 542  : 	
; 543  : 	// First free points to the first element
; 544  : 	m_FirstFree = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+16], 0

; 545  : 	
; 546  : 	// Clear everything else out
; 547  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 548  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 549  : 	m_ElementCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0
$L74345:

; 550  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlLinkedList@UJiggleData@@G@@QAEXXZ ENDP	; CUtlLinkedList<JiggleData,unsigned short>::RemoveAll
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Purge
;	COMDAT ??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ PROC NEAR ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::~CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Purge

; 262  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::~CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >
_TEXT	ENDS
PUBLIC	??A?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEAAVCIKTarget@@H@Z ; CUtlMemoryFixed<CIKTarget,12,0>::operator[]
;	COMDAT ??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z PROC NEAR ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEAAVCIKTarget@@H@Z ; CUtlMemoryFixed<CIKTarget,12,0>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ PROC NEAR ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4032]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Purge
PUBLIC	??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::~CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ PROC NEAR ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::~CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::~CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::~CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>
	ret	0
__ehhandler$??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::~CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >
PUBLIC	?Purge@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Purge
PUBLIC	??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ	; CUtlMemory<ikcontextikrule_t,int>::~CUtlMemory<ikcontextikrule_t,int>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ PROC NEAR ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::~CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ ; CUtlMemory<ikcontextikrule_t,int>::~CUtlMemory<ikcontextikrule_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ ; CUtlMemory<ikcontextikrule_t,int>::~CUtlMemory<ikcontextikrule_t,int>
	ret	0
__ehhandler$??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::~CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >
PUBLIC	?ConstructList@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ConstructList
PUBLIC	?ResetDbgInfo@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ResetDbgInfo
PUBLIC	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>
PUBLIC	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_this$ = -16
__$EHRec$ = -12
??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>, COMDAT

; 166  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 167  : 	ConstructList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConstructList@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ConstructList

; 168  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ResetDbgInfo

; 169  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@HH@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 182  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::RemoveAll

; 183  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAE@XZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>
PUBLIC	?Element@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Element
PUBLIC	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
PUBLIC	?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsValidIndex
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
PUBLIC	?Destruct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z ; Destruct
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_prev$ = -8
_i$ = -12
?RemoveAll@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::RemoveAll, COMDAT

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 524  : 	if (m_TotalElements == 0)

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $L74391

; 525  : 		return;

	jmp	$L74390
$L74391:

; 526  : 
; 527  : 	// Put everything into the free list
; 528  : 	I prev = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	mov	WORD PTR _prev$[ebp], ax

; 529  : 	for (int i = (int)m_TotalElements; --i >= 0; )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	DWORD PTR _i$[ebp], eax
$L74396:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L74397

; 531  : 		// Invoke the destructor
; 532  : 		if (IsValidIndex((I)i))

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74399

; 533  : 			Destruct( &Element((I)i) );

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Element
	push	eax
	call	?Destruct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z ; Destruct
	add	esp, 4
$L74399:

; 534  : 		
; 535  : 		// next points to the next free list item
; 536  : 		InternalElement((I)i).m_Next = prev;

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
	mov	dx, WORD PTR _prev$[ebp]
	mov	WORD PTR [eax+94], dx

; 537  : 		
; 538  : 		// Indicates it's in the free list
; 539  : 		InternalElement((I)i).m_Previous = (I)i;

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+92], cx

; 540  : 		prev = (I)i;

	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR _prev$[ebp], dx

; 541  : 	}

	jmp	SHORT $L74396
$L74397:

; 542  : 	
; 543  : 	// First free points to the first element
; 544  : 	m_FirstFree = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+16], 0

; 545  : 	
; 546  : 	// Clear everything else out
; 547  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 548  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 549  : 	m_ElementCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0
$L74390:

; 550  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::RemoveAll
_TEXT	ENDS
PUBLIC	?ConstructList@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ConstructList
PUBLIC	?ResetDbgInfo@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ResetDbgInfo
PUBLIC	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>
PUBLIC	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_this$ = -16
__$EHRec$ = -12
??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>, COMDAT

; 166  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 167  : 	ConstructList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConstructList@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ConstructList

; 168  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ResetDbgInfo

; 169  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@HH@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>
PUBLIC	?RemoveAll@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::RemoveAll
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 182  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::RemoveAll

; 183  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAE@XZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>
PUBLIC	?ConstructList@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ConstructList
PUBLIC	?ResetDbgInfo@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ResetDbgInfo
PUBLIC	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>
PUBLIC	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_this$ = -16
__$EHRec$ = -12
??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>, COMDAT

; 166  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 167  : 	ConstructList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConstructList@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ConstructList

; 168  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ResetDbgInfo

; 169  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@HH@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>
PUBLIC	?RemoveAll@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::RemoveAll
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 182  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::RemoveAll

; 183  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAE@XZ ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[], COMDAT

; 213  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[]

; 215  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::operator[]
_TEXT	ENDS
PUBLIC	?InsertBefore@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEGG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InsertBefore
PUBLIC	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
;	COMDAT ?AddToTail@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4
?AddToTail@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::AddToTail, COMDAT

; 431  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	return InsertBefore( InvalidIndex() ); 

	call	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEGG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InsertBefore

; 433  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddToTail@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::AddToTail
_TEXT	ENDS
PUBLIC	?Free@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Free
;	COMDAT ?Remove@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
?Remove@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Remove, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	Free( elem );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Free

; 519  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Remove
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Count, COMDAT

; 229  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 	return m_ElementCount; 

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+18]
	mov	eax, ecx

; 231  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Count
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsValidIndex, COMDAT

; 277  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return (i < m_TotalElements) && (i >= 0) &&
; 279  : 		((m_Memory[i].m_Previous != i) || (m_Memory[i].m_Next == i));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L76801
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L76801
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+34092]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L76802
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+34094]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L76801
$L76802:
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L76803
$L76801:
	mov	DWORD PTR -8+[ebp], 0
$L76803:
	mov	al, BYTE PTR -8+[ebp]

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsValidIndex
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ PROC NEAR ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex, COMDAT

; 100  : 	inline static I  InvalidIndex()  { return INVALID_LLIST_IDX; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	or	ax, 65535				; 0000ffffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ENDP ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement, COMDAT

; 135  : 	ListElem_t& InternalElement( I i ) { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ENDP ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Base
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<JiggleData,unsigned short>::ResetDbgInfo, COMDAT

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		m_pElements = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 141  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ ENDP ; CUtlLinkedList<JiggleData,unsigned short>::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBE_NH@Z ; CUtlMemoryFixed<CIKTarget,12,0>::IsIdxValid
PUBLIC	?Base@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEPAVCIKTarget@@XZ ; CUtlMemoryFixed<CIKTarget,12,0>::Base
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEAAVCIKTarget@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEAAVCIKTarget@@H@Z PROC NEAR ; CUtlMemoryFixed<CIKTarget,12,0>::operator[], COMDAT

; 239  : 	T& operator[]( int i )									{ assert( IsIdxValid(i) ); return Base()[i];	}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBE_NH@Z ; CUtlMemoryFixed<CIKTarget,12,0>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L76812
	push	239					; 000000efH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76812:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEPAVCIKTarget@@XZ ; CUtlMemoryFixed<CIKTarget,12,0>::Base
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 336				; 00000150H
	add	eax, edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEAAVCIKTarget@@H@Z ENDP ; CUtlMemoryFixed<CIKTarget,12,0>::operator[]
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex, COMDAT

; 100  : 	inline static I  InvalidIndex()  { return INVALID_LLIST_IDX; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	or	ax, 65535				; 0000ffffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement, COMDAT

; 135  : 	ListElem_t& InternalElement( I i ) { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InternalElement
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Base
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ResetDbgInfo, COMDAT

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		m_pElements = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 141  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Base
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ResetDbgInfo, COMDAT

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		m_pElements = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 141  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ResetDbgInfo
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex, COMDAT

; 100  : 	inline static I  InvalidIndex()  { return INVALID_LLIST_IDX; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	or	ax, 65535				; 0000ffffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::Base
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ResetDbgInfo, COMDAT

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		m_pElements = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 141  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ResetDbgInfo
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBE_NH@Z PROC NEAR ; CUtlMemoryFixed<CIKTarget,12,0>::IsIdxValid, COMDAT

; 231  : 	bool IsIdxValid( int i ) const							{ return (i >= 0) && (i < SIZE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L76827
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jae	SHORT $L76827
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L76828
$L76827:
	mov	DWORD PTR -8+[ebp], 0
$L76828:
	mov	al, BYTE PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBE_NH@Z ENDP ; CUtlMemoryFixed<CIKTarget,12,0>::IsIdxValid
_TEXT	ENDS
PUBLIC	?AlignValue@@YAPADPADI@Z			; AlignValue
;	COMDAT ?Base@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEPAVCIKTarget@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEPAVCIKTarget@@XZ PROC NEAR ; CUtlMemoryFixed<CIKTarget,12,0>::Base, COMDAT

; 235  : 	T* Base()												{ if ( nAlignment == 0 ) return (T*)(&m_Memory[0]); else return (T*)AlignValue( &m_Memory[0], nAlignment ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	test	eax, eax
	je	SHORT $L74470
	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $L74472
$L74470:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?AlignValue@@YAPADPADI@Z		; AlignValue
	add	esp, 8
$L74472:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEPAVCIKTarget@@XZ ENDP ; CUtlMemoryFixed<CIKTarget,12,0>::Base
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z PROC NEAR ; CUtlLinkedList<JiggleData,unsigned short>::Element, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]

; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z ENDP ; CUtlLinkedList<JiggleData,unsigned short>::Element
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<JiggleData,unsigned short>::IsValidIndex, COMDAT

; 277  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return (i < m_TotalElements) && (i >= 0) &&
; 279  : 		((m_Memory[i].m_Previous != i) || (m_Memory[i].m_Next == i));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L76835
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L76835
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+148]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L76836
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+150]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L76835
$L76836:
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L76837
$L76835:
	mov	DWORD PTR -8+[ebp], 0
$L76837:
	mov	al, BYTE PTR -8+[ebp]

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<JiggleData,unsigned short>::IsValidIndex
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ConstructList@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<JiggleData,unsigned short>::ConstructList, COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 189  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 190  : 	m_FirstFree = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+16], ax

; 191  : 	m_ElementCount = m_TotalElements = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0

; 192  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ConstructList@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ ENDP ; CUtlLinkedList<JiggleData,unsigned short>::ConstructList
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::ValidateGrowSize
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@HH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L76842
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76842:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L74497

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 152				; 00000098H
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L74497:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@HH@Z ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Purge
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@XZ ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsReadOnly
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L76847
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76847:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L76848
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76848:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 152				; 00000098H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L76851
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76851:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Base
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUJiggleData@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUJiggleData@@@Z PROC NEAR		; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	148					; 00000094H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUJiggleData@@@Z ENDP			; Destruct
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXXZ ; CUtlMemoryFixed<CIKTarget,12,0>::Purge
PUBLIC	?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ResetDbgInfo
;	COMDAT ?Purge@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ PROC NEAR ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXXZ ; CUtlMemoryFixed<CIKTarget,12,0>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Purge
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Purge
PUBLIC	?ResetDbgInfo@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ResetDbgInfo
;	COMDAT ?Purge@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Purge
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ PROC NEAR ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::~CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::~CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXXZ ; CUtlMemory<ikcontextikrule_t,int>::Purge
PUBLIC	?ResetDbgInfo@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ResetDbgInfo
;	COMDAT ?Purge@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXXZ ; CUtlMemory<ikcontextikrule_t,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Purge
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ PROC NEAR	; CUtlMemory<ikcontextikrule_t,int>::~CUtlMemory<ikcontextikrule_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXXZ ; CUtlMemory<ikcontextikrule_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ ENDP	; CUtlMemory<ikcontextikrule_t,int>::~CUtlMemory<ikcontextikrule_t,int>
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Element, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]

; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QAEAAUDecalMaterial_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::Element
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsValidIndex, COMDAT

; 277  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return (i < m_TotalElements) && (i >= 0) &&
; 279  : 		((m_Memory[i].m_Previous != i) || (m_Memory[i].m_Next == i));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L76868
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L76868
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+92]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L76869
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+94]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L76868
$L76869:
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L76870
$L76868:
	mov	DWORD PTR -8+[ebp], 0
$L76870:
	mov	al, BYTE PTR -8+[ebp]

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::IsValidIndex
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ConstructList@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ConstructList, COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 189  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 190  : 	m_FirstFree = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+16], ax

; 191  : 	m_ElementCount = m_TotalElements = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0

; 192  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ConstructList@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@IAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ConstructList
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::ValidateGrowSize
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L76875
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76875:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L74548

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 96					; 00000060H
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L74548:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Purge
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAE@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L76880
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76880:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L76881
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76881:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L76884
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76884:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Base
_TEXT	ENDS
PUBLIC	??_GDecalMaterial_t@CStudioModelRenderer@@QAEPAXI@Z ; CStudioModelRenderer::DecalMaterial_t::`scalar deleting destructor'
;	COMDAT ?Destruct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z PROC NEAR ; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();

	push	0
	mov	ecx, DWORD PTR _pMemory$[ebp]
	call	??_GDecalMaterial_t@CStudioModelRenderer@@QAEPAXI@Z ; CStudioModelRenderer::DecalMaterial_t::`scalar deleting destructor'

; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	92					; 0000005cH
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUDecalMaterial_t@CStudioModelRenderer@@@Z ENDP ; Destruct
_TEXT	ENDS
PUBLIC	?Element@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Element
PUBLIC	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
PUBLIC	?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsValidIndex
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
PUBLIC	?Destruct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z ; Destruct
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_prev$ = -8
_i$ = -12
?RemoveAll@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::RemoveAll, COMDAT

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 524  : 	if (m_TotalElements == 0)

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $L74569

; 525  : 		return;

	jmp	$L74568
$L74569:

; 526  : 
; 527  : 	// Put everything into the free list
; 528  : 	I prev = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
	mov	WORD PTR _prev$[ebp], ax

; 529  : 	for (int i = (int)m_TotalElements; --i >= 0; )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	DWORD PTR _i$[ebp], eax
$L74574:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L74575

; 531  : 		// Invoke the destructor
; 532  : 		if (IsValidIndex((I)i))

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74577

; 533  : 			Destruct( &Element((I)i) );

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Element
	push	eax
	call	?Destruct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z ; Destruct
	add	esp, 4
$L74577:

; 534  : 		
; 535  : 		// next points to the next free list item
; 536  : 		InternalElement((I)i).m_Next = prev;

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
	mov	dx, WORD PTR _prev$[ebp]
	mov	WORD PTR [eax+34], dx

; 537  : 		
; 538  : 		// Indicates it's in the free list
; 539  : 		InternalElement((I)i).m_Previous = (I)i;

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+32], cx

; 540  : 		prev = (I)i;

	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR _prev$[ebp], dx

; 541  : 	}

	jmp	SHORT $L74574
$L74575:

; 542  : 	
; 543  : 	// First free points to the first element
; 544  : 	m_FirstFree = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+16], 0

; 545  : 	
; 546  : 	// Clear everything else out
; 547  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 548  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 549  : 	m_ElementCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0
$L74568:

; 550  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::RemoveAll
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ConstructList@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ConstructList, COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 189  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 190  : 	m_FirstFree = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+16], ax

; 191  : 	m_ElementCount = m_TotalElements = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0

; 192  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ConstructList@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ConstructList
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::ValidateGrowSize
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L76893
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76893:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L74596

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 36					; 00000024H
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L74596:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Purge
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAE@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsReadOnly
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L76898
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76898:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Base
_TEXT	ENDS
PUBLIC	?Element@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Element
PUBLIC	?LinkBefore@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXGG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::LinkBefore
PUBLIC	?AllocInternal@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEG_N@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::AllocInternal
PUBLIC	?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z ; Construct
;	COMDAT ?InsertBefore@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEGG@Z
_TEXT	SEGMENT
_before$ = 8
_this$ = -4
_newNode$ = -8
?InsertBefore@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InsertBefore, COMDAT

; 395  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 396  : 	// Make a new node
; 397  : 	I   newNode = AllocInternal();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocInternal@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEG_N@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::AllocInternal
	mov	WORD PTR _newNode$[ebp], ax

; 398  : 	
; 399  : 	// Link it in
; 400  : 	LinkBefore( before, newNode );

	mov	ax, WORD PTR _newNode$[ebp]
	push	eax
	mov	cx, WORD PTR _before$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkBefore@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXGG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::LinkBefore

; 401  : 	
; 402  : 	// Construct the data
; 403  : 	Construct( &Element(newNode) );

	mov	dx, WORD PTR _newNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Element
	push	eax
	call	?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z ; Construct
	add	esp, 4

; 404  : 	
; 405  : 	return newNode;

	mov	ax, WORD PTR _newNode$[ebp]

; 406  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InsertBefore@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InsertBefore
_TEXT	ENDS
PUBLIC	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
PUBLIC	?Destruct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z ; Destruct
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_prev$ = -8
_i$ = -12
?RemoveAll@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::RemoveAll, COMDAT

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 524  : 	if (m_TotalElements == 0)

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $L74618

; 525  : 		return;

	jmp	$L74617
$L74618:

; 526  : 
; 527  : 	// Put everything into the free list
; 528  : 	I prev = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
	mov	WORD PTR _prev$[ebp], ax

; 529  : 	for (int i = (int)m_TotalElements; --i >= 0; )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	DWORD PTR _i$[ebp], eax
$L74623:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L74624

; 531  : 		// Invoke the destructor
; 532  : 		if (IsValidIndex((I)i))

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L74626

; 533  : 			Destruct( &Element((I)i) );

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Element
	push	eax
	call	?Destruct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z ; Destruct
	add	esp, 4
$L74626:

; 534  : 		
; 535  : 		// next points to the next free list item
; 536  : 		InternalElement((I)i).m_Next = prev;

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
	mov	dx, WORD PTR _prev$[ebp]
	mov	WORD PTR [eax+34094], dx

; 537  : 		
; 538  : 		// Indicates it's in the free list
; 539  : 		InternalElement((I)i).m_Previous = (I)i;

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+34092], cx

; 540  : 		prev = (I)i;

	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR _prev$[ebp], dx

; 541  : 	}

	jmp	SHORT $L74623
$L74624:

; 542  : 	
; 543  : 	// First free points to the first element
; 544  : 	m_FirstFree = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+16], 0

; 545  : 	
; 546  : 	// Clear everything else out
; 547  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 548  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 549  : 	m_ElementCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0
$L74617:

; 550  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::RemoveAll
_TEXT	ENDS
PUBLIC	?Unlink@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Unlink
PUBLIC	??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
PUBLIC	??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@	; `string'
;	COMDAT ??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@
; File z:\xashxtsrc\game_shared\utllinkedlist.h
CONST	SEGMENT
??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utllinkedlist.h', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ DB 'IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?Free@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_internalElem$ = -8
?Free@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Free, COMDAT

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L76905
	push	380					; 0000017cH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76905:

; 381  : 	Unlink(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlink@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Unlink

; 382  : 
; 383  : 	ListElem_t &internalElem = InternalElement(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
	mov	DWORD PTR _internalElem$[ebp], eax

; 384  : 	Destruct( &internalElem.m_Element );

	mov	ecx, DWORD PTR _internalElem$[ebp]
	push	ecx
	call	?Destruct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z ; Destruct
	add	esp, 4

; 385  : 	internalElem.m_Next = m_FirstFree;

	mov	edx, DWORD PTR _internalElem$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	mov	WORD PTR [edx+34094], cx

; 386  : 	m_FirstFree = elem;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+16], ax

; 387  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Free@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Free
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ConstructList@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ConstructList, COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 189  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 190  : 	m_FirstFree = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+16], ax

; 191  : 	m_ElementCount = m_TotalElements = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0

; 192  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ConstructList@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ConstructList
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::ValidateGrowSize
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@IAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L76910
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76910:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L74656

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 34096				; 00008530H
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L74656:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@HH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::Purge
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAE@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsIdxValid
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L76915
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76915:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 34096				; 00008530H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L76918
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76918:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L76919
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76919:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 34096				; 00008530H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L76922
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76922:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::Base
_TEXT	ENDS
;	COMDAT ?AlignValue@@YAPADPADI@Z
_TEXT	SEGMENT
_val$ = 8
_alignment$ = 12
?AlignValue@@YAPADPADI@Z PROC NEAR			; AlignValue, COMDAT

; 27   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 28   : 	return (T)( ( (unsigned int)val + alignment - 1 ) & ~( alignment - 1 ) );

	mov	eax, DWORD PTR _alignment$[ebp]
	mov	ecx, DWORD PTR _val$[ebp]
	lea	eax, DWORD PTR [ecx+eax-1]
	mov	edx, DWORD PTR _alignment$[ebp]
	sub	edx, 1
	not	edx
	and	eax, edx

; 29   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AlignValue@@YAPADPADI@Z ENDP				; AlignValue
_TEXT	ENDS
PUBLIC	??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ	; CStudioModelRenderer::DecalMaterial_t::~DecalMaterial_t
;	COMDAT ??_GDecalMaterial_t@CStudioModelRenderer@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GDecalMaterial_t@CStudioModelRenderer@@QAEPAXI@Z PROC NEAR ; CStudioModelRenderer::DecalMaterial_t::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::DecalMaterial_t::~DecalMaterial_t
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L74683
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L74683:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDecalMaterial_t@CStudioModelRenderer@@QAEPAXI@Z ENDP ; CStudioModelRenderer::DecalMaterial_t::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::~CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >
PUBLIC	??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ	; CUtlLinkedList<DecalVertex_t,unsigned short>::~CUtlLinkedList<DecalVertex_t,unsigned short>
PUBLIC	??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ DD 019930520H
	DD	02H
	DD	FLAT:__unwindtable$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT ??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ PROC NEAR ; CStudioModelRenderer::DecalMaterial_t::~DecalMaterial_t, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::~CUtlLinkedList<DecalVertex_t,unsigned short>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::~CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::~CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >
	ret	0
__unwindfunclet$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::~CUtlLinkedList<DecalVertex_t,unsigned short>
	ret	0
__ehhandler$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1DecalMaterial_t@CStudioModelRenderer@@QAE@XZ ENDP	; CStudioModelRenderer::DecalMaterial_t::~DecalMaterial_t
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@IAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@IAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::ValidateGrowSize
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Base
;	COMDAT ?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ PROC NEAR ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4036], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ResetDbgInfo
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXXZ PROC NEAR ; CUtlMemoryFixed<CIKTarget,12,0>::Purge, COMDAT

; 258  : 	void Purge()											{}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXXZ ENDP ; CUtlMemoryFixed<CIKTarget,12,0>::Purge
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Base
;	COMDAT ?ResetDbgInfo@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXXZ PROC NEAR ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXXZ ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Base
;	COMDAT ?ResetDbgInfo@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXXZ PROC NEAR ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXXZ ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ResetDbgInfo
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@IAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@IAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex, COMDAT

; 100  : 	inline static I  InvalidIndex()  { return INVALID_LLIST_IDX; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	or	ax, 65535				; 0000ffffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@SAGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InvalidIndex
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement, COMDAT

; 135  : 	ListElem_t& InternalElement( I i ) { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::InternalElement
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@IAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@IAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement, COMDAT

; 135  : 	ListElem_t& InternalElement( I i ) { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@IAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@IAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ PROC NEAR ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEPAVCIKTarget@@XZ ; CUtlMemoryFixed<CIKTarget,12,0>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Base
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Base
;	COMDAT ?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ PROC NEAR ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Base
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEPAUikcontextikrule_t@@XZ ; CUtlMemory<ikcontextikrule_t,int>::Base
;	COMDAT ?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ PROC NEAR ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEPAUikcontextikrule_t@@XZ ; CUtlMemory<ikcontextikrule_t,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Base
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L76968
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76968:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 152				; 00000098H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L76971
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L76971
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L76972
$L76971:
	mov	DWORD PTR -8+[ebp], 0
$L76972:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74728

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L74729

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L74729:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L74728:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Element
PUBLIC	?Destruct@@YAXPAVCIKTarget@@@Z			; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ PROC NEAR ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4032]
	mov	DWORD PTR _i$[ebp], ecx
$L74739:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L74740

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Element
	push	eax
	call	?Destruct@@YAXPAVCIKTarget@@@Z		; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L74739
$L74740:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4032], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::RemoveAll
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ; Destruct
PUBLIC	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
;	COMDAT ?RemoveAll@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L74750:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L74751

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	push	eax
	call	?Destruct@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L74750
$L74751:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?IsReadOnly@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsReadOnly
;	COMDAT ?Base@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ PROC NEAR ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L76983
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76983:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Base
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXXZ PROC NEAR ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74763

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L74764

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L74764:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L74763:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXXZ ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Purge
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAUikcontextikrule_t@@@Z		; Destruct
PUBLIC	?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
;	COMDAT ?RemoveAll@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L74771:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L74772

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
	push	eax
	call	?Destruct@@YAXPAUikcontextikrule_t@@@Z	; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L74771
$L74772:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?IsReadOnly@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ; CUtlMemory<ikcontextikrule_t,int>::IsReadOnly
;	COMDAT ?Base@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEPAUikcontextikrule_t@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEPAUikcontextikrule_t@@XZ PROC NEAR ; CUtlMemory<ikcontextikrule_t,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ; CUtlMemory<ikcontextikrule_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L76990
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76990:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEPAUikcontextikrule_t@@XZ ENDP ; CUtlMemory<ikcontextikrule_t,int>::Base
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ; CUtlMemory<ikcontextikrule_t,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXXZ PROC NEAR ; CUtlMemory<ikcontextikrule_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ; CUtlMemory<ikcontextikrule_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74784

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L74785

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L74785:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L74784:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXXZ ENDP	; CUtlMemory<ikcontextikrule_t,int>::Purge
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L76995
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L76995:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 96					; 00000060H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L76998
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L76998
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L76999
$L76998:
	mov	DWORD PTR -8+[ebp], 0
$L76999:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74801

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L74802

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L74802:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L74801:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Element, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]

; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QAEAAUDecalModelList_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::Element
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsValidIndex, COMDAT

; 277  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return (i < m_TotalElements) && (i >= 0) &&
; 279  : 		((m_Memory[i].m_Previous != i) || (m_Memory[i].m_Next == i));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L77008
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L77008
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+32]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L77009
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+34]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L77008
$L77009:
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L77010
$L77008:
	mov	DWORD PTR -8+[ebp], 0
$L77010:
	mov	al, BYTE PTR -8+[ebp]

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::IsValidIndex
_TEXT	ENDS
PUBLIC	??_GDecalModelList_t@CStudioModelRenderer@@QAEPAXI@Z ; CStudioModelRenderer::DecalModelList_t::`scalar deleting destructor'
;	COMDAT ?Destruct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z PROC NEAR ; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();

	push	0
	mov	ecx, DWORD PTR _pMemory$[ebp]
	call	??_GDecalModelList_t@CStudioModelRenderer@@QAEPAXI@Z ; CStudioModelRenderer::DecalModelList_t::`scalar deleting destructor'

; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	32					; 00000020H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUDecalModelList_t@CStudioModelRenderer@@@Z ENDP ; Destruct
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsIdxValid
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L77015
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77015:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77016
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77016:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74826

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L74827

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L74827:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L74826:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Element, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[]

; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEAAUModelInstance_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Element
_TEXT	ENDS
PUBLIC	??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@	; `string'
PUBLIC	?IsInList@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsInList
;	COMDAT ??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utllinkedlist.h
CONST	SEGMENT
??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@ DB 'IsInList(before)', 00H ; `string'
CONST	ENDS
;	COMDAT ?LinkBefore@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXGG@Z
_TEXT	SEGMENT
_before$ = 8
_elem$ = 12
_this$ = -4
_newElem$ = -8
_beforeElem$74847 = -12
?LinkBefore@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::LinkBefore, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 560  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77025
	push	560					; 00000230H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77025:

; 561  : 	
; 562  : 	// Unlink it if it's in the list at the moment
; 563  : 	Unlink(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlink@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Unlink

; 564  : 	
; 565  : 	ListElem_t& newElem = InternalElement(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
	mov	DWORD PTR _newElem$[ebp], eax

; 566  : 	
; 567  : 	// The element *after* our newly linked one is the one we linked before.
; 568  : 	newElem.m_Next = before;

	mov	ecx, DWORD PTR _newElem$[ebp]
	mov	dx, WORD PTR _before$[ebp]
	mov	WORD PTR [ecx+34094], dx

; 569  : 	
; 570  : 	if (before == InvalidIndex())

	mov	esi, DWORD PTR _before$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L74843

; 572  : 		// In this case, we're linking to the end of the list, so reset the tail
; 573  : 		newElem.m_Previous = m_Tail;

	mov	eax, DWORD PTR _newElem$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+14]
	mov	WORD PTR [eax+34092], dx

; 574  : 		m_Tail = elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+14], cx

; 576  : 	else

	jmp	SHORT $L74844
$L74843:

; 578  : 		// Here, we're not linking to the end. Set the prev pointer to point to
; 579  : 		// the element we're linking.
; 580  : 		assert( IsInList(before) );

	mov	dx, WORD PTR _before$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsInList
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77026
	push	580					; 00000244H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BB@FBME@IsInList?$CIbefore?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77026:

; 581  : 		ListElem_t& beforeElem = InternalElement(before);

	mov	cx, WORD PTR _before$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
	mov	DWORD PTR _beforeElem$74847[ebp], eax

; 582  : 		newElem.m_Previous = beforeElem.m_Previous;

	mov	edx, DWORD PTR _newElem$[ebp]
	mov	eax, DWORD PTR _beforeElem$74847[ebp]
	mov	cx, WORD PTR [eax+34092]
	mov	WORD PTR [edx+34092], cx

; 583  : 		beforeElem.m_Previous = elem;

	mov	edx, DWORD PTR _beforeElem$74847[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+34092], ax
$L74844:

; 585  : 	
; 586  : 	// Reset the head if we linked to the head of the list
; 587  : 	if (newElem.m_Previous == InvalidIndex())

	mov	ecx, DWORD PTR _newElem$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+34092]
	mov	esi, edx
	call	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L74848

; 588  : 		m_Head = elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+12], cx

; 589  : 	else

	jmp	SHORT $L74849
$L74848:

; 590  : 		InternalElement(newElem.m_Previous).m_Next = elem;

	mov	edx, DWORD PTR _newElem$[ebp]
	mov	ax, WORD PTR [edx+34092]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+34094], cx
$L74849:

; 591  : 	
; 592  : 	// one more element baby
; 593  : 	++m_ElementCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+18]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+18], ax

; 594  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?LinkBefore@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::LinkBefore
_TEXT	ENDS
;	COMDAT ?Unlink@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_pBase$74856 = -8
_pOldElem$74857 = -12
?Unlink@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Unlink, COMDAT

; 637  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 	assert( IsValidIndex(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77029
	push	638					; 0000027eH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77029:

; 639  : 	if (IsInList(elem))

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsInList
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L74855

; 641  : 		ListElem_t *pBase = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::Base
	mov	DWORD PTR _pBase$74856[ebp], eax

; 642  : 		ListElem_t *pOldElem = &pBase[elem];

	mov	eax, DWORD PTR _elem$[ebp]
	and	eax, 65535				; 0000ffffH
	imul	eax, 34096				; 00008530H
	mov	ecx, DWORD PTR _pBase$74856[ebp]
	add	ecx, eax
	mov	DWORD PTR _pOldElem$74857[ebp], ecx

; 643  : 		
; 644  : 		// If we're the first guy, reset the head
; 645  : 		// otherwise, make our previous node's next pointer = our next
; 646  : 		if ( pOldElem->m_Previous != INVALID_LLIST_IDX )

	mov	edx, DWORD PTR _pOldElem$74857[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+34092]
	cmp	eax, 65535				; 0000ffffH
	je	SHORT $L74859

; 648  : 			pBase[pOldElem->m_Previous].m_Next = pOldElem->m_Next;

	mov	ecx, DWORD PTR _pOldElem$74857[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+34092]
	imul	edx, 34096				; 00008530H
	mov	eax, DWORD PTR _pBase$74856[ebp]
	mov	ecx, DWORD PTR _pOldElem$74857[ebp]
	mov	cx, WORD PTR [ecx+34094]
	mov	WORD PTR [eax+edx+34094], cx

; 650  : 		else

	jmp	SHORT $L74860
$L74859:

; 652  : 			m_Head = pOldElem->m_Next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pOldElem$74857[ebp]
	mov	cx, WORD PTR [eax+34094]
	mov	WORD PTR [edx+12], cx
$L74860:

; 654  : 		
; 655  : 		// If we're the last guy, reset the tail
; 656  : 		// otherwise, make our next node's prev pointer = our prev
; 657  : 		if ( pOldElem->m_Next != INVALID_LLIST_IDX )

	mov	edx, DWORD PTR _pOldElem$74857[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+34094]
	cmp	eax, 65535				; 0000ffffH
	je	SHORT $L74862

; 659  : 			pBase[pOldElem->m_Next].m_Previous = pOldElem->m_Previous;

	mov	ecx, DWORD PTR _pOldElem$74857[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+34094]
	imul	edx, 34096				; 00008530H
	mov	eax, DWORD PTR _pBase$74856[ebp]
	mov	ecx, DWORD PTR _pOldElem$74857[ebp]
	mov	cx, WORD PTR [ecx+34092]
	mov	WORD PTR [eax+edx+34092], cx

; 661  : 		else

	jmp	SHORT $L74863
$L74862:

; 663  : 			m_Tail = pOldElem->m_Previous;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pOldElem$74857[ebp]
	mov	cx, WORD PTR [eax+34092]
	mov	WORD PTR [edx+14], cx
$L74863:

; 665  : 		
; 666  : 		// This marks this node as not in the list, 
; 667  : 		// but not in the free list either
; 668  : 		pOldElem->m_Previous = pOldElem->m_Next = elem;

	mov	edx, DWORD PTR _pOldElem$74857[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+34094], ax
	mov	ecx, DWORD PTR _pOldElem$74857[ebp]
	mov	dx, WORD PTR _elem$[ebp]
	mov	WORD PTR [ecx+34092], dx

; 669  : 		
; 670  : 		// One less puppy
; 671  : 		--m_ElementCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+18]
	sub	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+18], cx
$L74855:

; 673  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Unlink@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QAEXG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Unlink
_TEXT	ENDS
PUBLIC	??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@ ; `string'
PUBLIC	??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
PUBLIC	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::Grow
;	COMDAT ??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@
; File z:\xashxtsrc\game_shared\utllinkedlist.h
CONST	SEGMENT
??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@ DB 'm_TotalEl'
	DB	'ements != InvalidIndex()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@ DB 'elem != Inva'
	DB	'lidIndex()', 00H				; `string'
CONST	ENDS
;	COMDAT ?AllocInternal@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEG_N@Z
_TEXT	SEGMENT
_multilist$ = 8
_this$ = -4
_elem$ = -8
?AllocInternal@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEG_N@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::AllocInternal, COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 336  : 	I elem;
; 337  : 	if (m_FirstFree == InvalidIndex())

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+16]
	mov	esi, ecx
	call	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	$L74869

; 339  : 		// Nothing in the free list; add.
; 340  : 		// Since nothing is in the free list, m_TotalElements == total # of elements
; 341  : 		// the list knows about.
; 342  : 		if (m_TotalElements == m_Memory.NumAllocated())

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::NumAllocated
	cmp	esi, eax
	jne	SHORT $L74870

; 343  : 			m_Memory.Grow();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::Grow
$L74870:

; 344  : 
; 345  : 		assert( m_TotalElements != InvalidIndex() );

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	mov	esi, edx
	call	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L77032
	push	345					; 00000159H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0CC@INNL@m_TotalElements?5?$CB?$DN?5InvalidIndex?$CI@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77032:

; 346  : 
; 347  : 		elem = (I)m_TotalElements;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+20]
	mov	WORD PTR _elem$[ebp], dx

; 348  : 		++m_TotalElements;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+20]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], cx

; 349  : 
; 350  : 		assert( elem != InvalidIndex() );

	mov	esi, DWORD PTR _elem$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L77033
	push	350					; 0000015eH
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BH@NBKM@elem?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77033:

; 352  : 	else

	jmp	SHORT $L74876
$L74869:

; 354  : 		elem = m_FirstFree;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+16]
	mov	WORD PTR _elem$[ebp], dx

; 355  : 		m_FirstFree = InternalElement(m_FirstFree).m_Next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+34094]
	mov	WORD PTR [edx+16], ax
$L74876:

; 357  : 	
; 358  : 	if (!multilist)

	mov	ecx, DWORD PTR _multilist$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L74877

; 359  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = elem;

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+34092], cx
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+34094], cx

; 360  : 	else

	jmp	SHORT $L74878
$L74877:

; 361  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InvalidIndex
	mov	si, ax
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
	add	eax, 34092				; 0000852cH
	mov	DWORD PTR -12+[ebp], eax
	mov	eax, DWORD PTR -12+[ebp]
	mov	WORD PTR [eax], si
	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
	mov	edx, DWORD PTR -12+[ebp]
	mov	cx, WORD PTR [edx]
	mov	WORD PTR [eax+34094], cx
$L74878:

; 362  : 
; 363  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEXXZ ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ResetDbgInfo

; 364  : 
; 365  : 	return elem;

	mov	ax, WORD PTR _elem$[ebp]

; 366  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocInternal@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IAEG_N@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::AllocInternal
_TEXT	ENDS
PUBLIC	??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ	; CStudioModelRenderer::ModelInstance_t::ModelInstance_t
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlmemory.h
xdata$x	SEGMENT
__ehfuncinfo$?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z$0
xdata$x	ENDS
;	COMDAT ?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
$T77036 = -16
$T77037 = -20
__$EHRec$ = -12
_pMemory$ = 8
?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z PROC NEAR ; Construct, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 38   : 	new( pMemory ) T;

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	34092					; 0000852cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T77037[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T77037[ebp], 0
	je	SHORT $L77038
	mov	ecx, DWORD PTR $T77037[ebp]
	call	??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::ModelInstance_t::ModelInstance_t
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L77039
$L77038:
	mov	DWORD PTR -24+[ebp], 0
$L77039:
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T77036[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 39   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z$0:
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T77037[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?Construct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z ENDP ; Construct
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 79   : 	{return; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_GModelInstance_t@CStudioModelRenderer@@QAEPAXI@Z ; CStudioModelRenderer::ModelInstance_t::`scalar deleting destructor'
;	COMDAT ?Destruct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z PROC NEAR ; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();

	push	0
	mov	ecx, DWORD PTR _pMemory$[ebp]
	call	??_GModelInstance_t@CStudioModelRenderer@@QAEPAXI@Z ; CStudioModelRenderer::ModelInstance_t::`scalar deleting destructor'

; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	34092					; 0000852cH
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUModelInstance_t@CStudioModelRenderer@@@Z ENDP ; Destruct
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L77055
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L77055
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L77056
$L77055:
	mov	DWORD PTR -8+[ebp], 0
$L77056:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L74896

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L74897

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L74897:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L74896:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Purge
PUBLIC	??1?$CUtlMemory@GH@@QAE@XZ			; CUtlMemory<unsigned short,int>::~CUtlMemory<unsigned short,int>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ PROC NEAR	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::~CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@GH@@QAE@XZ		; CUtlMemory<unsigned short,int>::~CUtlMemory<unsigned short,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@GH@@QAE@XZ		; CUtlMemory<unsigned short,int>::~CUtlMemory<unsigned short,int>
	ret	0
__ehhandler$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@GV?$CUtlMemory@GH@@@@QAE@XZ ENDP		; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::~CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >
PUBLIC	?RemoveAll@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::RemoveAll
PUBLIC	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ PROC NEAR	; CUtlLinkedList<DecalVertex_t,unsigned short>::~CUtlLinkedList<DecalVertex_t,unsigned short>, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 182  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::RemoveAll

; 183  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlLinkedList@UDecalVertex_t@@G@@QAE@XZ ENDP	; CUtlLinkedList<DecalVertex_t,unsigned short>::~CUtlLinkedList<DecalVertex_t,unsigned short>
PUBLIC	?RemoveAll@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::RemoveAll
PUBLIC	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 182  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::RemoveAll

; 183  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAE@XZ ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>
PUBLIC	??1DecalModelList_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::DecalModelList_t::~DecalModelList_t
;	COMDAT ??_GDecalModelList_t@CStudioModelRenderer@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GDecalModelList_t@CStudioModelRenderer@@QAEPAXI@Z PROC NEAR ; CStudioModelRenderer::DecalModelList_t::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DecalModelList_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::DecalModelList_t::~DecalModelList_t
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L74915
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L74915:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDecalModelList_t@CStudioModelRenderer@@QAEPAXI@Z ENDP ; CStudioModelRenderer::DecalModelList_t::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0BoneCache_t@CStudioModelRenderer@@QAE@XZ	; CStudioModelRenderer::BoneCache_t::BoneCache_t
PUBLIC	??0StudioAttachment_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::StudioAttachment_t::StudioAttachment_t
PUBLIC	??0Radian@@QAE@XZ				; Radian::Radian
PUBLIC	??0mstudiolight_t@@QAE@XZ			; mstudiolight_t::mstudiolight_t
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ PROC NEAR ; CStudioModelRenderer::ModelInstance_t::ModelInstance_t, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??0mstudiolight_t@@QAE@XZ		; mstudiolight_t::mstudiolight_t
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	8
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	call	??0BoneCache_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::BoneCache_t::BoneCache_t
	push	OFFSET FLAT:??0StudioAttachment_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::StudioAttachment_t::StudioAttachment_t
	push	64					; 00000040H
	push	104					; 00000068H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 352				; 00000160H
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 7308				; 00001c8cH
	call	??0CIKContext@@QAE@XZ			; CIKContext::CIKContext
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 11452				; 00002cbcH
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 11500				; 00002cecH
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4
	push	OFFSET FLAT:??0matrix3x4@@QAE@XZ	; matrix3x4::matrix3x4
	push	128					; 00000080H
	push	48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 11548				; 00002d1cH
	push	edx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0matrix3x4@@QAE@XZ	; matrix3x4::matrix3x4
	push	128					; 00000080H
	push	48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 17692				; 0000451cH
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Radian@@QAE@XZ		; Radian::Radian
	push	128					; 00000080H
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 23836				; 00005d1cH
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	128					; 00000080H
	push	12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 25372				; 0000631cH
	push	edx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	128					; 00000080H
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 26916				; 00006924H
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	128					; 00000080H
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28964				; 00007124H
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	128					; 00000080H
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 30500				; 00007724H
	push	edx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	128					; 00000080H
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32548				; 00007f24H
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 7308				; 00001c8cH
	call	??1CIKContext@@QAE@XZ			; CIKContext::~CIKContext
	ret	0
__ehhandler$??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0ModelInstance_t@CStudioModelRenderer@@QAE@XZ ENDP	; CStudioModelRenderer::ModelInstance_t::ModelInstance_t
;	COMDAT ??0Radian@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Radian@@QAE@XZ PROC NEAR				; Radian::Radian, COMDAT

; 362  : 	inline Radian( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Radian@@QAE@XZ ENDP					; Radian::Radian
_TEXT	ENDS
PUBLIC	??1ModelInstance_t@CStudioModelRenderer@@QAE@XZ	; CStudioModelRenderer::ModelInstance_t::~ModelInstance_t
;	COMDAT ??_GModelInstance_t@CStudioModelRenderer@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GModelInstance_t@CStudioModelRenderer@@QAEPAXI@Z PROC NEAR ; CStudioModelRenderer::ModelInstance_t::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ModelInstance_t@CStudioModelRenderer@@QAE@XZ ; CStudioModelRenderer::ModelInstance_t::~ModelInstance_t
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L74930
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L74930:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GModelInstance_t@CStudioModelRenderer@@QAEPAXI@Z ENDP ; CStudioModelRenderer::ModelInstance_t::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>
;	COMDAT ??1DecalModelList_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1DecalModelList_t@CStudioModelRenderer@@QAE@XZ PROC NEAR ; CStudioModelRenderer::DecalModelList_t::~DecalModelList_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1DecalModelList_t@CStudioModelRenderer@@QAE@XZ ENDP	; CStudioModelRenderer::DecalModelList_t::~DecalModelList_t
_TEXT	ENDS
;	COMDAT ??0mstudiolight_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0mstudiolight_t@@QAE@XZ PROC NEAR			; mstudiolight_t::mstudiolight_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0mstudiolight_t@@QAE@XZ ENDP				; mstudiolight_t::mstudiolight_t
_TEXT	ENDS
;	COMDAT ??0BoneCache_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0BoneCache_t@CStudioModelRenderer@@QAE@XZ PROC NEAR	; CStudioModelRenderer::BoneCache_t::BoneCache_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0BoneCache_t@CStudioModelRenderer@@QAE@XZ ENDP	; CStudioModelRenderer::BoneCache_t::BoneCache_t
_TEXT	ENDS
;	COMDAT ??0StudioAttachment_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0StudioAttachment_t@CStudioModelRenderer@@QAE@XZ PROC NEAR ; CStudioModelRenderer::StudioAttachment_t::StudioAttachment_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0StudioAttachment_t@CStudioModelRenderer@@QAE@XZ ENDP	; CStudioModelRenderer::StudioAttachment_t::StudioAttachment_t
_TEXT	ENDS
;	COMDAT ??1ModelInstance_t@CStudioModelRenderer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1ModelInstance_t@CStudioModelRenderer@@QAE@XZ PROC NEAR ; CStudioModelRenderer::ModelInstance_t::~ModelInstance_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 7308				; 00001c8cH
	call	??1CIKContext@@QAE@XZ			; CIKContext::~CIKContext
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1ModelInstance_t@CStudioModelRenderer@@QAE@XZ ENDP	; CStudioModelRenderer::ModelInstance_t::~ModelInstance_t
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z PROC NEAR ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEAAVCIKTarget@@H@Z ; CUtlMemoryFixed<CIKTarget,12,0>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Element
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAVCIKTarget@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAVCIKTarget@@@Z PROC NEAR		; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	336					; 00000150H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAVCIKTarget@@@Z ENDP			; Destruct
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::operator[]
;	COMDAT ?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z PROC NEAR ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
_TEXT	ENDS
PUBLIC	??_G?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAXI@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::`scalar deleting destructor'
;	COMDAT ?Destruct@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z PROC NEAR ; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();

	push	0
	mov	ecx, DWORD PTR _pMemory$[ebp]
	call	??_G?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAXI@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::`scalar deleting destructor'

; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	20					; 00000014H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ENDP ; Destruct
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsReadOnly
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@Uikcontextikrule_t@@H@@QAEAAUikcontextikrule_t@@H@Z ; CUtlMemory<ikcontextikrule_t,int>::operator[]
;	COMDAT ?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z PROC NEAR ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@Uikcontextikrule_t@@H@@QAEAAUikcontextikrule_t@@H@Z ; CUtlMemory<ikcontextikrule_t,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUikcontextikrule_t@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUikcontextikrule_t@@@Z PROC NEAR	; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	132					; 00000084H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUikcontextikrule_t@@@Z ENDP		; Destruct
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<ikcontextikrule_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ENDP ; CUtlMemory<ikcontextikrule_t,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<ikcontextikrule_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ENDP ; CUtlMemory<ikcontextikrule_t,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalMaterial_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalMaterial_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77141
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77141:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L77144
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L77144
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L77145
$L77144:
	mov	DWORD PTR -8+[ebp], 0
$L77145:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalModelList_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalModelList_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
_TEXT	ENDS
PUBLIC	?Previous@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Previous
;	COMDAT ?IsInList@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsInList@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsInList, COMDAT

; 284  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 285  : 	return (i < m_TotalElements) && (i >= 0) && (Previous(i) != i);

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L77150
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L77150
	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Previous@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEGG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Previous
	and	eax, 65535				; 0000ffffH
	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 65535				; 0000ffffH
	cmp	eax, edx
	je	SHORT $L77150
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L77151
$L77150:
	mov	DWORD PTR -8+[ebp], 0
$L77151:
	mov	al, BYTE PTR -8+[ebp]

; 286  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsInList@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsInList
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEHXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEHXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::NumAllocated
_TEXT	ENDS
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEXH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L77156
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77156:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L75004

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L77157
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77157:

; 567  : 		return;

	jmp	$L75001
$L75004:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	34096					; 00008530H
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L75023

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L75015
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L75015

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L75023
$L75015:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L75019

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L77158
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77158:

; 589  : 				return;

	jmp	$L75001
$L75019:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L75023

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L75019
$L75023:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L75026

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 34096				; 00008530H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L77159
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77159:

; 603  : 	else

	jmp	SHORT $L77160
$L75026:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 34096				; 00008530H
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L77160
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77160:
$L75001:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QAEXH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L64793

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L64798
$L64793:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L64795

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L64795:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L64798

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L64795
$L64798:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@GH@@QAEXXZ			; CUtlMemory<unsigned short,int>::Purge
PUBLIC	?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ResetDbgInfo
;	COMDAT ?Purge@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@GH@@QAEXXZ		; CUtlMemory<unsigned short,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ ENDP	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Purge
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@GH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@GH@@QAE@XZ PROC NEAR			; CUtlMemory<unsigned short,int>::~CUtlMemory<unsigned short,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@GH@@QAEXXZ		; CUtlMemory<unsigned short,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@GH@@QAE@XZ ENDP				; CUtlMemory<unsigned short,int>::~CUtlMemory<unsigned short,int>
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAUDecalVertex_t@@@Z		; Destruct
PUBLIC	?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Element
PUBLIC	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
PUBLIC	?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsValidIndex
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_prev$ = -8
_i$ = -12
?RemoveAll@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXXZ PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::RemoveAll, COMDAT

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 524  : 	if (m_TotalElements == 0)

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $L75047

; 525  : 		return;

	jmp	$L75046
$L75047:

; 526  : 
; 527  : 	// Put everything into the free list
; 528  : 	I prev = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	mov	WORD PTR _prev$[ebp], ax

; 529  : 	for (int i = (int)m_TotalElements; --i >= 0; )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	DWORD PTR _i$[ebp], eax
$L75052:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L75053

; 531  : 		// Invoke the destructor
; 532  : 		if (IsValidIndex((I)i))

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L75055

; 533  : 			Destruct( &Element((I)i) );

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::Element
	push	eax
	call	?Destruct@@YAXPAUDecalVertex_t@@@Z	; Destruct
	add	esp, 4
$L75055:

; 534  : 		
; 535  : 		// next points to the next free list item
; 536  : 		InternalElement((I)i).m_Next = prev;

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	dx, WORD PTR _prev$[ebp]
	mov	WORD PTR [eax+66], dx

; 537  : 		
; 538  : 		// Indicates it's in the free list
; 539  : 		InternalElement((I)i).m_Previous = (I)i;

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+64], cx

; 540  : 		prev = (I)i;

	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR _prev$[ebp], dx

; 541  : 	}

	jmp	SHORT $L75052
$L75053:

; 542  : 	
; 543  : 	// First free points to the first element
; 544  : 	m_FirstFree = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+16], 0

; 545  : 	
; 546  : 	// Clear everything else out
; 547  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 548  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 549  : 	m_ElementCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0
$L75046:

; 550  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEXXZ ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::RemoveAll
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Purge
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAE@XZ ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z ; Destruct
PUBLIC	?Element@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Element
PUBLIC	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
PUBLIC	?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsValidIndex
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_prev$ = -8
_i$ = -12
?RemoveAll@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::RemoveAll, COMDAT

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 524  : 	if (m_TotalElements == 0)

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $L75071

; 525  : 		return;

	jmp	$L75070
$L75071:

; 526  : 
; 527  : 	// Put everything into the free list
; 528  : 	I prev = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	mov	WORD PTR _prev$[ebp], ax

; 529  : 	for (int i = (int)m_TotalElements; --i >= 0; )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	DWORD PTR _i$[ebp], eax
$L75076:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L75077

; 531  : 		// Invoke the destructor
; 532  : 		if (IsValidIndex((I)i))

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L75079

; 533  : 			Destruct( &Element((I)i) );

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Element
	push	eax
	call	?Destruct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z ; Destruct
	add	esp, 4
$L75079:

; 534  : 		
; 535  : 		// next points to the next free list item
; 536  : 		InternalElement((I)i).m_Next = prev;

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	dx, WORD PTR _prev$[ebp]
	mov	WORD PTR [eax+74], dx

; 537  : 		
; 538  : 		// Indicates it's in the free list
; 539  : 		InternalElement((I)i).m_Previous = (I)i;

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+72], cx

; 540  : 		prev = (I)i;

	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR _prev$[ebp], dx

; 541  : 	}

	jmp	SHORT $L75076
$L75077:

; 542  : 	
; 543  : 	// First free points to the first element
; 544  : 	m_FirstFree = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+16], 0

; 545  : 	
; 546  : 	// Clear everything else out
; 547  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 548  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 549  : 	m_ElementCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0
$L75070:

; 550  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::RemoveAll
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Purge
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAE@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::RemoveAll
PUBLIC	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utllinkedlist.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 182  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::RemoveAll

; 183  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>
	ret	0
__ehhandler$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAE@XZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::~CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>
;	COMDAT ??_G?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_G?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAXI@Z PROC NEAR ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::~CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L75098
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L75098:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAXI@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base
;	COMDAT ?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@GV?$CUtlMemory@GH@@@@IAEXXZ ENDP ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::ResetDbgInfo
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex, COMDAT

; 100  : 	inline static I  InvalidIndex()  { return INVALID_LLIST_IDX; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	or	ax, 65535				; 0000ffffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@SAGXZ ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::InvalidIndex
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT
_this$ = -4
_i$ = 8
?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement, COMDAT

; 135  : 	ListElem_t& InternalElement( I i ) { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecalVertex_t@@G@@IAEAAUListElem_t@1@G@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::InternalElement
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex, COMDAT

; 100  : 	inline static I  InvalidIndex()  { return INVALID_LLIST_IDX; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	or	ax, 65535				; 0000ffffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@SAGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InvalidIndex
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT
_this$ = -4
_i$ = 8
?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement, COMDAT

; 135  : 	ListElem_t& InternalElement( I i ) { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::InternalElement
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@GH@@QAEPAGXZ			; CUtlMemory<unsigned short,int>::Base
;	COMDAT ?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@GH@@QAEPAGXZ		; CUtlMemory<unsigned short,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEPAGXZ ENDP	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Base
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NH@Z ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsIdxValid
;	COMDAT ??A?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z PROC NEAR ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L77202
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77202:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NH@Z ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77203
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77203:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::operator[]
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NH@Z ; CUtlMemory<ikcontextikrule_t,int>::IsIdxValid
;	COMDAT ??A?$CUtlMemory@Uikcontextikrule_t@@H@@QAEAAUikcontextikrule_t@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@Uikcontextikrule_t@@H@@QAEAAUikcontextikrule_t@@H@Z PROC NEAR ; CUtlMemory<ikcontextikrule_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ; CUtlMemory<ikcontextikrule_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L77206
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77206:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NH@Z ; CUtlMemory<ikcontextikrule_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77207
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77207:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@Uikcontextikrule_t@@H@@QAEAAUikcontextikrule_t@@H@Z ENDP ; CUtlMemory<ikcontextikrule_t,int>::operator[]
_TEXT	ENDS
PUBLIC	??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@	; `string'
PUBLIC	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
;	COMDAT ??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utllinkedlist.h
CONST	SEGMENT
??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@ DB 'IsValidIndex(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ?Previous@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Previous@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEGG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Previous, COMDAT

; 258  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 259  : 	assert( IsValidIndex(i) ); 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77210
	push	259					; 00000103H
	push	OFFSET FLAT:??_C@_0CJ@MAMB@z?3?2xashxtsrc?2game_shared?2utllink@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77210:

; 260  : 	return InternalElement(i).m_Previous; 

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
	mov	ax, WORD PTR [eax+34092]

; 261  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Previous@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEGG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::Previous
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element
PUBLIC	?Destruct@@YAXPAG@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L75134:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L75135

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element
	push	eax
	call	?Destruct@@YAXPAG@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L75134
$L75135:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEXXZ ENDP	; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ		; CUtlMemory<unsigned short,int>::IsReadOnly
;	COMDAT ?Base@?$CUtlMemory@GH@@QAEPAGXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@GH@@QAEPAGXZ PROC NEAR		; CUtlMemory<unsigned short,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ	; CUtlMemory<unsigned short,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L77215
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77215:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@GH@@QAEPAGXZ ENDP			; CUtlMemory<unsigned short,int>::Base
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@GH@@QBE_NXZ	; CUtlMemory<unsigned short,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@GH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@GH@@QAEXXZ PROC NEAR		; CUtlMemory<unsigned short,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@GH@@QBE_NXZ ; CUtlMemory<unsigned short,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75147

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L75148

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L75148:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L75147:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@GH@@QAEXXZ ENDP			; CUtlMemory<unsigned short,int>::Purge
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::Element, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]

; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlLinkedList@UDecalVertex_t@@G@@QAEAAUDecalVertex_t@@G@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::Element
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsValidIndex, COMDAT

; 277  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return (i < m_TotalElements) && (i >= 0) &&
; 279  : 		((m_Memory[i].m_Previous != i) || (m_Memory[i].m_Next == i));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L77222
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L77222
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+64]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L77223
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+66]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L77222
$L77223:
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L77224
$L77222:
	mov	DWORD PTR -8+[ebp], 0
$L77224:
	mov	al, BYTE PTR -8+[ebp]

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlLinkedList@UDecalVertex_t@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<DecalVertex_t,unsigned short>::IsValidIndex
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecalVertex_t@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUDecalVertex_t@@@Z PROC NEAR		; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	64					; 00000040H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUDecalVertex_t@@@Z ENDP			; Destruct
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L77229
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77229:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77230
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77230:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75169

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L75170

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L75170:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L75169:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::Purge
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Element, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]

; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QAEAAUDecal_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::Element
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsValidIndex, COMDAT

; 277  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return (i < m_TotalElements) && (i >= 0) &&
; 279  : 		((m_Memory[i].m_Previous != i) || (m_Memory[i].m_Next == i));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L77237
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L77237
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+72]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L77238
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+74]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L77237
$L77238:
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L77239
$L77237:
	mov	DWORD PTR -8+[ebp], 0
$L77239:
	mov	al, BYTE PTR -8+[ebp]

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::IsValidIndex
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z PROC NEAR ; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	72					; 00000048H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUDecal_t@CStudioModelRenderer@@@Z ENDP	; Destruct
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L77244
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77244:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77245
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77245:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75191

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L75192

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L75192:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L75191:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::Purge
_TEXT	ENDS
PUBLIC	?Element@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Element
PUBLIC	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
PUBLIC	?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsValidIndex
PUBLIC	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
PUBLIC	?Destruct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z ; Destruct
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_prev$ = -8
_i$ = -12
?RemoveAll@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::RemoveAll, COMDAT

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 524  : 	if (m_TotalElements == 0)

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $L75197

; 525  : 		return;

	jmp	$L75196
$L75197:

; 526  : 
; 527  : 	// Put everything into the free list
; 528  : 	I prev = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	mov	WORD PTR _prev$[ebp], ax

; 529  : 	for (int i = (int)m_TotalElements; --i >= 0; )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	DWORD PTR _i$[ebp], eax
$L75202:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L75203

; 531  : 		// Invoke the destructor
; 532  : 		if (IsValidIndex((I)i))

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L75205

; 533  : 			Destruct( &Element((I)i) );

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Element
	push	eax
	call	?Destruct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z ; Destruct
	add	esp, 4
$L75205:

; 534  : 		
; 535  : 		// next points to the next free list item
; 536  : 		InternalElement((I)i).m_Next = prev;

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	mov	dx, WORD PTR _prev$[ebp]
	mov	WORD PTR [eax+6], dx

; 537  : 		
; 538  : 		// Indicates it's in the free list
; 539  : 		InternalElement((I)i).m_Previous = (I)i;

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+4], cx

; 540  : 		prev = (I)i;

	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR _prev$[ebp], dx

; 541  : 	}

	jmp	SHORT $L75202
$L75203:

; 542  : 	
; 543  : 	// First free points to the first element
; 544  : 	m_FirstFree = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+16], 0

; 545  : 	
; 546  : 	// Clear everything else out
; 547  : 	m_Head = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 548  : 	m_Tail = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+14], ax

; 549  : 	m_ElementCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0
$L75196:

; 550  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEXXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::RemoveAll
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Purge
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAE@XZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::~CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex, COMDAT

; 100  : 	inline static I  InvalidIndex()  { return INVALID_LLIST_IDX; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	or	ax, 65535				; 0000ffffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@SAGXZ ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InvalidIndex
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement, COMDAT

; 135  : 	ListElem_t& InternalElement( I i ) { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@IAEAAUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::InternalElement
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z
_TEXT	SEGMENT
_this$ = -4
_i$ = 8
?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement, COMDAT

; 136  : 	ListElem_t const& InternalElement( I i ) const { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::ListElem_t,int>::operator[]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@IBEABUListElem_t@1@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::ModelInstance_t,unsigned short>::InternalElement
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L77260
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L77260
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L77261
$L77260:
	mov	DWORD PTR -8+[ebp], 0
$L77261:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsIdxValid
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<ikcontextikrule_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L77264
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L77264
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L77265
$L77264:
	mov	DWORD PTR -8+[ebp], 0
$L77265:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NH@Z ENDP ; CUtlMemory<ikcontextikrule_t,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@GH@@QAEAAGH@Z			; CUtlMemory<unsigned short,int>::operator[]
;	COMDAT ?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z PROC NEAR ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@GH@@QAEAAGH@Z		; CUtlMemory<unsigned short,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@GV?$CUtlMemory@GH@@@@QAEAAGH@Z ENDP ; CUtlArray<unsigned short,CUtlMemory<unsigned short,int> >::Element
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAG@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAG@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	2
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAG@Z ENDP				; Destruct
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@GH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@GH@@QBE_NXZ PROC NEAR ; CUtlMemory<unsigned short,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@GH@@QBE_NXZ ENDP	; CUtlMemory<unsigned short,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ PROC NEAR		; CUtlMemory<unsigned short,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ ENDP		; CUtlMemory<unsigned short,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77276
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77276:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 68					; 00000044H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L77279
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L77279
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L77280
$L77279:
	mov	DWORD PTR -8+[ebp], 0
$L77280:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalVertex_t@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<DecalVertex_t,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77287
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77287:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L77290
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L77290
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L77291
$L77290:
	mov	DWORD PTR -8+[ebp], 0
$L77291:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecal_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::Decal_t,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Element, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	return m_Memory[i].m_Element; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]

; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QAEAAUDecalHistory_t@CStudioModelRenderer@@G@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::Element
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z PROC NEAR ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsValidIndex, COMDAT

; 277  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return (i < m_TotalElements) && (i >= 0) &&
; 279  : 		((m_Memory[i].m_Previous != i) || (m_Memory[i].m_Next == i));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $L77300
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L77300
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L77301
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
	xor	edx, edx
	mov	dx, WORD PTR [eax+6]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	edx, eax
	jne	SHORT $L77300
$L77301:
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L77302
$L77300:
	mov	DWORD PTR -8+[ebp], 0
$L77302:
	mov	al, BYTE PTR -8+[ebp]

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::IsValidIndex
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z PROC NEAR ; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUDecalHistory_t@CStudioModelRenderer@@@Z ENDP ; Destruct
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L77307
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77307:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77308
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77308:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L75301

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L75302

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L75302:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L75301:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QAEXXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::Purge
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@GH@@QBE_NH@Z		; CUtlMemory<unsigned short,int>::IsIdxValid
;	COMDAT ??A?$CUtlMemory@GH@@QAEAAGH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@GH@@QAEAAGH@Z PROC NEAR			; CUtlMemory<unsigned short,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@GH@@QBE_NXZ	; CUtlMemory<unsigned short,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L77313
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77313:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@GH@@QBE_NH@Z	; CUtlMemory<unsigned short,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77314
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77314:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*2]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@GH@@QAEAAGH@Z ENDP			; CUtlMemory<unsigned short,int>::operator[]
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L77317
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L77317:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L77320
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L77320
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L77321
$L77320:
	mov	DWORD PTR -8+[ebp], 0
$L77321:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UDecalHistory_t@CStudioModelRenderer@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<CStudioModelRenderer::DecalHistory_t,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@GH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@GH@@QBE_NH@Z PROC NEAR		; CUtlMemory<unsigned short,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L77328
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L77328
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L77329
$L77328:
	mov	DWORD PTR -8+[ebp], 0
$L77329:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@GH@@QBE_NH@Z ENDP		; CUtlMemory<unsigned short,int>::IsIdxValid
_TEXT	ENDS
END
