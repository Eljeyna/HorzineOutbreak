	TITLE	Z:\XashXTSRC\client\render\r_shader.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0CN@DDDA@GL_PrintInfoLog?3?5message?5exceeds@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@GBE@GL_PrintShaderSource?3?5message?5ex@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@ICLD@GL_PushFileStack?3?5stack?5overflow@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@LKDI@GL_PushFileStack?3?5stack?5underflo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@OIMK@recursive?5include?5for?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@LNAL@couldn?8t?5load?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08POEE@?$CDline?50?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08HOOI@?$CDinclude?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07GDNJ@glsl?1?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09EDEG@?$CDline?5?$CFi?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HHKO@?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@CNKF@?$CDversion?5120?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@NELG@?$CDifndef?5M_PI?6?$CDdefine?5M_PI?53?41415@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@JDPI@?$CDifndef?5M_PI2?6?$CDdefine?5M_PI2?56?428@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DKLD@?$CDextension?5GL_EXT_gpu_shader4?5?3?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@ODNP@?$CDdefine?5GLSL_gpu_shader4?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@FIBF@?$CDdefine?5GLSL_ALLOW_TEXTURE_ARRAY@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@ICPE@?$CDextension?5GL_EXT_texture_array?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BENL@?$CDifndef?5MAXSTUDIOBONES?6?$CDdefine?5M@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@DFIJ@?$CDifndef?5MAX_LIGHTSTYLES?6?$CDdefine?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DF@GEGD@?$CDifndef?5MAXLIGHTMAPS?6?$CDdefine?5MAX@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@LILL@?$CDifndef?5GRASS_ANIM_DIST?6?$CDdefine?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@PHEN@glsl?1?$CFs_vp?4glsl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@BOBH@glsl?1?$CFs_fp?4glsl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@FCBH@GL_LoadGPUShader?3?5unknown?5shader@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@BLBN@loading?5?8?$CFs?8?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DILL@?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@BJIP@Shader?5options?3?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@GPIL@Couldn?8t?5compile?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@PJK@?$CFs?6?$CFs?5shader?5failed?5to?5link?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@JNHB@?$CFs?6?$CFs?5shader?5failed?5to?5validate?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03EMIM@int?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04FHHA@uint?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PIME@float?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04EDIP@vec2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OJBI@vec3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LMPN@vec4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BAGO@mat2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LKPJ@mat3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OPBM@mat4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MINJ@sampler1D?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09PDCG@sampler2D?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09OFIM@sampler3D?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OHEM@samplerCube?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@FJJF@sampler1DArray?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@CKCL@sampler2DArray?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LEFG@sampler1DShadow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMCF@sampler2DShadow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@CEBP@sampler2DRect?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@FHO@sampler2DRectShadow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@PGNK@samplerCubeShadow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03NMFM@?$DP?$DP?$DP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@FLLN@uniform?5?$CFs?5?$CFs?$DL?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@BIMD@uniform?5?$CFs?5?$CFs?$FL?$CFi?$FN?$DL?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@NOKH@used?5uniforms?5?$CFi?5is?5overflowed?5m@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@JLNN@used?5uniforms?5?$CFi?5from?5?$CFi?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IGF@?$CFs?5used?5?$CFi?5uniforms?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JKGE@?$CFs?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@DBCF@GL_InitGPUShader?3?5GLSL?5shaders?5l@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@GCHP@attr_Position?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@FMMD@attr_TexCoord0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@PGFE@attr_TexCoord1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@JON@attr_TexCoord2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@NANC@attr_Normal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HOGI@attr_BoneIndexes?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@CBFE@attr_BoneWeights?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FGGJ@attr_LightStyles?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GOGD@attr_LightColor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@EPKC@attr_LightVecs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DL@BILI@GL_CreateUberShader?3?5GLSL?5shader@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@BLMD@CompileUberShader?5?$CD?$CFi?3?5?$CFs?6?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU2@@Z@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@CGMG@?$CDdefine?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@CEPF@u_ColorMap?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@ICKK@u_DetailMap?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NGMC@u_LightMap?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@CDNB@u_ScreenMap?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09EKDB@u_GlowMap?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@DAAC@BMODEL_MULTI_LAYERS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@DCKL@u_HeightMap?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@JGPP@u_LightStyleValues?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@NMNP@u_ModelMatrix?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@DNJP@u_DetailScale?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OCHJ@u_TexOffset?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BNFL@u_FogParams?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLKN@u_ScreenSizeInv?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@IEKC@u_RenderColor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06OPNC@u_zFar?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitSolidBmodelUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@GDLB@u_ProjectMap?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@KOBB@u_ShadowMap?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PEBL@u_LightDir?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@FEGO@u_LightDiffuse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@IHNO@u_ShadowParams?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@IPOH@u_LightOrigin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@MOPE@u_LightViewProjectionMatrix?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitBmodelDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitBmodelDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@NBHD@u_DecalMap?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitBmodelDecalUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DNPD@u_BoneQuaternion?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@IFJG@u_BonePosition?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@LEI@STUDIO_VERTEX_LIGHTING?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MPOJ@u_LightStyles?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@OCGF@u_GammaTable?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@OOMD@u_LightColor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@HHOG@u_LightAmbient?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@OOOP@u_LightShade?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@HFAH@u_ViewOrigin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@ILDE@u_ViewRight?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitSolidStudioUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitStudioDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitStudioDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DDGN@u_GrassFadeStart?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@NNKA@u_GrassFadeDist?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@GDAL@u_GrassFadeEnd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HAJO@u_RealTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitGrassSolidUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitGrassDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@BONN@u_LightScale?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitGenericDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitStudioDecalUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitSkyBoxUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@CGPN@u_BlurFactor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitPostProcessUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitGenericFogUniforms@@YAXPAUglsl_prog_s@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@ICDM@u_DepthMap?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitGenShaftsUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??GL_InitDrawShaftsUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07GIIJ@?$CDdefine?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@IHGG@BmodelSolid?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBPO@BMODEL_MONOCHROME?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@HJK@BMODEL_FULLBRIGHT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@CMPL@BMODEL_APPLY_STYLE?$CFi?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@CGBF@BMODEL_HAS_LUMA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@JDPH@BMODEL_DRAWTURB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@LEMI@BMODEL_WAVEHEIGHT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@DHNK@TERRAIN_NUM_LAYERS?5?$CFi?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@CMG@BMODEL_HAS_DETAIL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BDDM@BMODEL_REFLECTION_PLANAR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@EFAO@BMODEL_FOG_EXP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GL_UberShaderForSolidBmodel@@YAGPAUmsurface_s@@_N@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@JHKA@BmodelDlight?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@EAPG@BMODEL_LIGHT_OMNIDIRECTIONAL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@FIEA@BMODEL_LIGHT_PROJECTION?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@KLBC@BMODEL_HAS_SHADOWS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OMCN@GrassSolid?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@DNNA@GRASS_FULLBRIGHT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GEKE@GRASS_APPLY_STYLE?$CFi?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@LGNN@GRASS_FOG_EXP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@HJML@GrassDlight?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@CDCB@GRASS_LIGHT_OMNIDIRECTIONAL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@GPJF@GRASS_LIGHT_PROJECTION?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@CHCI@GRASS_HAS_SHADOWS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@EKMF@BmodelDecal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@JFJO@DECAL_APPLY_STYLE?$CFi?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@OEHD@DECAL_ALPHATEST?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HMDN@DECAL_FULLBRIGHT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@NFNC@DECAL_FOG_EXP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GL_UberShaderForBmodelDecal@@YAGPAUdecal_s@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@KKJ@StudioSolid?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@GCND@?$CDdefine?5MAXSTUDIOBONES?5?$CFd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@CJHN@?$CDdefine?5MAXSTUDIOBONES?51?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOAP@STUDIO_BONEWEIGHTING?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@ILPH@STUDIO_HAS_CHROME?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@EAPK@STUDIO_FULLBRIGHT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@OLBI@STUDIO_LIGHT_FLATSHADE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@EBHP@STUDIO_FOG_EXP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@LNCN@StudioDlight?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@HFAD@STUDIO_LIGHT_OMNIDIRECTIONAL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@LBGG@STUDIO_LIGHT_PROJECTION?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@NHFF@STUDIO_HAS_SHADOWS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@MHAK@StudioDecal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@FBLB@STUDIO_ALPHA_GLASS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@ONKA@GenericDlight?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@GGLJ@GENERIC_LIGHT_OMNIDIRECTIONAL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DEA@GENERIC_LIGHT_PROJECTION?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@ENIE@GENERIC_FOG_EXP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@PHFM@GENERIC_HAS_SHADOWS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@EGKO@?$CD?$CFi?5?$CFs?5?$FL?$CFs?$FN?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07KHDD@?$CD?$CFi?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@MLEK@total?5?$CFi?5shaders?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OIIH@shaderlist?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DMKC@genshafts?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07LFGH@generic?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@PBCC@GenSunShafts?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HHEC@drawshafts?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@PBJN@DrawSunShafts?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LPOA@?$CDdefine?5BLUR_X?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09PGBC@gaussblur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@FMEL@HW_GaussBlurX?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@KJEK@?$CDdefine?5BLUR_Y?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@PGNM@HW_GaussBlurY?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06LCDM@skybox?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@IHBG@SkyBoxGeneric?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@JMKO@StudioDepth?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@GCPH@?$CDdefine?5STUDIO_BONEWEIGHTING?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BBGB@BmodelDepth?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@CBFB@BrushDepth?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HKCK@GrassDepth?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GABA@?$CDdefine?5GENERIC_FOG_EXP?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KDCB@GenericFog?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@QAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@Vector@@QAEXMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Random@RandomRange@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudBase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CHudBase@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VidInit@CHudBase@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@CHudBase@@UAEHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CHudBase@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@CHudBase@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitHUDData@CHudBase@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudBase@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudAmmo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudAmmo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudHealth@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudHealth@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudGeiger@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudGeiger@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudBattery@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudBattery@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudTrain@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudTrain@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudFlashlight@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudFlashlight@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudMessage@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudMessage@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudScoreboard@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudScoreboard@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudStatusBar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudStatusBar@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudDeathNotice@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudDeathNotice@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudSayText@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudSayText@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudMenu@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudMenu@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudAmmoSecondary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudAmmoSecondary@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudTextMessage@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudTextMessage@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudStatusIcons@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudStatusIcons@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudMOTD@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudMOTD@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ViewSmoothingData_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudAmmo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudBase@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudHealth@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudGeiger@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudBattery@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudTrain@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudFlashlight@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudMessage@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudScoreboard@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudStatusBar@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudDeathNotice@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudSayText@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudMenu@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudAmmoSecondary@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudTextMessage@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudStatusIcons@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudMOTD@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pHitboxSet@CStudioBoneSetup@@QBEPAUmstudiohitboxset_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitBoneWeights@CStudioBoneSetup@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?debugMsg@CStudioBoneSetup@@UAAXPADZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?debugLine@CStudioBoneSetup@@UAEXABVVector@@0HHH_NM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@CVirtualFS@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@CVirtualFS@@QAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CVirtualFS@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CVirtualFS@@QAE@PBEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CVirtualFS@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Read@CVirtualFS@@QAEIPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Write@CVirtualFS@@QAEIPBXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Insert@CVirtualFS@@QAEIPBXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Print@CVirtualFS@@QAEIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IPrint@CVirtualFS@@QAEIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Printf@CVirtualFS@@QAAIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IPrintf@CVirtualFS@@QAAIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VPrintf@CVirtualFS@@QAEIPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IVPrintf@CVirtualFS@@QAEIPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Getc@CVirtualFS@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Gets@CVirtualFS@@QAEHPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Seek@CVirtualFS@@QAEHIH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_PrintInfoLog@@YAPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_PushFileStack@@YA_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_PopFileStack@@YA_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_CheckFileStack@@YA_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_LoadSource@@YA_NPBDPAVCVirtualFS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_ProcessShader@@YA_NPBDPAVCVirtualFS@@_N0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_LinkProgram@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_UniformTypeToDwordCount@@YAHI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_UniformTypeToName@@YAPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_BindShader@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_FreeGPUShader@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_CreateUberShader@@YAPAUglsl_prog_s@@IPBD0P6AXPAU1@@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU1@@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_AddShaderDirective@@YAXPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_AddShaderDefine@@YAXPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_FindShaderDirective@@YA_NPAUglsl_prog_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitSolidBmodelUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitBmodelDlightUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitBmodelDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitBmodelDecalUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitSolidStudioUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitStudioDlightUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitStudioDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitGrassSolidUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitGrassDlightUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitGenericDlightUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitStudioDecalUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitSkyBoxUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitPostProcessUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitGenericFogUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitGenShaftsUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitDrawShaftsUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_PretifyListOptions@@YAPBDPBD_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_UberShaderForSolidBmodel@@YAGPAUmsurface_s@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_UberShaderForBmodelDlight@@YAGPBUplight_s@@PAUmsurface_s@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_UberShaderForGrassSolid@@YAGPAUmsurface_s@@PAUgrass_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_UberShaderForGrassDlight@@YAGPAUplight_s@@PAUgrass_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_UberShaderForBmodelDecal@@YAGPAUdecal_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_UberShaderForSolidStudio@@YAGPAUmstudiomat_s@@_N11H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_UberShaderForDlightStudio@@YAGPBUplight_s@@PAUmstudiomat_s@@_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_UberShaderForStudioDecal@@YAGPAUmstudiomat_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_UberShaderForDlightGeneric@@YAGPBUplight_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_ListGPUShaders@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_InitGPUShaders@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0plight_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFrustum@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0mplane_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_FreeUberShaders@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GL_FreeGPUShaders@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UJiggleData@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUJiggleData@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CHudBase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CStudioBoneSetup@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudSayText@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudFlashlight@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudGeiger@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudDeathNotice@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudBattery@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudTrain@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudMenu@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudTextMessage@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudAmmo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudHealth@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudStatusIcons@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudAmmoSecondary@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudStatusBar@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudMessage@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudMOTD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudScoreboard@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?glsl_programs@@3PAUglsl_prog_s@@A		; glsl_programs
PUBLIC	?num_glsl_programs@@3IA				; num_glsl_programs
PUBLIC	?glsl@@3Uref_shaders_t@@A			; glsl
PUBLIC	?glsl_programsHashTable@@3PAPAUglsl_prog_s@@A	; glsl_programsHashTable
_BSS	SEGMENT
?glsl_programs@@3PAUglsl_prog_s@@A DB 06d800H DUP (?)	; glsl_programs
?num_glsl_programs@@3IA DD 01H DUP (?)			; num_glsl_programs
?glsl@@3Uref_shaders_t@@A DB 028H DUP (?)		; glsl
?glsl_programsHashTable@@3PAPAUglsl_prog_s@@A DD 080H DUP (?) ; glsl_programsHashTable
_BSS	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L55256:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L55257
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L55256
$L55257:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0CVirtualFS@@QAE@XZ				; CVirtualFS::CVirtualFS
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_memset:NEAR
;	COMDAT ??0CVirtualFS@@QAE@XZ
_TEXT	SEGMENT
$T72835 = -8
_this$ = -4
??0CVirtualFS@@QAE@XZ PROC NEAR				; CVirtualFS::CVirtualFS, COMDAT

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 	m_iBuffSize = FS_MEM_BLOCK; // can be resized later

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 65535		; 0000ffffH

; 44   : 	m_pBuffer = new byte[m_iBuffSize];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T72835[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T72835[ebp]
	mov	DWORD PTR [eax], ecx

; 45   : 	memset( m_pBuffer, 0, m_iBuffSize );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 46   : 	m_iLength = m_iOffset = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 47   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CVirtualFS@@QAE@XZ ENDP				; CVirtualFS::CVirtualFS
_TEXT	ENDS
PUBLIC	??0CVirtualFS@@QAE@PBEI@Z			; CVirtualFS::CVirtualFS
EXTRN	_memcpy:NEAR
;	COMDAT ??0CVirtualFS@@QAE@PBEI@Z
_TEXT	SEGMENT
$T72838 = -8
_file$ = 8
_size$ = 12
_this$ = -4
??0CVirtualFS@@QAE@PBEI@Z PROC NEAR			; CVirtualFS::CVirtualFS, COMDAT

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 	if( !file || size <= 0 )

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $L71122
	cmp	DWORD PTR _size$[ebp], 0
	ja	SHORT $L71121
$L71122:

; 53   : 		m_iBuffSize = m_iOffset = m_iLength = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 54   : 		m_pBuffer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 55   : 		return;

	jmp	SHORT $L71120
$L71121:

; 57   : 
; 58   : 	m_iLength = m_iBuffSize = size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 59   : 	m_pBuffer = new byte[m_iBuffSize];	

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T72838[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T72838[ebp]
	mov	DWORD PTR [ecx], edx

; 60   : 	memcpy( m_pBuffer, file, m_iBuffSize );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 61   : 	m_iOffset = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
$L71120:

; 62   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0CVirtualFS@@QAE@PBEI@Z ENDP				; CVirtualFS::CVirtualFS
_TEXT	ENDS
PUBLIC	??1CVirtualFS@@QAE@XZ				; CVirtualFS::~CVirtualFS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ??1CVirtualFS@@QAE@XZ
_TEXT	SEGMENT
$T72841 = -8
_this$ = -4
??1CVirtualFS@@QAE@XZ PROC NEAR				; CVirtualFS::~CVirtualFS, COMDAT

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	delete [] m_pBuffer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T72841[ebp], ecx
	mov	edx, DWORD PTR $T72841[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 67   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CVirtualFS@@QAE@XZ ENDP				; CVirtualFS::~CVirtualFS
_TEXT	ENDS
PUBLIC	?Read@CVirtualFS@@QAEIPADI@Z			; CVirtualFS::Read
;	COMDAT ?Read@CVirtualFS@@QAEIPADI@Z
_TEXT	SEGMENT
_out$ = 8
_size$ = 12
_this$ = -4
_read_size$ = -8
_reduced_size$71140 = -12
?Read@CVirtualFS@@QAEIPADI@Z PROC NEAR			; CVirtualFS::Read, COMDAT

; 70   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 	if( !m_pBuffer || !out || size <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L71135
	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $L71135
	cmp	DWORD PTR _size$[ebp], 0
	ja	SHORT $L71134
$L71135:

; 72   : 		return 0;

	xor	eax, eax
	jmp	$L71133
$L71134:

; 73   : 
; 74   : 	// check for enough room
; 75   : 	if( m_iOffset >= m_iLength )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+12]
	jb	SHORT $L71136

; 76   : 		return 0; // hit EOF

	xor	eax, eax
	jmp	$L71133
$L71136:

; 77   : 
; 78   : 	size_t read_size = 0;

	mov	DWORD PTR _read_size$[ebp], 0

; 79   : 
; 80   : 	if( m_iOffset + size <= m_iLength )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+12]
	ja	SHORT $L71138

; 82   : 		memcpy( out, m_pBuffer + m_iOffset, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	push	eax
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 83   : 		m_iOffset += size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 84   : 		read_size = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _read_size$[ebp], eax

; 86   : 	else

	jmp	SHORT $L71139
$L71138:

; 88   : 		int reduced_size = m_iLength - m_iOffset;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _reduced_size$71140[ebp], eax

; 89   : 		memcpy( out, m_pBuffer + m_iOffset, reduced_size );

	mov	ecx, DWORD PTR _reduced_size$71140[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	push	eax
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 90   : 		m_iOffset += reduced_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _reduced_size$71140[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 91   : 		read_size = reduced_size;

	mov	eax, DWORD PTR _reduced_size$71140[ebp]
	mov	DWORD PTR _read_size$[ebp], eax
$L71139:

; 93   : 
; 94   : 	return read_size;

	mov	eax, DWORD PTR _read_size$[ebp]
$L71133:

; 95   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Read@CVirtualFS@@QAEIPADI@Z ENDP			; CVirtualFS::Read
_TEXT	ENDS
PUBLIC	?Write@CVirtualFS@@QAEIPBXI@Z			; CVirtualFS::Write
EXTRN	_realloc:NEAR
;	COMDAT ?Write@CVirtualFS@@QAEIPBXI@Z
_TEXT	SEGMENT
_in$ = 8
_size$ = 12
_this$ = -4
_newsize$71148 = -8
?Write@CVirtualFS@@QAEIPBXI@Z PROC NEAR			; CVirtualFS::Write, COMDAT

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 	if( !m_pBuffer ) return -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L71146
	or	eax, -1
	jmp	$L71145
$L71146:

; 100  : 
; 101  : 	if( m_iOffset + size >= m_iBuffSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+4]
	jb	SHORT $L71149

; 103  : 		size_t newsize = m_iOffset + size + FS_MEM_BLOCK;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _size$[ebp]
	lea	ecx, DWORD PTR [edx+eax+65535]
	mov	DWORD PTR _newsize$71148[ebp], ecx

; 104  : 
; 105  : 		if( m_iBuffSize < newsize )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _newsize$71148[ebp]
	jae	SHORT $L71149

; 107  : 			// reallocate buffer now
; 108  : 			m_pBuffer = (byte *)realloc( m_pBuffer, newsize );

	mov	ecx, DWORD PTR _newsize$71148[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 109  : 			memset( m_pBuffer + m_iBuffSize, 0, newsize - m_iBuffSize );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newsize$71148[ebp]
	sub	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 110  : 			m_iBuffSize = newsize; // update buffsize

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newsize$71148[ebp]
	mov	DWORD PTR [ecx+4], edx
$L71149:

; 113  : 
; 114  : 	// write into buffer
; 115  : 	memcpy( m_pBuffer + m_iOffset, in, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 116  : 	m_iOffset += size;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 117  : 
; 118  : 	if( m_iOffset > m_iLength ) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	cmp	ecx, DWORD PTR [eax+12]
	jbe	SHORT $L71151

; 119  : 		m_iLength = m_iOffset;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+12], ecx
$L71151:

; 120  : 
; 121  : 	return m_iLength;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
$L71145:

; 122  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Write@CVirtualFS@@QAEIPBXI@Z ENDP			; CVirtualFS::Write
_TEXT	ENDS
PUBLIC	?Insert@CVirtualFS@@QAEIPBXI@Z			; CVirtualFS::Insert
;	COMDAT ?Insert@CVirtualFS@@QAEIPBXI@Z
_TEXT	SEGMENT
$T72848 = -20
$T72849 = -24
_in$ = 8
_size$ = 12
_this$ = -4
_newsize$71159 = -8
_rp_size$ = -12
_backup$ = -16
?Insert@CVirtualFS@@QAEIPBXI@Z PROC NEAR		; CVirtualFS::Insert, COMDAT

; 125  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 126  : 	if( !m_pBuffer ) return -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L71157
	or	eax, -1
	jmp	$L71156
$L71157:

; 127  : 
; 128  : 	if( m_iLength + size >= m_iBuffSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+4]
	jb	SHORT $L71160

; 130  : 		size_t newsize = m_iLength + size + FS_MEM_BLOCK;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _size$[ebp]
	lea	ecx, DWORD PTR [edx+eax+65535]
	mov	DWORD PTR _newsize$71159[ebp], ecx

; 131  : 
; 132  : 		if( m_iBuffSize < newsize )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _newsize$71159[ebp]
	jae	SHORT $L71160

; 134  : 			// reallocate buffer now
; 135  : 			m_pBuffer = (byte *)realloc( m_pBuffer, newsize );

	mov	ecx, DWORD PTR _newsize$71159[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 136  : 			memset( m_pBuffer + m_iBuffSize, 0, newsize - m_iBuffSize );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newsize$71159[ebp]
	sub	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 137  : 			m_iBuffSize = newsize; // update buffsize

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newsize$71159[ebp]
	mov	DWORD PTR [ecx+4], edx
$L71160:

; 140  : 
; 141  : 	// backup right part
; 142  : 	size_t rp_size = m_iLength - m_iOffset;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _rp_size$[ebp], edx

; 143  : 	byte *backup = new byte[rp_size];

	mov	eax, DWORD PTR _rp_size$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T72848[ebp], eax
	mov	ecx, DWORD PTR $T72848[ebp]
	mov	DWORD PTR _backup$[ebp], ecx

; 144  : 	memcpy( backup, m_pBuffer + m_iOffset, rp_size );

	mov	edx, DWORD PTR _rp_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	push	ecx
	mov	eax, DWORD PTR _backup$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 145  : 
; 146  : 	// insert into buffer
; 147  : 	memcpy( m_pBuffer + m_iOffset, in, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 148  : 	m_iOffset += size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 149  : 
; 150  : 	// write right part buffer
; 151  : 	memcpy( m_pBuffer + m_iOffset, backup, rp_size );

	mov	eax, DWORD PTR _rp_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _backup$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 152  : 	delete [] backup;

	mov	edx, DWORD PTR _backup$[ebp]
	mov	DWORD PTR $T72849[ebp], edx
	mov	eax, DWORD PTR $T72849[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 153  : 
; 154  : 	if(( m_iOffset + rp_size ) > m_iLength ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _rp_size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+12]
	jbe	SHORT $L71167

; 155  : 		m_iLength = m_iOffset + rp_size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _rp_size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$L71167:

; 156  : 
; 157  : 	return m_iLength;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
$L71156:

; 158  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@CVirtualFS@@QAEIPBXI@Z ENDP			; CVirtualFS::Insert
_TEXT	ENDS
PUBLIC	?Print@CVirtualFS@@QAEIPBD@Z			; CVirtualFS::Print
EXTRN	?Q_strlen@@YAHPBD@Z:NEAR			; Q_strlen
;	COMDAT ?Print@CVirtualFS@@QAEIPBD@Z
_TEXT	SEGMENT
_message$ = 8
_this$ = -4
?Print@CVirtualFS@@QAEIPBD@Z PROC NEAR			; CVirtualFS::Print, COMDAT

; 161  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 162  : 	return Write( message, Q_strlen( message ));

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Write

; 163  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Print@CVirtualFS@@QAEIPBD@Z ENDP			; CVirtualFS::Print
_TEXT	ENDS
PUBLIC	?IPrint@CVirtualFS@@QAEIPBD@Z			; CVirtualFS::IPrint
;	COMDAT ?IPrint@CVirtualFS@@QAEIPBD@Z
_TEXT	SEGMENT
_message$ = 8
_this$ = -4
?IPrint@CVirtualFS@@QAEIPBD@Z PROC NEAR			; CVirtualFS::IPrint, COMDAT

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 	return Insert( message, Q_strlen( message ));

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Insert

; 168  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IPrint@CVirtualFS@@QAEIPBD@Z ENDP			; CVirtualFS::IPrint
_TEXT	ENDS
PUBLIC	?Printf@CVirtualFS@@QAAIPBDZZ			; CVirtualFS::Printf
PUBLIC	?VPrintf@CVirtualFS@@QAEIPBDPAD@Z		; CVirtualFS::VPrintf
;	COMDAT ?Printf@CVirtualFS@@QAAIPBDZZ
_TEXT	SEGMENT
_fmt$ = 12
_this$ = 8
_result$ = -4
_args$ = -8
?Printf@CVirtualFS@@QAAIPBDZZ PROC NEAR			; CVirtualFS::Printf, COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 172  : 	size_t result;
; 173  : 	va_list args;
; 174  : 
; 175  : 	va_start( args, fmt );

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 176  : 	result = VPrintf( fmt, args );

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fmt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VPrintf@CVirtualFS@@QAEIPBDPAD@Z	; CVirtualFS::VPrintf
	mov	DWORD PTR _result$[ebp], eax

; 177  : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 178  : 
; 179  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 180  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Printf@CVirtualFS@@QAAIPBDZZ ENDP			; CVirtualFS::Printf
_TEXT	ENDS
PUBLIC	?IPrintf@CVirtualFS@@QAAIPBDZZ			; CVirtualFS::IPrintf
PUBLIC	?IVPrintf@CVirtualFS@@QAEIPBDPAD@Z		; CVirtualFS::IVPrintf
;	COMDAT ?IPrintf@CVirtualFS@@QAAIPBDZZ
_TEXT	SEGMENT
_fmt$ = 12
_this$ = 8
_result$ = -4
_args$ = -8
?IPrintf@CVirtualFS@@QAAIPBDZZ PROC NEAR		; CVirtualFS::IPrintf, COMDAT

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 184  : 	size_t result;
; 185  : 	va_list args;
; 186  : 
; 187  : 	va_start( args, fmt );

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 188  : 	result = IVPrintf( fmt, args );

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fmt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IVPrintf@CVirtualFS@@QAEIPBDPAD@Z	; CVirtualFS::IVPrintf
	mov	DWORD PTR _result$[ebp], eax

; 189  : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 190  : 
; 191  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 192  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IPrintf@CVirtualFS@@QAAIPBDZZ ENDP			; CVirtualFS::IPrintf
_TEXT	ENDS
EXTRN	?Q_vsnprintf@@YAHPADIPBD0@Z:NEAR		; Q_vsnprintf
;	COMDAT ?VPrintf@CVirtualFS@@QAEIPBDPAD@Z
_TEXT	SEGMENT
$T72860 = -20
$T72861 = -24
$T72862 = -28
_fmt$ = 8
_ap$ = 12
_this$ = -4
_buff_size$ = -8
_tempbuff$ = -12
_len$ = -16
?VPrintf@CVirtualFS@@QAEIPBDPAD@Z PROC NEAR		; CVirtualFS::VPrintf, COMDAT

; 195  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 196  : 	size_t	buff_size = FS_MSG_BLOCK;

	mov	DWORD PTR _buff_size$[ebp], 8192	; 00002000H
$L71207:

; 197  : 	char	*tempbuff;
; 198  : 	size_t	len;
; 199  : 
; 200  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $L71208

; 202  : 		tempbuff = new char[buff_size];

	mov	ecx, DWORD PTR _buff_size$[ebp]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T72860[ebp], eax
	mov	edx, DWORD PTR $T72860[ebp]
	mov	DWORD PTR _tempbuff$[ebp], edx

; 203  : 		len = Q_vsprintf( tempbuff, fmt, ap );

	mov	eax, DWORD PTR _ap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	push	99999					; 0001869fH
	mov	edx, DWORD PTR _tempbuff$[ebp]
	push	edx
	call	?Q_vsnprintf@@YAHPADIPBD0@Z		; Q_vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 204  : 		if( len >= 0 && len < buff_size )

	cmp	DWORD PTR _len$[ebp], 0
	jb	SHORT $L71211
	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _buff_size$[ebp]
	jae	SHORT $L71211

; 205  : 			break;

	jmp	SHORT $L71208
$L71211:

; 206  : 		delete [] tempbuff;

	mov	ecx, DWORD PTR _tempbuff$[ebp]
	mov	DWORD PTR $T72861[ebp], ecx
	mov	edx, DWORD PTR $T72861[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 207  : 		buff_size <<= 1;

	mov	eax, DWORD PTR _buff_size$[ebp]
	shl	eax, 1
	mov	DWORD PTR _buff_size$[ebp], eax

; 208  : 	}

	jmp	SHORT $L71207
$L71208:

; 209  : 
; 210  : 	len = Write( tempbuff, len );

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tempbuff$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Write
	mov	DWORD PTR _len$[ebp], eax

; 211  : 	delete [] tempbuff;

	mov	eax, DWORD PTR _tempbuff$[ebp]
	mov	DWORD PTR $T72862[ebp], eax
	mov	ecx, DWORD PTR $T72862[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 212  : 
; 213  : 	return len;

	mov	eax, DWORD PTR _len$[ebp]

; 214  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?VPrintf@CVirtualFS@@QAEIPBDPAD@Z ENDP			; CVirtualFS::VPrintf
_TEXT	ENDS
;	COMDAT ?IVPrintf@CVirtualFS@@QAEIPBDPAD@Z
_TEXT	SEGMENT
$T72865 = -20
$T72866 = -24
$T72867 = -28
_fmt$ = 8
_ap$ = 12
_this$ = -4
_buff_size$ = -8
_tempbuff$ = -12
_len$ = -16
?IVPrintf@CVirtualFS@@QAEIPBDPAD@Z PROC NEAR		; CVirtualFS::IVPrintf, COMDAT

; 217  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 218  : 	size_t	buff_size = FS_MSG_BLOCK;

	mov	DWORD PTR _buff_size$[ebp], 8192	; 00002000H
$L71223:

; 219  : 	char	*tempbuff;
; 220  : 	size_t	len;
; 221  : 
; 222  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $L71224

; 224  : 		tempbuff = new char[buff_size];

	mov	ecx, DWORD PTR _buff_size$[ebp]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T72865[ebp], eax
	mov	edx, DWORD PTR $T72865[ebp]
	mov	DWORD PTR _tempbuff$[ebp], edx

; 225  : 		len = Q_vsprintf( tempbuff, fmt, ap );

	mov	eax, DWORD PTR _ap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	push	99999					; 0001869fH
	mov	edx, DWORD PTR _tempbuff$[ebp]
	push	edx
	call	?Q_vsnprintf@@YAHPADIPBD0@Z		; Q_vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 226  : 		if( len >= 0 && len < buff_size )

	cmp	DWORD PTR _len$[ebp], 0
	jb	SHORT $L71227
	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _buff_size$[ebp]
	jae	SHORT $L71227

; 227  : 			break;

	jmp	SHORT $L71224
$L71227:

; 228  : 		delete [] tempbuff;

	mov	ecx, DWORD PTR _tempbuff$[ebp]
	mov	DWORD PTR $T72866[ebp], ecx
	mov	edx, DWORD PTR $T72866[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 229  : 		buff_size <<= 1;

	mov	eax, DWORD PTR _buff_size$[ebp]
	shl	eax, 1
	mov	DWORD PTR _buff_size$[ebp], eax

; 230  : 	}

	jmp	SHORT $L71223
$L71224:

; 231  : 
; 232  : 	len = Insert( tempbuff, len );

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tempbuff$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Insert
	mov	DWORD PTR _len$[ebp], eax

; 233  : 	delete [] tempbuff;

	mov	eax, DWORD PTR _tempbuff$[ebp]
	mov	DWORD PTR $T72867[ebp], eax
	mov	ecx, DWORD PTR $T72867[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 234  : 
; 235  : 	return len;

	mov	eax, DWORD PTR _len$[ebp]

; 236  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?IVPrintf@CVirtualFS@@QAEIPBDPAD@Z ENDP			; CVirtualFS::IVPrintf
_TEXT	ENDS
PUBLIC	?Getc@CVirtualFS@@QAEHXZ			; CVirtualFS::Getc
;	COMDAT ?Getc@CVirtualFS@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_c$ = -8
?Getc@CVirtualFS@@QAEHXZ PROC NEAR			; CVirtualFS::Getc, COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 240  : 	char c;
; 241  : 
; 242  : 	if( !Read( &c, 1 ))

	push	1
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CVirtualFS@@QAEIPADI@Z		; CVirtualFS::Read
	test	eax, eax
	jne	SHORT $L71235

; 243  : 		return EOF;

	or	eax, -1
	jmp	SHORT $L71233
$L71235:

; 244  : 	return (byte)c;

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 255				; 000000ffH
$L71233:

; 245  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Getc@CVirtualFS@@QAEHXZ ENDP				; CVirtualFS::Getc
_TEXT	ENDS
PUBLIC	?Seek@CVirtualFS@@QAEHIH@Z			; CVirtualFS::Seek
PUBLIC	?Gets@CVirtualFS@@QAEHPADI@Z			; CVirtualFS::Gets
;	COMDAT ?Gets@CVirtualFS@@QAEHPADI@Z
_TEXT	SEGMENT
_string$ = 8
_size$ = 12
_this$ = -4
_end$ = -8
_c$ = -12
?Gets@CVirtualFS@@QAEHPADI@Z PROC NEAR			; CVirtualFS::Gets, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 249  : 	size_t	end = 0;

	mov	DWORD PTR _end$[ebp], 0
$L71245:

; 250  : 	int	c;
; 251  : 
; 252  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $L71246

; 254  : 		c = Getc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Getc@CVirtualFS@@QAEHXZ		; CVirtualFS::Getc
	mov	DWORD PTR _c$[ebp], eax

; 255  : 
; 256  : 		if( c == '\r' || c == '\n' || c < 0 )

	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	je	SHORT $L71248
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $L71248
	cmp	DWORD PTR _c$[ebp], 0
	jge	SHORT $L71247
$L71248:

; 257  : 			break;

	jmp	SHORT $L71246
$L71247:

; 258  : 
; 259  : 		if( end < ( size - 1 ))

	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _end$[ebp], ecx
	jae	SHORT $L71249

; 260  : 			string[end++] = c;

	mov	edx, DWORD PTR _string$[ebp]
	add	edx, DWORD PTR _end$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _end$[ebp]
	add	ecx, 1
	mov	DWORD PTR _end$[ebp], ecx
$L71249:

; 261  : 	}

	jmp	SHORT $L71245
$L71246:

; 262  : 
; 263  : 	string[end] = 0;

	mov	edx, DWORD PTR _string$[ebp]
	add	edx, DWORD PTR _end$[ebp]
	mov	BYTE PTR [edx], 0

; 264  : 
; 265  : 	// remove \n following \r
; 266  : 	if( c == '\r' )

	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	jne	SHORT $L71251

; 268  : 		c = Getc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Getc@CVirtualFS@@QAEHXZ		; CVirtualFS::Getc
	mov	DWORD PTR _c$[ebp], eax

; 269  : 		if( c != '\n' ) Seek( -1, SEEK_CUR ); // rewind

	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $L71251
	push	1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Seek@CVirtualFS@@QAEHIH@Z		; CVirtualFS::Seek
$L71251:

; 271  : 
; 272  : 	return c;

	mov	eax, DWORD PTR _c$[ebp]

; 273  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Gets@CVirtualFS@@QAEHPADI@Z ENDP			; CVirtualFS::Gets
_TEXT	ENDS
;	COMDAT ?Seek@CVirtualFS@@QAEHIH@Z
_TEXT	SEGMENT
_offset$ = 8
_whence$ = 12
_this$ = -4
?Seek@CVirtualFS@@QAEHIH@Z PROC NEAR			; CVirtualFS::Seek, COMDAT

; 276  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 279  : 	{

	mov	eax, DWORD PTR _whence$[ebp]
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 0
	je	SHORT $L71262
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L71261
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L71263
	jmp	SHORT $L71264
$L71261:

; 280  : 	case SEEK_CUR:
; 281  : 		offset += m_iOffset;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _offset$[ebp]
	add	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _offset$[ebp], edx

; 282  : 		break;

	jmp	SHORT $L71258
$L71262:

; 283  : 	case SEEK_SET:
; 284  : 		break;

	jmp	SHORT $L71258
$L71263:

; 285  : 	case SEEK_END:
; 286  : 		offset += m_iLength;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	add	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _offset$[ebp], ecx

; 287  : 		break;

	jmp	SHORT $L71258
$L71264:

; 288  : 	default: 
; 289  : 		return -1;

	or	eax, -1
	jmp	SHORT $L71256
$L71258:

; 291  : 
; 292  : 	if(( offset < 0 ) || ( offset > m_iLength ))

	cmp	DWORD PTR _offset$[ebp], 0
	jb	SHORT $L71266
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _offset$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jbe	SHORT $L71265
$L71266:

; 293  : 		return -1;

	or	eax, -1
	jmp	SHORT $L71256
$L71265:

; 294  : 
; 295  : 	m_iOffset = offset;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 296  : 
; 297  : 	return 0;

	xor	eax, eax
$L71256:

; 298  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Seek@CVirtualFS@@QAEHIH@Z ENDP				; CVirtualFS::Seek
_TEXT	ENDS
PUBLIC	?GL_UniformTypeToDwordCount@@YAHI_N@Z		; GL_UniformTypeToDwordCount
;	COMDAT ?GL_UniformTypeToDwordCount@@YAHI_N@Z
_TEXT	SEGMENT
_type$ = 8
_align$ = 12
?GL_UniformTypeToDwordCount@@YAHI_N@Z PROC NEAR		; GL_UniformTypeToDwordCount, COMDAT

; 296  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 298  : 	{

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR -4+[ebp], eax
	cmp	DWORD PTR -4+[ebp], 35674		; 00008b5aH
	ja	SHORT $L72876
	cmp	DWORD PTR -4+[ebp], 35674		; 00008b5aH
	je	$L71638
	cmp	DWORD PTR -4+[ebp], 35664		; 00008b50H
	ja	SHORT $L72877
	cmp	DWORD PTR -4+[ebp], 35664		; 00008b50H
	je	$L71635
	cmp	DWORD PTR -4+[ebp], 5124		; 00001404H
	jb	$L71641
	cmp	DWORD PTR -4+[ebp], 5125		; 00001405H
	jbe	SHORT $L71633
	cmp	DWORD PTR -4+[ebp], 5126		; 00001406H
	je	SHORT $L71634
	jmp	$L71641
$L72877:
	cmp	DWORD PTR -4+[ebp], 35665		; 00008b51H
	je	$L71636
	cmp	DWORD PTR -4+[ebp], 35666		; 00008b52H
	je	$L71637
	jmp	$L71641
$L72876:
	cmp	DWORD PTR -4+[ebp], 35684		; 00008b64H
	ja	SHORT $L72878
	cmp	DWORD PTR -4+[ebp], 35677		; 00008b5dH
	jae	SHORT $L71633
	cmp	DWORD PTR -4+[ebp], 35675		; 00008b5bH
	je	SHORT $L71639
	cmp	DWORD PTR -4+[ebp], 35676		; 00008b5cH
	je	$L71640
	jmp	$L71641
$L72878:
	cmp	DWORD PTR -4+[ebp], 36293		; 00008dc5H
	je	SHORT $L71633
	jmp	SHORT $L71641
$L71633:

; 299  : 	case GL_INT:
; 300  : 	case GL_UNSIGNED_INT:
; 301  : 	case GL_SAMPLER_1D_ARB:
; 302  : 	case GL_SAMPLER_2D_ARB:
; 303  : 	case GL_SAMPLER_3D_ARB:
; 304  : 	case GL_SAMPLER_CUBE_ARB:
; 305  : 	case GL_SAMPLER_1D_SHADOW_ARB:
; 306  : 	case GL_SAMPLER_2D_SHADOW_ARB:
; 307  : 	case GL_SAMPLER_2D_RECT_ARB:
; 308  : 	case GL_SAMPLER_2D_RECT_SHADOW_ARB:
; 309  : 	case GL_SAMPLER_CUBE_SHADOW_EXT:
; 310  : 		return align ? 4 : 1;	// int[1]

	mov	eax, DWORD PTR _align$[ebp]
	and	eax, 255				; 000000ffH
	neg	eax
	sbb	eax, eax
	and	eax, 3
	add	eax, 1
	jmp	SHORT $L71630
$L71634:

; 311  : 	case GL_FLOAT:
; 312  : 		return align ? 4 : 1;	// float[1]

	mov	eax, DWORD PTR _align$[ebp]
	and	eax, 255				; 000000ffH
	neg	eax
	sbb	eax, eax
	and	eax, 3
	add	eax, 1
	jmp	SHORT $L71630
$L71635:

; 313  : 	case GL_FLOAT_VEC2_ARB:
; 314  : 		return align ? 4 : 2;	// float[2]

	mov	eax, DWORD PTR _align$[ebp]
	and	eax, 255				; 000000ffH
	neg	eax
	sbb	eax, eax
	and	eax, 2
	add	eax, 2
	jmp	SHORT $L71630
$L71636:

; 315  : 	case GL_FLOAT_VEC3_ARB:
; 316  : 		return align ? 4 : 3;	// float[3]

	mov	eax, DWORD PTR _align$[ebp]
	and	eax, 255				; 000000ffH
	neg	eax
	sbb	eax, eax
	neg	eax
	add	eax, 3
	jmp	SHORT $L71630
$L71637:

; 317  : 	case GL_FLOAT_VEC4_ARB:
; 318  : 		return 4;	// float[4]

	mov	eax, 4
	jmp	SHORT $L71630
$L71638:

; 319  : 	case GL_FLOAT_MAT2_ARB:
; 320  : 		return 4;	// float[2][2]

	mov	eax, 4
	jmp	SHORT $L71630
$L71639:

; 321  : 	case GL_FLOAT_MAT3_ARB:
; 322  : 		return align ? 12 : 9;	// float[3][3]

	mov	eax, DWORD PTR _align$[ebp]
	and	eax, 255				; 000000ffH
	neg	eax
	sbb	eax, eax
	and	eax, 3
	add	eax, 9
	jmp	SHORT $L71630
$L71640:

; 323  : 	case GL_FLOAT_MAT4_ARB:
; 324  : 		return 16;// float[4][4]

	mov	eax, 16					; 00000010H
	jmp	SHORT $L71630
$L71641:

; 325  : 	default: return align ? 4 : 1; // assume error

	mov	eax, DWORD PTR _align$[ebp]
	and	eax, 255				; 000000ffH
	neg	eax
	sbb	eax, eax
	and	eax, 3
	add	eax, 1
$L71630:

; 327  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_UniformTypeToDwordCount@@YAHI_N@Z ENDP		; GL_UniformTypeToDwordCount
_TEXT	ENDS
PUBLIC	??_C@_0BA@LEFG@sampler1DShadow?$AA@		; `string'
PUBLIC	??_C@_0BA@GMCF@sampler2DShadow?$AA@		; `string'
PUBLIC	??_C@_0O@CEBP@sampler2DRect?$AA@		; `string'
PUBLIC	??_C@_0BE@FHO@sampler2DRectShadow?$AA@		; `string'
PUBLIC	??_C@_0BC@PGNK@samplerCubeShadow?$AA@		; `string'
PUBLIC	??_C@_03NMFM@?$DP?$DP?$DP?$AA@			; `string'
PUBLIC	?GL_UniformTypeToName@@YAPBDI@Z			; GL_UniformTypeToName
PUBLIC	??_C@_03EMIM@int?$AA@				; `string'
PUBLIC	??_C@_04FHHA@uint?$AA@				; `string'
PUBLIC	??_C@_05PIME@float?$AA@				; `string'
PUBLIC	??_C@_04EDIP@vec2?$AA@				; `string'
PUBLIC	??_C@_04OJBI@vec3?$AA@				; `string'
PUBLIC	??_C@_04LMPN@vec4?$AA@				; `string'
PUBLIC	??_C@_04BAGO@mat2?$AA@				; `string'
PUBLIC	??_C@_04LKPJ@mat3?$AA@				; `string'
PUBLIC	??_C@_04OPBM@mat4?$AA@				; `string'
PUBLIC	??_C@_09MINJ@sampler1D?$AA@			; `string'
PUBLIC	??_C@_09PDCG@sampler2D?$AA@			; `string'
PUBLIC	??_C@_09OFIM@sampler3D?$AA@			; `string'
PUBLIC	??_C@_0M@OHEM@samplerCube?$AA@			; `string'
PUBLIC	??_C@_0P@FJJF@sampler1DArray?$AA@		; `string'
PUBLIC	??_C@_0P@CKCL@sampler2DArray?$AA@		; `string'
;	COMDAT ??_C@_03EMIM@int?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_03EMIM@int?$AA@ DB 'int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FHHA@uint?$AA@
CONST	SEGMENT
??_C@_04FHHA@uint?$AA@ DB 'uint', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PIME@float?$AA@
CONST	SEGMENT
??_C@_05PIME@float?$AA@ DB 'float', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDIP@vec2?$AA@
CONST	SEGMENT
??_C@_04EDIP@vec2?$AA@ DB 'vec2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OJBI@vec3?$AA@
CONST	SEGMENT
??_C@_04OJBI@vec3?$AA@ DB 'vec3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LMPN@vec4?$AA@
CONST	SEGMENT
??_C@_04LMPN@vec4?$AA@ DB 'vec4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BAGO@mat2?$AA@
CONST	SEGMENT
??_C@_04BAGO@mat2?$AA@ DB 'mat2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LKPJ@mat3?$AA@
CONST	SEGMENT
??_C@_04LKPJ@mat3?$AA@ DB 'mat3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OPBM@mat4?$AA@
CONST	SEGMENT
??_C@_04OPBM@mat4?$AA@ DB 'mat4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09MINJ@sampler1D?$AA@
CONST	SEGMENT
??_C@_09MINJ@sampler1D?$AA@ DB 'sampler1D', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PDCG@sampler2D?$AA@
CONST	SEGMENT
??_C@_09PDCG@sampler2D?$AA@ DB 'sampler2D', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OFIM@sampler3D?$AA@
CONST	SEGMENT
??_C@_09OFIM@sampler3D?$AA@ DB 'sampler3D', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OHEM@samplerCube?$AA@
CONST	SEGMENT
??_C@_0M@OHEM@samplerCube?$AA@ DB 'samplerCube', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FJJF@sampler1DArray?$AA@
CONST	SEGMENT
??_C@_0P@FJJF@sampler1DArray?$AA@ DB 'sampler1DArray', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CKCL@sampler2DArray?$AA@
CONST	SEGMENT
??_C@_0P@CKCL@sampler2DArray?$AA@ DB 'sampler2DArray', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LEFG@sampler1DShadow?$AA@
CONST	SEGMENT
??_C@_0BA@LEFG@sampler1DShadow?$AA@ DB 'sampler1DShadow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMCF@sampler2DShadow?$AA@
CONST	SEGMENT
??_C@_0BA@GMCF@sampler2DShadow?$AA@ DB 'sampler2DShadow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CEBP@sampler2DRect?$AA@
CONST	SEGMENT
??_C@_0O@CEBP@sampler2DRect?$AA@ DB 'sampler2DRect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FHO@sampler2DRectShadow?$AA@
CONST	SEGMENT
??_C@_0BE@FHO@sampler2DRectShadow?$AA@ DB 'sampler2DRectShadow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PGNK@samplerCubeShadow?$AA@
CONST	SEGMENT
??_C@_0BC@PGNK@samplerCubeShadow?$AA@ DB 'samplerCubeShadow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NMFM@?$DP?$DP?$DP?$AA@
CONST	SEGMENT
??_C@_03NMFM@?$DP?$DP?$DP?$AA@ DB '???', 00H		; `string'
CONST	ENDS
;	COMDAT ?GL_UniformTypeToName@@YAPBDI@Z
_TEXT	SEGMENT
_type$ = 8
?GL_UniformTypeToName@@YAPBDI@Z PROC NEAR		; GL_UniformTypeToName, COMDAT

; 330  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 332  : 	{

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR -4+[ebp], eax
	cmp	DWORD PTR -4+[ebp], 35678		; 00008b5eH
	ja	$L72881
	cmp	DWORD PTR -4+[ebp], 35678		; 00008b5eH
	je	$L71669
	cmp	DWORD PTR -4+[ebp], 35666		; 00008b52H
	ja	SHORT $L72882
	cmp	DWORD PTR -4+[ebp], 35666		; 00008b52H
	je	$L71659
	cmp	DWORD PTR -4+[ebp], 5126		; 00001406H
	ja	SHORT $L72883
	cmp	DWORD PTR -4+[ebp], 5126		; 00001406H
	je	$L71653
	cmp	DWORD PTR -4+[ebp], 5124		; 00001404H
	je	$L71649
	cmp	DWORD PTR -4+[ebp], 5125		; 00001405H
	je	$L71651
	jmp	$L71689
$L72883:
	cmp	DWORD PTR -4+[ebp], 35664		; 00008b50H
	je	$L71655
	cmp	DWORD PTR -4+[ebp], 35665		; 00008b51H
	je	$L71657
	jmp	$L71689
$L72882:
	mov	ecx, DWORD PTR -4+[ebp]
	sub	ecx, 35674				; 00008b5aH
	mov	DWORD PTR -4+[ebp], ecx
	cmp	DWORD PTR -4+[ebp], 3
	ja	$L71689
	mov	edx, DWORD PTR -4+[ebp]
	jmp	DWORD PTR $L72885[edx*4]
$L72881:
	cmp	DWORD PTR -4+[ebp], 36288		; 00008dc0H
	ja	SHORT $L72884
	cmp	DWORD PTR -4+[ebp], 36288		; 00008dc0H
	je	$L71675
	mov	eax, DWORD PTR -4+[ebp]
	sub	eax, 35679				; 00008b5fH
	mov	DWORD PTR -4+[ebp], eax
	cmp	DWORD PTR -4+[ebp], 5
	ja	$L71689
	mov	ecx, DWORD PTR -4+[ebp]
	jmp	DWORD PTR $L72886[ecx*4]
$L72884:
	cmp	DWORD PTR -4+[ebp], 36289		; 00008dc1H
	je	SHORT $L71677
	cmp	DWORD PTR -4+[ebp], 36293		; 00008dc5H
	je	$L71687
	jmp	$L71689
$L71649:

; 333  : 	case GL_INT:
; 334  : 		return "int";

	mov	eax, OFFSET FLAT:??_C@_03EMIM@int?$AA@	; `string'
	jmp	$L71646
$L71651:

; 335  : 	case GL_UNSIGNED_INT:
; 336  : 		return "uint";

	mov	eax, OFFSET FLAT:??_C@_04FHHA@uint?$AA@	; `string'
	jmp	$L71646
$L71653:

; 337  : 	case GL_FLOAT:
; 338  : 		return "float";

	mov	eax, OFFSET FLAT:??_C@_05PIME@float?$AA@ ; `string'
	jmp	SHORT $L71646
$L71655:

; 339  : 	case GL_FLOAT_VEC2_ARB:
; 340  : 		return "vec2";

	mov	eax, OFFSET FLAT:??_C@_04EDIP@vec2?$AA@	; `string'
	jmp	SHORT $L71646
$L71657:

; 341  : 	case GL_FLOAT_VEC3_ARB:
; 342  : 		return "vec3";

	mov	eax, OFFSET FLAT:??_C@_04OJBI@vec3?$AA@	; `string'
	jmp	SHORT $L71646
$L71659:

; 343  : 	case GL_FLOAT_VEC4_ARB:
; 344  : 		return "vec4";

	mov	eax, OFFSET FLAT:??_C@_04LMPN@vec4?$AA@	; `string'
	jmp	SHORT $L71646
$L71661:

; 345  : 	case GL_FLOAT_MAT2_ARB:
; 346  : 		return "mat2";

	mov	eax, OFFSET FLAT:??_C@_04BAGO@mat2?$AA@	; `string'
	jmp	SHORT $L71646
$L71663:

; 347  : 	case GL_FLOAT_MAT3_ARB:
; 348  : 		return "mat3";

	mov	eax, OFFSET FLAT:??_C@_04LKPJ@mat3?$AA@	; `string'
	jmp	SHORT $L71646
$L71665:

; 349  : 	case GL_FLOAT_MAT4_ARB:
; 350  : 		return "mat4";

	mov	eax, OFFSET FLAT:??_C@_04OPBM@mat4?$AA@	; `string'
	jmp	SHORT $L71646
$L71667:

; 351  : 	case GL_SAMPLER_1D_ARB:
; 352  : 		return "sampler1D";

	mov	eax, OFFSET FLAT:??_C@_09MINJ@sampler1D?$AA@ ; `string'
	jmp	SHORT $L71646
$L71669:

; 353  : 	case GL_SAMPLER_2D_ARB:
; 354  : 		return "sampler2D";

	mov	eax, OFFSET FLAT:??_C@_09PDCG@sampler2D?$AA@ ; `string'
	jmp	SHORT $L71646
$L71671:

; 355  : 	case GL_SAMPLER_3D_ARB:
; 356  : 		return "sampler3D";

	mov	eax, OFFSET FLAT:??_C@_09OFIM@sampler3D?$AA@ ; `string'
	jmp	SHORT $L71646
$L71673:

; 357  : 	case GL_SAMPLER_CUBE_ARB:
; 358  : 		return "samplerCube";

	mov	eax, OFFSET FLAT:??_C@_0M@OHEM@samplerCube?$AA@ ; `string'
	jmp	SHORT $L71646
$L71675:

; 359  : 	case GL_SAMPLER_1D_ARRAY_EXT:
; 360  : 		return "sampler1DArray";

	mov	eax, OFFSET FLAT:??_C@_0P@FJJF@sampler1DArray?$AA@ ; `string'
	jmp	SHORT $L71646
$L71677:

; 361  : 	case GL_SAMPLER_2D_ARRAY_EXT:
; 362  : 		return "sampler2DArray";

	mov	eax, OFFSET FLAT:??_C@_0P@CKCL@sampler2DArray?$AA@ ; `string'
	jmp	SHORT $L71646
$L71679:

; 363  : 	case GL_SAMPLER_1D_SHADOW_ARB:
; 364  : 		return "sampler1DShadow";

	mov	eax, OFFSET FLAT:??_C@_0BA@LEFG@sampler1DShadow?$AA@ ; `string'
	jmp	SHORT $L71646
$L71681:

; 365  : 	case GL_SAMPLER_2D_SHADOW_ARB:
; 366  : 		return "sampler2DShadow";

	mov	eax, OFFSET FLAT:??_C@_0BA@GMCF@sampler2DShadow?$AA@ ; `string'
	jmp	SHORT $L71646
$L71683:

; 367  : 	case GL_SAMPLER_2D_RECT_ARB:
; 368  : 		return "sampler2DRect";

	mov	eax, OFFSET FLAT:??_C@_0O@CEBP@sampler2DRect?$AA@ ; `string'
	jmp	SHORT $L71646
$L71685:

; 369  : 	case GL_SAMPLER_2D_RECT_SHADOW_ARB:
; 370  : 		return "sampler2DRectShadow";

	mov	eax, OFFSET FLAT:??_C@_0BE@FHO@sampler2DRectShadow?$AA@ ; `string'
	jmp	SHORT $L71646
$L71687:

; 371  : 	case GL_SAMPLER_CUBE_SHADOW_EXT:
; 372  : 		return "samplerCubeShadow";

	mov	eax, OFFSET FLAT:??_C@_0BC@PGNK@samplerCubeShadow?$AA@ ; `string'
	jmp	SHORT $L71646
$L71689:

; 373  : 	default:	return "???";

	mov	eax, OFFSET FLAT:??_C@_03NMFM@?$DP?$DP?$DP?$AA@ ; `string'
$L71646:

; 375  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L72885:
	DD	$L71661
	DD	$L71663
	DD	$L71665
	DD	$L71667
$L72886:
	DD	$L71671
	DD	$L71673
	DD	$L71679
	DD	$L71681
	DD	$L71683
	DD	$L71685
?GL_UniformTypeToName@@YAPBDI@Z ENDP			; GL_UniformTypeToName
_TEXT	ENDS
PUBLIC	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z	; GL_ShowProgramUniforms
PUBLIC	??_C@_0BA@FLLN@uniform?5?$CFs?5?$CFs?$DL?6?$AA@	; `string'
PUBLIC	??_C@_0BE@BIMD@uniform?5?$CFs?5?$CFs?$FL?$CFi?$FN?$DL?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@NOKH@used?5uniforms?5?$CFi?5is?5overflowed?5m@ ; `string'
PUBLIC	??_C@_0BK@JLNN@used?5uniforms?5?$CFi?5from?5?$CFi?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@IGF@?$CFs?5used?5?$CFi?5uniforms?6?$AA@ ; `string'
EXTRN	?developer_level@@3HA:DWORD			; developer_level
EXTRN	?ALERT@@YAXW4ALERT_TYPE@@PADZZ:NEAR		; ALERT
EXTRN	?pglUseProgramObjectARB@@3P6GXI@ZA:DWORD	; pglUseProgramObjectARB
EXTRN	?Q_strchr@@YAPADPBDD@Z:NEAR			; Q_strchr
EXTRN	?pglGetObjectParameterivARB@@3P6GXIIPAH@ZA:DWORD ; pglGetObjectParameterivARB
EXTRN	?pglGetActiveUniformARB@@3P6GXIIHPAH0PAIPAD@ZA:DWORD ; pglGetActiveUniformARB
EXTRN	?tr@@3Uref_globals_t@@A:BYTE			; tr
EXTRN	?glConfig@@3UglConfig_t@@A:BYTE			; glConfig
;	COMDAT ??_C@_0BA@FLLN@uniform?5?$CFs?5?$CFs?$DL?6?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0BA@FLLN@uniform?5?$CFs?5?$CFs?$DL?6?$AA@ DB 'uniform %s %s;', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BIMD@uniform?5?$CFs?5?$CFs?$FL?$CFi?$FN?$DL?6?$AA@
CONST	SEGMENT
??_C@_0BE@BIMD@uniform?5?$CFs?5?$CFs?$FL?$CFi?$FN?$DL?6?$AA@ DB 'uniform '
	DB	'%s %s[%i];', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NOKH@used?5uniforms?5?$CFi?5is?5overflowed?5m@
CONST	SEGMENT
??_C@_0CN@NOKH@used?5uniforms?5?$CFi?5is?5overflowed?5m@ DB 'used uniform'
	DB	's %i is overflowed max count %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JLNN@used?5uniforms?5?$CFi?5from?5?$CFi?6?$AA@
CONST	SEGMENT
??_C@_0BK@JLNN@used?5uniforms?5?$CFi?5from?5?$CFi?6?$AA@ DB 'used uniform'
	DB	's %i from %i', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IGF@?$CFs?5used?5?$CFi?5uniforms?6?$AA@
CONST	SEGMENT
??_C@_0BF@IGF@?$CFs?5used?5?$CFi?5uniforms?6?$AA@ DB '%s used %i uniforms'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
_count$ = -4
_size$ = -8
_uniformName$ = -264
_total_uniforms_used$ = -268
_type$ = -272
_i$ = -276
_end$71707 = -280
_max_shader_uniforms$ = -284
?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_ShowProgramUniforms, COMDAT

; 378  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	push	ebx
	push	esi
	push	edi

; 379  : 	int	count, size;
; 380  : 	char	uniformName[256];
; 381  : 	int	total_uniforms_used = 0;

	mov	DWORD PTR _total_uniforms_used$[ebp], 0

; 382  : 	GLuint	type;
; 383  : 
; 384  : 	if( !shader || developer_level < DEV_EXTENDED )

	cmp	DWORD PTR _shader$[ebp], 0
	je	SHORT $L71700
	cmp	DWORD PTR ?developer_level@@3HA, 2	; developer_level
	jge	SHORT $L71699
$L71700:

; 385  : 		return;

	jmp	$L71693
$L71699:

; 386  : 	
; 387  : 	// install the executables in the program object as part of current state.
; 388  : 	pglUseProgramObjectARB( shader->handle );

	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglUseProgramObjectARB@@3P6GXI@ZA ; pglUseProgramObjectARB

; 389  : 
; 390  : 	// query the number of active uniforms
; 391  : 	pglGetObjectParameterivARB( shader->handle, GL_OBJECT_ACTIVE_UNIFORMS_ARB, &count );

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	push	35718					; 00008b86H
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetObjectParameterivARB@@3P6GXIIPAH@ZA ; pglGetObjectParameterivARB

; 392  : 
; 393  : 	// Loop over each of the active uniforms, and set their value
; 394  : 	for( int i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L71702
$L71703:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L71702:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$L71704

; 396  : 		pglGetActiveUniformARB( shader->handle, i, sizeof( uniformName ), NULL, &size, &type, uniformName );

	lea	ecx, DWORD PTR _uniformName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _type$[ebp]
	push	edx
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	push	0
	push	256					; 00000100H
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetActiveUniformARB@@3P6GXIIHPAH0PAIPAD@ZA ; pglGetActiveUniformARB

; 397  : 		if( developer_level >= DEV_EXTENDED )

	cmp	DWORD PTR ?developer_level@@3HA, 2	; developer_level
	jl	$L71711

; 399  : 			if( size != 1 )

	cmp	DWORD PTR _size$[ebp], 1
	je	SHORT $L71708

; 401  : 				char *end = Q_strchr( uniformName, '[' );

	push	91					; 0000005bH
	lea	ecx, DWORD PTR _uniformName$[ebp]
	push	ecx
	call	?Q_strchr@@YAPADPBDD@Z			; Q_strchr
	add	esp, 8
	mov	DWORD PTR _end$71707[ebp], eax

; 402  : 				if( end ) *end = '\0'; // cutoff [0]

	cmp	DWORD PTR _end$71707[ebp], 0
	je	SHORT $L71708
	mov	edx, DWORD PTR _end$71707[ebp]
	mov	BYTE PTR [edx], 0
$L71708:

; 404  : 
; 405  : 			if( size == 1 ) ALERT( at_aiconsole, "uniform %s %s;\n", GL_UniformTypeToName( type ), uniformName );

	cmp	DWORD PTR _size$[ebp], 1
	jne	SHORT $L71709
	lea	eax, DWORD PTR _uniformName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	call	?GL_UniformTypeToName@@YAPBDI@Z		; GL_UniformTypeToName
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BA@FLLN@uniform?5?$CFs?5?$CFs?$DL?6?$AA@ ; `string'
	push	2
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 16					; 00000010H

; 406  : 			else ALERT( at_aiconsole, "uniform %s %s[%i];\n", GL_UniformTypeToName( type ), uniformName, size );

	jmp	SHORT $L71711
$L71709:
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	lea	eax, DWORD PTR _uniformName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	call	?GL_UniformTypeToName@@YAPBDI@Z		; GL_UniformTypeToName
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BE@BIMD@uniform?5?$CFs?5?$CFs?$FL?$CFi?$FN?$DL?6?$AA@ ; `string'
	push	2
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 20					; 00000014H
$L71711:

; 408  : 		total_uniforms_used += GL_UniformTypeToDwordCount( type ) * size;

	push	0
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	call	?GL_UniformTypeToDwordCount@@YAHI_N@Z	; GL_UniformTypeToDwordCount
	add	esp, 8
	imul	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _total_uniforms_used$[ebp]
	add	ecx, eax
	mov	DWORD PTR _total_uniforms_used$[ebp], ecx

; 409  : 	}

	jmp	$L71703
$L71704:

; 410  : 
; 411  : 	if( total_uniforms_used >= glConfig.max_vertex_uniforms )

	mov	edx, DWORD PTR _total_uniforms_used$[ebp]
	cmp	edx, DWORD PTR ?glConfig@@3UglConfig_t@@A+60
	jl	SHORT $L71713

; 412  : 		ALERT( at_error, "used uniforms %i is overflowed max count %i\n", total_uniforms_used, glConfig.max_vertex_uniforms );

	mov	eax, DWORD PTR ?glConfig@@3UglConfig_t@@A+60
	push	eax
	mov	ecx, DWORD PTR _total_uniforms_used$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CN@NOKH@used?5uniforms?5?$CFi?5is?5overflowed?5m@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 16					; 00000010H

; 413  : 	else ALERT( at_aiconsole, "used uniforms %i from %i\n", total_uniforms_used, glConfig.max_vertex_uniforms );

	jmp	SHORT $L71715
$L71713:
	mov	edx, DWORD PTR ?glConfig@@3UglConfig_t@@A+60
	push	edx
	mov	eax, DWORD PTR _total_uniforms_used$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BK@JLNN@used?5uniforms?5?$CFi?5from?5?$CFi?6?$AA@ ; `string'
	push	2
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 16					; 00000010H
$L71715:

; 414  : 
; 415  : 	int max_shader_uniforms = total_uniforms_used;

	mov	ecx, DWORD PTR _total_uniforms_used$[ebp]
	mov	DWORD PTR _max_shader_uniforms$[ebp], ecx

; 416  : 
; 417  : 	if( max_shader_uniforms > ( glConfig.max_skinning_bones * 7 ))

	mov	edx, DWORD PTR ?glConfig@@3UglConfig_t@@A+72
	imul	edx, 7
	cmp	DWORD PTR _max_shader_uniforms$[ebp], edx
	jle	SHORT $L71718

; 418  : 		max_shader_uniforms -= ( glConfig.max_skinning_bones * 7 );

	mov	eax, DWORD PTR ?glConfig@@3UglConfig_t@@A+72
	imul	eax, 7
	mov	ecx, DWORD PTR _max_shader_uniforms$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _max_shader_uniforms$[ebp], ecx
$L71718:

; 419  : 
; 420  : 	ALERT( at_aiconsole, "%s used %i uniforms\n", shader->name, max_shader_uniforms );

	mov	edx, DWORD PTR _max_shader_uniforms$[ebp]
	push	edx
	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@IGF@?$CFs?5used?5?$CFi?5uniforms?6?$AA@ ; `string'
	push	2
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 16					; 00000010H

; 421  : 
; 422  : 	if( max_shader_uniforms > glConfig.peak_used_uniforms )

	mov	ecx, DWORD PTR _max_shader_uniforms$[ebp]
	cmp	ecx, DWORD PTR ?glConfig@@3UglConfig_t@@A+76
	jle	SHORT $L71720

; 424  : 		glConfig.peak_used_uniforms = max_shader_uniforms;

	mov	edx, DWORD PTR _max_shader_uniforms$[ebp]
	mov	DWORD PTR ?glConfig@@3UglConfig_t@@A+76, edx

; 425  : 		tr.show_uniforms_peak = true;

	mov	BYTE PTR ?tr@@3Uref_globals_t@@A+1412004, 1
$L71720:

; 427  : 
; 428  : 	pglUseProgramObjectARB( GL_NONE );

	push	0
	call	DWORD PTR ?pglUseProgramObjectARB@@3P6GXI@ZA ; pglUseProgramObjectARB
$L71693:

; 429  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ENDP	; GL_ShowProgramUniforms
_TEXT	ENDS
PUBLIC	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z		; GL_BindShader
EXTRN	?RI@@3PAUref_instance_t@@A:DWORD		; RI
EXTRN	?r_stats@@3Uref_stats_t@@A:BYTE			; r_stats
;	COMDAT ?GL_BindShader@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_BindShader@@YAXPAUglsl_prog_s@@@Z PROC NEAR		; GL_BindShader, COMDAT

; 432  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 433  : 	if( !shader && RI->currentshader )

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71724
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $L71724

; 435  : 		pglUseProgramObjectARB( GL_NONE );

	push	0
	call	DWORD PTR ?pglUseProgramObjectARB@@3P6GXI@ZA ; pglUseProgramObjectARB

; 436  : 		RI->currentshader = NULL;

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	DWORD PTR [ecx+28], 0

; 438  : 	else if( shader != RI->currentshader && shader != NULL && shader->handle )

	jmp	SHORT $L71726
$L71724:
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR _shader$[ebp]
	cmp	eax, DWORD PTR [edx+28]
	je	SHORT $L71726
	cmp	DWORD PTR _shader$[ebp], 0
	je	SHORT $L71726
	mov	ecx, DWORD PTR _shader$[ebp]
	cmp	DWORD PTR [ecx+576], 0
	je	SHORT $L71726

; 440  : 		pglUseProgramObjectARB( shader->handle );

	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglUseProgramObjectARB@@3P6GXI@ZA ; pglUseProgramObjectARB

; 441  : 		r_stats.num_shader_binds++;

	mov	ecx, DWORD PTR ?r_stats@@3Uref_stats_t@@A+72
	add	ecx, 1
	mov	DWORD PTR ?r_stats@@3Uref_stats_t@@A+72, ecx

; 442  : 		RI->currentshader = shader;

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+28], eax
$L71726:

; 444  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_BindShader@@YAXPAUglsl_prog_s@@@Z ENDP		; GL_BindShader
_TEXT	ENDS
PUBLIC	?GL_AddShaderDirective@@YAXPADPBD@Z		; GL_AddShaderDirective
PUBLIC	??_C@_0M@CGMG@?$CDdefine?5?$CFs?6?$AA@		; `string'
EXTRN	?Q_strncat@@YAIPADPBDI@Z:NEAR			; Q_strncat
EXTRN	?va@@YAPADPBDZZ:NEAR				; va
;	COMDAT ??_C@_0M@CGMG@?$CDdefine?5?$CFs?6?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0M@CGMG@?$CDdefine?5?$CFs?6?$AA@ DB '#define %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?GL_AddShaderDirective@@YAXPADPBD@Z
_TEXT	SEGMENT
_options$ = 8
_directive$ = 12
?GL_AddShaderDirective@@YAXPADPBD@Z PROC NEAR		; GL_AddShaderDirective, COMDAT

; 651  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 652  : 	Q_strncat( options, va( "#define %s\n", directive ), MAX_OPTIONS_LENGTH );

	push	512					; 00000200H
	mov	eax, DWORD PTR _directive$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0M@CGMG@?$CDdefine?5?$CFs?6?$AA@ ; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 653  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_AddShaderDirective@@YAXPADPBD@Z ENDP		; GL_AddShaderDirective
_TEXT	ENDS
PUBLIC	?GL_AddShaderDefine@@YAXPADPBD@Z		; GL_AddShaderDefine
;	COMDAT ?GL_AddShaderDefine@@YAXPADPBD@Z
_TEXT	SEGMENT
_options$ = 8
_directive$ = 12
?GL_AddShaderDefine@@YAXPADPBD@Z PROC NEAR		; GL_AddShaderDefine, COMDAT

; 656  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 657  : 	Q_strncat( options, directive, MAX_OPTIONS_LENGTH );

	push	512					; 00000200H
	mov	eax, DWORD PTR _directive$[ebp]
	push	eax
	mov	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 658  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_AddShaderDefine@@YAXPADPBD@Z ENDP			; GL_AddShaderDefine
_TEXT	ENDS
PUBLIC	?GL_FindShaderDirective@@YA_NPAUglsl_prog_s@@PBD@Z ; GL_FindShaderDirective
EXTRN	?Q_stristr@@YAPADPBD0@Z:NEAR			; Q_stristr
;	COMDAT ?GL_FindShaderDirective@@YA_NPAUglsl_prog_s@@PBD@Z
_TEXT	SEGMENT
_shader$ = 8
_directive$ = 12
?GL_FindShaderDirective@@YA_NPAUglsl_prog_s@@PBD@Z PROC NEAR ; GL_FindShaderDirective, COMDAT

; 661  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 662  : 	if( Q_stristr( shader->options, directive ))

	mov	eax, DWORD PTR _directive$[ebp]
	push	eax
	mov	ecx, DWORD PTR _shader$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	call	?Q_stristr@@YAPADPBD0@Z			; Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $L71831

; 663  : 		return true;

	mov	al, 1
	jmp	SHORT $L71830
$L71831:

; 664  : 	return false;

	xor	al, al
$L71830:

; 665  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_FindShaderDirective@@YA_NPAUglsl_prog_s@@PBD@Z ENDP	; GL_FindShaderDirective
_TEXT	ENDS
PUBLIC	??_C@_0L@CEPF@u_ColorMap?$AA@			; `string'
PUBLIC	??_C@_0M@BNFL@u_FogParams?$AA@			; `string'
PUBLIC	?GL_InitGenericFogUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitGenericFogUniforms
PUBLIC	?__LINE__Var@?1??GL_InitGenericFogUniforms@@YAXPAUglsl_prog_s@@@Z@4FA ; `GL_InitGenericFogUniforms'::`2'::__LINE__Var
PUBLIC	??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
PUBLIC	??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
EXTRN	?gRenderfuncs@@3Urender_api_s@@A:BYTE		; gRenderfuncs
EXTRN	?pglUniform1iARB@@3P6GXHH@ZA:DWORD		; pglUniform1iARB
EXTRN	?pglGetUniformLocationARB@@3P6GHIPBD@ZA:DWORD	; pglGetUniformLocationARB
;	COMDAT ?__LINE__Var@?1??GL_InitGenericFogUniforms@@YAXPAUglsl_prog_s@@@Z@4FA
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitGenericFogUniforms@@YAXPAUglsl_prog_s@@@Z@4FA DW 03e4H ; `GL_InitGenericFogUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@
CONST	SEGMENT
??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ DB 'z:\xashxtsrc\cl'
	DB	'ient\render\r_shader.cpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@
CONST	SEGMENT
??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CEPF@u_ColorMap?$AA@
CONST	SEGMENT
??_C@_0L@CEPF@u_ColorMap?$AA@ DB 'u_ColorMap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BNFL@u_FogParams?$AA@
CONST	SEGMENT
??_C@_0M@BNFL@u_FogParams?$AA@ DB 'u_FogParams', 00H	; `string'
CONST	ENDS
;	COMDAT ?GL_InitGenericFogUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitGenericFogUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitGenericFogUniforms, COMDAT

; 996  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 997  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71946
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitGenericFogUniforms@@YAXPAUglsl_prog_s@@@Z@4FA ; `GL_InitGenericFogUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71946:

; 998  : 
; 999  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 1000 : 
; 1001 : 	shader->u_FogParams = pglGetUniformLocationARB( shader->handle, "u_FogParams" );

	push	OFFSET FLAT:??_C@_0M@BNFL@u_FogParams?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+768], eax

; 1002 : 
; 1003 : 	GL_BindShader( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 1004 : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 1005 : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 1006 : 
; 1007 : 	GL_ValidateProgram( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 1008 : 	GL_ShowProgramUniforms( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 1009 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitGenericFogUniforms@@YAXPAUglsl_prog_s@@@Z ENDP	; GL_InitGenericFogUniforms
_TEXT	ENDS
PUBLIC	??_C@_0CB@JNHB@?$CFs?6?$CFs?5shader?5failed?5to?5validate?6@ ; `string'
EXTRN	?pglValidateProgramARB@@3P6GXI@ZA:DWORD		; pglValidateProgramARB
;	COMDAT ??_C@_0CB@JNHB@?$CFs?6?$CFs?5shader?5failed?5to?5validate?6@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0CB@JNHB@?$CFs?6?$CFs?5shader?5failed?5to?5validate?6@ DB '%s', 0aH
	DB	'%s shader failed to validate', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
_validated$ = -4
?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z PROC NEAR	; GL_ValidateProgram, COMDAT

; 284  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 285  : 	GLint	validated = 0;

	mov	DWORD PTR _validated$[ebp], 0

; 286  : 
; 287  : 	if( !shader ) return;

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71622
	jmp	SHORT $L71620
$L71622:

; 288  : 
; 289  : 	pglValidateProgramARB( shader->handle );

	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglValidateProgramARB@@3P6GXI@ZA ; pglValidateProgramARB

; 290  : 
; 291  : 	pglGetObjectParameterivARB( shader->handle, GL_OBJECT_VALIDATE_STATUS_ARB, &validated );

	lea	edx, DWORD PTR _validated$[ebp]
	push	edx
	push	35715					; 00008b83H
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetObjectParameterivARB@@3P6GXIIPAH@ZA ; pglGetObjectParameterivARB

; 292  : 	if( !validated ) ALERT( at_error, "%s\n%s shader failed to validate\n", GL_PrintInfoLog( shader->handle ), shader->name );

	cmp	DWORD PTR _validated$[ebp], 0
	jne	SHORT $L71623
	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	?GL_PrintInfoLog@@YAPADI@Z		; GL_PrintInfoLog
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CB@JNHB@?$CFs?6?$CFs?5shader?5failed?5to?5validate?6@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 16					; 00000010H
$L71623:
$L71620:

; 293  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ENDP		; GL_ValidateProgram
_TEXT	ENDS
PUBLIC	??_C@_0CN@DDDA@GL_PrintInfoLog?3?5message?5exceeds@ ; `string'
EXTRN	?pglGetInfoLogARB@@3P6GXIHPAHPAD@ZA:DWORD	; pglGetInfoLogARB
_BSS	SEGMENT
_?msg@?1??GL_PrintInfoLog@@YAPADI@Z@4PADA DB 02000H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CN@DDDA@GL_PrintInfoLog?3?5message?5exceeds@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0CN@DDDA@GL_PrintInfoLog?3?5message?5exceeds@ DB 'GL_PrintInfoLog: '
	DB	'message exceeds %i symbols', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?GL_PrintInfoLog@@YAPADI@Z
_TEXT	SEGMENT
_object$ = 8
_maxLength$ = -4
?GL_PrintInfoLog@@YAPADI@Z PROC NEAR			; GL_PrintInfoLog, COMDAT

; 38   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 39   : 	static char	msg[8192];
; 40   : 	int		maxLength = 0;

	mov	DWORD PTR _maxLength$[ebp], 0

; 41   : 
; 42   : 	pglGetObjectParameterivARB( object, GL_OBJECT_INFO_LOG_LENGTH_ARB, &maxLength );

	lea	eax, DWORD PTR _maxLength$[ebp]
	push	eax
	push	35716					; 00008b84H
	mov	ecx, DWORD PTR _object$[ebp]
	push	ecx
	call	DWORD PTR ?pglGetObjectParameterivARB@@3P6GXIIPAH@ZA ; pglGetObjectParameterivARB

; 43   : 
; 44   : 	if( maxLength >= sizeof( msg ))

	cmp	DWORD PTR _maxLength$[ebp], 8192	; 00002000H
	jb	SHORT $L71481

; 46   : 		ALERT( at_warning, "GL_PrintInfoLog: message exceeds %i symbols\n", sizeof( msg ));

	push	8192					; 00002000H
	push	OFFSET FLAT:??_C@_0CN@DDDA@GL_PrintInfoLog?3?5message?5exceeds@ ; `string'
	push	3
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH

; 47   : 		maxLength = sizeof( msg ) - 1;

	mov	DWORD PTR _maxLength$[ebp], 8191	; 00001fffH
$L71481:

; 49   : 
; 50   : 	pglGetInfoLogARB( object, maxLength, &maxLength, msg );

	push	OFFSET FLAT:_?msg@?1??GL_PrintInfoLog@@YAPADI@Z@4PADA
	lea	edx, DWORD PTR _maxLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _maxLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _object$[ebp]
	push	ecx
	call	DWORD PTR ?pglGetInfoLogARB@@3P6GXIHPAHPAD@ZA ; pglGetInfoLogARB

; 51   : 
; 52   : 	return msg;

	mov	eax, OFFSET FLAT:_?msg@?1??GL_PrintInfoLog@@YAPADI@Z@4PADA

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_PrintInfoLog@@YAPADI@Z ENDP				; GL_PrintInfoLog
_TEXT	ENDS
PUBLIC	?GL_PretifyListOptions@@YAPBDPBD_N@Z		; GL_PretifyListOptions
PUBLIC	??_C@_07GIIJ@?$CDdefine?$AA@			; `string'
PUBLIC	??_C@_00A@?$AA@					; `string'
EXTRN	?Q_strstr@@YAPADPBD0@Z:NEAR			; Q_strstr
_BSS	SEGMENT
_?output@?1??GL_PretifyListOptions@@YAPBDPBD_N@Z@4PADA DB 0200H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_00A@?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07GIIJ@?$CDdefine?$AA@
CONST	SEGMENT
??_C@_07GIIJ@?$CDdefine?$AA@ DB '#define', 00H		; `string'
CONST	ENDS
;	COMDAT ?GL_PretifyListOptions@@YAPBDPBD_N@Z
_TEXT	SEGMENT
_options$ = 8
_newlines$ = 12
_pstart$ = -4
_pend$ = -8
_pout$ = -12
_pfind$71970 = -16
?GL_PretifyListOptions@@YAPBDPBD_N@Z PROC NEAR		; GL_PretifyListOptions, COMDAT

; 1051 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1052 : 	static char output[MAX_OPTIONS_LENGTH];
; 1053 : 	const char *pstart = options;

	mov	eax, DWORD PTR _options$[ebp]
	mov	DWORD PTR _pstart$[ebp], eax

; 1054 : 	const char *pend = options + Q_strlen( options );

	mov	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	mov	edx, DWORD PTR _options$[ebp]
	add	edx, eax
	mov	DWORD PTR _pend$[ebp], edx

; 1055 : 	char *pout = output;

	mov	DWORD PTR _pout$[ebp], OFFSET FLAT:_?output@?1??GL_PretifyListOptions@@YAPBDPBD_N@Z@4PADA

; 1056 : 
; 1057 : 	*pout = '\0';

	mov	eax, DWORD PTR _pout$[ebp]
	mov	BYTE PTR [eax], 0
$L71968:

; 1058 : 
; 1059 : 	while( pstart < pend )

	mov	ecx, DWORD PTR _pstart$[ebp]
	cmp	ecx, DWORD PTR _pend$[ebp]
	jae	$L71969

; 1061 : 		const char *pfind = Q_strstr( pstart, "#define" );

	push	OFFSET FLAT:??_C@_07GIIJ@?$CDdefine?$AA@ ; `string'
	mov	edx, DWORD PTR _pstart$[ebp]
	push	edx
	call	?Q_strstr@@YAPADPBD0@Z			; Q_strstr
	add	esp, 8
	mov	DWORD PTR _pfind$71970[ebp], eax

; 1062 : 		if( !pfind ) break;

	cmp	DWORD PTR _pfind$71970[ebp], 0
	jne	SHORT $L71972
	jmp	SHORT $L71969
$L71972:

; 1063 : 
; 1064 : 		pstart = pfind + Q_strlen( "#define" );

	push	OFFSET FLAT:??_C@_07GIIJ@?$CDdefine?$AA@ ; `string'
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pfind$71970[ebp]
	add	ecx, eax
	mov	DWORD PTR _pstart$[ebp], ecx

; 1065 : 
; 1066 : 		for( ; *pstart != '\n'; pstart++, pout++ )

	jmp	SHORT $L71973
$L71974:
	mov	edx, DWORD PTR _pstart$[ebp]
	add	edx, 1
	mov	DWORD PTR _pstart$[ebp], edx
	mov	eax, DWORD PTR _pout$[ebp]
	add	eax, 1
	mov	DWORD PTR _pout$[ebp], eax
$L71973:
	mov	ecx, DWORD PTR _pstart$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $L71975

; 1067 : 			*pout = *pstart;

	mov	eax, DWORD PTR _pout$[ebp]
	mov	ecx, DWORD PTR _pstart$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $L71974
$L71975:

; 1068 : 		if( newlines )

	mov	eax, DWORD PTR _newlines$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L71976

; 1069 : 			*pout++ = *pstart++;

	mov	ecx, DWORD PTR _pout$[ebp]
	mov	edx, DWORD PTR _pstart$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pout$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pout$[ebp], ecx
	mov	edx, DWORD PTR _pstart$[ebp]
	add	edx, 1
	mov	DWORD PTR _pstart$[ebp], edx

; 1070 : 		else pstart++; // skip '\n'

	jmp	SHORT $L71977
$L71976:
	mov	eax, DWORD PTR _pstart$[ebp]
	add	eax, 1
	mov	DWORD PTR _pstart$[ebp], eax
$L71977:

; 1071 : 	}

	jmp	$L71968
$L71969:

; 1072 : 
; 1073 : 	if( pout == output )

	cmp	DWORD PTR _pout$[ebp], OFFSET FLAT:_?output@?1??GL_PretifyListOptions@@YAPBDPBD_N@Z@4PADA
	jne	SHORT $L71978

; 1074 : 		return ""; // nothing found

	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	jmp	SHORT $L71961
$L71978:

; 1075 : 
; 1076 : 	*pout++ = ' ';

	mov	ecx, DWORD PTR _pout$[ebp]
	mov	BYTE PTR [ecx], 32			; 00000020H
	mov	edx, DWORD PTR _pout$[ebp]
	add	edx, 1
	mov	DWORD PTR _pout$[ebp], edx

; 1077 : 	*pout = '\0';

	mov	eax, DWORD PTR _pout$[ebp]
	mov	BYTE PTR [eax], 0

; 1078 : 
; 1079 : 	return output;

	mov	eax, OFFSET FLAT:_?output@?1??GL_PretifyListOptions@@YAPBDPBD_N@Z@4PADA
$L71961:

; 1080 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_PretifyListOptions@@YAPBDPBD_N@Z ENDP		; GL_PretifyListOptions
_TEXT	ENDS
PUBLIC	??_C@_0BE@DAAC@BMODEL_MULTI_LAYERS?$AA@		; `string'
PUBLIC	?GL_UberShaderForSolidBmodel@@YAGPAUmsurface_s@@_N@Z ; GL_UberShaderForSolidBmodel
PUBLIC	__real@4@00000000000000000000
PUBLIC	?__LINE__Var@?1??GL_UberShaderForSolidBmodel@@YAGPAUmsurface_s@@_N@Z@4FA ; `GL_UberShaderForSolidBmodel'::`2'::__LINE__Var
PUBLIC	??_C@_0M@IHGG@BmodelSolid?$AA@			; `string'
PUBLIC	??_C@_0BC@KBPO@BMODEL_MONOCHROME?$AA@		; `string'
PUBLIC	??_C@_0BC@HJK@BMODEL_FULLBRIGHT?$AA@		; `string'
PUBLIC	??_C@_0BF@CMPL@BMODEL_APPLY_STYLE?$CFi?$AA@	; `string'
PUBLIC	??_C@_0BA@CGBF@BMODEL_HAS_LUMA?$AA@		; `string'
PUBLIC	??_C@_0BA@JDPH@BMODEL_DRAWTURB?$AA@		; `string'
PUBLIC	??_C@_0BC@LEMI@BMODEL_WAVEHEIGHT?$AA@		; `string'
PUBLIC	??_C@_0BG@DHNK@TERRAIN_NUM_LAYERS?5?$CFi?$AA@	; `string'
PUBLIC	??_C@_0BC@CMG@BMODEL_HAS_DETAIL?$AA@		; `string'
PUBLIC	??_C@_0BJ@BDDM@BMODEL_REFLECTION_PLANAR?$AA@	; `string'
PUBLIC	??_C@_0P@EFAO@BMODEL_FOG_EXP?$AA@		; `string'
EXTRN	__fltused:NEAR
EXTRN	?Q_strncpy@@YAIPADPBDI@Z:NEAR			; Q_strncpy
EXTRN	?r_fullbright@@3PAUcvar_s@@A:DWORD		; r_fullbright
EXTRN	?r_allow_mirrors@@3PAUcvar_s@@A:DWORD		; r_allow_mirrors
EXTRN	?r_allow_portals@@3PAUcvar_s@@A:DWORD		; r_allow_portals
EXTRN	?r_allow_screens@@3PAUcvar_s@@A:DWORD		; r_allow_screens
EXTRN	?r_detailtextures@@3PAUcvar_s@@A:DWORD		; r_detailtextures
EXTRN	?worldmodel@@3PAUmodel_s@@A:DWORD		; worldmodel
EXTRN	?glState@@3UglState_t@@A:BYTE			; glState
;	COMDAT ?__LINE__Var@?1??GL_UberShaderForSolidBmodel@@YAGPAUmsurface_s@@_N@Z@4FA
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_UberShaderForSolidBmodel@@YAGPAUmsurface_s@@_N@Z@4FA DW 043bH ; `GL_UberShaderForSolidBmodel'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BE@DAAC@BMODEL_MULTI_LAYERS?$AA@
CONST	SEGMENT
??_C@_0BE@DAAC@BMODEL_MULTI_LAYERS?$AA@ DB 'BMODEL_MULTI_LAYERS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IHGG@BmodelSolid?$AA@
CONST	SEGMENT
??_C@_0M@IHGG@BmodelSolid?$AA@ DB 'BmodelSolid', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBPO@BMODEL_MONOCHROME?$AA@
CONST	SEGMENT
??_C@_0BC@KBPO@BMODEL_MONOCHROME?$AA@ DB 'BMODEL_MONOCHROME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HJK@BMODEL_FULLBRIGHT?$AA@
CONST	SEGMENT
??_C@_0BC@HJK@BMODEL_FULLBRIGHT?$AA@ DB 'BMODEL_FULLBRIGHT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CMPL@BMODEL_APPLY_STYLE?$CFi?$AA@
CONST	SEGMENT
??_C@_0BF@CMPL@BMODEL_APPLY_STYLE?$CFi?$AA@ DB 'BMODEL_APPLY_STYLE%i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CGBF@BMODEL_HAS_LUMA?$AA@
CONST	SEGMENT
??_C@_0BA@CGBF@BMODEL_HAS_LUMA?$AA@ DB 'BMODEL_HAS_LUMA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JDPH@BMODEL_DRAWTURB?$AA@
CONST	SEGMENT
??_C@_0BA@JDPH@BMODEL_DRAWTURB?$AA@ DB 'BMODEL_DRAWTURB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LEMI@BMODEL_WAVEHEIGHT?$AA@
CONST	SEGMENT
??_C@_0BC@LEMI@BMODEL_WAVEHEIGHT?$AA@ DB 'BMODEL_WAVEHEIGHT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DHNK@TERRAIN_NUM_LAYERS?5?$CFi?$AA@
CONST	SEGMENT
??_C@_0BG@DHNK@TERRAIN_NUM_LAYERS?5?$CFi?$AA@ DB 'TERRAIN_NUM_LAYERS %i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CMG@BMODEL_HAS_DETAIL?$AA@
CONST	SEGMENT
??_C@_0BC@CMG@BMODEL_HAS_DETAIL?$AA@ DB 'BMODEL_HAS_DETAIL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BDDM@BMODEL_REFLECTION_PLANAR?$AA@
CONST	SEGMENT
??_C@_0BJ@BDDM@BMODEL_REFLECTION_PLANAR?$AA@ DB 'BMODEL_REFLECTION_PLANAR'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EFAO@BMODEL_FOG_EXP?$AA@
CONST	SEGMENT
??_C@_0P@EFAO@BMODEL_FOG_EXP?$AA@ DB 'BMODEL_FOG_EXP', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4@00000000000000000000
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT ?GL_UberShaderForSolidBmodel@@YAGPAUmsurface_s@@_N@Z
_TEXT	SEGMENT
_s$ = 8
_translucent$ = 12
_glname$ = -64
_options$ = -576
_landscape$ = -580
_es$ = -584
_fullBright$ = -588
_mirror$ = -592
_tx$ = -596
_i$72007 = -600
_shader$ = -604
_shaderNum$ = -608
?GL_UberShaderForSolidBmodel@@YAGPAUmsurface_s@@_N@Z PROC NEAR ; GL_UberShaderForSolidBmodel, COMDAT

; 1083 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 696				; 000002b8H
	push	ebx
	push	esi
	push	edi

; 1084 : 	char glname[64];
; 1085 : 	char options[MAX_OPTIONS_LENGTH];
; 1086 : 	mfaceinfo_t *landscape = NULL;

	mov	DWORD PTR _landscape$[ebp], 0

; 1087 : 	mextrasurf_t *es = s->info;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _es$[ebp], ecx

; 1088 : 	bool fullBright = false;

	mov	BYTE PTR _fullBright$[ebp], 0

; 1089 : 	bool mirror = false;

	mov	BYTE PTR _mirror$[ebp], 0

; 1090 : 
; 1091 : 	ASSERT( worldmodel != NULL );

	cmp	DWORD PTR ?worldmodel@@3PAUmodel_s@@A, 0 ; worldmodel
	jne	SHORT $L71990
	movsx	edx, WORD PTR ?__LINE__Var@?1??GL_UberShaderForSolidBmodel@@YAGPAUmsurface_s@@_N@Z@4FA ; `GL_UberShaderForSolidBmodel'::`2'::__LINE__Var
	add	edx, 8
	push	edx
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71990:

; 1092 : 
; 1093 : 	if( !FBitSet( s->flags, SURF_SCREEN ) && s->info->subtexture[glState.stack_position] )

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1024				; 00000400H
	test	ecx, ecx
	jne	SHORT $L71991
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR ?glState@@3UglState_t@@A+112200
	movsx	edx, WORD PTR [eax+ecx*2+206]
	test	edx, edx
	je	SHORT $L71991

; 1094 : 		mirror = true;

	mov	BYTE PTR _mirror$[ebp], 1
$L71991:

; 1095 : 
; 1096 : 	landscape = s->texinfo->faceinfo;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _landscape$[ebp], edx

; 1097 : 
; 1098 : 	if( es->shaderNum[mirror] && es->glsl_sequence[mirror] == tr.glsl_valid_sequence )

	mov	eax, DWORD PTR _mirror$[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _es$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+eax*2+166]
	test	edx, edx
	je	SHORT $L71992
	mov	eax, DWORD PTR _mirror$[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _es$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+eax*2+176]
	cmp	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1412000
	jne	SHORT $L71992

; 1099 : 		return es->shaderNum[mirror]; // valid

	mov	eax, DWORD PTR _mirror$[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _es$[ebp]
	mov	ax, WORD PTR [ecx+eax*2+166]
	jmp	$L71982
$L71992:

; 1100 : 
; 1101 : 	Q_strncpy( glname, "BmodelSolid", sizeof( glname ));

	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_0M@IHGG@BmodelSolid?$AA@ ; `string'
	lea	edx, DWORD PTR _glname$[ebp]
	push	edx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1102 : 	memset( options, 0, sizeof( options ));

	push	512					; 00000200H
	push	0
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1103 : 
; 1104 : 	texture_t *tx = s->texinfo->texture;

	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _tx$[ebp], eax

; 1105 : 
; 1106 : 	if( FBitSet( s->flags, SURF_REFLECT ) && CVAR_TO_BOOL( r_allow_mirrors ))

	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -2147483648			; 80000000H
	test	edx, edx
	je	SHORT $L71995
	cmp	DWORD PTR ?r_allow_mirrors@@3PAUcvar_s@@A, 0 ; r_allow_mirrors
	je	SHORT $L72907
	mov	eax, DWORD PTR ?r_allow_mirrors@@3PAUcvar_s@@A ; r_allow_mirrors
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72907
	mov	BYTE PTR -612+[ebp], 1
	jmp	SHORT $L72908
$L72907:
	mov	BYTE PTR -612+[ebp], 0
$L72908:
	mov	ecx, DWORD PTR -612+[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L71995

; 1107 : 		fullBright = true;

	mov	BYTE PTR _fullBright$[ebp], 1
$L71995:

; 1108 : 
; 1109 : 	if( FBitSet( s->flags, SURF_PORTAL ) && CVAR_TO_BOOL( r_allow_portals ))

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $L71996
	cmp	DWORD PTR ?r_allow_portals@@3PAUcvar_s@@A, 0 ; r_allow_portals
	je	SHORT $L72909
	mov	ecx, DWORD PTR ?r_allow_portals@@3PAUcvar_s@@A ; r_allow_portals
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72909
	mov	BYTE PTR -616+[ebp], 1
	jmp	SHORT $L72910
$L72909:
	mov	BYTE PTR -616+[ebp], 0
$L72910:
	mov	edx, DWORD PTR -616+[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L71996

; 1110 : 		fullBright = true;

	mov	BYTE PTR _fullBright$[ebp], 1
$L71996:

; 1111 : 
; 1112 : 	if( FBitSet( s->flags, SURF_SCREEN ) && CVAR_TO_BOOL( r_allow_screens ))

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1024				; 00000400H
	test	ecx, ecx
	je	SHORT $L71997
	cmp	DWORD PTR ?r_allow_screens@@3PAUcvar_s@@A, 0 ; r_allow_screens
	je	SHORT $L72911
	mov	edx, DWORD PTR ?r_allow_screens@@3PAUcvar_s@@A ; r_allow_screens
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72911
	mov	BYTE PTR -620+[ebp], 1
	jmp	SHORT $L72912
$L72911:
	mov	BYTE PTR -620+[ebp], 0
$L72912:
	mov	eax, DWORD PTR -620+[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L71997

; 1114 : 		if( RI->currententity && FBitSet( RI->currententity->curstate.iuser1, CF_MONOCHROME ))

	mov	ecx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L71998
	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+948]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L71998

; 1115 : 			GL_AddShaderDirective( options, "BMODEL_MONOCHROME" );

	push	OFFSET FLAT:??_C@_0BC@KBPO@BMODEL_MONOCHROME?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L71998:

; 1116 : 		fullBright = true;

	mov	BYTE PTR _fullBright$[ebp], 1
$L71997:

; 1118 : 
; 1119 : 	if( FBitSet( s->flags, SURF_MOVIE ))

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 2048				; 00000800H
	test	ecx, ecx
	je	SHORT $L72000

; 1120 : 		fullBright = true;

	mov	BYTE PTR _fullBright$[ebp], 1
$L72000:

; 1121 : 
; 1122 : 	// solid water with lightmaps looks ugly
; 1123 : 	if( FBitSet( s->flags, SURF_DRAWTURB ) || translucent )

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L72002
	mov	ecx, DWORD PTR _translucent$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L72001
$L72002:

; 1124 : 		fullBright = true;

	mov	BYTE PTR _fullBright$[ebp], 1
$L72001:

; 1125 : 
; 1126 : 	if( FBitSet( s->flags, SURF_FULLBRIGHT ) || R_FullBright( ) || fullBright )

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	jne	SHORT $L72004
	cmp	DWORD PTR ?r_fullbright@@3PAUcvar_s@@A, 0 ; r_fullbright
	je	SHORT $L72913
	mov	ecx, DWORD PTR ?r_fullbright@@3PAUcvar_s@@A ; r_fullbright
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72913
	mov	BYTE PTR -624+[ebp], 1
	jmp	SHORT $L72914
$L72913:
	mov	BYTE PTR -624+[ebp], 0
$L72914:
	mov	edx, DWORD PTR -624+[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L72004
	mov	eax, DWORD PTR ?worldmodel@@3PAUmodel_s@@A ; worldmodel
	cmp	DWORD PTR [eax+380], 0
	je	SHORT $L72004
	mov	ecx, DWORD PTR _fullBright$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L72003
$L72004:

; 1128 : 		GL_AddShaderDirective( options, "BMODEL_FULLBRIGHT" );

	push	OFFSET FLAT:??_C@_0BC@HJK@BMODEL_FULLBRIGHT?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8

; 1130 : 	else

	jmp	$L72012
$L72003:

; 1132 : 		// process lightstyles
; 1133 : 		for( int i = 0; i < MAXLIGHTMAPS && s->styles[i] != LS_NONE; i++ )

	mov	DWORD PTR _i$72007[ebp], 0
	jmp	SHORT $L72008
$L72009:
	mov	eax, DWORD PTR _i$72007[ebp]
	add	eax, 1
	mov	DWORD PTR _i$72007[ebp], eax
$L72008:
	cmp	DWORD PTR _i$72007[ebp], 4
	jge	SHORT $L72010
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, DWORD PTR _i$72007[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+60]
	cmp	edx, 255				; 000000ffH
	je	SHORT $L72010

; 1134 : 			GL_AddShaderDirective( options, va( "BMODEL_APPLY_STYLE%i", i ));

	mov	eax, DWORD PTR _i$72007[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@CMPL@BMODEL_APPLY_STYLE?$CFi?$AA@ ; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
	jmp	SHORT $L72009
$L72010:

; 1135 : 
; 1136 : 		if( tx->fb_texturenum != 0 )

	mov	edx, DWORD PTR _tx$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+52]
	test	eax, eax
	je	SHORT $L72012

; 1137 : 			GL_AddShaderDirective( options, "BMODEL_HAS_LUMA" );

	push	OFFSET FLAT:??_C@_0BA@CGBF@BMODEL_HAS_LUMA?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72012:

; 1139 : 
; 1140 : 	if( FBitSet( s->flags, SURF_DRAWTURB ))

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 16					; 00000010H
	test	eax, eax
	je	SHORT $L72016

; 1142 : 		GL_AddShaderDirective( options, "BMODEL_DRAWTURB" );

	push	OFFSET FLAT:??_C@_0BA@JDPH@BMODEL_DRAWTURB?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8

; 1143 : 
; 1144 : 		if( RI->currententity && RI->currententity->curstate.scale)

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $L72016
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+16]
	fld	DWORD PTR [ecx+752]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72016

; 1145 : 			GL_AddShaderDirective( options, "BMODEL_WAVEHEIGHT" );

	push	OFFSET FLAT:??_C@_0BC@LEMI@BMODEL_WAVEHEIGHT?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72016:

; 1147 : 
; 1148 : #if 0
; 1149 : 	// can't properly draw for beams particles through glass. g-cont
; 1150 : 	// disabled for now
; 1151 : 	if( translucent )
; 1152 : 		GL_AddShaderDirective( options, "BMODEL_TRANSLUCENT" );
; 1153 : #endif
; 1154 : 	if( FBitSet( s->flags, SURF_LANDSCAPE ) && landscape && landscape->terrain )

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	test	ecx, ecx
	je	$L72018
	cmp	DWORD PTR _landscape$[ebp], 0
	je	$L72018
	mov	edx, DWORD PTR _landscape$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	$L72018

; 1156 : 		if( landscape->terrain->layermap.gl_diffuse_id != 0 )

	mov	eax, DWORD PTR _landscape$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+2208]
	test	edx, edx
	je	SHORT $L72019

; 1158 : 			GL_AddShaderDirective( options, va( "TERRAIN_NUM_LAYERS %i", landscape->terrain->numLayers ));

	mov	eax, DWORD PTR _landscape$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx+2212]
	push	edx
	push	OFFSET FLAT:??_C@_0BG@DHNK@TERRAIN_NUM_LAYERS?5?$CFi?$AA@ ; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8

; 1159 : 			GL_AddShaderDirective( options, "BMODEL_MULTI_LAYERS" );

	push	OFFSET FLAT:??_C@_0BE@DAAC@BMODEL_MULTI_LAYERS?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72019:

; 1161 : 
; 1162 : 		if( landscape->terrain->indexmap.gl_diffuse_id != 0 && CVAR_TO_BOOL( r_detailtextures ))

	mov	edx, DWORD PTR _landscape$[ebp]
	mov	eax, DWORD PTR [edx+48]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+144]
	test	ecx, ecx
	je	SHORT $L72021
	cmp	DWORD PTR ?r_detailtextures@@3PAUcvar_s@@A, 0 ; r_detailtextures
	je	SHORT $L72915
	mov	edx, DWORD PTR ?r_detailtextures@@3PAUcvar_s@@A ; r_detailtextures
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72915
	mov	BYTE PTR -628+[ebp], 1
	jmp	SHORT $L72916
$L72915:
	mov	BYTE PTR -628+[ebp], 0
$L72916:
	mov	eax, DWORD PTR -628+[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L72021

; 1163 : 			GL_AddShaderDirective( options, "BMODEL_HAS_DETAIL" );

	push	OFFSET FLAT:??_C@_0BC@CMG@BMODEL_HAS_DETAIL?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72021:

; 1165 : 	else

	jmp	SHORT $L72024
$L72018:

; 1167 : 		if( tx->dt_texturenum != 0 && CVAR_TO_BOOL( r_detailtextures ))

	mov	edx, DWORD PTR _tx$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+54]
	test	eax, eax
	je	SHORT $L72024
	cmp	DWORD PTR ?r_detailtextures@@3PAUcvar_s@@A, 0 ; r_detailtextures
	je	SHORT $L72917
	mov	ecx, DWORD PTR ?r_detailtextures@@3PAUcvar_s@@A ; r_detailtextures
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72917
	mov	BYTE PTR -632+[ebp], 1
	jmp	SHORT $L72918
$L72917:
	mov	BYTE PTR -632+[ebp], 0
$L72918:
	mov	edx, DWORD PTR -632+[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72024

; 1168 : 			GL_AddShaderDirective( options, "BMODEL_HAS_DETAIL" );

	push	OFFSET FLAT:??_C@_0BC@CMG@BMODEL_HAS_DETAIL?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72024:

; 1170 : 
; 1171 : 	if( !FBitSet( s->flags, SURF_SCREEN ) && s->info->subtexture[glState.stack_position] > 0 )

	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 1024				; 00000400H
	test	edx, edx
	jne	SHORT $L72025
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR ?glState@@3UglState_t@@A+112200
	movsx	eax, WORD PTR [ecx+edx*2+206]
	test	eax, eax
	jle	SHORT $L72025

; 1172 : 		GL_AddShaderDirective( options, "BMODEL_REFLECTION_PLANAR" );

	push	OFFSET FLAT:??_C@_0BJ@BDDM@BMODEL_REFLECTION_PLANAR?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72025:

; 1173 : 
; 1174 : 	if( tr.fogEnabled )

	xor	edx, edx
	mov	dl, BYTE PTR ?tr@@3Uref_globals_t@@A+1411956
	test	edx, edx
	je	SHORT $L72027

; 1175 : 		GL_AddShaderDirective( options, "BMODEL_FOG_EXP" );

	push	OFFSET FLAT:??_C@_0P@EFAO@BMODEL_FOG_EXP?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72027:

; 1176 : 
; 1177 : 	glsl_program_t *shader = GL_FindUberShader( glname, options, &GL_InitSolidBmodelUniforms );

	push	OFFSET FLAT:?GL_InitSolidBmodelUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitSolidBmodelUniforms
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	lea	edx, DWORD PTR _glname$[ebp]
	push	edx
	call	?GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU1@@Z@Z ; GL_FindUberShader
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _shader$[ebp], eax

; 1178 : 
; 1179 : 	if( !shader )

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L72030

; 1181 : 		tr.fClearScreen = true; // to avoid ugly blur

	mov	BYTE PTR ?tr@@3Uref_globals_t@@A+2, 1

; 1182 : 		SetBits( s->flags, SURF_NODRAW );

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ch, 64					; 00000040H
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1183 : 		return 0; // something bad happens

	xor	ax, ax
	jmp	SHORT $L71982
$L72030:

; 1185 : 
; 1186 : 	word shaderNum = (shader - glsl_programs);

	mov	eax, DWORD PTR _shader$[ebp]
	sub	eax, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	cdq
	mov	ecx, 876				; 0000036cH
	idiv	ecx
	mov	WORD PTR _shaderNum$[ebp], ax

; 1187 : #if 0
; 1188 : 	// can't properly draw for beams particles through glass. g-cont
; 1189 : 	// disabled for now
; 1190 : 	if( translucent )
; 1191 : 		SetBits( shader->status, SHADER_USE_SCREENCOPY );
; 1192 : #endif
; 1193 : 	es->glsl_sequence[mirror] = tr.glsl_valid_sequence;

	mov	edx, DWORD PTR _mirror$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _es$[ebp]
	mov	cx, WORD PTR ?tr@@3Uref_globals_t@@A+1412000
	mov	WORD PTR [eax+edx*2+176], cx

; 1194 : 	ClearBits( s->flags, SURF_NODRAW );

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	ah, -65					; ffffffbfH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1195 : 	es->shaderNum[mirror] = shaderNum;

	mov	edx, DWORD PTR _mirror$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _es$[ebp]
	mov	cx, WORD PTR _shaderNum$[ebp]
	mov	WORD PTR [eax+edx*2+166], cx

; 1196 : 	
; 1197 : 	return shaderNum;

	mov	ax, WORD PTR _shaderNum$[ebp]
$L71982:

; 1198 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_UberShaderForSolidBmodel@@YAGPAUmsurface_s@@_N@Z ENDP ; GL_UberShaderForSolidBmodel
_TEXT	ENDS
PUBLIC	??_C@_05JKGE@?$CFs?5?$CFs?$AA@			; `string'
PUBLIC	?__LINE__Var@?1??GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU2@@Z@Z@4FA@30a12103 ; `GL_FindUberShader'::`2'::__LINE__Var
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
EXTRN	?COM_HashKey@@YAIPBDI@Z:NEAR			; COM_HashKey
EXTRN	?GL_Support@@YA_NH@Z:NEAR			; GL_Support
;	COMDAT ?__LINE__Var@?1??GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU2@@Z@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU2@@Z@Z@4FA@30a12103 DW 0265H ; `GL_FindUberShader'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_05JKGE@?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_05JKGE@?$CFs?5?$CFs?$AA@ DB '%s %s', 00H		; `string'
CONST	ENDS
;	COMDAT ?GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU1@@Z@Z
_TEXT	SEGMENT
_glname$ = 8
_options$ = 12
_pfnInitUniforms$ = 16
_find$ = -4
_i$ = -8
_hash$ = -12
_prog$ = -16
?GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU1@@Z@Z PROC NEAR ; GL_FindUberShader, COMDAT

; 613  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 614  : 	const char	*find;
; 615  : 	unsigned int	i, hash;
; 616  : 	glsl_program_t	*prog;
; 617  : 
; 618  : 	if( !GL_Support( R_SHADER_GLSL100_EXT ))

	push	8
	call	?GL_Support@@YA_NH@Z			; GL_Support
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L71806

; 619  : 		return NULL;

	xor	eax, eax
	jmp	$L71801
$L71806:

; 620  : 
; 621  : 	ASSERT( glname != NULL );

	cmp	DWORD PTR _glname$[ebp], 0
	jne	SHORT $L71808
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU2@@Z@Z@4FA@30a12103 ; `GL_FindUberShader'::`2'::__LINE__Var
	add	eax, 8
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71808:

; 622  : 
; 623  : 	find = va( "%s %s", glname, options );

	mov	ecx, DWORD PTR _options$[ebp]
	push	ecx
	mov	edx, DWORD PTR _glname$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_05JKGE@?$CFs?5?$CFs?$AA@ ; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _find$[ebp], eax

; 624  : 	hash = COM_HashKey( find, SHADERS_HASH_SIZE );

	push	128					; 00000080H
	mov	eax, DWORD PTR _find$[ebp]
	push	eax
	call	?COM_HashKey@@YAIPBDI@Z			; COM_HashKey
	add	esp, 8
	mov	DWORD PTR _hash$[ebp], eax

; 625  : 
; 626  : 	// check for coexist
; 627  : 	for( prog = glsl_programsHashTable[hash]; prog != NULL; prog = prog->nextHash )

	mov	ecx, DWORD PTR _hash$[ebp]
	mov	edx, DWORD PTR ?glsl_programsHashTable@@3PAPAUglsl_prog_s@@A[ecx*4]
	mov	DWORD PTR _prog$[ebp], edx
	jmp	SHORT $L71809
$L71810:
	mov	eax, DWORD PTR _prog$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	mov	DWORD PTR _prog$[ebp], ecx
$L71809:
	cmp	DWORD PTR _prog$[ebp], 0
	je	SHORT $L71811

; 629  : 		if( !Q_strcmp( prog->name, glname ) && !Q_strcmp( prog->options, options ))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _glname$[ebp]
	push	edx
	mov	eax, DWORD PTR _prog$[ebp]
	push	eax
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L71812
	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _options$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prog$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L71812

; 630  : 			return prog;

	mov	eax, DWORD PTR _prog$[ebp]
	jmp	SHORT $L71801
$L71812:

; 631  : 	}

	jmp	SHORT $L71810
$L71811:

; 632  : 
; 633  : 	// find free spot
; 634  : 	for( i = 1; i < num_glsl_programs; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L71813
$L71814:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L71813:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?num_glsl_programs@@3IA	; num_glsl_programs
	jae	SHORT $L71815

; 635  : 		if( !glsl_programs[i].name[0] )

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 876				; 0000036cH
	movsx	eax, BYTE PTR ?glsl_programs@@3PAUglsl_prog_s@@A[edx]
	test	eax, eax
	jne	SHORT $L71816

; 636  : 			break;

	jmp	SHORT $L71815
$L71816:

; 637  : 
; 638  : 	prog = GL_CreateUberShader( i, glname, options, pfnInitUniforms );

	jmp	SHORT $L71814
$L71815:
	mov	ecx, DWORD PTR _pfnInitUniforms$[ebp]
	push	ecx
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _glname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	?GL_CreateUberShader@@YAPAUglsl_prog_s@@IPBD0P6AXPAU1@@Z@Z ; GL_CreateUberShader
	add	esp, 16					; 00000010H
	mov	DWORD PTR _prog$[ebp], eax

; 639  : 
; 640  : 	if( prog != NULL )

	cmp	DWORD PTR _prog$[ebp], 0
	je	SHORT $L71817

; 642  : 		// add to hash table
; 643  : 		prog->nextHash = glsl_programsHashTable[hash];

	mov	edx, DWORD PTR _prog$[ebp]
	mov	eax, DWORD PTR _hash$[ebp]
	mov	ecx, DWORD PTR ?glsl_programsHashTable@@3PAPAUglsl_prog_s@@A[eax*4]
	mov	DWORD PTR [edx+584], ecx

; 644  : 		glsl_programsHashTable[hash] = prog;

	mov	edx, DWORD PTR _hash$[ebp]
	mov	eax, DWORD PTR _prog$[ebp]
	mov	DWORD PTR ?glsl_programsHashTable@@3PAPAUglsl_prog_s@@A[edx*4], eax
$L71817:

; 646  : 
; 647  : 	return prog;

	mov	eax, DWORD PTR _prog$[ebp]
$L71801:

; 648  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU1@@Z@Z ENDP ; GL_FindUberShader
_TEXT	ENDS
PUBLIC	??_C@_0O@GCHP@attr_Position?$AA@		; `string'
PUBLIC	??_C@_0P@FMMD@attr_TexCoord0?$AA@		; `string'
PUBLIC	??_C@_0P@PGFE@attr_TexCoord1?$AA@		; `string'
PUBLIC	??_C@_0P@JON@attr_TexCoord2?$AA@		; `string'
PUBLIC	??_C@_0M@NANC@attr_Normal?$AA@			; `string'
PUBLIC	??_C@_0BB@HOGI@attr_BoneIndexes?$AA@		; `string'
PUBLIC	??_C@_0BB@CBFE@attr_BoneWeights?$AA@		; `string'
PUBLIC	??_C@_0BB@FGGJ@attr_LightStyles?$AA@		; `string'
PUBLIC	??_C@_0BA@GOGD@attr_LightColor?$AA@		; `string'
PUBLIC	??_C@_0P@EPKC@attr_LightVecs?$AA@		; `string'
PUBLIC	??_C@_0DL@BILI@GL_CreateUberShader?3?5GLSL?5shader@ ; `string'
PUBLIC	??_C@_0BO@BLMD@CompileUberShader?5?$CD?$CFi?3?5?$CFs?6?$CFs?6?$AA@ ; `string'
EXTRN	?pglCreateProgramObjectARB@@3P6GIXZA:DWORD	; pglCreateProgramObjectARB
EXTRN	?pglBindAttribLocationARB@@3P6GXIIPBD@ZA:DWORD	; pglBindAttribLocationARB
;	COMDAT ??_C@_0O@GCHP@attr_Position?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0O@GCHP@attr_Position?$AA@ DB 'attr_Position', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FMMD@attr_TexCoord0?$AA@
CONST	SEGMENT
??_C@_0P@FMMD@attr_TexCoord0?$AA@ DB 'attr_TexCoord0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PGFE@attr_TexCoord1?$AA@
CONST	SEGMENT
??_C@_0P@PGFE@attr_TexCoord1?$AA@ DB 'attr_TexCoord1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JON@attr_TexCoord2?$AA@
CONST	SEGMENT
??_C@_0P@JON@attr_TexCoord2?$AA@ DB 'attr_TexCoord2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NANC@attr_Normal?$AA@
CONST	SEGMENT
??_C@_0M@NANC@attr_Normal?$AA@ DB 'attr_Normal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HOGI@attr_BoneIndexes?$AA@
CONST	SEGMENT
??_C@_0BB@HOGI@attr_BoneIndexes?$AA@ DB 'attr_BoneIndexes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CBFE@attr_BoneWeights?$AA@
CONST	SEGMENT
??_C@_0BB@CBFE@attr_BoneWeights?$AA@ DB 'attr_BoneWeights', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FGGJ@attr_LightStyles?$AA@
CONST	SEGMENT
??_C@_0BB@FGGJ@attr_LightStyles?$AA@ DB 'attr_LightStyles', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GOGD@attr_LightColor?$AA@
CONST	SEGMENT
??_C@_0BA@GOGD@attr_LightColor?$AA@ DB 'attr_LightColor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EPKC@attr_LightVecs?$AA@
CONST	SEGMENT
??_C@_0P@EPKC@attr_LightVecs?$AA@ DB 'attr_LightVecs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@BILI@GL_CreateUberShader?3?5GLSL?5shader@
CONST	SEGMENT
??_C@_0DL@BILI@GL_CreateUberShader?3?5GLSL?5shader@ DB 'GL_CreateUberShad'
	DB	'er: GLSL shaders limit exceeded (%i max)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BLMD@CompileUberShader?5?$CD?$CFi?3?5?$CFs?6?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BO@BLMD@CompileUberShader?5?$CD?$CFi?3?5?$CFs?6?$CFs?6?$AA@ DB 'Co'
	DB	'mpileUberShader #%i: %s', 0aH, '%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?GL_CreateUberShader@@YAPAUglsl_prog_s@@IPBD0P6AXPAU1@@Z@Z
_TEXT	SEGMENT
_slot$ = 8
_glname$ = 12
_options$ = 16
_pfnInitUniforms$ = 20
_shader$ = -4
?GL_CreateUberShader@@YAPAUglsl_prog_s@@IPBD0P6AXPAU1@@Z@Z PROC NEAR ; GL_CreateUberShader, COMDAT

; 551  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 552  : 	if( !GL_Support( R_SHADER_GLSL100_EXT ))

	push	8
	call	?GL_Support@@YA_NH@Z			; GL_Support
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L71787

; 553  : 		return NULL;

	xor	eax, eax
	jmp	$L71786
$L71787:

; 554  : 
; 555  : 	if( num_glsl_programs >= MAX_GLSL_PROGRAMS )

	cmp	DWORD PTR ?num_glsl_programs@@3IA, 512	; num_glsl_programs, 00000200H
	jb	SHORT $L71788

; 557  : 		ALERT( at_error, "GL_CreateUberShader: GLSL shaders limit exceeded (%i max)\n", MAX_GLSL_PROGRAMS );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_0DL@BILI@GL_CreateUberShader?3?5GLSL?5shader@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH

; 558  : 		return NULL;

	xor	eax, eax
	jmp	$L71786
$L71788:

; 560  : 
; 561  : 	// alloc new shader
; 562  : 	glsl_program_t *shader = &glsl_programs[slot];

	mov	eax, DWORD PTR _slot$[ebp]
	imul	eax, 876				; 0000036cH
	add	eax, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	mov	DWORD PTR _shader$[ebp], eax

; 563  : 
; 564  : 	shader->handle = pglCreateProgramObjectARB();

	call	DWORD PTR ?pglCreateProgramObjectARB@@3P6GIXZA ; pglCreateProgramObjectARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+576], eax

; 565  : 	if( !shader->handle ) return NULL; // some bad happens

	mov	edx, DWORD PTR _shader$[ebp]
	cmp	DWORD PTR [edx+576], 0
	jne	SHORT $L71791
	xor	eax, eax
	jmp	$L71786
$L71791:

; 566  : 
; 567  : 	Q_strncpy( shader->name, glname, sizeof( shader->name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _glname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 568  : 	Q_strncpy( shader->options, options, sizeof( shader->options ));

	push	512					; 00000200H
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _shader$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 569  : 
; 570  : 	GL_LoadGPUShader( shader, glname, GL_VERTEX_SHADER_ARB, true, options );

	mov	ecx, DWORD PTR _options$[ebp]
	push	ecx
	push	1
	push	35633					; 00008b31H
	mov	edx, DWORD PTR _glname$[ebp]
	push	edx
	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z ; GL_LoadGPUShader
	add	esp, 20					; 00000014H

; 571  : 	GL_LoadGPUShader( shader, glname, GL_FRAGMENT_SHADER_ARB, true, options );

	mov	ecx, DWORD PTR _options$[ebp]
	push	ecx
	push	1
	push	35632					; 00008b30H
	mov	edx, DWORD PTR _glname$[ebp]
	push	edx
	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z ; GL_LoadGPUShader
	add	esp, 20					; 00000014H

; 572  : 
; 573  : 	if( FBitSet( shader->status, SHADER_VERTEX_COMPILED ))

	mov	ecx, DWORD PTR _shader$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+580]
	and	edx, 1
	test	edx, edx
	je	$L71792

; 575  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_POSITION, "attr_Position" );

	push	OFFSET FLAT:??_C@_0O@GCHP@attr_Position?$AA@ ; `string'
	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 576  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_TEXCOORD0, "attr_TexCoord0" );

	push	OFFSET FLAT:??_C@_0P@FMMD@attr_TexCoord0?$AA@ ; `string'
	push	2
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 577  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_TEXCOORD1, "attr_TexCoord1" );

	push	OFFSET FLAT:??_C@_0P@PGFE@attr_TexCoord1?$AA@ ; `string'
	push	3
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 578  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_TEXCOORD2, "attr_TexCoord2" );

	push	OFFSET FLAT:??_C@_0P@JON@attr_TexCoord2?$AA@ ; `string'
	push	4
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 579  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_NORMAL, "attr_Normal" );

	push	OFFSET FLAT:??_C@_0M@NANC@attr_Normal?$AA@ ; `string'
	push	1
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 580  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_BONE_INDEXES, "attr_BoneIndexes" );

	push	OFFSET FLAT:??_C@_0BB@HOGI@attr_BoneIndexes?$AA@ ; `string'
	push	5
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 581  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_BONE_WEIGHTS, "attr_BoneWeights" );

	push	OFFSET FLAT:??_C@_0BB@CBFE@attr_BoneWeights?$AA@ ; `string'
	push	6
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 582  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_LIGHT_STYLES, "attr_LightStyles" );

	push	OFFSET FLAT:??_C@_0BB@FGGJ@attr_LightStyles?$AA@ ; `string'
	push	7
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 583  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_LIGHT_COLOR, "attr_LightColor" );

	push	OFFSET FLAT:??_C@_0BA@GOGD@attr_LightColor?$AA@ ; `string'
	push	8
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 584  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_LIGHT_VECS, "attr_LightVecs" );

	push	OFFSET FLAT:??_C@_0P@EPKC@attr_LightVecs?$AA@ ; `string'
	push	9
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB
$L71792:

; 586  : 
; 587  : 	GL_LinkProgram( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_LinkProgram@@YAXPAUglsl_prog_s@@@Z	; GL_LinkProgram
	add	esp, 4

; 588  : 
; 589  : 	if( pfnInitUniforms != NULL && FBitSet( shader->status, SHADER_PROGRAM_LINKED ))

	cmp	DWORD PTR _pfnInitUniforms$[ebp], 0
	je	SHORT $L71793
	mov	eax, DWORD PTR _shader$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+580]
	and	ecx, 4
	test	ecx, ecx
	je	SHORT $L71793

; 590  : 		pfnInitUniforms( shader ); // register shader uniforms

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	DWORD PTR _pfnInitUniforms$[ebp]
	add	esp, 4
$L71793:

; 591  : 
; 592  : 	shader->status |= SHADER_UBERSHADER; // it's UberShader!

	mov	eax, DWORD PTR _shader$[ebp]
	mov	cx, WORD PTR [eax+580]
	or	cl, 8
	mov	edx, DWORD PTR _shader$[ebp]
	mov	WORD PTR [edx+580], cx

; 593  : 
; 594  : 	ALERT( at_aiconsole, "CompileUberShader #%i: %s\n%s\n", slot, glname, options );

	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	ecx, DWORD PTR _glname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _slot$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BO@BLMD@CompileUberShader?5?$CD?$CFi?3?5?$CFs?6?$CFs?6?$AA@ ; `string'
	push	2
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 20					; 00000014H

; 595  : 
; 596  : 	if( slot == num_glsl_programs )

	mov	eax, DWORD PTR _slot$[ebp]
	cmp	eax, DWORD PTR ?num_glsl_programs@@3IA	; num_glsl_programs
	jne	SHORT $L71795

; 598  : 		if( num_glsl_programs == MAX_GLSL_PROGRAMS )

	cmp	DWORD PTR ?num_glsl_programs@@3IA, 512	; num_glsl_programs, 00000200H
	jne	SHORT $L71796

; 600  : 			ALERT( at_error, "GL_CreateUberShader: GLSL shaders limit exceeded (%i max)\n", MAX_GLSL_PROGRAMS );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_0DL@BILI@GL_CreateUberShader?3?5GLSL?5shader@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH

; 601  : 			GL_FreeGPUShader( shader );

	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_FreeGPUShader@@YAXPAUglsl_prog_s@@@Z ; GL_FreeGPUShader
	add	esp, 4

; 602  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $L71786
$L71796:

; 604  : 		num_glsl_programs++;

	mov	edx, DWORD PTR ?num_glsl_programs@@3IA	; num_glsl_programs
	add	edx, 1
	mov	DWORD PTR ?num_glsl_programs@@3IA, edx	; num_glsl_programs
$L71795:

; 606  : 
; 607  : 	// all done, program is loaded
; 608  : 
; 609  : 	return shader;

	mov	eax, DWORD PTR _shader$[ebp]
$L71786:

; 610  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_CreateUberShader@@YAPAUglsl_prog_s@@IPBD0P6AXPAU1@@Z@Z ENDP ; GL_CreateUberShader
_TEXT	ENDS
PUBLIC	?GetBuffer@CVirtualFS@@QAEPADXZ			; CVirtualFS::GetBuffer
PUBLIC	?GetSize@CVirtualFS@@QAEIXZ			; CVirtualFS::GetSize
PUBLIC	?__LINE__Var@?1??GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z@4FA@30a12103 ; `GL_LoadGPUShader'::`2'::__LINE__Var
PUBLIC	??_C@_0BA@PHEN@glsl?1?$CFs_vp?4glsl?$AA@	; `string'
PUBLIC	??_C@_0BA@BOBH@glsl?1?$CFs_fp?4glsl?$AA@	; `string'
PUBLIC	??_C@_0CK@FCBH@GL_LoadGPUShader?3?5unknown?5shader@ ; `string'
PUBLIC	??_C@_0O@BLBN@loading?5?8?$CFs?8?6?$AA@		; `string'
PUBLIC	??_C@_02DILL@?$CFs?$AA@				; `string'
PUBLIC	??_C@_0BD@BJIP@Shader?5options?3?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0BF@GPIL@Couldn?8t?5compile?5?$CFs?6?$AA@	; `string'
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?gEngfuncs@@3Ucl_enginefuncs_s@@A:BYTE		; gEngfuncs
EXTRN	?pglDeleteObjectARB@@3P6GXI@ZA:DWORD		; pglDeleteObjectARB
EXTRN	?pglCreateShaderObjectARB@@3P6GII@ZA:DWORD	; pglCreateShaderObjectARB
EXTRN	?pglShaderSourceARB@@3P6GXIHPAPBDPBH@ZA:DWORD	; pglShaderSourceARB
EXTRN	?pglCompileShaderARB@@3P6GXI@ZA:DWORD		; pglCompileShaderARB
EXTRN	?pglAttachObjectARB@@3P6GXII@ZA:DWORD		; pglAttachObjectARB
EXTRN	?Q_snprintf@@YAHPADIPBDZZ:NEAR			; Q_snprintf
;	COMDAT ?__LINE__Var@?1??GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z@4FA@30a12103 DW 0d5H ; `GL_LoadGPUShader'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@PHEN@glsl?1?$CFs_vp?4glsl?$AA@
CONST	SEGMENT
??_C@_0BA@PHEN@glsl?1?$CFs_vp?4glsl?$AA@ DB 'glsl/%s_vp.glsl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BOBH@glsl?1?$CFs_fp?4glsl?$AA@
CONST	SEGMENT
??_C@_0BA@BOBH@glsl?1?$CFs_fp?4glsl?$AA@ DB 'glsl/%s_fp.glsl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FCBH@GL_LoadGPUShader?3?5unknown?5shader@
CONST	SEGMENT
??_C@_0CK@FCBH@GL_LoadGPUShader?3?5unknown?5shader@ DB 'GL_LoadGPUShader:'
	DB	' unknown shader type %p', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BLBN@loading?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0O@BLBN@loading?5?8?$CFs?8?6?$AA@ DB 'loading ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DILL@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DILL@?$CFs?$AA@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BJIP@Shader?5options?3?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BD@BJIP@Shader?5options?3?$CFs?6?$AA@ DB 'Shader options:%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GPIL@Couldn?8t?5compile?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BF@GPIL@Couldn?8t?5compile?5?$CFs?6?$AA@ DB 'Couldn''t compile %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z$0
xdata$x	ENDS
;	COMDAT ?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_shader$ = 8
_name$ = 12
_shaderType$ = 16
_compatible$ = 20
_defines$ = 24
_filename$ = -268
_object$ = -272
_source$ = -288
_compiled$ = -292
_buffer$ = -296
_bufferSize$ = -300
?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z PROC NEAR ; GL_LoadGPUShader, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 356				; 00000164H
	push	ebx
	push	esi
	push	edi

; 214  : 	char		filename[256];
; 215  : 	GLhandleARB	object;
; 216  : 	CVirtualFS	source;

	lea	ecx, DWORD PTR _source$[ebp]
	call	??0CVirtualFS@@QAE@XZ			; CVirtualFS::CVirtualFS
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 217  : 	GLint		compiled;
; 218  : 
; 219  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71583
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z@4FA@30a12103 ; `GL_LoadGPUShader'::`2'::__LINE__Var
	add	eax, 6
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71583:

; 222  : 	{

	mov	ecx, DWORD PTR _shaderType$[ebp]
	mov	DWORD PTR -304+[ebp], ecx
	cmp	DWORD PTR -304+[ebp], 35632		; 00008b30H
	je	SHORT $L71592
	cmp	DWORD PTR -304+[ebp], 35633		; 00008b31H
	je	SHORT $L71590
	jmp	SHORT $L71594
$L71590:

; 223  : 	case GL_VERTEX_SHADER_ARB:
; 224  : 		Q_snprintf( filename, sizeof( filename ), "glsl/%s_vp.glsl", name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BA@PHEN@glsl?1?$CFs_vp?4glsl?$AA@ ; `string'
	push	256					; 00000100H
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 225  : 		break;

	jmp	SHORT $L71587
$L71592:

; 226  : 	case GL_FRAGMENT_SHADER_ARB:
; 227  : 		Q_snprintf( filename, sizeof( filename ), "glsl/%s_fp.glsl", name );

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BA@BOBH@glsl?1?$CFs_fp?4glsl?$AA@ ; `string'
	push	256					; 00000100H
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 228  : 		break;

	jmp	SHORT $L71587
$L71594:

; 229  : 	default:
; 230  : 		ALERT( at_error, "GL_LoadGPUShader: unknown shader type %p\n", shaderType );

	mov	eax, DWORD PTR _shaderType$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CK@FCBH@GL_LoadGPUShader?3?5unknown?5shader@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH

; 231  : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _source$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	jmp	$L71577
$L71587:

; 233  : 
; 234  : 	// load includes, add some directives
; 235  : 	if( !GL_ProcessShader( filename, &source, compatible, defines ))

	mov	ecx, DWORD PTR _defines$[ebp]
	push	ecx
	mov	dl, BYTE PTR _compatible$[ebp]
	push	edx
	lea	eax, DWORD PTR _source$[ebp]
	push	eax
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	?GL_ProcessShader@@YA_NPBDPAVCVirtualFS@@_N0@Z ; GL_ProcessShader
	add	esp, 16					; 00000010H
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L71596

; 236  : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _source$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	jmp	$L71577
$L71596:

; 237  : 
; 238  : 	GLcharARB *buffer = (GLcharARB *)source.GetBuffer();

	lea	ecx, DWORD PTR _source$[ebp]
	call	?GetBuffer@CVirtualFS@@QAEPADXZ		; CVirtualFS::GetBuffer
	mov	DWORD PTR _buffer$[ebp], eax

; 239  : 	int bufferSize = source.GetSize();

	lea	ecx, DWORD PTR _source$[ebp]
	call	?GetSize@CVirtualFS@@QAEIXZ		; CVirtualFS::GetSize
	mov	DWORD PTR _bufferSize$[ebp], eax

; 240  : 
; 241  : 	ALERT( at_aiconsole, "loading '%s'\n", filename );

	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0O@BLBN@loading?5?8?$CFs?8?6?$AA@ ; `string'
	push	2
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH

; 242  : 	object = pglCreateShaderObjectARB( shaderType );

	mov	eax, DWORD PTR _shaderType$[ebp]
	push	eax
	call	DWORD PTR ?pglCreateShaderObjectARB@@3P6GII@ZA ; pglCreateShaderObjectARB
	mov	DWORD PTR _object$[ebp], eax

; 243  : 	pglShaderSourceARB( object, GL_TRUE, (const GLcharARB **)&buffer, &bufferSize );

	lea	ecx, DWORD PTR _bufferSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _object$[ebp]
	push	eax
	call	DWORD PTR ?pglShaderSourceARB@@3P6GXIHPAPBDPBH@ZA ; pglShaderSourceARB

; 244  : 
; 245  : 	// compile shader
; 246  : 	pglCompileShaderARB( object );

	mov	ecx, DWORD PTR _object$[ebp]
	push	ecx
	call	DWORD PTR ?pglCompileShaderARB@@3P6GXI@ZA ; pglCompileShaderARB

; 247  : 
; 248  : 	// check if shader compiled
; 249  : 	pglGetObjectParameterivARB( object, GL_OBJECT_COMPILE_STATUS_ARB, &compiled );

	lea	edx, DWORD PTR _compiled$[ebp]
	push	edx
	push	35713					; 00008b81H
	mov	eax, DWORD PTR _object$[ebp]
	push	eax
	call	DWORD PTR ?pglGetObjectParameterivARB@@3P6GXIIPAH@ZA ; pglGetObjectParameterivARB

; 250  : 
; 251  : 	if( !compiled )

	cmp	DWORD PTR _compiled$[ebp], 0
	jne	SHORT $L71602

; 253  : 		if( developer_level ) Msg( "%s", GL_PrintInfoLog( object ));

	cmp	DWORD PTR ?developer_level@@3HA, 0	; developer_level
	je	SHORT $L71603
	mov	ecx, DWORD PTR _object$[ebp]
	push	ecx
	call	?GL_PrintInfoLog@@YAPADI@Z		; GL_PrintInfoLog
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_02DILL@?$CFs?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+160
	add	esp, 8
$L71603:

; 254  : 		if( developer_level ) Msg( "Shader options:%s\n", GL_PretifyListOptions( defines ));

	cmp	DWORD PTR ?developer_level@@3HA, 0	; developer_level
	je	SHORT $L71605
	push	0
	mov	edx, DWORD PTR _defines$[ebp]
	push	edx
	call	?GL_PretifyListOptions@@YAPBDPBD_N@Z	; GL_PretifyListOptions
	add	esp, 8
	push	eax
	push	OFFSET FLAT:??_C@_0BD@BJIP@Shader?5options?3?$CFs?6?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+160
	add	esp, 8
$L71605:

; 255  : 		ALERT( at_error, "Couldn't compile %s\n", filename ); 

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@GPIL@Couldn?8t?5compile?5?$CFs?6?$AA@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH

; 256  : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _source$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	jmp	SHORT $L71577
$L71602:

; 258  : 
; 259  : 	if( shaderType == GL_VERTEX_SHADER_ARB )

	cmp	DWORD PTR _shaderType$[ebp], 35633	; 00008b31H
	jne	SHORT $L71608

; 260  : 		shader->status |= SHADER_VERTEX_COMPILED;

	mov	ecx, DWORD PTR _shader$[ebp]
	mov	dx, WORD PTR [ecx+580]
	or	dl, 1
	mov	eax, DWORD PTR _shader$[ebp]
	mov	WORD PTR [eax+580], dx

; 261  : 	else shader->status |= SHADER_FRAGMENT_COMPILED;

	jmp	SHORT $L71609
$L71608:
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	dx, WORD PTR [ecx+580]
	or	dl, 2
	mov	eax, DWORD PTR _shader$[ebp]
	mov	WORD PTR [eax+580], dx
$L71609:

; 262  : 
; 263  : 	// attach shader to program
; 264  : 	pglAttachObjectARB( shader->handle, object );

	mov	ecx, DWORD PTR _object$[ebp]
	push	ecx
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglAttachObjectARB@@3P6GXII@ZA ; pglAttachObjectARB

; 265  : 
; 266  : 	// delete shader, no longer needed
; 267  : 	pglDeleteObjectARB( object );

	mov	ecx, DWORD PTR _object$[ebp]
	push	ecx
	call	DWORD PTR ?pglDeleteObjectARB@@3P6GXI@ZA ; pglDeleteObjectARB

; 268  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _source$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
$L71577:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z$0:
	lea	ecx, DWORD PTR _source$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	ret	0
__ehhandler$?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z ENDP	; GL_LoadGPUShader
;	COMDAT ?GetBuffer@CVirtualFS@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4
?GetBuffer@CVirtualFS@@QAEPADXZ PROC NEAR		; CVirtualFS::GetBuffer, COMDAT

; 27   : 	char *GetBuffer( void ) { return (char *)m_pBuffer; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuffer@CVirtualFS@@QAEPADXZ ENDP			; CVirtualFS::GetBuffer
_TEXT	ENDS
;	COMDAT ?GetSize@CVirtualFS@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetSize@CVirtualFS@@QAEIXZ PROC NEAR			; CVirtualFS::GetSize, COMDAT

; 28   : 	size_t GetSize( void ) { return m_iLength; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@CVirtualFS@@QAEIXZ ENDP			; CVirtualFS::GetSize
_TEXT	ENDS
PUBLIC	??_C@_0O@CNKF@?$CDversion?5120?6?$AA@		; `string'
PUBLIC	??_C@_0DJ@NELG@?$CDifndef?5M_PI?6?$CDdefine?5M_PI?53?41415@ ; `string'
PUBLIC	??_C@_0DL@JDPI@?$CDifndef?5M_PI2?6?$CDdefine?5M_PI2?56?428@ ; `string'
PUBLIC	??_C@_0CJ@DKLD@?$CDextension?5GL_EXT_gpu_shader4?5?3?5@ ; `string'
PUBLIC	??_C@_0BK@ODNP@?$CDdefine?5GLSL_gpu_shader4?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@FIBF@?$CDdefine?5GLSL_ALLOW_TEXTURE_ARRAY@ ; `string'
PUBLIC	??_C@_0CL@ICPE@?$CDextension?5GL_EXT_texture_array?5@ ; `string'
PUBLIC	??_C@_0DJ@BENL@?$CDifndef?5MAXSTUDIOBONES?6?$CDdefine?5M@ ; `string'
PUBLIC	??_C@_0DL@DFIJ@?$CDifndef?5MAX_LIGHTSTYLES?6?$CDdefine?5@ ; `string'
PUBLIC	??_C@_0DF@GEGD@?$CDifndef?5MAXLIGHTMAPS?6?$CDdefine?5MAX@ ; `string'
PUBLIC	??_C@_0DL@LILL@?$CDifndef?5GRASS_ANIM_DIST?6?$CDdefine?5@ ; `string'
_BSS	SEGMENT
_file_stack_pos DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@CNKF@?$CDversion?5120?6?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0O@CNKF@?$CDversion?5120?6?$AA@ DB '#version 120', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@NELG@?$CDifndef?5M_PI?6?$CDdefine?5M_PI?53?41415@
CONST	SEGMENT
??_C@_0DJ@NELG@?$CDifndef?5M_PI?6?$CDdefine?5M_PI?53?41415@ DB '#ifndef M'
	DB	'_PI', 0aH, '#define M_PI 3.14159265358979323846', 0aH, '#endi'
	DB	'f', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@JDPI@?$CDifndef?5M_PI2?6?$CDdefine?5M_PI2?56?428@
CONST	SEGMENT
??_C@_0DL@JDPI@?$CDifndef?5M_PI2?6?$CDdefine?5M_PI2?56?428@ DB '#ifndef M'
	DB	'_PI2', 0aH, '#define M_PI2 6.28318530717958647692', 0aH, '#en'
	DB	'dif', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DKLD@?$CDextension?5GL_EXT_gpu_shader4?5?3?5@
CONST	SEGMENT
??_C@_0CJ@DKLD@?$CDextension?5GL_EXT_gpu_shader4?5?3?5@ DB '#extension GL'
	DB	'_EXT_gpu_shader4 : require', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ODNP@?$CDdefine?5GLSL_gpu_shader4?6?$AA@
CONST	SEGMENT
??_C@_0BK@ODNP@?$CDdefine?5GLSL_gpu_shader4?6?$AA@ DB '#define GLSL_gpu_s'
	DB	'hader4', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FIBF@?$CDdefine?5GLSL_ALLOW_TEXTURE_ARRAY@
CONST	SEGMENT
??_C@_0CC@FIBF@?$CDdefine?5GLSL_ALLOW_TEXTURE_ARRAY@ DB '#define GLSL_ALL'
	DB	'OW_TEXTURE_ARRAY', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ICPE@?$CDextension?5GL_EXT_texture_array?5@
CONST	SEGMENT
??_C@_0CL@ICPE@?$CDextension?5GL_EXT_texture_array?5@ DB '#extension GL_E'
	DB	'XT_texture_array : require', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BENL@?$CDifndef?5MAXSTUDIOBONES?6?$CDdefine?5M@
CONST	SEGMENT
??_C@_0DJ@BENL@?$CDifndef?5MAXSTUDIOBONES?6?$CDdefine?5M@ DB '#ifndef MAX'
	DB	'STUDIOBONES', 0aH, '#define MAXSTUDIOBONES %i', 0aH, '#endif', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@DFIJ@?$CDifndef?5MAX_LIGHTSTYLES?6?$CDdefine?5@
CONST	SEGMENT
??_C@_0DL@DFIJ@?$CDifndef?5MAX_LIGHTSTYLES?6?$CDdefine?5@ DB '#ifndef MAX'
	DB	'_LIGHTSTYLES', 0aH, '#define MAX_LIGHTSTYLES %i', 0aH, '#endi'
	DB	'f', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GEGD@?$CDifndef?5MAXLIGHTMAPS?6?$CDdefine?5MAX@
CONST	SEGMENT
??_C@_0DF@GEGD@?$CDifndef?5MAXLIGHTMAPS?6?$CDdefine?5MAX@ DB '#ifndef MAX'
	DB	'LIGHTMAPS', 0aH, '#define MAXLIGHTMAPS %i', 0aH, '#endif', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@LILL@?$CDifndef?5GRASS_ANIM_DIST?6?$CDdefine?5@
CONST	SEGMENT
??_C@_0DL@LILL@?$CDifndef?5GRASS_ANIM_DIST?6?$CDdefine?5@ DB '#ifndef GRA'
	DB	'SS_ANIM_DIST', 0aH, '#define GRASS_ANIM_DIST %f', 0aH, '#endi'
	DB	'f', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GL_ProcessShader@@YA_NPBDPAVCVirtualFS@@_N0@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GL_ProcessShader@@YA_NPBDPAVCVirtualFS@@_N0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GL_ProcessShader@@YA_NPBDPAVCVirtualFS@@_N0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GL_ProcessShader@@YA_NPBDPAVCVirtualFS@@_N0@Z$0
xdata$x	ENDS
;	COMDAT ?GL_ProcessShader@@YA_NPBDPAVCVirtualFS@@_N0@Z
_TEXT	SEGMENT
$T72945 = -32
$T72946 = -36
__$EHRec$ = -12
_filename$ = 8
_out$ = 12
_defines$ = 20
_file$ = -28
?GL_ProcessShader@@YA_NPBDPAVCVirtualFS@@_N0@Z PROC NEAR ; GL_ProcessShader, COMDAT

; 174  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GL_ProcessShader@@YA_NPBDPAVCVirtualFS@@_N0@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 175  : 	CVirtualFS file;

	lea	ecx, DWORD PTR _file$[ebp]
	call	??0CVirtualFS@@QAE@XZ			; CVirtualFS::CVirtualFS
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 176  : 
; 177  : 	file_stack_pos = 0;	// debug

	mov	DWORD PTR _file_stack_pos, 0

; 178  : 
; 179  : 	if( !GL_LoadSource( filename, &file ))

	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	?GL_LoadSource@@YA_NPBDPAVCVirtualFS@@@Z ; GL_LoadSource
	add	esp, 8
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L71551

; 180  : 		return false;

	mov	BYTE PTR $T72945[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	mov	al, BYTE PTR $T72945[ebp]
	jmp	$L71549
$L71551:

; 181  : 
; 182  : 	// add internal defines
; 183  : 	out->Printf( "#version 120\n" ); // g-cont. version 110 is working fine too

	push	OFFSET FLAT:??_C@_0O@CNKF@?$CDversion?5120?6?$AA@ ; `string'
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 184  : 	out->Printf( "#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n" );

	push	OFFSET FLAT:??_C@_0DJ@NELG@?$CDifndef?5M_PI?6?$CDdefine?5M_PI?53?41415@ ; `string'
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 185  : 	out->Printf( "#ifndef M_PI2\n#define M_PI2 6.28318530717958647692\n#endif\n" );

	push	OFFSET FLAT:??_C@_0DL@JDPI@?$CDifndef?5M_PI2?6?$CDdefine?5M_PI2?56?428@ ; `string'
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 186  : 	if( GL_Support( R_EXT_GPU_SHADER4 ))

	push	4
	call	?GL_Support@@YA_NH@Z			; GL_Support
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L71556

; 188  : 		out->Printf( "#extension GL_EXT_gpu_shader4 : require\n" ); // support bitwise ops

	push	OFFSET FLAT:??_C@_0CJ@DKLD@?$CDextension?5GL_EXT_gpu_shader4?5?3?5@ ; `string'
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 189  : 		out->Printf( "#define GLSL_gpu_shader4\n" );

	push	OFFSET FLAT:??_C@_0BK@ODNP@?$CDdefine?5GLSL_gpu_shader4?6?$AA@ ; `string'
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 190  : 		if( GL_Support( R_TEXTURE_ARRAY_EXT ))

	push	5
	call	?GL_Support@@YA_NH@Z			; GL_Support
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L71559

; 191  : 			out->Printf( "#define GLSL_ALLOW_TEXTURE_ARRAY\n" );

	push	OFFSET FLAT:??_C@_0CC@FIBF@?$CDdefine?5GLSL_ALLOW_TEXTURE_ARRAY@ ; `string'
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8
$L71559:

; 193  : 	else if( GL_Support( R_TEXTURE_ARRAY_EXT ))

	jmp	SHORT $L71562
$L71556:
	push	5
	call	?GL_Support@@YA_NH@Z			; GL_Support
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L71562

; 195  : 		out->Printf( "#extension GL_EXT_texture_array : require\n" ); // support texture arrays

	push	OFFSET FLAT:??_C@_0CL@ICPE@?$CDextension?5GL_EXT_texture_array?5@ ; `string'
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 196  : 		out->Printf( "#define GLSL_ALLOW_TEXTURE_ARRAY\n" );

	push	OFFSET FLAT:??_C@_0CC@FIBF@?$CDdefine?5GLSL_ALLOW_TEXTURE_ARRAY@ ; `string'
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8
$L71562:

; 198  : 	if( defines ) out->Print( defines );

	cmp	DWORD PTR _defines$[ebp], 0
	je	SHORT $L71564
	mov	ecx, DWORD PTR _defines$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _out$[ebp]
	call	?Print@CVirtualFS@@QAEIPBD@Z		; CVirtualFS::Print
$L71564:

; 199  : 
; 200  : 	// user may override this constants
; 201  : 	out->Printf( "#ifndef MAXSTUDIOBONES\n#define MAXSTUDIOBONES %i\n#endif\n", glConfig.max_skinning_bones );

	mov	edx, DWORD PTR ?glConfig@@3UglConfig_t@@A+72
	push	edx
	push	OFFSET FLAT:??_C@_0DJ@BENL@?$CDifndef?5MAXSTUDIOBONES?6?$CDdefine?5M@ ; `string'
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 202  : 	out->Printf( "#ifndef MAX_LIGHTSTYLES\n#define MAX_LIGHTSTYLES %i\n#endif\n", MAX_LIGHTSTYLES );

	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_0DL@DFIJ@?$CDifndef?5MAX_LIGHTSTYLES?6?$CDdefine?5@ ; `string'
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 203  : 	out->Printf( "#ifndef MAXLIGHTMAPS\n#define MAXLIGHTMAPS %i\n#endif\n", MAXLIGHTMAPS );

	push	4
	push	OFFSET FLAT:??_C@_0DF@GEGD@?$CDifndef?5MAXLIGHTMAPS?6?$CDdefine?5MAX@ ; `string'
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 204  : 	out->Printf( "#ifndef GRASS_ANIM_DIST\n#define GRASS_ANIM_DIST %f\n#endif\n", GRASS_ANIM_DIST );

	push	1082130432				; 40800000H
	push	0
	push	OFFSET FLAT:??_C@_0DL@LILL@?$CDifndef?5GRASS_ANIM_DIST?6?$CDdefine?5@ ; `string'
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 16					; 00000010H

; 205  : 
; 206  : 	GL_ParseFile( filename, &file, out );

	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z	; GL_ParseFile
	add	esp, 12					; 0000000cH

; 207  : 	out->Write( "", 1 ); // terminator

	push	1
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _out$[ebp]
	call	?Write@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Write

; 208  : 
; 209  : 	return true;

	mov	BYTE PTR $T72946[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	mov	al, BYTE PTR $T72946[ebp]
$L71549:

; 210  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GL_ProcessShader@@YA_NPBDPAVCVirtualFS@@_N0@Z$0:
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	ret	0
__ehhandler$?GL_ProcessShader@@YA_NPBDPAVCVirtualFS@@_N0@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GL_ProcessShader@@YA_NPBDPAVCVirtualFS@@_N0@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GL_ProcessShader@@YA_NPBDPAVCVirtualFS@@_N0@Z ENDP	; GL_ProcessShader
PUBLIC	??_C@_0BK@OIMK@recursive?5include?5for?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@LNAL@couldn?8t?5load?5?$CFs?6?$AA@	; `string'
;	COMDAT ??_C@_0BK@OIMK@recursive?5include?5for?5?$CFs?6?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0BK@OIMK@recursive?5include?5for?5?$CFs?6?$AA@ DB 'recursive includ'
	DB	'e for %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LNAL@couldn?8t?5load?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BC@LNAL@couldn?8t?5load?5?$CFs?6?$AA@ DB 'couldn''t load %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?GL_LoadSource@@YA_NPBDPAVCVirtualFS@@@Z
_TEXT	SEGMENT
_filename$ = 8
_file$ = 12
_size$ = -4
_source$ = -8
?GL_LoadSource@@YA_NPBDPAVCVirtualFS@@@Z PROC NEAR	; GL_LoadSource, COMDAT

; 110  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 111  : 	if( GL_CheckFileStack( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?GL_CheckFileStack@@YA_NPBD@Z		; GL_CheckFileStack
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L71513

; 113  : 		ALERT( at_error, "recursive include for %s\n", filename );

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BK@OIMK@recursive?5include?5for?5?$CFs?6?$AA@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH

; 114  : 		return false;

	xor	al, al
	jmp	SHORT $L71512
$L71513:

; 118  : 	char *source = (char *)gEngfuncs.COM_LoadFile((char *)filename, 5, &size );

	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	push	5
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+316
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _source$[ebp], eax

; 119  : 	if( !source )

	cmp	DWORD PTR _source$[ebp], 0
	jne	SHORT $L71519

; 121  : 		ALERT( at_error, "couldn't load %s\n", filename );

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BC@LNAL@couldn?8t?5load?5?$CFs?6?$AA@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH

; 122  : 		return false;

	xor	al, al
	jmp	SHORT $L71512
$L71519:

; 124  : 
; 125  : 	GL_PushFileStack( filename );

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	?GL_PushFileStack@@YA_NPBD@Z		; GL_PushFileStack
	add	esp, 4

; 126  : 	file->Write( source, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _file$[ebp]
	call	?Write@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Write

; 127  : 	file->Seek( 0, SEEK_SET ); // rewind

	push	0
	push	0
	mov	ecx, DWORD PTR _file$[ebp]
	call	?Seek@CVirtualFS@@QAEHIH@Z		; CVirtualFS::Seek

; 128  : 
; 129  : 	gEngfuncs.COM_FreeFile( source );

	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+324
	add	esp, 4

; 130  : 
; 131  : 	return true;

	mov	al, 1
$L71512:

; 132  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_LoadSource@@YA_NPBDPAVCVirtualFS@@@Z ENDP		; GL_LoadSource
_TEXT	ENDS
PUBLIC	??_C@_0CC@ICLD@GL_PushFileStack?3?5stack?5overflow@ ; `string'
_BSS	SEGMENT
_filenames_stack DB 04000H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CC@ICLD@GL_PushFileStack?3?5stack?5overflow@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0CC@ICLD@GL_PushFileStack?3?5stack?5overflow@ DB 'GL_PushFileStack:'
	DB	' stack overflow', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?GL_PushFileStack@@YA_NPBD@Z
_TEXT	SEGMENT
_filename$ = 8
?GL_PushFileStack@@YA_NPBD@Z PROC NEAR			; GL_PushFileStack, COMDAT

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 75   : 	if( file_stack_pos < MAX_FILE_STACK )

	cmp	DWORD PTR _file_stack_pos, 64		; 00000040H
	jge	SHORT $L71494

; 77   : 		Q_strncpy( filenames_stack[file_stack_pos], filename, sizeof( filenames_stack[0] ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file_stack_pos
	shl	ecx, 8
	add	ecx, OFFSET FLAT:_filenames_stack
	push	ecx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 78   : 		file_stack_pos++;

	mov	edx, DWORD PTR _file_stack_pos
	add	edx, 1
	mov	DWORD PTR _file_stack_pos, edx

; 79   : 		return true;

	mov	al, 1
	jmp	SHORT $L71493
$L71494:

; 81   : 
; 82   : 	ALERT( at_error, "GL_PushFileStack: stack overflow\n" );

	push	OFFSET FLAT:??_C@_0CC@ICLD@GL_PushFileStack?3?5stack?5overflow@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 8

; 83   : 	return false;

	xor	al, al
$L71493:

; 84   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_PushFileStack@@YA_NPBD@Z ENDP			; GL_PushFileStack
_TEXT	ENDS
EXTRN	?Q_strnicmp@@YAHPBD0H@Z:NEAR			; Q_strnicmp
;	COMDAT ?GL_CheckFileStack@@YA_NPBD@Z
_TEXT	SEGMENT
_filename$ = 8
_i$ = -4
?GL_CheckFileStack@@YA_NPBD@Z PROC NEAR			; GL_CheckFileStack, COMDAT

; 100  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 101  : 	for( int i = 0; i < file_stack_pos; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L71505
$L71506:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L71505:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _file_stack_pos
	jge	SHORT $L71507

; 103  : 		if( !Q_stricmp( filenames_stack[i], filename ))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, OFFSET FLAT:_filenames_stack
	push	eax
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L71508

; 104  : 			return true;

	mov	al, 1
	jmp	SHORT $L71503
$L71508:

; 105  : 	}

	jmp	SHORT $L71506
$L71507:

; 106  : 	return false;

	xor	al, al
$L71503:

; 107  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_CheckFileStack@@YA_NPBD@Z ENDP			; GL_CheckFileStack
_TEXT	ENDS
PUBLIC	??_C@_08POEE@?$CDline?50?6?$AA@			; `string'
PUBLIC	??_C@_08HOOI@?$CDinclude?$AA@			; `string'
PUBLIC	??_C@_07GDNJ@glsl?1?$CFs?$AA@			; `string'
PUBLIC	??_C@_09EDEG@?$CDline?5?$CFi?6?$AA@		; `string'
PUBLIC	??_C@_03HHKO@?$CFs?6?$AA@			; `string'
EXTRN	?COM_ParseFileExt@@YAPADPAD0J_N@Z:NEAR		; COM_ParseFileExt
;	COMDAT ??_C@_08POEE@?$CDline?50?6?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_08POEE@?$CDline?50?6?$AA@ DB '#line 0', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HOOI@?$CDinclude?$AA@
CONST	SEGMENT
??_C@_08HOOI@?$CDinclude?$AA@ DB '#include', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GDNJ@glsl?1?$CFs?$AA@
CONST	SEGMENT
??_C@_07GDNJ@glsl?1?$CFs?$AA@ DB 'glsl/%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EDEG@?$CDline?5?$CFi?6?$AA@
CONST	SEGMENT
??_C@_09EDEG@?$CDline?5?$CFi?6?$AA@ DB '#line %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HHKO@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03HHKO@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z$0
xdata$x	ENDS
;	COMDAT ?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_file$ = 12
_out$ = 16
_pfile$ = -16
_token$ = -272
_ret$ = -276
_fileline$ = -280
_line$ = -2328
_incfile$71537 = -2344
_incname$71538 = -2600
?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z PROC NEAR	; GL_ParseFile, COMDAT

; 135  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 2652				; 00000a5cH
	push	ebx
	push	esi
	push	edi

; 136  : 	char	*pfile, token[256];
; 137  : 	int	ret, fileline = 1;

	mov	DWORD PTR _fileline$[ebp], 1

; 138  : 	char	line[2048];
; 139  : 
; 140  : //	out->Printf( "#file %s\n", filename );	// OpenGL doesn't support #file :-(
; 141  : 	out->Printf( "#line 0\n" );

	push	OFFSET FLAT:??_C@_08POEE@?$CDline?50?6?$AA@ ; `string'
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8
$L71532:

; 145  : 		ret = file->Gets( line, sizeof( line ));

	push	2048					; 00000800H
	lea	ecx, DWORD PTR _line$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _file$[ebp]
	call	?Gets@CVirtualFS@@QAEHPADI@Z		; CVirtualFS::Gets
	mov	DWORD PTR _ret$[ebp], eax

; 146  : 		pfile = line;

	lea	edx, DWORD PTR _line$[ebp]
	mov	DWORD PTR _pfile$[ebp], edx

; 147  : 
; 148  : 		// NOTE: if first keyword it's not an '#include' just ignore it
; 149  : 		pfile = COM_ParseFile( pfile, token );

	push	1
	push	256					; 00000100H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	?COM_ParseFileExt@@YAPADPAD0J_N@Z	; COM_ParseFileExt
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pfile$[ebp], eax

; 150  : 		if( !Q_strcmp( token, "#include" ))

	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_08HOOI@?$CDinclude?$AA@ ; `string'
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$L71535

; 152  : 			CVirtualFS incfile;

	lea	ecx, DWORD PTR _incfile$71537[ebp]
	call	??0CVirtualFS@@QAE@XZ			; CVirtualFS::CVirtualFS
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 153  : 			char incname[256];
; 154  : 
; 155  : 			pfile = COM_ParseLine( pfile, token );

	push	0
	push	256					; 00000100H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	?COM_ParseFileExt@@YAPADPAD0J_N@Z	; COM_ParseFileExt
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pfile$[ebp], eax

; 156  : 			Q_snprintf( incname, sizeof( incname ), "glsl/%s", token );

	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_07GDNJ@glsl?1?$CFs?$AA@ ; `string'
	push	256					; 00000100H
	lea	eax, DWORD PTR _incname$71538[ebp]
	push	eax
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 157  : 			if( !GL_LoadSource( incname, &incfile ))

	lea	ecx, DWORD PTR _incfile$71537[ebp]
	push	ecx
	lea	edx, DWORD PTR _incname$71538[ebp]
	push	edx
	call	?GL_LoadSource@@YA_NPBDPAVCVirtualFS@@@Z ; GL_LoadSource
	add	esp, 8
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L71540

; 159  : 				fileline++;

	mov	eax, DWORD PTR _fileline$[ebp]
	add	eax, 1
	mov	DWORD PTR _fileline$[ebp], eax

; 160  : 				continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incfile$71537[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	jmp	SHORT $L71533
$L71540:

; 162  : 			GL_ParseFile( incname, &incfile, out );

	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	lea	edx, DWORD PTR _incfile$71537[ebp]
	push	edx
	lea	eax, DWORD PTR _incname$71538[ebp]
	push	eax
	call	?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z	; GL_ParseFile
	add	esp, 12					; 0000000cH

; 163  : //			out->Printf( "#file %s\n", filename );	// OpenGL doesn't support #file :-(
; 164  : 			out->Printf( "#line %i\n", fileline );

	mov	ecx, DWORD PTR _fileline$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_09EDEG@?$CDline?5?$CFi?6?$AA@ ; `string'
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 165  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incfile$71537[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS

; 166  : 		else out->Printf( "%s\n", line );

	jmp	SHORT $L71542
$L71535:
	lea	eax, DWORD PTR _line$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_03HHKO@?$CFs?6?$AA@	; `string'
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH
$L71542:

; 167  : 		fileline++;

	mov	edx, DWORD PTR _fileline$[ebp]
	add	edx, 1
	mov	DWORD PTR _fileline$[ebp], edx
$L71533:

; 168  : 	} while( ret != EOF );

	cmp	DWORD PTR _ret$[ebp], -1
	jne	$L71532

; 169  : 
; 170  : 	GL_PopFileStack();

	call	?GL_PopFileStack@@YA_NXZ		; GL_PopFileStack

; 171  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z$0:
	lea	ecx, DWORD PTR _incfile$71537[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	ret	0
__ehhandler$?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GL_ParseFile@@YAXPBDPAVCVirtualFS@@1@Z ENDP		; GL_ParseFile
PUBLIC	??_C@_0CD@LKDI@GL_PushFileStack?3?5stack?5underflo@ ; `string'
;	COMDAT ??_C@_0CD@LKDI@GL_PushFileStack?3?5stack?5underflo@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0CD@LKDI@GL_PushFileStack?3?5stack?5underflo@ DB 'GL_PushFileStack:'
	DB	' stack underflow', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?GL_PopFileStack@@YA_NXZ
_TEXT	SEGMENT
?GL_PopFileStack@@YA_NXZ PROC NEAR			; GL_PopFileStack, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 88   : 	file_stack_pos--;

	mov	eax, DWORD PTR _file_stack_pos
	sub	eax, 1
	mov	DWORD PTR _file_stack_pos, eax

; 89   : 
; 90   : 	if( file_stack_pos < 0 )

	cmp	DWORD PTR _file_stack_pos, 0
	jge	SHORT $L71499

; 92   : 		ALERT( at_error, "GL_PushFileStack: stack underflow\n" );

	push	OFFSET FLAT:??_C@_0CD@LKDI@GL_PushFileStack?3?5stack?5underflo@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 8

; 93   : 		return false;

	xor	al, al
	jmp	SHORT $L71498
$L71499:

; 95   : 
; 96   : 	return true;

	mov	al, 1
$L71498:

; 97   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_PopFileStack@@YA_NXZ ENDP				; GL_PopFileStack
_TEXT	ENDS
PUBLIC	??_C@_0BN@PJK@?$CFs?6?$CFs?5shader?5failed?5to?5link?6?$AA@ ; `string'
EXTRN	?pglLinkProgramARB@@3P6GXI@ZA:DWORD		; pglLinkProgramARB
;	COMDAT ??_C@_0BN@PJK@?$CFs?6?$CFs?5shader?5failed?5to?5link?6?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0BN@PJK@?$CFs?6?$CFs?5shader?5failed?5to?5link?6?$AA@ DB '%s', 0aH, '%'
	DB	's shader failed to link', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?GL_LinkProgram@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
_linked$ = -4
?GL_LinkProgram@@YAXPAUglsl_prog_s@@@Z PROC NEAR	; GL_LinkProgram, COMDAT

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 272  : 	GLint	linked = 0;

	mov	DWORD PTR _linked$[ebp], 0

; 273  : 
; 274  : 	if( !shader ) return;

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71614
	jmp	SHORT $L71612
$L71614:

; 275  : 
; 276  : 	pglLinkProgramARB( shader->handle );

	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglLinkProgramARB@@3P6GXI@ZA	; pglLinkProgramARB

; 277  : 
; 278  : 	pglGetObjectParameterivARB( shader->handle, GL_OBJECT_LINK_STATUS_ARB, &linked );

	lea	edx, DWORD PTR _linked$[ebp]
	push	edx
	push	35714					; 00008b82H
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetObjectParameterivARB@@3P6GXIIPAH@ZA ; pglGetObjectParameterivARB

; 279  : 	if( !linked ) ALERT( at_error, "%s\n%s shader failed to link\n", GL_PrintInfoLog( shader->handle ), shader->name );

	cmp	DWORD PTR _linked$[ebp], 0
	jne	SHORT $L71615
	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	?GL_PrintInfoLog@@YAPADI@Z		; GL_PrintInfoLog
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BN@PJK@?$CFs?6?$CFs?5shader?5failed?5to?5link?6?$AA@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 16					; 00000010H

; 280  : 	else shader->status |= SHADER_PROGRAM_LINKED;

	jmp	SHORT $L71617
$L71615:
	mov	edx, DWORD PTR _shader$[ebp]
	mov	ax, WORD PTR [edx+580]
	or	al, 4
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	WORD PTR [ecx+580], ax
$L71617:
$L71612:

; 281  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_LinkProgram@@YAXPAUglsl_prog_s@@@Z ENDP		; GL_LinkProgram
_TEXT	ENDS
;	COMDAT ?GL_FreeGPUShader@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
_hash$71772 = -4
_cur$71773 = -8
_prev$71774 = -12
_find$71775 = -16
?GL_FreeGPUShader@@YAXPAUglsl_prog_s@@@Z PROC NEAR	; GL_FreeGPUShader, COMDAT

; 518  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 519  : 	if( shader && shader->handle )

	cmp	DWORD PTR _shader$[ebp], 0
	je	$L71771
	mov	eax, DWORD PTR _shader$[ebp]
	cmp	DWORD PTR [eax+576], 0
	je	$L71771

; 521  : 		unsigned int	hash;
; 522  : 		glsl_program_t	*cur;
; 523  : 		glsl_program_t	**prev;
; 524  : 		const char	*find;
; 525  : 
; 526  : 		find = va( "%s %s", shader->name, shader->options );

	mov	ecx, DWORD PTR _shader$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_05JKGE@?$CFs?5?$CFs?$AA@ ; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _find$71775[ebp], eax

; 527  : 
; 528  : 		// remove from hash table
; 529  : 		hash = COM_HashKey( find, SHADERS_HASH_SIZE );

	push	128					; 00000080H
	mov	eax, DWORD PTR _find$71775[ebp]
	push	eax
	call	?COM_HashKey@@YAIPBDI@Z			; COM_HashKey
	add	esp, 8
	mov	DWORD PTR _hash$71772[ebp], eax

; 530  : 		prev = &glsl_programsHashTable[hash];

	mov	ecx, DWORD PTR _hash$71772[ebp]
	lea	edx, DWORD PTR ?glsl_programsHashTable@@3PAPAUglsl_prog_s@@A[ecx*4]
	mov	DWORD PTR _prev$71774[ebp], edx
$L71777:

; 531  : 
; 532  : 		while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $L71778

; 534  : 			cur = *prev;

	mov	ecx, DWORD PTR _prev$71774[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$71773[ebp], edx

; 535  : 			if( !cur ) break;

	cmp	DWORD PTR _cur$71773[ebp], 0
	jne	SHORT $L71779
	jmp	SHORT $L71778
$L71779:

; 536  : 
; 537  : 			if( cur == shader )

	mov	eax, DWORD PTR _cur$71773[ebp]
	cmp	eax, DWORD PTR _shader$[ebp]
	jne	SHORT $L71780

; 539  : 				*prev = cur->nextHash;

	mov	ecx, DWORD PTR _prev$71774[ebp]
	mov	edx, DWORD PTR _cur$71773[ebp]
	mov	eax, DWORD PTR [edx+584]
	mov	DWORD PTR [ecx], eax

; 540  : 				break;

	jmp	SHORT $L71778
$L71780:

; 542  : 			prev = &cur->nextHash;

	mov	ecx, DWORD PTR _cur$71773[ebp]
	add	ecx, 584				; 00000248H
	mov	DWORD PTR _prev$71774[ebp], ecx

; 543  : 		}

	jmp	SHORT $L71777
$L71778:

; 544  : 
; 545  : 		pglDeleteObjectARB( shader->handle );

	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglDeleteObjectARB@@3P6GXI@ZA ; pglDeleteObjectARB

; 546  : 		memset( shader, 0, sizeof( *shader ));

	push	876					; 0000036cH
	push	0
	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$L71771:

; 548  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_FreeGPUShader@@YAXPAUglsl_prog_s@@@Z ENDP		; GL_FreeGPUShader
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitSolidBmodelUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitSolidBmodelUniforms'::`2'::__LINE__Var
PUBLIC	??_C@_0M@ICKK@u_DetailMap?$AA@			; `string'
PUBLIC	??_C@_0L@NGMC@u_LightMap?$AA@			; `string'
PUBLIC	??_C@_0M@CDNB@u_ScreenMap?$AA@			; `string'
PUBLIC	??_C@_09EKDB@u_GlowMap?$AA@			; `string'
PUBLIC	??_C@_0M@DCKL@u_HeightMap?$AA@			; `string'
PUBLIC	??_C@_0BD@JGPP@u_LightStyleValues?$AA@		; `string'
PUBLIC	??_C@_0O@NMNP@u_ModelMatrix?$AA@		; `string'
PUBLIC	??_C@_0O@DNJP@u_DetailScale?$AA@		; `string'
PUBLIC	??_C@_0M@OCHJ@u_TexOffset?$AA@			; `string'
PUBLIC	??_C@_0BA@PLKN@u_ScreenSizeInv?$AA@		; `string'
PUBLIC	??_C@_0O@IEKC@u_RenderColor?$AA@		; `string'
PUBLIC	??_C@_06OPNC@u_zFar?$AA@			; `string'
;	COMDAT ?__LINE__Var@?1??GL_InitSolidBmodelUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitSolidBmodelUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 029cH ; `GL_InitSolidBmodelUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@ICKK@u_DetailMap?$AA@
CONST	SEGMENT
??_C@_0M@ICKK@u_DetailMap?$AA@ DB 'u_DetailMap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NGMC@u_LightMap?$AA@
CONST	SEGMENT
??_C@_0L@NGMC@u_LightMap?$AA@ DB 'u_LightMap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CDNB@u_ScreenMap?$AA@
CONST	SEGMENT
??_C@_0M@CDNB@u_ScreenMap?$AA@ DB 'u_ScreenMap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EKDB@u_GlowMap?$AA@
CONST	SEGMENT
??_C@_09EKDB@u_GlowMap?$AA@ DB 'u_GlowMap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DCKL@u_HeightMap?$AA@
CONST	SEGMENT
??_C@_0M@DCKL@u_HeightMap?$AA@ DB 'u_HeightMap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JGPP@u_LightStyleValues?$AA@
CONST	SEGMENT
??_C@_0BD@JGPP@u_LightStyleValues?$AA@ DB 'u_LightStyleValues', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NMNP@u_ModelMatrix?$AA@
CONST	SEGMENT
??_C@_0O@NMNP@u_ModelMatrix?$AA@ DB 'u_ModelMatrix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DNJP@u_DetailScale?$AA@
CONST	SEGMENT
??_C@_0O@DNJP@u_DetailScale?$AA@ DB 'u_DetailScale', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OCHJ@u_TexOffset?$AA@
CONST	SEGMENT
??_C@_0M@OCHJ@u_TexOffset?$AA@ DB 'u_TexOffset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLKN@u_ScreenSizeInv?$AA@
CONST	SEGMENT
??_C@_0BA@PLKN@u_ScreenSizeInv?$AA@ DB 'u_ScreenSizeInv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IEKC@u_RenderColor?$AA@
CONST	SEGMENT
??_C@_0O@IEKC@u_RenderColor?$AA@ DB 'u_RenderColor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OPNC@u_zFar?$AA@
CONST	SEGMENT
??_C@_06OPNC@u_zFar?$AA@ DB 'u_zFar', 00H		; `string'
CONST	ENDS
;	COMDAT ?GL_InitSolidBmodelUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitSolidBmodelUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitSolidBmodelUniforms, COMDAT

; 668  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 669  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71836
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitSolidBmodelUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitSolidBmodelUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71836:

; 670  : 
; 671  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 672  : 	shader->u_DetailMap = pglGetUniformLocationARB( shader->handle, "u_DetailMap" );

	push	OFFSET FLAT:??_C@_0M@ICKK@u_DetailMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+604], eax

; 673  : 	shader->u_LightMap = pglGetUniformLocationARB( shader->handle, "u_LightMap" );

	push	OFFSET FLAT:??_C@_0L@NGMC@u_LightMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+620], eax

; 674  : 	shader->u_ScreenMap = pglGetUniformLocationARB( shader->handle, "u_ScreenMap" );

	push	OFFSET FLAT:??_C@_0M@CDNB@u_ScreenMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+632], eax

; 675  : 	shader->u_GlowMap = pglGetUniformLocationARB( shader->handle, "u_GlowMap" );

	push	OFFSET FLAT:??_C@_09EKDB@u_GlowMap?$AA@	; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+644], eax

; 676  : 
; 677  : 	if( GL_FindShaderDirective( shader, "BMODEL_MULTI_LAYERS" ))

	push	OFFSET FLAT:??_C@_0BE@DAAC@BMODEL_MULTI_LAYERS?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_FindShaderDirective@@YA_NPAUglsl_prog_s@@PBD@Z ; GL_FindShaderDirective
	add	esp, 8
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L71842

; 678  : 		shader->u_DepthMap = pglGetUniformLocationARB( shader->handle, "u_HeightMap" );

	push	OFFSET FLAT:??_C@_0M@DCKL@u_HeightMap?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+592], eax
$L71842:

; 679  : 
; 680  : 	shader->u_LightStyleValues = pglGetUniformLocationARB( shader->handle, "u_LightStyleValues" );

	push	OFFSET FLAT:??_C@_0BD@JGPP@u_LightStyleValues?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+748], eax

; 681  : 	shader->u_ModelMatrix = pglGetUniformLocationARB( shader->handle, "u_ModelMatrix" );

	push	OFFSET FLAT:??_C@_0O@NMNP@u_ModelMatrix?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+668], eax

; 682  : 	shader->u_DetailScale = pglGetUniformLocationARB( shader->handle, "u_DetailScale" );

	push	OFFSET FLAT:??_C@_0O@DNJP@u_DetailScale?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+820], eax

; 683  : 	shader->u_TexOffset = pglGetUniformLocationARB( shader->handle, "u_TexOffset" );

	push	OFFSET FLAT:??_C@_0M@OCHJ@u_TexOffset?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+836], eax

; 684  : 	shader->u_FogParams = pglGetUniformLocationARB( shader->handle, "u_FogParams" );

	push	OFFSET FLAT:??_C@_0M@BNFL@u_FogParams?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+768], eax

; 685  : 	shader->u_ScreenSizeInv = pglGetUniformLocationARB( shader->handle, "u_ScreenSizeInv" );

	push	OFFSET FLAT:??_C@_0BA@PLKN@u_ScreenSizeInv?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+704], eax

; 686  : 	shader->u_RenderColor = pglGetUniformLocationARB( shader->handle, "u_RenderColor" );

	push	OFFSET FLAT:??_C@_0O@IEKC@u_RenderColor?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+840], eax

; 687  : 	shader->u_zFar = pglGetUniformLocationARB( shader->handle, "u_zFar" );

	push	OFFSET FLAT:??_C@_06OPNC@u_zFar?$AA@	; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+708], eax

; 688  : 
; 689  : 	GL_BindShader( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 690  : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+588]
	push	edx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 691  : 	pglUniform1iARB( shader->u_DetailMap, GL_TEXTURE1 );

	push	1
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+604]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 692  : 	pglUniform1iARB( shader->u_LightMap, GL_TEXTURE2 );

	push	2
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+620]
	push	eax
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 693  : 	pglUniform1iARB( shader->u_ScreenMap, GL_TEXTURE3 );

	push	3
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+632]
	push	edx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 694  : 
; 695  : 	if( GL_FindShaderDirective( shader, "BMODEL_MULTI_LAYERS" ))

	push	OFFSET FLAT:??_C@_0BE@DAAC@BMODEL_MULTI_LAYERS?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_FindShaderDirective@@YA_NPAUglsl_prog_s@@PBD@Z ; GL_FindShaderDirective
	add	esp, 8
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L71853

; 696  : 		pglUniform1iARB( shader->u_DepthMap, GL_TEXTURE4 );

	push	4
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+592]
	push	edx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB
$L71853:

; 697  : 	pglUniform1iARB( shader->u_GlowMap, GL_TEXTURE5 );

	push	5
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+644]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 698  : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 699  : 
; 700  : 	GL_ValidateProgram( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 701  : 	GL_ShowProgramUniforms( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 702  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitSolidBmodelUniforms@@YAXPAUglsl_prog_s@@@Z ENDP	; GL_InitSolidBmodelUniforms
_TEXT	ENDS
PUBLIC	?GL_UberShaderForBmodelDlight@@YAGPBUplight_s@@PAUmsurface_s@@_N@Z ; GL_UberShaderForBmodelDlight
PUBLIC	??_C@_0N@JHKA@BmodelDlight?$AA@			; `string'
PUBLIC	??_C@_0BN@EAPG@BMODEL_LIGHT_OMNIDIRECTIONAL?$AA@ ; `string'
PUBLIC	??_C@_0BI@FIEA@BMODEL_LIGHT_PROJECTION?$AA@	; `string'
PUBLIC	??_C@_0BD@KLBC@BMODEL_HAS_SHADOWS?$AA@		; `string'
EXTRN	?r_shadows@@3PAUcvar_s@@A:DWORD			; r_shadows
;	COMDAT ??_C@_0N@JHKA@BmodelDlight?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0N@JHKA@BmodelDlight?$AA@ DB 'BmodelDlight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EAPG@BMODEL_LIGHT_OMNIDIRECTIONAL?$AA@
CONST	SEGMENT
??_C@_0BN@EAPG@BMODEL_LIGHT_OMNIDIRECTIONAL?$AA@ DB 'BMODEL_LIGHT_OMNIDIR'
	DB	'ECTIONAL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FIEA@BMODEL_LIGHT_PROJECTION?$AA@
CONST	SEGMENT
??_C@_0BI@FIEA@BMODEL_LIGHT_PROJECTION?$AA@ DB 'BMODEL_LIGHT_PROJECTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KLBC@BMODEL_HAS_SHADOWS?$AA@
CONST	SEGMENT
??_C@_0BD@KLBC@BMODEL_HAS_SHADOWS?$AA@ DB 'BMODEL_HAS_SHADOWS', 00H ; `string'
CONST	ENDS
;	COMDAT ?GL_UberShaderForBmodelDlight@@YAGPBUplight_s@@PAUmsurface_s@@_N@Z
_TEXT	SEGMENT
_pl$ = 8
_s$ = 12
_shadows$ = -4
_glname$ = -68
_options$ = -580
_es$ = -584
_mirrorSurface$ = -588
_portalSurface$ = -592
_landscape$ = -596
_tx$ = -600
_shader$ = -604
_shaderNum$ = -608
?GL_UberShaderForBmodelDlight@@YAGPBUplight_s@@PAUmsurface_s@@_N@Z PROC NEAR ; GL_UberShaderForBmodelDlight, COMDAT

; 1201 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 688				; 000002b0H
	push	ebx
	push	esi
	push	edi

; 1202 : 	bool shadows = (!pl->pointlight && !FBitSet( pl->flags, CF_NOSHADOWS )) ? true : false;

	mov	eax, DWORD PTR _pl$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+44]
	test	ecx, ecx
	jne	SHORT $L72979
	mov	edx, DWORD PTR _pl$[ebp]
	mov	eax, DWORD PTR [edx+428]
	and	eax, 1024				; 00000400H
	test	eax, eax
	jne	SHORT $L72979
	mov	BYTE PTR -609+[ebp], 1
	jmp	SHORT $L72980
$L72979:
	mov	BYTE PTR -609+[ebp], 0
$L72980:
	mov	cl, BYTE PTR -609+[ebp]
	mov	BYTE PTR _shadows$[ebp], cl

; 1203 : 	char glname[64];
; 1204 : 	char options[MAX_OPTIONS_LENGTH];
; 1205 : 	mextrasurf_t *es = s->info;

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _es$[ebp], eax

; 1206 : 	bool mirrorSurface = false;

	mov	BYTE PTR _mirrorSurface$[ebp], 0

; 1207 : 	bool portalSurface = false;

	mov	BYTE PTR _portalSurface$[ebp], 0

; 1208 : 	mfaceinfo_t *landscape = NULL;

	mov	DWORD PTR _landscape$[ebp], 0

; 1209 : 
; 1210 : 	Q_strncpy( glname, "BmodelDlight", sizeof( glname ));

	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_0N@JHKA@BmodelDlight?$AA@ ; `string'
	lea	ecx, DWORD PTR _glname$[ebp]
	push	ecx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1211 : 	memset( options, 0, sizeof( options ));

	push	512					; 00000200H
	push	0
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1212 : 
; 1213 : 	landscape = s->texinfo->faceinfo;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _landscape$[ebp], edx

; 1214 : 
; 1215 : 	if( pl->pointlight )

	mov	eax, DWORD PTR _pl$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+44]
	test	ecx, ecx
	je	SHORT $L72045

; 1217 : 		if( es->omniLightShaderNum && es->glsl_sequence_omni == tr.glsl_valid_sequence )

	mov	edx, DWORD PTR _es$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+170]
	test	eax, eax
	je	SHORT $L72046
	mov	ecx, DWORD PTR _es$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+180]
	cmp	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1412000
	jne	SHORT $L72046

; 1218 : 			return es->omniLightShaderNum; // valid

	mov	eax, DWORD PTR _es$[ebp]
	mov	ax, WORD PTR [eax+170]
	jmp	$L72036
$L72046:

; 1219 : 		GL_AddShaderDirective( options, "BMODEL_LIGHT_OMNIDIRECTIONAL" );

	push	OFFSET FLAT:??_C@_0BN@EAPG@BMODEL_LIGHT_OMNIDIRECTIONAL?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8

; 1221 : 	else

	jmp	SHORT $L72048
$L72045:

; 1223 : 		if( es->projLightShaderNum[shadows] && es->glsl_sequence_proj[shadows] == tr.glsl_valid_sequence )

	mov	edx, DWORD PTR _shadows$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _es$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+edx*2+172]
	test	ecx, ecx
	je	SHORT $L72049
	mov	edx, DWORD PTR _shadows$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _es$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+edx*2+182]
	cmp	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1412000
	jne	SHORT $L72049

; 1224 : 			return es->projLightShaderNum[shadows]; // valid

	mov	edx, DWORD PTR _shadows$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _es$[ebp]
	mov	ax, WORD PTR [eax+edx*2+172]
	jmp	$L72036
$L72049:

; 1225 : 		GL_AddShaderDirective( options, "BMODEL_LIGHT_PROJECTION" );

	push	OFFSET FLAT:??_C@_0BI@FIEA@BMODEL_LIGHT_PROJECTION?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72048:

; 1227 : 
; 1228 : 	texture_t *tx = s->texinfo->texture;

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _tx$[ebp], ecx

; 1229 : 
; 1230 : 	if( FBitSet( s->flags, SURF_LANDSCAPE ) && landscape && landscape->terrain )

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 8192				; 00002000H
	test	eax, eax
	je	$L72052
	cmp	DWORD PTR _landscape$[ebp], 0
	je	$L72052
	mov	ecx, DWORD PTR _landscape$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	$L72052

; 1232 : 		if( landscape->terrain->layermap.gl_diffuse_id != 0 )

	mov	edx, DWORD PTR _landscape$[ebp]
	mov	eax, DWORD PTR [edx+48]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+2208]
	test	ecx, ecx
	je	SHORT $L72053

; 1234 : 			GL_AddShaderDirective( options, va( "TERRAIN_NUM_LAYERS %i", landscape->terrain->numLayers ));

	mov	edx, DWORD PTR _landscape$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR [eax+2212]
	push	ecx
	push	OFFSET FLAT:??_C@_0BG@DHNK@TERRAIN_NUM_LAYERS?5?$CFi?$AA@ ; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 8
	push	eax
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8

; 1235 : 			GL_AddShaderDirective( options, "BMODEL_MULTI_LAYERS" );

	push	OFFSET FLAT:??_C@_0BE@DAAC@BMODEL_MULTI_LAYERS?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72053:

; 1237 : 
; 1238 : 		if( landscape->terrain->indexmap.gl_diffuse_id != 0 && CVAR_TO_BOOL( r_detailtextures ))

	mov	ecx, DWORD PTR _landscape$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	xor	eax, eax
	mov	ax, WORD PTR [edx+144]
	test	eax, eax
	je	SHORT $L72054
	cmp	DWORD PTR ?r_detailtextures@@3PAUcvar_s@@A, 0 ; r_detailtextures
	je	SHORT $L72981
	mov	ecx, DWORD PTR ?r_detailtextures@@3PAUcvar_s@@A ; r_detailtextures
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72981
	mov	BYTE PTR -616+[ebp], 1
	jmp	SHORT $L72982
$L72981:
	mov	BYTE PTR -616+[ebp], 0
$L72982:
	mov	edx, DWORD PTR -616+[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72054

; 1239 : 			GL_AddShaderDirective( options, "BMODEL_HAS_DETAIL" );

	push	OFFSET FLAT:??_C@_0BC@CMG@BMODEL_HAS_DETAIL?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72054:

; 1241 : 	else

	jmp	SHORT $L72056
$L72052:

; 1243 : 		if( tx->dt_texturenum != 0 && CVAR_TO_BOOL( r_detailtextures ))

	mov	ecx, DWORD PTR _tx$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+54]
	test	edx, edx
	je	SHORT $L72056
	cmp	DWORD PTR ?r_detailtextures@@3PAUcvar_s@@A, 0 ; r_detailtextures
	je	SHORT $L72983
	mov	eax, DWORD PTR ?r_detailtextures@@3PAUcvar_s@@A ; r_detailtextures
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72983
	mov	BYTE PTR -620+[ebp], 1
	jmp	SHORT $L72984
$L72983:
	mov	BYTE PTR -620+[ebp], 0
$L72984:
	mov	ecx, DWORD PTR -620+[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L72056

; 1244 : 			GL_AddShaderDirective( options, "BMODEL_HAS_DETAIL" );

	push	OFFSET FLAT:??_C@_0BC@CMG@BMODEL_HAS_DETAIL?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72056:

; 1246 : 
; 1247 : 	if( tr.fogEnabled )

	xor	eax, eax
	mov	al, BYTE PTR ?tr@@3Uref_globals_t@@A+1411956
	test	eax, eax
	je	SHORT $L72057

; 1248 : 		GL_AddShaderDirective( options, "BMODEL_FOG_EXP" );

	push	OFFSET FLAT:??_C@_0P@EFAO@BMODEL_FOG_EXP?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72057:

; 1249 : #if 0
; 1250 : 	// can't properly draw for beams particles through glass. g-cont
; 1251 : 	// disabled for now
; 1252 : 	if( translucent )
; 1253 : 		GL_AddShaderDirective( options, "BMODEL_TRANSLUCENT" );
; 1254 : #endif
; 1255 : 
; 1256 : 	if( FBitSet( s->flags, SURF_DRAWTURB ))

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 16					; 00000010H
	test	eax, eax
	je	SHORT $L72059

; 1258 : 		GL_AddShaderDirective( options, "BMODEL_DRAWTURB" );

	push	OFFSET FLAT:??_C@_0BA@JDPH@BMODEL_DRAWTURB?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8

; 1259 : 
; 1260 : 		if( RI->currententity && RI->currententity->curstate.scale)

	mov	edx, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $L72059
	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+16]
	fld	DWORD PTR [ecx+752]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72059

; 1261 : 			GL_AddShaderDirective( options, "BMODEL_WAVEHEIGHT" );

	push	OFFSET FLAT:??_C@_0BC@LEMI@BMODEL_WAVEHEIGHT?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72059:

; 1263 : 
; 1264 : 	if( CVAR_TO_BOOL( r_shadows ) && !tr.shadows_notsupport )

	cmp	DWORD PTR ?r_shadows@@3PAUcvar_s@@A, 0	; r_shadows
	je	SHORT $L72985
	mov	eax, DWORD PTR ?r_shadows@@3PAUcvar_s@@A ; r_shadows
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72985
	mov	BYTE PTR -624+[ebp], 1
	jmp	SHORT $L72986
$L72985:
	mov	BYTE PTR -624+[ebp], 0
$L72986:
	mov	ecx, DWORD PTR -624+[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L72061
	xor	edx, edx
	mov	dl, BYTE PTR ?tr@@3Uref_globals_t@@A+1411998
	test	edx, edx
	jne	SHORT $L72061

; 1266 : 		if( !pl->pointlight && !FBitSet( pl->flags, CF_NOSHADOWS ))

	mov	eax, DWORD PTR _pl$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+44]
	test	ecx, ecx
	jne	SHORT $L72061
	mov	edx, DWORD PTR _pl$[ebp]
	mov	eax, DWORD PTR [edx+428]
	and	eax, 1024				; 00000400H
	test	eax, eax
	jne	SHORT $L72061

; 1267 : 			GL_AddShaderDirective( options, "BMODEL_HAS_SHADOWS" );

	push	OFFSET FLAT:??_C@_0BD@KLBC@BMODEL_HAS_SHADOWS?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72061:

; 1269 : 
; 1270 : 	glsl_program_t *shader = GL_FindUberShader( glname, options, &GL_InitBmodelDlightUniforms );

	push	OFFSET FLAT:?GL_InitBmodelDlightUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitBmodelDlightUniforms
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	lea	eax, DWORD PTR _glname$[ebp]
	push	eax
	call	?GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU1@@Z@Z ; GL_FindUberShader
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _shader$[ebp], eax

; 1271 : 	if( !shader )

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L72064

; 1273 : 		SetBits( s->flags, SURF_NODLIGHT );

	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	or	dh, -128				; ffffff80H
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1274 : 		return 0; // something bad happens

	xor	ax, ax
	jmp	$L72036
$L72064:

; 1276 : 
; 1277 : 	word shaderNum = (shader - glsl_programs);

	mov	eax, DWORD PTR _shader$[ebp]
	sub	eax, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	cdq
	mov	ecx, 876				; 0000036cH
	idiv	ecx
	mov	WORD PTR _shaderNum$[ebp], ax

; 1278 : 
; 1279 : #if 0
; 1280 : 	// can't properly draw for beams particles through glass. g-cont
; 1281 : 	// disabled for now
; 1282 : 	if( translucent )
; 1283 : 		SetBits( shader->status, SHADER_USE_SCREENCOPY );
; 1284 : #endif
; 1285 : 	// done
; 1286 : 	ClearBits( s->flags, SURF_NODLIGHT );

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	ah, 127					; 0000007fH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1287 : 
; 1288 : 	if( pl->pointlight )

	mov	edx, DWORD PTR _pl$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+44]
	test	eax, eax
	je	SHORT $L72066

; 1290 : 		es->omniLightShaderNum = shaderNum;

	mov	ecx, DWORD PTR _es$[ebp]
	mov	dx, WORD PTR _shaderNum$[ebp]
	mov	WORD PTR [ecx+170], dx

; 1291 : 		es->glsl_sequence_omni = tr.glsl_valid_sequence;

	mov	eax, DWORD PTR _es$[ebp]
	mov	cx, WORD PTR ?tr@@3Uref_globals_t@@A+1412000
	mov	WORD PTR [eax+180], cx

; 1293 : 	else

	jmp	SHORT $L72067
$L72066:

; 1295 : 		es->projLightShaderNum[shadows] = shaderNum;

	mov	edx, DWORD PTR _shadows$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _es$[ebp]
	mov	cx, WORD PTR _shaderNum$[ebp]
	mov	WORD PTR [eax+edx*2+172], cx

; 1296 : 		es->glsl_sequence_proj[shadows] = tr.glsl_valid_sequence;

	mov	edx, DWORD PTR _shadows$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _es$[ebp]
	mov	cx, WORD PTR ?tr@@3Uref_globals_t@@A+1412000
	mov	WORD PTR [eax+edx*2+182], cx
$L72067:

; 1298 : 
; 1299 : 	return shaderNum;

	mov	ax, WORD PTR _shaderNum$[ebp]
$L72036:

; 1300 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_UberShaderForBmodelDlight@@YAGPBUplight_s@@PAUmsurface_s@@_N@Z ENDP ; GL_UberShaderForBmodelDlight
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitBmodelDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitBmodelDlightUniforms'::`2'::__LINE__Var
PUBLIC	??_C@_0N@GDLB@u_ProjectMap?$AA@			; `string'
PUBLIC	??_C@_0M@KOBB@u_ShadowMap?$AA@			; `string'
PUBLIC	??_C@_0L@PEBL@u_LightDir?$AA@			; `string'
PUBLIC	??_C@_0P@FEGO@u_LightDiffuse?$AA@		; `string'
PUBLIC	??_C@_0P@IHNO@u_ShadowParams?$AA@		; `string'
PUBLIC	??_C@_0O@IPOH@u_LightOrigin?$AA@		; `string'
PUBLIC	??_C@_0BM@MOPE@u_LightViewProjectionMatrix?$AA@	; `string'
;	COMDAT ?__LINE__Var@?1??GL_InitBmodelDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitBmodelDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 02c1H ; `GL_InitBmodelDlightUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@GDLB@u_ProjectMap?$AA@
CONST	SEGMENT
??_C@_0N@GDLB@u_ProjectMap?$AA@ DB 'u_ProjectMap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KOBB@u_ShadowMap?$AA@
CONST	SEGMENT
??_C@_0M@KOBB@u_ShadowMap?$AA@ DB 'u_ShadowMap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PEBL@u_LightDir?$AA@
CONST	SEGMENT
??_C@_0L@PEBL@u_LightDir?$AA@ DB 'u_LightDir', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FEGO@u_LightDiffuse?$AA@
CONST	SEGMENT
??_C@_0P@FEGO@u_LightDiffuse?$AA@ DB 'u_LightDiffuse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IHNO@u_ShadowParams?$AA@
CONST	SEGMENT
??_C@_0P@IHNO@u_ShadowParams?$AA@ DB 'u_ShadowParams', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IPOH@u_LightOrigin?$AA@
CONST	SEGMENT
??_C@_0O@IPOH@u_LightOrigin?$AA@ DB 'u_LightOrigin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MOPE@u_LightViewProjectionMatrix?$AA@
CONST	SEGMENT
??_C@_0BM@MOPE@u_LightViewProjectionMatrix?$AA@ DB 'u_LightViewProjection'
	DB	'Matrix', 00H				; `string'
CONST	ENDS
;	COMDAT ?GL_InitBmodelDlightUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitBmodelDlightUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitBmodelDlightUniforms, COMDAT

; 705  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 706  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71858
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitBmodelDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitBmodelDlightUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71858:

; 707  : 
; 708  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 709  : 	shader->u_DetailMap = pglGetUniformLocationARB( shader->handle, "u_DetailMap" );

	push	OFFSET FLAT:??_C@_0M@ICKK@u_DetailMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+604], eax

; 710  : 	shader->u_ProjectMap = pglGetUniformLocationARB( shader->handle, "u_ProjectMap" );

	push	OFFSET FLAT:??_C@_0N@GDLB@u_ProjectMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+608], eax

; 711  : 	shader->u_ShadowMap = pglGetUniformLocationARB( shader->handle, "u_ShadowMap" ); // shadow2D or shadowCube

	push	OFFSET FLAT:??_C@_0M@KOBB@u_ShadowMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+612], eax

; 712  : 	shader->u_ScreenMap = pglGetUniformLocationARB( shader->handle, "u_ScreenMap" );

	push	OFFSET FLAT:??_C@_0M@CDNB@u_ScreenMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+632], eax

; 713  : 
; 714  : 	if( GL_FindShaderDirective( shader, "BMODEL_MULTI_LAYERS" ))

	push	OFFSET FLAT:??_C@_0BE@DAAC@BMODEL_MULTI_LAYERS?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_FindShaderDirective@@YA_NPAUglsl_prog_s@@PBD@Z ; GL_FindShaderDirective
	add	esp, 8
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L71861

; 715  : 		shader->u_DepthMap = pglGetUniformLocationARB( shader->handle, "u_HeightMap" );

	push	OFFSET FLAT:??_C@_0M@DCKL@u_HeightMap?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+592], eax
$L71861:

; 716  : 
; 717  : 	shader->u_ModelMatrix = pglGetUniformLocationARB( shader->handle, "u_ModelMatrix" );

	push	OFFSET FLAT:??_C@_0O@NMNP@u_ModelMatrix?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+668], eax

; 718  : 	shader->u_DetailScale = pglGetUniformLocationARB( shader->handle, "u_DetailScale" );

	push	OFFSET FLAT:??_C@_0O@DNJP@u_DetailScale?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+820], eax

; 719  : 	shader->u_TexOffset = pglGetUniformLocationARB( shader->handle, "u_TexOffset" );

	push	OFFSET FLAT:??_C@_0M@OCHJ@u_TexOffset?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+836], eax

; 720  : 
; 721  : 	shader->u_LightDir = pglGetUniformLocationARB( shader->handle, "u_LightDir" );

	push	OFFSET FLAT:??_C@_0L@PEBL@u_LightDir?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+724], eax

; 722  : 	shader->u_LightDiffuse = pglGetUniformLocationARB( shader->handle, "u_LightDiffuse" );

	push	OFFSET FLAT:??_C@_0P@FEGO@u_LightDiffuse?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+740], eax

; 723  : 	shader->u_ShadowParams = pglGetUniformLocationARB( shader->handle, "u_ShadowParams" );

	push	OFFSET FLAT:??_C@_0P@IHNO@u_ShadowParams?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+816], eax

; 724  : 	shader->u_LightOrigin = pglGetUniformLocationARB( shader->handle, "u_LightOrigin" );

	push	OFFSET FLAT:??_C@_0O@IPOH@u_LightOrigin?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+772], eax

; 725  : 	shader->u_LightViewProjectionMatrix = pglGetUniformLocationARB( shader->handle, "u_LightViewProjectionMatrix" );

	push	OFFSET FLAT:??_C@_0BM@MOPE@u_LightViewProjectionMatrix?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+676], eax

; 726  : 	shader->u_FogParams = pglGetUniformLocationARB( shader->handle, "u_FogParams" );

	push	OFFSET FLAT:??_C@_0M@BNFL@u_FogParams?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+768], eax

; 727  : 	shader->u_ScreenSizeInv = pglGetUniformLocationARB( shader->handle, "u_ScreenSizeInv" );

	push	OFFSET FLAT:??_C@_0BA@PLKN@u_ScreenSizeInv?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+704], eax

; 728  : 	shader->u_RenderColor = pglGetUniformLocationARB( shader->handle, "u_RenderColor" );

	push	OFFSET FLAT:??_C@_0O@IEKC@u_RenderColor?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+840], eax

; 729  : 
; 730  : 	GL_BindShader( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 731  : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+588]
	push	edx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 732  : 	pglUniform1iARB( shader->u_DetailMap, GL_TEXTURE1 );

	push	1
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+604]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 733  : 	pglUniform1iARB( shader->u_ProjectMap, GL_TEXTURE2 );	// projection lights only

	push	2
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+608]
	push	eax
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 734  : 	pglUniform1iARB( shader->u_ShadowMap, GL_TEXTURE3 );	// shadowmap or cubemap

	push	3
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+612]
	push	edx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 735  : 	pglUniform1iARB( shader->u_ScreenMap, GL_TEXTURE4 );

	push	4
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+632]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 736  : 
; 737  : 	if( GL_FindShaderDirective( shader, "BMODEL_MULTI_LAYERS" ))

	push	OFFSET FLAT:??_C@_0BE@DAAC@BMODEL_MULTI_LAYERS?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_FindShaderDirective@@YA_NPAUglsl_prog_s@@PBD@Z ; GL_FindShaderDirective
	add	esp, 8
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L71867

; 738  : 		pglUniform1iARB( shader->u_DepthMap, GL_TEXTURE5 );

	push	5
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+592]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB
$L71867:

; 739  : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 740  : 
; 741  : 	GL_ValidateProgram( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 742  : 	GL_ShowProgramUniforms( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 743  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitBmodelDlightUniforms@@YAXPAUglsl_prog_s@@@Z ENDP ; GL_InitBmodelDlightUniforms
_TEXT	ENDS
PUBLIC	?GL_UberShaderForGrassSolid@@YAGPAUmsurface_s@@PAUgrass_s@@@Z ; GL_UberShaderForGrassSolid
PUBLIC	??_C@_0L@OMCN@GrassSolid?$AA@			; `string'
PUBLIC	??_C@_0BB@DNNA@GRASS_FULLBRIGHT?$AA@		; `string'
PUBLIC	??_C@_0BE@GEKE@GRASS_APPLY_STYLE?$CFi?$AA@	; `string'
PUBLIC	??_C@_0O@LGNN@GRASS_FOG_EXP?$AA@		; `string'
;	COMDAT ??_C@_0L@OMCN@GrassSolid?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0L@OMCN@GrassSolid?$AA@ DB 'GrassSolid', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DNNA@GRASS_FULLBRIGHT?$AA@
CONST	SEGMENT
??_C@_0BB@DNNA@GRASS_FULLBRIGHT?$AA@ DB 'GRASS_FULLBRIGHT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GEKE@GRASS_APPLY_STYLE?$CFi?$AA@
CONST	SEGMENT
??_C@_0BE@GEKE@GRASS_APPLY_STYLE?$CFi?$AA@ DB 'GRASS_APPLY_STYLE%i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LGNN@GRASS_FOG_EXP?$AA@
CONST	SEGMENT
??_C@_0O@LGNN@GRASS_FOG_EXP?$AA@ DB 'GRASS_FOG_EXP', 00H ; `string'
CONST	ENDS
;	COMDAT ?GL_UberShaderForGrassSolid@@YAGPAUmsurface_s@@PAUgrass_s@@@Z
_TEXT	SEGMENT
_s$ = 8
_g$ = 12
_glname$ = -64
_options$ = -576
_i$72080 = -580
_shader$ = -584
?GL_UberShaderForGrassSolid@@YAGPAUmsurface_s@@PAUgrass_s@@@Z PROC NEAR ; GL_UberShaderForGrassSolid, COMDAT

; 1303 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 652				; 0000028cH
	push	ebx
	push	esi
	push	edi

; 1304 : 	if( g->vbo.shaderNum && g->vbo.glsl_sequence == tr.glsl_valid_sequence )

	mov	eax, DWORD PTR _g$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $L72072
	mov	edx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+1412000
	jne	SHORT $L72072

; 1305 : 		return g->vbo.shaderNum; // valid

	mov	ecx, DWORD PTR _g$[ebp]
	mov	ax, WORD PTR [ecx+4]
	jmp	$L72071
$L72072:

; 1308 : 	char options[MAX_OPTIONS_LENGTH];
; 1309 : 
; 1310 : 	Q_strncpy( glname, "GrassSolid", sizeof( glname ));

	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_0L@OMCN@GrassSolid?$AA@ ; `string'
	lea	edx, DWORD PTR _glname$[ebp]
	push	edx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1311 : 	memset( options, 0, sizeof( options ));

	push	512					; 00000200H
	push	0
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1312 : 
; 1313 : 	if( R_FullBright( ))

	cmp	DWORD PTR ?r_fullbright@@3PAUcvar_s@@A, 0 ; r_fullbright
	je	SHORT $L72991
	mov	ecx, DWORD PTR ?r_fullbright@@3PAUcvar_s@@A ; r_fullbright
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72991
	mov	BYTE PTR -588+[ebp], 1
	jmp	SHORT $L72992
$L72991:
	mov	BYTE PTR -588+[ebp], 0
$L72992:
	mov	edx, DWORD PTR -588+[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L72077
	mov	eax, DWORD PTR ?worldmodel@@3PAUmodel_s@@A ; worldmodel
	cmp	DWORD PTR [eax+380], 0
	jne	SHORT $L72076
$L72077:

; 1315 : 		GL_AddShaderDirective( options, "GRASS_FULLBRIGHT" );

	push	OFFSET FLAT:??_C@_0BB@DNNA@GRASS_FULLBRIGHT?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8

; 1317 : 	else

	jmp	SHORT $L72083
$L72076:

; 1319 : 		// process lightstyles
; 1320 : 		for( int i = 0; i < MAXLIGHTMAPS && s->styles[i] != LS_NONE; i++ )

	mov	DWORD PTR _i$72080[ebp], 0
	jmp	SHORT $L72081
$L72082:
	mov	edx, DWORD PTR _i$72080[ebp]
	add	edx, 1
	mov	DWORD PTR _i$72080[ebp], edx
$L72081:
	cmp	DWORD PTR _i$72080[ebp], 4
	jge	SHORT $L72083
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _i$72080[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+60]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $L72083

; 1321 : 			GL_AddShaderDirective( options, va( "GRASS_APPLY_STYLE%i", i ));

	mov	edx, DWORD PTR _i$72080[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BE@GEKE@GRASS_APPLY_STYLE?$CFi?$AA@ ; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
	jmp	SHORT $L72082
$L72083:

; 1323 : 
; 1324 : 	if( tr.fogEnabled )

	xor	ecx, ecx
	mov	cl, BYTE PTR ?tr@@3Uref_globals_t@@A+1411956
	test	ecx, ecx
	je	SHORT $L72085

; 1325 : 		GL_AddShaderDirective( options, "GRASS_FOG_EXP" );

	push	OFFSET FLAT:??_C@_0O@LGNN@GRASS_FOG_EXP?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72085:

; 1326 : 
; 1327 : 	glsl_program_t *shader = GL_FindUberShader( glname, options, &GL_InitGrassSolidUniforms );

	push	OFFSET FLAT:?GL_InitGrassSolidUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitGrassSolidUniforms
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	lea	ecx, DWORD PTR _glname$[ebp]
	push	ecx
	call	?GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU1@@Z@Z ; GL_FindUberShader
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _shader$[ebp], eax

; 1328 : 	if( !shader )

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L72088

; 1330 : 		SetBits( g->vbo.flags, FGRASS_NODRAW );

	mov	edx, DWORD PTR _g$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+8]
	or	al, 1
	mov	ecx, DWORD PTR _g$[ebp]
	mov	WORD PTR [ecx+8], ax

; 1331 : 		return 0; // something bad happens

	xor	ax, ax
	jmp	SHORT $L72071
$L72088:

; 1333 : 
; 1334 : 	g->vbo.glsl_sequence = tr.glsl_valid_sequence;

	mov	edx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+1412000
	mov	DWORD PTR [edx+28], eax

; 1335 : 	ClearBits( g->vbo.flags, FGRASS_NODRAW );

	mov	ecx, DWORD PTR _g$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+8]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _g$[ebp]
	mov	WORD PTR [eax+8], dx

; 1336 : 
; 1337 : 	return (shader - glsl_programs);

	mov	eax, DWORD PTR _shader$[ebp]
	sub	eax, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	cdq
	mov	ecx, 876				; 0000036cH
	idiv	ecx
$L72071:

; 1338 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_UberShaderForGrassSolid@@YAGPAUmsurface_s@@PAUgrass_s@@@Z ENDP ; GL_UberShaderForGrassSolid
_TEXT	ENDS
PUBLIC	??_C@_0N@OCGF@u_GammaTable?$AA@			; `string'
PUBLIC	??_C@_0N@HFAH@u_ViewOrigin?$AA@			; `string'
PUBLIC	?__LINE__Var@?1??GL_InitGrassSolidUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitGrassSolidUniforms'::`2'::__LINE__Var
PUBLIC	??_C@_0BB@DDGN@u_GrassFadeStart?$AA@		; `string'
PUBLIC	??_C@_0BA@NNKA@u_GrassFadeDist?$AA@		; `string'
PUBLIC	??_C@_0P@GDAL@u_GrassFadeEnd?$AA@		; `string'
PUBLIC	??_C@_0L@HAJO@u_RealTime?$AA@			; `string'
;	COMDAT ?__LINE__Var@?1??GL_InitGrassSolidUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitGrassSolidUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 0360H ; `GL_InitGrassSolidUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@OCGF@u_GammaTable?$AA@
CONST	SEGMENT
??_C@_0N@OCGF@u_GammaTable?$AA@ DB 'u_GammaTable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HFAH@u_ViewOrigin?$AA@
CONST	SEGMENT
??_C@_0N@HFAH@u_ViewOrigin?$AA@ DB 'u_ViewOrigin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DDGN@u_GrassFadeStart?$AA@
CONST	SEGMENT
??_C@_0BB@DDGN@u_GrassFadeStart?$AA@ DB 'u_GrassFadeStart', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NNKA@u_GrassFadeDist?$AA@
CONST	SEGMENT
??_C@_0BA@NNKA@u_GrassFadeDist?$AA@ DB 'u_GrassFadeDist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GDAL@u_GrassFadeEnd?$AA@
CONST	SEGMENT
??_C@_0P@GDAL@u_GrassFadeEnd?$AA@ DB 'u_GrassFadeEnd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HAJO@u_RealTime?$AA@
CONST	SEGMENT
??_C@_0L@HAJO@u_RealTime?$AA@ DB 'u_RealTime', 00H	; `string'
CONST	ENDS
;	COMDAT ?GL_InitGrassSolidUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitGrassSolidUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitGrassSolidUniforms, COMDAT

; 864  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 865  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71910
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitGrassSolidUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitGrassSolidUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71910:

; 866  : 
; 867  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 868  : 
; 869  : 	shader->u_ModelMatrix = pglGetUniformLocationARB( shader->handle, "u_ModelMatrix" );

	push	OFFSET FLAT:??_C@_0O@NMNP@u_ModelMatrix?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+668], eax

; 870  : 	shader->u_LightStyleValues = pglGetUniformLocationARB( shader->handle, "u_LightStyleValues" );

	push	OFFSET FLAT:??_C@_0BD@JGPP@u_LightStyleValues?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+748], eax

; 871  : 	shader->u_GammaTable = pglGetUniformLocationARB( shader->handle, "u_GammaTable" );

	push	OFFSET FLAT:??_C@_0N@OCGF@u_GammaTable?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+660], eax

; 872  : 	shader->u_GrassFadeStart = pglGetUniformLocationARB( shader->handle, "u_GrassFadeStart" );

	push	OFFSET FLAT:??_C@_0BB@DDGN@u_GrassFadeStart?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+864], eax

; 873  : 	shader->u_GrassFadeDist = pglGetUniformLocationARB( shader->handle, "u_GrassFadeDist" );

	push	OFFSET FLAT:??_C@_0BA@NNKA@u_GrassFadeDist?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+868], eax

; 874  : 	shader->u_GrassFadeEnd = pglGetUniformLocationARB( shader->handle, "u_GrassFadeEnd" );

	push	OFFSET FLAT:??_C@_0P@GDAL@u_GrassFadeEnd?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+872], eax

; 875  : 	shader->u_ViewOrigin = pglGetUniformLocationARB( shader->handle, "u_ViewOrigin" );

	push	OFFSET FLAT:??_C@_0N@HFAH@u_ViewOrigin?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+780], eax

; 876  : 	shader->u_RealTime = pglGetUniformLocationARB( shader->handle, "u_RealTime" );

	push	OFFSET FLAT:??_C@_0L@HAJO@u_RealTime?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+844], eax

; 877  : 	shader->u_FogParams = pglGetUniformLocationARB( shader->handle, "u_FogParams" );

	push	OFFSET FLAT:??_C@_0M@BNFL@u_FogParams?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+768], eax

; 878  : 
; 879  : 	GL_BindShader( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 880  : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 881  : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 882  : 
; 883  : 	GL_ValidateProgram( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 884  : 	GL_ShowProgramUniforms( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 885  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitGrassSolidUniforms@@YAXPAUglsl_prog_s@@@Z ENDP	; GL_InitGrassSolidUniforms
_TEXT	ENDS
PUBLIC	?GL_UberShaderForGrassDlight@@YAGPAUplight_s@@PAUgrass_s@@@Z ; GL_UberShaderForGrassDlight
PUBLIC	??_C@_0M@HJML@GrassDlight?$AA@			; `string'
PUBLIC	??_C@_0BM@CDCB@GRASS_LIGHT_OMNIDIRECTIONAL?$AA@	; `string'
PUBLIC	??_C@_0BH@GPJF@GRASS_LIGHT_PROJECTION?$AA@	; `string'
PUBLIC	??_C@_0BC@CHCI@GRASS_HAS_SHADOWS?$AA@		; `string'
;	COMDAT ??_C@_0M@HJML@GrassDlight?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0M@HJML@GrassDlight?$AA@ DB 'GrassDlight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CDCB@GRASS_LIGHT_OMNIDIRECTIONAL?$AA@
CONST	SEGMENT
??_C@_0BM@CDCB@GRASS_LIGHT_OMNIDIRECTIONAL?$AA@ DB 'GRASS_LIGHT_OMNIDIREC'
	DB	'TIONAL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GPJF@GRASS_LIGHT_PROJECTION?$AA@
CONST	SEGMENT
??_C@_0BH@GPJF@GRASS_LIGHT_PROJECTION?$AA@ DB 'GRASS_LIGHT_PROJECTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CHCI@GRASS_HAS_SHADOWS?$AA@
CONST	SEGMENT
??_C@_0BC@CHCI@GRASS_HAS_SHADOWS?$AA@ DB 'GRASS_HAS_SHADOWS', 00H ; `string'
CONST	ENDS
;	COMDAT ?GL_UberShaderForGrassDlight@@YAGPAUplight_s@@PAUgrass_s@@@Z
_TEXT	SEGMENT
_pl$ = 8
_g$ = 12
_shadows$ = -4
_glname$ = -68
_options$ = -580
_shader$ = -584
?GL_UberShaderForGrassDlight@@YAGPAUplight_s@@PAUgrass_s@@@Z PROC NEAR ; GL_UberShaderForGrassDlight, COMDAT

; 1341 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 656				; 00000290H
	push	ebx
	push	esi
	push	edi

; 1342 : 	bool shadows = (!pl->pointlight && !FBitSet( pl->flags, CF_NOSHADOWS )) ? true : false;

	mov	eax, DWORD PTR _pl$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+44]
	test	ecx, ecx
	jne	SHORT $L72997
	mov	edx, DWORD PTR _pl$[ebp]
	mov	eax, DWORD PTR [edx+428]
	and	eax, 1024				; 00000400H
	test	eax, eax
	jne	SHORT $L72997
	mov	BYTE PTR -585+[ebp], 1
	jmp	SHORT $L72998
$L72997:
	mov	BYTE PTR -585+[ebp], 0
$L72998:
	mov	cl, BYTE PTR -585+[ebp]
	mov	BYTE PTR _shadows$[ebp], cl

; 1343 : 	char glname[64];
; 1344 : 	char options[MAX_OPTIONS_LENGTH];
; 1345 : 
; 1346 : 	Q_strncpy( glname, "GrassDlight", sizeof( glname ));

	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_0M@HJML@GrassDlight?$AA@ ; `string'
	lea	edx, DWORD PTR _glname$[ebp]
	push	edx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1347 : 	memset( options, 0, sizeof( options ));

	push	512					; 00000200H
	push	0
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1348 : 
; 1349 : 	if( pl->pointlight )

	mov	ecx, DWORD PTR _pl$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+44]
	test	edx, edx
	je	SHORT $L72097

; 1350 : 		GL_AddShaderDirective( options, "GRASS_LIGHT_OMNIDIRECTIONAL" );

	push	OFFSET FLAT:??_C@_0BM@CDCB@GRASS_LIGHT_OMNIDIRECTIONAL?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8

; 1351 : 	else GL_AddShaderDirective( options, "GRASS_LIGHT_PROJECTION" );

	jmp	SHORT $L72099
$L72097:
	push	OFFSET FLAT:??_C@_0BH@GPJF@GRASS_LIGHT_PROJECTION?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72099:

; 1352 : 
; 1353 : 	if( CVAR_TO_BOOL( r_shadows ) && shadows && !tr.shadows_notsupport )

	cmp	DWORD PTR ?r_shadows@@3PAUcvar_s@@A, 0	; r_shadows
	je	SHORT $L72999
	mov	edx, DWORD PTR ?r_shadows@@3PAUcvar_s@@A ; r_shadows
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L72999
	mov	BYTE PTR -592+[ebp], 1
	jmp	SHORT $L73000
$L72999:
	mov	BYTE PTR -592+[ebp], 0
$L73000:
	mov	eax, DWORD PTR -592+[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L72101
	mov	ecx, DWORD PTR _shadows$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L72101
	xor	edx, edx
	mov	dl, BYTE PTR ?tr@@3Uref_globals_t@@A+1411998
	test	edx, edx
	jne	SHORT $L72101

; 1354 : 		GL_AddShaderDirective( options, "GRASS_HAS_SHADOWS" );

	push	OFFSET FLAT:??_C@_0BC@CHCI@GRASS_HAS_SHADOWS?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72101:

; 1355 : 
; 1356 : 	if( tr.fogEnabled )

	xor	ecx, ecx
	mov	cl, BYTE PTR ?tr@@3Uref_globals_t@@A+1411956
	test	ecx, ecx
	je	SHORT $L72103

; 1357 : 		GL_AddShaderDirective( options, "GRASS_FOG_EXP" );

	push	OFFSET FLAT:??_C@_0O@LGNN@GRASS_FOG_EXP?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72103:

; 1358 : 
; 1359 : 	glsl_program_t *shader = GL_FindUberShader( glname, options, &GL_InitGrassDlightUniforms );

	push	OFFSET FLAT:?GL_InitGrassDlightUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitGrassDlightUniforms
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	lea	ecx, DWORD PTR _glname$[ebp]
	push	ecx
	call	?GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU1@@Z@Z ; GL_FindUberShader
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _shader$[ebp], eax

; 1360 : 	if( !shader )

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L72105

; 1362 : 		SetBits( g->vbo.flags, FGRASS_NODLIGHT );

	mov	edx, DWORD PTR _g$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+8]
	or	al, 2
	mov	ecx, DWORD PTR _g$[ebp]
	mov	WORD PTR [ecx+8], ax

; 1363 : 		return 0; // something bad happens

	xor	ax, ax
	jmp	SHORT $L72092
$L72105:

; 1365 : 
; 1366 : 	ClearBits( g->vbo.flags, FGRASS_NODLIGHT );

	mov	edx, DWORD PTR _g$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+8]
	and	al, -3					; fffffffdH
	mov	ecx, DWORD PTR _g$[ebp]
	mov	WORD PTR [ecx+8], ax

; 1367 : 
; 1368 : 	return (shader - glsl_programs);

	mov	eax, DWORD PTR _shader$[ebp]
	sub	eax, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	cdq
	mov	ecx, 876				; 0000036cH
	idiv	ecx
$L72092:

; 1369 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_UberShaderForGrassDlight@@YAGPAUplight_s@@PAUgrass_s@@@Z ENDP ; GL_UberShaderForGrassDlight
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitGrassDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitGrassDlightUniforms'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??GL_InitGrassDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitGrassDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 0378H ; `GL_InitGrassDlightUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?GL_InitGrassDlightUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitGrassDlightUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitGrassDlightUniforms, COMDAT

; 888  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 889  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71919
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitGrassDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitGrassDlightUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71919:

; 890  : 
; 891  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 892  : 	shader->u_ProjectMap = pglGetUniformLocationARB( shader->handle, "u_ProjectMap" );

	push	OFFSET FLAT:??_C@_0N@GDLB@u_ProjectMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+608], eax

; 893  : 	shader->u_ShadowMap = pglGetUniformLocationARB( shader->handle, "u_ShadowMap" );

	push	OFFSET FLAT:??_C@_0M@KOBB@u_ShadowMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+612], eax

; 894  : 
; 895  : 	shader->u_LightViewProjectionMatrix = pglGetUniformLocationARB( shader->handle, "u_LightViewProjectionMatrix" );

	push	OFFSET FLAT:??_C@_0BM@MOPE@u_LightViewProjectionMatrix?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+676], eax

; 896  : 	shader->u_ShadowParams = pglGetUniformLocationARB( shader->handle, "u_ShadowParams" );

	push	OFFSET FLAT:??_C@_0P@IHNO@u_ShadowParams?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+816], eax

; 897  : 	shader->u_LightDiffuse = pglGetUniformLocationARB( shader->handle, "u_LightDiffuse" );

	push	OFFSET FLAT:??_C@_0P@FEGO@u_LightDiffuse?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+740], eax

; 898  : 	shader->u_LightOrigin = pglGetUniformLocationARB( shader->handle, "u_LightOrigin" );

	push	OFFSET FLAT:??_C@_0O@IPOH@u_LightOrigin?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+772], eax

; 899  : 	shader->u_LightDir = pglGetUniformLocationARB( shader->handle, "u_LightDir" );

	push	OFFSET FLAT:??_C@_0L@PEBL@u_LightDir?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+724], eax

; 900  : 	shader->u_ViewOrigin = pglGetUniformLocationARB( shader->handle, "u_ViewOrigin" );

	push	OFFSET FLAT:??_C@_0N@HFAH@u_ViewOrigin?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+780], eax

; 901  : 	shader->u_ModelMatrix = pglGetUniformLocationARB( shader->handle, "u_ModelMatrix" );

	push	OFFSET FLAT:??_C@_0O@NMNP@u_ModelMatrix?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+668], eax

; 902  : 	shader->u_GrassFadeStart = pglGetUniformLocationARB( shader->handle, "u_GrassFadeStart" );

	push	OFFSET FLAT:??_C@_0BB@DDGN@u_GrassFadeStart?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+864], eax

; 903  : 	shader->u_GrassFadeDist = pglGetUniformLocationARB( shader->handle, "u_GrassFadeDist" );

	push	OFFSET FLAT:??_C@_0BA@NNKA@u_GrassFadeDist?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+868], eax

; 904  : 	shader->u_GrassFadeEnd = pglGetUniformLocationARB( shader->handle, "u_GrassFadeEnd" );

	push	OFFSET FLAT:??_C@_0P@GDAL@u_GrassFadeEnd?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+872], eax

; 905  : 	shader->u_RealTime = pglGetUniformLocationARB( shader->handle, "u_RealTime" );

	push	OFFSET FLAT:??_C@_0L@HAJO@u_RealTime?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+844], eax

; 906  : 	shader->u_FogParams = pglGetUniformLocationARB( shader->handle, "u_FogParams" );

	push	OFFSET FLAT:??_C@_0M@BNFL@u_FogParams?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+768], eax

; 907  : 
; 908  : 	GL_BindShader( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 909  : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 910  : 	pglUniform1iARB( shader->u_ProjectMap, GL_TEXTURE1 );// projection texture or XY attenuation

	push	1
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+608]
	push	eax
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 911  : 	pglUniform1iARB( shader->u_ShadowMap, GL_TEXTURE2 ); // shadowmap or cubemap

	push	2
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+612]
	push	edx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 912  : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 913  : 
; 914  : 	GL_ValidateProgram( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 915  : 	GL_ShowProgramUniforms( shader );

	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 916  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitGrassDlightUniforms@@YAXPAUglsl_prog_s@@@Z ENDP	; GL_InitGrassDlightUniforms
_TEXT	ENDS
PUBLIC	?GL_UberShaderForBmodelDecal@@YAGPAUdecal_s@@@Z	; GL_UberShaderForBmodelDecal
PUBLIC	?__LINE__Var@?1??GL_UberShaderForBmodelDecal@@YAGPAUdecal_s@@@Z@4FA ; `GL_UberShaderForBmodelDecal'::`2'::__LINE__Var
PUBLIC	??_C@_0M@EKMF@BmodelDecal?$AA@			; `string'
PUBLIC	??_C@_0BE@JFJO@DECAL_APPLY_STYLE?$CFi?$AA@	; `string'
PUBLIC	??_C@_0BA@OEHD@DECAL_ALPHATEST?$AA@		; `string'
PUBLIC	??_C@_0BB@HMDN@DECAL_FULLBRIGHT?$AA@		; `string'
PUBLIC	??_C@_0O@NFNC@DECAL_FOG_EXP?$AA@		; `string'
;	COMDAT ?__LINE__Var@?1??GL_UberShaderForBmodelDecal@@YAGPAUdecal_s@@@Z@4FA
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_UberShaderForBmodelDecal@@YAGPAUdecal_s@@@Z@4FA DW 055cH ; `GL_UberShaderForBmodelDecal'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@EKMF@BmodelDecal?$AA@
CONST	SEGMENT
??_C@_0M@EKMF@BmodelDecal?$AA@ DB 'BmodelDecal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JFJO@DECAL_APPLY_STYLE?$CFi?$AA@
CONST	SEGMENT
??_C@_0BE@JFJO@DECAL_APPLY_STYLE?$CFi?$AA@ DB 'DECAL_APPLY_STYLE%i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OEHD@DECAL_ALPHATEST?$AA@
CONST	SEGMENT
??_C@_0BA@OEHD@DECAL_ALPHATEST?$AA@ DB 'DECAL_ALPHATEST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HMDN@DECAL_FULLBRIGHT?$AA@
CONST	SEGMENT
??_C@_0BB@HMDN@DECAL_FULLBRIGHT?$AA@ DB 'DECAL_FULLBRIGHT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NFNC@DECAL_FOG_EXP?$AA@
CONST	SEGMENT
??_C@_0O@NFNC@DECAL_FOG_EXP?$AA@ DB 'DECAL_FOG_EXP', 00H ; `string'
CONST	ENDS
;	COMDAT ?GL_UberShaderForBmodelDecal@@YAGPAUdecal_s@@@Z
_TEXT	SEGMENT
_decal$ = 8
_glname$ = -64
_fullbright$ = -68
_options$ = -580
_s$ = -584
_es$ = -588
_i$ = -592
_shader$ = -596
_shaderNum$ = -600
?GL_UberShaderForBmodelDecal@@YAGPAUdecal_s@@@Z PROC NEAR ; GL_UberShaderForBmodelDecal, COMDAT

; 1372 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 664				; 00000298H
	push	ebx
	push	esi
	push	edi

; 1373 : 	char glname[64];
; 1374 : 	bool fullbright = R_ModelOpaque( RI->currententity->curstate.rendermode ) ? false : true;

	mov	eax, DWORD PTR ?RI@@3PAUref_instance_t@@A ; RI
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+760], 0
	setne	dl
	mov	BYTE PTR _fullbright$[ebp], dl

; 1375 : 	char options[MAX_OPTIONS_LENGTH];
; 1376 : 	msurface_t *s = decal->psurface;

	mov	eax, DWORD PTR _decal$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _s$[ebp], ecx

; 1377 : 	mextrasurf_t *es = s->info;

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _es$[ebp], eax

; 1378 : 
; 1379 : 	ASSERT( worldmodel != NULL );

	cmp	DWORD PTR ?worldmodel@@3PAUmodel_s@@A, 0 ; worldmodel
	jne	SHORT $L72115
	movsx	ecx, WORD PTR ?__LINE__Var@?1??GL_UberShaderForBmodelDecal@@YAGPAUdecal_s@@@Z@4FA ; `GL_UberShaderForBmodelDecal'::`2'::__LINE__Var
	add	ecx, 7
	push	ecx
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L72115:

; 1380 : 
; 1381 : 	if( decal->shaderNum && decal->glsl_sequence == tr.glsl_valid_sequence )

	mov	edx, DWORD PTR _decal$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+48]
	test	eax, eax
	je	SHORT $L72116
	mov	ecx, DWORD PTR _decal$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1412000
	jne	SHORT $L72116

; 1382 : 		return decal->shaderNum; // valid

	mov	eax, DWORD PTR _decal$[ebp]
	mov	ax, WORD PTR [eax+48]
	jmp	$L72108
$L72116:

; 1383 : 
; 1384 : 	Q_strncpy( glname, "BmodelDecal", sizeof( glname ));

	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_0M@EKMF@BmodelDecal?$AA@ ; `string'
	lea	ecx, DWORD PTR _glname$[ebp]
	push	ecx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1385 : 	memset( options, 0, sizeof( options ));

	push	512					; 00000200H
	push	0
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1386 : 
; 1387 : 	// process lightstyles
; 1388 : 	for( int i = 0; i < MAXLIGHTMAPS && s->styles[i] != LS_NONE && !fullbright; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L72119
$L72120:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L72119:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L72121
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+60]
	cmp	edx, 255				; 000000ffH
	je	SHORT $L72121
	mov	eax, DWORD PTR _fullbright$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L72121

; 1390 : 		GL_AddShaderDirective( options, va( "DECAL_APPLY_STYLE%i", i ));

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BE@JFJO@DECAL_APPLY_STYLE?$CFi?$AA@ ; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 8
	push	eax
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8

; 1391 : 	}

	jmp	SHORT $L72120
$L72121:

; 1392 : 
; 1393 : 	if( FBitSet( s->flags, SURF_TRANSPARENT ))

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	je	SHORT $L72123

; 1394 : 		GL_AddShaderDirective( options, "DECAL_ALPHATEST" );

	push	OFFSET FLAT:??_C@_0BA@OEHD@DECAL_ALPHATEST?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72123:

; 1395 : 
; 1396 : 	if( fullbright )

	mov	eax, DWORD PTR _fullbright$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L72125

; 1397 : 		GL_AddShaderDirective( options, "DECAL_FULLBRIGHT" );

	push	OFFSET FLAT:??_C@_0BB@HMDN@DECAL_FULLBRIGHT?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72125:

; 1398 : 
; 1399 : 	if( tr.fogEnabled )

	xor	edx, edx
	mov	dl, BYTE PTR ?tr@@3Uref_globals_t@@A+1411956
	test	edx, edx
	je	SHORT $L72127

; 1400 : 		GL_AddShaderDirective( options, "DECAL_FOG_EXP" );

	push	OFFSET FLAT:??_C@_0O@NFNC@DECAL_FOG_EXP?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72127:

; 1401 : 
; 1402 : 	glsl_program_t *shader = GL_FindUberShader( glname, options, &GL_InitBmodelDecalUniforms );

	push	OFFSET FLAT:?GL_InitBmodelDecalUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitBmodelDecalUniforms
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	lea	edx, DWORD PTR _glname$[ebp]
	push	edx
	call	?GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU1@@Z@Z ; GL_FindUberShader
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _shader$[ebp], eax

; 1403 : 	if( !shader ) return 0; // something bad happens

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L72130
	xor	ax, ax
	jmp	SHORT $L72108
$L72130:

; 1404 : 
; 1405 : 	word shaderNum = (shader - glsl_programs);

	mov	eax, DWORD PTR _shader$[ebp]
	sub	eax, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	cdq
	mov	ecx, 876				; 0000036cH
	idiv	ecx
	mov	WORD PTR _shaderNum$[ebp], ax

; 1406 : 	decal->glsl_sequence = tr.glsl_valid_sequence;

	mov	edx, DWORD PTR _decal$[ebp]
	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+1412000
	mov	DWORD PTR [edx+44], eax

; 1407 : 	decal->shaderNum = shaderNum;

	mov	ecx, DWORD PTR _decal$[ebp]
	mov	dx, WORD PTR _shaderNum$[ebp]
	mov	WORD PTR [ecx+48], dx

; 1408 : 
; 1409 : 	return shaderNum;

	mov	ax, WORD PTR _shaderNum$[ebp]
$L72108:

; 1410 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_UberShaderForBmodelDecal@@YAGPAUdecal_s@@@Z ENDP	; GL_UberShaderForBmodelDecal
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitBmodelDecalUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitBmodelDecalUniforms'::`2'::__LINE__Var
PUBLIC	??_C@_0L@NBHD@u_DecalMap?$AA@			; `string'
;	COMDAT ?__LINE__Var@?1??GL_InitBmodelDecalUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitBmodelDecalUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 02faH ; `GL_InitBmodelDecalUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0L@NBHD@u_DecalMap?$AA@
CONST	SEGMENT
??_C@_0L@NBHD@u_DecalMap?$AA@ DB 'u_DecalMap', 00H	; `string'
CONST	ENDS
;	COMDAT ?GL_InitBmodelDecalUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitBmodelDecalUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitBmodelDecalUniforms, COMDAT

; 762  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 763  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71877
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitBmodelDecalUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitBmodelDecalUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71877:

; 764  : 
; 765  : 	shader->u_DecalMap = pglGetUniformLocationARB( shader->handle, "u_DecalMap" );

	push	OFFSET FLAT:??_C@_0L@NBHD@u_DecalMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+628], eax

; 766  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 767  : 	shader->u_LightMap = pglGetUniformLocationARB( shader->handle, "u_LightMap" );

	push	OFFSET FLAT:??_C@_0L@NGMC@u_LightMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+620], eax

; 768  : 
; 769  : 	shader->u_LightStyleValues = pglGetUniformLocationARB( shader->handle, "u_LightStyleValues" );

	push	OFFSET FLAT:??_C@_0BD@JGPP@u_LightStyleValues?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+748], eax

; 770  : 	shader->u_ModelMatrix = pglGetUniformLocationARB( shader->handle, "u_ModelMatrix" );

	push	OFFSET FLAT:??_C@_0O@NMNP@u_ModelMatrix?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+668], eax

; 771  : 	shader->u_FogParams = pglGetUniformLocationARB( shader->handle, "u_FogParams" );

	push	OFFSET FLAT:??_C@_0M@BNFL@u_FogParams?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+768], eax

; 772  : 
; 773  : 	GL_BindShader( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 774  : 	pglUniform1iARB( shader->u_DecalMap, GL_TEXTURE0 );

	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+628]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 775  : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE1 ); // detect alpha holes

	push	1
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+588]
	push	eax
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 776  : 	pglUniform1iARB( shader->u_LightMap, GL_TEXTURE2 );

	push	2
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+620]
	push	edx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 777  : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 778  : 
; 779  : 	GL_ValidateProgram( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 780  : 	GL_ShowProgramUniforms( shader );

	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitBmodelDecalUniforms@@YAXPAUglsl_prog_s@@@Z ENDP	; GL_InitBmodelDecalUniforms
_TEXT	ENDS
PUBLIC	?GL_UberShaderForSolidStudio@@YAGPAUmstudiomat_s@@_N11H@Z ; GL_UberShaderForSolidStudio
PUBLIC	??_C@_0BH@LEI@STUDIO_VERTEX_LIGHTING?$AA@	; `string'
PUBLIC	??_C@_0M@KKJ@StudioSolid?$AA@			; `string'
PUBLIC	??_C@_0BL@GCND@?$CDdefine?5MAXSTUDIOBONES?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@CJHN@?$CDdefine?5MAXSTUDIOBONES?51?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@HOAP@STUDIO_BONEWEIGHTING?$AA@	; `string'
PUBLIC	??_C@_0BC@ILPH@STUDIO_HAS_CHROME?$AA@		; `string'
PUBLIC	??_C@_0BC@EAPK@STUDIO_FULLBRIGHT?$AA@		; `string'
PUBLIC	??_C@_0BH@OLBI@STUDIO_LIGHT_FLATSHADE?$AA@	; `string'
PUBLIC	??_C@_0P@EBHP@STUDIO_FOG_EXP?$AA@		; `string'
;	COMDAT ??_C@_0BH@LEI@STUDIO_VERTEX_LIGHTING?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0BH@LEI@STUDIO_VERTEX_LIGHTING?$AA@ DB 'STUDIO_VERTEX_LIGHTING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KKJ@StudioSolid?$AA@
CONST	SEGMENT
??_C@_0M@KKJ@StudioSolid?$AA@ DB 'StudioSolid', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GCND@?$CDdefine?5MAXSTUDIOBONES?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BL@GCND@?$CDdefine?5MAXSTUDIOBONES?5?$CFd?6?$AA@ DB '#define MAXST'
	DB	'UDIOBONES %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CJHN@?$CDdefine?5MAXSTUDIOBONES?51?6?$AA@
CONST	SEGMENT
??_C@_0BK@CJHN@?$CDdefine?5MAXSTUDIOBONES?51?6?$AA@ DB '#define MAXSTUDIO'
	DB	'BONES 1', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOAP@STUDIO_BONEWEIGHTING?$AA@
CONST	SEGMENT
??_C@_0BF@HOAP@STUDIO_BONEWEIGHTING?$AA@ DB 'STUDIO_BONEWEIGHTING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ILPH@STUDIO_HAS_CHROME?$AA@
CONST	SEGMENT
??_C@_0BC@ILPH@STUDIO_HAS_CHROME?$AA@ DB 'STUDIO_HAS_CHROME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EAPK@STUDIO_FULLBRIGHT?$AA@
CONST	SEGMENT
??_C@_0BC@EAPK@STUDIO_FULLBRIGHT?$AA@ DB 'STUDIO_FULLBRIGHT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OLBI@STUDIO_LIGHT_FLATSHADE?$AA@
CONST	SEGMENT
??_C@_0BH@OLBI@STUDIO_LIGHT_FLATSHADE?$AA@ DB 'STUDIO_LIGHT_FLATSHADE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EBHP@STUDIO_FOG_EXP?$AA@
CONST	SEGMENT
??_C@_0P@EBHP@STUDIO_FOG_EXP?$AA@ DB 'STUDIO_FOG_EXP', 00H ; `string'
CONST	ENDS
;	COMDAT ?GL_UberShaderForSolidStudio@@YAGPAUmstudiomat_s@@_N11H@Z
_TEXT	SEGMENT
_mat$ = 8
_vertex_lighting$ = 12
_bone_weighting$ = 16
_fullbright$ = 20
_numbones$ = 24
_glname$ = -64
_options$ = -576
_num_bones$72144 = -580
_shader$ = -584
_shaderNum$ = -588
?GL_UberShaderForSolidStudio@@YAGPAUmstudiomat_s@@_N11H@Z PROC NEAR ; GL_UberShaderForSolidStudio, COMDAT

; 1413 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 656				; 00000290H
	push	ebx
	push	esi
	push	edi

; 1414 : 	char glname[64];
; 1415 : 	char options[MAX_OPTIONS_LENGTH];
; 1416 : 
; 1417 : 	if( mat->shaderNum && mat->glsl_sequence == tr.glsl_valid_sequence )

	mov	eax, DWORD PTR _mat$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $L72141
	mov	edx, DWORD PTR _mat$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	cmp	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+1412000
	jne	SHORT $L72141

; 1418 : 		return mat->shaderNum; // valid

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	ax, WORD PTR [ecx+12]
	jmp	$L72138
$L72141:

; 1419 : 
; 1420 : 	Q_strncpy( glname, "StudioSolid", sizeof( glname ));

	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_0M@KKJ@StudioSolid?$AA@ ; `string'
	lea	edx, DWORD PTR _glname$[ebp]
	push	edx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1421 : 	memset( options, 0, sizeof( options ));

	push	512					; 00000200H
	push	0
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1422 : 
; 1423 : 	if( numbones > 0 && glConfig.max_skinning_bones < MAXSTUDIOBONES && glConfig.uniforms_economy )

	cmp	DWORD PTR _numbones$[ebp], 0
	jle	SHORT $L72143
	cmp	DWORD PTR ?glConfig@@3UglConfig_t@@A+72, 128 ; 00000080H
	jge	SHORT $L72143
	xor	ecx, ecx
	mov	cl, BYTE PTR ?glConfig@@3UglConfig_t@@A+80
	test	ecx, ecx
	je	SHORT $L72143

; 1425 : 		int num_bones = Q_min( numbones, glConfig.max_skinning_bones );

	mov	edx, DWORD PTR _numbones$[ebp]
	cmp	edx, DWORD PTR ?glConfig@@3UglConfig_t@@A+72
	jge	SHORT $L73009
	mov	eax, DWORD PTR _numbones$[ebp]
	mov	DWORD PTR -592+[ebp], eax
	jmp	SHORT $L73010
$L73009:
	mov	ecx, DWORD PTR ?glConfig@@3UglConfig_t@@A+72
	mov	DWORD PTR -592+[ebp], ecx
$L73010:
	mov	edx, DWORD PTR -592+[ebp]
	mov	DWORD PTR _num_bones$72144[ebp], edx

; 1426 : 		GL_AddShaderDefine( options, va( "#define MAXSTUDIOBONES %d\n", num_bones ));

	mov	eax, DWORD PTR _num_bones$72144[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BL@GCND@?$CDdefine?5MAXSTUDIOBONES?5?$CFd?6?$AA@ ; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDefine@@YAXPADPBD@Z	; GL_AddShaderDefine
	add	esp, 8

; 1428 : 	else if( numbones == 1 )

	jmp	SHORT $L72147
$L72143:
	cmp	DWORD PTR _numbones$[ebp], 1
	jne	SHORT $L72147

; 1430 : 		GL_AddShaderDefine( options, "#define MAXSTUDIOBONES 1\n" );

	push	OFFSET FLAT:??_C@_0BK@CJHN@?$CDdefine?5MAXSTUDIOBONES?51?6?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDefine@@YAXPADPBD@Z	; GL_AddShaderDefine
	add	esp, 8
$L72147:

; 1432 : 
; 1433 : 	if( bone_weighting )

	mov	eax, DWORD PTR _bone_weighting$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L72149

; 1434 : 		GL_AddShaderDirective( options, "STUDIO_BONEWEIGHTING" );

	push	OFFSET FLAT:??_C@_0BF@HOAP@STUDIO_BONEWEIGHTING?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72149:

; 1435 : 
; 1436 : 	if( FBitSet( mat->flags, STUDIO_NF_CHROME ))

	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 2
	test	eax, eax
	je	SHORT $L72151

; 1437 : 		GL_AddShaderDirective( options, "STUDIO_HAS_CHROME" );

	push	OFFSET FLAT:??_C@_0BC@ILPH@STUDIO_HAS_CHROME?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72151:

; 1438 : 
; 1439 : 	if( vertex_lighting )

	mov	edx, DWORD PTR _vertex_lighting$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72153

; 1440 : 		GL_AddShaderDirective( options, "STUDIO_VERTEX_LIGHTING" );

	push	OFFSET FLAT:??_C@_0BH@LEI@STUDIO_VERTEX_LIGHTING?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72153:

; 1441 : 
; 1442 : 	if( fullbright || FBitSet( mat->flags, STUDIO_NF_FULLBRIGHT ))

	mov	ecx, DWORD PTR _fullbright$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L72155
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 4
	test	eax, eax
	je	SHORT $L72154
$L72155:

; 1444 : 		GL_AddShaderDirective( options, "STUDIO_FULLBRIGHT" );

	push	OFFSET FLAT:??_C@_0BC@EAPK@STUDIO_FULLBRIGHT?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8

; 1446 : 	else

	jmp	SHORT $L72158
$L72154:

; 1448 : 		if( FBitSet( mat->flags, STUDIO_NF_FLATSHADE ))

	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	test	eax, eax
	je	SHORT $L72158

; 1449 : 			GL_AddShaderDirective( options, "STUDIO_LIGHT_FLATSHADE" );

	push	OFFSET FLAT:??_C@_0BH@OLBI@STUDIO_LIGHT_FLATSHADE?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72158:

; 1451 : 
; 1452 : 	if( tr.fogEnabled )

	xor	edx, edx
	mov	dl, BYTE PTR ?tr@@3Uref_globals_t@@A+1411956
	test	edx, edx
	je	SHORT $L72160

; 1453 : 		GL_AddShaderDirective( options, "STUDIO_FOG_EXP" );

	push	OFFSET FLAT:??_C@_0P@EBHP@STUDIO_FOG_EXP?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72160:

; 1454 : 
; 1455 : 	glsl_program_t *shader = GL_FindUberShader( glname, options, &GL_InitSolidStudioUniforms );

	push	OFFSET FLAT:?GL_InitSolidStudioUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitSolidStudioUniforms
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	lea	edx, DWORD PTR _glname$[ebp]
	push	edx
	call	?GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU1@@Z@Z ; GL_FindUberShader
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _shader$[ebp], eax

; 1456 : 	if( !shader )

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L72163

; 1458 : 		SetBits( mat->flags, STUDIO_NF_NODRAW );

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1459 : 		return 0; // something bad happens

	xor	ax, ax
	jmp	SHORT $L72138
$L72163:

; 1461 : 
; 1462 : 	word shaderNum = (shader - glsl_programs);

	mov	eax, DWORD PTR _shader$[ebp]
	sub	eax, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	cdq
	mov	ecx, 876				; 0000036cH
	idiv	ecx
	mov	WORD PTR _shaderNum$[ebp], ax

; 1463 : 
; 1464 : 	// done
; 1465 : 	mat->glsl_sequence = tr.glsl_valid_sequence;

	mov	edx, DWORD PTR _mat$[ebp]
	mov	ax, WORD PTR ?tr@@3Uref_globals_t@@A+1412000
	mov	WORD PTR [edx+20], ax

; 1466 : 	ClearBits( mat->flags, STUDIO_NF_NODRAW );

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -65537				; fffeffffH
	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1467 : 	mat->shaderNum = shaderNum;

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	dx, WORD PTR _shaderNum$[ebp]
	mov	WORD PTR [ecx+12], dx

; 1468 : 
; 1469 : 	return shaderNum;

	mov	ax, WORD PTR _shaderNum$[ebp]
$L72138:

; 1470 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_UberShaderForSolidStudio@@YAGPAUmstudiomat_s@@_N11H@Z ENDP ; GL_UberShaderForSolidStudio
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitSolidStudioUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitSolidStudioUniforms'::`2'::__LINE__Var
PUBLIC	??_C@_0BB@DNPD@u_BoneQuaternion?$AA@		; `string'
PUBLIC	??_C@_0P@IFJG@u_BonePosition?$AA@		; `string'
PUBLIC	??_C@_0O@MPOJ@u_LightStyles?$AA@		; `string'
PUBLIC	??_C@_0N@OOMD@u_LightColor?$AA@			; `string'
PUBLIC	??_C@_0P@HHOG@u_LightAmbient?$AA@		; `string'
PUBLIC	??_C@_0N@OOOP@u_LightShade?$AA@			; `string'
PUBLIC	??_C@_0M@ILDE@u_ViewRight?$AA@			; `string'
;	COMDAT ?__LINE__Var@?1??GL_InitSolidStudioUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitSolidStudioUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 0310H ; `GL_InitSolidStudioUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BB@DNPD@u_BoneQuaternion?$AA@
CONST	SEGMENT
??_C@_0BB@DNPD@u_BoneQuaternion?$AA@ DB 'u_BoneQuaternion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IFJG@u_BonePosition?$AA@
CONST	SEGMENT
??_C@_0P@IFJG@u_BonePosition?$AA@ DB 'u_BonePosition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MPOJ@u_LightStyles?$AA@
CONST	SEGMENT
??_C@_0O@MPOJ@u_LightStyles?$AA@ DB 'u_LightStyles', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OOMD@u_LightColor?$AA@
CONST	SEGMENT
??_C@_0N@OOMD@u_LightColor?$AA@ DB 'u_LightColor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HHOG@u_LightAmbient?$AA@
CONST	SEGMENT
??_C@_0P@HHOG@u_LightAmbient?$AA@ DB 'u_LightAmbient', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OOOP@u_LightShade?$AA@
CONST	SEGMENT
??_C@_0N@OOOP@u_LightShade?$AA@ DB 'u_LightShade', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILDE@u_ViewRight?$AA@
CONST	SEGMENT
??_C@_0M@ILDE@u_ViewRight?$AA@ DB 'u_ViewRight', 00H	; `string'
CONST	ENDS
;	COMDAT ?GL_InitSolidStudioUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitSolidStudioUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitSolidStudioUniforms, COMDAT

; 784  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 785  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71883
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitSolidStudioUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitSolidStudioUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71883:

; 786  : 
; 787  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 788  : 	shader->u_BoneQuaternion = pglGetUniformLocationARB( shader->handle, "u_BoneQuaternion" );

	push	OFFSET FLAT:??_C@_0BB@DNPD@u_BoneQuaternion?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+652], eax

; 789  : 	shader->u_BonePosition = pglGetUniformLocationARB( shader->handle, "u_BonePosition" );

	push	OFFSET FLAT:??_C@_0P@IFJG@u_BonePosition?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+656], eax

; 790  : 
; 791  : 	if( GL_FindShaderDirective( shader, "STUDIO_VERTEX_LIGHTING" ))

	push	OFFSET FLAT:??_C@_0BH@LEI@STUDIO_VERTEX_LIGHTING?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_FindShaderDirective@@YA_NPAUglsl_prog_s@@PBD@Z ; GL_FindShaderDirective
	add	esp, 8
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L71886

; 793  : 		shader->u_LightStyleValues = pglGetUniformLocationARB( shader->handle, "u_LightStyles" ); 

	push	OFFSET FLAT:??_C@_0O@MPOJ@u_LightStyles?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+748], eax

; 794  : 		shader->u_GammaTable = pglGetUniformLocationARB( shader->handle, "u_GammaTable" );

	push	OFFSET FLAT:??_C@_0N@OCGF@u_GammaTable?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+660], eax

; 796  : 	else

	jmp	SHORT $L71890
$L71886:

; 798  : 		shader->u_LightDir = pglGetUniformLocationARB( shader->handle, "u_LightDir" );

	push	OFFSET FLAT:??_C@_0L@PEBL@u_LightDir?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+724], eax

; 799  : 		shader->u_LightColor = pglGetUniformLocationARB( shader->handle, "u_LightColor" );

	push	OFFSET FLAT:??_C@_0N@OOMD@u_LightColor?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+728], eax

; 800  : 		shader->u_LightAmbient = pglGetUniformLocationARB( shader->handle, "u_LightAmbient" );

	push	OFFSET FLAT:??_C@_0P@HHOG@u_LightAmbient?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+732], eax

; 801  : 		shader->u_LightShade = pglGetUniformLocationARB( shader->handle, "u_LightShade" );

	push	OFFSET FLAT:??_C@_0N@OOOP@u_LightShade?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+736], eax
$L71890:

; 803  : 
; 804  : 	shader->u_ViewOrigin = pglGetUniformLocationARB( shader->handle, "u_ViewOrigin" );

	push	OFFSET FLAT:??_C@_0N@HFAH@u_ViewOrigin?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+780], eax

; 805  : 	shader->u_ViewRight = pglGetUniformLocationARB( shader->handle, "u_ViewRight" );

	push	OFFSET FLAT:??_C@_0M@ILDE@u_ViewRight?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+784], eax

; 806  : 	shader->u_RenderColor = pglGetUniformLocationARB( shader->handle, "u_RenderColor" );

	push	OFFSET FLAT:??_C@_0O@IEKC@u_RenderColor?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+840], eax

; 807  : 	shader->u_FogParams = pglGetUniformLocationARB( shader->handle, "u_FogParams" );

	push	OFFSET FLAT:??_C@_0M@BNFL@u_FogParams?$AA@ ; `string'
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [edx+768], eax

; 808  : 
; 809  : 	GL_BindShader( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 810  : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+588]
	push	edx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 811  : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 812  : 
; 813  : 	GL_ValidateProgram( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 814  : 	GL_ShowProgramUniforms( shader );

	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 815  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitSolidStudioUniforms@@YAXPAUglsl_prog_s@@@Z ENDP	; GL_InitSolidStudioUniforms
_TEXT	ENDS
PUBLIC	?GL_UberShaderForDlightStudio@@YAGPBUplight_s@@PAUmstudiomat_s@@_NH@Z ; GL_UberShaderForDlightStudio
PUBLIC	??_C@_0N@LNCN@StudioDlight?$AA@			; `string'
PUBLIC	??_C@_0BN@HFAD@STUDIO_LIGHT_OMNIDIRECTIONAL?$AA@ ; `string'
PUBLIC	??_C@_0BI@LBGG@STUDIO_LIGHT_PROJECTION?$AA@	; `string'
PUBLIC	??_C@_0BD@NHFF@STUDIO_HAS_SHADOWS?$AA@		; `string'
;	COMDAT ??_C@_0N@LNCN@StudioDlight?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0N@LNCN@StudioDlight?$AA@ DB 'StudioDlight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HFAD@STUDIO_LIGHT_OMNIDIRECTIONAL?$AA@
CONST	SEGMENT
??_C@_0BN@HFAD@STUDIO_LIGHT_OMNIDIRECTIONAL?$AA@ DB 'STUDIO_LIGHT_OMNIDIR'
	DB	'ECTIONAL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LBGG@STUDIO_LIGHT_PROJECTION?$AA@
CONST	SEGMENT
??_C@_0BI@LBGG@STUDIO_LIGHT_PROJECTION?$AA@ DB 'STUDIO_LIGHT_PROJECTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NHFF@STUDIO_HAS_SHADOWS?$AA@
CONST	SEGMENT
??_C@_0BD@NHFF@STUDIO_HAS_SHADOWS?$AA@ DB 'STUDIO_HAS_SHADOWS', 00H ; `string'
CONST	ENDS
;	COMDAT ?GL_UberShaderForDlightStudio@@YAGPBUplight_s@@PAUmstudiomat_s@@_NH@Z
_TEXT	SEGMENT
_pl$ = 8
_mat$ = 12
_bone_weighting$ = 16
_numbones$ = 20
_shadows$ = -4
_glname$ = -68
_options$ = -580
_num_bones$72182 = -584
_shader$ = -588
_shaderNum$ = -592
?GL_UberShaderForDlightStudio@@YAGPBUplight_s@@PAUmstudiomat_s@@_NH@Z PROC NEAR ; GL_UberShaderForDlightStudio, COMDAT

; 1473 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 668				; 0000029cH
	push	ebx
	push	esi
	push	edi

; 1474 : 	bool shadows = (!pl->pointlight && !FBitSet( pl->flags, CF_NOSHADOWS )) ? true : false;

	mov	eax, DWORD PTR _pl$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+44]
	test	ecx, ecx
	jne	SHORT $L73015
	mov	edx, DWORD PTR _pl$[ebp]
	mov	eax, DWORD PTR [edx+428]
	and	eax, 1024				; 00000400H
	test	eax, eax
	jne	SHORT $L73015
	mov	BYTE PTR -593+[ebp], 1
	jmp	SHORT $L73016
$L73015:
	mov	BYTE PTR -593+[ebp], 0
$L73016:
	mov	cl, BYTE PTR -593+[ebp]
	mov	BYTE PTR _shadows$[ebp], cl

; 1475 : 	char glname[64];
; 1476 : 	char options[MAX_OPTIONS_LENGTH];
; 1477 : 
; 1478 : 	Q_strncpy( glname, "StudioDlight", sizeof( glname ));

	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_0N@LNCN@StudioDlight?$AA@ ; `string'
	lea	edx, DWORD PTR _glname$[ebp]
	push	edx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1479 : 	memset( options, 0, sizeof( options ));

	push	512					; 00000200H
	push	0
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1480 : 
; 1481 : 	if( pl->pointlight )

	mov	ecx, DWORD PTR _pl$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+44]
	test	edx, edx
	je	SHORT $L72175

; 1483 : 		if( mat->omniLightShaderNum && mat->glsl_sequence_omni == tr.glsl_valid_sequence )

	mov	eax, DWORD PTR _mat$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+14]
	test	ecx, ecx
	je	SHORT $L72176
	mov	edx, DWORD PTR _mat$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+22]
	cmp	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+1412000
	jne	SHORT $L72176

; 1484 : 			return mat->omniLightShaderNum; // valid

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	ax, WORD PTR [ecx+14]
	jmp	$L72170
$L72176:

; 1485 : 		GL_AddShaderDirective( options, "STUDIO_LIGHT_OMNIDIRECTIONAL" );

	push	OFFSET FLAT:??_C@_0BN@HFAD@STUDIO_LIGHT_OMNIDIRECTIONAL?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8

; 1487 : 	else

	jmp	SHORT $L72178
$L72175:

; 1489 : 		if( mat->projLightShaderNum[shadows] && mat->glsl_sequence_proj[shadows] == tr.glsl_valid_sequence )

	mov	eax, DWORD PTR _shadows$[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _mat$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+eax*2+16]
	test	edx, edx
	je	SHORT $L72179
	mov	eax, DWORD PTR _shadows$[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _mat$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+eax*2+24]
	cmp	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1412000
	jne	SHORT $L72179

; 1490 : 			return mat->projLightShaderNum[shadows]; // valid

	mov	eax, DWORD PTR _shadows$[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	ax, WORD PTR [ecx+eax*2+16]
	jmp	$L72170
$L72179:

; 1491 : 		GL_AddShaderDirective( options, "STUDIO_LIGHT_PROJECTION" );

	push	OFFSET FLAT:??_C@_0BI@LBGG@STUDIO_LIGHT_PROJECTION?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72178:

; 1493 : 
; 1494 : 	if( numbones > 0 && glConfig.max_skinning_bones < MAXSTUDIOBONES && glConfig.uniforms_economy )

	cmp	DWORD PTR _numbones$[ebp], 0
	jle	SHORT $L72181
	cmp	DWORD PTR ?glConfig@@3UglConfig_t@@A+72, 128 ; 00000080H
	jge	SHORT $L72181
	xor	eax, eax
	mov	al, BYTE PTR ?glConfig@@3UglConfig_t@@A+80
	test	eax, eax
	je	SHORT $L72181

; 1496 : 		int num_bones = Q_min( numbones, glConfig.max_skinning_bones );

	mov	ecx, DWORD PTR _numbones$[ebp]
	cmp	ecx, DWORD PTR ?glConfig@@3UglConfig_t@@A+72
	jge	SHORT $L73017
	mov	edx, DWORD PTR _numbones$[ebp]
	mov	DWORD PTR -600+[ebp], edx
	jmp	SHORT $L73018
$L73017:
	mov	eax, DWORD PTR ?glConfig@@3UglConfig_t@@A+72
	mov	DWORD PTR -600+[ebp], eax
$L73018:
	mov	ecx, DWORD PTR -600+[ebp]
	mov	DWORD PTR _num_bones$72182[ebp], ecx

; 1497 : 		GL_AddShaderDefine( options, va( "#define MAXSTUDIOBONES %d\n", num_bones ));

	mov	edx, DWORD PTR _num_bones$72182[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BL@GCND@?$CDdefine?5MAXSTUDIOBONES?5?$CFd?6?$AA@ ; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDefine@@YAXPADPBD@Z	; GL_AddShaderDefine
	add	esp, 8

; 1499 : 	else if( numbones == 1 )

	jmp	SHORT $L72184
$L72181:
	cmp	DWORD PTR _numbones$[ebp], 1
	jne	SHORT $L72184

; 1501 : 		GL_AddShaderDefine( options, "#define MAXSTUDIOBONES 1\n" );

	push	OFFSET FLAT:??_C@_0BK@CJHN@?$CDdefine?5MAXSTUDIOBONES?51?6?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDefine@@YAXPADPBD@Z	; GL_AddShaderDefine
	add	esp, 8
$L72184:

; 1503 : 
; 1504 : 	if( bone_weighting )

	mov	edx, DWORD PTR _bone_weighting$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72185

; 1505 : 		GL_AddShaderDirective( options, "STUDIO_BONEWEIGHTING" );

	push	OFFSET FLAT:??_C@_0BF@HOAP@STUDIO_BONEWEIGHTING?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72185:

; 1506 : 
; 1507 : 	if( FBitSet( mat->flags, STUDIO_NF_CHROME ))

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 2
	test	edx, edx
	je	SHORT $L72186

; 1508 : 		GL_AddShaderDirective( options, "STUDIO_HAS_CHROME" );

	push	OFFSET FLAT:??_C@_0BC@ILPH@STUDIO_HAS_CHROME?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72186:

; 1509 : 
; 1510 : 	if( tr.fogEnabled )

	xor	ecx, ecx
	mov	cl, BYTE PTR ?tr@@3Uref_globals_t@@A+1411956
	test	ecx, ecx
	je	SHORT $L72187

; 1511 : 		GL_AddShaderDirective( options, "STUDIO_FOG_EXP" );

	push	OFFSET FLAT:??_C@_0P@EBHP@STUDIO_FOG_EXP?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72187:

; 1512 : 
; 1513 : 	if( CVAR_TO_BOOL( r_shadows ) && !tr.shadows_notsupport )

	cmp	DWORD PTR ?r_shadows@@3PAUcvar_s@@A, 0	; r_shadows
	je	SHORT $L73019
	mov	eax, DWORD PTR ?r_shadows@@3PAUcvar_s@@A ; r_shadows
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L73019
	mov	BYTE PTR -604+[ebp], 1
	jmp	SHORT $L73020
$L73019:
	mov	BYTE PTR -604+[ebp], 0
$L73020:
	mov	ecx, DWORD PTR -604+[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L72189
	xor	edx, edx
	mov	dl, BYTE PTR ?tr@@3Uref_globals_t@@A+1411998
	test	edx, edx
	jne	SHORT $L72189

; 1515 : 		if( !pl->pointlight && !FBitSet( pl->flags, CF_NOSHADOWS ))

	mov	eax, DWORD PTR _pl$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+44]
	test	ecx, ecx
	jne	SHORT $L72189
	mov	edx, DWORD PTR _pl$[ebp]
	mov	eax, DWORD PTR [edx+428]
	and	eax, 1024				; 00000400H
	test	eax, eax
	jne	SHORT $L72189

; 1516 : 			GL_AddShaderDirective( options, "STUDIO_HAS_SHADOWS" );

	push	OFFSET FLAT:??_C@_0BD@NHFF@STUDIO_HAS_SHADOWS?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72189:

; 1518 : 
; 1519 : 	glsl_program_t *shader = GL_FindUberShader( glname, options, &GL_InitStudioDlightUniforms );

	push	OFFSET FLAT:?GL_InitStudioDlightUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitStudioDlightUniforms
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	lea	eax, DWORD PTR _glname$[ebp]
	push	eax
	call	?GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU1@@Z@Z ; GL_FindUberShader
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _shader$[ebp], eax

; 1520 : 	if( !shader )

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L72192

; 1522 : 		SetBits( mat->flags, STUDIO_NF_NODLIGHT );

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	or	edx, 131072				; 00020000H
	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1523 : 		return 0; // something bad happens

	xor	ax, ax
	jmp	$L72170
$L72192:

; 1525 : 
; 1526 : 	word shaderNum = (shader - glsl_programs);

	mov	eax, DWORD PTR _shader$[ebp]
	sub	eax, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	cdq
	mov	ecx, 876				; 0000036cH
	idiv	ecx
	mov	WORD PTR _shaderNum$[ebp], ax

; 1527 : 
; 1528 : 	// done
; 1529 : 	ClearBits( mat->flags, STUDIO_NF_NODLIGHT );

	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, -131073				; fffdffffH
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1530 : 
; 1531 : 	if( pl->pointlight )

	mov	edx, DWORD PTR _pl$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+44]
	test	eax, eax
	je	SHORT $L72194

; 1533 : 		mat->omniLightShaderNum = shaderNum;

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	dx, WORD PTR _shaderNum$[ebp]
	mov	WORD PTR [ecx+14], dx

; 1534 : 		mat->glsl_sequence_omni = tr.glsl_valid_sequence;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	cx, WORD PTR ?tr@@3Uref_globals_t@@A+1412000
	mov	WORD PTR [eax+22], cx

; 1536 : 	else

	jmp	SHORT $L72195
$L72194:

; 1538 : 		mat->projLightShaderNum[shadows] = shaderNum;

	mov	edx, DWORD PTR _shadows$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _mat$[ebp]
	mov	cx, WORD PTR _shaderNum$[ebp]
	mov	WORD PTR [eax+edx*2+16], cx

; 1539 : 		mat->glsl_sequence_proj[shadows] = tr.glsl_valid_sequence;

	mov	edx, DWORD PTR _shadows$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _mat$[ebp]
	mov	cx, WORD PTR ?tr@@3Uref_globals_t@@A+1412000
	mov	WORD PTR [eax+edx*2+24], cx
$L72195:

; 1541 : 
; 1542 : 	return shaderNum;

	mov	ax, WORD PTR _shaderNum$[ebp]
$L72170:

; 1543 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_UberShaderForDlightStudio@@YAGPBUplight_s@@PAUmstudiomat_s@@_NH@Z ENDP ; GL_UberShaderForDlightStudio
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitStudioDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitStudioDlightUniforms'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??GL_InitStudioDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitStudioDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 0332H ; `GL_InitStudioDlightUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?GL_InitStudioDlightUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitStudioDlightUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitStudioDlightUniforms, COMDAT

; 818  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 819  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71900
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitStudioDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitStudioDlightUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71900:

; 820  : 
; 821  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 822  : 	shader->u_ProjectMap = pglGetUniformLocationARB( shader->handle, "u_ProjectMap" );

	push	OFFSET FLAT:??_C@_0N@GDLB@u_ProjectMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+608], eax

; 823  : 	shader->u_ShadowMap = pglGetUniformLocationARB( shader->handle, "u_ShadowMap" );

	push	OFFSET FLAT:??_C@_0M@KOBB@u_ShadowMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+612], eax

; 824  : 	shader->u_BoneQuaternion = pglGetUniformLocationARB( shader->handle, "u_BoneQuaternion" );

	push	OFFSET FLAT:??_C@_0BB@DNPD@u_BoneQuaternion?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+652], eax

; 825  : 	shader->u_BonePosition = pglGetUniformLocationARB( shader->handle, "u_BonePosition" );

	push	OFFSET FLAT:??_C@_0P@IFJG@u_BonePosition?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+656], eax

; 826  : 
; 827  : 	shader->u_LightDir = pglGetUniformLocationARB( shader->handle, "u_LightDir" );

	push	OFFSET FLAT:??_C@_0L@PEBL@u_LightDir?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+724], eax

; 828  : 	shader->u_LightDiffuse = pglGetUniformLocationARB( shader->handle, "u_LightDiffuse" );

	push	OFFSET FLAT:??_C@_0P@FEGO@u_LightDiffuse?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+740], eax

; 829  : 	shader->u_ShadowParams = pglGetUniformLocationARB( shader->handle, "u_ShadowParams" );

	push	OFFSET FLAT:??_C@_0P@IHNO@u_ShadowParams?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+816], eax

; 830  : 	shader->u_LightOrigin = pglGetUniformLocationARB( shader->handle, "u_LightOrigin" );

	push	OFFSET FLAT:??_C@_0O@IPOH@u_LightOrigin?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+772], eax

; 831  : 	shader->u_LightViewProjectionMatrix = pglGetUniformLocationARB( shader->handle, "u_LightViewProjectionMatrix" );

	push	OFFSET FLAT:??_C@_0BM@MOPE@u_LightViewProjectionMatrix?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+676], eax

; 832  : 	shader->u_ViewOrigin = pglGetUniformLocationARB( shader->handle, "u_ViewOrigin" );

	push	OFFSET FLAT:??_C@_0N@HFAH@u_ViewOrigin?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+780], eax

; 833  : 	shader->u_ViewRight = pglGetUniformLocationARB( shader->handle, "u_ViewRight" );

	push	OFFSET FLAT:??_C@_0M@ILDE@u_ViewRight?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+784], eax

; 834  : 	shader->u_FogParams = pglGetUniformLocationARB( shader->handle, "u_FogParams" );

	push	OFFSET FLAT:??_C@_0M@BNFL@u_FogParams?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+768], eax

; 835  : 
; 836  : 	GL_BindShader( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 837  : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 838  : 	pglUniform1iARB( shader->u_ProjectMap, GL_TEXTURE1 );

	push	1
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+608]
	push	eax
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 839  : 	pglUniform1iARB( shader->u_ShadowMap, GL_TEXTURE2 ); // optional

	push	2
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+612]
	push	edx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 840  : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 841  : 
; 842  : 	GL_ValidateProgram( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 843  : 	GL_ShowProgramUniforms( shader );

	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 844  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitStudioDlightUniforms@@YAXPAUglsl_prog_s@@@Z ENDP ; GL_InitStudioDlightUniforms
_TEXT	ENDS
PUBLIC	?GL_UberShaderForStudioDecal@@YAGPAUmstudiomat_s@@@Z ; GL_UberShaderForStudioDecal
PUBLIC	??_C@_0M@MHAK@StudioDecal?$AA@			; `string'
PUBLIC	??_C@_0BD@FBLB@STUDIO_ALPHA_GLASS?$AA@		; `string'
;	COMDAT ??_C@_0M@MHAK@StudioDecal?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0M@MHAK@StudioDecal?$AA@ DB 'StudioDecal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FBLB@STUDIO_ALPHA_GLASS?$AA@
CONST	SEGMENT
??_C@_0BD@FBLB@STUDIO_ALPHA_GLASS?$AA@ DB 'STUDIO_ALPHA_GLASS', 00H ; `string'
CONST	ENDS
;	COMDAT ?GL_UberShaderForStudioDecal@@YAGPAUmstudiomat_s@@@Z
_TEXT	SEGMENT
_mat$ = 8
_glname$ = -64
_options$ = -576
_shader$ = -580
?GL_UberShaderForStudioDecal@@YAGPAUmstudiomat_s@@@Z PROC NEAR ; GL_UberShaderForStudioDecal, COMDAT

; 1546 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 644				; 00000284H
	push	ebx
	push	esi
	push	edi

; 1547 : 	char glname[64];
; 1548 : 	char options[MAX_OPTIONS_LENGTH];
; 1549 : 
; 1550 : 	Q_strncpy( glname, "StudioDecal", sizeof( glname ));

	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_0M@MHAK@StudioDecal?$AA@ ; `string'
	lea	eax, DWORD PTR _glname$[ebp]
	push	eax
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1551 : 	memset( options, 0, sizeof( options ));

	push	512					; 00000200H
	push	0
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1552 : 
; 1553 : 	if( tr.fogEnabled )

	xor	edx, edx
	mov	dl, BYTE PTR ?tr@@3Uref_globals_t@@A+1411956
	test	edx, edx
	je	SHORT $L72202

; 1554 : 		GL_AddShaderDirective( options, "DECAL_FOG_EXP" );

	push	OFFSET FLAT:??_C@_0O@NFNC@DECAL_FOG_EXP?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72202:

; 1555 : 
; 1556 : 	if( FBitSet( mat->flags, STUDIO_NF_MASKED ))

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 64					; 00000040H
	test	edx, edx
	je	SHORT $L72203

; 1557 : 		GL_AddShaderDirective( options, "DECAL_ALPHATEST" );

	push	OFFSET FLAT:??_C@_0BA@OEHD@DECAL_ALPHATEST?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72203:

; 1558 : 
; 1559 : 	if( FBitSet( mat->flags, STUDIO_NF_ADDITIVE ))

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 32					; 00000020H
	test	edx, edx
	je	SHORT $L72205

; 1561 : 		// mixed mode: solid & transparent controlled by alha-channel
; 1562 : 		if( FBitSet( mat->flags, STUDIO_NF_MASKED ))

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 64					; 00000040H
	test	ecx, ecx
	je	SHORT $L72205

; 1563 : 			GL_AddShaderDirective( options, "STUDIO_ALPHA_GLASS" );

	push	OFFSET FLAT:??_C@_0BD@FBLB@STUDIO_ALPHA_GLASS?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72205:

; 1565 : 
; 1566 : 	glsl_program_t *shader = GL_FindUberShader( glname, options, &GL_InitStudioDecalUniforms );

	push	OFFSET FLAT:?GL_InitStudioDecalUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitStudioDecalUniforms
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	lea	ecx, DWORD PTR _glname$[ebp]
	push	ecx
	call	?GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU1@@Z@Z ; GL_FindUberShader
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _shader$[ebp], eax

; 1567 : 	if( !shader ) return 0; // something bad happens

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L72208
	xor	ax, ax
	jmp	SHORT $L72198
$L72208:

; 1568 : 
; 1569 : 	return (shader - glsl_programs);

	mov	eax, DWORD PTR _shader$[ebp]
	sub	eax, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	cdq
	mov	ecx, 876				; 0000036cH
	idiv	ecx
$L72198:

; 1570 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_UberShaderForStudioDecal@@YAGPAUmstudiomat_s@@@Z ENDP ; GL_UberShaderForStudioDecal
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitStudioDecalUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitStudioDecalUniforms'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??GL_InitStudioDecalUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitStudioDecalUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 03b1H ; `GL_InitStudioDecalUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?GL_InitStudioDecalUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitStudioDecalUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitStudioDecalUniforms, COMDAT

; 945  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 946  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71930
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitStudioDecalUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitStudioDecalUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71930:

; 947  : 
; 948  : 	shader->u_DecalMap = pglGetUniformLocationARB( shader->handle, "u_DecalMap" );

	push	OFFSET FLAT:??_C@_0L@NBHD@u_DecalMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+628], eax

; 949  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 950  : 	shader->u_FogParams = pglGetUniformLocationARB( shader->handle, "u_FogParams" );

	push	OFFSET FLAT:??_C@_0M@BNFL@u_FogParams?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+768], eax

; 951  : 
; 952  : 	GL_BindShader( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 953  : 	pglUniform1iARB( shader->u_DecalMap, GL_TEXTURE0 );

	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+628]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 954  : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE1 );

	push	1
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+588]
	push	eax
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 955  : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 956  : 
; 957  : 	GL_ValidateProgram( shader );

	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 958  : 	GL_ShowProgramUniforms( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 959  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitStudioDecalUniforms@@YAXPAUglsl_prog_s@@@Z ENDP	; GL_InitStudioDecalUniforms
_TEXT	ENDS
PUBLIC	?GL_UberShaderForDlightGeneric@@YAGPBUplight_s@@@Z ; GL_UberShaderForDlightGeneric
PUBLIC	??_C@_0O@ONKA@GenericDlight?$AA@		; `string'
PUBLIC	??_C@_0BO@GGLJ@GENERIC_LIGHT_OMNIDIRECTIONAL?$AA@ ; `string'
PUBLIC	??_C@_0BJ@DEA@GENERIC_LIGHT_PROJECTION?$AA@	; `string'
PUBLIC	??_C@_0BA@ENIE@GENERIC_FOG_EXP?$AA@		; `string'
PUBLIC	??_C@_0BE@PHFM@GENERIC_HAS_SHADOWS?$AA@		; `string'
;	COMDAT ??_C@_0O@ONKA@GenericDlight?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0O@ONKA@GenericDlight?$AA@ DB 'GenericDlight', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GGLJ@GENERIC_LIGHT_OMNIDIRECTIONAL?$AA@
CONST	SEGMENT
??_C@_0BO@GGLJ@GENERIC_LIGHT_OMNIDIRECTIONAL?$AA@ DB 'GENERIC_LIGHT_OMNID'
	DB	'IRECTIONAL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DEA@GENERIC_LIGHT_PROJECTION?$AA@
CONST	SEGMENT
??_C@_0BJ@DEA@GENERIC_LIGHT_PROJECTION?$AA@ DB 'GENERIC_LIGHT_PROJECTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ENIE@GENERIC_FOG_EXP?$AA@
CONST	SEGMENT
??_C@_0BA@ENIE@GENERIC_FOG_EXP?$AA@ DB 'GENERIC_FOG_EXP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PHFM@GENERIC_HAS_SHADOWS?$AA@
CONST	SEGMENT
??_C@_0BE@PHFM@GENERIC_HAS_SHADOWS?$AA@ DB 'GENERIC_HAS_SHADOWS', 00H ; `string'
CONST	ENDS
;	COMDAT ?GL_UberShaderForDlightGeneric@@YAGPBUplight_s@@@Z
_TEXT	SEGMENT
_pl$ = 8
_shadows$ = -4
_glname$ = -68
_options$ = -580
_shader$ = -584
_shaderNum$ = -588
?GL_UberShaderForDlightGeneric@@YAGPBUplight_s@@@Z PROC NEAR ; GL_UberShaderForDlightGeneric, COMDAT

; 1573 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 660				; 00000294H
	push	ebx
	push	esi
	push	edi

; 1574 : 	bool shadows = (!pl->pointlight && !FBitSet( pl->flags, CF_NOSHADOWS )) ? true : false;

	mov	eax, DWORD PTR _pl$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+44]
	test	ecx, ecx
	jne	SHORT $L73029
	mov	edx, DWORD PTR _pl$[ebp]
	mov	eax, DWORD PTR [edx+428]
	and	eax, 1024				; 00000400H
	test	eax, eax
	jne	SHORT $L73029
	mov	BYTE PTR -589+[ebp], 1
	jmp	SHORT $L73030
$L73029:
	mov	BYTE PTR -589+[ebp], 0
$L73030:
	mov	cl, BYTE PTR -589+[ebp]
	mov	BYTE PTR _shadows$[ebp], cl

; 1575 : 
; 1576 : 	if( pl->pointlight )

	mov	edx, DWORD PTR _pl$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+44]
	test	eax, eax
	je	SHORT $L72213

; 1578 : 		if( tr.omniLightShaderNum && tr.glsl_sequence_omni == tr.glsl_valid_sequence )

	xor	ecx, ecx
	mov	cx, WORD PTR ?tr@@3Uref_globals_t@@A+1416122
	test	ecx, ecx
	je	SHORT $L72214
	xor	edx, edx
	mov	dx, WORD PTR ?tr@@3Uref_globals_t@@A+1416128
	cmp	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1412000
	jne	SHORT $L72214

; 1579 : 			return tr.omniLightShaderNum; // valid

	mov	ax, WORD PTR ?tr@@3Uref_globals_t@@A+1416122
	jmp	$L72211
$L72214:

; 1581 : 	else

	jmp	SHORT $L72216
$L72213:

; 1583 : 		if( tr.projLightShaderNum && tr.glsl_sequence_proj[shadows] == tr.glsl_valid_sequence )

	mov	eax, OFFSET FLAT:?tr@@3Uref_globals_t@@A+1416124
	test	eax, eax
	je	SHORT $L72216
	mov	ecx, DWORD PTR _shadows$[ebp]
	and	ecx, 255				; 000000ffH
	xor	edx, edx
	mov	dx, WORD PTR ?tr@@3Uref_globals_t@@A[ecx*2+1416130]
	cmp	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1412000
	jne	SHORT $L72216

; 1584 : 			return tr.projLightShaderNum[shadows]; // valid

	mov	eax, DWORD PTR _shadows$[ebp]
	and	eax, 255				; 000000ffH
	mov	ax, WORD PTR ?tr@@3Uref_globals_t@@A[eax*2+1416124]
	jmp	$L72211
$L72216:

; 1586 : 
; 1587 : 	char glname[64];
; 1588 : 	char options[MAX_OPTIONS_LENGTH];
; 1589 : 
; 1590 : 	Q_strncpy( glname, "GenericDlight", sizeof( glname ));

	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_0O@ONKA@GenericDlight?$AA@ ; `string'
	lea	ecx, DWORD PTR _glname$[ebp]
	push	ecx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1591 : 	memset( options, 0, sizeof( options ));

	push	512					; 00000200H
	push	0
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1592 : 
; 1593 : 	if( pl->pointlight )

	mov	eax, DWORD PTR _pl$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+44]
	test	ecx, ecx
	je	SHORT $L72220

; 1594 : 		GL_AddShaderDirective( options, "GENERIC_LIGHT_OMNIDIRECTIONAL" );

	push	OFFSET FLAT:??_C@_0BO@GGLJ@GENERIC_LIGHT_OMNIDIRECTIONAL?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8

; 1595 : 	else GL_AddShaderDirective( options, "GENERIC_LIGHT_PROJECTION" );

	jmp	SHORT $L72222
$L72220:
	push	OFFSET FLAT:??_C@_0BJ@DEA@GENERIC_LIGHT_PROJECTION?$AA@ ; `string'
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72222:

; 1596 : 
; 1597 : 	if( tr.fogEnabled )

	xor	ecx, ecx
	mov	cl, BYTE PTR ?tr@@3Uref_globals_t@@A+1411956
	test	ecx, ecx
	je	SHORT $L72224

; 1598 : 		GL_AddShaderDirective( options, "GENERIC_FOG_EXP" );

	push	OFFSET FLAT:??_C@_0BA@ENIE@GENERIC_FOG_EXP?$AA@ ; `string'
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72224:

; 1599 : 
; 1600 : 	if( CVAR_TO_BOOL( r_shadows ) && shadows && !tr.shadows_notsupport )

	cmp	DWORD PTR ?r_shadows@@3PAUcvar_s@@A, 0	; r_shadows
	je	SHORT $L73031
	mov	eax, DWORD PTR ?r_shadows@@3PAUcvar_s@@A ; r_shadows
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L73031
	mov	BYTE PTR -596+[ebp], 1
	jmp	SHORT $L73032
$L73031:
	mov	BYTE PTR -596+[ebp], 0
$L73032:
	mov	ecx, DWORD PTR -596+[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L72226
	mov	edx, DWORD PTR _shadows$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L72226
	xor	eax, eax
	mov	al, BYTE PTR ?tr@@3Uref_globals_t@@A+1411998
	test	eax, eax
	jne	SHORT $L72226

; 1601 : 		GL_AddShaderDirective( options, "GENERIC_HAS_SHADOWS" );

	push	OFFSET FLAT:??_C@_0BE@PHFM@GENERIC_HAS_SHADOWS?$AA@ ; `string'
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	?GL_AddShaderDirective@@YAXPADPBD@Z	; GL_AddShaderDirective
	add	esp, 8
$L72226:

; 1602 : 
; 1603 : 	glsl_program_t *shader = GL_FindUberShader( glname, options, &GL_InitGenericDlightUniforms );

	push	OFFSET FLAT:?GL_InitGenericDlightUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitGenericDlightUniforms
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	lea	eax, DWORD PTR _glname$[ebp]
	push	eax
	call	?GL_FindUberShader@@YAPAUglsl_prog_s@@PBD0P6AXPAU1@@Z@Z ; GL_FindUberShader
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _shader$[ebp], eax

; 1604 : 	if( !shader )

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L72229

; 1606 : 		tr.nodlights = true;

	mov	BYTE PTR ?tr@@3Uref_globals_t@@A+1416120, 1

; 1607 : 		return 0; // something bad happens

	xor	ax, ax
	jmp	$L72211
$L72229:

; 1609 : 
; 1610 : 	word shaderNum = (shader - glsl_programs);

	mov	eax, DWORD PTR _shader$[ebp]
	sub	eax, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	cdq
	mov	ecx, 876				; 0000036cH
	idiv	ecx
	mov	WORD PTR _shaderNum$[ebp], ax

; 1611 : 
; 1612 : 	// done
; 1613 : 	tr.nodlights = false;

	mov	BYTE PTR ?tr@@3Uref_globals_t@@A+1416120, 0

; 1614 : 
; 1615 : 	if( pl->pointlight )

	mov	edx, DWORD PTR _pl$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+44]
	test	eax, eax
	je	SHORT $L72231

; 1617 : 		tr.omniLightShaderNum = shaderNum;

	mov	cx, WORD PTR _shaderNum$[ebp]
	mov	WORD PTR ?tr@@3Uref_globals_t@@A+1416122, cx

; 1618 : 		tr.glsl_sequence_omni = tr.glsl_valid_sequence;

	mov	dx, WORD PTR ?tr@@3Uref_globals_t@@A+1412000
	mov	WORD PTR ?tr@@3Uref_globals_t@@A+1416128, dx

; 1620 : 	else

	jmp	SHORT $L72232
$L72231:

; 1622 : 		tr.projLightShaderNum[shadows] = shaderNum;

	mov	eax, DWORD PTR _shadows$[ebp]
	and	eax, 255				; 000000ffH
	mov	cx, WORD PTR _shaderNum$[ebp]
	mov	WORD PTR ?tr@@3Uref_globals_t@@A[eax*2+1416124], cx

; 1623 : 		tr.glsl_sequence_proj[shadows] = tr.glsl_valid_sequence;

	mov	edx, DWORD PTR _shadows$[ebp]
	and	edx, 255				; 000000ffH
	mov	ax, WORD PTR ?tr@@3Uref_globals_t@@A+1412000
	mov	WORD PTR ?tr@@3Uref_globals_t@@A[edx*2+1416130], ax
$L72232:

; 1625 : 
; 1626 : 	return shaderNum;

	mov	ax, WORD PTR _shaderNum$[ebp]
$L72211:

; 1627 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_UberShaderForDlightGeneric@@YAGPBUplight_s@@@Z ENDP	; GL_UberShaderForDlightGeneric
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitGenericDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitGenericDlightUniforms'::`2'::__LINE__Var
PUBLIC	??_C@_0N@BONN@u_LightScale?$AA@			; `string'
;	COMDAT ?__LINE__Var@?1??GL_InitGenericDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitGenericDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 0397H ; `GL_InitGenericDlightUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@BONN@u_LightScale?$AA@
CONST	SEGMENT
??_C@_0N@BONN@u_LightScale?$AA@ DB 'u_LightScale', 00H	; `string'
CONST	ENDS
;	COMDAT ?GL_InitGenericDlightUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitGenericDlightUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitGenericDlightUniforms, COMDAT

; 919  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 920  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71924
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitGenericDlightUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitGenericDlightUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71924:

; 921  : 
; 922  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 923  : 	shader->u_ProjectMap = pglGetUniformLocationARB( shader->handle, "u_ProjectMap" );

	push	OFFSET FLAT:??_C@_0N@GDLB@u_ProjectMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+608], eax

; 924  : 	shader->u_ShadowMap = pglGetUniformLocationARB( shader->handle, "u_ShadowMap" );

	push	OFFSET FLAT:??_C@_0M@KOBB@u_ShadowMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+612], eax

; 925  : 
; 926  : 	shader->u_LightDir = pglGetUniformLocationARB( shader->handle, "u_LightDir" );

	push	OFFSET FLAT:??_C@_0L@PEBL@u_LightDir?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+724], eax

; 927  : 	shader->u_LightDiffuse = pglGetUniformLocationARB( shader->handle, "u_LightDiffuse" );

	push	OFFSET FLAT:??_C@_0P@FEGO@u_LightDiffuse?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+740], eax

; 928  : 	shader->u_ShadowParams = pglGetUniformLocationARB( shader->handle, "u_ShadowParams" );

	push	OFFSET FLAT:??_C@_0P@IHNO@u_ShadowParams?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+816], eax

; 929  : 	shader->u_LightOrigin = pglGetUniformLocationARB( shader->handle, "u_LightOrigin" );

	push	OFFSET FLAT:??_C@_0O@IPOH@u_LightOrigin?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+772], eax

; 930  : 	shader->u_LightViewProjectionMatrix = pglGetUniformLocationARB( shader->handle, "u_LightViewProjectionMatrix" );

	push	OFFSET FLAT:??_C@_0BM@MOPE@u_LightViewProjectionMatrix?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+676], eax

; 931  : 	shader->u_FogParams = pglGetUniformLocationARB( shader->handle, "u_FogParams" );

	push	OFFSET FLAT:??_C@_0M@BNFL@u_FogParams?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+768], eax

; 932  : 	shader->u_LightScale = pglGetUniformLocationARB( shader->handle, "u_LightScale" );

	push	OFFSET FLAT:??_C@_0N@BONN@u_LightScale?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+776], eax

; 933  : 
; 934  : 	GL_BindShader( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 935  : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 936  : 	pglUniform1iARB( shader->u_ProjectMap, GL_TEXTURE1 );

	push	1
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+608]
	push	eax
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 937  : 	pglUniform1iARB( shader->u_ShadowMap, GL_TEXTURE2 ); // optional

	push	2
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+612]
	push	edx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 938  : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 939  : 
; 940  : 	GL_ValidateProgram( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 941  : 	GL_ShowProgramUniforms( shader );

	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 942  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitGenericDlightUniforms@@YAXPAUglsl_prog_s@@@Z ENDP ; GL_InitGenericDlightUniforms
_TEXT	ENDS
PUBLIC	?GL_ListGPUShaders@@YAXXZ			; GL_ListGPUShaders
PUBLIC	??_C@_0N@EGKO@?$CD?$CFi?5?$CFs?5?$FL?$CFs?$FN?6?$AA@ ; `string'
PUBLIC	??_C@_07KHDD@?$CD?$CFi?5?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_0BC@MLEK@total?5?$CFi?5shaders?6?$AA@	; `string'
;	COMDAT ??_C@_0N@EGKO@?$CD?$CFi?5?$CFs?5?$FL?$CFs?$FN?6?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0N@EGKO@?$CD?$CFi?5?$CFs?5?$FL?$CFs?$FN?6?$AA@ DB '#%i %s [%s]', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07KHDD@?$CD?$CFi?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_07KHDD@?$CD?$CFi?5?$CFs?6?$AA@ DB '#%i %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MLEK@total?5?$CFi?5shaders?6?$AA@
CONST	SEGMENT
??_C@_0BC@MLEK@total?5?$CFi?5shaders?6?$AA@ DB 'total %i shaders', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?GL_ListGPUShaders@@YAXXZ
_TEXT	SEGMENT
_count$ = -4
_i$ = -8
_cur$72241 = -12
_options$72243 = -16
?GL_ListGPUShaders@@YAXXZ PROC NEAR			; GL_ListGPUShaders, COMDAT

; 1630 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1631 : 	int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 1632 : 
; 1633 : 	for( unsigned int i = 1; i < num_glsl_programs; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L72238
$L72239:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L72238:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?num_glsl_programs@@3IA	; num_glsl_programs
	jae	$L72240

; 1635 : 		glsl_program_t *cur = &glsl_programs[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 876				; 0000036cH
	add	edx, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	mov	DWORD PTR _cur$72241[ebp], edx

; 1636 : 		if( !cur->name[0] ) continue;

	mov	eax, DWORD PTR _cur$72241[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L72242
	jmp	SHORT $L72239
$L72242:

; 1637 : 
; 1638 : 		const char *options = GL_PretifyListOptions( cur->options );

	push	0
	mov	edx, DWORD PTR _cur$72241[ebp]
	add	edx, 64					; 00000040H
	push	edx
	call	?GL_PretifyListOptions@@YAPBDPBD_N@Z	; GL_PretifyListOptions
	add	esp, 8
	mov	DWORD PTR _options$72243[ebp], eax

; 1639 : 
; 1640 : 		if( Q_stricmp( options, "" ))

	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	eax, DWORD PTR _options$72243[ebp]
	push	eax
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L72244

; 1641 : 			Msg( "#%i %s [%s]\n", i, cur->name, options );

	mov	ecx, DWORD PTR _options$72243[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$72241[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0N@EGKO@?$CD?$CFi?5?$CFs?5?$FL?$CFs?$FN?6?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+160
	add	esp, 16					; 00000010H

; 1642 : 		else Msg( "#%i %s\n", i, cur->name );

	jmp	SHORT $L72246
$L72244:
	mov	ecx, DWORD PTR _cur$72241[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_07KHDD@?$CD?$CFi?5?$CFs?6?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+160
	add	esp, 12					; 0000000cH
$L72246:

; 1643 : 		count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 1644 : 	}

	jmp	$L72239
$L72240:

; 1645 : 
; 1646 : 	Msg( "total %i shaders\n", count );

	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BC@MLEK@total?5?$CFi?5shaders?6?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+160
	add	esp, 8

; 1647 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_ListGPUShaders@@YAXXZ ENDP				; GL_ListGPUShaders
_TEXT	ENDS
PUBLIC	?GL_InitGPUShaders@@YAXXZ			; GL_InitGPUShaders
PUBLIC	??_C@_0L@OIIH@shaderlist?$AA@			; `string'
PUBLIC	??_C@_09DMKC@genshafts?$AA@			; `string'
PUBLIC	??_C@_07LFGH@generic?$AA@			; `string'
PUBLIC	??_C@_0N@PBCC@GenSunShafts?$AA@			; `string'
PUBLIC	??_C@_0L@HHEC@drawshafts?$AA@			; `string'
PUBLIC	??_C@_0O@PBJN@DrawSunShafts?$AA@		; `string'
PUBLIC	??_C@_0BA@LPOA@?$CDdefine?5BLUR_X?6?$AA@	; `string'
PUBLIC	??_C@_09PGBC@gaussblur?$AA@			; `string'
PUBLIC	??_C@_0O@FMEL@HW_GaussBlurX?$AA@		; `string'
PUBLIC	??_C@_0BA@KJEK@?$CDdefine?5BLUR_Y?6?$AA@	; `string'
PUBLIC	??_C@_0O@PGNM@HW_GaussBlurY?$AA@		; `string'
PUBLIC	??_C@_06LCDM@skybox?$AA@			; `string'
PUBLIC	??_C@_0O@IHBG@SkyBoxGeneric?$AA@		; `string'
PUBLIC	??_C@_0M@JMKO@StudioDepth?$AA@			; `string'
PUBLIC	??_C@_0BO@GCPH@?$CDdefine?5STUDIO_BONEWEIGHTING?6?$AA@ ; `string'
PUBLIC	??_C@_0M@BBGB@BmodelDepth?$AA@			; `string'
PUBLIC	??_C@_0L@CBFB@BrushDepth?$AA@			; `string'
PUBLIC	??_C@_0L@HKCK@GrassDepth?$AA@			; `string'
PUBLIC	??_C@_0BJ@GABA@?$CDdefine?5GENERIC_FOG_EXP?6?$AA@ ; `string'
PUBLIC	??_C@_0L@KDCB@GenericFog?$AA@			; `string'
PUBLIC	??0plight_s@@QAE@XZ				; plight_s::plight_s
;	COMDAT ??_C@_0L@OIIH@shaderlist?$AA@
; File z:\xashxtsrc\client\render\r_shader.cpp
CONST	SEGMENT
??_C@_0L@OIIH@shaderlist?$AA@ DB 'shaderlist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DMKC@genshafts?$AA@
CONST	SEGMENT
??_C@_09DMKC@genshafts?$AA@ DB 'genshafts', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LFGH@generic?$AA@
CONST	SEGMENT
??_C@_07LFGH@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PBCC@GenSunShafts?$AA@
CONST	SEGMENT
??_C@_0N@PBCC@GenSunShafts?$AA@ DB 'GenSunShafts', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HHEC@drawshafts?$AA@
CONST	SEGMENT
??_C@_0L@HHEC@drawshafts?$AA@ DB 'drawshafts', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PBJN@DrawSunShafts?$AA@
CONST	SEGMENT
??_C@_0O@PBJN@DrawSunShafts?$AA@ DB 'DrawSunShafts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LPOA@?$CDdefine?5BLUR_X?6?$AA@
CONST	SEGMENT
??_C@_0BA@LPOA@?$CDdefine?5BLUR_X?6?$AA@ DB '#define BLUR_X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PGBC@gaussblur?$AA@
CONST	SEGMENT
??_C@_09PGBC@gaussblur?$AA@ DB 'gaussblur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FMEL@HW_GaussBlurX?$AA@
CONST	SEGMENT
??_C@_0O@FMEL@HW_GaussBlurX?$AA@ DB 'HW_GaussBlurX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KJEK@?$CDdefine?5BLUR_Y?6?$AA@
CONST	SEGMENT
??_C@_0BA@KJEK@?$CDdefine?5BLUR_Y?6?$AA@ DB '#define BLUR_Y', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PGNM@HW_GaussBlurY?$AA@
CONST	SEGMENT
??_C@_0O@PGNM@HW_GaussBlurY?$AA@ DB 'HW_GaussBlurY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LCDM@skybox?$AA@
CONST	SEGMENT
??_C@_06LCDM@skybox?$AA@ DB 'skybox', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IHBG@SkyBoxGeneric?$AA@
CONST	SEGMENT
??_C@_0O@IHBG@SkyBoxGeneric?$AA@ DB 'SkyBoxGeneric', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMKO@StudioDepth?$AA@
CONST	SEGMENT
??_C@_0M@JMKO@StudioDepth?$AA@ DB 'StudioDepth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GCPH@?$CDdefine?5STUDIO_BONEWEIGHTING?6?$AA@
CONST	SEGMENT
??_C@_0BO@GCPH@?$CDdefine?5STUDIO_BONEWEIGHTING?6?$AA@ DB '#define STUDIO'
	DB	'_BONEWEIGHTING', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BBGB@BmodelDepth?$AA@
CONST	SEGMENT
??_C@_0M@BBGB@BmodelDepth?$AA@ DB 'BmodelDepth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CBFB@BrushDepth?$AA@
CONST	SEGMENT
??_C@_0L@CBFB@BrushDepth?$AA@ DB 'BrushDepth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HKCK@GrassDepth?$AA@
CONST	SEGMENT
??_C@_0L@HKCK@GrassDepth?$AA@ DB 'GrassDepth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GABA@?$CDdefine?5GENERIC_FOG_EXP?6?$AA@
CONST	SEGMENT
??_C@_0BJ@GABA@?$CDdefine?5GENERIC_FOG_EXP?6?$AA@ DB '#define GENERIC_FOG'
	DB	'_EXP', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KDCB@GenericFog?$AA@
CONST	SEGMENT
??_C@_0L@KDCB@GenericFog?$AA@ DB 'GenericFog', 00H	; `string'
CONST	ENDS
;	COMDAT ?GL_InitGPUShaders@@YAXXZ
_TEXT	SEGMENT
_pl$ = -436
_shader$ = -440
?GL_InitGPUShaders@@YAXXZ PROC NEAR			; GL_InitGPUShaders, COMDAT

; 1650 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 504				; 000001f8H
	push	ebx
	push	esi
	push	edi

; 1651 : 	plight_t	pl;

	lea	ecx, DWORD PTR _pl$[ebp]
	call	??0plight_s@@QAE@XZ			; plight_s::plight_s

; 1652 : 
; 1653 : 	memset( &glsl_programs, 0, sizeof( glsl_programs ));

	push	448512					; 0006d800H
	push	0
	push	OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	call	_memset
	add	esp, 12					; 0000000cH

; 1654 : 	memset( &glsl, 0, sizeof( glsl ));

	push	40					; 00000028H
	push	0
	push	OFFSET FLAT:?glsl@@3Uref_shaders_t@@A	; glsl
	call	_memset
	add	esp, 12					; 0000000cH

; 1655 : 	memset( &pl, 0, sizeof( pl ));

	push	436					; 000001b4H
	push	0
	lea	eax, DWORD PTR _pl$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1656 : 	tr.glsl_valid_sequence = 1;

	mov	DWORD PTR ?tr@@3Uref_globals_t@@A+1412000, 1

; 1657 : 	num_glsl_programs = 1; // entry #0 isn't used

	mov	DWORD PTR ?num_glsl_programs@@3IA, 1	; num_glsl_programs

; 1658 : 
; 1659 : 	if( !GL_Support( R_SHADER_GLSL100_EXT ))

	push	8
	call	?GL_Support@@YA_NH@Z			; GL_Support
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L72253

; 1660 : 		return;

	jmp	$L72251
$L72253:

; 1661 : 
; 1662 : 	ADD_COMMAND( "shaderlist", GL_ListGPUShaders );

	push	OFFSET FLAT:?GL_ListGPUShaders@@YAXXZ	; GL_ListGPUShaders
	push	OFFSET FLAT:??_C@_0L@OIIH@shaderlist?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+68
	add	esp, 8

; 1663 : 
; 1664 : 	glsl_program_t *shader; // generic pointer. help to initialize uniforms
; 1665 : 
; 1666 : 	// prepare sunshafts
; 1667 : 	glsl.genSunShafts = shader = GL_InitGPUShader( "GenSunShafts", "generic", "genshafts" );

	push	0
	push	OFFSET FLAT:??_C@_09DMKC@genshafts?$AA@	; `string'
	push	OFFSET FLAT:??_C@_07LFGH@generic?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@PBCC@GenSunShafts?$AA@ ; `string'
	call	?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z ; GL_InitGPUShader
	add	esp, 16					; 00000010H
	mov	DWORD PTR _shader$[ebp], eax
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR ?glsl@@3Uref_shaders_t@@A, ecx

; 1668 : 	GL_InitGenShaftsUniforms( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_InitGenShaftsUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitGenShaftsUniforms
	add	esp, 4

; 1669 : 
; 1670 : 	// render sunshafts
; 1671 : 	glsl.drawSunShafts = shader = GL_InitGPUShader( "DrawSunShafts", "generic", "drawshafts" );

	push	0
	push	OFFSET FLAT:??_C@_0L@HHEC@drawshafts?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_07LFGH@generic?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@PBJN@DrawSunShafts?$AA@ ; `string'
	call	?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z ; GL_InitGPUShader
	add	esp, 16					; 00000010H
	mov	DWORD PTR _shader$[ebp], eax
	mov	eax, DWORD PTR _shader$[ebp]
	mov	DWORD PTR ?glsl@@3Uref_shaders_t@@A+12, eax

; 1672 : 	GL_InitDrawShaftsUniforms( shader );

	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_InitDrawShaftsUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitDrawShaftsUniforms
	add	esp, 4

; 1673 : 
; 1674 : 	// gaussian blur for X
; 1675 : 	glsl.blurShader[0] = shader = GL_InitGPUShader( "HW_GaussBlurX", "generic", "gaussblur", "#define BLUR_X\n" );

	push	OFFSET FLAT:??_C@_0BA@LPOA@?$CDdefine?5BLUR_X?6?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09PGBC@gaussblur?$AA@	; `string'
	push	OFFSET FLAT:??_C@_07LFGH@generic?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@FMEL@HW_GaussBlurX?$AA@ ; `string'
	call	?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z ; GL_InitGPUShader
	add	esp, 16					; 00000010H
	mov	DWORD PTR _shader$[ebp], eax
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR ?glsl@@3Uref_shaders_t@@A+4, edx

; 1676 : 	GL_InitPostProcessUniforms( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_InitPostProcessUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitPostProcessUniforms
	add	esp, 4

; 1677 : 
; 1678 : 	// gaussian blur for Y
; 1679 : 	glsl.blurShader[1] = shader = GL_InitGPUShader( "HW_GaussBlurY", "generic", "gaussblur", "#define BLUR_Y\n" );

	push	OFFSET FLAT:??_C@_0BA@KJEK@?$CDdefine?5BLUR_Y?6?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09PGBC@gaussblur?$AA@	; `string'
	push	OFFSET FLAT:??_C@_07LFGH@generic?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@PGNM@HW_GaussBlurY?$AA@ ; `string'
	call	?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z ; GL_InitGPUShader
	add	esp, 16					; 00000010H
	mov	DWORD PTR _shader$[ebp], eax
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR ?glsl@@3Uref_shaders_t@@A+8, ecx

; 1680 : 	GL_InitPostProcessUniforms( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_InitPostProcessUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitPostProcessUniforms
	add	esp, 4

; 1681 : 
; 1682 : 	// draw sun & skybox
; 1683 : 	glsl.skyboxEnv = shader = GL_InitGPUShader( "SkyBoxGeneric", "generic", "skybox" );

	push	0
	push	OFFSET FLAT:??_C@_06LCDM@skybox?$AA@	; `string'
	push	OFFSET FLAT:??_C@_07LFGH@generic?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@IHBG@SkyBoxGeneric?$AA@ ; `string'
	call	?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z ; GL_InitGPUShader
	add	esp, 16					; 00000010H
	mov	DWORD PTR _shader$[ebp], eax
	mov	eax, DWORD PTR _shader$[ebp]
	mov	DWORD PTR ?glsl@@3Uref_shaders_t@@A+16, eax

; 1684 : 	GL_InitSkyBoxUniforms( shader );

	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_InitSkyBoxUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitSkyBoxUniforms
	add	esp, 4

; 1685 : 
; 1686 : 	// studio shadowing
; 1687 : 	glsl.studioDepthFill[0] = shader = GL_InitGPUShader( "StudioDepth", "StudioDepth", "generic" );

	push	0
	push	OFFSET FLAT:??_C@_07LFGH@generic?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0M@JMKO@StudioDepth?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0M@JMKO@StudioDepth?$AA@ ; `string'
	call	?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z ; GL_InitGPUShader
	add	esp, 16					; 00000010H
	mov	DWORD PTR _shader$[ebp], eax
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR ?glsl@@3Uref_shaders_t@@A+28, edx

; 1688 : 	GL_InitStudioDepthFillUniforms( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_InitStudioDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitStudioDepthFillUniforms
	add	esp, 4

; 1689 : 
; 1690 : 	glsl.studioDepthFill[1] = shader = GL_InitGPUShader( "StudioDepth", "StudioDepth", "generic", "#define STUDIO_BONEWEIGHTING\n"  );

	push	OFFSET FLAT:??_C@_0BO@GCPH@?$CDdefine?5STUDIO_BONEWEIGHTING?6?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_07LFGH@generic?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0M@JMKO@StudioDepth?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0M@JMKO@StudioDepth?$AA@ ; `string'
	call	?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z ; GL_InitGPUShader
	add	esp, 16					; 00000010H
	mov	DWORD PTR _shader$[ebp], eax
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR ?glsl@@3Uref_shaders_t@@A+32, ecx

; 1691 : 	GL_InitStudioDepthFillUniforms( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_InitStudioDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitStudioDepthFillUniforms
	add	esp, 4

; 1692 : 
; 1693 : 	// bmodel shadowing
; 1694 : 	glsl.bmodelDepthFill = shader = GL_InitGPUShader( "BrushDepth", "BmodelDepth", "generic" );

	push	0
	push	OFFSET FLAT:??_C@_07LFGH@generic?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0M@BBGB@BmodelDepth?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@CBFB@BrushDepth?$AA@ ; `string'
	call	?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z ; GL_InitGPUShader
	add	esp, 16					; 00000010H
	mov	DWORD PTR _shader$[ebp], eax
	mov	eax, DWORD PTR _shader$[ebp]
	mov	DWORD PTR ?glsl@@3Uref_shaders_t@@A+24, eax

; 1695 : 	GL_InitBmodelDepthFillUniforms( shader );

	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_InitBmodelDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitBmodelDepthFillUniforms
	add	esp, 4

; 1696 : 
; 1697 : 	// grass shadowing
; 1698 : 	glsl.grassDepthFill = shader = GL_InitGPUShader( "GrassDepth", "GrassDepth", "generic" );

	push	0
	push	OFFSET FLAT:??_C@_07LFGH@generic?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@HKCK@GrassDepth?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@HKCK@GrassDepth?$AA@ ; `string'
	call	?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z ; GL_InitGPUShader
	add	esp, 16					; 00000010H
	mov	DWORD PTR _shader$[ebp], eax
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR ?glsl@@3Uref_shaders_t@@A+36, edx

; 1699 : 	GL_InitGrassSolidUniforms( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_InitGrassSolidUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitGrassSolidUniforms
	add	esp, 4

; 1700 : 
; 1701 : 	// fog processing
; 1702 : 	glsl.genericFog = shader = GL_InitGPUShader( "GenericFog", "generic", "generic", "#define GENERIC_FOG_EXP\n" );

	push	OFFSET FLAT:??_C@_0BJ@GABA@?$CDdefine?5GENERIC_FOG_EXP?6?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_07LFGH@generic?$AA@	; `string'
	push	OFFSET FLAT:??_C@_07LFGH@generic?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@KDCB@GenericFog?$AA@ ; `string'
	call	?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z ; GL_InitGPUShader
	add	esp, 16					; 00000010H
	mov	DWORD PTR _shader$[ebp], eax
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR ?glsl@@3Uref_shaders_t@@A+20, ecx

; 1703 : 	GL_InitGenericFogUniforms( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_InitGenericFogUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_InitGenericFogUniforms
	add	esp, 4

; 1704 : 
; 1705 : 	// HACKHACK: precache generic light shaders
; 1706 : 	GL_UberShaderForDlightGeneric( &pl );

	lea	eax, DWORD PTR _pl$[ebp]
	push	eax
	call	?GL_UberShaderForDlightGeneric@@YAGPBUplight_s@@@Z ; GL_UberShaderForDlightGeneric
	add	esp, 4

; 1707 : 	SetBits( pl.flags, CF_NOSHADOWS );

	mov	ecx, DWORD PTR _pl$[ebp+428]
	or	ch, 4
	mov	DWORD PTR _pl$[ebp+428], ecx

; 1708 : 	GL_UberShaderForDlightGeneric( &pl );

	lea	edx, DWORD PTR _pl$[ebp]
	push	edx
	call	?GL_UberShaderForDlightGeneric@@YAGPBUplight_s@@@Z ; GL_UberShaderForDlightGeneric
	add	esp, 4

; 1709 : 	pl.pointlight = true;

	mov	BYTE PTR _pl$[ebp+44], 1

; 1710 : 	GL_UberShaderForDlightGeneric( &pl );

	lea	eax, DWORD PTR _pl$[ebp]
	push	eax
	call	?GL_UberShaderForDlightGeneric@@YAGPBUplight_s@@@Z ; GL_UberShaderForDlightGeneric
	add	esp, 4
$L72251:

; 1711 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitGPUShaders@@YAXXZ ENDP				; GL_InitGPUShaders
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z@4FA@30a12103 ; `GL_InitGPUShader'::`2'::__LINE__Var
PUBLIC	??_C@_0DI@DBCF@GL_InitGPUShader?3?5GLSL?5shaders?5l@ ; `string'
;	COMDAT ?__LINE__Var@?1??GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z@4FA@30a12103 DW 01bfH ; `GL_InitGPUShader'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DI@DBCF@GL_InitGPUShader?3?5GLSL?5shaders?5l@
CONST	SEGMENT
??_C@_0DI@DBCF@GL_InitGPUShader?3?5GLSL?5shaders?5l@ DB 'GL_InitGPUShader'
	DB	': GLSL shaders limit exceeded (%i max)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z
_TEXT	SEGMENT
_glname$ = 8
_vpname$ = 12
_fpname$ = 16
_defines$ = 20
_find$ = -4
_i$ = -8
_hash$ = -12
_prog$ = -16
_shader$ = -20
?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z PROC NEAR	; GL_InitGPUShader, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 448  : 	const char	*find;
; 449  : 	unsigned int	i, hash;
; 450  : 	glsl_program_t	*prog;
; 451  : 
; 452  : 	if( !GL_Support( R_SHADER_GLSL100_EXT ))

	push	8
	call	?GL_Support@@YA_NH@Z			; GL_Support
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L71737

; 453  : 		return NULL;

	xor	eax, eax
	jmp	$L71732
$L71737:

; 454  : 
; 455  : 	ASSERT( glname != NULL );

	cmp	DWORD PTR _glname$[ebp], 0
	jne	SHORT $L71739
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z@4FA@30a12103 ; `GL_InitGPUShader'::`2'::__LINE__Var
	add	eax, 8
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71739:

; 456  : 
; 457  : 	find = va( "%s %s", glname, defines );

	mov	ecx, DWORD PTR _defines$[ebp]
	push	ecx
	mov	edx, DWORD PTR _glname$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_05JKGE@?$CFs?5?$CFs?$AA@ ; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _find$[ebp], eax

; 458  : 	hash = COM_HashKey( find, SHADERS_HASH_SIZE );

	push	128					; 00000080H
	mov	eax, DWORD PTR _find$[ebp]
	push	eax
	call	?COM_HashKey@@YAIPBDI@Z			; COM_HashKey
	add	esp, 8
	mov	DWORD PTR _hash$[ebp], eax

; 459  : 
; 460  : 	// check for coexist
; 461  : 	for( prog = glsl_programsHashTable[hash]; prog != NULL; prog = prog->nextHash )

	mov	ecx, DWORD PTR _hash$[ebp]
	mov	edx, DWORD PTR ?glsl_programsHashTable@@3PAPAUglsl_prog_s@@A[ecx*4]
	mov	DWORD PTR _prog$[ebp], edx
	jmp	SHORT $L71741
$L71742:
	mov	eax, DWORD PTR _prog$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	mov	DWORD PTR _prog$[ebp], ecx
$L71741:
	cmp	DWORD PTR _prog$[ebp], 0
	je	SHORT $L71743

; 463  : 		if( !Q_strcmp( prog->name, glname ) && !Q_strcmp( prog->options, defines ))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _glname$[ebp]
	push	edx
	mov	eax, DWORD PTR _prog$[ebp]
	push	eax
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L71744
	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _defines$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prog$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L71744

; 464  : 			return prog;

	mov	eax, DWORD PTR _prog$[ebp]
	jmp	$L71732
$L71744:

; 465  : 	}

	jmp	SHORT $L71742
$L71743:

; 466  : 
; 467  : 	// find free spot
; 468  : 	for( i = 1; i < num_glsl_programs; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L71745
$L71746:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L71745:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?num_glsl_programs@@3IA	; num_glsl_programs
	jae	SHORT $L71747

; 469  : 		if( !glsl_programs[i].name[0] )

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 876				; 0000036cH
	movsx	eax, BYTE PTR ?glsl_programs@@3PAUglsl_prog_s@@A[edx]
	test	eax, eax
	jne	SHORT $L71748

; 470  : 			break;

	jmp	SHORT $L71747
$L71748:

; 471  : 
; 472  : 	if( num_glsl_programs >= MAX_GLSL_PROGRAMS )

	jmp	SHORT $L71746
$L71747:
	cmp	DWORD PTR ?num_glsl_programs@@3IA, 512	; num_glsl_programs, 00000200H
	jb	SHORT $L71749

; 474  : 		ALERT( at_error, "GL_InitGPUShader: GLSL shaders limit exceeded (%i max)\n", MAX_GLSL_PROGRAMS );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_0DI@DBCF@GL_InitGPUShader?3?5GLSL?5shaders?5l@ ; `string'
	push	4
	call	?ALERT@@YAXW4ALERT_TYPE@@PADZZ		; ALERT
	add	esp, 12					; 0000000cH

; 475  : 		return NULL;

	xor	eax, eax
	jmp	$L71732
$L71749:

; 477  : 
; 478  : 	// alloc new shader
; 479  : 	glsl_program_t *shader = &glsl_programs[i];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 876				; 0000036cH
	add	ecx, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	mov	DWORD PTR _shader$[ebp], ecx

; 480  : 	num_glsl_programs++;

	mov	edx, DWORD PTR ?num_glsl_programs@@3IA	; num_glsl_programs
	add	edx, 1
	mov	DWORD PTR ?num_glsl_programs@@3IA, edx	; num_glsl_programs

; 481  : 
; 482  : 	Q_strncpy( shader->name, glname, sizeof( shader->name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _glname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 483  : 	Q_strncpy( shader->options, defines, sizeof( shader->options ));

	push	512					; 00000200H
	mov	edx, DWORD PTR _defines$[ebp]
	push	edx
	mov	eax, DWORD PTR _shader$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 484  : 	shader->handle = pglCreateProgramObjectARB();

	call	DWORD PTR ?pglCreateProgramObjectARB@@3P6GIXZA ; pglCreateProgramObjectARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+576], eax

; 485  : 
; 486  : 	if( vpname ) GL_LoadGPUShader( shader, vpname, GL_VERTEX_SHADER_ARB, false, defines );

	cmp	DWORD PTR _vpname$[ebp], 0
	je	SHORT $L71752
	mov	edx, DWORD PTR _defines$[ebp]
	push	edx
	push	0
	push	35633					; 00008b31H
	mov	eax, DWORD PTR _vpname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z ; GL_LoadGPUShader
	add	esp, 20					; 00000014H

; 487  : 	else shader->status |= SHADER_VERTEX_COMPILED;

	jmp	SHORT $L71753
$L71752:
	mov	edx, DWORD PTR _shader$[ebp]
	mov	ax, WORD PTR [edx+580]
	or	al, 1
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	WORD PTR [ecx+580], ax
$L71753:

; 488  : 	if( fpname ) GL_LoadGPUShader( shader, fpname, GL_FRAGMENT_SHADER_ARB, false, defines );

	cmp	DWORD PTR _fpname$[ebp], 0
	je	SHORT $L71754
	mov	edx, DWORD PTR _defines$[ebp]
	push	edx
	push	0
	push	35632					; 00008b30H
	mov	eax, DWORD PTR _fpname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_LoadGPUShader@@YAXPAUglsl_prog_s@@PBDI_N1@Z ; GL_LoadGPUShader
	add	esp, 20					; 00000014H

; 489  : 	else shader->status |= SHADER_FRAGMENT_COMPILED;

	jmp	SHORT $L71755
$L71754:
	mov	edx, DWORD PTR _shader$[ebp]
	mov	ax, WORD PTR [edx+580]
	or	al, 2
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	WORD PTR [ecx+580], ax
$L71755:

; 490  : 
; 491  : 	if( vpname && FBitSet( shader->status, SHADER_VERTEX_COMPILED ))

	cmp	DWORD PTR _vpname$[ebp], 0
	je	$L71756
	mov	edx, DWORD PTR _shader$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+580]
	and	eax, 1
	test	eax, eax
	je	$L71756

; 493  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_POSITION, "attr_Position" );

	push	OFFSET FLAT:??_C@_0O@GCHP@attr_Position?$AA@ ; `string'
	push	0
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 494  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_TEXCOORD0, "attr_TexCoord0" );

	push	OFFSET FLAT:??_C@_0P@FMMD@attr_TexCoord0?$AA@ ; `string'
	push	2
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 495  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_TEXCOORD1, "attr_TexCoord1" );

	push	OFFSET FLAT:??_C@_0P@PGFE@attr_TexCoord1?$AA@ ; `string'
	push	3
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 496  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_TEXCOORD2, "attr_TexCoord2" );

	push	OFFSET FLAT:??_C@_0P@JON@attr_TexCoord2?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 497  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_NORMAL, "attr_Normal" );

	push	OFFSET FLAT:??_C@_0M@NANC@attr_Normal?$AA@ ; `string'
	push	1
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 498  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_BONE_INDEXES, "attr_BoneIndexes" );

	push	OFFSET FLAT:??_C@_0BB@HOGI@attr_BoneIndexes?$AA@ ; `string'
	push	5
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 499  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_BONE_WEIGHTS, "attr_BoneWeights" );

	push	OFFSET FLAT:??_C@_0BB@CBFE@attr_BoneWeights?$AA@ ; `string'
	push	6
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 500  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_LIGHT_STYLES, "attr_LightStyles" );

	push	OFFSET FLAT:??_C@_0BB@FGGJ@attr_LightStyles?$AA@ ; `string'
	push	7
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	push	ecx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 501  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_LIGHT_COLOR, "attr_LightColor" );

	push	OFFSET FLAT:??_C@_0BA@GOGD@attr_LightColor?$AA@ ; `string'
	push	8
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB

; 502  : 		pglBindAttribLocationARB( shader->handle, ATTR_INDEX_LIGHT_VECS, "attr_LightVecs" );

	push	OFFSET FLAT:??_C@_0P@EPKC@attr_LightVecs?$AA@ ; `string'
	push	9
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglBindAttribLocationARB@@3P6GXIIPBD@ZA ; pglBindAttribLocationARB
$L71756:

; 504  : 
; 505  : 	GL_LinkProgram( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_LinkProgram@@YAXPAUglsl_prog_s@@@Z	; GL_LinkProgram
	add	esp, 4

; 506  : 
; 507  : 	if( shader != NULL )

	cmp	DWORD PTR _shader$[ebp], 0
	je	SHORT $L71767

; 509  : 		// add to hash table
; 510  : 		shader->nextHash = glsl_programsHashTable[hash];

	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR _hash$[ebp]
	mov	eax, DWORD PTR ?glsl_programsHashTable@@3PAPAUglsl_prog_s@@A[edx*4]
	mov	DWORD PTR [ecx+584], eax

; 511  : 		glsl_programsHashTable[hash] = shader;

	mov	ecx, DWORD PTR _hash$[ebp]
	mov	edx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR ?glsl_programsHashTable@@3PAPAUglsl_prog_s@@A[ecx*4], edx
$L71767:

; 513  : 
; 514  : 	return shader;

	mov	eax, DWORD PTR _shader$[ebp]
$L71732:

; 515  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitGPUShader@@YAPAUglsl_prog_s@@PBD000@Z ENDP	; GL_InitGPUShader
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitBmodelDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitBmodelDepthFillUniforms'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??GL_InitBmodelDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitBmodelDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 02eaH ; `GL_InitBmodelDepthFillUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?GL_InitBmodelDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitBmodelDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitBmodelDepthFillUniforms, COMDAT

; 746  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 747  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71872
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitBmodelDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitBmodelDepthFillUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71872:

; 748  : 
; 749  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 750  : 	shader->u_TexOffset = pglGetUniformLocationARB( shader->handle, "u_TexOffset" );

	push	OFFSET FLAT:??_C@_0M@OCHJ@u_TexOffset?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+836], eax

; 751  : 	shader->u_ModelMatrix = pglGetUniformLocationARB( shader->handle, "u_ModelMatrix" );

	push	OFFSET FLAT:??_C@_0O@NMNP@u_ModelMatrix?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+668], eax

; 752  : 
; 753  : 	GL_BindShader( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 754  : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 755  : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 756  : 
; 757  : 	GL_ValidateProgram( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 758  : 	GL_ShowProgramUniforms( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 759  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitBmodelDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z ENDP ; GL_InitBmodelDepthFillUniforms
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitStudioDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitStudioDepthFillUniforms'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??GL_InitStudioDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitStudioDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 034fH ; `GL_InitStudioDepthFillUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?GL_InitStudioDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitStudioDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitStudioDepthFillUniforms, COMDAT

; 847  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 848  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71905
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitStudioDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitStudioDepthFillUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71905:

; 849  : 
; 850  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 851  : 
; 852  : 	shader->u_BoneQuaternion = pglGetUniformLocationARB( shader->handle, "u_BoneQuaternion" );

	push	OFFSET FLAT:??_C@_0BB@DNPD@u_BoneQuaternion?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+652], eax

; 853  : 	shader->u_BonePosition = pglGetUniformLocationARB( shader->handle, "u_BonePosition" );

	push	OFFSET FLAT:??_C@_0P@IFJG@u_BonePosition?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+656], eax

; 854  : 
; 855  : 	GL_BindShader( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 856  : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 857  : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 858  : 
; 859  : 	GL_ValidateProgram( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 860  : 	GL_ShowProgramUniforms( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 861  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitStudioDepthFillUniforms@@YAXPAUglsl_prog_s@@@Z ENDP ; GL_InitStudioDepthFillUniforms
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitSkyBoxUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitSkyBoxUniforms'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??GL_InitSkyBoxUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitSkyBoxUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 03c2H ; `GL_InitSkyBoxUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?GL_InitSkyBoxUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitSkyBoxUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR	; GL_InitSkyBoxUniforms, COMDAT

; 962  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 963  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71935
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitSkyBoxUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitSkyBoxUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71935:

; 964  : 
; 965  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 966  : 
; 967  : 	shader->u_LightDir = pglGetUniformLocationARB( shader->handle, "u_LightDir" );

	push	OFFSET FLAT:??_C@_0L@PEBL@u_LightDir?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+724], eax

; 968  : 	shader->u_LightDiffuse = pglGetUniformLocationARB( shader->handle, "u_LightDiffuse" );

	push	OFFSET FLAT:??_C@_0P@FEGO@u_LightDiffuse?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+740], eax

; 969  : 	shader->u_ViewOrigin = pglGetUniformLocationARB( shader->handle, "u_ViewOrigin" );

	push	OFFSET FLAT:??_C@_0N@HFAH@u_ViewOrigin?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+780], eax

; 970  : 	shader->u_FogParams = pglGetUniformLocationARB( shader->handle, "u_FogParams" );

	push	OFFSET FLAT:??_C@_0M@BNFL@u_FogParams?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+768], eax

; 971  : 
; 972  : 	GL_BindShader( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 973  : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 974  : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 975  : 
; 976  : 	GL_ValidateProgram( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 977  : 	GL_ShowProgramUniforms( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 978  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitSkyBoxUniforms@@YAXPAUglsl_prog_s@@@Z ENDP	; GL_InitSkyBoxUniforms
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitPostProcessUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitPostProcessUniforms'::`2'::__LINE__Var
PUBLIC	??_C@_0N@CGPN@u_BlurFactor?$AA@			; `string'
;	COMDAT ?__LINE__Var@?1??GL_InitPostProcessUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitPostProcessUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 03d5H ; `GL_InitPostProcessUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@CGPN@u_BlurFactor?$AA@
CONST	SEGMENT
??_C@_0N@CGPN@u_BlurFactor?$AA@ DB 'u_BlurFactor', 00H	; `string'
CONST	ENDS
;	COMDAT ?GL_InitPostProcessUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitPostProcessUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitPostProcessUniforms, COMDAT

; 981  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 982  : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71940
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitPostProcessUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitPostProcessUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71940:

; 983  : 
; 984  : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 985  : 	shader->u_BlurFactor = pglGetUniformLocationARB( shader->handle, "u_BlurFactor" );

	push	OFFSET FLAT:??_C@_0N@CGPN@u_BlurFactor?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+692], eax

; 986  : 
; 987  : 	GL_BindShader( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 988  : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 989  : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 990  : 
; 991  : 	GL_ValidateProgram( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 992  : 	GL_ShowProgramUniforms( shader );

	mov	eax, DWORD PTR _shader$[ebp]
	push	eax
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 993  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitPostProcessUniforms@@YAXPAUglsl_prog_s@@@Z ENDP	; GL_InitPostProcessUniforms
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitGenShaftsUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitGenShaftsUniforms'::`2'::__LINE__Var
PUBLIC	??_C@_0L@ICDM@u_DepthMap?$AA@			; `string'
;	COMDAT ?__LINE__Var@?1??GL_InitGenShaftsUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitGenShaftsUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 03f4H ; `GL_InitGenShaftsUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0L@ICDM@u_DepthMap?$AA@
CONST	SEGMENT
??_C@_0L@ICDM@u_DepthMap?$AA@ DB 'u_DepthMap', 00H	; `string'
CONST	ENDS
;	COMDAT ?GL_InitGenShaftsUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitGenShaftsUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitGenShaftsUniforms, COMDAT

; 1012 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1013 : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71951
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitGenShaftsUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitGenShaftsUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71951:

; 1014 : 
; 1015 : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 1016 : 	shader->u_DepthMap = pglGetUniformLocationARB( shader->handle, "u_DepthMap" );

	push	OFFSET FLAT:??_C@_0L@ICDM@u_DepthMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+592], eax

; 1017 : 
; 1018 : 	shader->u_ScreenSizeInv = pglGetUniformLocationARB( shader->handle, "u_ScreenSizeInv" );

	push	OFFSET FLAT:??_C@_0BA@PLKN@u_ScreenSizeInv?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+704], eax

; 1019 : 	shader->u_zFar = pglGetUniformLocationARB( shader->handle, "u_zFar" );

	push	OFFSET FLAT:??_C@_06OPNC@u_zFar?$AA@	; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+708], eax

; 1020 : 
; 1021 : 	GL_BindShader( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 1022 : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 1023 : 	pglUniform1iARB( shader->u_DepthMap, GL_TEXTURE1 );

	push	1
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+592]
	push	eax
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 1024 : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 1025 : 
; 1026 : 	GL_ValidateProgram( shader );

	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 1027 : 	GL_ShowProgramUniforms( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 1028 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitGenShaftsUniforms@@YAXPAUglsl_prog_s@@@Z ENDP	; GL_InitGenShaftsUniforms
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GL_InitDrawShaftsUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitDrawShaftsUniforms'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??GL_InitDrawShaftsUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103
; File z:\xashxtsrc\client\render\r_shader.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GL_InitDrawShaftsUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 DW 0407H ; `GL_InitDrawShaftsUniforms'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?GL_InitDrawShaftsUniforms@@YAXPAUglsl_prog_s@@@Z
_TEXT	SEGMENT
_shader$ = 8
?GL_InitDrawShaftsUniforms@@YAXPAUglsl_prog_s@@@Z PROC NEAR ; GL_InitDrawShaftsUniforms, COMDAT

; 1031 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1032 : 	ASSERT( shader != NULL );

	cmp	DWORD PTR _shader$[ebp], 0
	jne	SHORT $L71957
	movsx	eax, WORD PTR ?__LINE__Var@?1??GL_InitDrawShaftsUniforms@@YAXPAUglsl_prog_s@@@Z@4FA@30a12103 ; `GL_InitDrawShaftsUniforms'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CI@HOGM@z?3?2xashxtsrc?2client?2render?2r_sha@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MFPO@assert?5failed?5at?5?$CFs?3?$CFi?6?$AA@ ; `string'
	call	DWORD PTR ?gRenderfuncs@@3Urender_api_s@@A+236
	add	esp, 12					; 0000000cH
$L71957:

; 1033 : 
; 1034 : 	shader->u_ColorMap = pglGetUniformLocationARB( shader->handle, "u_ColorMap" );

	push	OFFSET FLAT:??_C@_0L@CEPF@u_ColorMap?$AA@ ; `string'
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 1035 : 	shader->u_DepthMap = pglGetUniformLocationARB( shader->handle, "u_DepthMap" );

	push	OFFSET FLAT:??_C@_0L@ICDM@u_DepthMap?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+592], eax

; 1036 : 
; 1037 : 	shader->u_LightOrigin = pglGetUniformLocationARB( shader->handle, "u_LightOrigin" );

	push	OFFSET FLAT:??_C@_0O@IPOH@u_LightOrigin?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+772], eax

; 1038 : 	shader->u_LightDiffuse = pglGetUniformLocationARB( shader->handle, "u_LightDiffuse" );

	push	OFFSET FLAT:??_C@_0P@FEGO@u_LightDiffuse?$AA@ ; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+740], eax

; 1039 : 	shader->u_zFar = pglGetUniformLocationARB( shader->handle, "u_zFar" );

	push	OFFSET FLAT:??_C@_06OPNC@u_zFar?$AA@	; `string'
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	DWORD PTR ?pglGetUniformLocationARB@@3P6GHIPBD@ZA ; pglGetUniformLocationARB
	mov	ecx, DWORD PTR _shader$[ebp]
	mov	DWORD PTR [ecx+708], eax

; 1040 : 
; 1041 : 	GL_BindShader( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 1042 : 	pglUniform1iARB( shader->u_ColorMap, GL_TEXTURE0 );

	push	0
	mov	eax, DWORD PTR _shader$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 1043 : 	pglUniform1iARB( shader->u_DepthMap, GL_TEXTURE1 );

	push	1
	mov	edx, DWORD PTR _shader$[ebp]
	mov	eax, DWORD PTR [edx+592]
	push	eax
	call	DWORD PTR ?pglUniform1iARB@@3P6GXHH@ZA	; pglUniform1iARB

; 1044 : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4

; 1045 : 
; 1046 : 	GL_ValidateProgram( shader );

	mov	ecx, DWORD PTR _shader$[ebp]
	push	ecx
	call	?GL_ValidateProgram@@YAXPAUglsl_prog_s@@@Z ; GL_ValidateProgram
	add	esp, 4

; 1047 : 	GL_ShowProgramUniforms( shader );

	mov	edx, DWORD PTR _shader$[ebp]
	push	edx
	call	?GL_ShowProgramUniforms@@YAXPAUglsl_prog_s@@@Z ; GL_ShowProgramUniforms
	add	esp, 4

; 1048 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_InitDrawShaftsUniforms@@YAXPAUglsl_prog_s@@@Z ENDP	; GL_InitDrawShaftsUniforms
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0CFrustum@@QAE@XZ				; CFrustum::CFrustum
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
;	COMDAT ??0plight_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0plight_s@@QAE@XZ PROC NEAR				; plight_s::plight_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 240				; 000000f0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 252				; 000000fcH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 264				; 00000108H
	call	??0CFrustum@@QAE@XZ			; CFrustum::CFrustum
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0plight_s@@QAE@XZ ENDP				; plight_s::plight_s
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
PUBLIC	??0mplane_s@@QAE@XZ				; mplane_s::mplane_s
;	COMDAT ??0CFrustum@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFrustum@@QAE@XZ PROC NEAR				; CFrustum::CFrustum, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0mplane_s@@QAE@XZ		; mplane_s::mplane_s
	push	6
	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFrustum@@QAE@XZ ENDP				; CFrustum::CFrustum
_TEXT	ENDS
;	COMDAT ??0mplane_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0mplane_s@@QAE@XZ PROC NEAR				; mplane_s::mplane_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0mplane_s@@QAE@XZ ENDP				; mplane_s::mplane_s
_TEXT	ENDS
PUBLIC	?GL_FreeUberShaders@@YAXXZ			; GL_FreeUberShaders
;	COMDAT ?GL_FreeUberShaders@@YAXXZ
_TEXT	SEGMENT
_i$ = -4
?GL_FreeUberShaders@@YAXXZ PROC NEAR			; GL_FreeUberShaders, COMDAT

; 1714 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1715 : 	if( !GL_Support( R_SHADER_GLSL100_EXT ))

	push	8
	call	?GL_Support@@YA_NH@Z			; GL_Support
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L72285

; 1716 : 		return;

	jmp	SHORT $L72284
$L72285:

; 1717 : 
; 1718 : 	for( unsigned int i = 1; i < num_glsl_programs; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L72287
$L72288:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L72287:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?num_glsl_programs@@3IA	; num_glsl_programs
	jae	SHORT $L72289

; 1720 : 		if( FBitSet( glsl_programs[i].status, SHADER_UBERSHADER )) 

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 876				; 0000036cH
	xor	eax, eax
	mov	ax, WORD PTR ?glsl_programs@@3PAUglsl_prog_s@@A[edx+580]
	and	eax, 8
	test	eax, eax
	je	SHORT $L72290

; 1721 : 			GL_FreeGPUShader( &glsl_programs[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 876				; 0000036cH
	add	ecx, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	push	ecx
	call	?GL_FreeGPUShader@@YAXPAUglsl_prog_s@@@Z ; GL_FreeGPUShader
	add	esp, 4
$L72290:

; 1722 : 	}

	jmp	SHORT $L72288
$L72289:

; 1723 : 
; 1724 : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4
$L72284:

; 1725 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_FreeUberShaders@@YAXXZ ENDP				; GL_FreeUberShaders
_TEXT	ENDS
PUBLIC	?GL_FreeGPUShaders@@YAXXZ			; GL_FreeGPUShaders
;	COMDAT ?GL_FreeGPUShaders@@YAXXZ
_TEXT	SEGMENT
_i$ = -4
?GL_FreeGPUShaders@@YAXXZ PROC NEAR			; GL_FreeGPUShaders, COMDAT

; 1728 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1729 : 	if( !GL_Support( R_SHADER_GLSL100_EXT ))

	push	8
	call	?GL_Support@@YA_NH@Z			; GL_Support
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L72294

; 1730 : 		return;

	jmp	SHORT $L72293
$L72294:

; 1731 : 
; 1732 : 	for( unsigned int i = 1; i < num_glsl_programs; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L72296
$L72297:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L72296:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?num_glsl_programs@@3IA	; num_glsl_programs
	jae	SHORT $L72298

; 1733 : 		GL_FreeGPUShader( &glsl_programs[i] );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 876				; 0000036cH
	add	edx, OFFSET FLAT:?glsl_programs@@3PAUglsl_prog_s@@A ; glsl_programs
	push	edx
	call	?GL_FreeGPUShader@@YAXPAUglsl_prog_s@@@Z ; GL_FreeGPUShader
	add	esp, 4
	jmp	SHORT $L72297
$L72298:

; 1734 : 
; 1735 : 	GL_BindShader( GL_NONE );

	push	0
	call	?GL_BindShader@@YAXPAUglsl_prog_s@@@Z	; GL_BindShader
	add	esp, 4
$L72293:

; 1736 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GL_FreeGPUShaders@@YAXXZ ENDP				; GL_FreeGPUShaders
_TEXT	ENDS
END
