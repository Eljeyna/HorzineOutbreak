	TITLE	Z:\XashXTSRC\client\render\r_view.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0N@BADI@v_iyaw_cycle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KOLO@2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@NCGN@v_iroll_cycle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03IPBN@0?45?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@IHFO@v_ipitch_cycle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FBAH@1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@PNOG@v_iyaw_level?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HAGP@0?43?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@DPLD@v_iroll_level?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CFEB@0?41?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@GKIA@v_ipitch_level?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04JDHO@0?415?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@KEFH@v_centermove?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03DNJI@500?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@GJCG@v_centerspeed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03NLGO@0?48?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@NDIF@cl_bobcycle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04CPII@0?401?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FFIM@cl_bob?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08BPEI@cl_bobup?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FBMM@4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@JGKA@cl_waterdist?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03DGEG@112?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@IKKM@cl_chasedist?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BKCD@cl_weaponlag?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@NCIF@gl_allow_extensions?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09IEFK@gl_finish?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CLGN@gl_clear?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MNKK@r_speeds?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07MKFJ@gl_test?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08NKJJ@viewsize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07CBKH@r_novis?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08HJPD@r_nocull?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09ILGG@gl_nosort?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BIML@r_lockpvs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LGEB@r_dynamic?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DOIK@r_lightmap?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@LEFO@gl_wireframe?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@MPPJ@r_adjust_fov?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@JLA@gl_check_errors?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05CAAD@gamma?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HCKI@brightness?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@GOOL@gl_polyoffset?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@MMGG@r_fullbright?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@LECL@r_drawentities?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@JPMN@r_detailtextures?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@NIBJ@r_lighting_modulate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@ICLI@cl_lightstyle_lerping?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GHPE@r_lighting_extended?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04IFNE@0?405?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@IMI@cl_vsmoothing?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@IDJM@gl_allow_portals?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@BONP@gl_allow_screens?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@IPEA@gl_renderer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09CNME@r_shadows?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MHOB@gl_allow_3dsky?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@PMEE@gl_allow_mirrors?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@PHDP@gl_recursion_depth?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@KFIC@gl_recursive_world_node?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07CCKA@r_grass?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MOOI@r_grass_alpha?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GONJ@r_grass_lighting?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LANA@r_grass_shadows?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04JMAB@2048?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@CFNH@r_grass_fade_start?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@GHFP@r_grass_fade_dist?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@JNAI@r_show_renderpass?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@PEIH@r_show_light_scissors?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@IJFN@r_show_normals?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCJJ@r_show_lightprobes?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@PBHN@thirdperson?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@NCDD@firstperson?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EKJH@centerview?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09IHBH@BLEND?5?$CFf?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CPJ@CLAMPED?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@FNNP@STILL?5LOCKED?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@LPHC@vehicle_driver_eyes?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PECN@incar?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@QAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@Vector@@QAEXMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ZVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyToArray@Vector@@QBEXPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAEXAAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Transpose@matrix3x4@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapValClamped@@YAMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Random@RandomRange@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudBase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CHudBase@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VidInit@CHudBase@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@CHudBase@@UAEHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CHudBase@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@CHudBase@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitHUDData@CHudBase@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudBase@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudAmmo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudAmmo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudHealth@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudHealth@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudGeiger@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudGeiger@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudBattery@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudBattery@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudTrain@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudTrain@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudFlashlight@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudFlashlight@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudMessage@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudMessage@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudScoreboard@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudScoreboard@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudStatusBar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudStatusBar@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudDeathNotice@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudDeathNotice@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudSayText@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudSayText@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudMenu@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudMenu@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudAmmoSecondary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudAmmoSecondary@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudTextMessage@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudTextMessage@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudStatusIcons@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudStatusIcons@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudMOTD@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CHudMOTD@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ViewSmoothingData_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudAmmo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudBase@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudHealth@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudGeiger@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudBattery@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudTrain@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudFlashlight@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudMessage@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudScoreboard@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudStatusBar@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudDeathNotice@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudSayText@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudMenu@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudAmmoSecondary@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudTextMessage@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudStatusIcons@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCHudMOTD@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pHitboxSet@CStudioBoneSetup@@QBEPAUmstudiohitboxset_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitBoneWeights@CStudioBoneSetup@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?debugMsg@CStudioBoneSetup@@UAAXPADZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?debugLine@CStudioBoneSetup@@UAEXABVVector@@0HHH_NM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?R_StudioAttachmentTransform@@YAXPBUcl_entity_s@@HPAVVector@@1H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?R_StudioAttachmentAngles@@YA?AVVector@@PBUcl_entity_s@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?R_StudioLookupAttachment@@YAHPBUcl_entity_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?R_StudioSequenceDuration@@YAMPBUcl_entity_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CAM_Think@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CL_CameraOffset@@YAXPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CL_IsThirdPerson@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_ThirdPerson@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_FirstPerson@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_Init@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_CalcBob@@YAMPAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_StartPitchDrift@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_StopPitchDrift@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_DriftPitch@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_CalcGunAngle@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_AddIdle@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_CalcViewRoll@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_CalcSendOrigin@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_GetChaseOrigin@@YAXABVVector@@0MAAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapAngleRange@@YAMMMMPAW4RemapAngleRange_CurvePart_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ApplyViewLocking@@YAMPAUref_params_s@@MMAAUViewLockData_t@@W4RemapAngleRange_CurvePart_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapViewAngles@@YAXPAUref_params_s@@PAUViewSmoothingData_t@@AAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcVehicleRefdef@@YAXPAUref_params_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_ResetCarSmoothData@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_FindIntermisionSpot@@YAPAUcl_entity_s@@PAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_CalcIntermisionRefdef@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_CalcWaterLevel@@YAMPAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_InterpolatePos@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E15
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E14
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0viewinterp_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?V_CalcRefdef@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlLinkedList@UJiggleData@@G@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlLinkedList@UJiggleData@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlLinkedList@UJiggleData@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlLinkedList@UModelInstance_t@CStudioModelRenderer@@G@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lerp@@YAMMABM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lerp@@YA?AVVector@@MABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructList@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUJiggleData@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CHudBase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CStudioBoneSetup@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudSayText@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudFlashlight@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudGeiger@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudDeathNotice@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudBattery@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudTrain@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudMenu@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudTextMessage@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudAmmo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudHealth@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudStatusIcons@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudAmmoSecondary@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudStatusBar@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudMessage@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudMOTD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudScoreboard@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?pause@@3HA					; pause
PUBLIC	?v_idlescale@@3MA				; v_idlescale
PUBLIC	?v_intermission_spot@@3PAUcl_entity_s@@A	; v_intermission_spot
PUBLIC	?gl_renderer@@3PAUcvar_s@@A			; gl_renderer
PUBLIC	?r_test@@3PAUcvar_s@@A				; r_test
PUBLIC	?r_extensions@@3PAUcvar_s@@A			; r_extensions
PUBLIC	?r_shadows@@3PAUcvar_s@@A			; r_shadows
PUBLIC	?r_finish@@3PAUcvar_s@@A			; r_finish
PUBLIC	?r_clear@@3PAUcvar_s@@A				; r_clear
PUBLIC	?r_speeds@@3PAUcvar_s@@A			; r_speeds
PUBLIC	?cl_viewsize@@3PAUcvar_s@@A			; cl_viewsize
PUBLIC	?r_dynamic@@3PAUcvar_s@@A			; r_dynamic
PUBLIC	?r_novis@@3PAUcvar_s@@A				; r_novis
PUBLIC	?r_nocull@@3PAUcvar_s@@A			; r_nocull
PUBLIC	?r_nosort@@3PAUcvar_s@@A			; r_nosort
PUBLIC	?r_lockpvs@@3PAUcvar_s@@A			; r_lockpvs
PUBLIC	?r_lightmap@@3PAUcvar_s@@A			; r_lightmap
PUBLIC	?r_adjust_fov@@3PAUcvar_s@@A			; r_adjust_fov
PUBLIC	?r_wireframe@@3PAUcvar_s@@A			; r_wireframe
PUBLIC	?r_fullbright@@3PAUcvar_s@@A			; r_fullbright
PUBLIC	?r_drawentities@@3PAUcvar_s@@A			; r_drawentities
PUBLIC	?r_allow_3dsky@@3PAUcvar_s@@A			; r_allow_3dsky
PUBLIC	?r_allow_mirrors@@3PAUcvar_s@@A			; r_allow_mirrors
PUBLIC	?r_allow_portals@@3PAUcvar_s@@A			; r_allow_portals
PUBLIC	?r_allow_screens@@3PAUcvar_s@@A			; r_allow_screens
PUBLIC	?r_recursion_depth@@3PAUcvar_s@@A		; r_recursion_depth
PUBLIC	?r_detailtextures@@3PAUcvar_s@@A		; r_detailtextures
PUBLIC	?r_lighting_modulate@@3PAUcvar_s@@A		; r_lighting_modulate
PUBLIC	?r_lightstyle_lerping@@3PAUcvar_s@@A		; r_lightstyle_lerping
PUBLIC	?r_lighting_extended@@3PAUcvar_s@@A		; r_lighting_extended
PUBLIC	?r_recursive_world_node@@3PAUcvar_s@@A		; r_recursive_world_node
PUBLIC	?r_polyoffset@@3PAUcvar_s@@A			; r_polyoffset
PUBLIC	?r_grass@@3PAUcvar_s@@A				; r_grass
PUBLIC	?r_grass_alpha@@3PAUcvar_s@@A			; r_grass_alpha
PUBLIC	?r_grass_lighting@@3PAUcvar_s@@A		; r_grass_lighting
PUBLIC	?r_grass_shadows@@3PAUcvar_s@@A			; r_grass_shadows
PUBLIC	?r_grass_fade_start@@3PAUcvar_s@@A		; r_grass_fade_start
PUBLIC	?r_grass_fade_dist@@3PAUcvar_s@@A		; r_grass_fade_dist
PUBLIC	?gl_check_errors@@3PAUcvar_s@@A			; gl_check_errors
PUBLIC	?vid_gamma@@3PAUcvar_s@@A			; vid_gamma
PUBLIC	?vid_brightness@@3PAUcvar_s@@A			; vid_brightness
PUBLIC	?r_show_renderpass@@3PAUcvar_s@@A		; r_show_renderpass
PUBLIC	?r_show_light_scissors@@3PAUcvar_s@@A		; r_show_light_scissors
PUBLIC	?r_show_normals@@3PAUcvar_s@@A			; r_show_normals
PUBLIC	?r_show_lightprobes@@3PAUcvar_s@@A		; r_show_lightprobes
PUBLIC	?cl_bobcycle@@3PAUcvar_s@@A			; cl_bobcycle
PUBLIC	?cl_bob@@3PAUcvar_s@@A				; cl_bob
PUBLIC	?cl_bobup@@3PAUcvar_s@@A			; cl_bobup
PUBLIC	?cl_waterdist@@3PAUcvar_s@@A			; cl_waterdist
PUBLIC	?cl_chasedist@@3PAUcvar_s@@A			; cl_chasedist
PUBLIC	?cl_weaponlag@@3PAUcvar_s@@A			; cl_weaponlag
PUBLIC	?cl_vsmoothing@@3PAUcvar_s@@A			; cl_vsmoothing
PUBLIC	?v_centermove@@3PAUcvar_s@@A			; v_centermove
PUBLIC	?v_centerspeed@@3PAUcvar_s@@A			; v_centerspeed
PUBLIC	?v_iyaw_cycle@@3Ucvar_s@@A			; v_iyaw_cycle
PUBLIC	??_C@_0N@BADI@v_iyaw_cycle?$AA@			; `string'
PUBLIC	??_C@_01KOLO@2?$AA@				; `string'
PUBLIC	?v_iroll_cycle@@3Ucvar_s@@A			; v_iroll_cycle
PUBLIC	??_C@_0O@NCGN@v_iroll_cycle?$AA@		; `string'
PUBLIC	??_C@_03IPBN@0?45?$AA@				; `string'
PUBLIC	?v_ipitch_cycle@@3Ucvar_s@@A			; v_ipitch_cycle
PUBLIC	??_C@_0P@IHFO@v_ipitch_cycle?$AA@		; `string'
PUBLIC	??_C@_01FBAH@1?$AA@				; `string'
PUBLIC	?v_iyaw_level@@3Ucvar_s@@A			; v_iyaw_level
PUBLIC	??_C@_0N@PNOG@v_iyaw_level?$AA@			; `string'
PUBLIC	??_C@_03HAGP@0?43?$AA@				; `string'
PUBLIC	?v_iroll_level@@3Ucvar_s@@A			; v_iroll_level
PUBLIC	??_C@_0O@DPLD@v_iroll_level?$AA@		; `string'
PUBLIC	??_C@_03CFEB@0?41?$AA@				; `string'
PUBLIC	?v_ipitch_level@@3Ucvar_s@@A			; v_ipitch_level
PUBLIC	??_C@_0P@GKIA@v_ipitch_level?$AA@		; `string'
PUBLIC	?pd@@3U__unnamed@@A				; pd
_BSS	SEGMENT
_?oldz@?1??V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z@4MA DD 01H DUP (?)
_?oldz@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA DD 01H DUP (?)
?pause@@3HA DD	01H DUP (?)				; pause
?v_idlescale@@3MA DD 01H DUP (?)			; v_idlescale
?v_intermission_spot@@3PAUcl_entity_s@@A DD 01H DUP (?)	; v_intermission_spot
?gl_renderer@@3PAUcvar_s@@A DD 01H DUP (?)		; gl_renderer
?r_test@@3PAUcvar_s@@A DD 01H DUP (?)			; r_test
?r_extensions@@3PAUcvar_s@@A DD 01H DUP (?)		; r_extensions
?r_shadows@@3PAUcvar_s@@A DD 01H DUP (?)		; r_shadows
?r_finish@@3PAUcvar_s@@A DD 01H DUP (?)			; r_finish
?r_clear@@3PAUcvar_s@@A DD 01H DUP (?)			; r_clear
?r_speeds@@3PAUcvar_s@@A DD 01H DUP (?)			; r_speeds
?cl_viewsize@@3PAUcvar_s@@A DD 01H DUP (?)		; cl_viewsize
?r_dynamic@@3PAUcvar_s@@A DD 01H DUP (?)		; r_dynamic
?r_novis@@3PAUcvar_s@@A DD 01H DUP (?)			; r_novis
?r_nocull@@3PAUcvar_s@@A DD 01H DUP (?)			; r_nocull
?r_nosort@@3PAUcvar_s@@A DD 01H DUP (?)			; r_nosort
?r_lockpvs@@3PAUcvar_s@@A DD 01H DUP (?)		; r_lockpvs
?r_lightmap@@3PAUcvar_s@@A DD 01H DUP (?)		; r_lightmap
?r_adjust_fov@@3PAUcvar_s@@A DD 01H DUP (?)		; r_adjust_fov
?r_wireframe@@3PAUcvar_s@@A DD 01H DUP (?)		; r_wireframe
?r_fullbright@@3PAUcvar_s@@A DD 01H DUP (?)		; r_fullbright
?r_drawentities@@3PAUcvar_s@@A DD 01H DUP (?)		; r_drawentities
?r_allow_3dsky@@3PAUcvar_s@@A DD 01H DUP (?)		; r_allow_3dsky
?r_allow_mirrors@@3PAUcvar_s@@A DD 01H DUP (?)		; r_allow_mirrors
?r_allow_portals@@3PAUcvar_s@@A DD 01H DUP (?)		; r_allow_portals
?r_allow_screens@@3PAUcvar_s@@A DD 01H DUP (?)		; r_allow_screens
?r_recursion_depth@@3PAUcvar_s@@A DD 01H DUP (?)	; r_recursion_depth
?r_detailtextures@@3PAUcvar_s@@A DD 01H DUP (?)		; r_detailtextures
?r_lighting_modulate@@3PAUcvar_s@@A DD 01H DUP (?)	; r_lighting_modulate
?r_lightstyle_lerping@@3PAUcvar_s@@A DD 01H DUP (?)	; r_lightstyle_lerping
?r_lighting_extended@@3PAUcvar_s@@A DD 01H DUP (?)	; r_lighting_extended
?r_recursive_world_node@@3PAUcvar_s@@A DD 01H DUP (?)	; r_recursive_world_node
?r_polyoffset@@3PAUcvar_s@@A DD 01H DUP (?)		; r_polyoffset
?r_grass@@3PAUcvar_s@@A DD 01H DUP (?)			; r_grass
?r_grass_alpha@@3PAUcvar_s@@A DD 01H DUP (?)		; r_grass_alpha
?r_grass_lighting@@3PAUcvar_s@@A DD 01H DUP (?)		; r_grass_lighting
?r_grass_shadows@@3PAUcvar_s@@A DD 01H DUP (?)		; r_grass_shadows
?r_grass_fade_start@@3PAUcvar_s@@A DD 01H DUP (?)	; r_grass_fade_start
?r_grass_fade_dist@@3PAUcvar_s@@A DD 01H DUP (?)	; r_grass_fade_dist
?gl_check_errors@@3PAUcvar_s@@A DD 01H DUP (?)		; gl_check_errors
?vid_gamma@@3PAUcvar_s@@A DD 01H DUP (?)		; vid_gamma
?vid_brightness@@3PAUcvar_s@@A DD 01H DUP (?)		; vid_brightness
?r_show_renderpass@@3PAUcvar_s@@A DD 01H DUP (?)	; r_show_renderpass
?r_show_light_scissors@@3PAUcvar_s@@A DD 01H DUP (?)	; r_show_light_scissors
?r_show_normals@@3PAUcvar_s@@A DD 01H DUP (?)		; r_show_normals
?r_show_lightprobes@@3PAUcvar_s@@A DD 01H DUP (?)	; r_show_lightprobes
?cl_bobcycle@@3PAUcvar_s@@A DD 01H DUP (?)		; cl_bobcycle
?cl_bob@@3PAUcvar_s@@A DD 01H DUP (?)			; cl_bob
?cl_bobup@@3PAUcvar_s@@A DD 01H DUP (?)			; cl_bobup
?cl_waterdist@@3PAUcvar_s@@A DD 01H DUP (?)		; cl_waterdist
?cl_chasedist@@3PAUcvar_s@@A DD 01H DUP (?)		; cl_chasedist
?cl_weaponlag@@3PAUcvar_s@@A DD 01H DUP (?)		; cl_weaponlag
?cl_vsmoothing@@3PAUcvar_s@@A DD 01H DUP (?)		; cl_vsmoothing
?v_centermove@@3PAUcvar_s@@A DD 01H DUP (?)		; v_centermove
?v_centerspeed@@3PAUcvar_s@@A DD 01H DUP (?)		; v_centerspeed
?pd@@3U__unnamed@@A DB 018H DUP (?)			; pd
_?oldz@?1??V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z@4MA DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
?v_iyaw_cycle@@3Ucvar_s@@A DD FLAT:??_C@_0N@BADI@v_iyaw_cycle?$AA@ ; v_iyaw_cycle
	DD	FLAT:??_C@_01KOLO@2?$AA@
	DD	00H
	DD	040000000r			; 2
	ORG $+4
	ORG $+4
?v_iroll_cycle@@3Ucvar_s@@A DD FLAT:??_C@_0O@NCGN@v_iroll_cycle?$AA@ ; v_iroll_cycle
	DD	FLAT:??_C@_03IPBN@0?45?$AA@
	DD	00H
	DD	03f000000r			; 0.5
	ORG $+4
	ORG $+4
?v_ipitch_cycle@@3Ucvar_s@@A DD FLAT:??_C@_0P@IHFO@v_ipitch_cycle?$AA@ ; v_ipitch_cycle
	DD	FLAT:??_C@_01FBAH@1?$AA@
	DD	00H
	DD	03f800000r			; 1
	ORG $+4
	ORG $+4
?v_iyaw_level@@3Ucvar_s@@A DD FLAT:??_C@_0N@PNOG@v_iyaw_level?$AA@ ; v_iyaw_level
	DD	FLAT:??_C@_03HAGP@0?43?$AA@
	DD	00H
	DD	03e99999ar			; 0.3
	ORG $+4
	ORG $+4
?v_iroll_level@@3Ucvar_s@@A DD FLAT:??_C@_0O@DPLD@v_iroll_level?$AA@ ; v_iroll_level
	DD	FLAT:??_C@_03CFEB@0?41?$AA@
	DD	00H
	DD	03dcccccdr			; 0.1
	ORG $+4
	ORG $+4
?v_ipitch_level@@3Ucvar_s@@A DD FLAT:??_C@_0P@GKIA@v_ipitch_level?$AA@ ; v_ipitch_level
	DD	FLAT:??_C@_03HAGP@0?43?$AA@
	DD	00H
	DD	03e99999ar			; 0.3
	ORG $+4
_DATA	ENDS
;	COMDAT ??_C@_0N@BADI@v_iyaw_cycle?$AA@
CONST	SEGMENT
??_C@_0N@BADI@v_iyaw_cycle?$AA@ DB 'v_iyaw_cycle', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KOLO@2?$AA@
CONST	SEGMENT
??_C@_01KOLO@2?$AA@ DB '2', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NCGN@v_iroll_cycle?$AA@
CONST	SEGMENT
??_C@_0O@NCGN@v_iroll_cycle?$AA@ DB 'v_iroll_cycle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03IPBN@0?45?$AA@
CONST	SEGMENT
??_C@_03IPBN@0?45?$AA@ DB '0.5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IHFO@v_ipitch_cycle?$AA@
CONST	SEGMENT
??_C@_0P@IHFO@v_ipitch_cycle?$AA@ DB 'v_ipitch_cycle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01FBAH@1?$AA@
CONST	SEGMENT
??_C@_01FBAH@1?$AA@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PNOG@v_iyaw_level?$AA@
CONST	SEGMENT
??_C@_0N@PNOG@v_iyaw_level?$AA@ DB 'v_iyaw_level', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03HAGP@0?43?$AA@
CONST	SEGMENT
??_C@_03HAGP@0?43?$AA@ DB '0.3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DPLD@v_iroll_level?$AA@
CONST	SEGMENT
??_C@_0O@DPLD@v_iroll_level?$AA@ DB 'v_iroll_level', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03CFEB@0?41?$AA@
CONST	SEGMENT
??_C@_03CFEB@0?41?$AA@ DB '0.1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GKIA@v_ipitch_level?$AA@
CONST	SEGMENT
??_C@_0P@GKIA@v_ipitch_level?$AA@ DB 'v_ipitch_level', 00H ; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L55256:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L55257
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L55256
$L55257:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?CAM_Think@@YAXXZ				; CAM_Think
;	COMDAT ?CAM_Think@@YAXXZ
_TEXT	SEGMENT
?CAM_Think@@YAXXZ PROC NEAR				; CAM_Think, COMDAT

; 18   : void CAM_Think( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CAM_Think@@YAXXZ ENDP					; CAM_Think
_TEXT	ENDS
PUBLIC	?CopyToArray@Vector@@QBEXPAM@Z			; Vector::CopyToArray
PUBLIC	?CL_CameraOffset@@YAXPAM@Z			; CL_CameraOffset
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
;	COMDAT ?CL_CameraOffset@@YAXPAM@Z
_TEXT	SEGMENT
_ofs$ = 8
?CL_CameraOffset@@YAXPAM@Z PROC NEAR			; CL_CameraOffset, COMDAT

; 19   : void CL_CameraOffset( float *ofs ) { g_vecZero.CopyToArray( ofs ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _ofs$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?g_vecZero@@3VVector@@B
	call	?CopyToArray@Vector@@QBEXPAM@Z		; Vector::CopyToArray
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CL_CameraOffset@@YAXPAM@Z ENDP				; CL_CameraOffset
_TEXT	ENDS
EXTRN	__fltused:NEAR
;	COMDAT ?CopyToArray@Vector@@QBEXPAM@Z
_TEXT	SEGMENT
_rgfl$ = 8
_this$ = -4
?CopyToArray@Vector@@QBEXPAM@Z PROC NEAR		; Vector::CopyToArray, COMDAT

; 225  : 	inline void CopyToArray( float *rgfl ) const	{ rgfl[0] = x, rgfl[1] = y, rgfl[2] = z; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _rgfl$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _rgfl$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _rgfl$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CopyToArray@Vector@@QBEXPAM@Z ENDP			; Vector::CopyToArray
_TEXT	ENDS
PUBLIC	?CL_IsThirdPerson@@YAHXZ			; CL_IsThirdPerson
EXTRN	?gHUD@@3VCHud@@A:BYTE				; gHUD
;	COMDAT ?CL_IsThirdPerson@@YAHXZ
_TEXT	SEGMENT
?CL_IsThirdPerson@@YAHXZ PROC NEAR			; CL_IsThirdPerson, COMDAT

; 20   : int CL_IsThirdPerson( void ){ return (gHUD.m_iCameraMode ? 1 : 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR ?gHUD@@3VCHud@@A+100, 0
	setne	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CL_IsThirdPerson@@YAHXZ ENDP				; CL_IsThirdPerson
_TEXT	ENDS
PUBLIC	?V_ThirdPerson@@YAXXZ				; V_ThirdPerson
EXTRN	?gEngfuncs@@3Ucl_enginefuncs_s@@A:BYTE		; gEngfuncs
;	COMDAT ?V_ThirdPerson@@YAXXZ
_TEXT	SEGMENT
?V_ThirdPerson@@YAXXZ PROC NEAR				; V_ThirdPerson, COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 96   : 	if( gEngfuncs.GetMaxClients() == 1 )

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+144
	cmp	eax, 1
	jne	SHORT $L71268

; 97   : 		gHUD.m_iCameraMode = 1;

	mov	DWORD PTR ?gHUD@@3VCHud@@A+100, 1
$L71268:

; 98   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_ThirdPerson@@YAXXZ ENDP				; V_ThirdPerson
_TEXT	ENDS
PUBLIC	?V_FirstPerson@@YAXXZ				; V_FirstPerson
;	COMDAT ?V_FirstPerson@@YAXXZ
_TEXT	SEGMENT
?V_FirstPerson@@YAXXZ PROC NEAR				; V_FirstPerson, COMDAT

; 106  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 107  : 	gHUD.m_iCameraMode = 0;

	mov	DWORD PTR ?gHUD@@3VCHud@@A+100, 0

; 108  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_FirstPerson@@YAXXZ ENDP				; V_FirstPerson
_TEXT	ENDS
PUBLIC	?V_Init@@YAXXZ					; V_Init
PUBLIC	?V_StartPitchDrift@@YAXXZ			; V_StartPitchDrift
PUBLIC	??_C@_04JDHO@0?415?$AA@				; `string'
PUBLIC	??_C@_0N@KEFH@v_centermove?$AA@			; `string'
PUBLIC	??_C@_03DNJI@500?$AA@				; `string'
PUBLIC	??_C@_0O@GJCG@v_centerspeed?$AA@		; `string'
PUBLIC	??_C@_03NLGO@0?48?$AA@				; `string'
PUBLIC	??_C@_0M@NDIF@cl_bobcycle?$AA@			; `string'
PUBLIC	??_C@_04CPII@0?401?$AA@				; `string'
PUBLIC	??_C@_06FFIM@cl_bob?$AA@			; `string'
PUBLIC	??_C@_08BPEI@cl_bobup?$AA@			; `string'
PUBLIC	??_C@_01FBMM@4?$AA@				; `string'
PUBLIC	??_C@_0N@JGKA@cl_waterdist?$AA@			; `string'
PUBLIC	??_C@_03DGEG@112?$AA@				; `string'
PUBLIC	??_C@_0N@IKKM@cl_chasedist?$AA@			; `string'
PUBLIC	??_C@_0N@BKCD@cl_weaponlag?$AA@			; `string'
PUBLIC	??_C@_0BE@NCIF@gl_allow_extensions?$AA@		; `string'
PUBLIC	??_C@_09IEFK@gl_finish?$AA@			; `string'
PUBLIC	??_C@_08CLGN@gl_clear?$AA@			; `string'
PUBLIC	??_C@_08MNKK@r_speeds?$AA@			; `string'
PUBLIC	??_C@_07MKFJ@gl_test?$AA@			; `string'
PUBLIC	??_C@_08NKJJ@viewsize?$AA@			; `string'
PUBLIC	??_C@_07CBKH@r_novis?$AA@			; `string'
PUBLIC	??_C@_08HJPD@r_nocull?$AA@			; `string'
PUBLIC	??_C@_09ILGG@gl_nosort?$AA@			; `string'
PUBLIC	??_C@_09BIML@r_lockpvs?$AA@			; `string'
PUBLIC	??_C@_09LGEB@r_dynamic?$AA@			; `string'
PUBLIC	??_C@_0L@DOIK@r_lightmap?$AA@			; `string'
PUBLIC	??_C@_0N@LEFO@gl_wireframe?$AA@			; `string'
PUBLIC	??_C@_0N@MPPJ@r_adjust_fov?$AA@			; `string'
PUBLIC	??_C@_0BA@JLA@gl_check_errors?$AA@		; `string'
PUBLIC	??_C@_05CAAD@gamma?$AA@				; `string'
PUBLIC	??_C@_0L@HCKI@brightness?$AA@			; `string'
PUBLIC	??_C@_0O@GOOL@gl_polyoffset?$AA@		; `string'
PUBLIC	??_C@_0N@MMGG@r_fullbright?$AA@			; `string'
PUBLIC	??_C@_0P@LECL@r_drawentities?$AA@		; `string'
PUBLIC	??_C@_0BB@JPMN@r_detailtextures?$AA@		; `string'
PUBLIC	??_C@_0BE@NIBJ@r_lighting_modulate?$AA@		; `string'
PUBLIC	??_C@_0BG@ICLI@cl_lightstyle_lerping?$AA@	; `string'
PUBLIC	??_C@_0BE@GHPE@r_lighting_extended?$AA@		; `string'
PUBLIC	??_C@_04IFNE@0?405?$AA@				; `string'
PUBLIC	??_C@_0O@IMI@cl_vsmoothing?$AA@			; `string'
PUBLIC	??_C@_0BB@IDJM@gl_allow_portals?$AA@		; `string'
PUBLIC	??_C@_0BB@BONP@gl_allow_screens?$AA@		; `string'
PUBLIC	??_C@_0M@IPEA@gl_renderer?$AA@			; `string'
PUBLIC	??_C@_09CNME@r_shadows?$AA@			; `string'
PUBLIC	??_C@_0P@MHOB@gl_allow_3dsky?$AA@		; `string'
PUBLIC	??_C@_0BB@PMEE@gl_allow_mirrors?$AA@		; `string'
PUBLIC	??_C@_0BD@PHDP@gl_recursion_depth?$AA@		; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_0BI@KFIC@gl_recursive_world_node?$AA@	; `string'
PUBLIC	??_C@_07CCKA@r_grass?$AA@			; `string'
PUBLIC	??_C@_0O@MOOI@r_grass_alpha?$AA@		; `string'
PUBLIC	??_C@_0BB@GONJ@r_grass_lighting?$AA@		; `string'
PUBLIC	??_C@_0BA@LANA@r_grass_shadows?$AA@		; `string'
PUBLIC	??_C@_04JMAB@2048?$AA@				; `string'
PUBLIC	??_C@_0BD@CFNH@r_grass_fade_start?$AA@		; `string'
PUBLIC	??_C@_0BC@GHFP@r_grass_fade_dist?$AA@		; `string'
PUBLIC	??_C@_0BC@JNAI@r_show_renderpass?$AA@		; `string'
PUBLIC	??_C@_0BG@PEIH@r_show_light_scissors?$AA@	; `string'
PUBLIC	??_C@_0P@IJFN@r_show_normals?$AA@		; `string'
PUBLIC	??_C@_0BD@DCJJ@r_show_lightprobes?$AA@		; `string'
PUBLIC	??_C@_0M@PBHN@thirdperson?$AA@			; `string'
PUBLIC	??_C@_0M@NCDD@firstperson?$AA@			; `string'
PUBLIC	??_C@_0L@EKJH@centerview?$AA@			; `string'
;	COMDAT ??_C@_04JDHO@0?415?$AA@
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
??_C@_04JDHO@0?415?$AA@ DB '0.15', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KEFH@v_centermove?$AA@
CONST	SEGMENT
??_C@_0N@KEFH@v_centermove?$AA@ DB 'v_centermove', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03DNJI@500?$AA@
CONST	SEGMENT
??_C@_03DNJI@500?$AA@ DB '500', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GJCG@v_centerspeed?$AA@
CONST	SEGMENT
??_C@_0O@GJCG@v_centerspeed?$AA@ DB 'v_centerspeed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NLGO@0?48?$AA@
CONST	SEGMENT
??_C@_03NLGO@0?48?$AA@ DB '0.8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NDIF@cl_bobcycle?$AA@
CONST	SEGMENT
??_C@_0M@NDIF@cl_bobcycle?$AA@ DB 'cl_bobcycle', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CPII@0?401?$AA@
CONST	SEGMENT
??_C@_04CPII@0?401?$AA@ DB '0.01', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFIM@cl_bob?$AA@
CONST	SEGMENT
??_C@_06FFIM@cl_bob?$AA@ DB 'cl_bob', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BPEI@cl_bobup?$AA@
CONST	SEGMENT
??_C@_08BPEI@cl_bobup?$AA@ DB 'cl_bobup', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01FBMM@4?$AA@
CONST	SEGMENT
??_C@_01FBMM@4?$AA@ DB '4', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JGKA@cl_waterdist?$AA@
CONST	SEGMENT
??_C@_0N@JGKA@cl_waterdist?$AA@ DB 'cl_waterdist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03DGEG@112?$AA@
CONST	SEGMENT
??_C@_03DGEG@112?$AA@ DB '112', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IKKM@cl_chasedist?$AA@
CONST	SEGMENT
??_C@_0N@IKKM@cl_chasedist?$AA@ DB 'cl_chasedist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BKCD@cl_weaponlag?$AA@
CONST	SEGMENT
??_C@_0N@BKCD@cl_weaponlag?$AA@ DB 'cl_weaponlag', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NCIF@gl_allow_extensions?$AA@
CONST	SEGMENT
??_C@_0BE@NCIF@gl_allow_extensions?$AA@ DB 'gl_allow_extensions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IEFK@gl_finish?$AA@
CONST	SEGMENT
??_C@_09IEFK@gl_finish?$AA@ DB 'gl_finish', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CLGN@gl_clear?$AA@
CONST	SEGMENT
??_C@_08CLGN@gl_clear?$AA@ DB 'gl_clear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MNKK@r_speeds?$AA@
CONST	SEGMENT
??_C@_08MNKK@r_speeds?$AA@ DB 'r_speeds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MKFJ@gl_test?$AA@
CONST	SEGMENT
??_C@_07MKFJ@gl_test?$AA@ DB 'gl_test', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NKJJ@viewsize?$AA@
CONST	SEGMENT
??_C@_08NKJJ@viewsize?$AA@ DB 'viewsize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CBKH@r_novis?$AA@
CONST	SEGMENT
??_C@_07CBKH@r_novis?$AA@ DB 'r_novis', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HJPD@r_nocull?$AA@
CONST	SEGMENT
??_C@_08HJPD@r_nocull?$AA@ DB 'r_nocull', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ILGG@gl_nosort?$AA@
CONST	SEGMENT
??_C@_09ILGG@gl_nosort?$AA@ DB 'gl_nosort', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BIML@r_lockpvs?$AA@
CONST	SEGMENT
??_C@_09BIML@r_lockpvs?$AA@ DB 'r_lockpvs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LGEB@r_dynamic?$AA@
CONST	SEGMENT
??_C@_09LGEB@r_dynamic?$AA@ DB 'r_dynamic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DOIK@r_lightmap?$AA@
CONST	SEGMENT
??_C@_0L@DOIK@r_lightmap?$AA@ DB 'r_lightmap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LEFO@gl_wireframe?$AA@
CONST	SEGMENT
??_C@_0N@LEFO@gl_wireframe?$AA@ DB 'gl_wireframe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MPPJ@r_adjust_fov?$AA@
CONST	SEGMENT
??_C@_0N@MPPJ@r_adjust_fov?$AA@ DB 'r_adjust_fov', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JLA@gl_check_errors?$AA@
CONST	SEGMENT
??_C@_0BA@JLA@gl_check_errors?$AA@ DB 'gl_check_errors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CAAD@gamma?$AA@
CONST	SEGMENT
??_C@_05CAAD@gamma?$AA@ DB 'gamma', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HCKI@brightness?$AA@
CONST	SEGMENT
??_C@_0L@HCKI@brightness?$AA@ DB 'brightness', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GOOL@gl_polyoffset?$AA@
CONST	SEGMENT
??_C@_0O@GOOL@gl_polyoffset?$AA@ DB 'gl_polyoffset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MMGG@r_fullbright?$AA@
CONST	SEGMENT
??_C@_0N@MMGG@r_fullbright?$AA@ DB 'r_fullbright', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LECL@r_drawentities?$AA@
CONST	SEGMENT
??_C@_0P@LECL@r_drawentities?$AA@ DB 'r_drawentities', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JPMN@r_detailtextures?$AA@
CONST	SEGMENT
??_C@_0BB@JPMN@r_detailtextures?$AA@ DB 'r_detailtextures', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NIBJ@r_lighting_modulate?$AA@
CONST	SEGMENT
??_C@_0BE@NIBJ@r_lighting_modulate?$AA@ DB 'r_lighting_modulate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ICLI@cl_lightstyle_lerping?$AA@
CONST	SEGMENT
??_C@_0BG@ICLI@cl_lightstyle_lerping?$AA@ DB 'cl_lightstyle_lerping', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GHPE@r_lighting_extended?$AA@
CONST	SEGMENT
??_C@_0BE@GHPE@r_lighting_extended?$AA@ DB 'r_lighting_extended', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IFNE@0?405?$AA@
CONST	SEGMENT
??_C@_04IFNE@0?405?$AA@ DB '0.05', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IMI@cl_vsmoothing?$AA@
CONST	SEGMENT
??_C@_0O@IMI@cl_vsmoothing?$AA@ DB 'cl_vsmoothing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IDJM@gl_allow_portals?$AA@
CONST	SEGMENT
??_C@_0BB@IDJM@gl_allow_portals?$AA@ DB 'gl_allow_portals', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BONP@gl_allow_screens?$AA@
CONST	SEGMENT
??_C@_0BB@BONP@gl_allow_screens?$AA@ DB 'gl_allow_screens', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IPEA@gl_renderer?$AA@
CONST	SEGMENT
??_C@_0M@IPEA@gl_renderer?$AA@ DB 'gl_renderer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CNME@r_shadows?$AA@
CONST	SEGMENT
??_C@_09CNME@r_shadows?$AA@ DB 'r_shadows', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MHOB@gl_allow_3dsky?$AA@
CONST	SEGMENT
??_C@_0P@MHOB@gl_allow_3dsky?$AA@ DB 'gl_allow_3dsky', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PMEE@gl_allow_mirrors?$AA@
CONST	SEGMENT
??_C@_0BB@PMEE@gl_allow_mirrors?$AA@ DB 'gl_allow_mirrors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PHDP@gl_recursion_depth?$AA@
CONST	SEGMENT
??_C@_0BD@PHDP@gl_recursion_depth?$AA@ DB 'gl_recursion_depth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KFIC@gl_recursive_world_node?$AA@
CONST	SEGMENT
??_C@_0BI@KFIC@gl_recursive_world_node?$AA@ DB 'gl_recursive_world_node', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CCKA@r_grass?$AA@
CONST	SEGMENT
??_C@_07CCKA@r_grass?$AA@ DB 'r_grass', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MOOI@r_grass_alpha?$AA@
CONST	SEGMENT
??_C@_0O@MOOI@r_grass_alpha?$AA@ DB 'r_grass_alpha', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GONJ@r_grass_lighting?$AA@
CONST	SEGMENT
??_C@_0BB@GONJ@r_grass_lighting?$AA@ DB 'r_grass_lighting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LANA@r_grass_shadows?$AA@
CONST	SEGMENT
??_C@_0BA@LANA@r_grass_shadows?$AA@ DB 'r_grass_shadows', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JMAB@2048?$AA@
CONST	SEGMENT
??_C@_04JMAB@2048?$AA@ DB '2048', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CFNH@r_grass_fade_start?$AA@
CONST	SEGMENT
??_C@_0BD@CFNH@r_grass_fade_start?$AA@ DB 'r_grass_fade_start', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GHFP@r_grass_fade_dist?$AA@
CONST	SEGMENT
??_C@_0BC@GHFP@r_grass_fade_dist?$AA@ DB 'r_grass_fade_dist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JNAI@r_show_renderpass?$AA@
CONST	SEGMENT
??_C@_0BC@JNAI@r_show_renderpass?$AA@ DB 'r_show_renderpass', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PEIH@r_show_light_scissors?$AA@
CONST	SEGMENT
??_C@_0BG@PEIH@r_show_light_scissors?$AA@ DB 'r_show_light_scissors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IJFN@r_show_normals?$AA@
CONST	SEGMENT
??_C@_0P@IJFN@r_show_normals?$AA@ DB 'r_show_normals', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCJJ@r_show_lightprobes?$AA@
CONST	SEGMENT
??_C@_0BD@DCJJ@r_show_lightprobes?$AA@ DB 'r_show_lightprobes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PBHN@thirdperson?$AA@
CONST	SEGMENT
??_C@_0M@PBHN@thirdperson?$AA@ DB 'thirdperson', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NCDD@firstperson?$AA@
CONST	SEGMENT
??_C@_0M@NCDD@firstperson?$AA@ DB 'firstperson', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EKJH@centerview?$AA@
CONST	SEGMENT
??_C@_0L@EKJH@centerview?$AA@ DB 'centerview', 00H	; `string'
CONST	ENDS
;	COMDAT ?V_Init@@YAXXZ
_TEXT	SEGMENT
?V_Init@@YAXXZ PROC NEAR				; V_Init, COMDAT

; 114  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 115  : 	v_centermove	= CVAR_REGISTER( "v_centermove", "0.15", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04JDHO@0?415?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@KEFH@v_centermove?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?v_centermove@@3PAUcvar_s@@A, eax ; v_centermove

; 116  : 	v_centerspeed	= CVAR_REGISTER( "v_centerspeed","500", 0 );

	push	0
	push	OFFSET FLAT:??_C@_03DNJI@500?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@GJCG@v_centerspeed?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?v_centerspeed@@3PAUcvar_s@@A, eax ; v_centerspeed

; 117  : 
; 118  : 	cl_bobcycle	= CVAR_REGISTER( "cl_bobcycle","0.8", 0 );

	push	0
	push	OFFSET FLAT:??_C@_03NLGO@0?48?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0M@NDIF@cl_bobcycle?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?cl_bobcycle@@3PAUcvar_s@@A, eax ; cl_bobcycle

; 119  : 	cl_bob		= CVAR_REGISTER( "cl_bob","0.01", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04CPII@0?401?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06FFIM@cl_bob?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?cl_bob@@3PAUcvar_s@@A, eax	; cl_bob

; 120  : 	cl_bobup		= CVAR_REGISTER( "cl_bobup","0.5", 0 );

	push	0
	push	OFFSET FLAT:??_C@_03IPBN@0?45?$AA@	; `string'
	push	OFFSET FLAT:??_C@_08BPEI@cl_bobup?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?cl_bobup@@3PAUcvar_s@@A, eax	; cl_bobup

; 121  : 	cl_waterdist	= CVAR_REGISTER( "cl_waterdist","4", 0 );

	push	0
	push	OFFSET FLAT:??_C@_01FBMM@4?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@JGKA@cl_waterdist?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?cl_waterdist@@3PAUcvar_s@@A, eax ; cl_waterdist

; 122  : 	cl_chasedist	= CVAR_REGISTER( "cl_chasedist","112", 0 );

	push	0
	push	OFFSET FLAT:??_C@_03DGEG@112?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@IKKM@cl_chasedist?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?cl_chasedist@@3PAUcvar_s@@A, eax ; cl_chasedist

; 123  : 	cl_weaponlag	= CVAR_REGISTER( "cl_weaponlag", "0.3", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_03HAGP@0?43?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@BKCD@cl_weaponlag?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?cl_weaponlag@@3PAUcvar_s@@A, eax ; cl_weaponlag

; 124  : 
; 125  : 	// setup some engine cvars for custom rendering
; 126  : 	r_extensions	= CVAR_GET_POINTER( "gl_allow_extensions" );

	push	OFFSET FLAT:??_C@_0BE@NCIF@gl_allow_extensions?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_extensions@@3PAUcvar_s@@A, eax ; r_extensions

; 127  : 	r_finish		= CVAR_GET_POINTER( "gl_finish" );

	push	OFFSET FLAT:??_C@_09IEFK@gl_finish?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_finish@@3PAUcvar_s@@A, eax	; r_finish

; 128  : 	r_clear		= CVAR_GET_POINTER( "gl_clear" );

	push	OFFSET FLAT:??_C@_08CLGN@gl_clear?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_clear@@3PAUcvar_s@@A, eax	; r_clear

; 129  : 	r_speeds		= CVAR_GET_POINTER( "r_speeds" );

	push	OFFSET FLAT:??_C@_08MNKK@r_speeds?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_speeds@@3PAUcvar_s@@A, eax	; r_speeds

; 130  : 	r_test		= CVAR_GET_POINTER( "gl_test" );

	push	OFFSET FLAT:??_C@_07MKFJ@gl_test?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_test@@3PAUcvar_s@@A, eax	; r_test

; 131  : 	cl_viewsize	= CVAR_GET_POINTER( "viewsize" );

	push	OFFSET FLAT:??_C@_08NKJJ@viewsize?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?cl_viewsize@@3PAUcvar_s@@A, eax ; cl_viewsize

; 132  : 
; 133  : 	r_novis		= CVAR_GET_POINTER( "r_novis" );

	push	OFFSET FLAT:??_C@_07CBKH@r_novis?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_novis@@3PAUcvar_s@@A, eax	; r_novis

; 134  : 	r_nocull		= CVAR_GET_POINTER( "r_nocull" );

	push	OFFSET FLAT:??_C@_08HJPD@r_nocull?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_nocull@@3PAUcvar_s@@A, eax	; r_nocull

; 135  : 	r_nosort		= CVAR_GET_POINTER( "gl_nosort" );

	push	OFFSET FLAT:??_C@_09ILGG@gl_nosort?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_nosort@@3PAUcvar_s@@A, eax	; r_nosort

; 136  : 	r_lockpvs		= CVAR_GET_POINTER( "r_lockpvs" );

	push	OFFSET FLAT:??_C@_09BIML@r_lockpvs?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_lockpvs@@3PAUcvar_s@@A, eax ; r_lockpvs

; 137  : 	r_dynamic		= CVAR_GET_POINTER( "r_dynamic" );

	push	OFFSET FLAT:??_C@_09LGEB@r_dynamic?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_dynamic@@3PAUcvar_s@@A, eax ; r_dynamic

; 138  : 	r_lightmap	= CVAR_GET_POINTER( "r_lightmap" );

	push	OFFSET FLAT:??_C@_0L@DOIK@r_lightmap?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_lightmap@@3PAUcvar_s@@A, eax ; r_lightmap

; 139  : 	r_wireframe	= CVAR_GET_POINTER( "gl_wireframe" );

	push	OFFSET FLAT:??_C@_0N@LEFO@gl_wireframe?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_wireframe@@3PAUcvar_s@@A, eax ; r_wireframe

; 140  : 	r_adjust_fov	= CVAR_GET_POINTER( "r_adjust_fov" );

	push	OFFSET FLAT:??_C@_0N@MPPJ@r_adjust_fov?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_adjust_fov@@3PAUcvar_s@@A, eax ; r_adjust_fov

; 141  : 	gl_check_errors	= CVAR_GET_POINTER( "gl_check_errors" );

	push	OFFSET FLAT:??_C@_0BA@JLA@gl_check_errors?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?gl_check_errors@@3PAUcvar_s@@A, eax ; gl_check_errors

; 142  : 	vid_gamma		= CVAR_GET_POINTER( "gamma" );

	push	OFFSET FLAT:??_C@_05CAAD@gamma?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?vid_gamma@@3PAUcvar_s@@A, eax ; vid_gamma

; 143  : 	vid_brightness	= CVAR_GET_POINTER( "brightness" );

	push	OFFSET FLAT:??_C@_0L@HCKI@brightness?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?vid_brightness@@3PAUcvar_s@@A, eax ; vid_brightness

; 144  : 	r_polyoffset	= CVAR_GET_POINTER( "gl_polyoffset" );

	push	OFFSET FLAT:??_C@_0O@GOOL@gl_polyoffset?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_polyoffset@@3PAUcvar_s@@A, eax ; r_polyoffset

; 145  : 
; 146  : 	r_fullbright	= CVAR_GET_POINTER( "r_fullbright" );

	push	OFFSET FLAT:??_C@_0N@MMGG@r_fullbright?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_fullbright@@3PAUcvar_s@@A, eax ; r_fullbright

; 147  : 	r_drawentities	= CVAR_GET_POINTER( "r_drawentities" );

	push	OFFSET FLAT:??_C@_0P@LECL@r_drawentities?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_drawentities@@3PAUcvar_s@@A, eax ; r_drawentities

; 148  : 	r_detailtextures	= CVAR_GET_POINTER( "r_detailtextures" );

	push	OFFSET FLAT:??_C@_0BB@JPMN@r_detailtextures?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_detailtextures@@3PAUcvar_s@@A, eax ; r_detailtextures

; 149  : 	r_lighting_modulate	= CVAR_GET_POINTER( "r_lighting_modulate" );

	push	OFFSET FLAT:??_C@_0BE@NIBJ@r_lighting_modulate?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_lighting_modulate@@3PAUcvar_s@@A, eax ; r_lighting_modulate

; 150  : 	r_lightstyle_lerping= CVAR_GET_POINTER( "cl_lightstyle_lerping" );

	push	OFFSET FLAT:??_C@_0BG@ICLI@cl_lightstyle_lerping?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_lightstyle_lerping@@3PAUcvar_s@@A, eax ; r_lightstyle_lerping

; 151  : 	r_lighting_extended	= CVAR_GET_POINTER( "r_lighting_extended" );

	push	OFFSET FLAT:??_C@_0BE@GHPE@r_lighting_extended?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+288
	add	esp, 4
	mov	DWORD PTR ?r_lighting_extended@@3PAUcvar_s@@A, eax ; r_lighting_extended

; 152  : 
; 153  : 	cl_vsmoothing	= CVAR_REGISTER( "cl_vsmoothing", "0.05", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_04IFNE@0?405?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@IMI@cl_vsmoothing?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?cl_vsmoothing@@3PAUcvar_s@@A, eax ; cl_vsmoothing

; 154  : 	r_allow_portals	= CVAR_REGISTER( "gl_allow_portals", "1", FCVAR_ARCHIVE|FCVAR_CLIENTDLL );

	push	17					; 00000011H
	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BB@IDJM@gl_allow_portals?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_allow_portals@@3PAUcvar_s@@A, eax ; r_allow_portals

; 155  : 	r_allow_screens	= CVAR_REGISTER( "gl_allow_screens", "1", FCVAR_ARCHIVE|FCVAR_CLIENTDLL );

	push	17					; 00000011H
	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BB@BONP@gl_allow_screens?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_allow_screens@@3PAUcvar_s@@A, eax ; r_allow_screens

; 156  : 	gl_renderer	= CVAR_REGISTER( "gl_renderer", "1", FCVAR_CLIENTDLL|FCVAR_ARCHIVE ); 

	push	17					; 00000011H
	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0M@IPEA@gl_renderer?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?gl_renderer@@3PAUcvar_s@@A, eax ; gl_renderer

; 157  : 	r_shadows		= CVAR_REGISTER( "r_shadows", "2", FCVAR_CLIENTDLL|FCVAR_ARCHIVE ); 

	push	17					; 00000011H
	push	OFFSET FLAT:??_C@_01KOLO@2?$AA@		; `string'
	push	OFFSET FLAT:??_C@_09CNME@r_shadows?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_shadows@@3PAUcvar_s@@A, eax ; r_shadows

; 158  : 	r_allow_3dsky	= CVAR_REGISTER( "gl_allow_3dsky", "1", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0P@MHOB@gl_allow_3dsky?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_allow_3dsky@@3PAUcvar_s@@A, eax ; r_allow_3dsky

; 159  : 	r_allow_mirrors	= CVAR_REGISTER( "gl_allow_mirrors", "1", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BB@PMEE@gl_allow_mirrors?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_allow_mirrors@@3PAUcvar_s@@A, eax ; r_allow_mirrors

; 160  : 	r_recursion_depth	= CVAR_REGISTER( "gl_recursion_depth", "1", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BD@PHDP@gl_recursion_depth?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_recursion_depth@@3PAUcvar_s@@A, eax ; r_recursion_depth

; 161  : 	r_recursive_world_node = CVAR_REGISTER( "gl_recursive_world_node", "0", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BI@KFIC@gl_recursive_world_node?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_recursive_world_node@@3PAUcvar_s@@A, eax ; r_recursive_world_node

; 162  : 
; 163  : 	r_grass = CVAR_REGISTER( "r_grass", "1", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_07CCKA@r_grass?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_grass@@3PAUcvar_s@@A, eax	; r_grass

; 164  : 	r_grass_alpha = CVAR_REGISTER( "r_grass_alpha", "0.5", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_03IPBN@0?45?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@MOOI@r_grass_alpha?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_grass_alpha@@3PAUcvar_s@@A, eax ; r_grass_alpha

; 165  : 	r_grass_lighting = CVAR_REGISTER( "r_grass_lighting", "1", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BB@GONJ@r_grass_lighting?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_grass_lighting@@3PAUcvar_s@@A, eax ; r_grass_lighting

; 166  : 	r_grass_shadows = CVAR_REGISTER( "r_grass_shadows", "1", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BA@LANA@r_grass_shadows?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_grass_shadows@@3PAUcvar_s@@A, eax ; r_grass_shadows

; 167  : 	r_grass_fade_start = CVAR_REGISTER( "r_grass_fade_start", "2048", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_04JMAB@2048?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BD@CFNH@r_grass_fade_start?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_grass_fade_start@@3PAUcvar_s@@A, eax ; r_grass_fade_start

; 168  : 	r_grass_fade_dist = CVAR_REGISTER( "r_grass_fade_dist", "2048", FCVAR_ARCHIVE );

	push	1
	push	OFFSET FLAT:??_C@_04JMAB@2048?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BC@GHFP@r_grass_fade_dist?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_grass_fade_dist@@3PAUcvar_s@@A, eax ; r_grass_fade_dist

; 169  : 
; 170  : 	r_show_renderpass = CVAR_REGISTER( "r_show_renderpass", "0", 0 );

	push	0
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BC@JNAI@r_show_renderpass?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_show_renderpass@@3PAUcvar_s@@A, eax ; r_show_renderpass

; 171  : 	r_show_light_scissors = CVAR_REGISTER( "r_show_light_scissors", "0", 0 );

	push	0
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BG@PEIH@r_show_light_scissors?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_show_light_scissors@@3PAUcvar_s@@A, eax ; r_show_light_scissors

; 172  : 	r_show_normals = CVAR_REGISTER( "r_show_normals", "0", 0 );

	push	0
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0P@IJFN@r_show_normals?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_show_normals@@3PAUcvar_s@@A, eax ; r_show_normals

; 173  : 	r_show_lightprobes = CVAR_REGISTER( "r_show_lightprobes", "0", 0 );

	push	0
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BD@DCJJ@r_show_lightprobes?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?r_show_lightprobes@@3PAUcvar_s@@A, eax ; r_show_lightprobes

; 174  : 
; 175  : 	ADD_COMMAND( "thirdperson", V_ThirdPerson );

	push	OFFSET FLAT:?V_ThirdPerson@@YAXXZ	; V_ThirdPerson
	push	OFFSET FLAT:??_C@_0M@PBHN@thirdperson?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+68
	add	esp, 8

; 176  : 	ADD_COMMAND( "firstperson", V_FirstPerson );

	push	OFFSET FLAT:?V_FirstPerson@@YAXXZ	; V_FirstPerson
	push	OFFSET FLAT:??_C@_0M@NCDD@firstperson?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+68
	add	esp, 8

; 177  : 	ADD_COMMAND( "centerview", V_StartPitchDrift );

	push	OFFSET FLAT:?V_StartPitchDrift@@YAXXZ	; V_StartPitchDrift
	push	OFFSET FLAT:??_C@_0L@EKJH@centerview?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+68
	add	esp, 8

; 178  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_Init@@YAXXZ ENDP					; V_Init
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	__real@8@4000c90fdaa22168c000
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	__real@4@3ffd99999a0000000000
PUBLIC	__real@4@3ffeb333330000000000
PUBLIC	__real@4@c001e000000000000000
PUBLIC	__real@4@40018000000000000000
PUBLIC	?V_CalcBob@@YAMPAUref_params_s@@@Z		; V_CalcBob
EXTRN	_sin:NEAR
EXTRN	_sqrt:NEAR
EXTRN	__ftol:NEAR
_BSS	SEGMENT
	ALIGN	8

_?bobtime@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4NA DQ 01H DUP (?)
_?bob@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4MA DD 01H DUP (?)
_?lasttime@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4MA DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@8@4000c90fdaa22168c000
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
__real@8@4000c90fdaa22168c000 DQ 0400921fb54442d18r ; 3.14159
CONST	ENDS
;	COMDAT __real@4@3fff8000000000000000
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT __real@4@3ffd99999a0000000000
CONST	SEGMENT
__real@4@3ffd99999a0000000000 DD 03e99999ar	; 0.3
CONST	ENDS
;	COMDAT __real@4@3ffeb333330000000000
CONST	SEGMENT
__real@4@3ffeb333330000000000 DD 03f333333r	; 0.7
CONST	ENDS
;	COMDAT __real@4@c001e000000000000000
CONST	SEGMENT
__real@4@c001e000000000000000 DD 0c0e00000r	; -7
CONST	ENDS
;	COMDAT __real@4@40018000000000000000
CONST	SEGMENT
__real@4@40018000000000000000 DD 040800000r	; 4
CONST	ENDS
;	COMDAT ?V_CalcBob@@YAMPAUref_params_s@@@Z
_TEXT	SEGMENT
_pparams$ = 8
_cycle$ = -4
_vel$ = -16
?V_CalcBob@@YAMPAUref_params_s@@@Z PROC NEAR		; V_CalcBob, COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 188  : 	static double bobtime;
; 189  : 	static float bob, lasttime;
; 190  : 	float cycle;
; 191  : 	Vector vel;

	lea	ecx, DWORD PTR _vel$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 192  : 
; 193  : 	if( pparams->onground == -1 || pparams->time == lasttime )

	mov	eax, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [eax+80], -1
	je	SHORT $L71350
	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR [ecx+64]
	fcomp	DWORD PTR _?lasttime@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4MA
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L71349
$L71350:

; 194  : 		return bob;	

	fld	DWORD PTR _?bob@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4MA
	jmp	$L71340
$L71349:

; 195  : 
; 196  : 	lasttime = pparams->time;

	mov	edx, DWORD PTR _pparams$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR _?lasttime@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4MA, eax

; 197  : 
; 198  : 	bobtime += pparams->frametime;

	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR [ecx+60]
	fadd	QWORD PTR _?bobtime@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4NA
	fstp	QWORD PTR _?bobtime@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4NA

; 199  : 	cycle = bobtime - (int)( bobtime / cl_bobcycle->value ) * cl_bobcycle->value;

	mov	edx, DWORD PTR ?cl_bobcycle@@3PAUcvar_s@@A ; cl_bobcycle
	fld	DWORD PTR [edx+12]
	fdivr	QWORD PTR _?bobtime@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4NA
	call	__ftol
	mov	DWORD PTR -20+[ebp], eax
	fild	DWORD PTR -20+[ebp]
	mov	eax, DWORD PTR ?cl_bobcycle@@3PAUcvar_s@@A ; cl_bobcycle
	fmul	DWORD PTR [eax+12]
	fsubr	QWORD PTR _?bobtime@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4NA
	fstp	DWORD PTR _cycle$[ebp]

; 200  : 	cycle /= cl_bobcycle->value;

	mov	ecx, DWORD PTR ?cl_bobcycle@@3PAUcvar_s@@A ; cl_bobcycle
	fld	DWORD PTR _cycle$[ebp]
	fdiv	DWORD PTR [ecx+12]
	fstp	DWORD PTR _cycle$[ebp]

; 201  : 	
; 202  : 	if( cycle < cl_bobup->value )

	mov	edx, DWORD PTR ?cl_bobup@@3PAUcvar_s@@A	; cl_bobup
	fld	DWORD PTR _cycle$[ebp]
	fcomp	DWORD PTR [edx+12]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71352

; 204  : 		cycle = M_PI * cycle / cl_bobup->value;

	fld	DWORD PTR _cycle$[ebp]
	fmul	QWORD PTR __real@8@4000c90fdaa22168c000
	mov	eax, DWORD PTR ?cl_bobup@@3PAUcvar_s@@A	; cl_bobup
	fdiv	DWORD PTR [eax+12]
	fstp	DWORD PTR _cycle$[ebp]

; 206  : 	else

	jmp	SHORT $L71353
$L71352:

; 208  : 		cycle = M_PI + M_PI * ( cycle - cl_bobup->value ) / ( 1.0f - cl_bobup->value );

	mov	ecx, DWORD PTR ?cl_bobup@@3PAUcvar_s@@A	; cl_bobup
	fld	DWORD PTR _cycle$[ebp]
	fsub	DWORD PTR [ecx+12]
	fmul	QWORD PTR __real@8@4000c90fdaa22168c000
	mov	edx, DWORD PTR ?cl_bobup@@3PAUcvar_s@@A	; cl_bobup
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR [edx+12]
	fdivp	ST(1), ST(0)
	fadd	QWORD PTR __real@8@4000c90fdaa22168c000
	fstp	DWORD PTR _cycle$[ebp]
$L71353:

; 210  : 
; 211  : 	vel = pparams->simvel;

	mov	eax, DWORD PTR _pparams$[ebp]
	add	eax, 88					; 00000058H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vel$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vel$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vel$[ebp+8], eax

; 212  : 	bob = sqrt( vel.x * vel.x + vel.y * vel.y ) * cl_bob->value;

	fld	DWORD PTR _vel$[ebp]
	fmul	DWORD PTR _vel$[ebp]
	fld	DWORD PTR _vel$[ebp+4]
	fmul	DWORD PTR _vel$[ebp+4]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	mov	ecx, DWORD PTR ?cl_bob@@3PAUcvar_s@@A	; cl_bob
	fmul	DWORD PTR [ecx+12]
	fst	DWORD PTR _?bob@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4MA

; 213  : 	bob = bob * 0.3f + bob * 0.7f * sin( cycle );

	fmul	DWORD PTR __real@4@3ffd99999a0000000000
	fstp	QWORD PTR -28+[ebp]
	fld	DWORD PTR _?bob@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4MA
	fmul	DWORD PTR __real@4@3ffeb333330000000000
	fstp	QWORD PTR -36+[ebp]
	fld	DWORD PTR _cycle$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sin
	add	esp, 8
	fmul	QWORD PTR -36+[ebp]
	fadd	QWORD PTR -28+[ebp]
	fst	DWORD PTR _?bob@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4MA

; 214  : 
; 215  : 	return bound( -7, bob, 4 );

	fcomp	DWORD PTR __real@4@c001e000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L72230
	fld	DWORD PTR _?bob@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4MA
	fcomp	DWORD PTR __real@4@40018000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72228
	mov	edx, DWORD PTR _?bob@?1??V_CalcBob@@YAMPAUref_params_s@@@Z@4MA
	mov	DWORD PTR -40+[ebp], edx
	jmp	SHORT $L72229
$L72228:
	mov	DWORD PTR -40+[ebp], 1082130432		; 40800000H
$L72229:
	mov	eax, DWORD PTR -40+[ebp]
	mov	DWORD PTR -44+[ebp], eax
	jmp	SHORT $L72231
$L72230:
	mov	DWORD PTR -44+[ebp], -1059061760	; c0e00000H
$L72231:
	fld	DWORD PTR -44+[ebp]
$L71340:

; 216  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_CalcBob@@YAMPAUref_params_s@@@Z ENDP			; V_CalcBob
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
PUBLIC	__real@4@00000000000000000000
;	COMDAT __real@4@00000000000000000000
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT ?V_StartPitchDrift@@YAXXZ
_TEXT	SEGMENT
?V_StartPitchDrift@@YAXXZ PROC NEAR			; V_StartPitchDrift, COMDAT

; 232  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 233  : 	if( pd.laststop == GET_CLIENT_TIME( ))

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+216
	fcomp	QWORD PTR ?pd@@3U__unnamed@@A+16
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L71371

; 235  : 		// something else is keeping it from drifting
; 236  : 		return;

	jmp	SHORT $L71370
$L71371:

; 238  : 
; 239  : 	if( pd.nodrift || !pd.pitchvel )

	cmp	DWORD PTR ?pd@@3U__unnamed@@A+4, 0
	jne	SHORT $L71373
	fld	DWORD PTR ?pd@@3U__unnamed@@A
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L71372
$L71373:

; 241  : 		pd.pitchvel = v_centerspeed->value;

	mov	eax, DWORD PTR ?v_centerspeed@@3PAUcvar_s@@A ; v_centerspeed
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR ?pd@@3U__unnamed@@A, ecx

; 242  : 		pd.driftmove = 0;

	mov	DWORD PTR ?pd@@3U__unnamed@@A+8, 0

; 243  : 		pd.nodrift = 0;

	mov	DWORD PTR ?pd@@3U__unnamed@@A+4, 0
$L71372:
$L71370:

; 245  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_StartPitchDrift@@YAXXZ ENDP				; V_StartPitchDrift
_TEXT	ENDS
PUBLIC	?V_StopPitchDrift@@YAXXZ			; V_StopPitchDrift
;	COMDAT ?V_StopPitchDrift@@YAXXZ
_TEXT	SEGMENT
?V_StopPitchDrift@@YAXXZ PROC NEAR			; V_StopPitchDrift, COMDAT

; 251  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 252  : 	pd.laststop = GET_CLIENT_TIME();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+216
	fstp	QWORD PTR ?pd@@3U__unnamed@@A+16

; 253  : 	pd.nodrift = 1;

	mov	DWORD PTR ?pd@@3U__unnamed@@A+4, 1

; 254  : 	pd.pitchvel = 0;

	mov	DWORD PTR ?pd@@3U__unnamed@@A, 0

; 255  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_StopPitchDrift@@YAXXZ ENDP				; V_StopPitchDrift
_TEXT	ENDS
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	?V_DriftPitch@@YAXPAUref_params_s@@@Z		; V_DriftPitch
EXTRN	_fabs:NEAR
EXTRN	?cl_forwardspeed@@3PAUcvar_s@@A:DWORD		; cl_forwardspeed
;	COMDAT ?V_DriftPitch@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT
_pparams$ = 8
_delta$ = -4
_move$ = -8
?V_DriftPitch@@YAXPAUref_params_s@@@Z PROC NEAR		; V_DriftPitch, COMDAT

; 268  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 269  : 	if( gEngfuncs.IsNoClipping() || !pparams->onground || pparams->demoplayback )

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+200
	test	eax, eax
	jne	SHORT $L71381
	mov	eax, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $L71381
	mov	ecx, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [ecx+188], 0
	je	SHORT $L71380
$L71381:

; 271  : 		pd.driftmove = 0;

	mov	DWORD PTR ?pd@@3U__unnamed@@A+8, 0

; 272  : 		pd.pitchvel = 0;

	mov	DWORD PTR ?pd@@3U__unnamed@@A, 0

; 273  : 		return;

	jmp	$L71379
$L71380:

; 275  : 
; 276  : 	if( pd.nodrift )

	cmp	DWORD PTR ?pd@@3U__unnamed@@A+4, 0
	je	SHORT $L71382

; 278  : 		if( fabs( pparams->cmd->forwardmove ) < cl_forwardspeed->value )

	mov	edx, DWORD PTR _pparams$[ebp]
	mov	eax, DWORD PTR [edx+200]
	fld	DWORD PTR [eax+16]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	ecx, DWORD PTR ?cl_forwardspeed@@3PAUcvar_s@@A ; cl_forwardspeed
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71383

; 280  : 			pd.driftmove = 0;

	mov	DWORD PTR ?pd@@3U__unnamed@@A+8, 0

; 282  : 		else

	jmp	SHORT $L71384
$L71383:

; 284  : 			pd.driftmove += pparams->frametime;

	mov	edx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR ?pd@@3U__unnamed@@A+8
	fadd	DWORD PTR [edx+60]
	fstp	DWORD PTR ?pd@@3U__unnamed@@A+8
$L71384:

; 286  : 
; 287  : 		if( pd.driftmove > v_centermove->value )

	mov	eax, DWORD PTR ?v_centermove@@3PAUcvar_s@@A ; v_centermove
	fld	DWORD PTR ?pd@@3U__unnamed@@A+8
	fcomp	DWORD PTR [eax+12]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71385

; 288  : 			V_StartPitchDrift ();

	call	?V_StartPitchDrift@@YAXXZ		; V_StartPitchDrift
$L71385:

; 289  : 		return;

	jmp	$L71379
$L71382:

; 291  : 	
; 292  : 	float delta = pparams->idealpitch - pparams->cl_viewangles[PITCH];

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 128				; 00000080H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR [ecx+124]
	fsub	DWORD PTR [eax]
	fstp	DWORD PTR _delta$[ebp]

; 293  : 
; 294  : 	if( !delta )

	fld	DWORD PTR _delta$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L71387

; 296  : 		pd.pitchvel = 0;

	mov	DWORD PTR ?pd@@3U__unnamed@@A, 0

; 297  : 		return;

	jmp	$L71379
$L71387:

; 299  : 
; 300  : 	float move = pparams->frametime * pd.pitchvel;

	mov	edx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR ?pd@@3U__unnamed@@A
	fmul	DWORD PTR [edx+60]
	fstp	DWORD PTR _move$[ebp]

; 301  : 	pd.pitchvel += pparams->frametime * v_centerspeed->value;

	mov	eax, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR ?v_centerspeed@@3PAUcvar_s@@A ; v_centerspeed
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR [ecx+12]
	fadd	DWORD PTR ?pd@@3U__unnamed@@A
	fstp	DWORD PTR ?pd@@3U__unnamed@@A

; 302  : 	
; 303  : 	if( delta > 0 )

	fld	DWORD PTR _delta$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71389

; 305  : 		if( move > delta )

	fld	DWORD PTR _move$[ebp]
	fcomp	DWORD PTR _delta$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71390

; 307  : 			pd.pitchvel = 0;

	mov	DWORD PTR ?pd@@3U__unnamed@@A, 0

; 308  : 			move = delta;

	mov	edx, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _move$[ebp], edx
$L71390:

; 310  : 
; 311  : 		pparams->cl_viewangles[PITCH] += move;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 128				; 00000080H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR -12+[ebp], eax
	mov	eax, DWORD PTR -12+[ebp]
	fld	DWORD PTR _move$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR -12+[ebp]
	fstp	DWORD PTR [ecx]

; 313  : 	else if( delta < 0 )

	jmp	SHORT $L71392
$L71389:
	fld	DWORD PTR _delta$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71392

; 315  : 		if( move > -delta )

	fld	DWORD PTR _delta$[ebp]
	fchs
	fcomp	DWORD PTR _move$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71393

; 317  : 			pd.pitchvel = 0;

	mov	DWORD PTR ?pd@@3U__unnamed@@A, 0

; 318  : 			move = -delta;

	fld	DWORD PTR _delta$[ebp]
	fchs
	fstp	DWORD PTR _move$[ebp]
$L71393:

; 320  : 
; 321  : 		pparams->cl_viewangles[PITCH] -= move;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 128				; 00000080H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR -16+[ebp], eax
	mov	edx, DWORD PTR -16+[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR _move$[ebp]
	mov	eax, DWORD PTR -16+[ebp]
	fstp	DWORD PTR [eax]
$L71392:
$L71379:

; 323  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_DriftPitch@@YAXPAUref_params_s@@@Z ENDP		; V_DriftPitch
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
PUBLIC	__real@4@3ffd8000000000000000
PUBLIC	__real@4@3ffe8000000000000000
PUBLIC	?V_CalcGunAngle@@YAXPAUref_params_s@@@Z		; V_CalcGunAngle
;	COMDAT __real@4@3ffd8000000000000000
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
__real@4@3ffd8000000000000000 DD 03e800000r	; 0.25
CONST	ENDS
;	COMDAT __real@4@3ffe8000000000000000
CONST	SEGMENT
__real@4@3ffe8000000000000000 DD 03f000000r	; 0.5
CONST	ENDS
;	COMDAT ?V_CalcGunAngle@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT
_pparams$ = 8
_viewent$ = -4
?V_CalcGunAngle@@YAXPAUref_params_s@@@Z PROC NEAR	; V_CalcGunAngle, COMDAT

; 329  : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi

; 330  : 	cl_entity_t *viewent;
; 331  : 	
; 332  : 	viewent = GET_VIEWMODEL();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+208
	mov	DWORD PTR _viewent$[ebp], eax

; 333  : 	if( !viewent ) return;

	cmp	DWORD PTR _viewent$[ebp], 0
	jne	SHORT $L71398
	jmp	$L71396
$L71398:

; 334  : 
; 335  : 	viewent->angles[YAW] = pparams->viewangles[YAW] + pparams->crosshairangle[YAW];

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 144				; 00000090H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _viewent$[ebp]
	add	ecx, 2900				; 00000b54H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -8+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 336  : 	viewent->angles[PITCH] = pparams->viewangles[PITCH] + pparams->crosshairangle[PITCH] * 0.25f;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 144				; 00000090H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax]
	fmul	DWORD PTR __real@4@3ffd8000000000000000
	fadd	DWORD PTR [esi]
	fstp	DWORD PTR -12+[ebp]
	mov	ecx, DWORD PTR _viewent$[ebp]
	add	ecx, 2900				; 00000b54H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -12+[ebp]
	mov	DWORD PTR [eax], edx

; 337  : 	viewent->angles[ROLL] -= v_idlescale * sin( pparams->time * v_iroll_cycle.value ) * v_iroll_level.value;

	mov	ecx, DWORD PTR _viewent$[ebp]
	add	ecx, 2900				; 00000b54H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -16+[ebp], eax
	mov	eax, DWORD PTR -16+[ebp]
	fld	DWORD PTR [eax]
	fstp	QWORD PTR -24+[ebp]
	fld	DWORD PTR ?v_idlescale@@3MA		; v_idlescale
	fstp	QWORD PTR -32+[ebp]
	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR ?v_iroll_cycle@@3Ucvar_s@@A+12
	fmul	DWORD PTR [ecx+64]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sin
	add	esp, 8
	fmul	QWORD PTR -32+[ebp]
	fmul	DWORD PTR ?v_iroll_level@@3Ucvar_s@@A+12
	fsubr	QWORD PTR -24+[ebp]
	mov	edx, DWORD PTR -16+[ebp]
	fstp	DWORD PTR [edx]

; 338  : 	
; 339  : 	// don't apply all of the v_ipitch to prevent normally unseen parts of viewmodel from coming into view.
; 340  : 	viewent->angles[PITCH] -= v_idlescale * sin( pparams->time*v_ipitch_cycle.value ) * (v_ipitch_level.value * 0.5f);

	mov	ecx, DWORD PTR _viewent$[ebp]
	add	ecx, 2900				; 00000b54H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR -36+[ebp], eax
	mov	eax, DWORD PTR -36+[ebp]
	fld	DWORD PTR [eax]
	fstp	QWORD PTR -44+[ebp]
	fld	DWORD PTR ?v_idlescale@@3MA		; v_idlescale
	fstp	QWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR ?v_ipitch_cycle@@3Ucvar_s@@A+12
	fmul	DWORD PTR [ecx+64]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sin
	add	esp, 8
	fmul	QWORD PTR -52+[ebp]
	fld	DWORD PTR ?v_ipitch_level@@3Ucvar_s@@A+12
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fmulp	ST(1), ST(0)
	fsubr	QWORD PTR -44+[ebp]
	mov	edx, DWORD PTR -36+[ebp]
	fstp	DWORD PTR [edx]

; 341  : 	viewent->angles[YAW] -= v_idlescale * sin( pparams->time*v_iyaw_cycle.value ) * v_iyaw_level.value;

	mov	ecx, DWORD PTR _viewent$[ebp]
	add	ecx, 2900				; 00000b54H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 4
	mov	DWORD PTR -56+[ebp], eax
	mov	eax, DWORD PTR -56+[ebp]
	fld	DWORD PTR [eax]
	fstp	QWORD PTR -64+[ebp]
	fld	DWORD PTR ?v_idlescale@@3MA		; v_idlescale
	fstp	QWORD PTR -72+[ebp]
	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR ?v_iyaw_cycle@@3Ucvar_s@@A+12
	fmul	DWORD PTR [ecx+64]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sin
	add	esp, 8
	fmul	QWORD PTR -72+[ebp]
	fmul	DWORD PTR ?v_iyaw_level@@3Ucvar_s@@A+12
	fsubr	QWORD PTR -64+[ebp]
	mov	edx, DWORD PTR -56+[ebp]
	fstp	DWORD PTR [edx]

; 342  : 
; 343  : 	viewent->latched.prevangles = viewent->angles;

	mov	eax, DWORD PTR _viewent$[ebp]
	add	eax, 2900				; 00000b54H
	mov	ecx, DWORD PTR _viewent$[ebp]
	add	ecx, 2856				; 00000b28H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 344  : 	viewent->curstate.angles = viewent->angles;

	mov	ecx, DWORD PTR _viewent$[ebp]
	add	ecx, 2900				; 00000b54H
	mov	edx, DWORD PTR _viewent$[ebp]
	add	edx, 716				; 000002ccH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
$L71396:

; 345  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_CalcGunAngle@@YAXPAUref_params_s@@@Z ENDP		; V_CalcGunAngle
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	__real@4@4006b400000000000000
PUBLIC	__real@4@4007b400000000000000
PUBLIC	__real@4@c006b400000000000000
PUBLIC	__real@4@3ffa8f5c290000000000
PUBLIC	__real@4@3ff9f5c28f0000000000
PUBLIC	__real@4@3ff9a3d70a0000000000
PUBLIC	?V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV2@@Z ; V_CalcViewModelLag
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?m_vecLastFacing@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4V3@A DB 0cH DUP (?)
_?$S11@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@4@4006b400000000000000
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
__real@4@4006b400000000000000 DD 043340000r	; 180
CONST	ENDS
;	COMDAT __real@4@4007b400000000000000
CONST	SEGMENT
__real@4@4007b400000000000000 DD 043b40000r	; 360
CONST	ENDS
;	COMDAT __real@4@c006b400000000000000
CONST	SEGMENT
__real@4@c006b400000000000000 DD 0c3340000r	; -180
CONST	ENDS
;	COMDAT __real@4@3ffa8f5c290000000000
CONST	SEGMENT
__real@4@3ffa8f5c290000000000 DD 03d0f5c29r	; 0.035
CONST	ENDS
;	COMDAT __real@4@3ff9f5c28f0000000000
CONST	SEGMENT
__real@4@3ff9f5c28f0000000000 DD 03cf5c28fr	; 0.03
CONST	ENDS
;	COMDAT __real@4@3ff9a3d70a0000000000
CONST	SEGMENT
__real@4@3ff9a3d70a0000000000 DD 03ca3d70ar	; 0.02
CONST	ENDS
;	COMDAT ?V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV2@@Z
_TEXT	SEGMENT
$T72265 = -100
$T72266 = -112
$T72267 = -124
$T72268 = -136
$T72269 = -148
$T72270 = -160
$T72271 = -172
$T72272 = -184
$T72273 = -196
$T72274 = -208
$T72275 = -220
$T72276 = -232
$T72277 = -244
_pparams$ = 8
_origin$ = 12
_angles$ = 16
_original_angles$ = 20
_vOriginalOrigin$ = -12
_vOriginalAngles$ = -24
_forward$ = -36
_right$ = -48
_up$ = -60
_vDifference$71417 = -72
_flSpeed$71419 = -76
_flDiff$71420 = -80
_flScale$71422 = -84
_pitch$ = -88
?V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV2@@Z PROC NEAR ; V_CalcViewModelLag, COMDAT

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	push	ebx
	push	esi
	push	edi

; 352  : 	static Vector m_vecLastFacing;

	xor	eax, eax
	mov	al, BYTE PTR _?$S11@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L71409
	mov	cl, BYTE PTR _?$S11@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S11@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4EA, cl
	mov	ecx, OFFSET FLAT:_?m_vecLastFacing@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4V3@A
	call	??0Vector@@QAE@XZ			; Vector::Vector
	push	OFFSET FLAT:_$E12
	call	_atexit
	add	esp, 4
$L71409:

; 353  : 	Vector vOriginalOrigin = origin;

	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	lea	ecx, DWORD PTR _vOriginalOrigin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 354  : 	Vector vOriginalAngles = angles;

	mov	eax, DWORD PTR _angles$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vOriginalAngles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 355  : 
; 356  : 	// Calculate our drift
; 357  : 	Vector forward, right, up;

	lea	ecx, DWORD PTR _forward$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _right$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _up$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 358  : 
; 359  : 	AngleVectors( angles, forward, right, up );

	lea	ecx, DWORD PTR _up$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _right$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _forward$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+96
	add	esp, 16					; 00000010H

; 360  : 
; 361  : 	if( pparams->frametime != 0.0f )	// not in paused

	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR [ecx+60]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L71416

; 363  : 		Vector vDifference;

	lea	ecx, DWORD PTR _vDifference$71417[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 364  : 
; 365  : 		vDifference = forward - m_vecLastFacing;

	push	OFFSET FLAT:_?m_vecLastFacing@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4V3@A
	lea	edx, DWORD PTR $T72265[ebp]
	push	edx
	lea	ecx, DWORD PTR _forward$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vDifference$71417[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vDifference$71417[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vDifference$71417[ebp+8], eax

; 366  : 
; 367  : 		float flSpeed = 5.0f;

	mov	DWORD PTR _flSpeed$71419[ebp], 1084227584 ; 40a00000H

; 368  : 
; 369  : 		// If we start to lag too far behind, we'll increase the "catch up" speed.
; 370  : 		// Solves the problem with fast cl_yawspeed, m_yaw or joysticks rotating quickly.
; 371  : 		// The old code would slam lastfacing with origin causing the viewmodel to pop to a new position
; 372  : 		float flDiff = vDifference.Length();

	lea	ecx, DWORD PTR _vDifference$71417[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flDiff$71420[ebp]

; 373  : 
; 374  : 		if(( flDiff > cl_weaponlag->value ) && ( cl_weaponlag->value > 0.0f ))

	mov	ecx, DWORD PTR ?cl_weaponlag@@3PAUcvar_s@@A ; cl_weaponlag
	fld	DWORD PTR _flDiff$71420[ebp]
	fcomp	DWORD PTR [ecx+12]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71421
	mov	edx, DWORD PTR ?cl_weaponlag@@3PAUcvar_s@@A ; cl_weaponlag
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71421

; 376  : 			float flScale = flDiff / cl_weaponlag->value;

	mov	eax, DWORD PTR ?cl_weaponlag@@3PAUcvar_s@@A ; cl_weaponlag
	fld	DWORD PTR _flDiff$71420[ebp]
	fdiv	DWORD PTR [eax+12]
	fstp	DWORD PTR _flScale$71422[ebp]

; 377  : 			flSpeed *= flScale;

	fld	DWORD PTR _flSpeed$71419[ebp]
	fmul	DWORD PTR _flScale$71422[ebp]
	fstp	DWORD PTR _flSpeed$71419[ebp]
$L71421:

; 379  : 
; 380  : 		// FIXME:  Needs to be predictable?
; 381  : 		m_vecLastFacing = m_vecLastFacing + vDifference * ( flSpeed * pparams->frametime );

	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR _flSpeed$71419[ebp]
	fmul	DWORD PTR [ecx+60]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR $T72266[ebp]
	push	edx
	lea	ecx, DWORD PTR _vDifference$71417[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T72267[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:_?m_vecLastFacing@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4V3@A
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _?m_vecLastFacing@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4V3@A, ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _?m_vecLastFacing@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4V3@A+4, edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _?m_vecLastFacing@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4V3@A+8, eax

; 382  : 		// Make sure it doesn't grow out of control!!!
; 383  : 		m_vecLastFacing = m_vecLastFacing.Normalize();

	lea	ecx, DWORD PTR $T72268[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:_?m_vecLastFacing@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4V3@A
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _?m_vecLastFacing@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4V3@A, edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _?m_vecLastFacing@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4V3@A+4, ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _?m_vecLastFacing@?1??V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV3@@Z@4V3@A+8, edx

; 384  : 		origin = origin + (vDifference * -1.0f) * flSpeed;

	mov	eax, DWORD PTR _flSpeed$71419[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72270[ebp]
	push	ecx
	push	-1082130432				; bf800000H
	lea	edx, DWORD PTR $T72269[ebp]
	push	edx
	lea	ecx, DWORD PTR _vDifference$71417[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T72271[ebp]
	push	eax
	mov	ecx, DWORD PTR _origin$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L71416:

; 386  : 
; 387  : 	AngleVectors( original_angles, forward, right, up );

	lea	ecx, DWORD PTR _up$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _right$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _forward$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _original_angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+96
	add	esp, 16					; 00000010H

; 388  : 
; 389  : 	float pitch = original_angles[PITCH];

	mov	ecx, DWORD PTR _original_angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pitch$[ebp], ecx

; 390  : 
; 391  : 	if( pitch > 180.0f )

	fld	DWORD PTR _pitch$[ebp]
	fcomp	DWORD PTR __real@4@4006b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71430

; 393  : 		pitch -= 360.0f;

	fld	DWORD PTR _pitch$[ebp]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _pitch$[ebp]

; 395  : 	else if( pitch < -180.0f )

	jmp	SHORT $L71432
$L71430:
	fld	DWORD PTR _pitch$[ebp]
	fcomp	DWORD PTR __real@4@c006b400000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71432

; 397  : 		pitch += 360.0f;

	fld	DWORD PTR _pitch$[ebp]
	fadd	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _pitch$[ebp]
$L71432:

; 399  : 
; 400  : 	if( cl_weaponlag->value <= 0.0f )

	mov	edx, DWORD PTR ?cl_weaponlag@@3PAUcvar_s@@A ; cl_weaponlag
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L71433

; 402  : 		origin = vOriginalOrigin;

	mov	eax, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR _vOriginalOrigin$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vOriginalOrigin$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vOriginalOrigin$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 403  : 		angles = vOriginalAngles;

	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR _vOriginalAngles$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _vOriginalAngles$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _vOriginalAngles$[ebp+8]
	mov	DWORD PTR [edx+8], eax

; 405  : 	else

	jmp	$L71434
$L71433:

; 407  : 		// FIXME: These are the old settings that caused too many exposed polys on some models
; 408  : 		origin = origin + forward * ( -pitch * 0.035f );

	fld	DWORD PTR _pitch$[ebp]
	fchs
	fmul	DWORD PTR __real@4@3ffa8f5c290000000000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T72272[ebp]
	push	ecx
	lea	ecx, DWORD PTR _forward$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T72273[ebp]
	push	edx
	mov	ecx, DWORD PTR _origin$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 409  : 		origin = origin + right * ( -pitch * 0.03f );

	fld	DWORD PTR _pitch$[ebp]
	fchs
	fmul	DWORD PTR __real@4@3ff9f5c28f0000000000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T72274[ebp]
	push	ecx
	lea	ecx, DWORD PTR _right$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T72275[ebp]
	push	edx
	mov	ecx, DWORD PTR _origin$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 410  : 		origin = origin + up * ( -pitch * 0.02f );

	fld	DWORD PTR _pitch$[ebp]
	fchs
	fmul	DWORD PTR __real@4@3ff9a3d70a0000000000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T72276[ebp]
	push	ecx
	lea	ecx, DWORD PTR _up$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T72277[ebp]
	push	edx
	mov	ecx, DWORD PTR _origin$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L71434:

; 412  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV2@@Z ENDP ; V_CalcViewModelLag
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T72294 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T72294[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T72299 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T72299[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T72302 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T72302[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QBEPBMXZ PROC NEAR				; Vector::operator float const *, COMDAT

; 229  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_flLen$ = -8
$T72309 = -20
?Normalize@Vector@@QBE?AV1@XZ PROC NEAR			; Vector::Normalize, COMDAT

; 232  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 234  : 
; 235  : 		if( flLen )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L54765

; 237  : 			flLen = 1.0f / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 238  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T72309[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L54763
$L54765:

; 240  : 
; 241  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L54763:

; 242  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
;	COMDAT _$E12
_TEXT	SEGMENT
_$E12	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E12	ENDP
_TEXT	ENDS
PUBLIC	?V_AddIdle@@YAXPAUref_params_s@@@Z		; V_AddIdle
;	COMDAT ?V_AddIdle@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT
_pparams$ = 8
?V_AddIdle@@YAXPAUref_params_s@@@Z PROC NEAR		; V_AddIdle, COMDAT

; 418  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 419  : 	pparams->viewangles[ROLL] += v_idlescale * sin(pparams->time*v_iroll_cycle.value) * v_iroll_level.value;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -4+[ebp], eax
	mov	eax, DWORD PTR -4+[ebp]
	fld	DWORD PTR [eax]
	fstp	QWORD PTR -12+[ebp]
	fld	DWORD PTR ?v_idlescale@@3MA		; v_idlescale
	fstp	QWORD PTR -20+[ebp]
	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR ?v_iroll_cycle@@3Ucvar_s@@A+12
	fmul	DWORD PTR [ecx+64]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sin
	add	esp, 8
	fmul	QWORD PTR -20+[ebp]
	fmul	DWORD PTR ?v_iroll_level@@3Ucvar_s@@A+12
	fadd	QWORD PTR -12+[ebp]
	mov	edx, DWORD PTR -4+[ebp]
	fstp	DWORD PTR [edx]

; 420  : 	pparams->viewangles[PITCH] += v_idlescale * sin(pparams->time*v_ipitch_cycle.value) * v_ipitch_level.value;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR -24+[ebp], eax
	mov	eax, DWORD PTR -24+[ebp]
	fld	DWORD PTR [eax]
	fstp	QWORD PTR -32+[ebp]
	fld	DWORD PTR ?v_idlescale@@3MA		; v_idlescale
	fstp	QWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR ?v_ipitch_cycle@@3Ucvar_s@@A+12
	fmul	DWORD PTR [ecx+64]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sin
	add	esp, 8
	fmul	QWORD PTR -40+[ebp]
	fmul	DWORD PTR ?v_ipitch_level@@3Ucvar_s@@A+12
	fadd	QWORD PTR -32+[ebp]
	mov	edx, DWORD PTR -24+[ebp]
	fstp	DWORD PTR [edx]

; 421  : 	pparams->viewangles[YAW] += v_idlescale * sin(pparams->time*v_iyaw_cycle.value) * v_iyaw_level.value;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 4
	mov	DWORD PTR -44+[ebp], eax
	mov	eax, DWORD PTR -44+[ebp]
	fld	DWORD PTR [eax]
	fstp	QWORD PTR -52+[ebp]
	fld	DWORD PTR ?v_idlescale@@3MA		; v_idlescale
	fstp	QWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR ?v_iyaw_cycle@@3Ucvar_s@@A+12
	fmul	DWORD PTR [ecx+64]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sin
	add	esp, 8
	fmul	QWORD PTR -60+[ebp]
	fmul	DWORD PTR ?v_iyaw_level@@3Ucvar_s@@A+12
	fadd	QWORD PTR -52+[ebp]
	mov	edx, DWORD PTR -44+[ebp]
	fstp	DWORD PTR [edx]

; 422  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_AddIdle@@YAXPAUref_params_s@@@Z ENDP			; V_AddIdle
_TEXT	ENDS
PUBLIC	?DotProduct@@YAMABVVector@@0@Z			; DotProduct
PUBLIC	?V_CalcViewRoll@@YAXPAUref_params_s@@@Z		; V_CalcViewRoll
;	COMDAT ?V_CalcViewRoll@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT
_pparams$ = 8
_sign$ = -4
_side$ = -8
_value$ = -12
_right$ = -24
_viewentity$ = -28
?V_CalcViewRoll@@YAXPAUref_params_s@@@Z PROC NEAR	; V_CalcViewRoll, COMDAT

; 428  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 429  : 	float   sign, side, value;
; 430  : 	Vector  right;

	lea	ecx, DWORD PTR _right$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 431  : 	
; 432  : 	cl_entity_t *viewentity = GET_ENTITY( pparams->viewentity );

	mov	eax, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	push	ecx
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR _viewentity$[ebp], eax

; 433  : 	if( !viewentity ) return;

	cmp	DWORD PTR _viewentity$[ebp], 0
	jne	SHORT $L71453
	jmp	$L71447
$L71453:

; 434  : 
; 435  : 	AngleVectors( viewentity->angles, NULL, right, NULL );

	push	0
	lea	ecx, DWORD PTR _right$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	push	0
	mov	ecx, DWORD PTR _viewentity$[ebp]
	add	ecx, 2900				; 00000b54H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+96
	add	esp, 16					; 00000010H

; 436  : 	side = DotProduct( pparams->simvel, right );

	lea	edx, DWORD PTR _right$[ebp]
	push	edx
	mov	eax, DWORD PTR _pparams$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fst	DWORD PTR _side$[ebp]

; 437  : 	sign = side < 0 ? -1 : 1;

	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72316
	mov	DWORD PTR -32+[ebp], -1
	jmp	SHORT $L72317
$L72316:
	mov	DWORD PTR -32+[ebp], 1
$L72317:
	fild	DWORD PTR -32+[ebp]
	fstp	DWORD PTR _sign$[ebp]

; 438  : 	side = fabs( side );

	fld	DWORD PTR _side$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _side$[ebp]

; 439  : 	value = pparams->movevars->rollangle;

	mov	ecx, DWORD PTR _pparams$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR _value$[ebp], eax

; 440  : 
; 441  : 	if( side < pparams->movevars->rollspeed )

	mov	ecx, DWORD PTR _pparams$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	fld	DWORD PTR _side$[ebp]
	fcomp	DWORD PTR [edx+104]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71454

; 442  : 		side = side * value / pparams->movevars->rollspeed;

	fld	DWORD PTR _side$[ebp]
	fmul	DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	fdiv	DWORD PTR [ecx+104]
	fstp	DWORD PTR _side$[ebp]

; 443  : 	else side = value;

	jmp	SHORT $L71455
$L71454:
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _side$[ebp], edx
$L71455:

; 444  : 
; 445  : 	side = side * sign;		

	fld	DWORD PTR _side$[ebp]
	fmul	DWORD PTR _sign$[ebp]
	fstp	DWORD PTR _side$[ebp]

; 446  : 	pparams->viewangles[ROLL] += side;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -36+[ebp], eax
	mov	eax, DWORD PTR -36+[ebp]
	fld	DWORD PTR _side$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR -36+[ebp]
	fstp	DWORD PTR [ecx]

; 447  : 
; 448  : 	if( pparams->health <= 0 && ( pparams->viewheight[2] != 0 ))

	mov	edx, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [edx+140], 0
	jg	SHORT $L71456
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 112				; 00000070H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L71456

; 450  : 		// only roll the view if the player is dead and the viewheight[2] is nonzero 
; 451  : 		// this is so deadcam in multiplayer will work.
; 452  : 		pparams->viewangles[ROLL] = 80; // dead view angle

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 1117782016		; 42a00000H
$L71456:
$L71447:

; 455  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_CalcViewRoll@@YAXPAUref_params_s@@@Z ENDP		; V_CalcViewRoll
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProduct@@YAMABVVector@@0@Z PROC NEAR		; DotProduct, COMDAT

; 289  : inline float DotProduct(const Vector& a, const Vector& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector@@0@Z ENDP			; DotProduct
_TEXT	ENDS
PUBLIC	__real@4@3ffa8000000000000000
PUBLIC	?V_CalcSendOrigin@@YAXPAUref_params_s@@@Z	; V_CalcSendOrigin
;	COMDAT __real@4@3ffa8000000000000000
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
__real@4@3ffa8000000000000000 DD 03d000000r	; 0.03125
CONST	ENDS
;	COMDAT ?V_CalcSendOrigin@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT
_pparams$ = 8
?V_CalcSendOrigin@@YAXPAUref_params_s@@@Z PROC NEAR	; V_CalcSendOrigin, COMDAT

; 461  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 462  : 	// never let view origin sit exactly on a node line, because a water plane can
; 463  : 	// dissapear when viewed with the eye exactly on it.
; 464  : 	// FIXME, we send origin at 1/128 now, change this?
; 465  : 	// the server protocol only specifies to 1/16 pixel, so add 1/32 in each axis
; 466  : 	pparams->vieworg[0] += 1.0f / 32;

	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR -4+[ebp], eax
	mov	eax, DWORD PTR -4+[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@3ffa8000000000000000
	mov	ecx, DWORD PTR -4+[ebp]
	fstp	DWORD PTR [ecx]

; 467  : 	pparams->vieworg[1] += 1.0f / 32;

	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 4
	mov	DWORD PTR -8+[ebp], eax
	mov	edx, DWORD PTR -8+[ebp]
	fld	DWORD PTR [edx]
	fadd	DWORD PTR __real@4@3ffa8000000000000000
	mov	eax, DWORD PTR -8+[ebp]
	fstp	DWORD PTR [eax]

; 468  : 	pparams->vieworg[2] += 1.0f / 32;

	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -12+[ebp], eax
	mov	ecx, DWORD PTR -12+[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@3ffa8000000000000000
	mov	edx, DWORD PTR -12+[ebp]
	fstp	DWORD PTR [edx]

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_CalcSendOrigin@@YAXPAUref_params_s@@@Z ENDP		; V_CalcSendOrigin
_TEXT	ENDS
PUBLIC	??GVector@@QBE?AV0@XZ				; Vector::operator-
PUBLIC	?V_GetChaseOrigin@@YAXABVVector@@0MAAV1@@Z	; V_GetChaseOrigin
EXTRN	?PM_GetPhysEntInfo@@YAHH@Z:NEAR			; PM_GetPhysEntInfo
;	COMDAT ?V_GetChaseOrigin@@YAXABVVector@@0MAAV1@@Z
_TEXT	SEGMENT
$T72326 = -88
$T72327 = -100
$T72328 = -112
$T72329 = -124
$T72330 = -136
$T72331 = -148
_angles$ = 8
_origin$ = 12
_distance$ = 16
_returnvec$ = 20
_vecStart$ = -12
_vecEnd$ = -24
_trace$ = -28
_maxLoops$ = -32
_forward$ = -44
_right$ = -56
_up$ = -68
_ignoreent$ = -72
_ent$ = -76
?V_GetChaseOrigin@@YAXABVVector@@0MAAV1@@Z PROC NEAR	; V_GetChaseOrigin, COMDAT

; 475  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi

; 476  : 	Vector vecStart, vecEnd;

	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 477  : 	pmtrace_t *trace;
; 478  : 	int maxLoops = 8;

	mov	DWORD PTR _maxLoops$[ebp], 8

; 479  : 
; 480  : 	Vector forward, right, up;	

	lea	ecx, DWORD PTR _forward$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _right$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _up$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 481  : 
; 482  : 	// trace back from the target using the player's view angles
; 483  : 	AngleVectors( angles, forward, right, up );

	lea	ecx, DWORD PTR _up$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _right$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _forward$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+96
	add	esp, 16					; 00000010H

; 484  : 	forward = -forward;

	lea	eax, DWORD PTR $T72326[ebp]
	push	eax
	lea	ecx, DWORD PTR _forward$[ebp]
	call	??GVector@@QBE?AV0@XZ			; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _forward$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _forward$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _forward$[ebp+8], eax

; 485  : 
; 486  : 	vecStart = origin;

	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _vecStart$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _vecStart$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _vecStart$[ebp+8], ecx

; 487  : 	vecEnd = vecStart + forward * distance;

	mov	edx, DWORD PTR _distance$[ebp]
	push	edx
	lea	eax, DWORD PTR $T72327[ebp]
	push	eax
	lea	ecx, DWORD PTR _forward$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T72328[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecEnd$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecEnd$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecEnd$[ebp+8], edx

; 488  : 
; 489  : 	int ignoreent = -1;	// first, ignore no entity

	mov	DWORD PTR _ignoreent$[ebp], -1

; 490  : 	cl_entity_t *ent = NULL;

	mov	DWORD PTR _ent$[ebp], 0
$L71479:

; 491  : 
; 492  : 	while( maxLoops > 0 )

	cmp	DWORD PTR _maxLoops$[ebp], 0
	jle	$L71480

; 494  : 		trace = gEngfuncs.PM_TraceLine( vecStart, vecEnd, PM_TRACELINE_PHYSENTSONLY, 2, ignoreent );

	mov	eax, DWORD PTR _ignoreent$[ebp]
	push	eax
	push	2
	push	0
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+236
	add	esp, 20					; 00000014H
	mov	DWORD PTR _trace$[ebp], eax

; 495  : 		if( trace->ent <= 0 ) break; // we hit the world or nothing, stop trace

	mov	ecx, DWORD PTR _trace$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jg	SHORT $L71481
	jmp	$L71480
$L71481:

; 496  : 
; 497  : 		ent = GET_ENTITY( PM_GetPhysEntInfo( trace->ent ));

	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	?PM_GetPhysEntInfo@@YAHH@Z		; PM_GetPhysEntInfo
	add	esp, 4
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 498  : 		if( ent == NULL ) break;

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $L71482
	jmp	SHORT $L71480
$L71482:

; 499  : 
; 500  : 		// hit non-player solid BSP, stop here
; 501  : 		if( ent->curstate.solid == SOLID_BSP && !ent->player )

	mov	ecx, DWORD PTR _ent$[ebp]
	movsx	edx, WORD PTR [ecx+746]
	cmp	edx, 4
	jne	SHORT $L71483
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L71483

; 502  : 			break;

	jmp	SHORT $L71480
$L71483:

; 503  : 
; 504  : 		// if close enought to end pos, stop, otherwise continue trace
; 505  : 		if(( vecEnd - trace->endpos ).Length() < 1.0f )

	mov	ecx, DWORD PTR _trace$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	lea	edx, DWORD PTR $T72329[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71485

; 507  : 			break;

	jmp	SHORT $L71480
$L71485:

; 511  : 			ignoreent = trace->ent;	// ignore last hit entity

	mov	eax, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _ignoreent$[ebp], ecx

; 512  : 			vecStart = trace->endpos;

	mov	edx, DWORD PTR _trace$[ebp]
	add	edx, 20					; 00000014H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _vecStart$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _vecStart$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _vecStart$[ebp+8], edx

; 514  : 		maxLoops--;

	mov	eax, DWORD PTR _maxLoops$[ebp]
	sub	eax, 1
	mov	DWORD PTR _maxLoops$[ebp], eax

; 515  : 	}  

	jmp	$L71479
$L71480:

; 516  : 
; 517  : 	returnvec = trace->endpos + trace->plane.normal * 8;

	push	1090519040				; 41000000H
	lea	ecx, DWORD PTR $T72330[ebp]
	push	ecx
	mov	ecx, DWORD PTR _trace$[ebp]
	add	ecx, 32					; 00000020H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T72331[ebp]
	push	edx
	mov	ecx, DWORD PTR _trace$[ebp]
	add	ecx, 20					; 00000014H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _returnvec$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 518  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_GetChaseOrigin@@YAXABVVector@@0MAAV1@@Z ENDP		; V_GetChaseOrigin
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T72334 = -16
??GVector@@QBE?AV0@XZ PROC NEAR				; Vector::operator-, COMDAT

; 146  : 	inline Vector operator-(void) const		{ return Vector(-x,-y,-z);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T72334[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??GVector@@QBE?AV0@XZ ENDP				; Vector::operator-
_TEXT	ENDS
PUBLIC	__real@4@bfff8000000000000000
PUBLIC	?RemapAngleRange@@YAMMMMPAW4RemapAngleRange_CurvePart_t@@@Z ; RemapAngleRange
PUBLIC	?SimpleSpline@@YAMM@Z				; SimpleSpline
EXTRN	?AngleNormalize@@YAMM@Z:NEAR			; AngleNormalize
;	COMDAT __real@4@bfff8000000000000000
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
__real@4@bfff8000000000000000 DD 0bf800000r	; -1
CONST	ENDS
;	COMDAT ?RemapAngleRange@@YAMMMMPAW4RemapAngleRange_CurvePart_t@@@Z
_TEXT	SEGMENT
_startInterval$ = 8
_endInterval$ = 12
_value$ = 16
_peCurvePart$ = 20
_absAngle$ = -4
_newAngle$71500 = -8
?RemapAngleRange@@YAMMMMPAW4RemapAngleRange_CurvePart_t@@@Z PROC NEAR ; RemapAngleRange, COMDAT

; 525  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 526  : 	// Fixup the roll
; 527  : 	value = AngleNormalize( value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	?AngleNormalize@@YAMM@Z			; AngleNormalize
	add	esp, 4
	fst	DWORD PTR _value$[ebp]

; 528  : 	float absAngle = fabs(value);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _absAngle$[ebp]

; 529  : 
; 530  : 	// beneath cutoff?
; 531  : 	if( absAngle < startInterval )

	fld	DWORD PTR _absAngle$[ebp]
	fcomp	DWORD PTR _startInterval$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71496

; 533  : 		if( peCurvePart )

	cmp	DWORD PTR _peCurvePart$[ebp], 0
	je	SHORT $L71497

; 535  : 			*peCurvePart = RemapAngleRange_CurvePart_Zero;

	mov	ecx, DWORD PTR _peCurvePart$[ebp]
	mov	DWORD PTR [ecx], 0
$L71497:

; 537  : 		value = 0;

	mov	DWORD PTR _value$[ebp], 0

; 539  : 	// in spline range?
; 540  : 	else if( absAngle <= endInterval )

	jmp	SHORT $L71504
$L71496:
	fld	DWORD PTR _absAngle$[ebp]
	fcomp	DWORD PTR _endInterval$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L71499

; 542  : 		float newAngle = SimpleSpline(( absAngle - startInterval ) / ( endInterval-startInterval )) * endInterval;

	fld	DWORD PTR _absAngle$[ebp]
	fsub	DWORD PTR _startInterval$[ebp]
	fld	DWORD PTR _endInterval$[ebp]
	fsub	DWORD PTR _startInterval$[ebp]
	fdivp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?SimpleSpline@@YAMM@Z			; SimpleSpline
	add	esp, 4
	fmul	DWORD PTR _endInterval$[ebp]
	fstp	DWORD PTR _newAngle$71500[ebp]

; 543  : 
; 544  : 		// grab the sign from the initial value
; 545  : 		if( value < 0 )

	fld	DWORD PTR _value$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71501

; 547  : 			newAngle *= -1;

	fld	DWORD PTR _newAngle$71500[ebp]
	fmul	DWORD PTR __real@4@bfff8000000000000000
	fstp	DWORD PTR _newAngle$71500[ebp]
$L71501:

; 549  : 
; 550  : 		if( peCurvePart )

	cmp	DWORD PTR _peCurvePart$[ebp], 0
	je	SHORT $L71502

; 552  : 			*peCurvePart = RemapAngleRange_CurvePart_Spline;

	mov	edx, DWORD PTR _peCurvePart$[ebp]
	mov	DWORD PTR [edx], 1
$L71502:

; 554  : 		value = newAngle;

	mov	eax, DWORD PTR _newAngle$71500[ebp]
	mov	DWORD PTR _value$[ebp], eax

; 556  : 	// else leave it alone, in linear range
; 557  : 	else if( peCurvePart )

	jmp	SHORT $L71504
$L71499:
	cmp	DWORD PTR _peCurvePart$[ebp], 0
	je	SHORT $L71504

; 559  : 		*peCurvePart = RemapAngleRange_CurvePart_Linear;

	mov	ecx, DWORD PTR _peCurvePart$[ebp]
	mov	DWORD PTR [ecx], 2
$L71504:

; 561  : 
; 562  : 	return value;

	fld	DWORD PTR _value$[ebp]

; 563  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemapAngleRange@@YAMMMMPAW4RemapAngleRange_CurvePart_t@@@Z ENDP ; RemapAngleRange
_TEXT	ENDS
PUBLIC	__real@4@4000c000000000000000
PUBLIC	__real@4@40008000000000000000
;	COMDAT __real@4@4000c000000000000000
; File z:\xashxtsrc\game_shared\mathlib.h
CONST	SEGMENT
__real@4@4000c000000000000000 DD 040400000r	; 3
CONST	ENDS
;	COMDAT __real@4@40008000000000000000
CONST	SEGMENT
__real@4@40008000000000000000 DD 040000000r	; 2
CONST	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT
_value$ = 8
_valueSquared$ = -4
?SimpleSpline@@YAMM@Z PROC NEAR				; SimpleSpline, COMDAT

; 229  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 230  : 	float valueSquared = value * value;

	fld	DWORD PTR _value$[ebp]
	fmul	DWORD PTR _value$[ebp]
	fstp	DWORD PTR _valueSquared$[ebp]

; 231  : 
; 232  : 	// Nice little ease-in, ease-out spline-like curve
; 233  : 	return (3 * valueSquared - 2 * valueSquared * value);

	fld	DWORD PTR __real@4@4000c000000000000000
	fmul	DWORD PTR _valueSquared$[ebp]
	fld	DWORD PTR __real@4@40008000000000000000
	fmul	DWORD PTR _valueSquared$[ebp]
	fmul	DWORD PTR _value$[ebp]
	fsubp	ST(1), ST(0)

; 234  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SimpleSpline@@YAMM@Z ENDP				; SimpleSpline
_TEXT	ENDS
PUBLIC	?RemapValClamped@@YAMMMMMM@Z			; RemapValClamped
PUBLIC	?ApplyViewLocking@@YAMPAUref_params_s@@MMAAUViewLockData_t@@W4RemapAngleRange_CurvePart_t@@@Z ; ApplyViewLocking
PUBLIC	??_C@_09IHBH@BLEND?5?$CFf?6?$AA@		; `string'
PUBLIC	?Lerp@@YAMMABM0@Z				; Lerp
PUBLIC	??_C@_08CPJ@CLAMPED?6?$AA@			; `string'
PUBLIC	??_C@_0O@FNNP@STILL?5LOCKED?6?$AA@		; `string'
;	COMDAT ??_C@_09IHBH@BLEND?5?$CFf?6?$AA@
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
??_C@_09IHBH@BLEND?5?$CFf?6?$AA@ DB 'BLEND %f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CPJ@CLAMPED?6?$AA@
CONST	SEGMENT
??_C@_08CPJ@CLAMPED?6?$AA@ DB 'CLAMPED', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FNNP@STILL?5LOCKED?6?$AA@
CONST	SEGMENT
??_C@_0O@FNNP@STILL?5LOCKED?6?$AA@ DB 'STILL LOCKED', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?ApplyViewLocking@@YAMPAUref_params_s@@MMAAUViewLockData_t@@W4RemapAngleRange_CurvePart_t@@@Z
_TEXT	SEGMENT
_params$ = 8
_flAngleRaw$ = 12
_flAngleClamped$ = 16
_lockData$ = 20
_eCurvePart$ = 24
_flAngleOut$ = -4
_flBlend$71522 = -8
?ApplyViewLocking@@YAMPAUref_params_s@@MMAAUViewLockData_t@@W4RemapAngleRange_CurvePart_t@@@Z PROC NEAR ; ApplyViewLocking, COMDAT

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 567  : 	// If we're set up to never lock this degree of freedom, return the clamped value.
; 568  : 	if( lockData.flLockInterval == 0 )

	mov	eax, DWORD PTR _lockData$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L71512

; 569  : 		return flAngleClamped;

	fld	DWORD PTR _flAngleClamped$[ebp]
	jmp	$L71511
$L71512:

; 570  : 
; 571  : 	float flAngleOut = flAngleClamped;

	mov	ecx, DWORD PTR _flAngleClamped$[ebp]
	mov	DWORD PTR _flAngleOut$[ebp], ecx

; 572  : 
; 573  : 	// Lock the view if we're in the linear part of the curve, and keep it locked
; 574  : 	// until some duration after we return to the flat (zero) part of the curve.
; 575  : 	if(( eCurvePart == RemapAngleRange_CurvePart_Linear ) || ( lockData.bLocked && ( eCurvePart == RemapAngleRange_CurvePart_Spline )))

	cmp	DWORD PTR _eCurvePart$[ebp], 2
	je	SHORT $L71515
	mov	edx, DWORD PTR _lockData$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+4]
	test	eax, eax
	je	SHORT $L71514
	cmp	DWORD PTR _eCurvePart$[ebp], 1
	jne	SHORT $L71514
$L71515:

; 577  : 		lockData.bLocked = true;

	mov	ecx, DWORD PTR _lockData$[ebp]
	mov	BYTE PTR [ecx+4], 1

; 578  : 		lockData.flUnlockTime = params->time + lockData.flLockInterval;

	mov	edx, DWORD PTR _params$[ebp]
	mov	eax, DWORD PTR _lockData$[ebp]
	fld	DWORD PTR [edx+64]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _lockData$[ebp]
	fstp	DWORD PTR [ecx+8]

; 579  : 		flAngleOut = flAngleRaw;

	mov	edx, DWORD PTR _flAngleRaw$[ebp]
	mov	DWORD PTR _flAngleOut$[ebp], edx

; 581  : 	else

	jmp	$L71533
$L71514:

; 583  : 		if(( lockData.bLocked ) && ( params->time > lockData.flUnlockTime ))

	mov	eax, DWORD PTR _lockData$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $L71519
	mov	edx, DWORD PTR _params$[ebp]
	mov	eax, DWORD PTR _lockData$[ebp]
	fld	DWORD PTR [edx+64]
	fcomp	DWORD PTR [eax+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71519

; 585  : 			lockData.bLocked = false;

	mov	ecx, DWORD PTR _lockData$[ebp]
	mov	BYTE PTR [ecx+4], 0

; 586  : 			if ( lockData.flUnlockBlendInterval > 0 )

	mov	edx, DWORD PTR _lockData$[ebp]
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71518

; 588  : 				lockData.flUnlockTime = params->time;

	mov	eax, DWORD PTR _lockData$[ebp]
	mov	ecx, DWORD PTR _params$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+8], edx

; 590  : 			else

	jmp	SHORT $L71519
$L71518:

; 592  : 				lockData.flUnlockTime = 0;

	mov	eax, DWORD PTR _lockData$[ebp]
	mov	DWORD PTR [eax+8], 0
$L71519:

; 595  : 
; 596  : 		if ( !lockData.bLocked )

	mov	ecx, DWORD PTR _lockData$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+4]
	test	edx, edx
	jne	$L71520

; 598  : 			if( lockData.flUnlockTime != 0 )

	mov	eax, DWORD PTR _lockData$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L71521

; 600  : 				// Blend out from the locked raw view (no remapping) to a remapped view.
; 601  : 				float flBlend = RemapValClamped( params->time-lockData.flUnlockTime, 0, lockData.flUnlockBlendInterval, 0, 1 );

	push	1065353216				; 3f800000H
	push	0
	mov	ecx, DWORD PTR _lockData$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	0
	mov	eax, DWORD PTR _params$[ebp]
	mov	ecx, DWORD PTR _lockData$[ebp]
	fld	DWORD PTR [eax+64]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?RemapValClamped@@YAMMMMMM@Z		; RemapValClamped
	add	esp, 20					; 00000014H
	fst	DWORD PTR _flBlend$71522[ebp]

; 602  : 				Msg( "BLEND %f\n", flBlend );

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_09IHBH@BLEND?5?$CFf?6?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+160
	add	esp, 12					; 0000000cH

; 603  : 
; 604  : 				flAngleOut = Lerp( flBlend, flAngleRaw, flAngleClamped );

	lea	edx, DWORD PTR _flAngleClamped$[ebp]
	push	edx
	lea	eax, DWORD PTR _flAngleRaw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flBlend$71522[ebp]
	push	ecx
	call	?Lerp@@YAMMABM0@Z			; Lerp
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _flAngleOut$[ebp]

; 605  : 
; 606  : 				if( flBlend >= 1.0f )

	fld	DWORD PTR _flBlend$71522[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L71530

; 608  : 					lockData.flUnlockTime = 0;

	mov	edx, DWORD PTR _lockData$[ebp]
	mov	DWORD PTR [edx+8], 0
$L71530:

; 611  : 			else

	jmp	SHORT $L71531
$L71521:

; 613  : 				// Not blending out from a locked view to a remapped view.
; 614  : 				Msg( "CLAMPED\n" );

	push	OFFSET FLAT:??_C@_08CPJ@CLAMPED?6?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+160
	add	esp, 4

; 615  : 				flAngleOut = flAngleClamped;

	mov	eax, DWORD PTR _flAngleClamped$[ebp]
	mov	DWORD PTR _flAngleOut$[ebp], eax
$L71531:

; 618  : 		else

	jmp	SHORT $L71533
$L71520:

; 620  : 			Msg( "STILL LOCKED\n" );

	push	OFFSET FLAT:??_C@_0O@FNNP@STILL?5LOCKED?6?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+160
	add	esp, 4

; 621  : 			flAngleOut = flAngleRaw;

	mov	ecx, DWORD PTR _flAngleRaw$[ebp]
	mov	DWORD PTR _flAngleOut$[ebp], ecx
$L71533:

; 624  : 
; 625  : 	return flAngleOut;

	fld	DWORD PTR _flAngleOut$[ebp]
$L71511:

; 626  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ApplyViewLocking@@YAMPAUref_params_s@@MMAAUViewLockData_t@@W4RemapAngleRange_CurvePart_t@@@Z ENDP ; ApplyViewLocking
_TEXT	ENDS
;	COMDAT ?RemapValClamped@@YAMMMMMM@Z
_TEXT	SEGMENT
_val$ = 8
_A$ = 12
_B$ = 16
_C$ = 20
_D$ = 24
_cVal$ = -4
?RemapValClamped@@YAMMMMMM@Z PROC NEAR			; RemapValClamped, COMDAT

; 97   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 98   : 	if( A == B ) return val >= B ? D : C;

	fld	DWORD PTR _A$[ebp]
	fcomp	DWORD PTR _B$[ebp]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L55985
	fld	DWORD PTR _val$[ebp]
	fcomp	DWORD PTR _B$[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L72349
	mov	eax, DWORD PTR _D$[ebp]
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L72350
$L72349:
	mov	ecx, DWORD PTR _C$[ebp]
	mov	DWORD PTR -8+[ebp], ecx
$L72350:
	fld	DWORD PTR -8+[ebp]
	jmp	SHORT $L55984
$L55985:

; 99   : 	float cVal = (val - A) / (B - A);

	fld	DWORD PTR _val$[ebp]
	fsub	DWORD PTR _A$[ebp]
	fld	DWORD PTR _B$[ebp]
	fsub	DWORD PTR _A$[ebp]
	fdivp	ST(1), ST(0)
	fst	DWORD PTR _cVal$[ebp]

; 100  : 	cVal = bound( 0.0f, cVal, 1.0f );

	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L72353
	fld	DWORD PTR _cVal$[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72351
	mov	edx, DWORD PTR _cVal$[ebp]
	mov	DWORD PTR -12+[ebp], edx
	jmp	SHORT $L72352
$L72351:
	mov	DWORD PTR -12+[ebp], 1065353216		; 3f800000H
$L72352:
	mov	eax, DWORD PTR -12+[ebp]
	mov	DWORD PTR -16+[ebp], eax
	jmp	SHORT $L72354
$L72353:
	mov	DWORD PTR -16+[ebp], 0
$L72354:
	mov	ecx, DWORD PTR -16+[ebp]
	mov	DWORD PTR _cVal$[ebp], ecx

; 101  : 
; 102  : 	return C + (D - C) * cVal;

	fld	DWORD PTR _D$[ebp]
	fsub	DWORD PTR _C$[ebp]
	fmul	DWORD PTR _cVal$[ebp]
	fadd	DWORD PTR _C$[ebp]
$L55984:

; 103  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemapValClamped@@YAMMMMMM@Z ENDP			; RemapValClamped
_TEXT	ENDS
PUBLIC	__real@8@4004f000000000000000
PUBLIC	?RemapViewAngles@@YAXPAUref_params_s@@PAUViewSmoothingData_t@@AAVVector@@@Z ; RemapViewAngles
;	COMDAT __real@8@4004f000000000000000
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
__real@8@4004f000000000000000 DQ 0404e000000000000r ; 60
CONST	ENDS
;	COMDAT ?RemapViewAngles@@YAXPAUref_params_s@@PAUViewSmoothingData_t@@AAVVector@@@Z
_TEXT	SEGMENT
_pparams$ = 8
_pData$ = 12
_vehicleEyeAngles$ = 16
_vecEyeAnglesRemapped$ = -12
_ePitchCurvePart$ = -16
_flBlendRoll$ = -20
_eRollCurvePart$ = -24
_flRollDamped$ = -28
?RemapViewAngles@@YAXPAUref_params_s@@PAUViewSmoothingData_t@@AAVVector@@@Z PROC NEAR ; RemapViewAngles, COMDAT

; 629  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 630  : 	Vector vecEyeAnglesRemapped;

	lea	ecx, DWORD PTR _vecEyeAnglesRemapped$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 631  : 
; 632  : 	// Clamp pitch.
; 633  : 	RemapAngleRange_CurvePart_t ePitchCurvePart;
; 634  : 	vecEyeAnglesRemapped.x = RemapAngleRange( pData->flPitchCurveZero, pData->flPitchCurveLinear, vehicleEyeAngles.x, &ePitchCurvePart );

	lea	eax, DWORD PTR _ePitchCurvePart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vehicleEyeAngles$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?RemapAngleRange@@YAMMMMPAW4RemapAngleRange_CurvePart_t@@@Z ; RemapAngleRange
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _vecEyeAnglesRemapped$[ebp]

; 635  : 
; 636  : 	vehicleEyeAngles.z = vecEyeAnglesRemapped.z = AngleNormalize( vehicleEyeAngles.z );

	mov	ecx, DWORD PTR _vehicleEyeAngles$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	?AngleNormalize@@YAMM@Z			; AngleNormalize
	add	esp, 4
	fstp	DWORD PTR _vecEyeAnglesRemapped$[ebp+8]
	mov	eax, DWORD PTR _vehicleEyeAngles$[ebp]
	mov	ecx, DWORD PTR _vecEyeAnglesRemapped$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 637  : 
; 638  : 	// Blend out the roll dampening as our pitch approaches 90 degrees, to avoid gimbal lock problems.
; 639  : 	float flBlendRoll = 1.0;

	mov	DWORD PTR _flBlendRoll$[ebp], 1065353216 ; 3f800000H

; 640  : 
; 641  : 	if( fabs( vehicleEyeAngles.x ) > 60 )

	mov	edx, DWORD PTR _vehicleEyeAngles$[ebp]
	fld	DWORD PTR [edx]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@4004f000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71543

; 643  : 		flBlendRoll = RemapValClamped( fabs( vecEyeAnglesRemapped.x ), 60, 80, 1, 0);

	push	0
	push	1065353216				; 3f800000H
	push	1117782016				; 42a00000H
	push	1114636288				; 42700000H
	fld	DWORD PTR _vecEyeAnglesRemapped$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fst	DWORD PTR -32+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?RemapValClamped@@YAMMMMMM@Z		; RemapValClamped
	add	esp, 20					; 00000014H
	fstp	DWORD PTR _flBlendRoll$[ebp]
$L71543:

; 647  : 	float flRollDamped = RemapAngleRange( pData->flRollCurveZero, pData->flRollCurveLinear, vecEyeAnglesRemapped.z, &eRollCurvePart );

	lea	eax, DWORD PTR _eRollCurvePart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecEyeAnglesRemapped$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	?RemapAngleRange@@YAMMMMPAW4RemapAngleRange_CurvePart_t@@@Z ; RemapAngleRange
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _flRollDamped$[ebp]

; 648  : 	vecEyeAnglesRemapped.z = Lerp( flBlendRoll, vecEyeAnglesRemapped.z, flRollDamped );

	lea	eax, DWORD PTR _flRollDamped$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecEyeAnglesRemapped$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _flBlendRoll$[ebp]
	push	edx
	call	?Lerp@@YAMMABM0@Z			; Lerp
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _vecEyeAnglesRemapped$[ebp+8]

; 649  : 
; 650  : 	//Msg("PITCH ");
; 651  : 	vehicleEyeAngles.x = ApplyViewLocking( pparams, vehicleEyeAngles.x, vecEyeAnglesRemapped.x, pData->pitchLockData, ePitchCurvePart );

	mov	eax, DWORD PTR _ePitchCurvePart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _vecEyeAnglesRemapped$[ebp]
	push	edx
	mov	eax, DWORD PTR _vehicleEyeAngles$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pparams$[ebp]
	push	edx
	call	?ApplyViewLocking@@YAMPAUref_params_s@@MMAAUViewLockData_t@@W4RemapAngleRange_CurvePart_t@@@Z ; ApplyViewLocking
	add	esp, 20					; 00000014H
	mov	eax, DWORD PTR _vehicleEyeAngles$[ebp]
	fstp	DWORD PTR [eax]

; 652  : 
; 653  : 	//Msg("ROLL ");
; 654  : 	vehicleEyeAngles.z = ApplyViewLocking( pparams, vehicleEyeAngles.z, vecEyeAnglesRemapped.z, pData->rollLockData, eRollCurvePart );

	mov	ecx, DWORD PTR _eRollCurvePart$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pData$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	eax, DWORD PTR _vecEyeAnglesRemapped$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _vehicleEyeAngles$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _pparams$[ebp]
	push	eax
	call	?ApplyViewLocking@@YAMPAUref_params_s@@MMAAUViewLockData_t@@W4RemapAngleRange_CurvePart_t@@@Z ; ApplyViewLocking
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _vehicleEyeAngles$[ebp]
	fstp	DWORD PTR [ecx+8]

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemapViewAngles@@YAXPAUref_params_s@@PAUViewSmoothingData_t@@AAVVector@@@Z ENDP ; RemapViewAngles
_TEXT	ENDS
PUBLIC	?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z		; matrix3x4::GetOrigin
PUBLIC	?GetAngles@matrix3x4@@QAE?AVVector@@XZ		; matrix3x4::GetAngles
PUBLIC	?GetAngles@matrix3x4@@QAEXAAVVector@@@Z		; matrix3x4::GetAngles
PUBLIC	?Transpose@matrix3x4@@QBE?AV1@XZ		; matrix3x4::Transpose
PUBLIC	??0matrix3x4@@QAE@ABV0@@Z			; matrix3x4::matrix3x4
PUBLIC	??ZVector@@QAEAAV0@ABV0@@Z			; Vector::operator-=
PUBLIC	??D@YA?AVVector@@MABV0@@Z			; operator*
PUBLIC	?R_StudioAttachmentTransform@@YAXPBUcl_entity_s@@HPAVVector@@1H@Z ; R_StudioAttachmentTransform
PUBLIC	?R_StudioAttachmentAngles@@YA?AVVector@@PBUcl_entity_s@@HH@Z ; R_StudioAttachmentAngles
PUBLIC	?R_StudioLookupAttachment@@YAHPBUcl_entity_s@@PBD@Z ; R_StudioLookupAttachment
PUBLIC	?R_StudioSequenceDuration@@YAMPBUcl_entity_s@@H@Z ; R_StudioSequenceDuration
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	?CalcVehicleRefdef@@YAXPAUref_params_s@@H@Z	; CalcVehicleRefdef
PUBLIC	??_C@_0BE@LPHC@vehicle_driver_eyes?$AA@		; `string'
PUBLIC	?Lerp@@YA?AVVector@@MABV1@0@Z			; Lerp
PUBLIC	??0matrix3x4@@QAE@ABVVector@@0M@Z		; matrix3x4::matrix3x4
EXTRN	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z:NEAR	; matrix3x4::ConcatTransforms
EXTRN	?tr@@3Uref_globals_t@@A:BYTE			; tr
EXTRN	?AngleDiff@@YAMMM@Z:NEAR			; AngleDiff
;	COMDAT ??_C@_0BE@LPHC@vehicle_driver_eyes?$AA@
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
??_C@_0BE@LPHC@vehicle_driver_eyes?$AA@ DB 'vehicle_driver_eyes', 00H ; `string'
CONST	ENDS
;	COMDAT __real@8@3fff8000000000000000
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT ?CalcVehicleRefdef@@YAXPAUref_params_s@@H@Z
_TEXT	SEGMENT
$T72361 = -484
$T72362 = -532
$T72363 = -580
$T72365 = -632
$T72366 = -644
$T72373 = -656
$T72374 = -704
$T72375 = -752
$T72377 = -804
$T72378 = -852
$T72380 = -904
$T72385 = -916
$T72386 = -928
$T72387 = -940
$T72388 = -952
_pparams$ = 8
_vstate$ = 12
_pData$ = -4
_vehicle$ = -8
_eyeAttachmentIndex$ = -12
_vecEyeExitEndpoint$ = -24
_vehicleEyeOrigin$ = -36
_vehicleEyeAngles$ = -48
_vehicleEyePosToWorld$ = -96
_vehicleTransform$ = -144
_v_angleTransform$ = -192
_bRunningAnim$ = -196
_frac$ = -200
_cameraToWorld$ = -248
_worldToEyePos$ = -296
_vehicleCameraToEyePos$ = -344
_newCameraToWorld$ = -392
_flSplineFrac$71593 = -396
_vecAngleDiffBlend$71594 = -408
_vecAngleDiffCur$71596 = -420
_i$71597 = -424
_vecAbsOrigin$71604 = -436
?CalcVehicleRefdef@@YAXPAUref_params_s@@H@Z PROC NEAR	; CalcVehicleRefdef, COMDAT

; 658  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1052				; 0000041cH
	push	ebx
	push	esi
	push	edi

; 659  : 	ViewSmoothingData_t	*pData = &gHUD.m_ViewSmoothingData;

	mov	DWORD PTR _pData$[ebp], OFFSET FLAT:?gHUD@@3VCHud@@A+3152

; 660  : 	cl_entity_t *vehicle = GET_ENTITY( pparams->viewentity );

	mov	eax, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	push	ecx
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR _vehicle$[ebp], eax

; 661  : 	int eyeAttachmentIndex = R_StudioLookupAttachment( vehicle, "vehicle_driver_eyes" );

	push	OFFSET FLAT:??_C@_0BE@LPHC@vehicle_driver_eyes?$AA@ ; `string'
	mov	edx, DWORD PTR _vehicle$[ebp]
	push	edx
	call	?R_StudioLookupAttachment@@YAHPBUcl_entity_s@@PBD@Z ; R_StudioLookupAttachment
	add	esp, 8
	mov	DWORD PTR _eyeAttachmentIndex$[ebp], eax

; 662  : 	Vector vecEyeExitEndpoint = vehicle->curstate.endpos;

	mov	eax, DWORD PTR _vehicle$[ebp]
	add	eax, 928				; 000003a0H
	push	eax
	lea	ecx, DWORD PTR _vecEyeExitEndpoint$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 663  : 
; 664  : 	Vector vehicleEyeOrigin;

	lea	ecx, DWORD PTR _vehicleEyeOrigin$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 665  : 	Vector vehicleEyeAngles;

	lea	ecx, DWORD PTR _vehicleEyeAngles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 666  : 	R_StudioAttachmentTransform( vehicle, eyeAttachmentIndex, &vehicleEyeOrigin, &vehicleEyeAngles, AF_FORCE_RECALC );

	push	1
	lea	ecx, DWORD PTR _vehicleEyeAngles$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vehicleEyeOrigin$[ebp]
	push	edx
	mov	eax, DWORD PTR _eyeAttachmentIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vehicle$[ebp]
	push	ecx
	call	?R_StudioAttachmentTransform@@YAXPBUcl_entity_s@@HPAVVector@@1H@Z ; R_StudioAttachmentTransform
	add	esp, 20					; 00000014H

; 667  : 	matrix3x4 vehicleEyePosToWorld = matrix3x4( g_vecZero, vehicleEyeAngles );

	push	1065353216				; 3f800000H
	lea	edx, DWORD PTR _vehicleEyeAngles$[ebp]
	push	edx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR $T72361[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@0M@Z	; matrix3x4::matrix3x4
	push	eax
	lea	ecx, DWORD PTR _vehicleEyePosToWorld$[ebp]
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4

; 668  : 	matrix3x4 vehicleTransform = matrix3x4( vehicle->origin, vehicle->angles );

	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _vehicle$[ebp]
	add	eax, 2900				; 00000b54H
	push	eax
	mov	ecx, DWORD PTR _vehicle$[ebp]
	add	ecx, 2888				; 00000b48H
	push	ecx
	lea	ecx, DWORD PTR $T72362[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@0M@Z	; matrix3x4::matrix3x4
	push	eax
	lea	ecx, DWORD PTR _vehicleTransform$[ebp]
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4

; 669  : 	matrix3x4 v_angleTransform = matrix3x4( g_vecZero, pparams->cl_viewangles );

	push	1065353216				; 3f800000H
	mov	edx, DWORD PTR _pparams$[ebp]
	add	edx, 128				; 00000080H
	push	edx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR $T72363[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@0M@Z	; matrix3x4::matrix3x4
	push	eax
	lea	ecx, DWORD PTR _v_angleTransform$[ebp]
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4

; 670  : 	v_angleTransform = vehicleTransform.ConcatTransforms( v_angleTransform );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	eax, DWORD PTR _v_angleTransform$[ebp]
	push	eax
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	ecx, DWORD PTR $T72365[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vehicleTransform$[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	esi, eax
	mov	ecx, 12					; 0000000cH
	lea	edi, DWORD PTR _v_angleTransform$[ebp]
	rep movsd

; 671  : 
; 672  : 	// Dampen the eye positional change as we drive around.
; 673  : 	pparams->viewangles = v_angleTransform.GetAngles();

	lea	edx, DWORD PTR $T72366[ebp]
	push	edx
	lea	ecx, DWORD PTR _v_angleTransform$[ebp]
	call	?GetAngles@matrix3x4@@QAE?AVVector@@XZ	; matrix3x4::GetAngles
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 674  : 
; 675  : 	// Started running an entry or exit anim?
; 676  : 	bool bRunningAnim = ( vstate == VEHICLE_ENTERING || vstate == VEHICLE_LEAVING );

	cmp	DWORD PTR _vstate$[ebp], 1
	je	SHORT $L72367
	cmp	DWORD PTR _vstate$[ebp], 3
	je	SHORT $L72367
	mov	DWORD PTR -956+[ebp], 0
	jmp	SHORT $L72368
$L72367:
	mov	DWORD PTR -956+[ebp], 1
$L72368:
	mov	cl, BYTE PTR -956+[ebp]
	mov	BYTE PTR _bRunningAnim$[ebp], cl

; 677  : 
; 678  : 	if( bRunningAnim && !pData->bWasRunningAnim )

	mov	edx, DWORD PTR _bRunningAnim$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	$L71572
	mov	eax, DWORD PTR _pData$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+53]
	test	ecx, ecx
	jne	$L71572

; 680  : 		pData->bRunningEnterExit = true;

	mov	edx, DWORD PTR _pData$[ebp]
	mov	BYTE PTR [edx+52], 1

; 681  : 		pData->flEnterExitStartTime = pparams->time;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR _pparams$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+56], edx

; 682  : 		pData->flEnterExitDuration = R_StudioSequenceDuration( vehicle, vehicle->curstate.sequence );

	mov	eax, DWORD PTR _vehicle$[ebp]
	mov	ecx, DWORD PTR [eax+732]
	push	ecx
	mov	edx, DWORD PTR _vehicle$[ebp]
	push	edx
	call	?R_StudioSequenceDuration@@YAMPBUcl_entity_s@@H@Z ; R_StudioSequenceDuration
	add	esp, 8
	mov	eax, DWORD PTR _pData$[ebp]
	fstp	DWORD PTR [eax+60]

; 683  : 
; 684  : 		pData->vecOriginSaved = tr.cached_vieworigin;

	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1417160
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?tr@@3Uref_globals_t@@A+1417164
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1417168
	mov	DWORD PTR [ecx+8], edx

; 685  : 		pData->vecAnglesSaved = tr.cached_viewangles;

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 64					; 00000040H
	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1417172
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?tr@@3Uref_globals_t@@A+1417176
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ?tr@@3Uref_globals_t@@A+1417180
	mov	DWORD PTR [eax+8], ecx

; 686  : 
; 687  : 		// Save our initial angular error, which we will blend out over the length of the animation.
; 688  : 		pData->vecAngleDiffSaved.x = AngleDiff( vehicleEyeAngles.x, pData->vecAnglesSaved.x );

	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	mov	ecx, DWORD PTR _vehicleEyeAngles$[ebp]
	push	ecx
	call	?AngleDiff@@YAMMM@Z			; AngleDiff
	add	esp, 8
	mov	edx, DWORD PTR _pData$[ebp]
	fstp	DWORD PTR [edx+88]

; 689  : 		pData->vecAngleDiffSaved.y = AngleDiff( vehicleEyeAngles.y, pData->vecAnglesSaved.y );

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	mov	edx, DWORD PTR _vehicleEyeAngles$[ebp+4]
	push	edx
	call	?AngleDiff@@YAMMM@Z			; AngleDiff
	add	esp, 8
	mov	eax, DWORD PTR _pData$[ebp]
	fstp	DWORD PTR [eax+92]

; 690  : 		pData->vecAngleDiffSaved.z = AngleDiff( vehicleEyeAngles.z, pData->vecAnglesSaved.z );

	mov	ecx, DWORD PTR _pData$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _vehicleEyeAngles$[ebp+8]
	push	eax
	call	?AngleDiff@@YAMMM@Z			; AngleDiff
	add	esp, 8
	mov	ecx, DWORD PTR _pData$[ebp]
	fstp	DWORD PTR [ecx+96]

; 691  : 
; 692  : 		pData->vecAngleDiffMin = pData->vecAngleDiffSaved;

	mov	edx, DWORD PTR _pData$[ebp]
	add	edx, 88					; 00000058H
	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 100				; 00000064H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
$L71572:

; 694  : 
; 695  : 	pData->bWasRunningAnim = bRunningAnim;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	cl, BYTE PTR _bRunningAnim$[ebp]
	mov	BYTE PTR [eax+53], cl

; 696  : 
; 697  : 	float frac = 0;

	mov	DWORD PTR _frac$[ebp], 0

; 698  : 
; 699  : 	// If we're in an enter/exit animation, blend the player's eye angles to the attachment's
; 700  : 	if( bRunningAnim || pData->bRunningEnterExit )

	mov	edx, DWORD PTR _bRunningAnim$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L71575
	mov	eax, DWORD PTR _pData$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+52]
	test	ecx, ecx
	je	$L71577
$L71575:

; 702  : 		pparams->viewangles = vehicleEyeAngles;

	mov	edx, DWORD PTR _pparams$[ebp]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _vehicleEyeAngles$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _vehicleEyeAngles$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _vehicleEyeAngles$[ebp+8]
	mov	DWORD PTR [edx+8], eax

; 703  : 
; 704  : 		// forward integrate to determine the elapsed time in this entry/exit anim.
; 705  : 		frac = ( pparams->time - pData->flEnterExitStartTime ) / pData->flEnterExitDuration;

	mov	ecx, DWORD PTR _pparams$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	fld	DWORD PTR [ecx+64]
	fsub	DWORD PTR [edx+56]
	mov	eax, DWORD PTR _pData$[ebp]
	fdiv	DWORD PTR [eax+60]
	fst	DWORD PTR _frac$[ebp]

; 706  : 		frac = bound( 0.0f, frac, 1.0f );

	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L72371
	fld	DWORD PTR _frac$[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72369
	mov	ecx, DWORD PTR _frac$[ebp]
	mov	DWORD PTR -960+[ebp], ecx
	jmp	SHORT $L72370
$L72369:
	mov	DWORD PTR -960+[ebp], 1065353216	; 3f800000H
$L72370:
	mov	edx, DWORD PTR -960+[ebp]
	mov	DWORD PTR -964+[ebp], edx
	jmp	SHORT $L72372
$L72371:
	mov	DWORD PTR -964+[ebp], 0
$L72372:
	mov	eax, DWORD PTR -964+[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 707  : 
; 708  : 		if( frac >= 1.0 )

	fld	DWORD PTR _frac$[ebp]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L71577

; 710  : 			pData->bRunningEnterExit = false;

	mov	ecx, DWORD PTR _pData$[ebp]
	mov	BYTE PTR [ecx+52], 0

; 711  : 
; 712  : 			// Enter animation has finished, align view with the eye attachment point
; 713  : 			// so they can start mouselooking around.
; 714  : 			if( vstate != VEHICLE_LEAVING )

	cmp	DWORD PTR _vstate$[ebp], 3
	je	SHORT $L71577

; 716  : 				pparams->cl_viewangles = R_StudioAttachmentAngles( vehicle, eyeAttachmentIndex, AF_FORCE_RECALC|AF_LOCAL_SPACE );

	push	3
	mov	edx, DWORD PTR _eyeAttachmentIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _vehicle$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72373[ebp]
	push	ecx
	call	?R_StudioAttachmentAngles@@YA?AVVector@@PBUcl_entity_s@@HH@Z ; R_StudioAttachmentAngles
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _pparams$[ebp]
	add	edx, 128				; 00000080H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L71577:

; 720  : 
; 721  : 	// Compute the relative rotation between the unperturbed eye attachment + the eye angles
; 722  : 	matrix3x4 cameraToWorld = matrix3x4( g_vecZero, pparams->viewangles );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR $T72374[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@0M@Z	; matrix3x4::matrix3x4
	push	eax
	lea	ecx, DWORD PTR _cameraToWorld$[ebp]
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4

; 723  : 	matrix3x4 worldToEyePos = vehicleEyePosToWorld.Transpose();

	lea	edx, DWORD PTR $T72375[ebp]
	push	edx
	lea	ecx, DWORD PTR _vehicleEyePosToWorld$[ebp]
	call	?Transpose@matrix3x4@@QBE?AV1@XZ	; matrix3x4::Transpose
	push	eax
	lea	ecx, DWORD PTR _worldToEyePos$[ebp]
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4

; 724  : 	matrix3x4 vehicleCameraToEyePos = worldToEyePos.ConcatTransforms( cameraToWorld );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	eax, DWORD PTR _cameraToWorld$[ebp]
	push	eax
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	ecx, DWORD PTR $T72377[ebp]
	push	ecx
	lea	ecx, DWORD PTR _worldToEyePos$[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	push	eax
	lea	ecx, DWORD PTR _vehicleCameraToEyePos$[ebp]
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4

; 725  : 
; 726  : 	// Damp out some of the vehicle motion (neck/head would do this)
; 727  : 	if( pData->bClampEyeAngles )

	mov	edx, DWORD PTR _pData$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L71586

; 729  : 		RemapViewAngles( pparams, pData, vehicleEyeAngles );

	lea	ecx, DWORD PTR _vehicleEyeAngles$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pparams$[ebp]
	push	eax
	call	?RemapViewAngles@@YAXPAUref_params_s@@PAUViewSmoothingData_t@@AAVVector@@@Z ; RemapViewAngles
	add	esp, 12					; 0000000cH
$L71586:

; 731  : 
; 732  : 	vehicleEyePosToWorld = matrix3x4( vehicleEyeOrigin, vehicleEyeAngles );

	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR _vehicleEyeAngles$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vehicleEyeOrigin$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T72378[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@0M@Z	; matrix3x4::matrix3x4
	mov	esi, eax
	mov	ecx, 12					; 0000000cH
	lea	edi, DWORD PTR _vehicleEyePosToWorld$[ebp]
	rep movsd

; 733  : 
; 734  : 	// Now treat the relative eye angles as being relative to this new, perturbed view position...
; 735  : 	matrix3x4 newCameraToWorld = vehicleEyePosToWorld.ConcatTransforms( vehicleCameraToEyePos );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	eax, DWORD PTR _vehicleCameraToEyePos$[ebp]
	push	eax
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	lea	ecx, DWORD PTR $T72380[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vehicleEyePosToWorld$[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	push	eax
	lea	ecx, DWORD PTR _newCameraToWorld$[ebp]
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4

; 736  : 
; 737  : 	// output new view abs angles
; 738  : 	newCameraToWorld.GetOrigin( pparams->vieworg ); 

	mov	edx, DWORD PTR _pparams$[ebp]
	push	edx
	lea	ecx, DWORD PTR _newCameraToWorld$[ebp]
	call	?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z	; matrix3x4::GetOrigin

; 739  : 	newCameraToWorld.GetAngles( pparams->viewangles ); 

	mov	eax, DWORD PTR _pparams$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _newCameraToWorld$[ebp]
	call	?GetAngles@matrix3x4@@QAEXAAVVector@@@Z	; matrix3x4::GetAngles

; 740  : 
; 741  : 	// If we're playing an entry or exit animation...
; 742  : 	if( bRunningAnim || pData->bRunningEnterExit )

	mov	ecx, DWORD PTR _bRunningAnim$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L71592
	mov	edx, DWORD PTR _pData$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+52]
	test	eax, eax
	je	$L71613
$L71592:

; 744  : 		float flSplineFrac = bound( 0, SimpleSpline( frac ), 1 );

	mov	ecx, DWORD PTR _frac$[ebp]
	push	ecx
	call	?SimpleSpline@@YAMM@Z			; SimpleSpline
	add	esp, 4
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L72383
	mov	edx, DWORD PTR _frac$[ebp]
	push	edx
	call	?SimpleSpline@@YAMM@Z			; SimpleSpline
	add	esp, 4
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72381
	mov	eax, DWORD PTR _frac$[ebp]
	push	eax
	call	?SimpleSpline@@YAMM@Z			; SimpleSpline
	add	esp, 4
	fstp	DWORD PTR -968+[ebp]
	jmp	SHORT $L72382
$L72381:
	mov	DWORD PTR -968+[ebp], 1065353216	; 3f800000H
$L72382:
	mov	ecx, DWORD PTR -968+[ebp]
	mov	DWORD PTR -972+[ebp], ecx
	jmp	SHORT $L72384
$L72383:
	mov	DWORD PTR -972+[ebp], 0
$L72384:
	mov	edx, DWORD PTR -972+[ebp]
	mov	DWORD PTR _flSplineFrac$71593[ebp], edx

; 745  : 
; 746  : 		// Blend out the error between the player's initial eye angles and the animation's initial
; 747  : 		// eye angles over the duration of the animation. 
; 748  : 		Vector vecAngleDiffBlend = (( 1 - flSplineFrac ) * pData->vecAngleDiffSaved );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _flSplineFrac$71593[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T72385[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _vecAngleDiffBlend$71594[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 749  : 
; 750  : 		// If our current error is less than the error amount that we're blending 
; 751  : 		// out, use that. This lets the angles converge as quickly as possible.
; 752  : 		Vector vecAngleDiffCur;

	lea	ecx, DWORD PTR _vecAngleDiffCur$71596[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 753  : 		vecAngleDiffCur.x = AngleDiff( vehicleEyeAngles.x, pData->vecAnglesSaved.x );

	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	mov	ecx, DWORD PTR _vehicleEyeAngles$[ebp]
	push	ecx
	call	?AngleDiff@@YAMMM@Z			; AngleDiff
	add	esp, 8
	fstp	DWORD PTR _vecAngleDiffCur$71596[ebp]

; 754  : 		vecAngleDiffCur.y = AngleDiff( vehicleEyeAngles.y, pData->vecAnglesSaved.y );

	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	mov	ecx, DWORD PTR _vehicleEyeAngles$[ebp+4]
	push	ecx
	call	?AngleDiff@@YAMMM@Z			; AngleDiff
	add	esp, 8
	fstp	DWORD PTR _vecAngleDiffCur$71596[ebp+4]

; 755  : 		vecAngleDiffCur.z = AngleDiff( vehicleEyeAngles.z, pData->vecAnglesSaved.z );

	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _vehicleEyeAngles$[ebp+8]
	push	ecx
	call	?AngleDiff@@YAMMM@Z			; AngleDiff
	add	esp, 8
	fstp	DWORD PTR _vecAngleDiffCur$71596[ebp+8]

; 756  : 
; 757  : 		// In either case, never increase the error, so track the minimum error and clamp to that.
; 758  : 		for( int i = 0; i < 3; i++ )

	mov	DWORD PTR _i$71597[ebp], 0
	jmp	SHORT $L71598
$L71599:
	mov	edx, DWORD PTR _i$71597[ebp]
	add	edx, 1
	mov	DWORD PTR _i$71597[ebp], edx
$L71598:
	cmp	DWORD PTR _i$71597[ebp], 3
	jge	$L71600

; 760  : 			if( fabs( vecAngleDiffCur[i] ) < fabs( pData->vecAngleDiffMin[i] ))

	lea	ecx, DWORD PTR _vecAngleDiffCur$71596[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$71597[ebp]
	fld	DWORD PTR [eax+ecx*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	fstp	QWORD PTR -980+[ebp]
	add	esp, 8
	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$71597[ebp]
	fld	DWORD PTR [eax+edx*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR -980+[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71601

; 762  : 				pData->vecAngleDiffMin[i] = vecAngleDiffCur[i];

	lea	ecx, DWORD PTR _vecAngleDiffCur$71596[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$71597[ebp]
	mov	edx, DWORD PTR _i$71597[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [eax+ecx*4], edx
$L71601:

; 764  : 
; 765  : 			if( fabs(vecAngleDiffBlend[i] ) < fabs( pData->vecAngleDiffMin[i] ))

	lea	ecx, DWORD PTR _vecAngleDiffBlend$71594[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$71597[ebp]
	fld	DWORD PTR [eax+ecx*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	fstp	QWORD PTR -988+[ebp]
	add	esp, 8
	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$71597[ebp]
	fld	DWORD PTR [eax+edx*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR -988+[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71602

; 767  : 				pData->vecAngleDiffMin[i] = vecAngleDiffBlend[i];

	lea	ecx, DWORD PTR _vecAngleDiffBlend$71594[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$71597[ebp]
	mov	edx, DWORD PTR _i$71597[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [eax+ecx*4], edx
$L71602:

; 769  : 		}

	jmp	$L71599
$L71600:

; 770  : 
; 771  : 		// Add the error to the animation's eye angles.
; 772  : 		pparams->viewangles -= pData->vecAngleDiffMin;

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=

; 773  : 
; 774  : 		// Use this as the basis for the next error calculation.
; 775  : 		pData->vecAnglesSaved = v_angleTransform.GetAngles();

	lea	ecx, DWORD PTR $T72386[ebp]
	push	ecx
	lea	ecx, DWORD PTR _v_angleTransform$[ebp]
	call	?GetAngles@matrix3x4@@QAE?AVVector@@XZ	; matrix3x4::GetAngles
	mov	edx, DWORD PTR _pData$[ebp]
	add	edx, 64					; 00000040H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 776  : 
; 777  : 		Vector vecAbsOrigin = pparams->vieworg;

	mov	ecx, DWORD PTR _pparams$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecAbsOrigin$71604[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 778  : 
; 779  : 		// If we're exiting, our desired position is the server-sent exit position
; 780  : 		if( vstate == VEHICLE_LEAVING )

	cmp	DWORD PTR _vstate$[ebp], 3
	jne	SHORT $L71605

; 782  : 			// Blend to the exit position
; 783  : 			pparams->vieworg = Lerp( flSplineFrac, vecAbsOrigin, vecEyeExitEndpoint );

	lea	edx, DWORD PTR _vecEyeExitEndpoint$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecAbsOrigin$71604[ebp]
	push	eax
	mov	ecx, DWORD PTR _flSplineFrac$71593[ebp]
	push	ecx
	lea	edx, DWORD PTR $T72387[ebp]
	push	edx
	call	?Lerp@@YA?AVVector@@MABV1@0@Z		; Lerp
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _pparams$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 785  : 		else

	jmp	SHORT $L71613
$L71605:

; 787  : 			// Blend from our starting position to the desired origin
; 788  : 			pparams->vieworg = Lerp( flSplineFrac, pData->vecOriginSaved, vecAbsOrigin );

	lea	ecx, DWORD PTR _vecAbsOrigin$71604[ebp]
	push	ecx
	mov	edx, DWORD PTR _pData$[ebp]
	add	edx, 76					; 0000004cH
	push	edx
	mov	eax, DWORD PTR _flSplineFrac$71593[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72388[ebp]
	push	ecx
	call	?Lerp@@YA?AVVector@@MABV1@0@Z		; Lerp
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L71613:

; 791  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CalcVehicleRefdef@@YAXPAUref_params_s@@H@Z ENDP	; CalcVehicleRefdef
_TEXT	ENDS
;	COMDAT ??ZVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??ZVector@@QAEAAV0@ABV0@@Z PROC NEAR			; Vector::operator-=, COMDAT

; 164  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		x-=v.x; y-=v.y; z -= v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 166  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 167  : 	}		

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??ZVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator-=
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT
_fl$ = 12
_v$ = 16
___$ReturnUdt$ = 8
$T72395 = -12
??D@YA?AVVector@@MABV0@@Z PROC NEAR			; operator*, COMDAT

; 288  : inline Vector operator* ( float fl, const Vector& v ) { return v * fl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72395[ebp]
	push	ecx
	mov	ecx, DWORD PTR _v$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??D@YA?AVVector@@MABV0@@Z ENDP				; operator*
_TEXT	ENDS
PUBLIC	?SinCos@@YAXMPAM0@Z				; SinCos
PUBLIC	__real@8@3ff98efa351294e9c800
;	COMDAT __real@8@3ff98efa351294e9c800
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@8@3ff98efa351294e9c800 DQ 03f91df46a2529d39r ; 0.0174533
CONST	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT
_this$ = -4
_angle$ = -8
_sr$ = -12
_sp$ = -16
_sy$ = -20
_cr$ = -24
_cp$ = -28
_cy$ = -32
_origin$ = 8
_angles$ = 12
_scale$ = 16
??0matrix3x4@@QAE@ABVVector@@0M@Z PROC NEAR		; matrix3x4::matrix3x4, COMDAT

; 354  : 	_forceinline matrix3x4( const Vector &origin, const Vector &angles, float scale = 1.0f )

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 355  : 	{
; 356  : 		float	angle, sr, sp, sy, cr, cp, cy;
; 357  : 
; 358  : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L55408

; 360  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 361  : 			SinCos( angle, &sy, &cy );

	lea	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 362  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 363  : 			SinCos( angle, &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 364  : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 365  : 			SinCos( angle, &sr, &cr );

	lea	ecx, DWORD PTR _cr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sr$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 366  : 
; 367  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax], ecx

; 368  : 			mat[1][0] = (sr*sp*cy+cr*-sy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _cr$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax], edx

; 369  : 			mat[2][0] = (cr*sp*cy+-sr*-sy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR [eax], ecx

; 370  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 371  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+4], edx

; 372  : 			mat[1][1] = (sr*sp*sy+cr*cy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 373  : 			mat[2][1] = (cr*sp*sy+-sr*cy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax+4], edx

; 374  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 375  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 376  : 			mat[1][2] = (sr*cp) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -64+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+8], edx

; 377  : 			mat[2][2] = (cr*cp) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 378  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 380  : 		else if( angles[PITCH] )

	jmp	$L55413
$L55408:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L55410

; 382  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 383  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 384  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 385  : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 386  : 
; 387  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -72+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -72+[ebp]
	mov	DWORD PTR [eax], edx

; 388  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -76+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -76+[ebp]
	mov	DWORD PTR [eax], ecx

; 389  : 			mat[2][0] = (sp*cy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -80+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -80+[ebp]
	mov	DWORD PTR [eax], edx

; 390  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 391  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -84+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -84+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 392  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -88+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -88+[ebp]
	mov	DWORD PTR [eax+4], edx

; 393  : 			mat[2][1] = (sp*sy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -92+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -92+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 394  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 395  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -96+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -96+[ebp]
	mov	DWORD PTR [eax+8], edx

; 396  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 397  : 			mat[2][2] = (cp) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -100+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -100+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 398  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 400  : 		else if( angles[YAW] )

	jmp	$L55413
$L55410:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L55412

; 402  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 403  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 404  : 
; 405  : 			mat[0][0] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -104+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -104+[ebp]
	mov	DWORD PTR [eax], edx

; 406  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -108+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -108+[ebp]
	mov	DWORD PTR [eax], ecx

; 407  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 408  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 409  : 			mat[0][1] = (sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -112+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -112+[ebp]
	mov	DWORD PTR [eax+4], edx

; 410  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -116+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -116+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 411  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 412  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 413  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 414  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 415  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], edx

; 416  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 418  : 		else

	jmp	$L55413
$L55412:

; 420  : 			mat[0][0] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax], ecx

; 421  : 			mat[1][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 422  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 423  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 424  : 			mat[0][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 425  : 			mat[1][1] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+4], edx

; 426  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 427  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 428  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 429  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 430  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 431  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
$L55413:

; 433  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0matrix3x4@@QAE@ABVVector@@0M@Z ENDP			; matrix3x4::matrix3x4
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT
_angle$ = 8
_sine$ = 12
_cosine$ = 16
?SinCos@@YAXMPAM0@Z PROC NEAR				; SinCos, COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 37   : 	__asm
; 38   : 	{
; 39   : 		push	ecx

	push	ecx

; 40   : 		fld	dword ptr angle

	fld	DWORD PTR _angle$[ebp]

; 41   : 		fsincos

	fsincos

; 42   : 		mov	ecx, dword ptr[cosine]

	mov	ecx, DWORD PTR _cosine$[ebp]

; 43   : 		fstp      dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 44   : 		mov 	ecx, dword ptr[sine]

	mov	ecx, DWORD PTR _sine$[ebp]

; 45   : 		fstp	dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 46   : 		pop	ecx

	pop	ecx

; 47   : 	}
; 48   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SinCos@@YAXMPAM0@Z ENDP				; SinCos
_TEXT	ENDS
;	COMDAT ?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z
_TEXT	SEGMENT
_vOrigin$ = 8
_this$ = -4
?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z PROC NEAR	; matrix3x4::GetOrigin, COMDAT

; 531  : 	void	GetOrigin( Vector &vOrigin ) { vOrigin = mat[3]; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _vOrigin$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetOrigin@matrix3x4@@QAEXAAVVector@@@Z ENDP		; matrix3x4::GetOrigin
_TEXT	ENDS
PUBLIC	__real@4@3ff583126f0000000000
PUBLIC	__real@4@4004e52ee10000000000
EXTRN	_atan2:NEAR
;	COMDAT __real@4@3ff583126f0000000000
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@4@3ff583126f0000000000 DD 03a83126fr	; 0.001
CONST	ENDS
;	COMDAT __real@4@4004e52ee10000000000
CONST	SEGMENT
__real@4@4004e52ee10000000000 DD 042652ee1r	; 57.2958
CONST	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_xyDist$ = -8
_angles$ = -20
?GetAngles@matrix3x4@@QAE?AVVector@@XZ PROC NEAR	; matrix3x4::GetAngles, COMDAT

; 534  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 535  : 		float xyDist = sqrt( mat[0][0] * mat[0][0] + mat[0][1] * mat[0][1] );

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi+4]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -24+[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _xyDist$[ebp]

; 536  : 		Vector angles;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 537  : 
; 538  : 		// enough here to get angles?
; 539  : 		if( xyDist > 0.001f )

	fld	DWORD PTR _xyDist$[ebp]
	fcomp	DWORD PTR __real@4@3ff583126f0000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L55482

; 541  : 			angles[0] = RAD2DEG( atan2( -mat[0][2], xyDist ) );

	fld	DWORD PTR _xyDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -28+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -32+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -32+[ebp]
	mov	DWORD PTR [eax], ecx

; 542  : 			angles[1] = RAD2DEG( atan2( mat[0][1], mat[0][0] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -36+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -40+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax+4], edx

; 543  : 			angles[2] = RAD2DEG( atan2( mat[1][2], mat[2][2] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -44+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -48+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 545  : 		else	// forward is mostly Z, gimbal lock

	jmp	$L55489
$L55482:

; 547  : 			angles[0] = RAD2DEG( atan2( -mat[0][2], xyDist ) );

	fld	DWORD PTR _xyDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -52+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -56+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax], edx

; 548  : 			angles[1] = RAD2DEG( atan2( -mat[1][0], mat[1][1] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -60+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -64+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 549  : 			angles[2] = 0.0f;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0
$L55489:

; 551  : 
; 552  : 		return angles;

	lea	edx, DWORD PTR _angles$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 553  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAngles@matrix3x4@@QAE?AVVector@@XZ ENDP		; matrix3x4::GetAngles
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAEXAAVVector@@@Z
_TEXT	SEGMENT
_angles$ = 8
_this$ = -4
$T72412 = -16
?GetAngles@matrix3x4@@QAEXAAVVector@@@Z PROC NEAR	; matrix3x4::GetAngles, COMDAT

; 576  : 	void	GetAngles( Vector &angles ) { angles = GetAngles(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T72412[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAngles@matrix3x4@@QAE?AVVector@@XZ	; matrix3x4::GetAngles
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAngles@matrix3x4@@QAEXAAVVector@@@Z ENDP		; matrix3x4::GetAngles
_TEXT	ENDS
PUBLIC	??0matrix3x4@@QAE@MMMMMMMMMMMM@Z		; matrix3x4::matrix3x4
;	COMDAT ?Transpose@matrix3x4@@QBE?AV1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T72415 = -52
?Transpose@matrix3x4@@QBE?AV1@XZ PROC NEAR		; matrix3x4::Transpose, COMDAT

; 637  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 		return matrix3x4(  // transpose 3x3, position is unchanged
; 639  : 			mat[0][0], mat[1][0], mat[2][0],
; 640  : 			mat[0][1], mat[1][1], mat[2][1],
; 641  : 			mat[0][2], mat[1][2], mat[2][2],
; 642  : 			mat[3][0], mat[3][1], mat[3][2] );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, DWORD PTR [eax+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	ecx, DWORD PTR $T72415[ebp]
	call	??0matrix3x4@@QAE@MMMMMMMMMMMM@Z	; matrix3x4::matrix3x4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0matrix3x4@@QAE@ABV0@@Z		; matrix3x4::matrix3x4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Transpose@matrix3x4@@QBE?AV1@XZ ENDP			; matrix3x4::Transpose
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT
_this$ = -4
_m00$ = 8
_m01$ = 12
_m02$ = 16
_m10$ = 20
_m11$ = 24
_m12$ = 28
_m20$ = 32
_m21$ = 36
_m22$ = 40
_m30$ = 44
_m31$ = 48
_m32$ = 52
??0matrix3x4@@QAE@MMMMMMMMMMMM@Z PROC NEAR		; matrix3x4::matrix3x4, COMDAT

; 253  : 	matrix3x4( float m00, float m01, float m02,

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 254  : 		 float m10, float m11, float m12,
; 255  : 		 float m20, float m21, float m22,
; 256  : 		 float m30, float m31, float m32 )
; 257  : 	{
; 258  : 		mat[0][0] = m00;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _m00$[ebp]
	mov	DWORD PTR [eax], ecx

; 259  : 		mat[0][1] = m01;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _m01$[ebp]
	mov	DWORD PTR [eax+4], edx

; 260  : 		mat[0][2] = m02;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _m02$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 261  : 		mat[1][0] = m10;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _m10$[ebp]
	mov	DWORD PTR [eax], edx

; 262  : 		mat[1][1] = m11;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _m11$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 263  : 		mat[1][2] = m12;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _m12$[ebp]
	mov	DWORD PTR [eax+8], edx

; 264  : 		mat[2][0] = m20;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _m20$[ebp]
	mov	DWORD PTR [eax], ecx

; 265  : 		mat[2][1] = m21;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _m21$[ebp]
	mov	DWORD PTR [eax+4], edx

; 266  : 		mat[2][2] = m22;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _m22$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 267  : 		mat[3][0] = m30;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _m30$[ebp]
	mov	DWORD PTR [eax], edx

; 268  : 		mat[3][1] = m31;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _m31$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 269  : 		mat[3][2] = m32;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _m32$[ebp]
	mov	DWORD PTR [eax+8], edx

; 270  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
??0matrix3x4@@QAE@MMMMMMMMMMMM@Z ENDP			; matrix3x4::matrix3x4
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
_$S4$ = -8
_$S5$ = -12
_$S6$ = -16
??0matrix3x4@@QAE@ABV0@@Z PROC NEAR			; matrix3x4::matrix3x4, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S4$[ebp], 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _$S5$[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR _$S6$[ebp], ecx
$L55527:
	mov	edx, DWORD PTR _$S6$[ebp]
	push	edx
	mov	ecx, DWORD PTR _$S5$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR _$S5$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _$S5$[ebp], eax
	mov	ecx, DWORD PTR _$S6$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _$S6$[ebp], ecx
	mov	edx, DWORD PTR _$S4$[ebp]
	sub	edx, 1
	mov	DWORD PTR _$S4$[ebp], edx
	cmp	DWORD PTR _$S4$[ebp], 0
	ja	SHORT $L55527
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix3x4@@QAE@ABV0@@Z ENDP				; matrix3x4::matrix3x4
_TEXT	ENDS
EXTRN	?StudioGetAttachment@CStudioModelRenderer@@QAEXPBUcl_entity_s@@HPAVVector@@1H@Z:NEAR ; CStudioModelRenderer::StudioGetAttachment
EXTRN	?g_StudioRenderer@@3VCStudioModelRenderer@@A:BYTE ; g_StudioRenderer
;	COMDAT ?R_StudioAttachmentTransform@@YAXPBUcl_entity_s@@HPAVVector@@1H@Z
_TEXT	SEGMENT
_ent$ = 8
_num$ = 12
_origin$ = 16
_angles$ = 20
_flags$ = 24
?R_StudioAttachmentTransform@@YAXPBUcl_entity_s@@HPAVVector@@1H@Z PROC NEAR ; R_StudioAttachmentTransform, COMDAT

; 678  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 679  : 	g_StudioRenderer.StudioGetAttachment( ent, num, origin, angles, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?g_StudioRenderer@@3VCStudioModelRenderer@@A
	call	?StudioGetAttachment@CStudioModelRenderer@@QAEXPBUcl_entity_s@@HPAVVector@@1H@Z ; CStudioModelRenderer::StudioGetAttachment

; 680  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?R_StudioAttachmentTransform@@YAXPBUcl_entity_s@@HPAVVector@@1H@Z ENDP ; R_StudioAttachmentTransform
_TEXT	ENDS
;	COMDAT ?R_StudioAttachmentAngles@@YA?AVVector@@PBUcl_entity_s@@HH@Z
_TEXT	SEGMENT
_ent$ = 12
_num$ = 16
_flags$ = 20
___$ReturnUdt$ = 8
_angles$ = -12
?R_StudioAttachmentAngles@@YA?AVVector@@PBUcl_entity_s@@HH@Z PROC NEAR ; R_StudioAttachmentAngles, COMDAT

; 692  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 693  : 	Vector angles = g_vecZero;

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 694  : 
; 695  : 	g_StudioRenderer.StudioGetAttachment( ent, num, NULL, &angles, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?g_StudioRenderer@@3VCStudioModelRenderer@@A
	call	?StudioGetAttachment@CStudioModelRenderer@@QAEXPBUcl_entity_s@@HPAVVector@@1H@Z ; CStudioModelRenderer::StudioGetAttachment

; 696  : 
; 697  : 	return angles;

	lea	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 698  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?R_StudioAttachmentAngles@@YA?AVVector@@PBUcl_entity_s@@HH@Z ENDP ; R_StudioAttachmentAngles
_TEXT	ENDS
EXTRN	?StudioGetAttachmentNumber@CStudioModelRenderer@@QAEHPBUcl_entity_s@@PBD@Z:NEAR ; CStudioModelRenderer::StudioGetAttachmentNumber
;	COMDAT ?R_StudioLookupAttachment@@YAHPBUcl_entity_s@@PBD@Z
_TEXT	SEGMENT
_ent$ = 8
_name$ = 12
?R_StudioLookupAttachment@@YAHPBUcl_entity_s@@PBD@Z PROC NEAR ; R_StudioLookupAttachment, COMDAT

; 701  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 702  : 	return g_StudioRenderer.StudioGetAttachmentNumber( ent, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?g_StudioRenderer@@3VCStudioModelRenderer@@A
	call	?StudioGetAttachmentNumber@CStudioModelRenderer@@QAEHPBUcl_entity_s@@PBD@Z ; CStudioModelRenderer::StudioGetAttachmentNumber

; 703  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?R_StudioLookupAttachment@@YAHPBUcl_entity_s@@PBD@Z ENDP ; R_StudioLookupAttachment
_TEXT	ENDS
EXTRN	?StudioSequenceDuration@CStudioModelRenderer@@QAEMPBUcl_entity_s@@H@Z:NEAR ; CStudioModelRenderer::StudioSequenceDuration
;	COMDAT ?R_StudioSequenceDuration@@YAMPBUcl_entity_s@@H@Z
_TEXT	SEGMENT
_ent$ = 8
_sequence$ = 12
?R_StudioSequenceDuration@@YAMPBUcl_entity_s@@H@Z PROC NEAR ; R_StudioSequenceDuration, COMDAT

; 716  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 717  : 	return g_StudioRenderer.StudioSequenceDuration( ent, sequence );

	mov	eax, DWORD PTR _sequence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?g_StudioRenderer@@3VCStudioModelRenderer@@A
	call	?StudioSequenceDuration@CStudioModelRenderer@@QAEMPBUcl_entity_s@@H@Z ; CStudioModelRenderer::StudioSequenceDuration

; 718  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?R_StudioSequenceDuration@@YAMPBUcl_entity_s@@H@Z ENDP	; R_StudioSequenceDuration
_TEXT	ENDS
PUBLIC	?V_ResetCarSmoothData@@YAXXZ			; V_ResetCarSmoothData
;	COMDAT ?V_ResetCarSmoothData@@YAXXZ
_TEXT	SEGMENT
_pData$ = -4
?V_ResetCarSmoothData@@YAXXZ PROC NEAR			; V_ResetCarSmoothData, COMDAT

; 794  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 795  : 	ViewSmoothingData_t	*pData = &gHUD.m_ViewSmoothingData;

	mov	DWORD PTR _pData$[ebp], OFFSET FLAT:?gHUD@@3VCHud@@A+3152

; 796  : 
; 797  : 	// reset car smoothing data
; 798  : 	if( pData->bRunningEnterExit || pData->bWasRunningAnim )

	mov	eax, DWORD PTR _pData$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+52]
	test	ecx, ecx
	jne	SHORT $L71625
	mov	edx, DWORD PTR _pData$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+53]
	test	eax, eax
	je	SHORT $L71624
$L71625:

; 800  : 		pData->bRunningEnterExit = false;

	mov	ecx, DWORD PTR _pData$[ebp]
	mov	BYTE PTR [ecx+52], 0

; 801  : 		pData->bWasRunningAnim = false;

	mov	edx, DWORD PTR _pData$[ebp]
	mov	BYTE PTR [edx+53], 0
$L71624:

; 803  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_ResetCarSmoothData@@YAXXZ ENDP			; V_ResetCarSmoothData
_TEXT	ENDS
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
PUBLIC	??YVector@@QAEAAV0@ABV0@@Z			; Vector::operator+=
PUBLIC	__real@4@40069600000000000000
PUBLIC	?V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z	; V_CalcCameraRefdef
PUBLIC	??_C@_05PECN@incar?$AA@				; `string'
EXTRN	?IEngineStudio@@3Uengine_studio_api_s@@A:BYTE	; IEngineStudio
EXTRN	_atoi:NEAR
_BSS	SEGMENT
	ALIGN	4

_?lasttime@?1??V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z@4MA DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_05PECN@incar?$AA@
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
??_C@_05PECN@incar?$AA@ DB 'incar', 00H			; `string'
CONST	ENDS
;	COMDAT __real@4@40069600000000000000
CONST	SEGMENT
__real@4@40069600000000000000 DD 043160000r	; 150
CONST	ENDS
;	COMDAT ?V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT
$T72432 = -52
$T72433 = -64
$T72434 = -76
_pparams$ = 8
_view$ = -4
_vstate$71635 = -8
_viewmonster$71639 = -12
_forward$71642 = -24
_viewpos$71643 = -36
_steptime$71649 = -40
?V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z PROC NEAR	; V_CalcCameraRefdef, COMDAT

; 809  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi

; 810  : 	static float lasttime, oldz = 0;
; 811  : 
; 812  : 	// get viewentity and monster eyeposition
; 813  : 	cl_entity_t *view = GET_ENTITY( pparams->viewentity );

	mov	eax, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	push	ecx
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR _view$[ebp], eax

; 814  : 
; 815  :  	if( view )

	cmp	DWORD PTR _view$[ebp], 0
	je	$L71634

; 817  : 		int vstate = atoi( gEngfuncs.PhysInfo_ValueForKey( "incar" ));

	push	OFFSET FLAT:??_C@_05PECN@incar?$AA@	; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+176
	add	esp, 4
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _vstate$71635[ebp], eax

; 818  : 
; 819  : 		if( vstate != VEHICLE_INACTIVE )

	cmp	DWORD PTR _vstate$71635[ebp], 0
	je	SHORT $L71637

; 821  : 			CalcVehicleRefdef( pparams, vstate );

	mov	edx, DWORD PTR _vstate$71635[ebp]
	push	edx
	mov	eax, DWORD PTR _pparams$[ebp]
	push	eax
	call	?CalcVehicleRefdef@@YAXPAUref_params_s@@H@Z ; CalcVehicleRefdef
	add	esp, 8

; 823  : 		else

	jmp	$L71638
$L71637:

; 825  : 			pparams->vieworg = view->origin;

	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	mov	edx, DWORD PTR _pparams$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 826  : 			pparams->viewangles = view->angles;

	mov	edx, DWORD PTR _view$[ebp]
	add	edx, 2900				; 00000b54H
	mov	eax, DWORD PTR _pparams$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 827  : 
; 828  : 			studiohdr_t *viewmonster = (studiohdr_t *)IEngineStudio.Mod_Extradata( view->model );

	mov	eax, DWORD PTR _view$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	push	ecx
	call	DWORD PTR ?IEngineStudio@@3Uengine_studio_api_s@@A+16
	add	esp, 4
	mov	DWORD PTR _viewmonster$71639[ebp], eax

; 829  : 
; 830  : 			if( viewmonster && view->curstate.eflags & EFLAG_SLERP )

	cmp	DWORD PTR _viewmonster$71639[ebp], 0
	je	$L71641
	mov	edx, DWORD PTR _view$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+756]
	and	eax, 1
	test	eax, eax
	je	$L71641

; 832  : 				Vector forward;

	lea	ecx, DWORD PTR _forward$71642[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 833  : 				AngleVectors( pparams->viewangles, forward, NULL, NULL );

	push	0
	push	0
	lea	ecx, DWORD PTR _forward$71642[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+96
	add	esp, 16					; 00000010H

; 834  : 
; 835  : 				Vector viewpos = viewmonster->eyeposition;

	mov	ecx, DWORD PTR _viewmonster$71639[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	lea	ecx, DWORD PTR _viewpos$71643[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 836  : 
; 837  : 				if( viewpos == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR _viewpos$71643[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L71644

; 838  : 					viewpos = Vector( 0, 0, 8 );	// monster_cockroach

	push	1090519040				; 41000000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T72432[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _viewpos$71643[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _viewpos$71643[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _viewpos$71643[ebp+8], edx
$L71644:

; 839  : 
; 840  : 				pparams->vieworg += viewpos + forward * 8;	// best value for humans

	push	1090519040				; 41000000H
	lea	eax, DWORD PTR $T72433[ebp]
	push	eax
	lea	ecx, DWORD PTR _forward$71642[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T72434[ebp]
	push	ecx
	lea	ecx, DWORD PTR _viewpos$71643[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=
$L71641:

; 843  : 
; 844  : 			// this is smooth stair climbing in thirdperson mode but not affected for client model :(
; 845  : 			if( !pparams->smoothing && pparams->onground && view->origin[2] - oldz > 0.0f && viewmonster != NULL )

	mov	edx, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [edx+196], 0
	jne	$L71648
	mov	eax, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	$L71648
	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR _?oldz@?1??V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z@4MA
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L71648
	cmp	DWORD PTR _viewmonster$71639[ebp], 0
	je	$L71648

; 847  : 				float steptime;
; 848  : 		
; 849  : 				steptime = pparams->time - lasttime;

	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR [ecx+64]
	fsub	DWORD PTR _?lasttime@?1??V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z@4MA
	fstp	DWORD PTR _steptime$71649[ebp]

; 850  : 				if( steptime < 0 ) steptime = 0;

	fld	DWORD PTR _steptime$71649[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71650
	mov	DWORD PTR _steptime$71649[ebp], 0
$L71650:

; 851  : 
; 852  : 				oldz += steptime * 150.0f;

	fld	DWORD PTR _steptime$71649[ebp]
	fmul	DWORD PTR __real@4@40069600000000000000
	fadd	DWORD PTR _?oldz@?1??V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z@4MA
	fstp	DWORD PTR _?oldz@?1??V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z@4MA

; 853  : 
; 854  : 				if( oldz > view->origin[2] )

	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _?oldz@?1??V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z@4MA
	fcomp	DWORD PTR [eax+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71651

; 855  : 					oldz = view->origin[2];

	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _?oldz@?1??V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z@4MA, edx
$L71651:

; 856  : 				if( view->origin[2] - oldz > pparams->movevars->stepsize )

	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR _?oldz@?1??V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z@4MA
	mov	eax, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	fcomp	DWORD PTR [ecx+48]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71652

; 857  : 					oldz = view->origin[2] - pparams->movevars->stepsize;

	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR [edx+204]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+48]
	fstp	DWORD PTR _?oldz@?1??V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z@4MA
$L71652:

; 858  : 
; 859  : 				pparams->vieworg[2] += oldz - view->origin[2];

	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -80+[ebp], eax
	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _?oldz@?1??V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z@4MA
	fsub	DWORD PTR [eax+8]
	mov	edx, DWORD PTR -80+[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR -80+[ebp]
	fstp	DWORD PTR [eax]

; 861  : 			else

	jmp	SHORT $L71653
$L71648:

; 863  : 				oldz = view->origin[2];

	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _?oldz@?1??V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z@4MA, ecx
$L71653:

; 865  : 
; 866  : 			lasttime = pparams->time;

	mov	edx, DWORD PTR _pparams$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR _?lasttime@?1??V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z@4MA, eax

; 867  : 			V_ResetCarSmoothData();

	call	?V_ResetCarSmoothData@@YAXXZ		; V_ResetCarSmoothData
$L71638:

; 869  : 
; 870  : 		if( view->curstate.effects & EF_NUKE_ROCKET )

	mov	ecx, DWORD PTR _view$[ebp]
	mov	edx, DWORD PTR [ecx+748]
	and	edx, 4096				; 00001000H
	test	edx, edx
	je	SHORT $L71654

; 871  : 			pparams->viewangles.x = -pparams->viewangles.x; // stupid quake bug!

	mov	eax, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _pparams$[ebp]
	fstp	DWORD PTR [ecx+12]
$L71654:

; 872  : 
; 873  : 		// g-cont. apply shake to camera
; 874  : 		gEngfuncs.V_CalcShake();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+220

; 875  : 		gEngfuncs.V_ApplyShake( pparams->vieworg, pparams->viewangles, 1.0f );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+224
	add	esp, 12					; 0000000cH
$L71634:

; 877  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z ENDP	; V_CalcCameraRefdef
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L72439
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L72439
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L72439
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L72440
$L72439:
	mov	DWORD PTR -8+[ebp], 0
$L72440:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??YVector@@QAEAAV0@ABV0@@Z PROC NEAR			; Vector::operator+=, COMDAT

; 159  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		x+=v.x; y+=v.y; z += v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 161  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 162  : 	}			

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??YVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator+=
_TEXT	ENDS
PUBLIC	?V_FindIntermisionSpot@@YAPAUcl_entity_s@@PAUref_params_s@@@Z ; V_FindIntermisionSpot
;	COMDAT ?V_FindIntermisionSpot@@YAPAUcl_entity_s@@PAUref_params_s@@@Z
_TEXT	SEGMENT
_pparams$ = 8
_spotindex$ = -64
_ent$ = -68
_i$ = -72
_j$ = -76
?V_FindIntermisionSpot@@YAPAUcl_entity_s@@PAUref_params_s@@@Z PROC NEAR ; V_FindIntermisionSpot, COMDAT

; 885  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi

; 886  : 	int spotindex[MAX_SPOTS];
; 887  : 	cl_entity_t *ent;
; 888  : 
; 889  : 	// found intermission point
; 890  : 	for( int i = 0, j = 0; i < pparams->max_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L71663
$L71664:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L71663:
	mov	ecx, DWORD PTR _pparams$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+184]
	jge	SHORT $L71665

; 892  : 		ent = GET_ENTITY( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 893  : 
; 894  : 		if( ent && ent->curstate.eflags & EFLAG_INTERMISSION )

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $L71667
	mov	ecx, DWORD PTR _ent$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+756]
	and	edx, 2
	test	edx, edx
	je	SHORT $L71667

; 896  : 			spotindex[j] = ent->index;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _spotindex$[ebp+eax*4], edx

; 897  : 			if( ++j >= MAX_SPOTS ) break; // full

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jl	SHORT $L71667
	jmp	SHORT $L71665
$L71667:

; 899  : 	}	

	jmp	SHORT $L71664
$L71665:

; 900  : 	
; 901  : 	// ok, we have list of intermission spots
; 902  : 	if( j != 0 )

	cmp	DWORD PTR _j$[ebp], 0
	je	SHORT $L71668

; 904  : 		if( j > 1 ) j = RANDOM_LONG( 0, j );

	cmp	DWORD PTR _j$[ebp], 1
	jle	SHORT $L71669
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	push	0
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+272
	add	esp, 8
	mov	DWORD PTR _j$[ebp], eax
$L71669:

; 905  : 		ent = GET_ENTITY( spotindex[j-1] );

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _spotindex$[ebp+edx*4-4]
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 907  : 	else

	jmp	SHORT $L71670
$L71668:

; 909  : 		// defaulted to player view
; 910  : 		ent = gEngfuncs.GetLocalPlayer();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+204
	mov	DWORD PTR _ent$[ebp], eax
$L71670:

; 912  : 
; 913  : 	return ent;

	mov	eax, DWORD PTR _ent$[ebp]

; 914  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_FindIntermisionSpot@@YAPAUcl_entity_s@@PAUref_params_s@@@Z ENDP ; V_FindIntermisionSpot
_TEXT	ENDS
PUBLIC	?V_CalcIntermisionRefdef@@YAXPAUref_params_s@@@Z ; V_CalcIntermisionRefdef
;	COMDAT ?V_CalcIntermisionRefdef@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT
_pparams$ = 8
_view$ = -4
_old$ = -8
?V_CalcIntermisionRefdef@@YAXPAUref_params_s@@@Z PROC NEAR ; V_CalcIntermisionRefdef, COMDAT

; 920  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 921  :           if( !v_intermission_spot )

	cmp	DWORD PTR ?v_intermission_spot@@3PAUcl_entity_s@@A, 0 ; v_intermission_spot
	jne	SHORT $L71674

; 922  :           	v_intermission_spot = V_FindIntermisionSpot( pparams );

	mov	eax, DWORD PTR _pparams$[ebp]
	push	eax
	call	?V_FindIntermisionSpot@@YAPAUcl_entity_s@@PAUref_params_s@@@Z ; V_FindIntermisionSpot
	add	esp, 4
	mov	DWORD PTR ?v_intermission_spot@@3PAUcl_entity_s@@A, eax ; v_intermission_spot
$L71674:

; 923  : 
; 924  : 	pparams->vieworg = v_intermission_spot->origin;

	mov	ecx, DWORD PTR ?v_intermission_spot@@3PAUcl_entity_s@@A ; v_intermission_spot
	add	ecx, 2888				; 00000b48H
	mov	edx, DWORD PTR _pparams$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 925  : 	pparams->viewangles = v_intermission_spot->angles;

	mov	edx, DWORD PTR ?v_intermission_spot@@3PAUcl_entity_s@@A ; v_intermission_spot
	add	edx, 2900				; 00000b54H
	mov	eax, DWORD PTR _pparams$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 926  : 
; 927  : 	cl_entity_t *view = GET_VIEWMODEL();	

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+208
	mov	DWORD PTR _view$[ebp], eax

; 928  : 	view->model = NULL;

	mov	eax, DWORD PTR _view$[ebp]
	mov	DWORD PTR [eax+2964], 0

; 929  : 
; 930  : 	// allways idle in intermission
; 931  : 	float old = v_idlescale;

	mov	ecx, DWORD PTR ?v_idlescale@@3MA
	mov	DWORD PTR _old$[ebp], ecx

; 932  : 	v_idlescale = 1;

	mov	DWORD PTR ?v_idlescale@@3MA, 1065353216	; 3f800000H

; 933  : 	V_AddIdle( pparams );

	mov	edx, DWORD PTR _pparams$[ebp]
	push	edx
	call	?V_AddIdle@@YAXPAUref_params_s@@@Z	; V_AddIdle
	add	esp, 4

; 934  : 	v_idlescale = old;

	mov	eax, DWORD PTR _old$[ebp]
	mov	DWORD PTR ?v_idlescale@@3MA, eax

; 935  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_CalcIntermisionRefdef@@YAXPAUref_params_s@@@Z ENDP	; V_CalcIntermisionRefdef
_TEXT	ENDS
PUBLIC	__real@8@c000c000000000000000
PUBLIC	?V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z ; V_CalcThirdPersonRefdef
_BSS	SEGMENT
_?lasttime@?1??V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z@4MA DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@8@c000c000000000000000
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
__real@8@c000c000000000000000 DQ 0c008000000000000r ; -3
CONST	ENDS
;	COMDAT ?V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT
_steptime$71685 = -4
_pitch$ = -8
_ent$ = -12
_pparams$ = 8
?V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z PROC NEAR ; V_CalcThirdPersonRefdef, COMDAT

; 941  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 942  : 	static float lasttime, oldz = 0;
; 943  : 
; 944  : 	pparams->vieworg = pparams->simorg;

	mov	eax, DWORD PTR _pparams$[ebp]
	add	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _pparams$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 945  : 	pparams->vieworg += pparams->viewheight;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 946  : 	pparams->viewangles = pparams->cl_viewangles;

	mov	edx, DWORD PTR _pparams$[ebp]
	add	edx, 128				; 00000080H
	mov	eax, DWORD PTR _pparams$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 947  : 
; 948  : 	V_CalcSendOrigin( pparams );

	mov	eax, DWORD PTR _pparams$[ebp]
	push	eax
	call	?V_CalcSendOrigin@@YAXPAUref_params_s@@@Z ; V_CalcSendOrigin
	add	esp, 4

; 949  : 
; 950  : 	// this is smooth stair climbing in thirdperson mode but not affected for client model :(
; 951  : 	if( !pparams->smoothing && pparams->onground && pparams->simorg[2] - oldz > 0.0f )

	mov	ecx, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [ecx+196], 0
	jne	$L71684
	mov	edx, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [edx+80], 0
	je	$L71684
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR _?oldz@?1??V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L71684

; 953  : 		float steptime;
; 954  : 		
; 955  : 		steptime = pparams->time - lasttime;

	mov	eax, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR [eax+64]
	fsub	DWORD PTR _?lasttime@?1??V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
	fstp	DWORD PTR _steptime$71685[ebp]

; 956  : 		if( steptime < 0 ) steptime = 0;

	fld	DWORD PTR _steptime$71685[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71686
	mov	DWORD PTR _steptime$71685[ebp], 0
$L71686:

; 957  : 
; 958  : 		oldz += steptime * 150.0f;

	fld	DWORD PTR _steptime$71685[ebp]
	fmul	DWORD PTR __real@4@40069600000000000000
	fadd	DWORD PTR _?oldz@?1??V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
	fstp	DWORD PTR _?oldz@?1??V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z@4MA

; 959  : 
; 960  : 		if( oldz > pparams->simorg[2] )

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _?oldz@?1??V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
	fcomp	DWORD PTR [eax+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71687

; 961  : 			oldz = pparams->simorg[2];

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _?oldz@?1??V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z@4MA, ecx
$L71687:

; 962  : 		if( pparams->simorg[2] - oldz > pparams->movevars->stepsize )

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR _?oldz@?1??V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
	mov	edx, DWORD PTR _pparams$[ebp]
	mov	eax, DWORD PTR [edx+204]
	fcomp	DWORD PTR [eax+48]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71688

; 963  : 			oldz = pparams->simorg[2] - pparams->movevars->stepsize;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _pparams$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [edx+48]
	fstp	DWORD PTR _?oldz@?1??V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
$L71688:

; 964  : 
; 965  : 		pparams->vieworg[2] += oldz - pparams->simorg[2];

	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -16+[ebp], eax
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _?oldz@?1??V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
	fsub	DWORD PTR [eax+8]
	mov	eax, DWORD PTR -16+[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR -16+[ebp]
	fstp	DWORD PTR [ecx]

; 967  : 	else

	jmp	SHORT $L71689
$L71684:

; 969  : 		oldz = pparams->simorg[2];

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _?oldz@?1??V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z@4MA, edx
$L71689:

; 971  : 
; 972  : 	lasttime = pparams->time;

	mov	eax, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _?lasttime@?1??V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z@4MA, ecx

; 973  : 
; 974  : 	V_GetChaseOrigin( pparams->viewangles, pparams->vieworg, cl_chasedist->value, pparams->vieworg );

	mov	edx, DWORD PTR _pparams$[ebp]
	push	edx
	mov	eax, DWORD PTR ?cl_chasedist@@3PAUcvar_s@@A ; cl_chasedist
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _pparams$[ebp]
	push	edx
	mov	eax, DWORD PTR _pparams$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	?V_GetChaseOrigin@@YAXABVVector@@0MAAV1@@Z ; V_GetChaseOrigin
	add	esp, 16					; 00000010H

; 975  : 
; 976  : 	float pitch = pparams->viewangles[PITCH];

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pitch$[ebp], ecx

; 977  : 
; 978  : 	// normalize angles
; 979  : 	if( pitch > 180.0f ) 

	fld	DWORD PTR _pitch$[ebp]
	fcomp	DWORD PTR __real@4@4006b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71691

; 980  : 		pitch -= 360.0f;

	fld	DWORD PTR _pitch$[ebp]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _pitch$[ebp]

; 981  : 	else if( pitch < -180.0f )

	jmp	SHORT $L71693
$L71691:
	fld	DWORD PTR _pitch$[ebp]
	fcomp	DWORD PTR __real@4@c006b400000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71693

; 982  : 		pitch += 360.0f;

	fld	DWORD PTR _pitch$[ebp]
	fadd	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _pitch$[ebp]
$L71693:

; 983  : 
; 984  : 	// player pitch is inverted
; 985  : 	pitch /= -3.0;

	fld	DWORD PTR _pitch$[ebp]
	fdiv	QWORD PTR __real@8@c000c000000000000000
	fstp	DWORD PTR _pitch$[ebp]

; 986  : 
; 987  : 	cl_entity_t *ent = GET_LOCAL_PLAYER();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+204
	mov	DWORD PTR _ent$[ebp], eax

; 988  : 
; 989  : 	// slam local player's pitch value
; 990  : 	ent->angles[PITCH] = pitch;

	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 2900				; 00000b54H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [eax], edx

; 991  : 	ent->curstate.angles[PITCH] = pitch;

	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 716				; 000002ccH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [eax], ecx

; 992  : 	ent->prevstate.angles[PITCH] = pitch;

	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 376				; 00000178H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [eax], edx

; 993  : 	ent->latched.prevangles[PITCH] = pitch;

	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 2856				; 00000b28H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [eax], ecx

; 994  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z ENDP	; V_CalcThirdPersonRefdef
_TEXT	ENDS
PUBLIC	?V_CalcWaterLevel@@YAMPAUref_params_s@@@Z	; V_CalcWaterLevel
PUBLIC	__real@4@40038000000000000000
;	COMDAT __real@4@40038000000000000000
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
__real@4@40038000000000000000 DD 041800000r	; 16
CONST	ENDS
;	COMDAT ?V_CalcWaterLevel@@YAMPAUref_params_s@@@Z
_TEXT	SEGMENT
_pparams$ = 8
_waterOffset$ = -4
_waterEntity$71700 = -8
_waterDist$71701 = -12
_pwater$71703 = -16
_point$71705 = -28
_i$71707 = -32
_contents$71711 = -36
_i$71714 = -40
_contents$71718 = -44
?V_CalcWaterLevel@@YAMPAUref_params_s@@@Z PROC NEAR	; V_CalcWaterLevel, COMDAT

; 1000 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi

; 1001 : 	float waterOffset = 0.0f;

	mov	DWORD PTR _waterOffset$[ebp], 0

; 1002 : 	
; 1003 : 	if( pparams->waterlevel >= 2 )

	mov	eax, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [eax+84], 2
	jl	$L71713

; 1005 : 		int waterEntity = WATER_ENTITY( pparams->simorg );

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+232
	add	esp, 4
	mov	DWORD PTR _waterEntity$71700[ebp], eax

; 1006 : 		float waterDist = cl_waterdist->value;

	mov	ecx, DWORD PTR ?cl_waterdist@@3PAUcvar_s@@A ; cl_waterdist
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _waterDist$71701[ebp], edx

; 1007 : 
; 1008 : 		if( waterEntity >= 0 && waterEntity < pparams->max_entities )

	cmp	DWORD PTR _waterEntity$71700[ebp], 0
	jl	SHORT $L71704
	mov	eax, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR _waterEntity$71700[ebp]
	cmp	ecx, DWORD PTR [eax+184]
	jge	SHORT $L71704

; 1010 : 			cl_entity_t *pwater = GET_ENTITY( waterEntity );

	mov	edx, DWORD PTR _waterEntity$71700[ebp]
	push	edx
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+212
	add	esp, 4
	mov	DWORD PTR _pwater$71703[ebp], eax

; 1011 : 			if( pwater && ( pwater->model != NULL ))

	cmp	DWORD PTR _pwater$71703[ebp], 0
	je	SHORT $L71704
	mov	eax, DWORD PTR _pwater$71703[ebp]
	cmp	DWORD PTR [eax+2964], 0
	je	SHORT $L71704

; 1012 : 				waterDist += ( pwater->curstate.scale * 16.0f );

	mov	ecx, DWORD PTR _pwater$71703[ebp]
	fld	DWORD PTR [ecx+752]
	fmul	DWORD PTR __real@4@40038000000000000000
	fadd	DWORD PTR _waterDist$71701[ebp]
	fstp	DWORD PTR _waterDist$71701[ebp]
$L71704:

; 1014 : 
; 1015 : 		Vector point = pparams->vieworg;

	mov	edx, DWORD PTR _pparams$[ebp]
	push	edx
	lea	ecx, DWORD PTR _point$71705[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1016 : 
; 1017 : 		// eyes are above water, make sure we're above the waves
; 1018 : 		if( pparams->waterlevel == 2 )	

	mov	eax, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [eax+84], 2
	jne	SHORT $L71706

; 1020 : 			point.z -= waterDist;

	fld	DWORD PTR _point$71705[ebp+8]
	fsub	DWORD PTR _waterDist$71701[ebp]
	fstp	DWORD PTR _point$71705[ebp+8]

; 1021 : 
; 1022 : 			for( int i = 0; i < waterDist; i++ )

	mov	DWORD PTR _i$71707[ebp], 0
	jmp	SHORT $L71708
$L71709:
	mov	ecx, DWORD PTR _i$71707[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$71707[ebp], ecx
$L71708:
	fild	DWORD PTR _i$71707[ebp]
	fcomp	DWORD PTR _waterDist$71701[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71710

; 1024 : 				int contents = POINT_CONTENTS( point );

	push	0
	lea	ecx, DWORD PTR _point$71705[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+228
	add	esp, 8
	mov	DWORD PTR _contents$71711[ebp], eax

; 1025 : 				if( contents > CONTENTS_WATER )

	cmp	DWORD PTR _contents$71711[ebp], -3	; fffffffdH
	jle	SHORT $L71712

; 1026 : 					break;

	jmp	SHORT $L71710
$L71712:

; 1027 : 				point.z += 1;

	fld	DWORD PTR _point$71705[ebp+8]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _point$71705[ebp+8]

; 1028 : 			}

	jmp	SHORT $L71709
$L71710:

; 1029 : 			waterOffset = (point.z + waterDist) - pparams->vieworg[2];

	fld	DWORD PTR _point$71705[ebp+8]
	fadd	DWORD PTR _waterDist$71701[ebp]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR -48+[ebp]
	fsub	DWORD PTR [eax+8]
	fstp	DWORD PTR _waterOffset$[ebp]

; 1031 : 		else

	jmp	$L71713
$L71706:

; 1033 : 			// eyes are under water. Make sure we're far enough under
; 1034 : 			point[2] += waterDist;

	lea	ecx, DWORD PTR _point$71705[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -52+[ebp], eax
	mov	edx, DWORD PTR -52+[ebp]
	fld	DWORD PTR _waterDist$71701[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR -52+[ebp]
	fstp	DWORD PTR [eax]

; 1035 : 
; 1036 : 			for( int i = 0; i < waterDist; i++ )

	mov	DWORD PTR _i$71714[ebp], 0
	jmp	SHORT $L71715
$L71716:
	mov	ecx, DWORD PTR _i$71714[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$71714[ebp], ecx
$L71715:
	fild	DWORD PTR _i$71714[ebp]
	fcomp	DWORD PTR _waterDist$71701[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71717

; 1038 : 				int contents = POINT_CONTENTS( point );

	push	0
	lea	ecx, DWORD PTR _point$71705[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+228
	add	esp, 8
	mov	DWORD PTR _contents$71718[ebp], eax

; 1039 : 				if( contents <= CONTENTS_WATER )

	cmp	DWORD PTR _contents$71718[ebp], -3	; fffffffdH
	jg	SHORT $L71719

; 1040 : 					break;

	jmp	SHORT $L71717
$L71719:

; 1041 : 
; 1042 : 				point.z -= 1;

	fld	DWORD PTR _point$71705[ebp+8]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _point$71705[ebp+8]

; 1043 : 			}

	jmp	SHORT $L71716
$L71717:

; 1044 : 			waterOffset = (point.z - waterDist) - pparams->vieworg[2];

	fld	DWORD PTR _point$71705[ebp+8]
	fsub	DWORD PTR _waterDist$71701[ebp]
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR -56+[ebp]
	fsub	DWORD PTR [eax+8]
	fstp	DWORD PTR _waterOffset$[ebp]
$L71713:

; 1047 : 
; 1048 : 	return waterOffset;

	fld	DWORD PTR _waterOffset$[ebp]

; 1049 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_CalcWaterLevel@@YAMPAUref_params_s@@@Z ENDP		; V_CalcWaterLevel
_TEXT	ENDS
PUBLIC	??0viewinterp_t@@QAE@XZ				; viewinterp_t::viewinterp_t
PUBLIC	?V_InterpolatePos@@YAXPAUref_params_s@@@Z	; V_InterpolatePos
PUBLIC	__real@8@00000000000000000000
PUBLIC	__real@4@40058000000000000000
_BSS	SEGMENT
_?lastorg@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4VVector@@A DB 0cH DUP (?)
_?$S13@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4EA DB 01H DUP (?)
	ALIGN	4

_?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A DB 0808H DUP (?)
_BSS	ENDS
;	COMDAT __real@8@00000000000000000000
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
__real@8@00000000000000000000 DQ 00000000000000000r ; 0
CONST	ENDS
;	COMDAT __real@4@40058000000000000000
CONST	SEGMENT
__real@4@40058000000000000000 DD 042800000r	; 64
CONST	ENDS
;	COMDAT ?V_InterpolatePos@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT
_pparams$ = 8
_view$ = -4
_delta$ = -16
_i$71755 = -20
_foundidx$71756 = -24
_t$71757 = -28
_delta$71764 = -40
_neworg$71765 = -52
_dt$71766 = -60
_frac$71767 = -68
$T72457 = -80
$T72458 = -92
$T72461 = -104
$T72462 = -116
$T72463 = -128
?V_InterpolatePos@@YAXPAUref_params_s@@@Z PROC NEAR	; V_InterpolatePos, COMDAT

; 1070 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi

; 1071 : 	static Vector lastorg;

	xor	eax, eax
	mov	al, BYTE PTR _?$S13@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L71744
	mov	cl, BYTE PTR _?$S13@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S13@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4EA, cl
	mov	ecx, OFFSET FLAT:_?lastorg@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4VVector@@A
	call	??0Vector@@QAE@XZ			; Vector::Vector
	push	OFFSET FLAT:_$E14
	call	_atexit
	add	esp, 4
$L71744:

; 1072 : 	static viewinterp_t	ViewInterp;

	xor	edx, edx
	mov	dl, BYTE PTR _?$S13@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	SHORT $L71748
	mov	al, BYTE PTR _?$S13@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S13@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4EA, al
	mov	ecx, OFFSET FLAT:_?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A
	call	??0viewinterp_t@@QAE@XZ			; viewinterp_t::viewinterp_t
	push	OFFSET FLAT:_$E15
	call	_atexit
	add	esp, 4
$L71748:

; 1073 : 
; 1074 : 	// view is the weapon model (only visible from inside body )
; 1075 : 	cl_entity_t *view = GET_VIEWMODEL();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+208
	mov	DWORD PTR _view$[ebp], eax

; 1076 : 
; 1077 : 	Vector delta = pparams->simorg - lastorg;

	push	OFFSET FLAT:_?lastorg@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4VVector@@A
	lea	ecx, DWORD PTR $T72457[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _delta$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1078 : 
; 1079 : 	if( delta.Length() != 0.0f )

	lea	ecx, DWORD PTR _delta$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L71753

; 1081 : 		ViewInterp.Origins[ViewInterp.CurrentOrigin & ORIGIN_MASK] = pparams->simorg;

	mov	edx, DWORD PTR _pparams$[ebp]
	add	edx, 100				; 00000064H
	mov	eax, DWORD PTR _?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A+2048
	and	eax, 63					; 0000003fH
	imul	eax, 12					; 0000000cH
	add	eax, OFFSET FLAT:_?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 1082 : 		ViewInterp.OriginTime[ViewInterp.CurrentOrigin & ORIGIN_MASK] = pparams->time;

	mov	eax, DWORD PTR _?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A+2048
	and	eax, 63					; 0000003fH
	mov	ecx, DWORD PTR _pparams$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A[eax*4+768], edx

; 1083 : 		ViewInterp.CurrentOrigin++;

	mov	eax, DWORD PTR _?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A+2048
	add	eax, 1
	mov	DWORD PTR _?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A+2048, eax

; 1084 : 
; 1085 : 		lastorg = pparams->simorg;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _?lastorg@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4VVector@@A, edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _?lastorg@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4VVector@@A+4, eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _?lastorg@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4VVector@@A+8, ecx
$L71753:

; 1087 : 
; 1088 : 	if( cl_vsmoothing->value && pparams->smoothing && ( pparams->maxclients > 1 ))

	mov	edx, DWORD PTR ?cl_vsmoothing@@3PAUcvar_s@@A ; cl_vsmoothing
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L71772
	mov	eax, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [eax+196], 0
	je	$L71772
	mov	ecx, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [ecx+172], 1
	jle	$L71772

; 1090 : 		int i, foundidx;
; 1091 : 		float t;
; 1092 : 
; 1093 : 		if( cl_vsmoothing->value < 0.0f )

	mov	edx, DWORD PTR ?cl_vsmoothing@@3PAUcvar_s@@A ; cl_vsmoothing
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71758

; 1094 : 			CVAR_SET_FLOAT( "cl_vsmoothing", 0.0 );

	push	0
	push	OFFSET FLAT:??_C@_0O@IMI@cl_vsmoothing?$AA@ ; `string'
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+148
	add	esp, 8
$L71758:

; 1095 : 
; 1096 : 		t = pparams->time - cl_vsmoothing->value;

	mov	eax, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR ?cl_vsmoothing@@3PAUcvar_s@@A ; cl_vsmoothing
	fld	DWORD PTR [eax+64]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _t$71757[ebp]

; 1097 : 
; 1098 : 		for( i = 1; i < ORIGIN_MASK; i++ )

	mov	DWORD PTR _i$71755[ebp], 1
	jmp	SHORT $L71759
$L71760:
	mov	edx, DWORD PTR _i$71755[ebp]
	add	edx, 1
	mov	DWORD PTR _i$71755[ebp], edx
$L71759:
	cmp	DWORD PTR _i$71755[ebp], 63		; 0000003fH
	jge	SHORT $L71761

; 1100 : 			foundidx = ViewInterp.CurrentOrigin - 1 - i;

	mov	eax, DWORD PTR _?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A+2048
	sub	eax, 1
	sub	eax, DWORD PTR _i$71755[ebp]
	mov	DWORD PTR _foundidx$71756[ebp], eax

; 1101 : 
; 1102 : 			if( ViewInterp.OriginTime[foundidx & ORIGIN_MASK] <= t )

	mov	ecx, DWORD PTR _foundidx$71756[ebp]
	and	ecx, 63					; 0000003fH
	fld	DWORD PTR _?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A[ecx*4+768]
	fcomp	DWORD PTR _t$71757[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L71762

; 1103 : 				break;

	jmp	SHORT $L71761
$L71762:

; 1104 : 		}

	jmp	SHORT $L71760
$L71761:

; 1105 : 
; 1106 : 		if( i < ORIGIN_MASK &&  ViewInterp.OriginTime[foundidx & ORIGIN_MASK] != 0.0f )

	cmp	DWORD PTR _i$71755[ebp], 63		; 0000003fH
	jge	$L71772
	mov	edx, DWORD PTR _foundidx$71756[ebp]
	and	edx, 63					; 0000003fH
	fld	DWORD PTR _?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A[edx*4+768]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L71772

; 1108 : 			// Interpolate
; 1109 : 			Vector delta, neworg;

	lea	ecx, DWORD PTR _delta$71764[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _neworg$71765[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1110 : 			double dt, frac;
; 1111 : 
; 1112 : 			dt = ViewInterp.OriginTime[(foundidx + 1) & ORIGIN_MASK] - ViewInterp.OriginTime[foundidx & ORIGIN_MASK];

	mov	eax, DWORD PTR _foundidx$71756[ebp]
	add	eax, 1
	and	eax, 63					; 0000003fH
	mov	ecx, DWORD PTR _foundidx$71756[ebp]
	and	ecx, 63					; 0000003fH
	fld	DWORD PTR _?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A[eax*4+768]
	fsub	DWORD PTR _?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A[ecx*4+768]
	fstp	QWORD PTR _dt$71766[ebp]

; 1113 : 			if( dt > 0.0f )

	fld	QWORD PTR _dt$71766[ebp]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L71772

; 1115 : 				frac = ( t - ViewInterp.OriginTime[foundidx & ORIGIN_MASK] ) / dt;

	mov	edx, DWORD PTR _foundidx$71756[ebp]
	and	edx, 63					; 0000003fH
	fld	DWORD PTR _t$71757[ebp]
	fsub	DWORD PTR _?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A[edx*4+768]
	fdiv	QWORD PTR _dt$71766[ebp]
	fstp	QWORD PTR _frac$71767[ebp]

; 1116 : 				delta = ViewInterp.Origins[( foundidx + 1 ) & ORIGIN_MASK] - ViewInterp.Origins[foundidx & ORIGIN_MASK];

	mov	eax, DWORD PTR _foundidx$71756[ebp]
	and	eax, 63					; 0000003fH
	imul	eax, 12					; 0000000cH
	add	eax, OFFSET FLAT:_?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A
	push	eax
	lea	ecx, DWORD PTR $T72458[ebp]
	push	ecx
	mov	ecx, DWORD PTR _foundidx$71756[ebp]
	add	ecx, 1
	and	ecx, 63					; 0000003fH
	imul	ecx, 12					; 0000000cH
	add	ecx, OFFSET FLAT:_?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _delta$71764[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _delta$71764[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _delta$71764[ebp+8], edx

; 1117 : 				frac = min( 1.0, frac );

	fld	QWORD PTR __real@8@3fff8000000000000000
	fcomp	QWORD PTR _frac$71767[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L72459
	mov	DWORD PTR -136+[ebp], 0
	mov	DWORD PTR -136+[ebp+4], 1072693248	; 3ff00000H
	jmp	SHORT $L72460
$L72459:
	mov	eax, DWORD PTR _frac$71767[ebp]
	mov	DWORD PTR -136+[ebp], eax
	mov	ecx, DWORD PTR _frac$71767[ebp+4]
	mov	DWORD PTR -136+[ebp+4], ecx
$L72460:
	mov	edx, DWORD PTR -136+[ebp]
	mov	DWORD PTR _frac$71767[ebp], edx
	mov	eax, DWORD PTR -136+[ebp+4]
	mov	DWORD PTR _frac$71767[ebp+4], eax

; 1118 : 
; 1119 : 				neworg = ViewInterp.Origins[foundidx & ORIGIN_MASK] + delta * frac;

	fld	QWORD PTR _frac$71767[ebp]
	fst	DWORD PTR -140+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T72461[ebp]
	push	ecx
	lea	ecx, DWORD PTR _delta$71764[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T72462[ebp]
	push	edx
	mov	ecx, DWORD PTR _foundidx$71756[ebp]
	and	ecx, 63					; 0000003fH
	imul	ecx, 12					; 0000000cH
	add	ecx, OFFSET FLAT:_?ViewInterp@?1??V_InterpolatePos@@YAXPAUref_params_s@@@Z@4Uviewinterp_t@@A
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _neworg$71765[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _neworg$71765[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _neworg$71765[ebp+8], eax

; 1120 : 
; 1121 : 				// dont interpolate large changes (less than 64 units)
; 1122 : 				if( delta.Length() < 64 )

	lea	ecx, DWORD PTR _delta$71764[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fcomp	DWORD PTR __real@4@40058000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71772

; 1124 : 					delta = neworg - pparams->simorg;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	lea	edx, DWORD PTR $T72463[ebp]
	push	edx
	lea	ecx, DWORD PTR _neworg$71765[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _delta$71764[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _delta$71764[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _delta$71764[ebp+8], eax

; 1125 : 					pparams->simorg += delta;

	lea	ecx, DWORD PTR _delta$71764[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1126 : 					pparams->vieworg += delta;

	lea	edx, DWORD PTR _delta$71764[ebp]
	push	edx
	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1127 : 					view->origin += delta;

	lea	eax, DWORD PTR _delta$71764[ebp]
	push	eax
	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=
$L71772:

; 1132 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_InterpolatePos@@YAXPAUref_params_s@@@Z ENDP		; V_InterpolatePos
_TEXT	ENDS
;	COMDAT _$E15
_TEXT	SEGMENT
_$E15	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E15	ENDP
_TEXT	ENDS
;	COMDAT _$E14
_TEXT	SEGMENT
_$E14	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E14	ENDP
_TEXT	ENDS
;	COMDAT ??0viewinterp_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0viewinterp_t@@QAE@XZ PROC NEAR			; viewinterp_t::viewinterp_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	64					; 00000040H
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	64					; 00000040H
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1024				; 00000400H
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0viewinterp_t@@QAE@XZ ENDP				; viewinterp_t::viewinterp_t
_TEXT	ENDS
PUBLIC	?V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z ; V_CalcFirstPersonRefdef
PUBLIC	__real@4@4005dc00000000000000
PUBLIC	__real@4@4005c800000000000000
PUBLIC	__real@4@4005b400000000000000
PUBLIC	__real@4@4005a000000000000000
PUBLIC	__real@8@3ffe8000000000000000
_BSS	SEGMENT
_?lasttime@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@4@4005dc00000000000000
; File z:\xashxtsrc\client\render\r_view.cpp
CONST	SEGMENT
__real@4@4005dc00000000000000 DD 042dc0000r	; 110
CONST	ENDS
;	COMDAT __real@4@4005c800000000000000
CONST	SEGMENT
__real@4@4005c800000000000000 DD 042c80000r	; 100
CONST	ENDS
;	COMDAT __real@4@4005b400000000000000
CONST	SEGMENT
__real@4@4005b400000000000000 DD 042b40000r	; 90
CONST	ENDS
;	COMDAT __real@4@4005a000000000000000
CONST	SEGMENT
__real@4@4005a000000000000000 DD 042a00000r	; 80
CONST	ENDS
;	COMDAT __real@8@3ffe8000000000000000
CONST	SEGMENT
__real@8@3ffe8000000000000000 DQ 03fe0000000000000r ; 0.5
CONST	ENDS
;	COMDAT ?V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT
_pparams$ = 8
_bob$ = -4
_waterOffset$ = -8
_view$ = -12
_lastAngles$ = -24
_steptime$71801 = -28
$T72476 = -40
$T72477 = -52
?V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z PROC NEAR ; V_CalcFirstPersonRefdef, COMDAT

; 1138 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi

; 1139 : 	V_DriftPitch( pparams );

	mov	eax, DWORD PTR _pparams$[ebp]
	push	eax
	call	?V_DriftPitch@@YAXPAUref_params_s@@@Z	; V_DriftPitch
	add	esp, 4

; 1140 : 
; 1141 : 	float bob = V_CalcBob( pparams );

	mov	ecx, DWORD PTR _pparams$[ebp]
	push	ecx
	call	?V_CalcBob@@YAMPAUref_params_s@@@Z	; V_CalcBob
	add	esp, 4
	fstp	DWORD PTR _bob$[ebp]

; 1142 : 
; 1143 : 	pparams->vieworg = pparams->simorg;

	mov	edx, DWORD PTR _pparams$[ebp]
	add	edx, 100				; 00000064H
	mov	eax, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 1144 : 	pparams->vieworg += pparams->viewheight;

	mov	eax, DWORD PTR _pparams$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1145 : 	pparams->vieworg.z += bob;

	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR _bob$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _pparams$[ebp]
	fstp	DWORD PTR [edx+8]

; 1146 : 
; 1147 : 	pparams->viewangles = pparams->cl_viewangles;

	mov	eax, DWORD PTR _pparams$[ebp]
	add	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1148 : 
; 1149 : 	gEngfuncs.V_CalcShake();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+220

; 1150 : 	gEngfuncs.V_ApplyShake( pparams->vieworg, pparams->viewangles, 1.0f );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+224
	add	esp, 12					; 0000000cH

; 1151 : 
; 1152 : 	V_CalcSendOrigin( pparams );

	mov	ecx, DWORD PTR _pparams$[ebp]
	push	ecx
	call	?V_CalcSendOrigin@@YAXPAUref_params_s@@@Z ; V_CalcSendOrigin
	add	esp, 4

; 1153 : 
; 1154 : 	float waterOffset = V_CalcWaterLevel( pparams );

	mov	edx, DWORD PTR _pparams$[ebp]
	push	edx
	call	?V_CalcWaterLevel@@YAMPAUref_params_s@@@Z ; V_CalcWaterLevel
	add	esp, 4
	fstp	DWORD PTR _waterOffset$[ebp]

; 1155 : 	pparams->vieworg[2] += waterOffset;

	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -56+[ebp], eax
	mov	eax, DWORD PTR -56+[ebp]
	fld	DWORD PTR _waterOffset$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR -56+[ebp]
	fstp	DWORD PTR [ecx]

; 1156 : 
; 1157 : 	V_CalcViewRoll( pparams );

	mov	edx, DWORD PTR _pparams$[ebp]
	push	edx
	call	?V_CalcViewRoll@@YAXPAUref_params_s@@@Z	; V_CalcViewRoll
	add	esp, 4

; 1158 : 	V_AddIdle( pparams );

	mov	eax, DWORD PTR _pparams$[ebp]
	push	eax
	call	?V_AddIdle@@YAXPAUref_params_s@@@Z	; V_AddIdle
	add	esp, 4

; 1159 : 
; 1160 : 	// offsets
; 1161 : 	AngleVectors( pparams->cl_viewangles, pparams->forward, pparams->right, pparams->up );

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 128				; 00000080H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+96
	add	esp, 16					; 00000010H

; 1162 : 
; 1163 : 	cl_entity_t *view = GET_VIEWMODEL();

	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+208
	mov	DWORD PTR _view$[ebp], eax

; 1164 : 	Vector lastAngles = view->angles = pparams->cl_viewangles;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _view$[ebp]
	add	edx, 2900				; 00000b54H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR _view$[ebp]
	add	edx, 2900				; 00000b54H
	push	edx
	lea	ecx, DWORD PTR _lastAngles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1165 : 
; 1166 : 	V_CalcGunAngle( pparams );

	mov	eax, DWORD PTR _pparams$[ebp]
	push	eax
	call	?V_CalcGunAngle@@YAXPAUref_params_s@@@Z	; V_CalcGunAngle
	add	esp, 4

; 1167 : 
; 1168 : 	// use predicted origin as view origin.
; 1169 : 	view->origin = pparams->simorg;      

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	mov	edx, DWORD PTR _view$[ebp]
	add	edx, 2888				; 00000b48H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 1170 : 	view->origin += pparams->viewheight;

	mov	edx, DWORD PTR _pparams$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1171 : 	view->origin.z += waterOffset;

	mov	eax, DWORD PTR _view$[ebp]
	fld	DWORD PTR _waterOffset$[ebp]
	fadd	DWORD PTR [eax+2896]
	mov	ecx, DWORD PTR _view$[ebp]
	fstp	DWORD PTR [ecx+2896]

; 1172 : 
; 1173 : 	// Let the viewmodel shake at about 10% of the amplitude
; 1174 : 	gEngfuncs.V_ApplyShake( view->origin, view->angles, 0.9f );

	push	1063675494				; 3f666666H
	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2900				; 00000b54H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+224
	add	esp, 12					; 0000000cH

; 1175 : 
; 1176 : 	view->origin += pparams->forward * bob * 0.4f;

	push	1053609165				; 3ecccccdH
	lea	edx, DWORD PTR $T72477[ebp]
	push	edx
	mov	eax, DWORD PTR _bob$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72476[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 24					; 00000018H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1177 : 	view->origin.z += bob;

	mov	edx, DWORD PTR _view$[ebp]
	fld	DWORD PTR _bob$[ebp]
	fadd	DWORD PTR [edx+2896]
	mov	eax, DWORD PTR _view$[ebp]
	fstp	DWORD PTR [eax+2896]

; 1178 : 
; 1179 : 	view->angles[PITCH] -= bob * 0.3f;

	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2900				; 00000b54H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR -60+[ebp], eax
	fld	DWORD PTR _bob$[ebp]
	fmul	DWORD PTR __real@4@3ffd99999a0000000000
	mov	ecx, DWORD PTR -60+[ebp]
	fsubr	DWORD PTR [ecx]
	mov	edx, DWORD PTR -60+[ebp]
	fstp	DWORD PTR [edx]

; 1180 : 	view->angles[YAW] -= bob * 0.5f;

	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2900				; 00000b54H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 4
	mov	DWORD PTR -64+[ebp], eax
	fld	DWORD PTR _bob$[ebp]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	mov	eax, DWORD PTR -64+[ebp]
	fsubr	DWORD PTR [eax]
	mov	ecx, DWORD PTR -64+[ebp]
	fstp	DWORD PTR [ecx]

; 1181 : 	view->angles[ROLL] -= bob * 1.0f;

	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2900				; 00000b54H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -68+[ebp], eax
	fld	DWORD PTR _bob$[ebp]
	fmul	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR -68+[ebp]
	fsubr	DWORD PTR [edx]
	mov	eax, DWORD PTR -68+[ebp]
	fstp	DWORD PTR [eax]

; 1182 : 	view->origin.z -= 1;

	mov	ecx, DWORD PTR _view$[ebp]
	fld	DWORD PTR [ecx+2896]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR _view$[ebp]
	fstp	DWORD PTR [edx+2896]

; 1183 : 
; 1184 : 	// fudge position around to keep amount of weapon visible
; 1185 : 	// roughly equal with different FOV
; 1186 : 	if( pparams->viewsize == 110 )

	mov	eax, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR [eax+156]
	fcomp	DWORD PTR __real@4@4005dc00000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L71789

; 1188 : 		view->origin[2] += 1;

	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -72+[ebp], eax
	mov	ecx, DWORD PTR -72+[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR -72+[ebp]
	fstp	DWORD PTR [edx]

; 1190 : 	else if( pparams->viewsize == 100 )

	jmp	$L71795
$L71789:
	mov	eax, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR [eax+156]
	fcomp	DWORD PTR __real@4@4005c800000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L71791

; 1192 : 		view->origin[2] += 2;

	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -76+[ebp], eax
	mov	ecx, DWORD PTR -76+[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@40008000000000000000
	mov	edx, DWORD PTR -76+[ebp]
	fstp	DWORD PTR [edx]

; 1194 : 	else if( pparams->viewsize == 90 )

	jmp	SHORT $L71795
$L71791:
	mov	eax, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR [eax+156]
	fcomp	DWORD PTR __real@4@4005b400000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L71793

; 1196 : 		view->origin[2] += 1;

	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -80+[ebp], eax
	mov	ecx, DWORD PTR -80+[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR -80+[ebp]
	fstp	DWORD PTR [edx]

; 1198 : 	else if( pparams->viewsize == 80 )

	jmp	SHORT $L71795
$L71793:
	mov	eax, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR [eax+156]
	fcomp	DWORD PTR __real@4@4005a000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L71795

; 1200 : 		view->origin[2] += 0.5;

	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -84+[ebp], eax
	mov	ecx, DWORD PTR -84+[ebp]
	fld	DWORD PTR [ecx]
	fadd	QWORD PTR __real@8@3ffe8000000000000000
	mov	edx, DWORD PTR -84+[ebp]
	fstp	DWORD PTR [edx]
$L71795:

; 1202 : 
; 1203 : 	V_CalcViewModelLag( pparams, view->origin, view->angles, lastAngles );

	lea	eax, DWORD PTR _lastAngles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _view$[ebp]
	add	ecx, 2900				; 00000b54H
	push	ecx
	mov	edx, DWORD PTR _view$[ebp]
	add	edx, 2888				; 00000b48H
	push	edx
	mov	eax, DWORD PTR _pparams$[ebp]
	push	eax
	call	?V_CalcViewModelLag@@YAXPAUref_params_s@@AAVVector@@1ABV2@@Z ; V_CalcViewModelLag
	add	esp, 16					; 00000010H

; 1204 : 		
; 1205 : 	pparams->viewangles += pparams->punchangle;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 160				; 000000a0H
	push	ecx
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 12					; 0000000cH
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1206 : 
; 1207 : 	static float lasttime, oldz = 0;
; 1208 : 
; 1209 : 	if( !pparams->smoothing && pparams->onground && pparams->simorg[2] - oldz > 0.0f )

	mov	edx, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [edx+196], 0
	jne	$L71800
	mov	eax, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	$L71800
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR _?oldz@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L71800

; 1211 : 		float steptime;
; 1212 : 		
; 1213 : 		steptime = pparams->time - lasttime;

	mov	ecx, DWORD PTR _pparams$[ebp]
	fld	DWORD PTR [ecx+64]
	fsub	DWORD PTR _?lasttime@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
	fstp	DWORD PTR _steptime$71801[ebp]

; 1214 : 		if( steptime < 0 ) steptime = 0;

	fld	DWORD PTR _steptime$71801[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L71802
	mov	DWORD PTR _steptime$71801[ebp], 0
$L71802:

; 1215 : 
; 1216 : 		oldz += steptime * 150.0f;

	fld	DWORD PTR _steptime$71801[ebp]
	fmul	DWORD PTR __real@4@40069600000000000000
	fadd	DWORD PTR _?oldz@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
	fstp	DWORD PTR _?oldz@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA

; 1217 : 
; 1218 : 		if( oldz > pparams->simorg[2] )

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _?oldz@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
	fcomp	DWORD PTR [eax+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71803

; 1219 : 			oldz = pparams->simorg[2];

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _?oldz@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA, edx
$L71803:

; 1220 : 		if( pparams->simorg[2] - oldz > pparams->movevars->stepsize )

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR _?oldz@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
	mov	eax, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	fcomp	DWORD PTR [ecx+48]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L71804

; 1221 : 			oldz = pparams->simorg[2] - pparams->movevars->stepsize;

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR [edx+204]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+48]
	fstp	DWORD PTR _?oldz@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
$L71804:

; 1222 : 
; 1223 : 		pparams->vieworg[2] += oldz - pparams->simorg[2];

	mov	ecx, DWORD PTR _pparams$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 8
	mov	DWORD PTR -88+[ebp], eax
	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _?oldz@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
	fsub	DWORD PTR [eax+8]
	mov	edx, DWORD PTR -88+[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR -88+[ebp]
	fstp	DWORD PTR [eax]

; 1224 : 		view->origin.z += oldz - pparams->simorg[2];

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _?oldz@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA
	fsub	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _view$[ebp]
	fadd	DWORD PTR [ecx+2896]
	mov	edx, DWORD PTR _view$[ebp]
	fstp	DWORD PTR [edx+2896]

; 1226 : 	else

	jmp	SHORT $L71805
$L71800:

; 1228 : 		oldz = pparams->simorg[2];

	mov	ecx, DWORD PTR _pparams$[ebp]
	add	ecx, 100				; 00000064H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _?oldz@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA, eax
$L71805:

; 1230 : 
; 1231 : 	lasttime = pparams->time;

	mov	ecx, DWORD PTR _pparams$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _?lasttime@?BB@??V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z@4MA, edx

; 1232 : 
; 1233 : 	// smooth player view in multiplayer
; 1234 : 	V_InterpolatePos( pparams );

	mov	eax, DWORD PTR _pparams$[ebp]
	push	eax
	call	?V_InterpolatePos@@YAXPAUref_params_s@@@Z ; V_InterpolatePos
	add	esp, 4

; 1235 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z ENDP	; V_CalcFirstPersonRefdef
_TEXT	ENDS
PUBLIC	?V_CalcRefdef@@YAXPAUref_params_s@@@Z		; V_CalcRefdef
EXTRN	_memcpy:NEAR
;	COMDAT ?V_CalcRefdef@@YAXPAUref_params_s@@@Z
_TEXT	SEGMENT
_pparams$ = 8
?V_CalcRefdef@@YAXPAUref_params_s@@@Z PROC NEAR		; V_CalcRefdef, COMDAT

; 1241 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1242 : 	// store a local copy in case we need to calc firstperson later
; 1243 : 	memcpy( &tr.viewparams, pparams, sizeof( ref_params_t ));

	push	232					; 000000e8H
	mov	eax, DWORD PTR _pparams$[ebp]
	push	eax
	push	OFFSET FLAT:?tr@@3Uref_globals_t@@A+1411720
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1244 : 
; 1245 : 	pause = pparams->paused;

	mov	ecx, DWORD PTR _pparams$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR ?pause@@3HA, edx		; pause

; 1246 : 	if( pause ) return;

	cmp	DWORD PTR ?pause@@3HA, 0		; pause
	je	SHORT $L71810
	jmp	SHORT $L71808
$L71810:

; 1247 : 
; 1248 : 	if( pparams->intermission )

	mov	eax, DWORD PTR _pparams$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $L71811

; 1250 : 		V_CalcIntermisionRefdef( pparams );

	mov	ecx, DWORD PTR _pparams$[ebp]
	push	ecx
	call	?V_CalcIntermisionRefdef@@YAXPAUref_params_s@@@Z ; V_CalcIntermisionRefdef
	add	esp, 4

; 1251 : 		V_ResetCarSmoothData();

	call	?V_ResetCarSmoothData@@YAXXZ		; V_ResetCarSmoothData

; 1253 : 	else if( pparams->viewentity > pparams->maxclients )

	jmp	SHORT $L71816
$L71811:
	mov	edx, DWORD PTR _pparams$[ebp]
	mov	eax, DWORD PTR _pparams$[ebp]
	mov	ecx, DWORD PTR [edx+176]
	cmp	ecx, DWORD PTR [eax+172]
	jle	SHORT $L71813

; 1255 : 		V_CalcCameraRefdef( pparams );

	mov	edx, DWORD PTR _pparams$[ebp]
	push	edx
	call	?V_CalcCameraRefdef@@YAXPAUref_params_s@@@Z ; V_CalcCameraRefdef
	add	esp, 4

; 1257 : 	else if( gHUD.m_iCameraMode )

	jmp	SHORT $L71816
$L71813:
	cmp	DWORD PTR ?gHUD@@3VCHud@@A+100, 0
	je	SHORT $L71815

; 1259 : 		V_CalcThirdPersonRefdef( pparams );

	mov	eax, DWORD PTR _pparams$[ebp]
	push	eax
	call	?V_CalcThirdPersonRefdef@@YAXPAUref_params_s@@@Z ; V_CalcThirdPersonRefdef
	add	esp, 4

; 1260 : 		V_ResetCarSmoothData();

	call	?V_ResetCarSmoothData@@YAXXZ		; V_ResetCarSmoothData

; 1262 : 	else

	jmp	SHORT $L71816
$L71815:

; 1264 : 		V_CalcFirstPersonRefdef( pparams );

	mov	ecx, DWORD PTR _pparams$[ebp]
	push	ecx
	call	?V_CalcFirstPersonRefdef@@YAXPAUref_params_s@@@Z ; V_CalcFirstPersonRefdef
	add	esp, 4

; 1265 : 		V_ResetCarSmoothData();

	call	?V_ResetCarSmoothData@@YAXXZ		; V_ResetCarSmoothData
$L71816:
$L71808:

; 1267 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?V_CalcRefdef@@YAXPAUref_params_s@@@Z ENDP		; V_CalcRefdef
_TEXT	ENDS
;	COMDAT ?Lerp@@YAMMABM0@Z
_TEXT	SEGMENT
_flPercent$ = 8
_A$ = 12
_B$ = 16
?Lerp@@YAMMABM0@Z PROC NEAR				; Lerp, COMDAT

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 110  : 	return A + (B - A) * flPercent;

	mov	eax, DWORD PTR _B$[ebp]
	mov	ecx, DWORD PTR _A$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fmul	DWORD PTR _flPercent$[ebp]
	mov	edx, DWORD PTR _A$[ebp]
	fadd	DWORD PTR [edx]

; 111  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Lerp@@YAMMABM0@Z ENDP					; Lerp
_TEXT	ENDS
;	COMDAT ?Lerp@@YA?AVVector@@MABV1@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
$T72494 = -12
$T72495 = -24
$T72496 = -36
_flPercent$ = 12
_A$ = 16
_B$ = 20
?Lerp@@YA?AVVector@@MABV1@0@Z PROC NEAR			; Lerp, COMDAT

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 110  : 	return A + (B - A) * flPercent;

	mov	eax, DWORD PTR _flPercent$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72495[ebp]
	push	ecx
	mov	edx, DWORD PTR _A$[ebp]
	push	edx
	lea	eax, DWORD PTR $T72494[ebp]
	push	eax
	mov	ecx, DWORD PTR _B$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T72496[ebp]
	push	ecx
	mov	ecx, DWORD PTR _A$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 111  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Lerp@@YA?AVVector@@MABV1@0@Z ENDP			; Lerp
_TEXT	ENDS
END
