	TITLE	Z:\XashXTSRC\server\monsters\monsters.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OJHA@Bad?5link?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGEN@AnimateUntilDead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09OKKL@Half?9Life?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@KAGK@CBaseMonster?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08HOFM@m_hEnemy?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@FJE@m_hTargetEnt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@KKGA@m_hOldEnemy?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@HLKI@m_vecOldEnemy?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IAEJ@m_iClass?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@DIIK@m_iPlayerReact?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EDML@m_iWeapons?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@EJPL@m_flFieldOfView?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@CEKJ@m_flWaitFinished?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@ECMG@m_flMoveWaitFinished?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IIPI@m_Activity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@PCGJ@m_IdealActivity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@LEBP@m_LastHitGroup?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@EEJP@m_MonsterState?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@PMBL@m_IdealMonsterState?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@OPCC@m_iTaskStatus?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@NCLC@m_iScheduleIndex?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@NBJH@m_afConditions?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@DKPO@m_vecMoveGoal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@DADE@m_movementActivity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@FOJJ@m_vecLastPosition?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@EOAJ@m_iHintNode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MFDO@m_afMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GGEP@m_iMaxHealth?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@EGAB@m_vecEnemyLKP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@LLME@m_cAmmoLoaded?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@DGKC@m_afCapability?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@HMMP@m_flNextAttack?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@OABJ@m_bitsDamageType?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@OJKP@m_rgbTimeBasedDamage?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@OABP@m_bloodColor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@DOGG@m_failSchedule?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NBGF@MonsterUse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@EDJO@CallMonsterThink?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@OIHI@CorpseFallThink?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@DOGB@MonsterInitThink?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@PCMA@m_flHungryTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@HDPE@m_flDistTooFar?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BEAJ@m_flDistLook?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@LKHE@m_iTriggerCondition?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@DGBK@TriggerCondition?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@CAKJ@m_iszTriggerTarget?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@IGLO@TriggerTarget?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@PGCG@m_HackedGunPos?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@BEMP@m_scriptState?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07JLGL@m_pCine?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MMMF@?$CFs?5can?8t?5assess?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@EGDB@ERROR?$CB?5monster?5?$CFs?5has?5no?5audible@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@BGPP@NULL?5Return?5from?5PBestSound?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@OICG@ERROR?$CB?5PBestScent?$CI?$CJ?5has?5empty?5so@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@KIMI@NULL?5Return?5from?5PBestScent?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@LOML@Schedule?5stalled?$CB?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOMN@Can?8t?5draw?5route?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@LGAM@z?3?2xashxtsrc?2server?2monsters?2mon@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DJLF@i?5?$DM?5count?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@KLD@outCount?5?$DM?5?$CIROUTE_SIZE?$CK2?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@IGEF@?$CBHasConditions?$CIbits_COND_SEE_ENE@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@FOLO@?$CFs?5has?5no?5sequence?5for?5act?3?$CFd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@DCCI@?$CFs?5has?5no?5sequence?5named?3?$CFf?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@OHLJ@Can?8t?5Refresh?5Route?$CB?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@PKJM@Tried?5to?5move?5with?5no?5route?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DBAJ@?$CFs?5Failed?5to?5move?5?$CI?$CFd?$CJ?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@IPGN@ReadyMonster?$CI?$CJ?9?9?$CFs?5couldn?8t?5find@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@DGMP@Can?8t?5Create?5Route?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@JKDA@Monster?5?$CFs?5stuck?5in?5wall?9?9level?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@FMEF@Movement?5completed?5twice?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@KACF@FindCover?5MinDist?5?$CI?$CF?40f?$CJ?5too?5clo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@KMIK@Graph?5not?5ready?5for?5findcover?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@KICA@FindCover?$CI?$CJ?5?9?5?$CFs?5has?5no?5nearest?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@FNFC@Graph?5not?5ready?5for?5BuildNearest@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@DHMG@BuildNearestRoute?$CI?$CJ?5?9?5?$CFs?5has?5no?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BCJE@?$CFs?5has?5no?5view_ofs?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@DAFA@player?1pl_step1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@HABK@player?1pl_step3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@NADP@player?1pl_step2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@BAOA@player?1pl_step4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@LBED@player?1pl_metal1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@PBAJ@player?1pl_metal3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@FBCM@player?1pl_metal2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@JBPD@player?1pl_metal4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@IGBB@player?1pl_dirt1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGFL@player?1pl_dirt3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGHO@player?1pl_dirt2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@KGKB@player?1pl_dirt4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@KCPJ@player?1pl_duct1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@OCLD@player?1pl_duct3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@ECJG@player?1pl_duct2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@ICEJ@player?1pl_duct4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BEOK@player?1pl_grate1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@FEKA@player?1pl_grate3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@PEIF@player?1pl_grate2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@DEFK@player?1pl_grate4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@BHLL@player?1pl_tile1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@FHPB@player?1pl_tile3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@PHNE@player?1pl_tile2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@DHAL@player?1pl_tile4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@JHCO@player?1pl_tile5?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@DKOO@player?1pl_slosh1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@HKKE@player?1pl_slosh3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@NKIB@player?1pl_slosh2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BKFO@player?1pl_slosh4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IIKC@common?1npc_step1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@GIMN@common?1npc_step2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@MIOI@common?1npc_step3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KIBC@common?1npc_step4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@CEPA@player?1pl_wade3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@EEAK@player?1pl_wade4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@KDHF@Death?5event?3?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@HNIC@INVALID?5death?5event?3?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@ECKG@common?1npc_step?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@JCJ@common?1bodydrop3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@GJND@common?1bodydrop4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@CPHF@zombie?1claw_miss2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@GMHE@Unhandled?5animation?5event?5?$CFd?5for@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@BJNE@No?5Path?5from?5?$CFd?5to?5?$CFd?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@JKBN@find_hintnode?3?5graph?5not?5ready?$CB?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04COF@None?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LDIA@Idle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CAIJ@Combat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PJFK@Alert?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04MLBM@Hunt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EJFP@Prone?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08DPMB@Scripted?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04CINP@Dead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HPGM@?$CFs?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@KHMA@State?3?5?$CFs?0?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@PLOF@Activity?5?$CFs?0?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07PCHH@Unknown?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@CHAH@Schedule?5?$CFs?0?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HOFF@Task?5?$CFd?5?$CI?$CD?$CFd?$CJ?0?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@DDHO@No?5Schedule?0?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@FEEB@?6Enemy?5is?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FJLB@No?5enemy?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08BADG@?5Moving?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@DMEN@?3?5Stopped?5for?5?$CF?42f?4?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@FDPE@?3?5In?5stopped?5anim?4?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PPAE@not?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HPKL@In?5Squad?0?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07KOPI@Leader?4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@CHJM@Yaw?5speed?3?$CF3?41f?0Health?3?5?$CF3?41f?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@MCIH@?5PRISONER?$CB?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@DMBF@?5Pre?9Disaster?$CB?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07LLGA@weapons?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@DHEH@AI?5Trigger?5Fire?5Target?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LNFJ@common?1null?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@OMMM@DropItem?$CI?$CJ?5?9?5No?5item?5name?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@DAON@DropItem?$CI?$CJ?5?9?5Didn?8t?5create?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MDCK@monster_target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector2D@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector2D@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Make2D@Vector@@QBE?AVVector2D@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CrossProduct@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FIND_ENTITY_BY_TARGETNAME@@YAPAUedict_s@@PAU1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FClassnameIs@@YAHPAUedict_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLockedByMaster@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMonsterPointer@CBaseEntity@@SAPAVCBaseMonster@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMoveDoneTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPointEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddWeapon@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CallMonsterThink@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TaskComplete@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TaskFail@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TaskIsComplete@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MovementIsComplete@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remember@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Forget@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasMemory@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Node@CGraph@@QAEAAVCNode@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Link@CGraph@@QAEAAVCLink@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NodeLink@CGraph@@QAEAAVCLink@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InSquad@CSquadMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLeader@CSquadMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CBaseMonster@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E35
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Eat@CBaseMonster@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FShouldEat@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Listen@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FLSoundVolume@CBaseMonster@@QAEMPAVCSound@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FValidateHintType@CBaseMonster@@UAEHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Look@CBaseMonster@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ISoundMask@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MonsterThink@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MonsterUse@CBaseMonster@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IgnoreConditions@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RouteClear@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RouteNew@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FRouteClear@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FRefreshRoute@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveToEnemy@CBaseMonster@@QAEHW4Activity@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveToLocation@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveToTarget@CBaseMonster@@QAEHW4Activity@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveToNode@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawRoute@@YAXPAUentvars_s@@PAUWayPoint_t@@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShouldSimplify@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WayPoint_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckAttacks@CBaseMonster@@QAEXPAVCBaseEntity@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FCanCheckAttacks@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PushEnemy@CBaseMonster@@QAEXPAVCBaseEntity@@AAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PopEnemy@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSequenceByName@CBaseMonster@@QAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OpenDoorAndWait@CBaseMonster@@QAEMPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdvanceRoute@CBaseMonster@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RouteClassify@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildRoute@CBaseMonster@@QAEHABVVector@@HPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertWaypoint@CBaseMonster@@QAEXVVector@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Move@CBaseMonster@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MonsterInit@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MonsterInitThink@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartPatrol@CBaseMonster@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMonster@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MovementComplete@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TaskIsRunning@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeIdealYaw@CBaseMonster@@QAEXVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlYawDiff@CBaseMonster@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChangeYaw@CBaseMonster@@UAEMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VecToYaw@CBaseMonster@@QAEMVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetEyePosition@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StepSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FGetNodeRoute@CBaseMonster@@QAEHVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindHintNode@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReportAIState@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FCheckAITrigger@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanPlaySequence@CBaseMonster@@UAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindLateralCover@CBaseMonster@@QAEHABVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShootAtEnemy@CBaseMonster@@QAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FacingIdeal@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FCanActiveIdle@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SentenceStop@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CorpseFallThink@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MonsterInitDead@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BBoxFlat@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnemy@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DropItem@CBaseMonster@@QAEPAVCBaseEntity@@PADABVVector@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CMonsterTarget@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CMonsterTarget@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E40
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E41
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CMonsterTarget@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CMonsterTarget@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CMonsterTarget@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCMonsterTarget@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCMonsterTarget@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCMonsterTarget@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCMonsterTarget@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMonsterTarget@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMonsterTarget@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCMonsterTarget@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??_C@_0N@KAGK@CBaseMonster?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CBaseMonster_DataDescInit@@3PAUdatamap_s@@A ; CBaseMonster_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_08HOFM@m_hEnemy?$AA@			; `string'
PUBLIC	??_C@_0N@FJE@m_hTargetEnt?$AA@			; `string'
PUBLIC	??_C@_0M@KKGA@m_hOldEnemy?$AA@			; `string'
PUBLIC	??_C@_0O@HLKI@m_vecOldEnemy?$AA@		; `string'
PUBLIC	??_C@_08IAEJ@m_iClass?$AA@			; `string'
PUBLIC	??_C@_0P@DIIK@m_iPlayerReact?$AA@		; `string'
PUBLIC	??_C@_0L@EDML@m_iWeapons?$AA@			; `string'
PUBLIC	??_C@_0BA@EJPL@m_flFieldOfView?$AA@		; `string'
PUBLIC	??_C@_0BB@CEKJ@m_flWaitFinished?$AA@		; `string'
PUBLIC	??_C@_0BF@ECMG@m_flMoveWaitFinished?$AA@	; `string'
PUBLIC	??_C@_0L@IIPI@m_Activity?$AA@			; `string'
PUBLIC	??_C@_0BA@PCGJ@m_IdealActivity?$AA@		; `string'
PUBLIC	??_C@_0P@LEBP@m_LastHitGroup?$AA@		; `string'
PUBLIC	??_C@_0P@EEJP@m_MonsterState?$AA@		; `string'
PUBLIC	??_C@_0BE@PMBL@m_IdealMonsterState?$AA@		; `string'
PUBLIC	??_C@_0O@OPCC@m_iTaskStatus?$AA@		; `string'
PUBLIC	??_C@_0BB@NCLC@m_iScheduleIndex?$AA@		; `string'
PUBLIC	??_C@_0P@NBJH@m_afConditions?$AA@		; `string'
PUBLIC	??_C@_0O@DKPO@m_vecMoveGoal?$AA@		; `string'
PUBLIC	??_C@_0BD@DADE@m_movementActivity?$AA@		; `string'
PUBLIC	??_C@_0BC@FOJJ@m_vecLastPosition?$AA@		; `string'
PUBLIC	??_C@_0M@EOAJ@m_iHintNode?$AA@			; `string'
PUBLIC	??_C@_0L@MFDO@m_afMemory?$AA@			; `string'
PUBLIC	??_C@_0N@GGEP@m_iMaxHealth?$AA@			; `string'
PUBLIC	??_C@_0O@EGAB@m_vecEnemyLKP?$AA@		; `string'
PUBLIC	??_C@_0O@LLME@m_cAmmoLoaded?$AA@		; `string'
PUBLIC	??_C@_0P@DGKC@m_afCapability?$AA@		; `string'
PUBLIC	??_C@_0P@HMMP@m_flNextAttack?$AA@		; `string'
PUBLIC	??_C@_0BB@OABJ@m_bitsDamageType?$AA@		; `string'
PUBLIC	??_C@_0BF@OJKP@m_rgbTimeBasedDamage?$AA@	; `string'
PUBLIC	??_C@_0N@OABP@m_bloodColor?$AA@			; `string'
PUBLIC	??_C@_0P@DOGG@m_failSchedule?$AA@		; `string'
PUBLIC	?m_DataMap@CBaseMonster@@2Udatamap_s@@A		; CBaseMonster::m_DataMap
PUBLIC	??_C@_04COF@None?$AA@				; `string'
PUBLIC	??_C@_04LDIA@Idle?$AA@				; `string'
PUBLIC	??_C@_06CAIJ@Combat?$AA@			; `string'
PUBLIC	??_C@_05PJFK@Alert?$AA@				; `string'
PUBLIC	??_C@_04MLBM@Hunt?$AA@				; `string'
PUBLIC	??_C@_05EJFP@Prone?$AA@				; `string'
PUBLIC	??_C@_08DPMB@Scripted?$AA@			; `string'
PUBLIC	??_C@_04CINP@Dead?$AA@				; `string'
_BSS	SEGMENT
?g_DataMapHolder@CBaseMonster_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CBaseMonster_DataDescInit::g_DataMapHolder
_BSS	ENDS
_DATA	SEGMENT
?m_DataMap@CBaseMonster@@2Udatamap_s@@A DD 00H		; CBaseMonster::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0N@KAGK@CBaseMonster?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S37	DD	FLAT:_$E36
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_08HOFM@m_hEnemy?$AA@
	DD	07a8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_0N@FJE@m_hTargetEnt?$AA@
	DD	07b0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_0M@KKGA@m_hOldEnemy?$AA@
	DD	07b8H
	DW	04H
	DW	02H
	DD	00H
	DD	00H
	DD	08H
	DD	FLAT:??_C@_0O@HLKI@m_vecOldEnemy?$AA@
	DD	07d8H
	DW	04H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08IAEJ@m_iClass?$AA@
	DD	0954H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08IAEJ@m_iClass?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0P@DIIK@m_iPlayerReact?$AA@
	DD	0958H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0P@DIIK@m_iPlayerReact?$AA@
	DD	00H
	DD	0eH
	DD	FLAT:??_C@_0L@EDML@m_iWeapons?$AA@
	DD	092cH
	DW	08H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BA@EJPL@m_flFieldOfView?$AA@
	DD	0808H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BB@CEKJ@m_flWaitFinished?$AA@
	DD	080cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BF@ECMG@m_flMoveWaitFinished?$AA@
	DD	0810H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0L@IIPI@m_Activity?$AA@
	DD	0814H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BA@PCGJ@m_IdealActivity?$AA@
	DD	0818H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0P@LEBP@m_LastHitGroup?$AA@
	DD	081cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0P@EEJP@m_MonsterState?$AA@
	DD	0820H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BE@PMBL@m_IdealMonsterState?$AA@
	DD	0824H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0O@OPCC@m_iTaskStatus?$AA@
	DD	0828H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BB@NCLC@m_iScheduleIndex?$AA@
	DD	0830H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0P@NBJH@m_afConditions?$AA@
	DD	07a4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	08H
	DD	FLAT:??_C@_0O@DKPO@m_vecMoveGoal?$AA@
	DD	08c0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BD@DADE@m_movementActivity?$AA@
	DD	08ccH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	08H
	DD	FLAT:??_C@_0BC@FOJJ@m_vecLastPosition?$AA@
	DD	08d8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0M@EOAJ@m_iHintNode?$AA@
	DD	08e4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0L@MFDO@m_afMemory?$AA@
	DD	08e8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0N@GGEP@m_iMaxHealth?$AA@
	DD	08ecH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	08H
	DD	FLAT:??_C@_0O@EGAB@m_vecEnemyLKP?$AA@
	DD	08f0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0O@LLME@m_cAmmoLoaded?$AA@
	DD	08fcH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0P@DGKC@m_afCapability?$AA@
	DD	0900H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0P@HMMP@m_flNextAttack?$AA@
	DD	0904H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BB@OABJ@m_bitsDamageType?$AA@
	DD	0908H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0eH
	DD	FLAT:??_C@_0BF@OJKP@m_rgbTimeBasedDamage?$AA@
	DD	090cH
	DW	08H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0N@OABP@m_bloodColor?$AA@
	DD	0918H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0P@DOGG@m_failSchedule?$AA@
	DD	091cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+284
_?iEnemy@?1??IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z@4PAY0BB@HA DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0fffffffeH
	DD	0fffffffeH
	DD	02H
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	0fffffffeH
	DD	0fffffffeH
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	0fffffffeH
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	0fffffffeH
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	0fffffffeH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	0fffffffeH
_?pStateNames@?1??ReportAIState@CBaseMonster@@UAEXXZ@4PAPBDA DD FLAT:??_C@_04COF@None?$AA@
	DD	FLAT:??_C@_04LDIA@Idle?$AA@
	DD	FLAT:??_C@_06CAIJ@Combat?$AA@
	DD	FLAT:??_C@_05PJFK@Alert?$AA@
	DD	FLAT:??_C@_04MLBM@Hunt?$AA@
	DD	FLAT:??_C@_05EJFP@Prone?$AA@
	DD	FLAT:??_C@_08DPMB@Scripted?$AA@
	DD	FLAT:??_C@_04CINP@Dead?$AA@
_DATA	ENDS
CRT$XCU	SEGMENT
_$S42	DD	FLAT:_$E41
CRT$XCU	ENDS
;	COMDAT ??_C@_0N@KAGK@CBaseMonster?$AA@
CONST	SEGMENT
??_C@_0N@KAGK@CBaseMonster?$AA@ DB 'CBaseMonster', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HOFM@m_hEnemy?$AA@
CONST	SEGMENT
??_C@_08HOFM@m_hEnemy?$AA@ DB 'm_hEnemy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FJE@m_hTargetEnt?$AA@
CONST	SEGMENT
??_C@_0N@FJE@m_hTargetEnt?$AA@ DB 'm_hTargetEnt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KKGA@m_hOldEnemy?$AA@
CONST	SEGMENT
??_C@_0M@KKGA@m_hOldEnemy?$AA@ DB 'm_hOldEnemy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HLKI@m_vecOldEnemy?$AA@
CONST	SEGMENT
??_C@_0O@HLKI@m_vecOldEnemy?$AA@ DB 'm_vecOldEnemy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IAEJ@m_iClass?$AA@
CONST	SEGMENT
??_C@_08IAEJ@m_iClass?$AA@ DB 'm_iClass', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DIIK@m_iPlayerReact?$AA@
CONST	SEGMENT
??_C@_0P@DIIK@m_iPlayerReact?$AA@ DB 'm_iPlayerReact', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EDML@m_iWeapons?$AA@
CONST	SEGMENT
??_C@_0L@EDML@m_iWeapons?$AA@ DB 'm_iWeapons', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EJPL@m_flFieldOfView?$AA@
CONST	SEGMENT
??_C@_0BA@EJPL@m_flFieldOfView?$AA@ DB 'm_flFieldOfView', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CEKJ@m_flWaitFinished?$AA@
CONST	SEGMENT
??_C@_0BB@CEKJ@m_flWaitFinished?$AA@ DB 'm_flWaitFinished', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ECMG@m_flMoveWaitFinished?$AA@
CONST	SEGMENT
??_C@_0BF@ECMG@m_flMoveWaitFinished?$AA@ DB 'm_flMoveWaitFinished', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IIPI@m_Activity?$AA@
CONST	SEGMENT
??_C@_0L@IIPI@m_Activity?$AA@ DB 'm_Activity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PCGJ@m_IdealActivity?$AA@
CONST	SEGMENT
??_C@_0BA@PCGJ@m_IdealActivity?$AA@ DB 'm_IdealActivity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LEBP@m_LastHitGroup?$AA@
CONST	SEGMENT
??_C@_0P@LEBP@m_LastHitGroup?$AA@ DB 'm_LastHitGroup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EEJP@m_MonsterState?$AA@
CONST	SEGMENT
??_C@_0P@EEJP@m_MonsterState?$AA@ DB 'm_MonsterState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PMBL@m_IdealMonsterState?$AA@
CONST	SEGMENT
??_C@_0BE@PMBL@m_IdealMonsterState?$AA@ DB 'm_IdealMonsterState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OPCC@m_iTaskStatus?$AA@
CONST	SEGMENT
??_C@_0O@OPCC@m_iTaskStatus?$AA@ DB 'm_iTaskStatus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NCLC@m_iScheduleIndex?$AA@
CONST	SEGMENT
??_C@_0BB@NCLC@m_iScheduleIndex?$AA@ DB 'm_iScheduleIndex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NBJH@m_afConditions?$AA@
CONST	SEGMENT
??_C@_0P@NBJH@m_afConditions?$AA@ DB 'm_afConditions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DKPO@m_vecMoveGoal?$AA@
CONST	SEGMENT
??_C@_0O@DKPO@m_vecMoveGoal?$AA@ DB 'm_vecMoveGoal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DADE@m_movementActivity?$AA@
CONST	SEGMENT
??_C@_0BD@DADE@m_movementActivity?$AA@ DB 'm_movementActivity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FOJJ@m_vecLastPosition?$AA@
CONST	SEGMENT
??_C@_0BC@FOJJ@m_vecLastPosition?$AA@ DB 'm_vecLastPosition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EOAJ@m_iHintNode?$AA@
CONST	SEGMENT
??_C@_0M@EOAJ@m_iHintNode?$AA@ DB 'm_iHintNode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MFDO@m_afMemory?$AA@
CONST	SEGMENT
??_C@_0L@MFDO@m_afMemory?$AA@ DB 'm_afMemory', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GGEP@m_iMaxHealth?$AA@
CONST	SEGMENT
??_C@_0N@GGEP@m_iMaxHealth?$AA@ DB 'm_iMaxHealth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EGAB@m_vecEnemyLKP?$AA@
CONST	SEGMENT
??_C@_0O@EGAB@m_vecEnemyLKP?$AA@ DB 'm_vecEnemyLKP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LLME@m_cAmmoLoaded?$AA@
CONST	SEGMENT
??_C@_0O@LLME@m_cAmmoLoaded?$AA@ DB 'm_cAmmoLoaded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DGKC@m_afCapability?$AA@
CONST	SEGMENT
??_C@_0P@DGKC@m_afCapability?$AA@ DB 'm_afCapability', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HMMP@m_flNextAttack?$AA@
CONST	SEGMENT
??_C@_0P@HMMP@m_flNextAttack?$AA@ DB 'm_flNextAttack', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OABJ@m_bitsDamageType?$AA@
CONST	SEGMENT
??_C@_0BB@OABJ@m_bitsDamageType?$AA@ DB 'm_bitsDamageType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OJKP@m_rgbTimeBasedDamage?$AA@
CONST	SEGMENT
??_C@_0BF@OJKP@m_rgbTimeBasedDamage?$AA@ DB 'm_rgbTimeBasedDamage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OABP@m_bloodColor?$AA@
CONST	SEGMENT
??_C@_0N@OABP@m_bloodColor?$AA@ DB 'm_bloodColor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DOGG@m_failSchedule?$AA@
CONST	SEGMENT
??_C@_0P@DOGG@m_failSchedule?$AA@ DB 'm_failSchedule', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04COF@None?$AA@
CONST	SEGMENT
??_C@_04COF@None?$AA@ DB 'None', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LDIA@Idle?$AA@
CONST	SEGMENT
??_C@_04LDIA@Idle?$AA@ DB 'Idle', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CAIJ@Combat?$AA@
CONST	SEGMENT
??_C@_06CAIJ@Combat?$AA@ DB 'Combat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PJFK@Alert?$AA@
CONST	SEGMENT
??_C@_05PJFK@Alert?$AA@ DB 'Alert', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLBM@Hunt?$AA@
CONST	SEGMENT
??_C@_04MLBM@Hunt?$AA@ DB 'Hunt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05EJFP@Prone?$AA@
CONST	SEGMENT
??_C@_05EJFP@Prone?$AA@ DB 'Prone', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DPMB@Scripted?$AA@
CONST	SEGMENT
??_C@_08DPMB@Scripted?$AA@ DB 'Scripted', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CINP@Dead?$AA@
CONST	SEGMENT
??_C@_04CINP@Dead?$AA@ DB 'Dead', 00H			; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ ; CBaseMonster::GetDataDescMap
;	COMDAT ?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ PROC NEAR ; CBaseMonster::GetDataDescMap, COMDAT

; 56   : BEGIN_DATADESC( CBaseMonster )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CBaseMonster@@2Udatamap_s@@A ; CBaseMonster::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ ENDP	; CBaseMonster::GetDataDescMap
_TEXT	ENDS
PUBLIC	?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z ; DataMapAccess
PUBLIC	?GetBaseMap@CBaseMonster@@SAPAUdatamap_s@@XZ	; CBaseMonster::GetBaseMap
;	COMDAT ?GetBaseMap@CBaseMonster@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CBaseMonster@@SAPAUdatamap_s@@XZ PROC NEAR	; CBaseMonster::GetBaseMap, COMDAT

; 56   : BEGIN_DATADESC( CBaseMonster )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CBaseMonster@@SAPAUdatamap_s@@XZ ENDP	; CBaseMonster::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT
_$E36	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E35
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E36	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z ; DataMapInit
;	COMDAT _$E35
_TEXT	SEGMENT
_$E35	PROC NEAR					; COMDAT

; 56   : BEGIN_DATADESC( CBaseMonster )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CBaseMonster_DataDescInit@@3PAUdatamap_s@@A, eax ; CBaseMonster_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E35	ENDP
_TEXT	ENDS
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
PUBLIC	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
PUBLIC	??_C@_0L@NBGF@MonsterUse?$AA@			; `string'
PUBLIC	??_C@_0BB@EDJO@CallMonsterThink?$AA@		; `string'
PUBLIC	??_C@_0BA@OIHI@CorpseFallThink?$AA@		; `string'
PUBLIC	??_C@_0BB@DOGB@MonsterInitThink?$AA@		; `string'
PUBLIC	??_C@_0P@PCMA@m_flHungryTime?$AA@		; `string'
PUBLIC	??_C@_0P@HDPE@m_flDistTooFar?$AA@		; `string'
PUBLIC	??_C@_0N@BEAJ@m_flDistLook?$AA@			; `string'
PUBLIC	??_C@_0BE@LKHE@m_iTriggerCondition?$AA@		; `string'
PUBLIC	??_C@_0BB@DGBK@TriggerCondition?$AA@		; `string'
PUBLIC	??_C@_0BD@CAKJ@m_iszTriggerTarget?$AA@		; `string'
PUBLIC	??_C@_0O@IGLO@TriggerTarget?$AA@		; `string'
PUBLIC	??_C@_0P@PGCG@m_HackedGunPos?$AA@		; `string'
PUBLIC	??_C@_0O@BEMP@m_scriptState?$AA@		; `string'
PUBLIC	??_C@_07JLGL@m_pCine?$AA@			; `string'
PUBLIC	?MonsterUse@CBaseMonster@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CBaseMonster::MonsterUse
PUBLIC	?CallMonsterThink@CBaseMonster@@QAEXXZ		; CBaseMonster::CallMonsterThink
PUBLIC	?CorpseFallThink@CBaseMonster@@QAEXXZ		; CBaseMonster::CorpseFallThink
PUBLIC	?MonsterInitThink@CBaseMonster@@QAEXXZ		; CBaseMonster::MonsterInitThink
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0L@NBGF@MonsterUse?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0L@NBGF@MonsterUse?$AA@ DB 'MonsterUse', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EDJO@CallMonsterThink?$AA@
CONST	SEGMENT
??_C@_0BB@EDJO@CallMonsterThink?$AA@ DB 'CallMonsterThink', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OIHI@CorpseFallThink?$AA@
CONST	SEGMENT
??_C@_0BA@OIHI@CorpseFallThink?$AA@ DB 'CorpseFallThink', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DOGB@MonsterInitThink?$AA@
CONST	SEGMENT
??_C@_0BB@DOGB@MonsterInitThink?$AA@ DB 'MonsterInitThink', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PCMA@m_flHungryTime?$AA@
CONST	SEGMENT
??_C@_0P@PCMA@m_flHungryTime?$AA@ DB 'm_flHungryTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HDPE@m_flDistTooFar?$AA@
CONST	SEGMENT
??_C@_0P@HDPE@m_flDistTooFar?$AA@ DB 'm_flDistTooFar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BEAJ@m_flDistLook?$AA@
CONST	SEGMENT
??_C@_0N@BEAJ@m_flDistLook?$AA@ DB 'm_flDistLook', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LKHE@m_iTriggerCondition?$AA@
CONST	SEGMENT
??_C@_0BE@LKHE@m_iTriggerCondition?$AA@ DB 'm_iTriggerCondition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DGBK@TriggerCondition?$AA@
CONST	SEGMENT
??_C@_0BB@DGBK@TriggerCondition?$AA@ DB 'TriggerCondition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CAKJ@m_iszTriggerTarget?$AA@
CONST	SEGMENT
??_C@_0BD@CAKJ@m_iszTriggerTarget?$AA@ DB 'm_iszTriggerTarget', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IGLO@TriggerTarget?$AA@
CONST	SEGMENT
??_C@_0O@IGLO@TriggerTarget?$AA@ DB 'TriggerTarget', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PGCG@m_HackedGunPos?$AA@
CONST	SEGMENT
??_C@_0P@PGCG@m_HackedGunPos?$AA@ DB 'm_HackedGunPos', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BEMP@m_scriptState?$AA@
CONST	SEGMENT
??_C@_0O@BEMP@m_scriptState?$AA@ DB 'm_scriptState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JLGL@m_pCine?$AA@
CONST	SEGMENT
??_C@_07JLGL@m_pCine?$AA@ DB 'm_pCine', 00H		; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z PROC NEAR ; DataMapInit, COMDAT

; 56   : BEGIN_DATADESC( CBaseMonster )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L39564
	mov	cl, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0N@KAGK@CBaseMonster?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E39
	call	_atexit
	add	esp, 4
$L39564:
	call	?GetBaseMap@CBaseMonster@@SAPAUdatamap_s@@XZ ; CBaseMonster::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CBaseMonster@@2Udatamap_s@@A+12, eax

; 57   : 	DEFINE_FIELD( m_hEnemy, FIELD_EHANDLE ),
; 58   : 	DEFINE_FIELD( m_hTargetEnt, FIELD_EHANDLE ),
; 59   : 	DEFINE_AUTO_ARRAY( m_hOldEnemy, FIELD_EHANDLE ),
; 60   : 	DEFINE_AUTO_ARRAY( m_vecOldEnemy, FIELD_POSITION_VECTOR ),
; 61   : 
; 62   : 	DEFINE_KEYFIELD( m_iClass, FIELD_INTEGER, "m_iClass" ),
; 63   : 	DEFINE_KEYFIELD( m_iPlayerReact, FIELD_INTEGER, "m_iPlayerReact" ),
; 64   : 	DEFINE_AUTO_ARRAY( m_iWeapons, FIELD_CHARACTER ),
; 65   : 
; 66   : 	DEFINE_FIELD( m_flFieldOfView, FIELD_FLOAT ),
; 67   : 	DEFINE_FIELD( m_flWaitFinished, FIELD_TIME ),
; 68   : 	DEFINE_FIELD( m_flMoveWaitFinished, FIELD_TIME ),
; 69   : 
; 70   : 	DEFINE_FIELD( m_Activity, FIELD_INTEGER ),
; 71   : 	DEFINE_FIELD( m_IdealActivity, FIELD_INTEGER ),
; 72   : 	DEFINE_FIELD( m_LastHitGroup, FIELD_INTEGER ),
; 73   : 	DEFINE_FIELD( m_MonsterState, FIELD_INTEGER ),
; 74   : 	DEFINE_FIELD( m_IdealMonsterState, FIELD_INTEGER ),
; 75   : 	DEFINE_FIELD( m_iTaskStatus, FIELD_INTEGER ),
; 76   : 
; 77   : 	DEFINE_FIELD( m_iScheduleIndex, FIELD_INTEGER ),
; 78   : 	DEFINE_FIELD( m_afConditions, FIELD_INTEGER ),
; 79   : 
; 80   : 	DEFINE_FIELD( m_vecMoveGoal, FIELD_POSITION_VECTOR ),
; 81   : 	DEFINE_FIELD( m_movementActivity, FIELD_INTEGER ),
; 82   : 
; 83   : 	DEFINE_FIELD( m_vecLastPosition, FIELD_POSITION_VECTOR ),
; 84   : 	DEFINE_FIELD( m_iHintNode, FIELD_INTEGER ),
; 85   : 	DEFINE_FIELD( m_afMemory, FIELD_INTEGER ),
; 86   : 	DEFINE_FIELD( m_iMaxHealth, FIELD_INTEGER ),
; 87   : 
; 88   : 	DEFINE_FIELD( m_vecEnemyLKP, FIELD_POSITION_VECTOR ),
; 89   : 	DEFINE_FIELD( m_cAmmoLoaded, FIELD_INTEGER ),
; 90   : 	DEFINE_FIELD( m_afCapability, FIELD_INTEGER ),
; 91   : 
; 92   : 	DEFINE_FIELD( m_flNextAttack, FIELD_TIME ),
; 93   : 	DEFINE_FIELD( m_bitsDamageType, FIELD_INTEGER ),
; 94   : 	DEFINE_ARRAY( m_rgbTimeBasedDamage, FIELD_CHARACTER, CDMG_TIMEBASED ),
; 95   : 	DEFINE_FIELD( m_bloodColor, FIELD_INTEGER ),
; 96   : 	DEFINE_FIELD( m_failSchedule, FIELD_INTEGER ),
; 97   : 
; 98   : 	// function pointers
; 99   : 	DEFINE_FUNCTION( MonsterUse ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L39670
	mov	al, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_0L@NBGF@MonsterUse?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+796, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+800, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+804, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+806, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+808, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+812, OFFSET FLAT:?MonsterUse@CBaseMonster@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CBaseMonster::MonsterUse

; 100  : 	DEFINE_FUNCTION( CallMonsterThink ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+816, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0BB@EDJO@CallMonsterThink?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+820, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+824, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+828, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+830, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+832, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+836, OFFSET FLAT:?CallMonsterThink@CBaseMonster@@QAEXXZ ; CBaseMonster::CallMonsterThink

; 101  : 	DEFINE_FUNCTION( CorpseFallThink ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+840, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0BA@OIHI@CorpseFallThink?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+844, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+848, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+852, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+854, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+856, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+860, OFFSET FLAT:?CorpseFallThink@CBaseMonster@@QAEXXZ ; CBaseMonster::CorpseFallThink

; 102  : 	DEFINE_FUNCTION( MonsterInitThink ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+864, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0BB@DOGB@MonsterInitThink?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+868, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+872, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+876, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+878, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+880, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+884, OFFSET FLAT:?MonsterInitThink@CBaseMonster@@QAEXXZ ; CBaseMonster::MonsterInitThink

; 103  : 
; 104  : 	DEFINE_FIELD( m_flHungryTime, FIELD_TIME ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+888, 15 ; 0000000fH
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+892, OFFSET FLAT:??_C@_0P@PCMA@m_flHungryTime?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+896, 2336 ; 00000920H
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+900, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+902, 2
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+904, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+908, 0

; 105  : 	DEFINE_FIELD( m_flDistTooFar, FIELD_FLOAT ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+912, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+916, OFFSET FLAT:??_C@_0P@HDPE@m_flDistTooFar?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+920, 2340 ; 00000924H
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+924, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+926, 2
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+928, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+932, 0

; 106  : 	DEFINE_FIELD( m_flDistLook, FIELD_FLOAT ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+936, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+940, OFFSET FLAT:??_C@_0N@BEAJ@m_flDistLook?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+944, 2344 ; 00000928H
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+948, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+950, 2
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+952, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+956, 0

; 107  : 	DEFINE_KEYFIELD( m_iTriggerCondition, FIELD_INTEGER, "TriggerCondition" ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+960, 10 ; 0000000aH
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+964, OFFSET FLAT:??_C@_0BE@LKHE@m_iTriggerCondition?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+968, 2356 ; 00000934H
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+972, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+974, 6
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+976, OFFSET FLAT:??_C@_0BB@DGBK@TriggerCondition?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+980, 0

; 108  : 	DEFINE_KEYFIELD( m_iszTriggerTarget, FIELD_STRING, "TriggerTarget" ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+984, 1
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+988, OFFSET FLAT:??_C@_0BD@CAKJ@m_iszTriggerTarget?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+992, 2360 ; 00000938H
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+996, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+998, 6
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1000, OFFSET FLAT:??_C@_0O@IGLO@TriggerTarget?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1004, 0

; 109  : 	DEFINE_FIELD( m_HackedGunPos, FIELD_VECTOR ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1008, 7
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1012, OFFSET FLAT:??_C@_0P@PGCG@m_HackedGunPos?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1016, 2364 ; 0000093cH
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1020, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1022, 2
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1024, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1028, 0

; 110  : 	DEFINE_FIELD( m_scriptState, FIELD_INTEGER ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1032, 10 ; 0000000aH
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1036, OFFSET FLAT:??_C@_0O@BEMP@m_scriptState?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1040, 2380 ; 0000094cH
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1044, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1046, 2
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1048, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1052, 0

; 111  : 	DEFINE_FIELD( m_pCine, FIELD_CLASSPTR ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1056, 3
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1060, OFFSET FLAT:??_C@_07JLGL@m_pCine?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1064, 2384 ; 00000950H
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1068, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1070, 2
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1072, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+1076, 0
$L39670:

; 112  : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L39709
	mov	DWORD PTR ?m_DataMap@CBaseMonster@@2Udatamap_s@@A+4, 44 ; 0000002cH
	mov	DWORD PTR ?m_DataMap@CBaseMonster@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L39710
$L39709:
	mov	DWORD PTR ?m_DataMap@CBaseMonster@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CBaseMonster@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4PAUtypedescription_s@@A
$L39710:
	mov	eax, OFFSET FLAT:?m_DataMap@CBaseMonster@@2Udatamap_s@@A ; CBaseMonster::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z ENDP	; DataMapInit
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
EXTRN	_strlen:NEAR
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_pszBase$ = 8
_this$ = -4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC NEAR	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
PUBLIC	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
PUBLIC	??_C@_04NHIK@?$CFs?3?3?$AA@			; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_strcat:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
; File z:\xashxtsrc\common\datamap.h
CONST	SEGMENT
??_C@_04NHIK@?$CFs?3?3?$AA@ DB '%s::', 00H		; `string'
CONST	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT
_pszIdentifier$ = 8
_this$ = -4
_pBuf$ = -8
$T41870 = -12
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z PROC NEAR ; CDatadescGeneratedNameHolder::GenerateName, COMDAT

; 205  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		char *pBuf = new char[m_nLenBase + strlen(pszIdentifier) + 1];

	mov	eax, DWORD PTR _pszIdentifier$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax+1]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T41870[ebp], eax
	mov	ecx, DWORD PTR $T41870[ebp]
	mov	DWORD PTR _pBuf$[ebp], ecx

; 207  : 		sprintf( pBuf, "%s::", m_pszBase );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_04NHIK@?$CFs?3?3?$AA@	; `string'
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 208  : 		strcat( pBuf, pszIdentifier );

	mov	edx, DWORD PTR _pszIdentifier$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 209  : 		m_Names.AddToTail( pBuf );

	lea	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail

; 210  : 		return pBuf;

	mov	eax, DWORD PTR _pBuf$[ebp]

; 211  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ENDP ; CDatadescGeneratedNameHolder::GenerateName
_TEXT	ENDS
;	COMDAT ?CallMonsterThink@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CallMonsterThink@CBaseMonster@@QAEXXZ PROC NEAR	; CBaseMonster::CallMonsterThink, COMDAT

; 156  : 		void CallMonsterThink( void ) { this->MonsterThink(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+360]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CallMonsterThink@CBaseMonster@@QAEXXZ ENDP		; CBaseMonster::CallMonsterThink
_TEXT	ENDS
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E39
_TEXT	SEGMENT
_$E39	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseMonster@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E39	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File z:\xashxtsrc\common\datamap.h
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
_i$ = -20
$T41877 = -24
__$EHRec$ = -12
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC NEAR	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L30214
$L30215:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L30214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L30216

; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T41877[ebp], edx
	mov	eax, DWORD PTR $T41877[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 		}

	jmp	SHORT $L30215
$L30216:

; 202  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	ret	0
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
PUBLIC	?RouteClear@CBaseMonster@@QAEXXZ		; CBaseMonster::RouteClear
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z	; CBaseMonster::Restore
EXTRN	?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z:NEAR	; CBaseToggle::Restore
;	COMDAT ?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
_TEXT	SEGMENT
_restore$ = 8
_this$ = -4
_status$ = -8
?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z PROC NEAR	; CBaseMonster::Restore, COMDAT

; 115  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 	int status = BaseClass::Restore(restore);

	mov	eax, DWORD PTR _restore$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z ; CBaseToggle::Restore
	mov	DWORD PTR _status$[ebp], eax

; 117  : 	if ( !status )

	cmp	DWORD PTR _status$[ebp], 0
	jne	SHORT $L39717

; 118  : 		return 0;

	xor	eax, eax
	jmp	SHORT $L39715
$L39717:

; 119  : 	
; 120  : 	// We don't save/restore routes yet
; 121  : 	RouteClear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RouteClear@CBaseMonster@@QAEXXZ	; CBaseMonster::RouteClear

; 122  : 
; 123  : 	// We don't save/restore schedules yet
; 124  : 	m_pSchedule = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2092], 0

; 125  : 	m_iTaskStatus = TASKSTATUS_NEW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2088], 0

; 126  : 	
; 127  : 	// Reset animation
; 128  : 	m_Activity = ACT_RESET;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2068], 0

; 129  : 
; 130  : 	// If we don't have an enemy, clear conditions like see enemy, etc.
; 131  : 	if ( m_hEnemy == NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $L39718

; 132  : 		m_afConditions = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1956], 0
$L39718:

; 133  : 
; 134  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$L39715:

; 135  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z ENDP		; CBaseMonster::Restore
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
PUBLIC	?Eat@CBaseMonster@@QAEXM@Z			; CBaseMonster::Eat
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
EXTRN	__fltused:NEAR
;	COMDAT ?Eat@CBaseMonster@@QAEXM@Z
_TEXT	SEGMENT
_flFullDuration$ = 8
_this$ = -4
?Eat@CBaseMonster@@QAEXM@Z PROC NEAR			; CBaseMonster::Eat, COMDAT

; 142  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 	m_flHungryTime = gpGlobals->time + flFullDuration;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _flFullDuration$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2336]

; 144  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Eat@CBaseMonster@@QAEXM@Z ENDP				; CBaseMonster::Eat
_TEXT	ENDS
PUBLIC	?FShouldEat@CBaseMonster@@QAEHXZ		; CBaseMonster::FShouldEat
;	COMDAT ?FShouldEat@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FShouldEat@CBaseMonster@@QAEHXZ PROC NEAR		; CBaseMonster::FShouldEat, COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 151  : 	if ( m_flHungryTime > gpGlobals->time )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+2336]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39727

; 153  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L39726
$L39727:

; 155  : 
; 156  : 	return TRUE;

	mov	eax, 1
$L39726:

; 157  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FShouldEat@CBaseMonster@@QAEHXZ ENDP			; CBaseMonster::FShouldEat
_TEXT	ENDS
PUBLIC	?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z ; CBaseMonster::BarnacleVictimBitten
EXTRN	?ChangeSchedule@CBaseMonster@@QAEXPAUSchedule_t@@@Z:NEAR ; CBaseMonster::ChangeSchedule
;	COMDAT ?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pNewSchedule$ = -8
?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z PROC NEAR ; CBaseMonster::BarnacleVictimBitten, COMDAT

; 165  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 	Schedule_t	*pNewSchedule;
; 167  : 
; 168  : 	pNewSchedule = GetScheduleOfType( SCHED_BARNACLE_VICTIM_CHOMP );

	push	39					; 00000027H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	mov	DWORD PTR _pNewSchedule$[ebp], eax

; 169  : 
; 170  : 	if ( pNewSchedule )

	cmp	DWORD PTR _pNewSchedule$[ebp], 0
	je	SHORT $L39733

; 172  : 		ChangeSchedule( pNewSchedule );

	mov	eax, DWORD PTR _pNewSchedule$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeSchedule@CBaseMonster@@QAEXPAUSchedule_t@@@Z ; CBaseMonster::ChangeSchedule
$L39733:

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z ENDP ; CBaseMonster::BarnacleVictimBitten
_TEXT	ENDS
PUBLIC	?BarnacleVictimReleased@CBaseMonster@@UAEXXZ	; CBaseMonster::BarnacleVictimReleased
EXTRN	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsVelocity
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
;	COMDAT ?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?BarnacleVictimReleased@CBaseMonster@@UAEXXZ PROC NEAR	; CBaseMonster::BarnacleVictimReleased, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 182  : 	m_IdealMonsterState = MONSTERSTATE_IDLE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2084], 1

; 183  : 
; 184  : 	SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 185  : 	pev->movetype = MOVETYPE_STEP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+264], 4

; 186  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BarnacleVictimReleased@CBaseMonster@@UAEXXZ ENDP	; CBaseMonster::BarnacleVictimReleased
_TEXT	ENDS
PUBLIC	?SetConditions@CBaseMonster@@QAEXH@Z		; CBaseMonster::SetConditions
PUBLIC	?ClearConditions@CBaseMonster@@QAEXH@Z		; CBaseMonster::ClearConditions
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	?Listen@CBaseMonster@@QAEXXZ			; CBaseMonster::Listen
EXTRN	?FIsSound@CSound@@QAEHXZ:NEAR			; CSound::FIsSound
EXTRN	?ActiveList@CSoundEnt@@SAHXZ:NEAR		; CSoundEnt::ActiveList
EXTRN	?SoundPointerForIndex@CSoundEnt@@SAPAVCSound@@H@Z:NEAR ; CSoundEnt::SoundPointerForIndex
;	COMDAT ?Listen@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_iSound$ = -8
_iMySounds$ = -12
_hearingSensitivity$ = -16
_pCurrentSound$ = -20
$T41906 = -32
$T41907 = -44
?Listen@CBaseMonster@@QAEXXZ PROC NEAR			; CBaseMonster::Listen, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 194  : 	int		iSound;
; 195  : 	int		iMySounds;
; 196  : 	float	hearingSensitivity;
; 197  : 	CSound	*pCurrentSound;
; 198  : 
; 199  : 	m_iAudibleList = SOUNDLIST_EMPTY; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2256], -1

; 200  : 	ClearConditions(bits_COND_HEAR_SOUND | bits_COND_SMELL | bits_COND_SMELL_FOOD);

	push	393280					; 00060040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::ClearConditions

; 201  : 	m_afSoundTypes = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2260], 0

; 202  : 
; 203  : 	iMySounds = ISoundMask();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+540]
	mov	DWORD PTR _iMySounds$[ebp], eax

; 204  : 
; 205  : 	if ( m_pSchedule )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2092], 0
	je	SHORT $L39746

; 207  : 		//!!!WATCH THIS SPOT IF YOU ARE HAVING SOUND RELATED BUGS!
; 208  : 		// Make sure your schedule AND personal sound masks agree!
; 209  : 		iMySounds &= m_pSchedule->iSoundMask;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2092]
	mov	ecx, DWORD PTR _iMySounds$[ebp]
	and	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _iMySounds$[ebp], ecx
$L39746:

; 211  : 
; 212  : 	iSound = CSoundEnt::ActiveList();

	call	?ActiveList@CSoundEnt@@SAHXZ		; CSoundEnt::ActiveList
	mov	DWORD PTR _iSound$[ebp], eax

; 213  : 
; 214  : 	// UNDONE: Clear these here?
; 215  : 	ClearConditions( bits_COND_HEAR_SOUND | bits_COND_SMELL_FOOD | bits_COND_SMELL );

	push	393280					; 00060040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::ClearConditions

; 216  : 	hearingSensitivity = HearingSensitivity( );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+552]
	fstp	DWORD PTR _hearingSensitivity$[ebp]
$L39748:

; 217  : 
; 218  : 	while ( iSound != SOUNDLIST_EMPTY )

	cmp	DWORD PTR _iSound$[ebp], -1
	je	$L39749

; 220  : 		pCurrentSound = CSoundEnt::SoundPointerForIndex( iSound );

	mov	ecx, DWORD PTR _iSound$[ebp]
	push	ecx
	call	?SoundPointerForIndex@CSoundEnt@@SAPAVCSound@@H@Z ; CSoundEnt::SoundPointerForIndex
	add	esp, 4
	mov	DWORD PTR _pCurrentSound$[ebp], eax

; 223  : 			 ( pCurrentSound->m_iType & iMySounds )	&& 
; 224  : 			 ( pCurrentSound->m_vecOrigin - EarPosition() ).Length() <= pCurrentSound->m_iVolume * hearingSensitivity )

	cmp	DWORD PTR _pCurrentSound$[ebp], 0
	je	$L39752
	mov	edx, DWORD PTR _pCurrentSound$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, DWORD PTR _iMySounds$[ebp]
	test	eax, eax
	je	$L39752
	lea	ecx, DWORD PTR $T41906[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+312]
	push	eax
	lea	ecx, DWORD PTR $T41907[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCurrentSound$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	mov	edx, DWORD PTR _pCurrentSound$[ebp]
	fild	DWORD PTR [edx+16]
	fmul	DWORD PTR _hearingSensitivity$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	$L39752

; 228  :  			// the monster cares about this sound, and it's close enough to hear.
; 229  : 			//g_pSoundEnt->m_SoundPool[ iSound ].m_iNextAudible = m_iAudibleList;
; 230  : 			pCurrentSound->m_iNextAudible = m_iAudibleList;

	mov	eax, DWORD PTR _pCurrentSound$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2256]
	mov	DWORD PTR [eax+28], edx

; 231  : 			
; 232  : 			if ( pCurrentSound->FIsSound() )

	mov	ecx, DWORD PTR _pCurrentSound$[ebp]
	call	?FIsSound@CSound@@QAEHXZ		; CSound::FIsSound
	test	eax, eax
	je	SHORT $L39753

; 234  : 				// this is an audible sound.
; 235  : 				SetConditions( bits_COND_HEAR_SOUND );

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions

; 237  : 			else

	jmp	SHORT $L39756
$L39753:

; 239  : 				// if not a sound, must be a smell - determine if it's just a scent, or if it's a food scent
; 240  : //				if ( g_pSoundEnt->m_SoundPool[ iSound ].m_iType & ( bits_SOUND_MEAT | bits_SOUND_CARCASS ) )
; 241  : 				if ( pCurrentSound->m_iType & ( bits_SOUND_MEAT | bits_SOUND_CARCASS ) )

	mov	eax, DWORD PTR _pCurrentSound$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 24					; 00000018H
	test	ecx, ecx
	je	SHORT $L39755

; 243  : 					// the detected scent is a food item, so set both conditions.
; 244  : 					// !!!BUGBUG - maybe a virtual function to determine whether or not the scent is food?
; 245  : 					SetConditions( bits_COND_SMELL_FOOD );

	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions

; 246  : 					SetConditions( bits_COND_SMELL );

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions

; 248  : 				else

	jmp	SHORT $L39756
$L39755:

; 250  : 					// just a normal scent. 
; 251  : 					SetConditions( bits_COND_SMELL );

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
$L39756:

; 254  : 
; 255  : //			m_afSoundTypes |= g_pSoundEnt->m_SoundPool[ iSound ].m_iType;
; 256  : 			m_afSoundTypes |= pCurrentSound->m_iType;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pCurrentSound$[ebp]
	mov	ecx, DWORD PTR [edx+2260]
	or	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2260], ecx

; 257  : 
; 258  : 			m_iAudibleList = iSound;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iSound$[ebp]
	mov	DWORD PTR [eax+2256], ecx
$L39752:

; 260  : 
; 261  : //		iSound = g_pSoundEnt->m_SoundPool[ iSound ].m_iNext;
; 262  : 		iSound = pCurrentSound->m_iNext;

	mov	edx, DWORD PTR _pCurrentSound$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _iSound$[ebp], eax

; 263  : 	}

	jmp	$L39748
$L39749:

; 264  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Listen@CBaseMonster@@QAEXXZ ENDP			; CBaseMonster::Listen
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T41910 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41910[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
EXTRN	_sqrt:NEAR
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_iConditions$ = 8
_this$ = -4
?SetConditions@CBaseMonster@@QAEXH@Z PROC NEAR		; CBaseMonster::SetConditions, COMDAT

; 256  : 		inline void	SetConditions( int iConditions ) { m_afConditions |= iConditions; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1956]
	or	ecx, DWORD PTR _iConditions$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1956], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetConditions@CBaseMonster@@QAEXH@Z ENDP		; CBaseMonster::SetConditions
_TEXT	ENDS
;	COMDAT ?ClearConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_iConditions$ = 8
_this$ = -4
?ClearConditions@CBaseMonster@@QAEXH@Z PROC NEAR	; CBaseMonster::ClearConditions, COMDAT

; 257  : 		inline void	ClearConditions( int iConditions ) { m_afConditions &= ~iConditions; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _iConditions$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1956]
	and	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1956], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearConditions@CBaseMonster@@QAEXH@Z ENDP		; CBaseMonster::ClearConditions
_TEXT	ENDS
PUBLIC	?FLSoundVolume@CBaseMonster@@QAEMPAVCSound@@@Z	; CBaseMonster::FLSoundVolume
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
;	COMDAT ?FLSoundVolume@CBaseMonster@@QAEMPAVCSound@@@Z
_TEXT	SEGMENT
_pSound$ = 8
_this$ = -4
$T41923 = -16
?FLSoundVolume@CBaseMonster@@QAEMPAVCSound@@@Z PROC NEAR ; CBaseMonster::FLSoundVolume, COMDAT

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 	return ( pSound->m_iVolume - (( pSound->m_vecOrigin - GetAbsOrigin()).Length() ));

	mov	eax, DWORD PTR _pSound$[ebp]
	fild	DWORD PTR [eax+16]
	fstp	DWORD PTR -20+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T41923[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pSound$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fsubr	DWORD PTR -20+[ebp]

; 275  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FLSoundVolume@CBaseMonster@@QAEMPAVCSound@@@Z ENDP	; CBaseMonster::FLSoundVolume
_TEXT	ENDS
PUBLIC	?FValidateHintType@CBaseMonster@@UAEHF@Z	; CBaseMonster::FValidateHintType
;	COMDAT ?FValidateHintType@CBaseMonster@@UAEHF@Z
_TEXT	SEGMENT
_this$ = -4
?FValidateHintType@CBaseMonster@@UAEHF@Z PROC NEAR	; CBaseMonster::FValidateHintType, COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return FALSE;

	xor	eax, eax

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FValidateHintType@CBaseMonster@@UAEHF@Z ENDP		; CBaseMonster::FValidateHintType
_TEXT	ENDS
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??BEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator CBaseEntity *
PUBLIC	?Look@CBaseMonster@@UAEXH@Z			; CBaseMonster::Look
PUBLIC	??_C@_0BE@MMMF@?$CFs?5can?8t?5assess?5?$CFs?6?$AA@ ; `string'
PUBLIC	__real@4@00000000000000000000
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	?UTIL_EntitiesInBox@@YAHPAPAVCBaseEntity@@HABVVector@@1H@Z:NEAR ; UTIL_EntitiesInBox
;	COMDAT ??_C@_0BE@MMMF@?$CFs?5can?8t?5assess?5?$CFs?6?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BE@MMMF@?$CFs?5can?8t?5assess?5?$CFs?6?$AA@ DB '%s can''t assess %'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@4@00000000000000000000
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT ?Look@CBaseMonster@@UAEXH@Z
_TEXT	SEGMENT
_iDistance$ = 8
_this$ = -4
_iSighted$ = -8
_pSightEnt$ = -12
_pList$39773 = -412
_delta$39774 = -424
_count$39776 = -428
_i$39779 = -432
_pClient$39787 = -436
$T41928 = -448
$T41929 = -460
$T41930 = -472
?Look@CBaseMonster@@UAEXH@Z PROC NEAR			; CBaseMonster::Look, COMDAT

; 299  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 540				; 0000021cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 	int	iSighted = 0;

	mov	DWORD PTR _iSighted$[ebp], 0

; 301  : 
; 302  : 	// DON'T let visibility information from last frame sit around!
; 303  : 	ClearConditions(bits_COND_SEE_HATE | bits_COND_SEE_DISLIKE | bits_COND_SEE_ENEMY | bits_COND_SEE_FEAR | bits_COND_SEE_NEMESIS | bits_COND_SEE_CLIENT);

	push	6291486					; 0060001eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::ClearConditions

; 304  : 
; 305  : 	m_pLink = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 306  : 
; 307  : 	CBaseEntity	*pSightEnt = NULL;// the current visible entity that we're dealing with

	mov	DWORD PTR _pSightEnt$[ebp], 0

; 308  : 
; 309  : 	// See no evil if prisoner is set
; 310  : 	if ( !FBitSet( pev->spawnflags, SF_MONSTER_PRISONER ) )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 16					; 00000010H
	test	eax, eax
	jne	$L39782

; 312  : 		CBaseEntity *pList[100];
; 313  : 
; 314  : 		Vector delta = Vector( iDistance, iDistance, iDistance );

	fild	DWORD PTR _iDistance$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fild	DWORD PTR _iDistance$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fild	DWORD PTR _iDistance$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41928[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _delta$39774[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 315  : 
; 316  : 		// Find only monsters/clients in box, NOT limited to PVS
; 317  : 		int count = UTIL_EntitiesInBox( pList, 100, GetAbsOrigin() - delta, GetAbsOrigin() + delta, FL_CLIENT|FL_MONSTER );

	push	40					; 00000028H
	lea	ecx, DWORD PTR _delta$39774[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41929[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	eax, DWORD PTR _delta$39774[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41930[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	push	100					; 00000064H
	lea	edx, DWORD PTR _pList$39773[ebp]
	push	edx
	call	?UTIL_EntitiesInBox@@YAHPAPAVCBaseEntity@@HABVVector@@1H@Z ; UTIL_EntitiesInBox
	add	esp, 20					; 00000014H
	mov	DWORD PTR _count$39776[ebp], eax

; 318  : 		for ( int i = 0; i < count; i++ )

	mov	DWORD PTR _i$39779[ebp], 0
	jmp	SHORT $L39780
$L39781:
	mov	eax, DWORD PTR _i$39779[ebp]
	add	eax, 1
	mov	DWORD PTR _i$39779[ebp], eax
$L39780:
	mov	ecx, DWORD PTR _i$39779[ebp]
	cmp	ecx, DWORD PTR _count$39776[ebp]
	jge	$L39782

; 320  : 			pSightEnt = pList[i];

	mov	edx, DWORD PTR _i$39779[ebp]
	mov	eax, DWORD PTR _pList$39773[ebp+edx*4]
	mov	DWORD PTR _pSightEnt$[ebp], eax

; 323  : 				 !FBitSet( pSightEnt->pev->spawnflags, SF_MONSTER_PRISONER )	&& 
; 324  : 				 pSightEnt->pev->health > 0 )

	mov	ecx, DWORD PTR _pSightEnt$[ebp]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	$L39792
	mov	edx, DWORD PTR _pSightEnt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 16					; 00000010H
	test	ecx, ecx
	jne	$L39792
	mov	edx, DWORD PTR _pSightEnt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L39792

; 326  : 				// the looker will want to consider this entity
; 327  : 				// don't check anything else about an entity that can't be seen, or an entity that you don't care about.
; 328  : 				if ( IRelationship( pSightEnt ) != R_NO && FInViewCone( pSightEnt ) && !FBitSet( pSightEnt->pev->flags, FL_NOTARGET ) && FVisible( pSightEnt ) )

	mov	ecx, DWORD PTR _pSightEnt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+364]
	test	eax, eax
	je	$L39792
	mov	ecx, DWORD PTR _pSightEnt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+392]
	test	eax, eax
	je	$L39792
	mov	ecx, DWORD PTR _pSightEnt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	$L39792
	mov	ecx, DWORD PTR _pSightEnt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+332]
	test	eax, eax
	je	$L39792

; 330  : 					if ( pSightEnt->IsPlayer() )

	mov	ecx, DWORD PTR _pSightEnt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pSightEnt$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L39785

; 332  : 						if ( pev->spawnflags & SF_MONSTER_WAIT_TILL_SEEN )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1
	test	edx, edx
	je	SHORT $L39789

; 334  : 							CBaseMonster *pClient;
; 335  : 
; 336  : 							pClient = pSightEnt->MyMonsterPointer();

	mov	eax, DWORD PTR _pSightEnt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pSightEnt$[ebp]
	call	DWORD PTR [edx+124]
	mov	DWORD PTR _pClient$39787[ebp], eax

; 337  : 							// don't link this client in the list if the monster is wait till seen and the player isn't facing the monster
; 338  : 							if ( pSightEnt && !pClient->FInViewCone( this ) )

	cmp	DWORD PTR _pSightEnt$[ebp], 0
	je	SHORT $L39788
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pClient$39787[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pClient$39787[ebp]
	call	DWORD PTR [edx+392]
	test	eax, eax
	jne	SHORT $L39788

; 340  : 								// we're not in the player's view cone. 
; 341  : 								continue;

	jmp	$L39781
$L39788:

; 345  : 								// player sees us, become normal now.
; 346  : 								pev->spawnflags &= ~SF_MONSTER_WAIT_TILL_SEEN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+416], edx
$L39789:

; 349  : 
; 350  : 						// if we see a client, remember that (mostly for scripted AI)
; 351  : 						iSighted |= bits_COND_SEE_CLIENT;

	mov	edx, DWORD PTR _iSighted$[ebp]
	or	edx, 2097152				; 00200000H
	mov	DWORD PTR _iSighted$[ebp], edx
$L39785:

; 353  : 
; 354  : 					pSightEnt->m_pLink = m_pLink;

	mov	eax, DWORD PTR _pSightEnt$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 355  : 					m_pLink = pSightEnt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pSightEnt$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 356  : 
; 357  : 					if ( pSightEnt == m_hEnemy )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	cmp	DWORD PTR _pSightEnt$[ebp], eax
	jne	SHORT $L39790

; 359  : 						// we know this ent is visible, so if it also happens to be our enemy, store that now.
; 360  : 						iSighted |= bits_COND_SEE_ENEMY;

	mov	edx, DWORD PTR _iSighted$[ebp]
	or	edx, 16					; 00000010H
	mov	DWORD PTR _iSighted$[ebp], edx
$L39790:

; 366  : 					{

	mov	eax, DWORD PTR _pSightEnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+364]
	mov	DWORD PTR -476+[ebp], eax
	mov	eax, DWORD PTR -476+[ebp]
	add	eax, 2
	mov	DWORD PTR -476+[ebp], eax
	cmp	DWORD PTR -476+[ebp], 5
	ja	SHORT $L39800
	mov	ecx, DWORD PTR -476+[ebp]
	jmp	DWORD PTR $L41933[ecx*4]
$L39795:

; 367  : 					case	R_NM:
; 368  : 						iSighted |= bits_COND_SEE_NEMESIS;		

	mov	edx, DWORD PTR _iSighted$[ebp]
	or	edx, 4194304				; 00400000H
	mov	DWORD PTR _iSighted$[ebp], edx

; 369  : 						break;

	jmp	SHORT $L39792
$L39796:

; 370  : 					case	R_HT:		
; 371  : 						iSighted |= bits_COND_SEE_HATE;		

	mov	eax, DWORD PTR _iSighted$[ebp]
	or	al, 2
	mov	DWORD PTR _iSighted$[ebp], eax

; 372  : 						break;

	jmp	SHORT $L39792
$L39797:

; 373  : 					case	R_DL:
; 374  : 						iSighted |= bits_COND_SEE_DISLIKE;

	mov	ecx, DWORD PTR _iSighted$[ebp]
	or	ecx, 8
	mov	DWORD PTR _iSighted$[ebp], ecx

; 375  : 						break;

	jmp	SHORT $L39792
$L39798:

; 376  : 					case	R_FR:
; 377  : 						iSighted |= bits_COND_SEE_FEAR;

	mov	edx, DWORD PTR _iSighted$[ebp]
	or	edx, 4
	mov	DWORD PTR _iSighted$[ebp], edx

; 378  : 						break;

	jmp	SHORT $L39792
$L39799:

; 379  : 					case    R_AL:
; 380  : 						break;

	jmp	SHORT $L39792
$L39800:

; 381  : 					default:
; 382  : 						ALERT ( at_aiconsole, "%s can't assess %s\n", STRING(pev->classname), STRING(pSightEnt->pev->classname ) );

	mov	eax, DWORD PTR _pSightEnt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BE@MMMF@?$CFs?5can?8t?5assess?5?$CFs?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H
$L39792:

; 387  : 		}

	jmp	$L39781
$L39782:

; 389  : 	
; 390  : 	SetConditions( iSighted );

	mov	eax, DWORD PTR _iSighted$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions

; 391  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L41933:
	DD	$L39799
	DD	$L39798
	DD	$L39800
	DD	$L39797
	DD	$L39796
	DD	$L39795
?Look@CBaseMonster@@UAEXH@Z ENDP			; CBaseMonster::Look
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T41936 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41936[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator CBaseEntity *, COMDAT

; 64   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator CBaseEntity *
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
PUBLIC	?ISoundMask@CBaseMonster@@UAEHXZ		; CBaseMonster::ISoundMask
;	COMDAT ?ISoundMask@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ISoundMask@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::ISoundMask, COMDAT

; 399  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 400  : 	return	bits_SOUND_WORLD	|
; 401  : 			bits_SOUND_COMBAT	|
; 402  : 			bits_SOUND_PLAYER;

	mov	eax, 7

; 403  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ISoundMask@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::ISoundMask
_TEXT	ENDS
PUBLIC	?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ	; CBaseMonster::PBestSound
PUBLIC	??_C@_0CK@EGDB@ERROR?$CB?5monster?5?$CFs?5has?5no?5audible@ ; `string'
PUBLIC	??_C@_0BN@BGPP@NULL?5Return?5from?5PBestSound?6?$AA@ ; `string'
;	COMDAT ??_C@_0CK@EGDB@ERROR?$CB?5monster?5?$CFs?5has?5no?5audible@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0CK@EGDB@ERROR?$CB?5monster?5?$CFs?5has?5no?5audible@ DB 'ERROR! mo'
	DB	'nster %s has no audible sounds!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BGPP@NULL?5Return?5from?5PBestSound?6?$AA@
CONST	SEGMENT
??_C@_0BN@BGPP@NULL?5Return?5from?5PBestSound?6?$AA@ DB 'NULL Return from'
	DB	' PBestSound', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
_TEXT	SEGMENT
_this$ = -4
_iThisSound$ = -8
_iBestSound$ = -12
_flBestDist$ = -16
_flDist$ = -20
_pSound$ = -24
$T41945 = -36
$T41946 = -48
?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ PROC NEAR	; CBaseMonster::PBestSound, COMDAT

; 410  : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 411  : 	int iThisSound; 
; 412  : 	int	iBestSound = -1;

	mov	DWORD PTR _iBestSound$[ebp], -1

; 413  : 	float flBestDist = 8192;// so first nearby sound will become best so far.

	mov	DWORD PTR _flBestDist$[ebp], 1174405120	; 46000000H

; 414  : 	float flDist;
; 415  : 	CSound *pSound;
; 416  : 
; 417  : 	iThisSound = m_iAudibleList; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2256]
	mov	DWORD PTR _iThisSound$[ebp], ecx

; 418  : 
; 419  : 	if ( iThisSound == SOUNDLIST_EMPTY )

	cmp	DWORD PTR _iThisSound$[ebp], -1
	jne	SHORT $L39815

; 421  : 		ALERT ( at_aiconsole, "ERROR! monster %s has no audible sounds!\n", STRING(pev->classname) );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CK@EGDB@ERROR?$CB?5monster?5?$CFs?5has?5no?5audible@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 422  : #if _DEBUG
; 423  : 		ALERT( at_error, "NULL Return from PBestSound\n" );

	push	OFFSET FLAT:??_C@_0BN@BGPP@NULL?5Return?5from?5PBestSound?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 424  : #endif
; 425  : 		return NULL;

	xor	eax, eax
	jmp	$L39809
$L39815:

; 427  : 
; 428  : 	while ( iThisSound != SOUNDLIST_EMPTY )

	cmp	DWORD PTR _iThisSound$[ebp], -1
	je	SHORT $L39820

; 430  : 		pSound = CSoundEnt::SoundPointerForIndex( iThisSound );

	mov	edx, DWORD PTR _iThisSound$[ebp]
	push	edx
	call	?SoundPointerForIndex@CSoundEnt@@SAPAVCSound@@H@Z ; CSoundEnt::SoundPointerForIndex
	add	esp, 4
	mov	DWORD PTR _pSound$[ebp], eax

; 431  : 
; 432  : 		if ( pSound && pSound->FIsSound() )

	cmp	DWORD PTR _pSound$[ebp], 0
	je	SHORT $L39824
	mov	ecx, DWORD PTR _pSound$[ebp]
	call	?FIsSound@CSound@@QAEHXZ		; CSound::FIsSound
	test	eax, eax
	je	SHORT $L39824

; 434  : 			flDist = ( pSound->m_vecOrigin - EarPosition()).Length();

	lea	eax, DWORD PTR $T41945[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+312]
	push	eax
	lea	eax, DWORD PTR $T41946[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSound$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flDist$[ebp]

; 435  : 
; 436  : 			if ( flDist < flBestDist )

	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR _flBestDist$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39824

; 438  : 				iBestSound = iThisSound;

	mov	ecx, DWORD PTR _iThisSound$[ebp]
	mov	DWORD PTR _iBestSound$[ebp], ecx

; 439  : 				flBestDist = flDist;

	mov	edx, DWORD PTR _flDist$[ebp]
	mov	DWORD PTR _flBestDist$[ebp], edx
$L39824:

; 442  : 
; 443  : 		iThisSound = pSound->m_iNextAudible;

	mov	eax, DWORD PTR _pSound$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _iThisSound$[ebp], ecx

; 444  : 	}

	jmp	SHORT $L39815
$L39820:

; 445  : 	if ( iBestSound >= 0 )

	cmp	DWORD PTR _iBestSound$[ebp], 0
	jl	SHORT $L39825

; 447  : 		pSound = CSoundEnt::SoundPointerForIndex( iBestSound );

	mov	edx, DWORD PTR _iBestSound$[ebp]
	push	edx
	call	?SoundPointerForIndex@CSoundEnt@@SAPAVCSound@@H@Z ; CSoundEnt::SoundPointerForIndex
	add	esp, 4
	mov	DWORD PTR _pSound$[ebp], eax

; 448  : 		return pSound;

	mov	eax, DWORD PTR _pSound$[ebp]
	jmp	SHORT $L39809
$L39825:

; 450  : #if _DEBUG
; 451  : 	ALERT( at_error, "NULL Return from PBestSound\n" );

	push	OFFSET FLAT:??_C@_0BN@BGPP@NULL?5Return?5from?5PBestSound?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 452  : #endif
; 453  : 	return NULL;

	xor	eax, eax
$L39809:

; 454  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ ENDP		; CBaseMonster::PBestSound
_TEXT	ENDS
PUBLIC	?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ	; CBaseMonster::PBestScent
PUBLIC	??_C@_0CK@OICG@ERROR?$CB?5PBestScent?$CI?$CJ?5has?5empty?5so@ ; `string'
PUBLIC	??_C@_0BN@KIMI@NULL?5Return?5from?5PBestScent?6?$AA@ ; `string'
EXTRN	?FIsScent@CSound@@QAEHXZ:NEAR			; CSound::FIsScent
;	COMDAT ??_C@_0CK@OICG@ERROR?$CB?5PBestScent?$CI?$CJ?5has?5empty?5so@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0CK@OICG@ERROR?$CB?5PBestScent?$CI?$CJ?5has?5empty?5so@ DB 'ERROR! '
	DB	'PBestScent() has empty soundlist!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KIMI@NULL?5Return?5from?5PBestScent?6?$AA@
CONST	SEGMENT
??_C@_0BN@KIMI@NULL?5Return?5from?5PBestScent?6?$AA@ DB 'NULL Return from'
	DB	' PBestScent', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
_TEXT	SEGMENT
_this$ = -4
_iThisScent$ = -8
_iBestScent$ = -12
_flBestDist$ = -16
_flDist$ = -20
_pSound$ = -24
$T41949 = -36
?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ PROC NEAR	; CBaseMonster::PBestScent, COMDAT

; 461  : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 	int iThisScent; 
; 463  : 	int	iBestScent = -1;

	mov	DWORD PTR _iBestScent$[ebp], -1

; 464  : 	float flBestDist = 8192;// so first nearby smell will become best so far.

	mov	DWORD PTR _flBestDist$[ebp], 1174405120	; 46000000H

; 465  : 	float flDist;
; 466  : 	CSound *pSound;
; 467  : 
; 468  : 	iThisScent = m_iAudibleList;// smells are in the sound list.

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2256]
	mov	DWORD PTR _iThisScent$[ebp], ecx

; 469  : 
; 470  : 	if ( iThisScent == SOUNDLIST_EMPTY )

	cmp	DWORD PTR _iThisScent$[ebp], -1
	jne	SHORT $L39835

; 472  : 		ALERT ( at_aiconsole, "ERROR! PBestScent() has empty soundlist!\n" );

	push	OFFSET FLAT:??_C@_0CK@OICG@ERROR?$CB?5PBestScent?$CI?$CJ?5has?5empty?5so@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 473  : #if _DEBUG
; 474  : 		ALERT( at_error, "NULL Return from PBestSound\n" );

	push	OFFSET FLAT:??_C@_0BN@BGPP@NULL?5Return?5from?5PBestSound?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 475  : #endif
; 476  : 		return NULL;

	xor	eax, eax
	jmp	$L39829
$L39835:

; 478  : 
; 479  : 	while ( iThisScent != SOUNDLIST_EMPTY )

	cmp	DWORD PTR _iThisScent$[ebp], -1
	je	SHORT $L39839

; 481  : 		pSound = CSoundEnt::SoundPointerForIndex( iThisScent );

	mov	edx, DWORD PTR _iThisScent$[ebp]
	push	edx
	call	?SoundPointerForIndex@CSoundEnt@@SAPAVCSound@@H@Z ; CSoundEnt::SoundPointerForIndex
	add	esp, 4
	mov	DWORD PTR _pSound$[ebp], eax

; 482  : 
; 483  : 		if ( pSound->FIsScent() )

	mov	ecx, DWORD PTR _pSound$[ebp]
	call	?FIsScent@CSound@@QAEHXZ		; CSound::FIsScent
	test	eax, eax
	je	SHORT $L39842

; 485  : 			flDist = ( pSound->m_vecOrigin - GetAbsOrigin() ).Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T41949[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSound$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flDist$[ebp]

; 486  : 
; 487  : 			if ( flDist < flBestDist )

	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR _flBestDist$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39842

; 489  : 				iBestScent = iThisScent;

	mov	ecx, DWORD PTR _iThisScent$[ebp]
	mov	DWORD PTR _iBestScent$[ebp], ecx

; 490  : 				flBestDist = flDist;

	mov	edx, DWORD PTR _flDist$[ebp]
	mov	DWORD PTR _flBestDist$[ebp], edx
$L39842:

; 493  : 
; 494  : 		iThisScent = pSound->m_iNextAudible;

	mov	eax, DWORD PTR _pSound$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _iThisScent$[ebp], ecx

; 495  : 	}

	jmp	SHORT $L39835
$L39839:

; 496  : 	if ( iBestScent >= 0 )

	cmp	DWORD PTR _iBestScent$[ebp], 0
	jl	SHORT $L39843

; 498  : 		pSound = CSoundEnt::SoundPointerForIndex( iBestScent );

	mov	edx, DWORD PTR _iBestScent$[ebp]
	push	edx
	call	?SoundPointerForIndex@CSoundEnt@@SAPAVCSound@@H@Z ; CSoundEnt::SoundPointerForIndex
	add	esp, 4
	mov	DWORD PTR _pSound$[ebp], eax

; 499  : 
; 500  : 		return pSound;

	mov	eax, DWORD PTR _pSound$[ebp]
	jmp	SHORT $L39829
$L39843:

; 502  : #if _DEBUG
; 503  : 	ALERT( at_error, "NULL Return from PBestScent\n" );

	push	OFFSET FLAT:??_C@_0BN@KIMI@NULL?5Return?5from?5PBestScent?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 504  : #endif
; 505  : 	return NULL;

	xor	eax, eax
$L39829:

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ ENDP		; CBaseMonster::PBestScent
_TEXT	ENDS
PUBLIC	?MonsterThink@CBaseMonster@@UAEXXZ		; CBaseMonster::MonsterThink
PUBLIC	??_C@_0BE@LOML@Schedule?5stalled?$CB?$CB?6?$AA@	; `string'
PUBLIC	__real@8@3ffbccccccccccccd000
PUBLIC	?TaskIsRunning@CBaseMonster@@QAEHXZ		; CBaseMonster::TaskIsRunning
PUBLIC	?TaskIsComplete@CBaseMonster@@QAEHXZ		; CBaseMonster::TaskIsComplete
PUBLIC	?MovementIsComplete@CBaseMonster@@QAEHXZ	; CBaseMonster::MovementIsComplete
EXTRN	?StudioFrameAdvance@CBaseAnimating@@QAEMM@Z:NEAR ; CBaseAnimating::StudioFrameAdvance
EXTRN	?LookupActivity@CBaseAnimating@@QAEHH@Z:NEAR	; CBaseAnimating::LookupActivity
EXTRN	?LookupActivityHeaviest@CBaseAnimating@@QAEHH@Z:NEAR ; CBaseAnimating::LookupActivityHeaviest
EXTRN	?ResetSequenceInfo@CBaseAnimating@@QAEXXZ:NEAR	; CBaseAnimating::ResetSequenceInfo
EXTRN	?DispatchAnimEvents@CBaseAnimating@@QAEXM@Z:NEAR ; CBaseAnimating::DispatchAnimEvents
;	COMDAT ??_C@_0BE@LOML@Schedule?5stalled?$CB?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BE@LOML@Schedule?5stalled?$CB?$CB?6?$AA@ DB 'Schedule stalled!!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __real@8@3ffbccccccccccccd000
CONST	SEGMENT
__real@8@3ffbccccccccccccd000 DQ 03fb999999999999ar ; 0.1
CONST	ENDS
;	COMDAT ?MonsterThink@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_flInterval$ = -8
_iSequence$39851 = -12
?MonsterThink@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::MonsterThink, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 516  : 	pev->nextthink = gpGlobals->time + 0.1;// keep monster thinking.

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -16+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 517  : 
; 518  : 
; 519  : 	RunAI();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+348]

; 520  : 
; 521  : 	float flInterval = StudioFrameAdvance( ); // animate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioFrameAdvance@CBaseAnimating@@QAEMM@Z ; CBaseAnimating::StudioFrameAdvance
	fstp	DWORD PTR _flInterval$[ebp]

; 522  : // start or end a fidget
; 523  : // This needs a better home -- switching animations over time should be encapsulated on a per-activity basis
; 524  : // perhaps MaintainActivity() or a ShiftAnimationOverTime() or something.
; 525  : 	if ( m_MonsterState != MONSTERSTATE_SCRIPT && m_MonsterState != MONSTERSTATE_DEAD && m_Activity == ACT_IDLE && m_fSequenceFinished )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2080], 6
	je	SHORT $L39854
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2080], 8
	je	SHORT $L39854
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2068], 1
	jne	SHORT $L39854
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1804], 0
	je	SHORT $L39854

; 527  : 		int iSequence;
; 528  : 
; 529  : 		if ( m_fSequenceLoops )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1808], 0
	je	SHORT $L39852

; 531  : 			// animation does loop, which means we're playing subtle idle. Might need to 
; 532  : 			// fidget.
; 533  : 			iSequence = LookupActivity ( m_Activity );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2068]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	DWORD PTR _iSequence$39851[ebp], eax

; 535  : 		else

	jmp	SHORT $L39853
$L39852:

; 537  : 			// animation that just ended doesn't loop! That means we just finished a fidget
; 538  : 			// and should return to our heaviest weighted idle (the subtle one)
; 539  : 			iSequence = LookupActivityHeaviest ( m_Activity );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2068]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivityHeaviest@CBaseAnimating@@QAEHH@Z ; CBaseAnimating::LookupActivityHeaviest
	mov	DWORD PTR _iSequence$39851[ebp], eax
$L39853:

; 541  : 		if ( iSequence != ACTIVITY_NOT_AVAILABLE )

	cmp	DWORD PTR _iSequence$39851[ebp], -1
	je	SHORT $L39854

; 543  : 			pev->sequence = iSequence;	// Set to new anim (if it's there)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _iSequence$39851[ebp]
	mov	DWORD PTR [ecx+296], edx

; 544  : 			ResetSequenceInfo( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetSequenceInfo@CBaseAnimating@@QAEXXZ ; CBaseAnimating::ResetSequenceInfo
$L39854:

; 547  : 
; 548  : 	DispatchAnimEvents( flInterval );

	mov	eax, DWORD PTR _flInterval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DispatchAnimEvents@CBaseAnimating@@QAEXM@Z ; CBaseAnimating::DispatchAnimEvents

; 549  : 
; 550  : 	if ( !MovementIsComplete() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MovementIsComplete@CBaseMonster@@QAEHXZ ; CBaseMonster::MovementIsComplete
	test	eax, eax
	jne	SHORT $L39855

; 552  : 		Move( flInterval );

	mov	ecx, DWORD PTR _flInterval$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+400]

; 554  : #if _DEBUG	
; 555  : 	else 

	jmp	SHORT $L39857
$L39855:

; 557  : 		if ( !TaskIsRunning() && !TaskIsComplete() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskIsRunning@CBaseMonster@@QAEHXZ	; CBaseMonster::TaskIsRunning
	test	eax, eax
	jne	SHORT $L39857
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskIsComplete@CBaseMonster@@QAEHXZ	; CBaseMonster::TaskIsComplete
	test	eax, eax
	jne	SHORT $L39857

; 558  : 			ALERT( at_error, "Schedule stalled!!\n" );

	push	OFFSET FLAT:??_C@_0BE@LOML@Schedule?5stalled?$CB?$CB?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L39857:

; 560  : #endif
; 561  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MonsterThink@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::MonsterThink
_TEXT	ENDS
;	COMDAT ?TaskIsComplete@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?TaskIsComplete@CBaseMonster@@QAEHXZ PROC NEAR		; CBaseMonster::TaskIsComplete, COMDAT

; 231  : 		inline int TaskIsComplete( void ) { return (m_iTaskStatus == TASKSTATUS_COMPLETE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+2088], 4
	sete	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TaskIsComplete@CBaseMonster@@QAEHXZ ENDP		; CBaseMonster::TaskIsComplete
_TEXT	ENDS
;	COMDAT ?MovementIsComplete@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?MovementIsComplete@CBaseMonster@@QAEHXZ PROC NEAR	; CBaseMonster::MovementIsComplete, COMDAT

; 232  : 		inline int MovementIsComplete( void ) { return (m_movementGoal == MOVEGOAL_NONE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+2228], 0
	sete	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MovementIsComplete@CBaseMonster@@QAEHXZ ENDP		; CBaseMonster::MovementIsComplete
_TEXT	ENDS
;	COMDAT ?MonsterUse@CBaseMonster@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
?MonsterUse@CBaseMonster@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CBaseMonster::MonsterUse, COMDAT

; 568  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 569  : 	m_IdealMonsterState = MONSTERSTATE_ALERT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2084], 3

; 570  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?MonsterUse@CBaseMonster@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CBaseMonster::MonsterUse
_TEXT	ENDS
PUBLIC	?IgnoreConditions@CBaseMonster@@UAEHXZ		; CBaseMonster::IgnoreConditions
;	COMDAT ?IgnoreConditions@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
_iIgnoreConditions$ = -8
?IgnoreConditions@CBaseMonster@@UAEHXZ PROC NEAR	; CBaseMonster::IgnoreConditions, COMDAT

; 580  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 581  : 	int iIgnoreConditions = 0;

	mov	DWORD PTR _iIgnoreConditions$[ebp], 0

; 582  : 
; 583  : 	if ( !FShouldEat() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FShouldEat@CBaseMonster@@QAEHXZ	; CBaseMonster::FShouldEat
	test	eax, eax
	jne	SHORT $L39871

; 585  : 		// not hungry? Ignore food smell.
; 586  : 		iIgnoreConditions |= bits_COND_SMELL_FOOD;

	mov	eax, DWORD PTR _iIgnoreConditions$[ebp]
	or	al, 64					; 00000040H
	mov	DWORD PTR _iIgnoreConditions$[ebp], eax
$L39871:

; 588  : 
; 589  : 	if ( m_MonsterState == MONSTERSTATE_SCRIPT && m_pCine )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2080], 6
	jne	SHORT $L39872
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2384], 0
	je	SHORT $L39872

; 590  : 		iIgnoreConditions |= m_pCine->IgnoreConditions();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2384]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2384]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+528]
	mov	ecx, DWORD PTR _iIgnoreConditions$[ebp]
	or	ecx, eax
	mov	DWORD PTR _iIgnoreConditions$[ebp], ecx
$L39872:

; 591  : 
; 592  : 	return iIgnoreConditions;

	mov	eax, DWORD PTR _iIgnoreConditions$[ebp]

; 593  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IgnoreConditions@CBaseMonster@@UAEHXZ ENDP		; CBaseMonster::IgnoreConditions
_TEXT	ENDS
PUBLIC	?RouteNew@CBaseMonster@@QAEXXZ			; CBaseMonster::RouteNew
PUBLIC	?Forget@CBaseMonster@@QAEXH@Z			; CBaseMonster::Forget
;	COMDAT ?RouteClear@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RouteClear@CBaseMonster@@QAEXXZ PROC NEAR		; CBaseMonster::RouteClear, COMDAT

; 599  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 600  : 	RouteNew();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RouteNew@CBaseMonster@@QAEXXZ		; CBaseMonster::RouteNew

; 601  : 	m_movementGoal = MOVEGOAL_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2228], 0

; 602  : 	m_movementActivity = ACT_IDLE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2252], 1

; 603  : 	Forget( bits_MEMORY_MOVE_FAILED );

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Forget@CBaseMonster@@QAEXH@Z		; CBaseMonster::Forget

; 604  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RouteClear@CBaseMonster@@QAEXXZ ENDP			; CBaseMonster::RouteClear
_TEXT	ENDS
;	COMDAT ?Forget@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_iMemory$ = 8
_this$ = -4
?Forget@CBaseMonster@@QAEXH@Z PROC NEAR			; CBaseMonster::Forget, COMDAT

; 343  : 	inline void	Forget( int iMemory ) { m_afMemory &= ~iMemory; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _iMemory$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2280]
	and	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2280], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Forget@CBaseMonster@@QAEXH@Z ENDP			; CBaseMonster::Forget
_TEXT	ENDS
;	COMDAT ?RouteNew@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RouteNew@CBaseMonster@@QAEXXZ PROC NEAR		; CBaseMonster::RouteNew, COMDAT

; 611  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 	m_Route[ 0 ].iType		= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2112], 0

; 613  : 	m_iRouteIndex			= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2232], 0

; 614  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RouteNew@CBaseMonster@@QAEXXZ ENDP			; CBaseMonster::RouteNew
_TEXT	ENDS
PUBLIC	?FRouteClear@CBaseMonster@@QAEHXZ		; CBaseMonster::FRouteClear
;	COMDAT ?FRouteClear@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FRouteClear@CBaseMonster@@QAEHXZ PROC NEAR		; CBaseMonster::FRouteClear, COMDAT

; 621  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 	if ( m_Route[ m_iRouteIndex ].iType == 0 || m_movementGoal == MOVEGOAL_NONE )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2232]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+2112], 0
	je	SHORT $L39886
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2228], 0
	jne	SHORT $L39885
$L39886:

; 623  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L39884
$L39885:

; 624  : 
; 625  : 	return FALSE;

	xor	eax, eax
$L39884:

; 626  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FRouteClear@CBaseMonster@@QAEHXZ ENDP			; CBaseMonster::FRouteClear
_TEXT	ENDS
PUBLIC	?BuildRoute@CBaseMonster@@QAEHABVVector@@HPAVCBaseEntity@@@Z ; CBaseMonster::BuildRoute
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
PUBLIC	?FGetNodeRoute@CBaseMonster@@QAEHVVector@@@Z	; CBaseMonster::FGetNodeRoute
PUBLIC	?FRefreshRoute@CBaseMonster@@QAEHXZ		; CBaseMonster::FRefreshRoute
;	COMDAT ?FRefreshRoute@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_pPathCorner$ = -8
_i$ = -12
_returnCode$ = -16
?FRefreshRoute@CBaseMonster@@QAEHXZ PROC NEAR		; CBaseMonster::FRefreshRoute, COMDAT

; 634  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 	CBaseEntity	*pPathCorner;
; 636  : 	int			i;
; 637  : 	BOOL		returnCode;
; 638  : 
; 639  : 	RouteNew();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RouteNew@CBaseMonster@@QAEXXZ		; CBaseMonster::RouteNew

; 640  : 
; 641  : 	returnCode = FALSE;

	mov	DWORD PTR _returnCode$[ebp], 0

; 644  : 	{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2228]
	mov	DWORD PTR -24+[ebp], ecx
	mov	edx, DWORD PTR -24+[ebp]
	sub	edx, 1
	mov	DWORD PTR -24+[ebp], edx
	cmp	DWORD PTR -24+[ebp], 63			; 0000003fH
	ja	$L39895
	mov	ecx, DWORD PTR -24+[ebp]
	xor	eax, eax
	mov	al, BYTE PTR $L41973[ecx]
	jmp	DWORD PTR $L41974[eax*4]
$L39898:

; 647  : 				// monster is on a path_corner loop
; 648  : 				pPathCorner = m_pGoalEnt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _pPathCorner$[ebp], eax

; 649  : 				i = 0;

	mov	DWORD PTR _i$[ebp], 0
$L39900:

; 650  : 
; 651  : 				while ( pPathCorner && i < ROUTE_SIZE )

	cmp	DWORD PTR _pPathCorner$[ebp], 0
	je	$L39901
	cmp	DWORD PTR _i$[ebp], 8
	jge	$L39901

; 653  : 					m_Route[ i ].iType = bits_MF_TO_PATHCORNER;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+2112], 16		; 00000010H

; 654  : 					m_Route[ i ].vecLocation = pPathCorner->GetAbsOrigin();

	mov	ecx, DWORD PTR _pPathCorner$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+2100]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 655  : 
; 656  : 					pPathCorner = pPathCorner->GetNextTarget();

	mov	ecx, DWORD PTR _pPathCorner$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pPathCorner$[ebp]
	call	DWORD PTR [edx+268]
	mov	DWORD PTR _pPathCorner$[ebp], eax

; 657  : 
; 658  : 					// Last path_corner in list?
; 659  : 					if ( !pPathCorner )

	cmp	DWORD PTR _pPathCorner$[ebp], 0
	jne	SHORT $L39902

; 660  : 						m_Route[i].iType |= bits_MF_IS_GOAL;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+2112]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+2112], edx
$L39902:

; 661  : 					
; 662  : 					i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 663  : 				}

	jmp	$L39900
$L39901:

; 665  : 			returnCode = TRUE;

	mov	DWORD PTR _returnCode$[ebp], 1

; 666  : 			break;

	jmp	$L39895
$L39903:

; 667  : 
; 668  : 		case MOVEGOAL_ENEMY:
; 669  : 			returnCode = BuildRoute( m_vecEnemyLKP, bits_MF_TO_ENEMY, m_hEnemy );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2288				; 000008f0H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildRoute@CBaseMonster@@QAEHABVVector@@HPAVCBaseEntity@@@Z ; CBaseMonster::BuildRoute
	mov	DWORD PTR _returnCode$[ebp], eax

; 670  : 			break;

	jmp	$L39895
$L39904:

; 671  : 
; 672  : 		case MOVEGOAL_LOCATION:
; 673  : 			returnCode = BuildRoute( m_vecMoveGoal, bits_MF_TO_LOCATION, NULL );

	push	0
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2240				; 000008c0H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildRoute@CBaseMonster@@QAEHABVVector@@HPAVCBaseEntity@@@Z ; CBaseMonster::BuildRoute
	mov	DWORD PTR _returnCode$[ebp], eax

; 674  : 			break;

	jmp	SHORT $L39895
$L39905:

; 675  : 
; 676  : 		case MOVEGOAL_TARGETENT:
; 677  : 			if (m_hTargetEnt != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39906

; 679  : 				returnCode = BuildRoute( m_hTargetEnt->GetAbsOrigin(), bits_MF_TO_TARGETENT, m_hTargetEnt );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildRoute@CBaseMonster@@QAEHABVVector@@HPAVCBaseEntity@@@Z ; CBaseMonster::BuildRoute
	mov	DWORD PTR _returnCode$[ebp], eax
$L39906:

; 681  : 			break;

	jmp	SHORT $L39895
$L39907:

; 682  : 
; 683  : 		case MOVEGOAL_NODE:
; 684  : 			returnCode = FGetNodeRoute( m_vecMoveGoal );

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2240				; 000008c0H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FGetNodeRoute@CBaseMonster@@QAEHVVector@@@Z ; CBaseMonster::FGetNodeRoute
	mov	DWORD PTR _returnCode$[ebp], eax
$L39895:

; 689  : 
; 690  : 	return returnCode;

	mov	eax, DWORD PTR _returnCode$[ebp]

; 691  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L41974:
	DD	$L39905
	DD	$L39903
	DD	$L39898
	DD	$L39907
	DD	$L39904
	DD	$L39895
$L41973:
	DB	0
	DB	1
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
?FRefreshRoute@CBaseMonster@@QAEHXZ ENDP		; CBaseMonster::FRefreshRoute
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator->, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
PUBLIC	?MoveToEnemy@CBaseMonster@@QAEHW4Activity@@M@Z	; CBaseMonster::MoveToEnemy
;	COMDAT ?MoveToEnemy@CBaseMonster@@QAEHW4Activity@@M@Z
_TEXT	SEGMENT
_movementAct$ = 8
_waitTime$ = 12
_this$ = -4
?MoveToEnemy@CBaseMonster@@QAEHW4Activity@@M@Z PROC NEAR ; CBaseMonster::MoveToEnemy, COMDAT

; 695  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 696  : 	m_movementActivity = movementAct;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _movementAct$[ebp]
	mov	DWORD PTR [eax+2252], ecx

; 697  : 	m_moveWaitTime = waitTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _waitTime$[ebp]
	mov	DWORD PTR [edx+2236], eax

; 698  : 	
; 699  : 	m_movementGoal = MOVEGOAL_ENEMY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2228], 2

; 700  : 	return FRefreshRoute();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FRefreshRoute@CBaseMonster@@QAEHXZ	; CBaseMonster::FRefreshRoute

; 701  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?MoveToEnemy@CBaseMonster@@QAEHW4Activity@@M@Z ENDP	; CBaseMonster::MoveToEnemy
_TEXT	ENDS
PUBLIC	?MoveToLocation@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z ; CBaseMonster::MoveToLocation
;	COMDAT ?MoveToLocation@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z
_TEXT	SEGMENT
_movementAct$ = 8
_waitTime$ = 12
_goal$ = 16
_this$ = -4
?MoveToLocation@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z PROC NEAR ; CBaseMonster::MoveToLocation, COMDAT

; 705  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 706  : 	m_movementActivity = movementAct;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _movementAct$[ebp]
	mov	DWORD PTR [eax+2252], ecx

; 707  : 	m_moveWaitTime = waitTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _waitTime$[ebp]
	mov	DWORD PTR [edx+2236], eax

; 708  : 	
; 709  : 	m_movementGoal = MOVEGOAL_LOCATION;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2228], 64		; 00000040H

; 710  : 	m_vecMoveGoal = goal;

	mov	edx, DWORD PTR _goal$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2240				; 000008c0H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 711  : 	return FRefreshRoute();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FRefreshRoute@CBaseMonster@@QAEHXZ	; CBaseMonster::FRefreshRoute

; 712  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MoveToLocation@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z ENDP ; CBaseMonster::MoveToLocation
_TEXT	ENDS
PUBLIC	?MoveToTarget@CBaseMonster@@QAEHW4Activity@@M@Z	; CBaseMonster::MoveToTarget
;	COMDAT ?MoveToTarget@CBaseMonster@@QAEHW4Activity@@M@Z
_TEXT	SEGMENT
_movementAct$ = 8
_waitTime$ = 12
_this$ = -4
?MoveToTarget@CBaseMonster@@QAEHW4Activity@@M@Z PROC NEAR ; CBaseMonster::MoveToTarget, COMDAT

; 716  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 717  : 	m_movementActivity = movementAct;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _movementAct$[ebp]
	mov	DWORD PTR [eax+2252], ecx

; 718  : 	m_moveWaitTime = waitTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _waitTime$[ebp]
	mov	DWORD PTR [edx+2236], eax

; 719  : 	
; 720  : 	m_movementGoal = MOVEGOAL_TARGETENT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2228], 1

; 721  : 	return FRefreshRoute();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FRefreshRoute@CBaseMonster@@QAEHXZ	; CBaseMonster::FRefreshRoute

; 722  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?MoveToTarget@CBaseMonster@@QAEHW4Activity@@M@Z ENDP	; CBaseMonster::MoveToTarget
_TEXT	ENDS
PUBLIC	?MoveToNode@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z ; CBaseMonster::MoveToNode
;	COMDAT ?MoveToNode@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z
_TEXT	SEGMENT
_movementAct$ = 8
_waitTime$ = 12
_goal$ = 16
_this$ = -4
?MoveToNode@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z PROC NEAR ; CBaseMonster::MoveToNode, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	m_movementActivity = movementAct;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _movementAct$[ebp]
	mov	DWORD PTR [eax+2252], ecx

; 728  : 	m_moveWaitTime = waitTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _waitTime$[ebp]
	mov	DWORD PTR [edx+2236], eax

; 729  : 
; 730  : 	m_movementGoal = MOVEGOAL_NODE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2228], 32		; 00000020H

; 731  : 	m_vecMoveGoal = goal;

	mov	edx, DWORD PTR _goal$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2240				; 000008c0H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 732  : 	return FRefreshRoute();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FRefreshRoute@CBaseMonster@@QAEHXZ	; CBaseMonster::FRefreshRoute

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MoveToNode@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z ENDP ; CBaseMonster::MoveToNode
_TEXT	ENDS
PUBLIC	?DrawRoute@@YAXPAUentvars_s@@PAUWayPoint_t@@HHHH@Z ; DrawRoute
PUBLIC	??_C@_0BD@IOMN@Can?8t?5draw?5route?$CB?6?$AA@	; `string'
PUBLIC	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z		; MESSAGE_BEGIN
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z	; CBaseEntity::Instance
EXTRN	?g_sModelIndexLaser@@3FA:WORD			; g_sModelIndexLaser
;	COMDAT ??_C@_0BD@IOMN@Can?8t?5draw?5route?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BD@IOMN@Can?8t?5draw?5route?$CB?6?$AA@ DB 'Can''t draw route!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?DrawRoute@@YAXPAUentvars_s@@PAUWayPoint_t@@HHHH@Z
_TEXT	SEGMENT
_b$ = 28
_i$ = -4
_pEnt$ = -8
_vecOrigin$ = -20
_pev$ = 8
_m_Route$ = 12
_m_iRouteIndex$ = 16
_r$ = 20
_g$ = 24
?DrawRoute@@YAXPAUentvars_s@@PAUWayPoint_t@@HHHH@Z PROC NEAR ; DrawRoute, COMDAT

; 738  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 739  : 	int			i;
; 740  : 
; 741  : 	if ( m_Route[m_iRouteIndex].iType == 0 )

	mov	eax, DWORD PTR _m_iRouteIndex$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _m_Route$[ebp]
	cmp	DWORD PTR [ecx+eax+12], 0
	jne	SHORT $L39940

; 743  : 		ALERT( at_aiconsole, "Can't draw route!\n" );

	push	OFFSET FLAT:??_C@_0BD@IOMN@Can?8t?5draw?5route?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 744  : 		return;

	jmp	$L39938
$L39940:

; 746  : 
; 747  : //	UTIL_ParticleEffect ( m_Route[ m_iRouteIndex ].vecLocation, g_vecZero, 255, 25 );
; 748  : 	CBaseEntity *pEnt = CBaseEntity::Instance( pev );

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 749  : 	Vector vecOrigin = pEnt->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecOrigin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 750  : 
; 751  : 	MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );

	push	0
	push	0
	push	23					; 00000017H
	push	0
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 752  : 		WRITE_BYTE( TE_BEAMPOINTS);

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 753  : 		WRITE_COORD( vecOrigin.x );

	mov	eax, DWORD PTR _vecOrigin$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 754  : 		WRITE_COORD( vecOrigin.y );

	mov	ecx, DWORD PTR _vecOrigin$[ebp+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 755  : 		WRITE_COORD( vecOrigin.z );

	mov	edx, DWORD PTR _vecOrigin$[ebp+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 756  : 		WRITE_COORD( m_Route[ m_iRouteIndex ].vecLocation.x );

	mov	eax, DWORD PTR _m_iRouteIndex$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _m_Route$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 757  : 		WRITE_COORD( m_Route[ m_iRouteIndex ].vecLocation.y );

	mov	eax, DWORD PTR _m_iRouteIndex$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _m_Route$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 758  : 		WRITE_COORD( m_Route[ m_iRouteIndex ].vecLocation.z );

	mov	eax, DWORD PTR _m_iRouteIndex$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _m_Route$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 759  : 
; 760  : 		WRITE_SHORT( g_sModelIndexLaser );

	movsx	eax, WORD PTR ?g_sModelIndexLaser@@3FA	; g_sModelIndexLaser
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 761  : 		WRITE_BYTE( 0 ); // frame start

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 762  : 		WRITE_BYTE( 10 ); // framerate

	push	10					; 0000000aH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 763  : 		WRITE_BYTE( 1 ); // life

	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 764  : 		WRITE_BYTE( 16 );  // width

	push	16					; 00000010H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 765  : 		WRITE_BYTE( 0 );   // noise

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 766  : 		WRITE_BYTE( r );   // r, g, b

	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 767  : 		WRITE_BYTE( g );   // r, g, b

	mov	edx, DWORD PTR _g$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 768  : 		WRITE_BYTE( b );   // r, g, b

	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 769  : 		WRITE_BYTE( 255 );	// brightness

	push	255					; 000000ffH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 770  : 		WRITE_BYTE( 10 );		// speed

	push	10					; 0000000aH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 771  : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 772  : 
; 773  : 	for ( i = m_iRouteIndex ; i < ROUTE_SIZE - 1; i++ )

	mov	ecx, DWORD PTR _m_iRouteIndex$[ebp]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $L39944
$L39945:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L39944:
	cmp	DWORD PTR _i$[ebp], 7
	jge	$L39946

; 775  : 		if ( (m_Route[ i ].iType & bits_MF_IS_GOAL) || (m_Route[ i+1 ].iType == 0) )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _m_Route$[ebp]
	mov	edx, DWORD PTR [ecx+eax+12]
	and	edx, 128				; 00000080H
	test	edx, edx
	jne	SHORT $L39948
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _m_Route$[ebp]
	cmp	DWORD PTR [ecx+eax+12], 0
	jne	SHORT $L39947
$L39948:

; 776  : 			break;

	jmp	$L39946
$L39947:

; 777  : 
; 778  : 		
; 779  : 		MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );

	push	0
	push	0
	push	23					; 00000017H
	push	0
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 780  : 			WRITE_BYTE( TE_BEAMPOINTS );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 781  : 			WRITE_COORD( m_Route[ i ].vecLocation.x );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _m_Route$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 782  : 			WRITE_COORD( m_Route[ i ].vecLocation.y );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _m_Route$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 783  : 			WRITE_COORD( m_Route[ i ].vecLocation.z );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _m_Route$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 784  : 			WRITE_COORD( m_Route[ i + 1 ].vecLocation.x );

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _m_Route$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 785  : 			WRITE_COORD( m_Route[ i + 1 ].vecLocation.y );

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _m_Route$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 786  : 			WRITE_COORD( m_Route[ i + 1 ].vecLocation.z );

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _m_Route$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 787  : 			WRITE_SHORT( g_sModelIndexLaser );

	movsx	edx, WORD PTR ?g_sModelIndexLaser@@3FA	; g_sModelIndexLaser
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 788  : 			WRITE_BYTE( 0 ); // frame start

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 789  : 			WRITE_BYTE( 10 ); // framerate

	push	10					; 0000000aH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 790  : 			WRITE_BYTE( 1 ); // life

	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 791  : 			WRITE_BYTE( 8 );  // width

	push	8
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 792  : 			WRITE_BYTE( 0 );   // noise

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 793  : 			WRITE_BYTE( r );   // r, g, b

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 794  : 			WRITE_BYTE( g );   // r, g, b

	mov	ecx, DWORD PTR _g$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 795  : 			WRITE_BYTE( b );   // r, g, b

	mov	edx, DWORD PTR _b$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 796  : 			WRITE_BYTE( 255 );	// brightness

	push	255					; 000000ffH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 797  : 			WRITE_BYTE( 10 );		// speed

	push	10					; 0000000aH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 798  : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 799  : 
; 800  : //		UTIL_ParticleEffect ( m_Route[ i ].vecLocation, g_vecZero, 255, 25 );
; 801  : 	}

	jmp	$L39945
$L39946:
$L39938:

; 802  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawRoute@@YAXPAUentvars_s@@PAUWayPoint_t@@HHHH@Z ENDP	; DrawRoute
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_type$ = 12
_pOrigin$ = 16
_ed$ = 20
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z PROC NEAR	; MESSAGE_BEGIN, COMDAT

; 72   : inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin = NULL, edict_t *ed = NULL ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 73   : 	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ed);

	mov	eax, DWORD PTR _ed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+184
	add	esp, 16					; 00000010H

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z ENDP		; MESSAGE_BEGIN
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z PROC NEAR ; CBaseEntity::Instance, COMDAT

; 533  : 	static CBaseEntity *Instance( entvars_t *pev ) { return Instance( ENT( pev ) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
PUBLIC	?ShouldSimplify@@YAHH@Z				; ShouldSimplify
;	COMDAT ?ShouldSimplify@@YAHH@Z
_TEXT	SEGMENT
_routeType$ = 8
?ShouldSimplify@@YAHH@Z PROC NEAR			; ShouldSimplify, COMDAT

; 807  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 808  : 	routeType &= ~bits_MF_IS_GOAL;

	mov	eax, DWORD PTR _routeType$[ebp]
	and	al, 127					; 0000007fH
	mov	DWORD PTR _routeType$[ebp], eax

; 809  : 
; 810  : 	if ( (routeType == bits_MF_TO_PATHCORNER) || (routeType & bits_MF_DONT_SIMPLIFY) )

	cmp	DWORD PTR _routeType$[ebp], 16		; 00000010H
	je	SHORT $L39953
	mov	ecx, DWORD PTR _routeType$[ebp]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	je	SHORT $L39952
$L39953:

; 811  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L39951
$L39952:

; 812  : 	return TRUE;

	mov	eax, 1
$L39951:

; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ShouldSimplify@@YAHH@Z ENDP				; ShouldSimplify
_TEXT	ENDS
PUBLIC	??0WayPoint_t@@QAE@XZ				; WayPoint_t::WayPoint_t
PUBLIC	?__LINE__Var@?1??RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z@4FA ; `CBaseMonster::RouteSimplify'::`2'::__LINE__Var
PUBLIC	??_C@_0CK@LGAM@z?3?2xashxtsrc?2server?2monsters?2mon@ ; `string'
PUBLIC	??_C@_09DJLF@i?5?$DM?5count?$AA@		; `string'
PUBLIC	??_C@_0BK@KLD@outCount?5?$DM?5?$CIROUTE_SIZE?$CK2?$CJ?$AA@ ; `string'
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	?RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z ; CBaseMonster::RouteSimplify
EXTRN	?DBG_AssertFunction@@YAXHPBD0H0@Z:NEAR		; DBG_AssertFunction
;	COMDAT ?__LINE__Var@?1??RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z@4FA
; File z:\xashxtsrc\server\monsters\monsters.cpp
_DATA	SEGMENT
?__LINE__Var@?1??RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z@4FA DW 0337H ; `CBaseMonster::RouteSimplify'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CK@LGAM@z?3?2xashxtsrc?2server?2monsters?2mon@
CONST	SEGMENT
??_C@_0CK@LGAM@z?3?2xashxtsrc?2server?2monsters?2mon@ DB 'z:\xashxtsrc\se'
	DB	'rver\monsters\monsters.cpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DJLF@i?5?$DM?5count?$AA@
CONST	SEGMENT
??_C@_09DJLF@i?5?$DM?5count?$AA@ DB 'i < count', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KLD@outCount?5?$DM?5?$CIROUTE_SIZE?$CK2?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@KLD@outCount?5?$DM?5?$CIROUTE_SIZE?$CK2?$CJ?$AA@ DB 'outCount <'
	DB	' (ROUTE_SIZE*2)', 00H			; `string'
CONST	ENDS
;	COMDAT ?RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T42001 = -324
$T42002 = -336
_pTargetEnt$ = 8
$T42003 = -348
$T42004 = -360
_this$ = -4
_i$ = -8
_count$ = -12
_outCount$ = -16
_vecStart$ = -28
_outRoute$ = -284
_vecTest$39978 = -296
_vecSplit$39979 = -308
_iType$39984 = -312
?RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z PROC NEAR ; CBaseMonster::RouteSimplify, COMDAT

; 823  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 824  : 	// BUGBUG: this doesn't work 100% yet
; 825  : 	int			i, count, outCount;
; 826  : 	Vector		vecStart;

	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 827  : 	WayPoint_t	outRoute[ ROUTE_SIZE * 2 ];	// Any points except the ends can turn into 2 points in the simplified route

	push	OFFSET FLAT:??0WayPoint_t@@QAE@XZ	; WayPoint_t::WayPoint_t
	push	16					; 00000010H
	push	16					; 00000010H
	lea	eax, DWORD PTR _outRoute$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 828  : 
; 829  : 	count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 830  : 
; 831  : 	for ( i = m_iRouteIndex; i < ROUTE_SIZE; i++ )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2232]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $L39964
$L39965:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L39964:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $L39966

; 833  : 		if ( !m_Route[i].iType )

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+2112], 0
	jne	SHORT $L39967

; 834  : 			break;

	jmp	SHORT $L39966
$L39967:

; 836  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 837  : 		if ( m_Route[i].iType & bits_MF_IS_GOAL )

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+2112]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $L39969

; 838  : 			break;

	jmp	SHORT $L39966
$L39969:

; 839  : 	}

	jmp	SHORT $L39965
$L39966:

; 840  : 	// Can't simplify a direct route!
; 841  : 	if ( count < 2 )

	cmp	DWORD PTR _count$[ebp], 2
	jge	SHORT $L39970

; 843  : //		DrawRoute( pev, m_Route, m_iRouteIndex, 0, 0, 255 );
; 844  : 		return;

	jmp	$L39957
$L39970:

; 846  : 
; 847  : 	outCount = 0;

	mov	DWORD PTR _outCount$[ebp], 0

; 848  : 	vecStart = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecStart$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecStart$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecStart$[ebp+8], eax

; 849  : 	for ( i = 0; i < count-1; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39971
$L39972:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L39971:
	mov	edx, DWORD PTR _count$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _i$[ebp], edx
	jge	$L39973

; 851  : 		// Don't eliminate path_corners
; 852  : 		if ( !ShouldSimplify( m_Route[m_iRouteIndex+i].iType ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2232]
	add	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+2112]
	push	eax
	call	?ShouldSimplify@@YAHH@Z			; ShouldSimplify
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39974

; 854  : 			outRoute[outCount] = m_Route[ m_iRouteIndex + i ];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2232]
	add	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2100]
	mov	edx, DWORD PTR _outCount$[ebp]
	shl	edx, 4
	lea	eax, DWORD PTR _outRoute$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx

; 855  : 			outCount++;

	mov	edx, DWORD PTR _outCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _outCount$[ebp], edx

; 857  : 		else if ( CheckLocalMove ( vecStart, m_Route[m_iRouteIndex+i+1].vecLocation, pTargetEnt, NULL ) == LOCALMOVE_VALID )

	jmp	$L39988
$L39974:
	push	0
	mov	eax, DWORD PTR _pTargetEnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2232]
	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [edx+eax+1]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+2100]
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+396]
	cmp	eax, 2
	jne	SHORT $L39976

; 859  : 			// Skip vert
; 860  : 			continue;

	jmp	$L39972
$L39976:

; 864  : 			Vector vecTest, vecSplit;

	lea	ecx, DWORD PTR _vecTest$39978[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _vecSplit$39979[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 865  : 
; 866  : 			// Halfway between this and next
; 867  : 			vecTest = (m_Route[m_iRouteIndex+i+1].vecLocation + m_Route[m_iRouteIndex+i].vecLocation) * 0.5;

	push	1056964608				; 3f000000H
	lea	ecx, DWORD PTR $T42002[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2232]
	add	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2100]
	push	edx
	lea	eax, DWORD PTR $T42001[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2232]
	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [edx+eax+1]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+2100]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecTest$39978[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecTest$39978[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecTest$39978[ebp+8], eax

; 868  : 
; 869  : 			// Halfway between this and previous
; 870  : 			vecSplit = (m_Route[m_iRouteIndex+i].vecLocation + vecStart) * 0.5;

	push	1056964608				; 3f000000H
	lea	ecx, DWORD PTR $T42004[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecStart$[ebp]
	push	edx
	lea	eax, DWORD PTR $T42003[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2232]
	add	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2100]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecSplit$39979[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecSplit$39979[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecSplit$39979[ebp+8], eax

; 871  : 
; 872  : 			int iType = (m_Route[m_iRouteIndex+i].iType | bits_MF_TO_DETOUR) & ~bits_MF_NOT_TO_MASK;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2232]
	add	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+2112]
	or	ecx, 8
	and	ecx, -385				; fffffe7fH
	mov	DWORD PTR _iType$39984[ebp], ecx

; 873  : 			if ( CheckLocalMove ( vecStart, vecTest, pTargetEnt, NULL ) == LOCALMOVE_VALID )

	push	0
	mov	edx, DWORD PTR _pTargetEnt$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecTest$39978[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+396]
	cmp	eax, 2
	jne	SHORT $L39985

; 875  : 				outRoute[outCount].iType = iType;

	mov	ecx, DWORD PTR _outCount$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _iType$39984[ebp]
	mov	DWORD PTR _outRoute$[ebp+ecx+12], edx

; 876  : 				outRoute[outCount].vecLocation = vecTest;

	mov	eax, DWORD PTR _outCount$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _outRoute$[ebp+eax]
	mov	edx, DWORD PTR _vecTest$39978[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _vecTest$39978[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _vecTest$39978[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 878  : 			else if ( CheckLocalMove ( vecSplit, vecTest, pTargetEnt, NULL ) == LOCALMOVE_VALID )

	jmp	$L39988
$L39985:
	push	0
	mov	eax, DWORD PTR _pTargetEnt$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecTest$39978[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecSplit$39979[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+396]
	cmp	eax, 2
	jne	$L39987

; 880  : 				outRoute[outCount].iType = iType;

	mov	eax, DWORD PTR _outCount$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _iType$39984[ebp]
	mov	DWORD PTR _outRoute$[ebp+eax+12], ecx

; 881  : 				outRoute[outCount].vecLocation = vecSplit;

	mov	edx, DWORD PTR _outCount$[ebp]
	shl	edx, 4
	lea	eax, DWORD PTR _outRoute$[ebp+edx]
	mov	ecx, DWORD PTR _vecSplit$39979[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecSplit$39979[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecSplit$39979[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 882  : 				outRoute[outCount+1].iType = iType;

	mov	edx, DWORD PTR _outCount$[ebp]
	add	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _iType$39984[ebp]
	mov	DWORD PTR _outRoute$[ebp+edx+12], eax

; 883  : 				outRoute[outCount+1].vecLocation = vecTest;

	mov	ecx, DWORD PTR _outCount$[ebp]
	add	ecx, 1
	shl	ecx, 4
	lea	edx, DWORD PTR _outRoute$[ebp+ecx]
	mov	eax, DWORD PTR _vecTest$39978[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _vecTest$39978[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _vecTest$39978[ebp+8]
	mov	DWORD PTR [edx+8], eax

; 884  : 				outCount++; // Adding an extra point

	mov	ecx, DWORD PTR _outCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outCount$[ebp], ecx

; 886  : 			else

	jmp	SHORT $L39988
$L39987:

; 888  : 				outRoute[outCount] = m_Route[ m_iRouteIndex + i ];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2232]
	add	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2100]
	mov	eax, DWORD PTR _outCount$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _outRoute$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx
$L39988:

; 891  : 		// Get last point
; 892  : 		vecStart = outRoute[ outCount ].vecLocation;

	mov	eax, DWORD PTR _outCount$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _outRoute$[ebp+eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _vecStart$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _vecStart$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _vecStart$[ebp+8], ecx

; 893  : 		outCount++;

	mov	edx, DWORD PTR _outCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _outCount$[ebp], edx

; 894  : 	}

	jmp	$L39972
$L39973:

; 895  : 	ASSERT( i < count );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z@4FA ; `CBaseMonster::RouteSimplify'::`2'::__LINE__Var
	add	eax, 72					; 00000048H
	push	eax
	push	OFFSET FLAT:??_C@_0CK@LGAM@z?3?2xashxtsrc?2server?2monsters?2mon@ ; `string'
	push	OFFSET FLAT:??_C@_09DJLF@i?5?$DM?5count?$AA@ ; `string'
	mov	ecx, DWORD PTR _i$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR _count$[ebp]
	setl	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 896  : 	outRoute[outCount] = m_Route[ m_iRouteIndex + i ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2232]
	add	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+2100]
	mov	ecx, DWORD PTR _outCount$[ebp]
	shl	ecx, 4
	lea	edx, DWORD PTR _outRoute$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 897  : 	outCount++;

	mov	ecx, DWORD PTR _outCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outCount$[ebp], ecx

; 898  : 	
; 899  : 	// Terminate
; 900  : 	outRoute[outCount].iType = 0;

	mov	edx, DWORD PTR _outCount$[ebp]
	shl	edx, 4
	mov	DWORD PTR _outRoute$[ebp+edx+12], 0

; 901  : 	ASSERT( outCount < (ROUTE_SIZE*2) );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z@4FA ; `CBaseMonster::RouteSimplify'::`2'::__LINE__Var
	add	eax, 78					; 0000004eH
	push	eax
	push	OFFSET FLAT:??_C@_0CK@LGAM@z?3?2xashxtsrc?2server?2monsters?2mon@ ; `string'
	push	OFFSET FLAT:??_C@_0BK@KLD@outCount?5?$DM?5?$CIROUTE_SIZE?$CK2?$CJ?$AA@ ; `string'
	xor	ecx, ecx
	cmp	DWORD PTR _outCount$[ebp], 16		; 00000010H
	setl	cl
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 902  : 
; 903  : // Copy the simplified route, disable for testing
; 904  : 	m_iRouteIndex = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2232], 0

; 905  : 	for ( i = 0; i < ROUTE_SIZE && i < outCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39993
$L39994:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L39993:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $L39995
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _outCount$[ebp]
	jge	SHORT $L39995

; 907  : 		m_Route[i] = outRoute[i];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	lea	eax, DWORD PTR _outRoute$[ebp+edx]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+2100]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 908  : 	}

	jmp	SHORT $L39994
$L39995:

; 909  : 
; 910  : 	// Terminate route
; 911  : 	if ( i < ROUTE_SIZE )

	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $L39996

; 912  : 		m_Route[i].iType = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+2112], 0
$L39996:
$L39957:

; 913  : 
; 914  : // Debug, test movement code
; 915  : #if 0
; 916  : //	if ( CVAR_GET_FLOAT( "simplify" ) != 0 )
; 917  : 		DrawRoute( pev, outRoute, 0, 255, 0, 0 );
; 918  : //	else
; 919  : 		DrawRoute( pev, m_Route, m_iRouteIndex, 0, 255, 0 );
; 920  : #endif
; 921  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z ENDP ; CBaseMonster::RouteSimplify
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
$T42009 = -16
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T42009[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
;	COMDAT ??0WayPoint_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0WayPoint_t@@QAE@XZ PROC NEAR				; WayPoint_t::WayPoint_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0WayPoint_t@@QAE@XZ ENDP				; WayPoint_t::WayPoint_t
_TEXT	ENDS
PUBLIC	?FBecomeProne@CBaseMonster@@UAEHXZ		; CBaseMonster::FBecomeProne
;	COMDAT ?FBecomeProne@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FBecomeProne@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::FBecomeProne, COMDAT

; 929  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 930  : 	if ( FBitSet ( pev->flags, FL_ONGROUND ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	SHORT $L40003

; 932  : 		pev->flags -= FL_ONGROUND;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	sub	edx, 512				; 00000200H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx
$L40003:

; 934  : 
; 935  : 	m_IdealMonsterState = MONSTERSTATE_PRONE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2084], 5

; 936  : 	return TRUE;

	mov	eax, 1

; 937  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FBecomeProne@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::FBecomeProne
_TEXT	ENDS
PUBLIC	__real@4@40058000000000000000
PUBLIC	__real@4@4008c400000000000000
PUBLIC	__real@8@3ffe8000000000000000
PUBLIC	?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z	; CBaseMonster::CheckRangeAttack1
;	COMDAT __real@4@40058000000000000000
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
__real@4@40058000000000000000 DD 042800000r	; 64
CONST	ENDS
;	COMDAT __real@4@4008c400000000000000
CONST	SEGMENT
__real@4@4008c400000000000000 DD 044440000r	; 784
CONST	ENDS
;	COMDAT __real@8@3ffe8000000000000000
CONST	SEGMENT
__real@8@3ffe8000000000000000 DQ 03fe0000000000000r ; 0.5
CONST	ENDS
;	COMDAT ?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
_TEXT	SEGMENT
_flDot$ = 8
_flDist$ = 12
_this$ = -4
?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z PROC NEAR	; CBaseMonster::CheckRangeAttack1, COMDAT

; 943  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 944  : 	if ( flDist > 64 && flDist <= 784 && flDot >= 0.5 )

	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR __real@4@40058000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40009
	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR __real@4@4008c400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40009
	fld	DWORD PTR _flDot$[ebp]
	fcomp	QWORD PTR __real@8@3ffe8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40009

; 946  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L40008
$L40009:

; 948  : 	return FALSE;

	xor	eax, eax
$L40008:

; 949  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z ENDP		; CBaseMonster::CheckRangeAttack1
_TEXT	ENDS
PUBLIC	__real@4@40088000000000000000
PUBLIC	?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z	; CBaseMonster::CheckRangeAttack2
;	COMDAT __real@4@40088000000000000000
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
__real@4@40088000000000000000 DD 044000000r	; 512
CONST	ENDS
;	COMDAT ?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
_TEXT	SEGMENT
_flDot$ = 8
_flDist$ = 12
_this$ = -4
?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z PROC NEAR	; CBaseMonster::CheckRangeAttack2, COMDAT

; 955  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 956  : 	if ( flDist > 64 && flDist <= 512 && flDot >= 0.5 )

	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR __real@4@40058000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40015
	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR __real@4@40088000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40015
	fld	DWORD PTR _flDot$[ebp]
	fcomp	QWORD PTR __real@8@3ffe8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40015

; 958  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L40014
$L40015:

; 960  : 	return FALSE;

	xor	eax, eax
$L40014:

; 961  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z ENDP		; CBaseMonster::CheckRangeAttack2
_TEXT	ENDS
PUBLIC	__real@8@3ffeb333333333333000
PUBLIC	?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z	; CBaseMonster::CheckMeleeAttack1
;	COMDAT __real@8@3ffeb333333333333000
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
__real@8@3ffeb333333333333000 DQ 03fe6666666666666r ; 0.7
CONST	ENDS
;	COMDAT ?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
_TEXT	SEGMENT
_flDot$ = 8
_flDist$ = 12
_this$ = -4
?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z PROC NEAR	; CBaseMonster::CheckMeleeAttack1, COMDAT

; 967  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 968  : 	// Decent fix to keep folks from kicking/punching hornets and snarks is to check the onground flag(sjb)
; 969  : 	if ( flDist <= 64 && flDot >= 0.7 && m_hEnemy != NULL && FBitSet ( m_hEnemy->pev->flags, FL_ONGROUND ) )

	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR __real@4@40058000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40021
	fld	DWORD PTR _flDot$[ebp]
	fcomp	QWORD PTR __real@8@3ffeb333333333333000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40021
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40021
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 512				; 00000200H
	test	ecx, ecx
	je	SHORT $L40021

; 971  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L40020
$L40021:

; 973  : 	return FALSE;

	xor	eax, eax
$L40020:

; 974  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z ENDP		; CBaseMonster::CheckMeleeAttack1
_TEXT	ENDS
PUBLIC	?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z	; CBaseMonster::CheckMeleeAttack2
;	COMDAT ?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
_TEXT	SEGMENT
_flDot$ = 8
_flDist$ = 12
_this$ = -4
?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z PROC NEAR	; CBaseMonster::CheckMeleeAttack2, COMDAT

; 980  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 981  : 	if ( flDist <= 64 && flDot >= 0.7 )

	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR __real@4@40058000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40027
	fld	DWORD PTR _flDot$[ebp]
	fcomp	QWORD PTR __real@8@3ffeb333333333333000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40027

; 983  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L40026
$L40027:

; 985  : 	return FALSE;

	xor	eax, eax
$L40026:

; 986  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z ENDP		; CBaseMonster::CheckMeleeAttack2
_TEXT	ENDS
PUBLIC	?Normalize@Vector2D@@QBE?AV1@XZ			; Vector2D::Normalize
PUBLIC	?DotProduct@@YAMABVVector2D@@0@Z		; DotProduct
PUBLIC	?Make2D@Vector@@QBE?AVVector2D@@XZ		; Vector::Make2D
PUBLIC	?CheckAttacks@CBaseMonster@@QAEXPAVCBaseEntity@@M@Z ; CBaseMonster::CheckAttacks
PUBLIC	??0Vector2D@@QAE@XZ				; Vector2D::Vector2D
EXTRN	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsAngles
EXTRN	?UTIL_MakeVectors@@YAXABVVector@@@Z:NEAR	; UTIL_MakeVectors
;	COMDAT ?CheckAttacks@CBaseMonster@@QAEXPAVCBaseEntity@@M@Z
_TEXT	SEGMENT
$T42034 = -28
$T42035 = -36
$T42036 = -44
$T42037 = -52
_pTarget$ = 8
_flDist$ = 12
_this$ = -4
_vec2LOS$ = -12
_flDot$ = -16
?CheckAttacks@CBaseMonster@@QAEXPAVCBaseEntity@@M@Z PROC NEAR ; CBaseMonster::CheckAttacks, COMDAT

; 993  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 994  : 	Vector2D	vec2LOS;

	lea	ecx, DWORD PTR _vec2LOS$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 995  : 	float		flDot;
; 996  : 
; 997  : 	UTIL_MakeVectors ( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 998  : 
; 999  : 	vec2LOS = ( pTarget->GetAbsOrigin() - GetAbsOrigin() ).Make2D();

	lea	eax, DWORD PTR $T42035[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T42034[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Make2D@Vector@@QBE?AVVector2D@@XZ	; Vector::Make2D
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _vec2LOS$[ebp], edx
	mov	DWORD PTR _vec2LOS$[ebp+4], eax

; 1000 : 	vec2LOS = vec2LOS.Normalize();

	lea	ecx, DWORD PTR $T42036[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vec2LOS$[ebp]
	call	?Normalize@Vector2D@@QBE?AV1@XZ		; Vector2D::Normalize
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _vec2LOS$[ebp], edx
	mov	DWORD PTR _vec2LOS$[ebp+4], eax

; 1001 : 
; 1002 : 	flDot = DotProduct (vec2LOS , gpGlobals->v_forward.Make2D() );

	lea	ecx, DWORD PTR $T42037[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	?Make2D@Vector@@QBE?AVVector2D@@XZ	; Vector::Make2D
	push	eax
	lea	edx, DWORD PTR _vec2LOS$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector2D@@0@Z	; DotProduct
	add	esp, 8
	fstp	DWORD PTR _flDot$[ebp]

; 1003 : 
; 1004 : 	// we know the enemy is in front now. We'll find which attacks the monster is capable of by
; 1005 : 	// checking for corresponding Activities in the model file, then do the simple checks to validate
; 1006 : 	// those attack types.
; 1007 : 	
; 1008 : 	// Clear all attack conditions
; 1009 : 	ClearConditions( bits_COND_CAN_RANGE_ATTACK1 | bits_COND_CAN_RANGE_ATTACK2 | bits_COND_CAN_MELEE_ATTACK1 |bits_COND_CAN_MELEE_ATTACK2 );

	push	15360					; 00003c00H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::ClearConditions

; 1010 : 
; 1011 : 	if ( m_afCapability & bits_CAP_RANGE_ATTACK1 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2304]
	and	ecx, 2048				; 00000800H
	test	ecx, ecx
	je	SHORT $L40040

; 1013 : 		if ( CheckRangeAttack1 ( flDot, flDist ) )

	mov	edx, DWORD PTR _flDist$[ebp]
	push	edx
	mov	eax, DWORD PTR _flDot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+420]
	test	eax, eax
	je	SHORT $L40040

; 1014 : 			SetConditions( bits_COND_CAN_RANGE_ATTACK1 );

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
$L40040:

; 1016 : 	if ( m_afCapability & bits_CAP_RANGE_ATTACK2 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2304]
	and	ecx, 4096				; 00001000H
	test	ecx, ecx
	je	SHORT $L40042

; 1018 : 		if ( CheckRangeAttack2 ( flDot, flDist ) )

	mov	edx, DWORD PTR _flDist$[ebp]
	push	edx
	mov	eax, DWORD PTR _flDot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+424]
	test	eax, eax
	je	SHORT $L40042

; 1019 : 			SetConditions( bits_COND_CAN_RANGE_ATTACK2 );

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
$L40042:

; 1021 : 	if ( m_afCapability & bits_CAP_MELEE_ATTACK1 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2304]
	and	ecx, 8192				; 00002000H
	test	ecx, ecx
	je	SHORT $L40044

; 1023 : 		if ( CheckMeleeAttack1 ( flDot, flDist ) )

	mov	edx, DWORD PTR _flDist$[ebp]
	push	edx
	mov	eax, DWORD PTR _flDot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+428]
	test	eax, eax
	je	SHORT $L40044

; 1024 : 			SetConditions( bits_COND_CAN_MELEE_ATTACK1 );

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
$L40044:

; 1026 : 	if ( m_afCapability & bits_CAP_MELEE_ATTACK2 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2304]
	and	ecx, 16384				; 00004000H
	test	ecx, ecx
	je	SHORT $L40046

; 1028 : 		if ( CheckMeleeAttack2 ( flDot, flDist ) )

	mov	edx, DWORD PTR _flDist$[ebp]
	push	edx
	mov	eax, DWORD PTR _flDot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+432]
	test	eax, eax
	je	SHORT $L40046

; 1029 : 			SetConditions( bits_COND_CAN_MELEE_ATTACK2 );

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
$L40046:

; 1031 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CheckAttacks@CBaseMonster@@QAEXPAVCBaseEntity@@M@Z ENDP ; CBaseMonster::CheckAttacks
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector2D@@QAE@XZ PROC NEAR				; Vector2D::Vector2D, COMDAT

; 57   : 	inline Vector2D(void) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector2D@@QAE@XZ ENDP				; Vector2D::Vector2D
_TEXT	ENDS
PUBLIC	?Length@Vector2D@@QBEMXZ			; Vector2D::Length
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	??0Vector2D@@QAE@MM@Z				; Vector2D::Vector2D
;	COMDAT __real@4@3fff8000000000000000
; File z:\xashxtsrc\game_shared\vector.h
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT ?Normalize@Vector2D@@QBE?AV1@XZ
_TEXT	SEGMENT
$T42042 = -24
$T42043 = -32
___$ReturnUdt$ = 8
_this$ = -4
_vec2$ = -12
_flLen$ = -16
?Normalize@Vector2D@@QBE?AV1@XZ PROC NEAR		; Vector2D::Normalize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		Vector2D vec2;

	lea	ecx, DWORD PTR _vec2$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 105  : 
; 106  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector2D@@QBEMXZ		; Vector2D::Length
	fstp	DWORD PTR _flLen$[ebp]

; 107  : 		if ( flLen == 0 )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L24660

; 109  : 			return Vector2D( 0, 0 );

	push	0
	push	0
	lea	ecx, DWORD PTR $T42042[ebp]
	call	??0Vector2D@@QAE@MM@Z			; Vector2D::Vector2D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L24662
$L24660:

; 113  : 			flLen = 1 / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 114  : 			return Vector2D( x * flLen, y * flLen );

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T42043[ebp]
	call	??0Vector2D@@QAE@MM@Z			; Vector2D::Vector2D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L24662:

; 116  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector2D@@QBE?AV1@XZ ENDP			; Vector2D::Normalize
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT
_this$ = -4
_X$ = 8
_Y$ = 12
??0Vector2D@@QAE@MM@Z PROC NEAR				; Vector2D::Vector2D, COMDAT

; 58   : 	inline Vector2D(float X, float Y) { x = X; y = Y; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0Vector2D@@QAE@MM@Z ENDP				; Vector2D::Vector2D
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector2D@@QBEMXZ PROC NEAR			; Vector2D::Length, COMDAT

; 101  : 	inline float Length(void) const { return sqrt(x*x + y*y ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector2D@@QBEMXZ ENDP				; Vector2D::Length
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector2D@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProduct@@YAMABVVector2D@@0@Z PROC NEAR		; DotProduct, COMDAT

; 122  : inline float DotProduct(const Vector2D& a, const Vector2D& b) { return( a.x*b.x + a.y*b.y ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector2D@@0@Z ENDP			; DotProduct
_TEXT	ENDS
;	COMDAT ?Make2D@Vector@@QBE?AVVector2D@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_Vec2$ = -12
?Make2D@Vector@@QBE?AVVector2D@@XZ PROC NEAR		; Vector::Make2D, COMDAT

; 275  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 276  : 		Vector2D	Vec2;

	lea	ecx, DWORD PTR _Vec2$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 277  : 		Vec2.x = x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _Vec2$[ebp], ecx

; 278  : 		Vec2.y = y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _Vec2$[ebp+4], eax

; 279  : 		return Vec2;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _Vec2$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _Vec2$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 280  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Make2D@Vector@@QBE?AVVector2D@@XZ ENDP			; Vector::Make2D
_TEXT	ENDS
PUBLIC	?FCanCheckAttacks@CBaseMonster@@UAEHXZ		; CBaseMonster::FCanCheckAttacks
PUBLIC	?HasConditions@CBaseMonster@@QAEHH@Z		; CBaseMonster::HasConditions
;	COMDAT ?FCanCheckAttacks@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FCanCheckAttacks@CBaseMonster@@UAEHXZ PROC NEAR	; CBaseMonster::FCanCheckAttacks, COMDAT

; 1038 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1039 : 	if ( HasConditions(bits_COND_SEE_ENEMY) && !HasConditions( bits_COND_ENEMY_TOOFAR ) )

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L40051
	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	jne	SHORT $L40051

; 1041 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L40050
$L40051:

; 1043 : 
; 1044 : 	return FALSE;

	xor	eax, eax
$L40050:

; 1045 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FCanCheckAttacks@CBaseMonster@@UAEHXZ ENDP		; CBaseMonster::FCanCheckAttacks
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT
_iConditions$ = 8
_this$ = -4
?HasConditions@CBaseMonster@@QAEHH@Z PROC NEAR		; CBaseMonster::HasConditions, COMDAT

; 258  : 		inline BOOL HasConditions( int iConditions ) { if ( m_afConditions & iConditions ) return TRUE; return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1956]
	and	ecx, DWORD PTR _iConditions$[ebp]
	test	ecx, ecx
	je	SHORT $L36119
	mov	eax, 1
	jmp	SHORT $L36118
$L36119:
	xor	eax, eax
$L36118:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasConditions@CBaseMonster@@QAEHH@Z ENDP		; CBaseMonster::HasConditions
_TEXT	ENDS
PUBLIC	__real@4@40078000000000000000
PUBLIC	__real@4@4005a000000000000000
PUBLIC	?__LINE__Var@?1??CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z@4FA ; `CBaseMonster::CheckEnemy'::`2'::__LINE__Var
PUBLIC	??_C@_0CE@IGEF@?$CBHasConditions?$CIbits_COND_SEE_ENE@ ; `string'
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
PUBLIC	?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z ; CBaseMonster::CheckEnemy
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
;	COMDAT ?__LINE__Var@?1??CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z@4FA
; File z:\xashxtsrc\server\monsters\monsters.cpp
_DATA	SEGMENT
?__LINE__Var@?1??CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z@4FA DW 041dH ; `CBaseMonster::CheckEnemy'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CE@IGEF@?$CBHasConditions?$CIbits_COND_SEE_ENE@
CONST	SEGMENT
??_C@_0CE@IGEF@?$CBHasConditions?$CIbits_COND_SEE_ENE@ DB '!HasConditions'
	DB	'(bits_COND_SEE_ENEMY)', 00H			; `string'
CONST	ENDS
;	COMDAT __real@4@40078000000000000000
CONST	SEGMENT
__real@4@40078000000000000000 DD 043800000r	; 256
CONST	ENDS
;	COMDAT __real@4@4005a000000000000000
CONST	SEGMENT
__real@4@4005a000000000000000 DD 042a00000r	; 80
CONST	ENDS
;	COMDAT ?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T42060 = -52
$T42061 = -64
$T42062 = -76
$T42063 = -88
$T42064 = -100
$T42065 = -112
_pEnemy$ = 8
_this$ = -4
_flDistToEnemy$ = -8
_iUpdatedLKP$ = -12
_vecEnemyPos$ = -24
_flDistToEnemy2$ = -28
_flDistToEnemy2$40069 = -32
_pEnemyMonster$40073 = -36
_i$40087 = -40
?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z PROC NEAR ; CBaseMonster::CheckEnemy, COMDAT

; 1053 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1054 : 	float	flDistToEnemy;
; 1055 : 	int	iUpdatedLKP;// set this to TRUE if you update the EnemyLKP in this function.
; 1056 : 
; 1057 : 	iUpdatedLKP = FALSE;

	mov	DWORD PTR _iUpdatedLKP$[ebp], 0

; 1058 : 	ClearConditions ( bits_COND_ENEMY_FACING_ME );

	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::ClearConditions

; 1059 : 	
; 1060 : 	if ( !FVisible( pEnemy ) )

	mov	eax, DWORD PTR _pEnemy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+332]
	test	eax, eax
	jne	SHORT $L40058

; 1062 : 		ASSERT(!HasConditions(bits_COND_SEE_ENEMY));

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z@4FA ; `CBaseMonster::CheckEnemy'::`2'::__LINE__Var
	add	eax, 9
	push	eax
	push	OFFSET FLAT:??_C@_0CK@LGAM@z?3?2xashxtsrc?2server?2monsters?2mon@ ; `string'
	push	OFFSET FLAT:??_C@_0CE@IGEF@?$CBHasConditions?$CIbits_COND_SEE_ENE@ ; `string'
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	neg	eax
	sbb	eax, eax
	inc	eax
	push	eax
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1063 : 		SetConditions( bits_COND_ENEMY_OCCLUDED );

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions

; 1065 : 	else

	jmp	SHORT $L40061
$L40058:

; 1066 : 		ClearConditions( bits_COND_ENEMY_OCCLUDED );

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::ClearConditions
$L40061:

; 1067 : 
; 1068 : 	if ( !pEnemy->IsAlive() )

	mov	ecx, DWORD PTR _pEnemy$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEnemy$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	jne	SHORT $L40062

; 1070 : 		SetConditions ( bits_COND_ENEMY_DEAD );

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions

; 1071 : 		ClearConditions( bits_COND_SEE_ENEMY | bits_COND_ENEMY_OCCLUDED );

	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::ClearConditions

; 1072 : 		return FALSE;

	xor	eax, eax
	jmp	$L40055
$L40062:

; 1074 : 
; 1075 : 	Vector vecEnemyPos = pEnemy->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEnemy$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecEnemyPos$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1076 : 	// distance to enemy's origin
; 1077 : 	flDistToEnemy = ( vecEnemyPos - GetAbsOrigin() ).Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T42060[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecEnemyPos$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flDistToEnemy$[ebp]

; 1078 : 	vecEnemyPos.z += pEnemy->pev->size.z * 0.5;

	fld	DWORD PTR _vecEnemyPos$[ebp+8]
	mov	ecx, DWORD PTR _pEnemy$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+252]
	fmul	QWORD PTR __real@8@3ffe8000000000000000
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _vecEnemyPos$[ebp+8]

; 1079 : 	// distance to enemy's head
; 1080 : 	float flDistToEnemy2 = (vecEnemyPos - GetAbsOrigin()).Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T42061[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecEnemyPos$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flDistToEnemy2$[ebp]

; 1081 : 	if (flDistToEnemy2 < flDistToEnemy)

	fld	DWORD PTR _flDistToEnemy2$[ebp]
	fcomp	DWORD PTR _flDistToEnemy$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40067

; 1082 : 		flDistToEnemy = flDistToEnemy2;

	mov	ecx, DWORD PTR _flDistToEnemy2$[ebp]
	mov	DWORD PTR _flDistToEnemy$[ebp], ecx

; 1083 : 	else

	jmp	SHORT $L40071
$L40067:

; 1085 : 		// distance to enemy's feet
; 1086 : 		vecEnemyPos.z -= pEnemy->pev->size.z;

	mov	edx, DWORD PTR _pEnemy$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR _vecEnemyPos$[ebp+8]
	fsub	DWORD PTR [eax+252]
	fstp	DWORD PTR _vecEnemyPos$[ebp+8]

; 1087 : 		float flDistToEnemy2 = (vecEnemyPos - GetAbsOrigin()).Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T42062[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecEnemyPos$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flDistToEnemy2$40069[ebp]

; 1088 : 		if (flDistToEnemy2 < flDistToEnemy)

	fld	DWORD PTR _flDistToEnemy2$40069[ebp]
	fcomp	DWORD PTR _flDistToEnemy$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40071

; 1089 : 			flDistToEnemy = flDistToEnemy2;

	mov	edx, DWORD PTR _flDistToEnemy2$40069[ebp]
	mov	DWORD PTR _flDistToEnemy$[ebp], edx
$L40071:

; 1091 : 
; 1092 : 	if ( HasConditions( bits_COND_SEE_ENEMY ) )

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	$L40072

; 1094 : 		CBaseMonster *pEnemyMonster;
; 1095 : 
; 1096 : 		iUpdatedLKP = TRUE;

	mov	DWORD PTR _iUpdatedLKP$[ebp], 1

; 1097 : 		m_vecEnemyLKP = pEnemy->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEnemy$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1098 : 
; 1099 : 		pEnemyMonster = pEnemy->MyMonsterPointer();

	mov	ecx, DWORD PTR _pEnemy$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEnemy$[ebp]
	call	DWORD PTR [edx+124]
	mov	DWORD PTR _pEnemyMonster$40073[ebp], eax

; 1100 : 
; 1101 : 		if ( pEnemyMonster )

	cmp	DWORD PTR _pEnemyMonster$40073[ebp], 0
	je	SHORT $L40076

; 1103 : 			if ( pEnemyMonster->FInViewCone ( this ) )

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEnemyMonster$40073[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEnemyMonster$40073[ebp]
	call	DWORD PTR [edx+392]
	test	eax, eax
	je	SHORT $L40075

; 1105 : 				SetConditions ( bits_COND_ENEMY_FACING_ME );

	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions

; 1107 : 			else

	jmp	SHORT $L40076
$L40075:

; 1108 : 				ClearConditions( bits_COND_ENEMY_FACING_ME );

	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::ClearConditions
$L40076:

; 1110 : 
; 1111 : 		if (pEnemy->GetAbsVelocity() != g_vecZero)

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEnemy$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L40077

; 1113 : 			// trail the enemy a bit
; 1114 : 			m_vecEnemyLKP = m_vecEnemyLKP - pEnemy->GetAbsVelocity() * RANDOM_FLOAT( -0.05, 0 );

	push	0
	push	-1119040307				; bd4ccccdH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T42063[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEnemy$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T42064[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2288				; 000008f0H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L40077:

; 1121 : 	else if ( !HasConditions(bits_COND_ENEMY_OCCLUDED|bits_COND_SEE_ENEMY) && ( flDistToEnemy <= 256 ) )

	jmp	SHORT $L40082
$L40072:
	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	jne	SHORT $L40082
	fld	DWORD PTR _flDistToEnemy$[ebp]
	fcomp	DWORD PTR __real@4@40078000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40082

; 1123 : 		// if the enemy is not occluded, and unseen, that means it is behind or beside the monster.
; 1124 : 		// if the enemy is near enough the monster, we go ahead and let the monster know where the
; 1125 : 		// enemy is. 
; 1126 : 		iUpdatedLKP = TRUE;

	mov	DWORD PTR _iUpdatedLKP$[ebp], 1

; 1127 : 		m_vecEnemyLKP = pEnemy->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEnemy$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L40082:

; 1129 : 
; 1130 : 	if ( flDistToEnemy >= m_flDistTooFar )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flDistToEnemy$[ebp]
	fcomp	DWORD PTR [ecx+2340]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40083

; 1132 : 		// enemy is very far away from monster
; 1133 : 		SetConditions( bits_COND_ENEMY_TOOFAR );

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions

; 1135 : 	else

	jmp	SHORT $L40084
$L40083:

; 1136 : 		ClearConditions( bits_COND_ENEMY_TOOFAR );

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::ClearConditions
$L40084:

; 1137 : 
; 1138 : 	if ( FCanCheckAttacks() )	

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+520]
	test	eax, eax
	je	SHORT $L40085

; 1140 : 		CheckAttacks ( m_hEnemy, flDistToEnemy );

	mov	ecx, DWORD PTR _flDistToEnemy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckAttacks@CBaseMonster@@QAEXPAVCBaseEntity@@M@Z ; CBaseMonster::CheckAttacks
$L40085:

; 1142 : 
; 1143 : 	if ( m_movementGoal == MOVEGOAL_ENEMY )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2228], 2
	jne	SHORT $L40090

; 1145 : 		for ( int i = m_iRouteIndex; i < ROUTE_SIZE; i++ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2232]
	mov	DWORD PTR _i$40087[ebp], ecx
	jmp	SHORT $L40088
$L40089:
	mov	edx, DWORD PTR _i$40087[ebp]
	add	edx, 1
	mov	DWORD PTR _i$40087[ebp], edx
$L40088:
	cmp	DWORD PTR _i$40087[ebp], 8
	jge	SHORT $L40090

; 1147 : 			if ( m_Route[ i ].iType == (bits_MF_IS_GOAL|bits_MF_TO_ENEMY) )

	mov	eax, DWORD PTR _i$40087[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+2112], 130		; 00000082H
	jne	SHORT $L40093

; 1149 : 				// UNDONE: Should we allow monsters to override this distance (80?)
; 1150 : 				if ( (m_Route[ i ].vecLocation - m_vecEnemyLKP).Length() > 80 )

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2288				; 000008f0H
	push	edx
	lea	eax, DWORD PTR $T42065[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$40087[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+2100]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fcomp	DWORD PTR __real@4@4005a000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40093

; 1152 : 					// Refresh
; 1153 : 					FRefreshRoute();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FRefreshRoute@CBaseMonster@@QAEHXZ	; CBaseMonster::FRefreshRoute

; 1154 : 					return iUpdatedLKP;

	mov	eax, DWORD PTR _iUpdatedLKP$[ebp]
	jmp	SHORT $L40055
$L40093:

; 1157 : 		}

	jmp	SHORT $L40089
$L40090:

; 1159 : 
; 1160 : 	return iUpdatedLKP;

	mov	eax, DWORD PTR _iUpdatedLKP$[ebp]
$L40055:

; 1161 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z ENDP	; CBaseMonster::CheckEnemy
_TEXT	ENDS
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L42074
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L42074
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L42074
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L42075
$L42074:
	mov	DWORD PTR -8+[ebp], 0
$L42075:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
PUBLIC	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z		; EHANDLE::operator=
PUBLIC	?PushEnemy@CBaseMonster@@QAEXPAVCBaseEntity@@AAVVector@@@Z ; CBaseMonster::PushEnemy
;	COMDAT ?PushEnemy@CBaseMonster@@QAEXPAVCBaseEntity@@AAVVector@@@Z
_TEXT	SEGMENT
_pEnemy$ = 8
_vecLastKnownPos$ = 12
_this$ = -4
_i$ = -8
?PushEnemy@CBaseMonster@@QAEXPAVCBaseEntity@@AAVVector@@@Z PROC NEAR ; CBaseMonster::PushEnemy, COMDAT

; 1167 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1168 : 	int i;
; 1169 : 
; 1170 : 	if (pEnemy == NULL)

	cmp	DWORD PTR _pEnemy$[ebp], 0
	jne	SHORT $L40100

; 1171 : 		return;

	jmp	$L40098
$L40100:

; 1172 : 
; 1173 : 	// UNDONE: blah, this is bad, we should use a stack but I'm too lazy to code one.
; 1174 : 	for (i = 0; i < MAX_OLD_ENEMIES; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40101
$L40102:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L40101:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L40103

; 1176 : 		if (m_hOldEnemy[i] == pEnemy)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8+1976]
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	cmp	eax, DWORD PTR _pEnemy$[ebp]
	jne	SHORT $L40104

; 1177 : 			return;

	jmp	SHORT $L40098
$L40104:

; 1178 : 		if (m_hOldEnemy[i] == NULL) // someone died, reuse their slot

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8+1976]
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $L40105

; 1179 : 			break;

	jmp	SHORT $L40103
$L40105:

; 1180 : 	}

	jmp	SHORT $L40102
$L40103:

; 1181 : 	if (i >= MAX_OLD_ENEMIES)

	cmp	DWORD PTR _i$[ebp], 4
	jl	SHORT $L40106

; 1182 : 		return;

	jmp	SHORT $L40098
$L40106:

; 1183 : 
; 1184 : 	m_hOldEnemy[i] = pEnemy;

	mov	edx, DWORD PTR _pEnemy$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8+1976]
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1185 : 	m_vecOldEnemy[i] = vecLastKnownPos;

	mov	edx, DWORD PTR _vecLastKnownPos$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+2008]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
$L40098:

; 1186 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?PushEnemy@CBaseMonster@@QAEXPAVCBaseEntity@@AAVVector@@@Z ENDP ; CBaseMonster::PushEnemy
_TEXT	ENDS
EXTRN	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z:NEAR	; ENT
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z PROC NEAR	; EHANDLE::operator=, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 	if (pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L34280

; 72   : 		m_pent = ENT( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 73   : 		if (m_pent)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L34281

; 74   : 			m_serialnumber = m_pent->serialnumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$L34281:

; 76   : 	else

	jmp	SHORT $L34282
$L34280:

; 78   : 		m_pent = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 79   : 		m_serialnumber = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$L34282:

; 81   : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z ENDP		; EHANDLE::operator=
_TEXT	ENDS
PUBLIC	?PopEnemy@CBaseMonster@@QAEHXZ			; CBaseMonster::PopEnemy
;	COMDAT ?PopEnemy@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?PopEnemy@CBaseMonster@@QAEHXZ PROC NEAR		; CBaseMonster::PopEnemy, COMDAT

; 1192 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1193 : 	// UNDONE: blah, this is bad, we should use a stack but I'm too lazy to code one.
; 1194 : 	for (int i = MAX_OLD_ENEMIES - 1; i >= 0; i--)

	mov	DWORD PTR _i$[ebp], 3
	jmp	SHORT $L40111
$L40112:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L40111:
	cmp	DWORD PTR _i$[ebp], 0
	jl	$L40113

; 1196 : 		if (m_hOldEnemy[i] != NULL)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8+1976]
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	$L40116

; 1198 : 			if (m_hOldEnemy[i]->IsAlive( )) // cheat and know when they die

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8+1976]
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -12+[ebp], eax
	mov	edx, DWORD PTR -12+[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR -12+[ebp]
	call	DWORD PTR [eax+200]
	test	eax, eax
	je	SHORT $L40115

; 1200 : 				m_hEnemy = m_hOldEnemy[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+1976]
	mov	ecx, DWORD PTR [edx+ecx*8+1980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1960], eax
	mov	DWORD PTR [edx+1964], ecx

; 1201 : 				m_vecEnemyLKP = m_vecOldEnemy[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2008]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2288				; 000008f0H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 1202 : 				// ALERT( at_console, "remembering\n");
; 1203 : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $L40109
$L40115:

; 1207 : 				m_hOldEnemy[i] = NULL;

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8+1976]
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=
$L40116:

; 1210 : 	}

	jmp	$L40112
$L40113:

; 1211 : 	return FALSE;

	xor	eax, eax
$L40109:

; 1212 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PopEnemy@CBaseMonster@@QAEHXZ ENDP			; CBaseMonster::PopEnemy
_TEXT	ENDS
PUBLIC	??_C@_0BP@FOLO@?$CFs?5has?5no?5sequence?5for?5act?3?$CFd?6?$AA@ ; `string'
PUBLIC	?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z	; CBaseMonster::SetActivity
;	COMDAT ??_C@_0BP@FOLO@?$CFs?5has?5no?5sequence?5for?5act?3?$CFd?6?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BP@FOLO@?$CFs?5has?5no?5sequence?5for?5act?3?$CFd?6?$AA@ DB '%s ha'
	DB	's no sequence for act:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
_TEXT	SEGMENT
_NewActivity$ = 8
_this$ = -4
_iSequence$ = -8
?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z PROC NEAR	; CBaseMonster::SetActivity, COMDAT

; 1218 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1219 : 	int	iSequence;
; 1220 : 
; 1221 : 	iSequence = LookupActivity ( NewActivity );

	mov	eax, DWORD PTR _NewActivity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	DWORD PTR _iSequence$[ebp], eax

; 1222 : 
; 1223 : 	// Set to the desired anim, or default anim if the desired is not present
; 1224 : 	if ( iSequence > ACTIVITY_NOT_AVAILABLE )

	cmp	DWORD PTR _iSequence$[ebp], -1
	jle	SHORT $L40122

; 1226 : 		if ( pev->sequence != iSequence || !m_fSequenceLoops )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+296]
	cmp	eax, DWORD PTR _iSequence$[ebp]
	jne	SHORT $L40124
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1808], 0
	jne	SHORT $L40125
$L40124:

; 1228 : 			// don't reset frame between walk and run
; 1229 : 			if ( !(m_Activity == ACT_WALK || m_Activity == ACT_RUN) || !(NewActivity == ACT_WALK || NewActivity == ACT_RUN))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2068], 3
	je	SHORT $L40127
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2068], 4
	jne	SHORT $L40126
$L40127:
	cmp	DWORD PTR _NewActivity$[ebp], 3
	je	SHORT $L40125
	cmp	DWORD PTR _NewActivity$[ebp], 4
	je	SHORT $L40125
$L40126:

; 1230 : 				pev->frame = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+304], 0
$L40125:

; 1232 : 
; 1233 : 		pev->sequence		= iSequence;	// Set to the reset anim (if it's there)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _iSequence$[ebp]
	mov	DWORD PTR [ecx+296], edx

; 1234 : 		ResetSequenceInfo( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetSequenceInfo@CBaseAnimating@@QAEXXZ ; CBaseAnimating::ResetSequenceInfo

; 1235 : 		SetYawSpeed();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+500]

; 1237 : 	else

	jmp	SHORT $L40128
$L40122:

; 1239 : 		// Not available try to get default anim
; 1240 : 		ALERT ( at_aiconsole, "%s has no sequence for act:%d\n", STRING(pev->classname), NewActivity );

	mov	eax, DWORD PTR _NewActivity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BP@FOLO@?$CFs?5has?5no?5sequence?5for?5act?3?$CFd?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 1241 : 		pev->sequence		= 0;	// Set to the reset anim (if it's there)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+296], 0
$L40128:

; 1243 : 
; 1244 : 	m_Activity = NewActivity; // Go ahead and set this so it doesn't keep trying when the anim is not present

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _NewActivity$[ebp]
	mov	DWORD PTR [eax+2068], ecx

; 1245 : 	
; 1246 : 	// In case someone calls this with something other than the ideal activity
; 1247 : 	m_IdealActivity = m_Activity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2068]
	mov	DWORD PTR [edx+2072], ecx

; 1248 : 
; 1249 : 
; 1250 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z ENDP	; CBaseMonster::SetActivity
_TEXT	ENDS
PUBLIC	??_C@_0BN@DCCI@?$CFs?5has?5no?5sequence?5named?3?$CFf?6?$AA@ ; `string'
PUBLIC	?SetSequenceByName@CBaseMonster@@QAEXPAD@Z	; CBaseMonster::SetSequenceByName
EXTRN	?LookupSequence@CBaseAnimating@@QAEHPBD@Z:NEAR	; CBaseAnimating::LookupSequence
;	COMDAT ??_C@_0BN@DCCI@?$CFs?5has?5no?5sequence?5named?3?$CFf?6?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BN@DCCI@?$CFs?5has?5no?5sequence?5named?3?$CFf?6?$AA@ DB '%s has n'
	DB	'o sequence named:%f', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?SetSequenceByName@CBaseMonster@@QAEXPAD@Z
_TEXT	SEGMENT
_szSequence$ = 8
_this$ = -4
_iSequence$ = -8
?SetSequenceByName@CBaseMonster@@QAEXPAD@Z PROC NEAR	; CBaseMonster::SetSequenceByName, COMDAT

; 1256 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1257 : 	int	iSequence;
; 1258 : 
; 1259 : 	iSequence = LookupSequence ( szSequence );

	mov	eax, DWORD PTR _szSequence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupSequence@CBaseAnimating@@QAEHPBD@Z ; CBaseAnimating::LookupSequence
	mov	DWORD PTR _iSequence$[ebp], eax

; 1260 : 
; 1261 : 	// Set to the desired anim, or default anim if the desired is not present
; 1262 : 	if ( iSequence > ACTIVITY_NOT_AVAILABLE )

	cmp	DWORD PTR _iSequence$[ebp], -1
	jle	SHORT $L40135

; 1264 : 		if ( pev->sequence != iSequence || !m_fSequenceLoops )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+296]
	cmp	eax, DWORD PTR _iSequence$[ebp]
	jne	SHORT $L40137
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1808], 0
	jne	SHORT $L40136
$L40137:

; 1266 : 			pev->frame = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+304], 0
$L40136:

; 1268 : 
; 1269 : 		pev->sequence		= iSequence;	// Set to the reset anim (if it's there)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _iSequence$[ebp]
	mov	DWORD PTR [edx+296], eax

; 1270 : 		ResetSequenceInfo( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetSequenceInfo@CBaseAnimating@@QAEXXZ ; CBaseAnimating::ResetSequenceInfo

; 1271 : 		SetYawSpeed();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+500]

; 1273 : 	else

	jmp	SHORT $L40138
$L40135:

; 1275 : 		// Not available try to get default anim
; 1276 : 		ALERT ( at_aiconsole, "%s has no sequence named:%f\n", STRING(pev->classname), szSequence );

	mov	eax, DWORD PTR _szSequence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BN@DCCI@?$CFs?5has?5no?5sequence?5named?3?$CFf?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 1277 : 		pev->sequence		= 0;	// Set to the reset anim (if it's there)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+296], 0
$L40138:

; 1279 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSequenceByName@CBaseMonster@@QAEXPAD@Z ENDP		; CBaseMonster::SetSequenceByName
_TEXT	ENDS
PUBLIC	__real@4@40038000000000000000
PUBLIC	__real@8@40058000000000000000
PUBLIC	?Length2D@Vector@@QBEMXZ			; Vector::Length2D
PUBLIC	?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z ; CBaseMonster::CheckLocalMove
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
EXTRN	_fabs:NEAR
EXTRN	?UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z:NEAR	; UTIL_DropToFloor
EXTRN	?UTIL_VecToYaw@@YAMABVVector@@@Z:NEAR		; UTIL_VecToYaw
EXTRN	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z:NEAR ; UTIL_SetOrigin
;	COMDAT __real@4@40038000000000000000
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
__real@4@40038000000000000000 DD 041800000r	; 16
CONST	ENDS
;	COMDAT __real@8@40058000000000000000
CONST	SEGMENT
__real@8@40058000000000000000 DQ 04050000000000000r ; 64
CONST	ENDS
;	COMDAT ?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
_TEXT	SEGMENT
$T42088 = -48
$T42089 = -60
_vecStart$ = 8
_vecEnd$ = 12
_pTarget$ = 16
_pflDist$ = 20
_this$ = -4
_vecStartPos$ = -16
_flYaw$ = -20
_flDist$ = -24
_flStep$ = -28
_stepSize$ = -32
_iReturn$ = -36
?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z PROC NEAR ; CBaseMonster::CheckLocalMove, COMDAT

; 1296 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1297 : 	Vector	vecStartPos;// record monster's position before trying the move

	lea	ecx, DWORD PTR _vecStartPos$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1298 : 	float	flYaw;
; 1299 : 	float	flDist;
; 1300 : 	float	flStep, stepSize;
; 1301 : 	int		iReturn;
; 1302 : 
; 1303 : 	vecStartPos = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecStartPos$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecStartPos$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecStartPos$[ebp+8], eax

; 1304 : 	
; 1305 : 	flYaw = UTIL_VecToYaw ( vecEnd - vecStart );// build a yaw that points to the goal.

	mov	ecx, DWORD PTR _vecStart$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T42088[ebp]
	push	edx
	mov	ecx, DWORD PTR _vecEnd$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	call	?UTIL_VecToYaw@@YAMABVVector@@@Z	; UTIL_VecToYaw
	add	esp, 4
	fstp	DWORD PTR _flYaw$[ebp]

; 1306 : 	flDist = ( vecEnd - vecStart ).Length2D();// get the distance.

	mov	eax, DWORD PTR _vecStart$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T42089[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vecEnd$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length2D@Vector@@QBEMXZ		; Vector::Length2D
	fstp	DWORD PTR _flDist$[ebp]

; 1307 : 	iReturn = LOCALMOVE_VALID;// assume everything will be ok.

	mov	DWORD PTR _iReturn$[ebp], 2

; 1308 : 
; 1309 : 	// move the monster to the start of the local move that's to be checked.
; 1310 : 	UTIL_SetOrigin( this, vecStart );// !!!BUGBUG - won't this fire triggers? - nope, SetOrigin doesn't fire

	mov	edx, DWORD PTR _vecStart$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 1311 : 
; 1312 : 	if ( !(pev->flags & (FL_FLY|FL_SWIM)) )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 3
	test	eax, eax
	jne	SHORT $L40156

; 1314 : 		UTIL_DropToFloor( this );//make sure monster is on the floor!

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z ; UTIL_DropToFloor
	add	esp, 4
$L40156:

; 1316 : 
; 1317 : 	// this loop takes single steps to the goal.
; 1318 : 	for ( flStep = 0 ; flStep < flDist ; flStep += LOCAL_STEP_SIZE )

	mov	DWORD PTR _flStep$[ebp], 0
	jmp	SHORT $L40157
$L40158:
	fld	DWORD PTR _flStep$[ebp]
	fadd	DWORD PTR __real@4@40038000000000000000
	fstp	DWORD PTR _flStep$[ebp]
$L40157:
	fld	DWORD PTR _flStep$[ebp]
	fcomp	DWORD PTR _flDist$[ebp]
	fnstsw	ax
	test	ah, 1
	je	$L40159

; 1320 : 		stepSize = LOCAL_STEP_SIZE;

	mov	DWORD PTR _stepSize$[ebp], 1098907648	; 41800000H

; 1321 : 
; 1322 : 		if ( (flStep + LOCAL_STEP_SIZE) >= (flDist-1) )

	fld	DWORD PTR _flStep$[ebp]
	fadd	DWORD PTR __real@4@40038000000000000000
	fld	DWORD PTR _flDist$[ebp]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40160

; 1323 : 			stepSize = (flDist - flStep) - 1;

	fld	DWORD PTR _flDist$[ebp]
	fsub	DWORD PTR _flStep$[ebp]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _stepSize$[ebp]
$L40160:

; 1324 : 		
; 1325 : //		UTIL_ParticleEffect ( GetAbsOrigin(), g_vecZero, 255, 25 );
; 1326 : 
; 1327 : 		if ( !WALK_MOVE( ENT(pev), flYaw, stepSize, WALKMOVE_CHECKONLY ) )

	push	2
	mov	edx, DWORD PTR _stepSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _flYaw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+108
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L40164

; 1329 : 
; 1330 : 			if ( pflDist != NULL )

	cmp	DWORD PTR _pflDist$[ebp], 0
	je	SHORT $L40162

; 1332 : 				*pflDist = flStep;

	mov	eax, DWORD PTR _pflDist$[ebp]
	mov	ecx, DWORD PTR _flStep$[ebp]
	mov	DWORD PTR [eax], ecx
$L40162:

; 1334 : 			if ( pTarget && pTarget->edict() == gpGlobals->trace_ent )

	cmp	DWORD PTR _pTarget$[ebp], 0
	je	SHORT $L40163
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	cmp	eax, DWORD PTR [edx+116]
	jne	SHORT $L40163

; 1336 : 				// if this step hits target ent, the move is legal.
; 1337 : 				iReturn = LOCALMOVE_VALID;

	mov	DWORD PTR _iReturn$[ebp], 2

; 1338 : 				break;

	jmp	SHORT $L40159
$L40163:

; 1342 : 				// If we're going toward an entity, and we're almost getting there, it's OK.
; 1343 : //				if ( pTarget && fabs( flDist - iStep ) < LOCAL_STEP_SIZE )
; 1344 : //					fReturn = TRUE;
; 1345 : //				else
; 1346 : 				iReturn = LOCALMOVE_INVALID;

	mov	DWORD PTR _iReturn$[ebp], 0

; 1347 : 				break;

	jmp	SHORT $L40159
$L40164:

; 1351 : 	}

	jmp	$L40158
$L40159:

; 1352 : 
; 1353 : 	if ( iReturn == LOCALMOVE_VALID && 	!(pev->flags & (FL_FLY|FL_SWIM) ) && (!pTarget || (pTarget->pev->flags & FL_ONGROUND)) )

	cmp	DWORD PTR _iReturn$[ebp], 2
	jne	SHORT $L40167
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 3
	test	edx, edx
	jne	SHORT $L40167
	cmp	DWORD PTR _pTarget$[ebp], 0
	je	SHORT $L40166
	mov	eax, DWORD PTR _pTarget$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	SHORT $L40167
$L40166:

; 1355 : 		// The monster can move to a spot UNDER the target, but not to it. Don't try to triangulate, go directly to the node graph.
; 1356 : 		// UNDONE: Magic # 64 -- this used to be pev->size.z but that won't work for small creatures like the headcrab
; 1357 : 		if ( fabs(vecEnd.z - GetAbsOrigin().z) > 64 )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR _vecEnd$[ebp]
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@40058000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40167

; 1359 : 			iReturn = LOCALMOVE_INVALID_DONT_TRIANGULATE;

	mov	DWORD PTR _iReturn$[ebp], 1
$L40167:

; 1362 : 
; 1363 : 	// since we've actually moved the monster during the check, undo the move.
; 1364 : 	UTIL_SetOrigin( this, vecStartPos );

	lea	edx, DWORD PTR _vecStartPos$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 1365 : 
; 1366 : 	return iReturn;

	mov	eax, DWORD PTR _iReturn$[ebp]

; 1367 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z ENDP ; CBaseMonster::CheckLocalMove
_TEXT	ENDS
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length2D@Vector@@QBEMXZ PROC NEAR			; Vector::Length2D, COMDAT

; 282  : 	inline float Length2D(void) const { return sqrt(x*x + y*y); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length2D@Vector@@QBEMXZ ENDP				; Vector::Length2D
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
PUBLIC	?OpenDoorAndWait@CBaseMonster@@QAEMPAUentvars_s@@@Z ; CBaseMonster::OpenDoorAndWait
PUBLIC	?GetLocalTime@CBaseEntity@@QBEMXZ		; CBaseEntity::GetLocalTime
PUBLIC	?GetMoveDoneTime@CBaseEntity@@QBEMXZ		; CBaseEntity::GetMoveDoneTime
PUBLIC	?FIND_ENTITY_BY_TARGETNAME@@YAPAUedict_s@@PAU1@PBD@Z ; FIND_ENTITY_BY_TARGETNAME
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
PUBLIC	?FNullEnt@@YAHPBUedict_s@@@Z			; FNullEnt
PUBLIC	?FClassnameIs@@YAHPAUedict_s@@PBD@Z		; FClassnameIs
PUBLIC	?IsLockedByMaster@CBaseEntity@@QAEHXZ		; CBaseEntity::IsLockedByMaster
;	COMDAT ?OpenDoorAndWait@CBaseMonster@@QAEMPAUentvars_s@@@Z
_TEXT	SEGMENT
_pevDoor$ = 8
_this$ = -4
_flTravelTime$ = -8
_pcbeDoor$ = -12
_pentTarget$40176 = -16
_pDoor$40183 = -20
?OpenDoorAndWait@CBaseMonster@@QAEMPAUentvars_s@@@Z PROC NEAR ; CBaseMonster::OpenDoorAndWait, COMDAT

; 1371 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1372 : 	float flTravelTime = 0;

	mov	DWORD PTR _flTravelTime$[ebp], 0

; 1373 : 
; 1374 : 	//ALERT(at_aiconsole, "A door. ");
; 1375 : 	CBaseEntity *pcbeDoor = CBaseEntity::Instance(pevDoor);

	mov	eax, DWORD PTR _pevDoor$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pcbeDoor$[ebp], eax

; 1376 : 	if (pcbeDoor && !pcbeDoor->IsLockedByMaster())

	cmp	DWORD PTR _pcbeDoor$[ebp], 0
	je	$L40179
	mov	ecx, DWORD PTR _pcbeDoor$[ebp]
	call	?IsLockedByMaster@CBaseEntity@@QAEHXZ	; CBaseEntity::IsLockedByMaster
	test	eax, eax
	jne	$L40179

; 1378 : 		//ALERT(at_aiconsole, "unlocked! ");
; 1379 : 		pcbeDoor->Use(this, this, USE_ON, 0.0);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _pcbeDoor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pcbeDoor$[ebp]
	call	DWORD PTR [edx+276]

; 1380 : 		//ALERT(at_aiconsole, "pevDoor->nextthink = %d ms\n", (int)(1000*pevDoor->nextthink));
; 1381 : 		//ALERT(at_aiconsole, "pevDoor->ltime = %d ms\n", (int)(1000*pevDoor->ltime));
; 1382 : 		//ALERT(at_aiconsole, "pev-> nextthink = %d ms\n", (int)(1000*pev->nextthink));
; 1383 : 		//ALERT(at_aiconsole, "pev->ltime = %d ms\n", (int)(1000*pev->ltime));
; 1384 : 		flTravelTime = pcbeDoor->GetMoveDoneTime() - pcbeDoor->GetLocalTime();

	mov	ecx, DWORD PTR _pcbeDoor$[ebp]
	call	?GetMoveDoneTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetMoveDoneTime
	fstp	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _pcbeDoor$[ebp]
	call	?GetLocalTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetLocalTime
	fsubr	DWORD PTR -24+[ebp]
	fstp	DWORD PTR _flTravelTime$[ebp]

; 1385 : 		//ALERT(at_aiconsole, "Waiting %d ms\n", (int)(1000*flTravelTime));
; 1386 : 		if ( pcbeDoor->pev->targetname )

	mov	eax, DWORD PTR _pcbeDoor$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+460], 0
	je	$L40179

; 1388 : 			edict_t *pentTarget = NULL;

	mov	DWORD PTR _pentTarget$40176[ebp], 0
$L40178:

; 1391 : 				pentTarget = FIND_ENTITY_BY_TARGETNAME( pentTarget, STRING(pcbeDoor->pev->targetname));

	mov	edx, DWORD PTR _pcbeDoor$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+460]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pentTarget$40176[ebp]
	push	edx
	call	?FIND_ENTITY_BY_TARGETNAME@@YAPAUedict_s@@PAU1@PBD@Z ; FIND_ENTITY_BY_TARGETNAME
	add	esp, 8
	mov	DWORD PTR _pentTarget$40176[ebp], eax

; 1392 : 
; 1393 : 				if ( VARS( pentTarget ) != pcbeDoor->pev )

	mov	eax, DWORD PTR _pentTarget$40176[ebp]
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	ecx, DWORD PTR _pcbeDoor$[ebp]
	cmp	eax, DWORD PTR [ecx+4]
	je	SHORT $L40184

; 1395 : 					if (FNullEnt(pentTarget))

	mov	edx, DWORD PTR _pentTarget$40176[ebp]
	push	edx
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L40181

; 1396 : 						break;

	jmp	SHORT $L40179
$L40181:

; 1397 : 
; 1398 : 					if ( FClassnameIs ( pentTarget, STRING(pcbeDoor->pev->classname) ) )

	mov	eax, DWORD PTR _pcbeDoor$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pentTarget$40176[ebp]
	push	eax
	call	?FClassnameIs@@YAHPAUedict_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L40184

; 1400 : 						CBaseEntity *pDoor = Instance(pentTarget);

	mov	ecx, DWORD PTR _pentTarget$40176[ebp]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pDoor$40183[ebp], eax

; 1401 : 						if ( pDoor )

	cmp	DWORD PTR _pDoor$40183[ebp], 0
	je	SHORT $L40184

; 1402 : 							pDoor->Use(this, this, USE_ON, 0.0);

	push	0
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDoor$40183[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pDoor$40183[ebp]
	call	DWORD PTR [edx+276]
$L40184:

; 1405 : 			}

	jmp	$L40178
$L40179:

; 1408 : 
; 1409 : 	return gpGlobals->time + flTravelTime;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _flTravelTime$[ebp]
	fadd	DWORD PTR [eax]

; 1410 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OpenDoorAndWait@CBaseMonster@@QAEMPAUentvars_s@@@Z ENDP ; CBaseMonster::OpenDoorAndWait
_TEXT	ENDS
PUBLIC	??_C@_0L@PMO@targetname?$AA@			; `string'
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0L@PMO@targetname?$AA@ DB 'targetname', 00H	; `string'
CONST	ENDS
;	COMDAT ?FIND_ENTITY_BY_TARGETNAME@@YAPAUedict_s@@PAU1@PBD@Z
_TEXT	SEGMENT
_entStart$ = 8
_pszName$ = 12
?FIND_ENTITY_BY_TARGETNAME@@YAPAUedict_s@@PAU1@PBD@Z PROC NEAR ; FIND_ENTITY_BY_TARGETNAME, COMDAT

; 114  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 115  : 	return FIND_ENTITY_BY_STRING(entStart, "targetname", pszName);

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@PMO@targetname?$AA@ ; `string'
	mov	ecx, DWORD PTR _entStart$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+56
	add	esp, 12					; 0000000cH

; 116  : }	

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FIND_ENTITY_BY_TARGETNAME@@YAPAUedict_s@@PAU1@PBD@Z ENDP ; FIND_ENTITY_BY_TARGETNAME
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC NEAR		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32448

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L32447
$L32448:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$L32447:

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?FNullEnt@@YAHPBUedict_s@@@Z PROC NEAR			; FNullEnt, COMDAT

; 195  : inline BOOL FNullEnt(const edict_t* pent)	{ return pent == NULL || FNullEnt(OFFSET(pent)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L42106
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L42106
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L42107
$L42106:
	mov	DWORD PTR -4+[ebp], 1
$L42107:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPBUedict_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
;	COMDAT ?FClassnameIs@@YAHPAUedict_s@@PBD@Z
_TEXT	SEGMENT
_pent$ = 8
_szClassname$ = 12
?FClassnameIs@@YAHPAUedict_s@@PBD@Z PROC NEAR		; FClassnameIs, COMDAT

; 288  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 289  : 	if( FNullEnt( pent )) return FALSE;

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L32559
	xor	eax, eax
	jmp	SHORT $L32558
$L32559:

; 290  : 	return FStrEq( STRING( VARS( pent )->classname ), szClassname );

	mov	ecx, DWORD PTR _szClassname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
$L32558:

; 291  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FClassnameIs@@YAHPAUedict_s@@PBD@Z ENDP		; FClassnameIs
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
;	COMDAT ?IsLockedByMaster@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsLockedByMaster@CBaseEntity@@QAEHXZ PROC NEAR		; CBaseEntity::IsLockedByMaster, COMDAT

; 523  : 	BOOL	IsLockedByMaster( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLockedByMaster@CBaseEntity@@QAEHXZ ENDP		; CBaseEntity::IsLockedByMaster
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetLocalTime@CBaseEntity@@QBEMXZ PROC NEAR		; CBaseEntity::GetLocalTime, COMDAT

; 788  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 789  : 	return pev->ltime; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+256]

; 790  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLocalTime@CBaseEntity@@QBEMXZ ENDP			; CBaseEntity::GetLocalTime
_TEXT	ENDS
;	COMDAT ?GetMoveDoneTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetMoveDoneTime@CBaseEntity@@QBEMXZ PROC NEAR		; CBaseEntity::GetMoveDoneTime, COMDAT

; 805  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 806  : 	return (m_flMoveDoneTime >= 0) ? m_flMoveDoneTime - GetLocalTime() : -1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L42122
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetLocalTime
	mov	ecx, DWORD PTR _this$[ebp]
	fsubr	DWORD PTR [ecx+44]
	fstp	DWORD PTR -8+[ebp]
	jmp	SHORT $L42123
$L42122:
	mov	DWORD PTR -8+[ebp], -1082130432		; bf800000H
$L42123:
	fld	DWORD PTR -8+[ebp]

; 807  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMoveDoneTime@CBaseEntity@@QBEMXZ ENDP		; CBaseEntity::GetMoveDoneTime
_TEXT	ENDS
PUBLIC	__real@8@3ffcccccccccccccd000
PUBLIC	??_C@_0BH@OHLJ@Can?8t?5Refresh?5Route?$CB?$CB?6?$AA@ ; `string'
PUBLIC	?MovementComplete@CBaseMonster@@QAEXXZ		; CBaseMonster::MovementComplete
PUBLIC	?AdvanceRoute@CBaseMonster@@QAEXM@Z		; CBaseMonster::AdvanceRoute
EXTRN	?FindNearestNode@CGraph@@QAEHABVVector@@PAVCBaseEntity@@@Z:NEAR ; CGraph::FindNearestNode
EXTRN	?HandleLinkEnt@CGraph@@QAEHHPAUentvars_s@@HW4NODEQUERY@1@@Z:NEAR ; CGraph::HandleLinkEnt
EXTRN	?HashSearch@CGraph@@QAEXHHAAH@Z:NEAR		; CGraph::HashSearch
EXTRN	?WorldGraph@@3VCGraph@@A:BYTE			; WorldGraph
;	COMDAT ??_C@_0BH@OHLJ@Can?8t?5Refresh?5Route?$CB?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BH@OHLJ@Can?8t?5Refresh?5Route?$CB?$CB?6?$AA@ DB 'Can''t Refresh R'
	DB	'oute!!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@8@3ffcccccccccccccd000
CONST	SEGMENT
__real@8@3ffcccccccccccccd000 DQ 03fc999999999999ar ; 0.2
CONST	ENDS
;	COMDAT ?AdvanceRoute@CBaseMonster@@QAEXM@Z
_TEXT	SEGMENT
_distance$ = 8
_this$ = -4
_iSrcNode$40196 = -8
_iDestNode$40197 = -12
_iLink$40198 = -16
_pevDoor$40201 = -20
?AdvanceRoute@CBaseMonster@@QAEXM@Z PROC NEAR		; CBaseMonster::AdvanceRoute, COMDAT

; 1419 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1420 : 
; 1421 : 	if ( m_iRouteIndex == ROUTE_SIZE - 1 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2232], 7
	jne	SHORT $L40189

; 1423 : 		// time to refresh the route.
; 1424 : 		if ( !FRefreshRoute() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FRefreshRoute@CBaseMonster@@QAEHXZ	; CBaseMonster::FRefreshRoute
	test	eax, eax
	jne	SHORT $L40190

; 1426 : 			ALERT ( at_aiconsole, "Can't Refresh Route!!\n" );

	push	OFFSET FLAT:??_C@_0BH@OHLJ@Can?8t?5Refresh?5Route?$CB?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L40190:

; 1429 : 	else

	jmp	$L40204
$L40189:

; 1431 : 		if ( ! (m_Route[ m_iRouteIndex ].iType & bits_MF_IS_GOAL) )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2232]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+2112]
	and	ecx, 128				; 00000080H
	test	ecx, ecx
	jne	$L40193

; 1433 : 			// If we've just passed a path_corner, advance m_pGoalEnt
; 1434 : 			if ( (m_Route[ m_iRouteIndex ].iType & ~bits_MF_NOT_TO_MASK) == bits_MF_TO_PATHCORNER )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2232]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+2112]
	and	edx, -385				; fffffe7fH
	cmp	edx, 16					; 00000010H
	jne	SHORT $L40194

; 1435 : 				m_pGoalEnt = m_pGoalEnt->GetNextTarget();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+268]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$L40194:

; 1440 : 			   && (m_Route[m_iRouteIndex+1].iType & bits_MF_TO_NODE) == bits_MF_TO_NODE)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2232]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+2112]
	and	edx, 32					; 00000020H
	cmp	edx, 32					; 00000020H
	jne	$L40202
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2232]
	add	ecx, 1
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+2112]
	and	eax, 32					; 00000020H
	cmp	eax, 32					; 00000020H
	jne	$L40202

; 1442 : 				//ALERT(at_aiconsole, "SVD: Two nodes. ");
; 1443 : 
; 1444 : 				int iSrcNode  = WorldGraph.FindNearestNode(m_Route[m_iRouteIndex].vecLocation, this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2232]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2100]
	push	edx
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FindNearestNode@CGraph@@QAEHABVVector@@PAVCBaseEntity@@@Z ; CGraph::FindNearestNode
	mov	DWORD PTR _iSrcNode$40196[ebp], eax

; 1445 : 				int iDestNode = WorldGraph.FindNearestNode(m_Route[m_iRouteIndex+1].vecLocation, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2232]
	add	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2100]
	push	ecx
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FindNearestNode@CGraph@@QAEHABVVector@@PAVCBaseEntity@@@Z ; CGraph::FindNearestNode
	mov	DWORD PTR _iDestNode$40197[ebp], eax

; 1446 : 
; 1447 : 				int iLink;
; 1448 : 				WorldGraph.HashSearch(iSrcNode, iDestNode, iLink);

	lea	edx, DWORD PTR _iLink$40198[ebp]
	push	edx
	mov	eax, DWORD PTR _iDestNode$40197[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSrcNode$40196[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?HashSearch@CGraph@@QAEXHHAAH@Z		; CGraph::HashSearch

; 1449 : 
; 1450 : 				if ( iLink >= 0 && WorldGraph.m_pLinkPool[iLink].m_pLinkEnt != NULL )

	cmp	DWORD PTR _iLink$40198[ebp], 0
	jl	SHORT $L40202
	mov	edx, DWORD PTR _iLink$40198[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+16
	cmp	DWORD PTR [eax+edx+8], 0
	je	SHORT $L40202

; 1452 : 					//ALERT(at_aiconsole, "A link. ");
; 1453 : 					if ( WorldGraph.HandleLinkEnt ( iSrcNode, WorldGraph.m_pLinkPool[iLink].m_pLinkEnt, m_afCapability, CGraph::NODEGRAPH_DYNAMIC ) )

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2304]
	push	edx
	mov	eax, DWORD PTR _iLink$40198[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+16
	mov	edx, DWORD PTR [ecx+eax+8]
	push	edx
	mov	eax, DWORD PTR _iSrcNode$40196[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?HandleLinkEnt@CGraph@@QAEHHPAUentvars_s@@HW4NODEQUERY@1@@Z ; CGraph::HandleLinkEnt
	test	eax, eax
	je	SHORT $L40202

; 1455 : 						//ALERT(at_aiconsole, "usable.");
; 1456 : 						entvars_t *pevDoor = WorldGraph.m_pLinkPool[iLink].m_pLinkEnt;

	mov	ecx, DWORD PTR _iLink$40198[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+16
	mov	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _pevDoor$40201[ebp], eax

; 1457 : 						if (pevDoor)

	cmp	DWORD PTR _pevDoor$40201[ebp], 0
	je	SHORT $L40202

; 1459 : 							m_flMoveWaitFinished = OpenDoorAndWait( pevDoor );

	mov	ecx, DWORD PTR _pevDoor$40201[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OpenDoorAndWait@CBaseMonster@@QAEMPAUentvars_s@@@Z ; CBaseMonster::OpenDoorAndWait
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+2064]
$L40202:

; 1466 : 			m_iRouteIndex++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2232]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2232], ecx

; 1468 : 		else	// At goal!!!

	jmp	SHORT $L40204
$L40193:

; 1470 : 			if ( distance < m_flGroundSpeed * 0.2 /* FIX */ )

	fld	DWORD PTR _distance$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1796]
	fmul	QWORD PTR __real@8@3ffcccccccccccccd000
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40204

; 1472 : 				MovementComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MovementComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::MovementComplete
$L40204:

; 1476 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AdvanceRoute@CBaseMonster@@QAEXM@Z ENDP		; CBaseMonster::AdvanceRoute
_TEXT	ENDS
PUBLIC	?RouteClassify@CBaseMonster@@QAEHH@Z		; CBaseMonster::RouteClassify
;	COMDAT ?RouteClassify@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT
_iMoveFlag$ = 8
_this$ = -4
_movementGoal$ = -8
?RouteClassify@CBaseMonster@@QAEHH@Z PROC NEAR		; CBaseMonster::RouteClassify, COMDAT

; 1480 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1481 : 	int movementGoal;
; 1482 : 
; 1483 : 	movementGoal = MOVEGOAL_NONE;

	mov	DWORD PTR _movementGoal$[ebp], 0

; 1484 : 
; 1485 : 	if ( iMoveFlag & bits_MF_TO_TARGETENT )

	mov	eax, DWORD PTR _iMoveFlag$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L40210

; 1486 : 		movementGoal = MOVEGOAL_TARGETENT;

	mov	DWORD PTR _movementGoal$[ebp], 1

; 1487 : 	else if ( iMoveFlag & bits_MF_TO_ENEMY )

	jmp	SHORT $L40218
$L40210:
	mov	ecx, DWORD PTR _iMoveFlag$[ebp]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L40212

; 1488 : 		movementGoal = MOVEGOAL_ENEMY;

	mov	DWORD PTR _movementGoal$[ebp], 2

; 1489 : 	else if ( iMoveFlag & bits_MF_TO_PATHCORNER )

	jmp	SHORT $L40218
$L40212:
	mov	edx, DWORD PTR _iMoveFlag$[ebp]
	and	edx, 16					; 00000010H
	test	edx, edx
	je	SHORT $L40214

; 1490 : 		movementGoal = MOVEGOAL_PATHCORNER;

	mov	DWORD PTR _movementGoal$[ebp], 16	; 00000010H

; 1491 : 	else if ( iMoveFlag & bits_MF_TO_NODE )

	jmp	SHORT $L40218
$L40214:
	mov	eax, DWORD PTR _iMoveFlag$[ebp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $L40216

; 1492 : 		movementGoal = MOVEGOAL_NODE;

	mov	DWORD PTR _movementGoal$[ebp], 32	; 00000020H

; 1493 : 	else if ( iMoveFlag & bits_MF_TO_LOCATION )

	jmp	SHORT $L40218
$L40216:
	mov	ecx, DWORD PTR _iMoveFlag$[ebp]
	and	ecx, 64					; 00000040H
	test	ecx, ecx
	je	SHORT $L40218

; 1494 : 		movementGoal = MOVEGOAL_LOCATION;

	mov	DWORD PTR _movementGoal$[ebp], 64	; 00000040H
$L40218:

; 1495 : 
; 1496 : 	return movementGoal;

	mov	eax, DWORD PTR _movementGoal$[ebp]

; 1497 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RouteClassify@CBaseMonster@@QAEHH@Z ENDP		; CBaseMonster::RouteClassify
_TEXT	ENDS
;	COMDAT ?BuildRoute@CBaseMonster@@QAEHABVVector@@HPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_vecGoal$ = 8
_iMoveFlag$ = 12
_pTarget$ = 16
_this$ = -4
_flDist$ = -8
_vecApex$ = -20
_iLocalMove$ = -24
?BuildRoute@CBaseMonster@@QAEHABVVector@@HPAVCBaseEntity@@@Z PROC NEAR ; CBaseMonster::BuildRoute, COMDAT

; 1503 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1504 : 	float	flDist;
; 1505 : 	Vector	vecApex;

	lea	ecx, DWORD PTR _vecApex$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1506 : 	int		iLocalMove;
; 1507 : 
; 1508 : 	RouteNew();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RouteNew@CBaseMonster@@QAEXXZ		; CBaseMonster::RouteNew

; 1509 : 	m_movementGoal = RouteClassify( iMoveFlag );

	mov	eax, DWORD PTR _iMoveFlag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RouteClassify@CBaseMonster@@QAEHH@Z	; CBaseMonster::RouteClassify
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2228], eax

; 1510 : 
; 1511 : // so we don't end up with no moveflags
; 1512 : 	m_Route[ 0 ].vecLocation = vecGoal;

	mov	edx, DWORD PTR _vecGoal$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2100				; 00000834H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 1513 : 	m_Route[ 0 ].iType = iMoveFlag | bits_MF_IS_GOAL;

	mov	eax, DWORD PTR _iMoveFlag$[ebp]
	or	al, -128				; ffffff80H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2112], eax

; 1514 : 
; 1515 : // check simple local move
; 1516 : 	iLocalMove = CheckLocalMove( GetAbsOrigin(), vecGoal, pTarget, &flDist );

	lea	edx, DWORD PTR _flDist$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecGoal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+396]
	mov	DWORD PTR _iLocalMove$[ebp], eax

; 1517 : 
; 1518 : 	if ( iLocalMove == LOCALMOVE_VALID )

	cmp	DWORD PTR _iLocalMove$[ebp], 2
	jne	SHORT $L40228

; 1520 : 		// monster can walk straight there!
; 1521 : 		return TRUE;

	mov	eax, 1
	jmp	$L40224
$L40228:

; 1523 : // try to triangulate around any obstacles.
; 1524 : 	else if ( iLocalMove != LOCALMOVE_INVALID_DONT_TRIANGULATE && FTriangulate( GetAbsOrigin(), vecGoal, flDist, pTarget, &vecApex ) )

	cmp	DWORD PTR _iLocalMove$[ebp], 1
	je	$L40230
	lea	ecx, DWORD PTR _vecApex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	mov	eax, DWORD PTR _flDist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecGoal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+496]
	test	eax, eax
	je	SHORT $L40230

; 1526 : 		// there is a slightly more complicated path that allows the monster to reach vecGoal
; 1527 : 		m_Route[ 0 ].vecLocation = vecApex;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2100				; 00000834H
	mov	edx, DWORD PTR _vecApex$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _vecApex$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _vecApex$[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 1528 : 		m_Route[ 0 ].iType = (iMoveFlag | bits_MF_TO_DETOUR);

	mov	eax, DWORD PTR _iMoveFlag$[ebp]
	or	al, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2112], eax

; 1529 : 
; 1530 : 		m_Route[ 1 ].vecLocation = vecGoal;

	mov	edx, DWORD PTR _vecGoal$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2116				; 00000844H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 1531 : 		m_Route[ 1 ].iType = iMoveFlag | bits_MF_IS_GOAL;

	mov	eax, DWORD PTR _iMoveFlag$[ebp]
	or	al, -128				; ffffff80H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2128], eax

; 1532 : 
; 1533 : 			/*
; 1534 : 			WRITE_BYTE(MSG_BROADCAST, SVC_TEMPENTITY);
; 1535 : 			WRITE_BYTE(MSG_BROADCAST, TE_SHOWLINE);
; 1536 : 			WRITE_COORD(MSG_BROADCAST, vecApex.x );
; 1537 : 			WRITE_COORD(MSG_BROADCAST, vecApex.y );
; 1538 : 			WRITE_COORD(MSG_BROADCAST, vecApex.z );
; 1539 : 			WRITE_COORD(MSG_BROADCAST, vecApex.x );
; 1540 : 			WRITE_COORD(MSG_BROADCAST, vecApex.y );
; 1541 : 			WRITE_COORD(MSG_BROADCAST, vecApex.z + 128 );
; 1542 : 			*/
; 1543 : 
; 1544 : 		RouteSimplify( pTarget );

	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z ; CBaseMonster::RouteSimplify

; 1545 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L40224
$L40230:

; 1547 : 
; 1548 : // last ditch, try nodes
; 1549 : 	if ( FGetNodeRoute( vecGoal ) )

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	eax, DWORD PTR _vecGoal$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FGetNodeRoute@CBaseMonster@@QAEHVVector@@@Z ; CBaseMonster::FGetNodeRoute
	test	eax, eax
	je	SHORT $L40232

; 1551 : //		ALERT ( at_console, "Can get there on nodes\n" );
; 1552 : 		m_vecMoveGoal = vecGoal;

	mov	ecx, DWORD PTR _vecGoal$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2240				; 000008c0H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 1553 : 		RouteSimplify( pTarget );

	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z ; CBaseMonster::RouteSimplify

; 1554 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L40224
$L40232:

; 1556 : 
; 1557 : 	// b0rk
; 1558 : 	return FALSE;

	xor	eax, eax
$L40224:

; 1559 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?BuildRoute@CBaseMonster@@QAEHABVVector@@HPAVCBaseEntity@@@Z ENDP ; CBaseMonster::BuildRoute
_TEXT	ENDS
PUBLIC	?InsertWaypoint@CBaseMonster@@QAEXVVector@@H@Z	; CBaseMonster::InsertWaypoint
;	COMDAT ?InsertWaypoint@CBaseMonster@@QAEXVVector@@H@Z
_TEXT	SEGMENT
_vecLocation$ = 8
_afMoveFlags$ = 20
_this$ = -4
_i$ = -8
_type$ = -12
?InsertWaypoint@CBaseMonster@@QAEXVVector@@H@Z PROC NEAR ; CBaseMonster::InsertWaypoint, COMDAT

; 1569 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1570 : 	int			i, type;
; 1571 : 
; 1572 : 	
; 1573 : 	// we have to save some Index and Type information from the real
; 1574 : 	// path_corner or node waypoint that the monster was trying to reach. This makes sure that data necessary 
; 1575 : 	// to refresh the original path exists even in the new waypoints that don't correspond directy to a path_corner
; 1576 : 	// or node. 
; 1577 : 	type = afMoveFlags | (m_Route[ m_iRouteIndex ].iType & ~bits_MF_NOT_TO_MASK);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2232]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+2112]
	and	eax, -385				; fffffe7fH
	mov	ecx, DWORD PTR _afMoveFlags$[ebp]
	or	ecx, eax
	mov	DWORD PTR _type$[ebp], ecx

; 1578 : 
; 1579 : 	for ( i = ROUTE_SIZE-1; i > 0; i-- )

	mov	DWORD PTR _i$[ebp], 7
	jmp	SHORT $L40240
$L40241:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L40240:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $L40242

; 1580 : 		m_Route[i] = m_Route[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2100]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+2100]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $L40241
$L40242:

; 1581 : 
; 1582 : 	m_Route[ m_iRouteIndex ].vecLocation = vecLocation;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2232]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+2100]
	mov	ecx, DWORD PTR _vecLocation$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecLocation$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecLocation$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 1583 : 	m_Route[ m_iRouteIndex ].iType = type;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2232]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [ecx+eax+2112], edx

; 1584 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?InsertWaypoint@CBaseMonster@@QAEXVVector@@H@Z ENDP	; CBaseMonster::InsertWaypoint
_TEXT	ENDS
PUBLIC	__real@8@4003c000000000000000
PUBLIC	__real@8@4004c000000000000000
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	__real@4@4000c000000000000000
PUBLIC	?CrossProduct@@YA?AVVector@@ABV1@0@Z		; CrossProduct
PUBLIC	?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z ; CBaseMonster::FTriangulate
;	COMDAT __real@8@4003c000000000000000
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
__real@8@4003c000000000000000 DQ 04038000000000000r ; 24
CONST	ENDS
;	COMDAT __real@8@4004c000000000000000
CONST	SEGMENT
__real@8@4004c000000000000000 DQ 04048000000000000r ; 48
CONST	ENDS
;	COMDAT __real@4@4000c000000000000000
CONST	SEGMENT
__real@4@4000c000000000000000 DD 040400000r	; 3
CONST	ENDS
;	COMDAT ?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
_TEXT	SEGMENT
$T42137 = -136
$T42138 = -148
$T42139 = -160
$T42140 = -172
$T42141 = -184
$T42142 = -196
$T42143 = -208
$T42144 = -220
$T42145 = -232
$T42146 = -244
$T42147 = -256
$T42148 = -268
$T42149 = -280
$T42150 = -292
$T42151 = -304
$T42152 = -316
$T42153 = -328
$T42154 = -340
$T42155 = -352
$T42156 = -364
$T42157 = -376
$T42158 = -388
$T42159 = -400
$T42160 = -412
$T42161 = -424
$T42162 = -436
$T42163 = -448
$T42164 = -460
$T42165 = -472
_vecStart$ = 8
_vecEnd$ = 12
_flDist$ = 16
_pTargetEnt$ = 20
_pApex$ = 24
_this$ = -4
_vecDir$ = -16
_vecForward$ = -28
_vecLeft$ = -40
_vecRight$ = -52
_vecTop$ = -64
_vecBottom$ = -76
_vecFarSide$ = -88
_i$ = -92
_sizeX$ = -96
_sizeZ$ = -100
_vecDirUp$ = -112
_vecOrigin$40295 = -124
?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z PROC NEAR ; CBaseMonster::FTriangulate, COMDAT

; 1594 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 536				; 00000218H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1595 : 	Vector		vecDir;

	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1596 : 	Vector		vecForward;

	lea	ecx, DWORD PTR _vecForward$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1597 : 	Vector		vecLeft;// the spot we'll try to triangulate to on the left

	lea	ecx, DWORD PTR _vecLeft$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1598 : 	Vector		vecRight;// the spot we'll try to triangulate to on the right

	lea	ecx, DWORD PTR _vecRight$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1599 : 	Vector		vecTop;// the spot we'll try to triangulate to on the top

	lea	ecx, DWORD PTR _vecTop$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1600 : 	Vector		vecBottom;// the spot we'll try to triangulate to on the bottom

	lea	ecx, DWORD PTR _vecBottom$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1601 : 	Vector		vecFarSide;// the spot that we'll move to after hitting the triangulated point, before moving on to our normal goal.

	lea	ecx, DWORD PTR _vecFarSide$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1602 : 	int			i;
; 1603 : 	float		sizeX, sizeZ;
; 1604 : 
; 1605 : 	// If the hull width is less than 24, use 24 because CheckLocalMove uses a min of
; 1606 : 	// 24.
; 1607 : 	sizeX = pev->size.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+244]
	mov	DWORD PTR _sizeX$[ebp], edx

; 1608 : 	if (sizeX < 24.0)

	fld	DWORD PTR _sizeX$[ebp]
	fcomp	QWORD PTR __real@8@4003c000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40261

; 1609 : 		sizeX = 24.0;

	mov	DWORD PTR _sizeX$[ebp], 1103101952	; 41c00000H

; 1610 : 	else if (sizeX > 48.0)

	jmp	SHORT $L40263
$L40261:
	fld	DWORD PTR _sizeX$[ebp]
	fcomp	QWORD PTR __real@8@4004c000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40263

; 1611 : 		sizeX = 48.0;

	mov	DWORD PTR _sizeX$[ebp], 1111490560	; 42400000H
$L40263:

; 1612 : 	sizeZ = pev->size.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+252]
	mov	DWORD PTR _sizeZ$[ebp], edx

; 1613 : 	//if (sizeZ < 24.0)
; 1614 : 	//	sizeZ = 24.0;
; 1615 : 
; 1616 : 	vecForward = ( vecEnd - vecStart ).Normalize();

	lea	eax, DWORD PTR $T42138[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecStart$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T42137[ebp]
	push	edx
	mov	ecx, DWORD PTR _vecEnd$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecForward$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecForward$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecForward$[ebp+8], eax

; 1617 : 
; 1618 : 	Vector vecDirUp(0,0,1);

	push	1065353216				; 3f800000H
	push	0
	push	0
	lea	ecx, DWORD PTR _vecDirUp$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 1619 : 	vecDir = CrossProduct ( vecForward, vecDirUp);

	lea	ecx, DWORD PTR _vecDirUp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecForward$[ebp]
	push	edx
	lea	eax, DWORD PTR $T42139[ebp]
	push	eax
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecDir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecDir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecDir$[ebp+8], eax

; 1620 : 
; 1621 : 	// start checking right about where the object is, picking two equidistant starting points, one on
; 1622 : 	// the left, one on the right. As we progress through the loop, we'll push these away from the obstacle, 
; 1623 : 	// hoping to find a way around on either side. pev->size.x is added to the ApexDist in order to help select
; 1624 : 	// an apex point that insures that the monster is sufficiently past the obstacle before trying to turn back
; 1625 : 	// onto its original course.
; 1626 : 
; 1627 : 	vecLeft = GetAbsOrigin() + ( vecForward * ( flDist + sizeX ) ) - vecDir * ( sizeX * 3 );

	fld	DWORD PTR _sizeX$[ebp]
	fmul	DWORD PTR __real@4@4000c000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T42142[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T42143[ebp]
	push	edx
	fld	DWORD PTR _flDist$[ebp]
	fadd	DWORD PTR _sizeX$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T42140[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecForward$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T42141[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecLeft$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecLeft$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecLeft$[ebp+8], edx

; 1628 : 	vecRight = GetAbsOrigin() + ( vecForward * ( flDist + sizeX ) ) + vecDir * ( sizeX * 3 );

	fld	DWORD PTR _sizeX$[ebp]
	fmul	DWORD PTR __real@4@4000c000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T42146[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T42147[ebp]
	push	ecx
	fld	DWORD PTR _flDist$[ebp]
	fadd	DWORD PTR _sizeX$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR $T42144[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecForward$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T42145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecRight$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecRight$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecRight$[ebp+8], eax

; 1629 : 	if (pev->movetype == MOVETYPE_FLY)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 5
	jne	$L40276

; 1631 : 		vecTop = GetAbsOrigin() + (vecForward * flDist) + (vecDirUp * sizeZ * 3);

	push	1077936128				; 40400000H
	lea	eax, DWORD PTR $T42151[ebp]
	push	eax
	mov	ecx, DWORD PTR _sizeZ$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T42150[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecDirUp$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T42152[ebp]
	push	eax
	mov	ecx, DWORD PTR _flDist$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T42148[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecForward$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T42149[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecTop$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecTop$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecTop$[ebp+8], eax

; 1632 : 		vecBottom = GetAbsOrigin() + (vecForward * flDist) - (vecDirUp *  sizeZ * 3);

	push	1077936128				; 40400000H
	lea	ecx, DWORD PTR $T42156[ebp]
	push	ecx
	mov	edx, DWORD PTR _sizeZ$[ebp]
	push	edx
	lea	eax, DWORD PTR $T42155[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecDirUp$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T42157[ebp]
	push	ecx
	mov	edx, DWORD PTR _flDist$[ebp]
	push	edx
	lea	eax, DWORD PTR $T42153[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecForward$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T42154[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecBottom$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecBottom$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecBottom$[ebp+8], edx
$L40276:

; 1634 : 
; 1635 : 	vecFarSide = m_Route[ m_iRouteIndex ].vecLocation;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2232]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+2100]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecFarSide$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecFarSide$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecFarSide$[ebp+8], eax

; 1636 : 	
; 1637 : 	vecDir = vecDir * sizeX * 2;

	push	1073741824				; 40000000H
	lea	ecx, DWORD PTR $T42159[ebp]
	push	ecx
	mov	edx, DWORD PTR _sizeX$[ebp]
	push	edx
	lea	eax, DWORD PTR $T42158[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecDir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecDir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecDir$[ebp+8], eax

; 1638 : 	if (pev->movetype == MOVETYPE_FLY)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 5
	jne	SHORT $L40289

; 1639 : 		vecDirUp = vecDirUp * sizeZ * 2;

	push	1073741824				; 40000000H
	lea	eax, DWORD PTR $T42161[ebp]
	push	eax
	mov	ecx, DWORD PTR _sizeZ$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T42160[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecDirUp$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecDirUp$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecDirUp$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecDirUp$[ebp+8], eax
$L40289:

; 1640 : 
; 1641 : 	for ( i = 0 ; i < 8; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40292
$L40293:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L40292:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$L40294

; 1643 : 		Vector vecOrigin = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecOrigin$40295[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1644 : // Debug, Draw the triangulation
; 1645 : #if 0
; 1646 : 		MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );
; 1647 : 			WRITE_BYTE( TE_SHOWLINE);
; 1648 : 			WRITE_COORD( vecOrigin.x );
; 1649 : 			WRITE_COORD( vecOrigin.y );
; 1650 : 			WRITE_COORD( vecOrigin.z );
; 1651 : 			WRITE_COORD( vecRight.x );
; 1652 : 			WRITE_COORD( vecRight.y );
; 1653 : 			WRITE_COORD( vecRight.z );
; 1654 : 		MESSAGE_END();
; 1655 : 
; 1656 : 		MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );
; 1657 : 			WRITE_BYTE( TE_SHOWLINE );
; 1658 : 			WRITE_COORD( vecOrigin.x );
; 1659 : 			WRITE_COORD( vecOrigin.y );
; 1660 : 			WRITE_COORD( vecOrigin.z );
; 1661 : 			WRITE_COORD( vecLeft.x );
; 1662 : 			WRITE_COORD( vecLeft.y );
; 1663 : 			WRITE_COORD( vecLeft.z );
; 1664 : 		MESSAGE_END();
; 1665 : #endif
; 1666 : 
; 1667 : #if 0
; 1668 : 		if (pev->movetype == MOVETYPE_FLY)
; 1669 : 		{
; 1670 : 			MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );
; 1671 : 				WRITE_BYTE( TE_SHOWLINE );
; 1672 : 				WRITE_COORD( vecOrigin.x );
; 1673 : 				WRITE_COORD( vecOrigin.y );
; 1674 : 				WRITE_COORD( vecOrigin.z );
; 1675 : 				WRITE_COORD( vecTop.x );
; 1676 : 				WRITE_COORD( vecTop.y );
; 1677 : 				WRITE_COORD( vecTop.z );
; 1678 : 			MESSAGE_END();
; 1679 : 
; 1680 : 			MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );
; 1681 : 				WRITE_BYTE( TE_SHOWLINE );
; 1682 : 				WRITE_COORD( vecOrigin.x );
; 1683 : 				WRITE_COORD( vecOrigin.y );
; 1684 : 				WRITE_COORD( vecOrigin.z );
; 1685 : 				WRITE_COORD( vecBottom.x );
; 1686 : 				WRITE_COORD( vecBottom.y );
; 1687 : 				WRITE_COORD( vecBottom.z );
; 1688 : 			MESSAGE_END();
; 1689 : 		}
; 1690 : #endif
; 1691 : 
; 1692 : 		if ( CheckLocalMove( vecOrigin, vecRight, pTargetEnt, NULL ) == LOCALMOVE_VALID )

	push	0
	mov	edx, DWORD PTR _pTargetEnt$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecRight$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecOrigin$40295[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+396]
	cmp	eax, 2
	jne	SHORT $L40297

; 1694 : 			if ( CheckLocalMove ( vecRight, vecFarSide, pTargetEnt, NULL ) == LOCALMOVE_VALID )

	push	0
	mov	ecx, DWORD PTR _pTargetEnt$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecFarSide$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecRight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+396]
	cmp	eax, 2
	jne	SHORT $L40297

; 1696 : 				if ( pApex )

	cmp	DWORD PTR _pApex$[ebp], 0
	je	SHORT $L40298

; 1698 : 					*pApex = vecRight;

	mov	eax, DWORD PTR _pApex$[ebp]
	mov	ecx, DWORD PTR _vecRight$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecRight$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecRight$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
$L40298:

; 1700 : 
; 1701 : 				return TRUE;

	mov	eax, 1
	jmp	$L40250
$L40297:

; 1704 : 		if ( CheckLocalMove( vecOrigin, vecLeft, pTargetEnt, NULL ) == LOCALMOVE_VALID )

	push	0
	mov	edx, DWORD PTR _pTargetEnt$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecLeft$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecOrigin$40295[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+396]
	cmp	eax, 2
	jne	SHORT $L40300

; 1706 : 			if ( CheckLocalMove ( vecLeft, vecFarSide, pTargetEnt, NULL ) == LOCALMOVE_VALID )

	push	0
	mov	ecx, DWORD PTR _pTargetEnt$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecFarSide$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecLeft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+396]
	cmp	eax, 2
	jne	SHORT $L40300

; 1708 : 				if ( pApex )

	cmp	DWORD PTR _pApex$[ebp], 0
	je	SHORT $L40301

; 1710 : 					*pApex = vecLeft;

	mov	eax, DWORD PTR _pApex$[ebp]
	mov	ecx, DWORD PTR _vecLeft$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecLeft$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecLeft$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
$L40301:

; 1712 : 
; 1713 : 				return TRUE;

	mov	eax, 1
	jmp	$L40250
$L40300:

; 1716 : 
; 1717 : 		if (pev->movetype == MOVETYPE_FLY)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+264], 5
	jne	$L40307

; 1719 : 			if ( CheckLocalMove( vecOrigin, vecTop, pTargetEnt, NULL ) == LOCALMOVE_VALID)

	push	0
	mov	ecx, DWORD PTR _pTargetEnt$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecTop$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecOrigin$40295[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+396]
	cmp	eax, 2
	jne	SHORT $L40304

; 1721 : 				if ( CheckLocalMove ( vecTop, vecFarSide, pTargetEnt, NULL ) == LOCALMOVE_VALID )

	push	0
	mov	eax, DWORD PTR _pTargetEnt$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecFarSide$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecTop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+396]
	cmp	eax, 2
	jne	SHORT $L40304

; 1723 : 					if ( pApex )

	cmp	DWORD PTR _pApex$[ebp], 0
	je	SHORT $L40305

; 1725 : 						*pApex = vecTop;

	mov	eax, DWORD PTR _pApex$[ebp]
	mov	ecx, DWORD PTR _vecTop$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecTop$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecTop$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
$L40305:

; 1728 : 
; 1729 : 					return TRUE;

	mov	eax, 1
	jmp	$L40250
$L40304:

; 1732 : #if 1
; 1733 : 			if ( CheckLocalMove( vecOrigin, vecBottom, pTargetEnt, NULL ) == LOCALMOVE_VALID )

	push	0
	mov	edx, DWORD PTR _pTargetEnt$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecBottom$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecOrigin$40295[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+396]
	cmp	eax, 2
	jne	SHORT $L40307

; 1735 : 				if ( CheckLocalMove ( vecBottom, vecFarSide, pTargetEnt, NULL ) == LOCALMOVE_VALID )

	push	0
	mov	ecx, DWORD PTR _pTargetEnt$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecFarSide$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecBottom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+396]
	cmp	eax, 2
	jne	SHORT $L40307

; 1737 : 					if ( pApex )

	cmp	DWORD PTR _pApex$[ebp], 0
	je	SHORT $L40308

; 1739 : 						*pApex = vecBottom;

	mov	eax, DWORD PTR _pApex$[ebp]
	mov	ecx, DWORD PTR _vecBottom$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecBottom$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecBottom$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
$L40308:

; 1742 : 
; 1743 : 					return TRUE;

	mov	eax, 1
	jmp	$L40250
$L40307:

; 1748 : 
; 1749 : 		vecRight = vecRight + vecDir;

	lea	edx, DWORD PTR _vecDir$[ebp]
	push	edx
	lea	eax, DWORD PTR $T42162[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecRight$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecRight$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecRight$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecRight$[ebp+8], eax

; 1750 : 		vecLeft = vecLeft - vecDir;

	lea	ecx, DWORD PTR _vecDir$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T42163[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecLeft$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecLeft$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecLeft$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecLeft$[ebp+8], eax

; 1751 : 		if (pev->movetype == MOVETYPE_FLY)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 5
	jne	SHORT $L40311

; 1753 : 			vecTop = vecTop + vecDirUp;

	lea	eax, DWORD PTR _vecDirUp$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T42164[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecTop$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecTop$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecTop$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecTop$[ebp+8], edx

; 1754 : 			vecBottom = vecBottom - vecDirUp;

	lea	eax, DWORD PTR _vecDirUp$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T42165[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecBottom$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecBottom$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecBottom$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecBottom$[ebp+8], edx
$L40311:

; 1756 : 	}

	jmp	$L40293
$L40294:

; 1757 : 
; 1758 : 	return FALSE;

	xor	eax, eax
$L40250:

; 1759 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z ENDP ; CBaseMonster::FTriangulate
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
$T42174 = -20
___$ReturnUdt$ = 8
_this$ = -4
_flLen$ = -8
?Normalize@Vector@@QBE?AV1@XZ PROC NEAR			; Vector::Normalize, COMDAT

; 232  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 234  : 
; 235  : 		if( flLen )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L24894

; 237  : 			flLen = 1.0f / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 238  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T42174[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L24892
$L24894:

; 240  : 
; 241  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L24892:

; 242  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
;	COMDAT ?CrossProduct@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT
$T42177 = -12
_a$ = 12
_b$ = 16
___$ReturnUdt$ = 8
?CrossProduct@@YA?AVVector@@ABV1@0@Z PROC NEAR		; CrossProduct, COMDAT

; 291  : inline Vector CrossProduct( const Vector& a, const Vector& b ) { return Vector( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+4]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T42177[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CrossProduct@@YA?AVVector@@ABV1@0@Z ENDP		; CrossProduct
_TEXT	ENDS
PUBLIC	?Remember@CBaseMonster@@QAEXH@Z			; CBaseMonster::Remember
PUBLIC	?HasMemory@CBaseMonster@@QAEHH@Z		; CBaseMonster::HasMemory
PUBLIC	__real@4@4006c800000000000000
PUBLIC	__real@8@4000c000000000000000
PUBLIC	??_C@_0BO@PKJM@Tried?5to?5move?5with?5no?5route?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@DBAJ@?$CFs?5Failed?5to?5move?5?$CI?$CFd?$CJ?$CB?6?$AA@ ; `string'
PUBLIC	?Move@CBaseMonster@@UAEXM@Z			; CBaseMonster::Move
PUBLIC	?TaskFail@CBaseMonster@@QAEXXZ			; CBaseMonster::TaskFail
PUBLIC	?MakeIdealYaw@CBaseMonster@@QAEXVVector@@@Z	; CBaseMonster::MakeIdealYaw
EXTRN	__ftol:NEAR
EXTRN	?DispatchBlocked@@YAXPAUedict_s@@0@Z:NEAR	; DispatchBlocked
;	COMDAT ??_C@_0BO@PKJM@Tried?5to?5move?5with?5no?5route?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BO@PKJM@Tried?5to?5move?5with?5no?5route?$CB?6?$AA@ DB 'Tried to m'
	DB	'ove with no route!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DBAJ@?$CFs?5Failed?5to?5move?5?$CI?$CFd?$CJ?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BJ@DBAJ@?$CFs?5Failed?5to?5move?5?$CI?$CFd?$CJ?$CB?6?$AA@ DB '%s F'
	DB	'ailed to move (%d)!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@4@4006c800000000000000
CONST	SEGMENT
__real@4@4006c800000000000000 DD 043480000r	; 200
CONST	ENDS
;	COMDAT __real@8@4000c000000000000000
CONST	SEGMENT
__real@8@4000c000000000000000 DQ 04008000000000000r ; 3
CONST	ENDS
;	COMDAT ?Move@CBaseMonster@@UAEXM@Z
_TEXT	SEGMENT
$T42180 = -60
$T42181 = -72
$T42182 = -84
$T42184 = -100
$T42185 = -112
_flInterval$ = 8
_this$ = -4
_flWaypointDist$ = -8
_flCheckDist$ = -12
_flDist$ = -16
_vecDir$ = -28
_vecApex$ = -40
_pTargetEnt$ = -44
_pBlocker$40342 = -48
?Move@CBaseMonster@@UAEXM@Z PROC NEAR			; CBaseMonster::Move, COMDAT

; 1767 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1768 : 	float		flWaypointDist;
; 1769 : 	float		flCheckDist;
; 1770 : 	float		flDist;// how far the lookahead check got before hitting an object.
; 1771 : 	Vector		vecDir;

	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1772 : 	Vector		vecApex;

	lea	ecx, DWORD PTR _vecApex$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1773 : 	CBaseEntity	*pTargetEnt;
; 1774 : 
; 1775 : 	// Don't move if no valid route
; 1776 : 	if ( FRouteClear() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FRouteClear@CBaseMonster@@QAEHXZ	; CBaseMonster::FRouteClear
	test	eax, eax
	je	SHORT $L40326

; 1778 : 		// If we still have a movement goal, then this is probably a route truncated by SimplifyRoute()
; 1779 : 		// so refresh it.
; 1780 : 		if ( m_movementGoal == MOVEGOAL_NONE || !FRefreshRoute() )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2228], 0
	je	SHORT $L40327
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FRefreshRoute@CBaseMonster@@QAEHXZ	; CBaseMonster::FRefreshRoute
	test	eax, eax
	jne	SHORT $L40326
$L40327:

; 1782 : 			ALERT( at_aiconsole, "Tried to move with no route!\n" );

	push	OFFSET FLAT:??_C@_0BO@PKJM@Tried?5to?5move?5with?5no?5route?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1783 : 			TaskFail();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskFail@CBaseMonster@@QAEXXZ		; CBaseMonster::TaskFail

; 1784 : 			return;

	jmp	$L40318
$L40326:

; 1787 : 	
; 1788 : 	if ( m_flMoveWaitFinished > gpGlobals->time )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+2064]
	fcomp	DWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40329

; 1789 : 		return;

	jmp	$L40318
$L40329:

; 1790 : 
; 1791 : // Debug, test movement code
; 1792 : #if 0
; 1793 : //	if ( CVAR_GET_FLOAT("stopmove" ) != 0 )
; 1794 : 	{
; 1795 : 		if ( m_movementGoal == MOVEGOAL_ENEMY )
; 1796 : 			RouteSimplify( m_hEnemy );
; 1797 : 		else
; 1798 : 			RouteSimplify( m_hTargetEnt );
; 1799 : 		FRefreshRoute();
; 1800 : 		return;
; 1801 : 	}
; 1802 : #else
; 1803 : // Debug, draw the route
; 1804 : //	DrawRoute( pev, m_Route, m_iRouteIndex, 0, 200, 0 );
; 1805 : #endif
; 1806 : 
; 1807 : 	// if the monster is moving directly towards an entity (enemy for instance), we'll set this pointer
; 1808 : 	// to that entity for the CheckLocalMove and Triangulate functions.
; 1809 : 	pTargetEnt = NULL;

	mov	DWORD PTR _pTargetEnt$[ebp], 0

; 1810 : 
; 1811 : 	// local move to waypoint.
; 1812 : 	vecDir = ( m_Route[ m_iRouteIndex ].vecLocation - GetAbsOrigin() ).Normalize();

	lea	eax, DWORD PTR $T42181[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T42180[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2232]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+2100]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecDir$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecDir$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecDir$[ebp+8], edx

; 1813 : 	flWaypointDist = ( m_Route[ m_iRouteIndex ].vecLocation - GetAbsOrigin() ).Length2D();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T42182[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2232]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2100]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length2D@Vector@@QBEMXZ		; Vector::Length2D
	fstp	DWORD PTR _flWaypointDist$[ebp]

; 1814 : 	
; 1815 : 	MakeIdealYaw ( m_Route[ m_iRouteIndex ].vecLocation );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2232]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2100]
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	push	ecx
	mov	ecx, edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeIdealYaw@CBaseMonster@@QAEXVVector@@@Z ; CBaseMonster::MakeIdealYaw

; 1816 : 	ChangeYaw ( pev->yaw_speed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+176]
	call	__ftol
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+356]
	fstp	ST(0)

; 1817 : 
; 1818 : 	// if the waypoint is closer than CheckDist, CheckDist is the dist to waypoint
; 1819 : 	if ( flWaypointDist < DIST_TO_CHECK )

	fld	DWORD PTR _flWaypointDist$[ebp]
	fcomp	DWORD PTR __real@4@4006c800000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40334

; 1821 : 		flCheckDist = flWaypointDist;

	mov	ecx, DWORD PTR _flWaypointDist$[ebp]
	mov	DWORD PTR _flCheckDist$[ebp], ecx

; 1823 : 	else

	jmp	SHORT $L40335
$L40334:

; 1825 : 		flCheckDist = DIST_TO_CHECK;

	mov	DWORD PTR _flCheckDist$[ebp], 1128792064 ; 43480000H
$L40335:

; 1827 : 	
; 1828 : 	if ( (m_Route[ m_iRouteIndex ].iType & (~bits_MF_NOT_TO_MASK)) == bits_MF_TO_ENEMY )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2232]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+2112]
	and	edx, -385				; fffffe7fH
	cmp	edx, 2
	jne	SHORT $L40336

; 1830 : 		// only on a PURE move to enemy ( i.e., ONLY MF_TO_ENEMY set, not MF_TO_ENEMY and DETOUR )
; 1831 : 		pTargetEnt = m_hEnemy;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pTargetEnt$[ebp], eax

; 1833 : 	else if ( (m_Route[ m_iRouteIndex ].iType & ~bits_MF_NOT_TO_MASK) == bits_MF_TO_TARGETENT )

	jmp	SHORT $L40338
$L40336:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2232]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+2112]
	and	eax, -385				; fffffe7fH
	cmp	eax, 1
	jne	SHORT $L40338

; 1835 : 		pTargetEnt = m_hTargetEnt;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pTargetEnt$[ebp], eax
$L40338:

; 1837 : 
; 1838 : 	// !!!BUGBUG - CheckDist should be derived from ground speed.
; 1839 : 	// If this fails, it should be because of some dynamic entity blocking this guy.
; 1840 : 	// We've already checked this path, so we should wait and time out if the entity doesn't move
; 1841 : 	flDist = 0;

	mov	DWORD PTR _flDist$[ebp], 0

; 1842 : 	if ( CheckLocalMove ( GetAbsOrigin(), GetAbsOrigin() + vecDir * flCheckDist, pTargetEnt, &flDist ) != LOCALMOVE_VALID )

	lea	ecx, DWORD PTR _flDist$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTargetEnt$[ebp]
	push	edx
	mov	eax, DWORD PTR _flCheckDist$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T42184[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T42185[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+396]
	cmp	eax, 2
	je	$L40349

; 1844 : 		CBaseEntity *pBlocker;
; 1845 : 
; 1846 : 		// Can't move, stop
; 1847 : 		Stop();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+416]

; 1848 : 		// Blocking entity is in global trace_ent
; 1849 : 		pBlocker = CBaseEntity::Instance( gpGlobals->trace_ent );

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+116]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pBlocker$40342[ebp], eax

; 1850 : 		if (pBlocker)

	cmp	DWORD PTR _pBlocker$40342[ebp], 0
	je	SHORT $L40343

; 1852 : 			DispatchBlocked( edict(), pBlocker->edict() );

	mov	ecx, DWORD PTR _pBlocker$40342[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?DispatchBlocked@@YAXPAUedict_s@@0@Z	; DispatchBlocked
	add	esp, 8
$L40343:

; 1854 : 
; 1855 : 		if ( pBlocker && m_moveWaitTime > 0 && pBlocker->IsMoving() && !pBlocker->IsPlayer() && (gpGlobals->time-m_flMoveWaitFinished) > 3.0 )

	cmp	DWORD PTR _pBlocker$40342[ebp], 0
	je	$L40344
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+2236]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40344
	mov	eax, DWORD PTR _pBlocker$40342[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pBlocker$40342[ebp]
	call	DWORD PTR [edx+164]
	test	eax, eax
	je	SHORT $L40344
	mov	eax, DWORD PTR _pBlocker$40342[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pBlocker$40342[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L40344
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx+2064]
	fcomp	QWORD PTR __real@8@4000c000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40344

; 1857 : 			// Can we still move toward our target?
; 1858 : 			if ( flDist < m_flGroundSpeed )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR [edx+1796]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40345

; 1860 : 				// No, Wait for a second
; 1861 : 				m_flMoveWaitFinished = gpGlobals->time + m_moveWaitTime;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx+2236]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+2064]

; 1862 : 				return;

	jmp	$L40318
$L40345:

; 1866 : 		else 

	jmp	$L40349
$L40344:

; 1868 : 			// try to triangulate around whatever is in the way.
; 1869 : 			if ( FTriangulate( GetAbsOrigin(), m_Route[ m_iRouteIndex ].vecLocation, flDist, pTargetEnt, &vecApex ) )

	lea	eax, DWORD PTR _vecApex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTargetEnt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flDist$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2232]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+2100]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+496]
	test	eax, eax
	je	SHORT $L40347

; 1871 : 				InsertWaypoint( vecApex, bits_MF_TO_DETOUR );

	push	8
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecApex$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertWaypoint@CBaseMonster@@QAEXVVector@@H@Z ; CBaseMonster::InsertWaypoint

; 1872 : 				RouteSimplify( pTargetEnt );

	mov	ecx, DWORD PTR _pTargetEnt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RouteSimplify@CBaseMonster@@QAEXPAVCBaseEntity@@@Z ; CBaseMonster::RouteSimplify

; 1874 : 			else

	jmp	$L40349
$L40347:

; 1876 : //				ALERT ( at_aiconsole, "Couldn't Triangulate\n" );
; 1877 : 				Stop();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+416]

; 1878 : 				// Only do this once until your route is cleared
; 1879 : 				if ( m_moveWaitTime > 0 && !(m_afMemory & bits_MEMORY_MOVE_FAILED) )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+2236]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40350
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2280]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $L40350

; 1881 : 					FRefreshRoute();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FRefreshRoute@CBaseMonster@@QAEHXZ	; CBaseMonster::FRefreshRoute

; 1882 : 					if ( FRouteClear() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FRouteClear@CBaseMonster@@QAEHXZ	; CBaseMonster::FRouteClear
	test	eax, eax
	je	SHORT $L40351

; 1884 : 						TaskFail();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskFail@CBaseMonster@@QAEXXZ		; CBaseMonster::TaskFail

; 1886 : 					else

	jmp	SHORT $L40352
$L40351:

; 1888 : 						// Don't get stuck
; 1889 : 						if ( (gpGlobals->time - m_flMoveWaitFinished) < 0.2 )

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx+2064]
	fcomp	QWORD PTR __real@8@3ffcccccccccccccd000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40353

; 1890 : 							Remember( bits_MEMORY_MOVE_FAILED );

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Remember@CBaseMonster@@QAEXH@Z		; CBaseMonster::Remember
$L40353:

; 1891 : 
; 1892 : 						m_flMoveWaitFinished = gpGlobals->time + 0.1;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2064]
$L40352:

; 1895 : 				else

	jmp	SHORT $L40354
$L40350:

; 1897 : 					TaskFail();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskFail@CBaseMonster@@QAEXXZ		; CBaseMonster::TaskFail

; 1898 : 					ALERT( at_aiconsole, "%s Failed to move (%d)!\n", STRING(pev->classname), HasMemory( bits_MEMORY_MOVE_FAILED ) );

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasMemory@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasMemory
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BJ@DBAJ@?$CFs?5Failed?5to?5move?5?$CI?$CFd?$CJ?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H
$L40354:

; 1901 : 				return;

	jmp	$L40318
$L40349:

; 1905 : 
; 1906 : 	// close enough to the target, now advance to the next target. This is done before actually reaching
; 1907 : 	// the target so that we get a nice natural turn while moving.
; 1908 : 	if ( ShouldAdvanceRoute( flWaypointDist ) )///!!!BUGBUG- magic number

	mov	edx, DWORD PTR _flWaypointDist$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+408]
	test	eax, eax
	je	SHORT $L40356

; 1910 : 		AdvanceRoute( flWaypointDist );

	mov	eax, DWORD PTR _flWaypointDist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AdvanceRoute@CBaseMonster@@QAEXM@Z	; CBaseMonster::AdvanceRoute
$L40356:

; 1912 : 
; 1913 : 	// Might be waiting for a door
; 1914 : 	if ( m_flMoveWaitFinished > gpGlobals->time )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+2064]
	fcomp	DWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40357

; 1916 : 		Stop();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+416]

; 1917 : 		return;

	jmp	SHORT $L40318
$L40357:

; 1919 : 
; 1920 : 	// UNDONE: this is a hack to quit moving farther than it has looked ahead.
; 1921 : 	if (flCheckDist < m_flGroundSpeed * flInterval)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flInterval$[ebp]
	fmul	DWORD PTR [eax+1796]
	fcomp	DWORD PTR _flCheckDist$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40358

; 1923 : 		flInterval = flCheckDist / m_flGroundSpeed;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flCheckDist$[ebp]
	fdiv	DWORD PTR [ecx+1796]
	fstp	DWORD PTR _flInterval$[ebp]
$L40358:

; 1926 : 	MoveExecute( pTargetEnt, vecDir, flInterval );

	mov	edx, DWORD PTR _flInterval$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecDir$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTargetEnt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+404]

; 1927 : 
; 1928 : 	if ( MovementIsComplete() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MovementIsComplete@CBaseMonster@@QAEHXZ ; CBaseMonster::MovementIsComplete
	test	eax, eax
	je	SHORT $L40359

; 1930 : 		Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+416]

; 1931 : 		RouteClear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RouteClear@CBaseMonster@@QAEXXZ	; CBaseMonster::RouteClear
$L40359:
$L40318:

; 1933 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Move@CBaseMonster@@UAEXM@Z ENDP			; CBaseMonster::Move
_TEXT	ENDS
;	COMDAT ?TaskFail@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TaskFail@CBaseMonster@@QAEXXZ PROC NEAR		; CBaseMonster::TaskFail, COMDAT

; 228  : 		inline void TaskFail( void ) { SetConditions(bits_COND_TASK_FAILED); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1073741824				; 40000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TaskFail@CBaseMonster@@QAEXXZ ENDP			; CBaseMonster::TaskFail
_TEXT	ENDS
;	COMDAT ?Remember@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_iMemory$ = 8
_this$ = -4
?Remember@CBaseMonster@@QAEXH@Z PROC NEAR		; CBaseMonster::Remember, COMDAT

; 342  : 	inline void	Remember( int iMemory ) { m_afMemory |= iMemory; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2280]
	or	ecx, DWORD PTR _iMemory$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2280], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Remember@CBaseMonster@@QAEXH@Z ENDP			; CBaseMonster::Remember
_TEXT	ENDS
;	COMDAT ?HasMemory@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT
_iMemory$ = 8
_this$ = -4
?HasMemory@CBaseMonster@@QAEHH@Z PROC NEAR		; CBaseMonster::HasMemory, COMDAT

; 344  : 	inline BOOL HasMemory( int iMemory ) { if ( m_afMemory & iMemory ) return TRUE; return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2280]
	and	ecx, DWORD PTR _iMemory$[ebp]
	test	ecx, ecx
	je	SHORT $L36153
	mov	eax, 1
	jmp	SHORT $L36152
$L36153:
	xor	eax, eax
$L36152:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasMemory@CBaseMonster@@QAEHH@Z ENDP			; CBaseMonster::HasMemory
_TEXT	ENDS
PUBLIC	__real@4@40028000000000000000
PUBLIC	?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z	; CBaseMonster::ShouldAdvanceRoute
;	COMDAT __real@4@40028000000000000000
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
__real@4@40028000000000000000 DD 041000000r	; 8
CONST	ENDS
;	COMDAT ?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
_TEXT	SEGMENT
_flWaypointDist$ = 8
_this$ = -4
?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z PROC NEAR	; CBaseMonster::ShouldAdvanceRoute, COMDAT

; 1937 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1938 : 	if ( flWaypointDist <= MONSTER_CUT_CORNER_DIST )

	fld	DWORD PTR _flWaypointDist$[ebp]
	fcomp	DWORD PTR __real@4@40028000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40364

; 1940 : 		// ALERT( at_console, "cut %f\n", flWaypointDist );
; 1941 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L40363
$L40364:

; 1943 : 
; 1944 : 	return FALSE;

	xor	eax, eax
$L40363:

; 1945 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z ENDP		; CBaseMonster::ShouldAdvanceRoute
_TEXT	ENDS
PUBLIC	__real@8@3ff583126e978d4fe000
PUBLIC	__real@8@40038000000000000000
PUBLIC	?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z ; CBaseMonster::MoveExecute
EXTRN	?UTIL_MoveToOrigin@@YAXPAUedict_s@@ABVVector@@MH@Z:NEAR ; UTIL_MoveToOrigin
;	COMDAT __real@8@3ff583126e978d4fe000
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
__real@8@3ff583126e978d4fe000 DQ 03f50624dd2f1a9fcr ; 0.001
CONST	ENDS
;	COMDAT __real@8@40038000000000000000
CONST	SEGMENT
__real@8@40038000000000000000 DQ 04030000000000000r ; 16
CONST	ENDS
;	COMDAT ?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
_TEXT	SEGMENT
_flInterval$ = 16
_this$ = -4
_flTotal$ = -8
_flStep$ = -12
?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z PROC NEAR ; CBaseMonster::MoveExecute, COMDAT

; 1949 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1950 : 	if ( m_IdealActivity != m_movementActivity )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+2072]
	cmp	edx, DWORD PTR [ecx+2252]
	je	SHORT $L40371

; 1951 : 		m_IdealActivity = m_movementActivity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2252]
	mov	DWORD PTR [eax+2072], edx
$L40371:

; 1952 : 
; 1953 : 	float flTotal = m_flGroundSpeed * pev->framerate * flInterval;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1796]
	fmul	DWORD PTR [ecx+312]
	fmul	DWORD PTR _flInterval$[ebp]
	fstp	DWORD PTR _flTotal$[ebp]
$L40375:

; 1954 : 	float flStep;
; 1955 : 	while (flTotal > 0.001)

	fld	DWORD PTR _flTotal$[ebp]
	fcomp	QWORD PTR __real@8@3ff583126e978d4fe000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40376

; 1957 : 		// don't walk more than 16 units or stairs stop working
; 1958 : 		flStep = Q_min( 16.0, flTotal );

	fld	DWORD PTR _flTotal$[ebp]
	fcomp	QWORD PTR __real@8@40038000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L42204
	mov	DWORD PTR -20+[ebp], 0
	mov	DWORD PTR -20+[ebp+4], 1076887552	; 40300000H
	jmp	SHORT $L42205
$L42204:
	fld	DWORD PTR _flTotal$[ebp]
	fstp	QWORD PTR -20+[ebp]
$L42205:
	fld	QWORD PTR -20+[ebp]
	fstp	DWORD PTR _flStep$[ebp]

; 1959 : 		UTIL_MoveToOrigin ( ENT(pev), m_Route[ m_iRouteIndex ].vecLocation, flStep, MOVE_NORMAL );

	push	0
	mov	eax, DWORD PTR _flStep$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2232]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2100]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?UTIL_MoveToOrigin@@YAXPAUedict_s@@ABVVector@@MH@Z ; UTIL_MoveToOrigin
	add	esp, 16					; 00000010H

; 1960 : 		flTotal -= flStep;

	fld	DWORD PTR _flTotal$[ebp]
	fsub	DWORD PTR _flStep$[ebp]
	fstp	DWORD PTR _flTotal$[ebp]

; 1961 : 	}

	jmp	SHORT $L40375
$L40376:

; 1962 : 	// ALERT( at_console, "dist %f\n", m_flGroundSpeed * pev->framerate * flInterval );
; 1963 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z ENDP ; CBaseMonster::MoveExecute
_TEXT	ENDS
PUBLIC	?SetEyePosition@CBaseMonster@@QAEXXZ		; CBaseMonster::SetEyePosition
PUBLIC	?MonsterInit@CBaseMonster@@UAEXXZ		; CBaseMonster::MonsterInit
PUBLIC	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
PUBLIC	?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ; CBaseEntity::UseSet
EXTRN	?g_pGameRules@@3PAVCGameRules@@A:DWORD		; g_pGameRules
EXTRN	?WorldPhysic@@3PAVIPhysicLayer@@A:DWORD		; WorldPhysic
EXTRN	?InitBoneControllers@CBaseAnimating@@QAEXXZ:NEAR ; CBaseAnimating::InitBoneControllers
EXTRN	?ClearSchedule@CBaseMonster@@QAEXXZ:NEAR	; CBaseMonster::ClearSchedule
;	COMDAT ?MonsterInit@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MonsterInit@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::MonsterInit, COMDAT

; 1975 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1976 : 	if (!g_pGameRules->FAllowMonsters())

	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+232]
	test	eax, eax
	jne	SHORT $L40381

; 1978 : 		pev->flags |= FL_KILLME;		// Post this because some monster code modifies class data after calling this function

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 1979 : //		REMOVE_ENTITY(ENT(pev));
; 1980 : 		return;

	jmp	$L40380
$L40381:

; 1982 : 
; 1983 : 	// Set fields common to all monsters
; 1984 : 	pev->takedamage		= DAMAGE_AIM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+364], 1073741824		; 40000000H

; 1985 : 	pev->ideal_yaw		= GetAbsAngles().y;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+172], eax

; 1986 : 	pev->max_health		= pev->health;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+352]
	mov	DWORD PTR [ecx+432], edx

; 1987 : 	pev->deadflag		= DEAD_NO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+368], 0

; 1988 : 	m_IdealMonsterState	= MONSTERSTATE_IDLE;// Assume monster will be idle, until proven otherwise

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2084], 1

; 1989 : 
; 1990 : 	m_IdealActivity = ACT_IDLE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2072], 1

; 1991 : 
; 1992 : 	SetBits (pev->flags, FL_MONSTER);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+420], eax

; 1993 : 	if ( pev->spawnflags & SF_MONSTER_HITMONSTERCLIP )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 4
	test	edx, edx
	je	SHORT $L40382

; 1994 : 		pev->flags |= FL_MONSTERCLIP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	or	edx, 8388608				; 00800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx
$L40382:

; 1995 : 	
; 1996 : 	ClearSchedule();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearSchedule@CBaseMonster@@QAEXXZ	; CBaseMonster::ClearSchedule

; 1997 : 	RouteClear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RouteClear@CBaseMonster@@QAEXXZ	; CBaseMonster::RouteClear

; 1998 : 	InitBoneControllers( ); // FIX: should be done in Spawn

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitBoneControllers@CBaseAnimating@@QAEXXZ ; CBaseAnimating::InitBoneControllers

; 1999 : 
; 2000 : 	m_iHintNode			= NO_NODE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2276], -1

; 2001 : 
; 2002 : 	m_afMemory			= MEMORY_CLEAR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2280], 0

; 2003 : 
; 2004 : 	m_hEnemy			= NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 2005 : 
; 2006 : 	m_flDistTooFar		= 1024.0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2340], 1149239296	; 44800000H

; 2007 : 	m_flDistLook		= 2048.0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2344], 1157627904	; 45000000H

; 2008 : 
; 2009 : 	// set eye position
; 2010 : 	SetEyePosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEyePosition@CBaseMonster@@QAEXXZ	; CBaseMonster::SetEyePosition

; 2011 : 
; 2012 : 	// create a monster collision box
; 2013 : 	m_pUserData = WorldPhysic->CreateBoxFromEntity( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 2014 : 
; 2015 : 	SetThink( MonsterInitThink );

	push	OFFSET FLAT:??_C@_0BB@DOGB@MonsterInitThink?$AA@ ; `string'
	push	OFFSET FLAT:?MonsterInitThink@CBaseMonster@@QAEXXZ ; CBaseMonster::MonsterInitThink
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 2016 : 	SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]

; 2017 : 	SetUse ( MonsterUse );

	push	OFFSET FLAT:??_C@_0L@NBGF@MonsterUse?$AA@ ; `string'
	push	OFFSET FLAT:?MonsterUse@CBaseMonster@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CBaseMonster::MonsterUse
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ; CBaseEntity::UseSet
$L40380:

; 2018 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MonsterInit@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::MonsterInit
_TEXT	ENDS
PUBLIC	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z	; CBaseEntity::FunctionCheck
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::ThinkSet, COMDAT

; 560  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 		m_pfnThink = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1744], ecx

; 562  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnThink)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1744]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 563  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 564  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP	; CBaseEntity::ThinkSet
_TEXT	ENDS
PUBLIC	??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:NEAR ; UTIL_FunctionToName
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ DB 'F'
	DB	'UNCTION NOT IN TABLE!: %s:%s (%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT
_this$ = -4
_pFunction$ = 8
_name$ = 12
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z PROC NEAR	; CBaseEntity::FunctionCheck, COMDAT

; 554  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 		if (pFunction && !UTIL_FunctionToName( GetDataDescMap(), pFunction ) )

	cmp	DWORD PTR _pFunction$[ebp], 0
	je	SHORT $L35044
	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	test	eax, eax
	jne	SHORT $L35044

; 556  : 			ALERT( at_warning, "FUNCTION NOT IN TABLE!: %s:%s (%08lx)\n", GetClassname(), name, (unsigned long)pFunction );

	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L35044:

; 557  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ENDP		; CBaseEntity::FunctionCheck
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
;	COMDAT ?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z PROC NEAR ; CBaseEntity::UseSet, COMDAT

; 574  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 575  : 		m_pfnUse = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1752], ecx

; 576  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnUse)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1752]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 577  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 578  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ENDP ; CBaseEntity::UseSet
_TEXT	ENDS
;	COMDAT ?MonsterInitThink@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MonsterInitThink@CBaseMonster@@QAEXXZ PROC NEAR	; CBaseMonster::MonsterInitThink, COMDAT

; 2025 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2026 : 	StartMonster();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+380]

; 2027 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MonsterInitThink@CBaseMonster@@QAEXXZ ENDP		; CBaseMonster::MonsterInitThink
_TEXT	ENDS
PUBLIC	?StartPatrol@CBaseMonster@@QAEXPAVCBaseEntity@@@Z ; CBaseMonster::StartPatrol
PUBLIC	??_C@_0CO@IPGN@ReadyMonster?$CI?$CJ?9?9?$CFs?5couldn?8t?5find@ ; `string'
PUBLIC	??_C@_0BF@DGMP@Can?8t?5Create?5Route?$CB?6?$AA@	; `string'
EXTRN	?SetState@CBaseMonster@@QAEXW4MONSTERSTATE@@@Z:NEAR ; CBaseMonster::SetState
;	COMDAT ??_C@_0CO@IPGN@ReadyMonster?$CI?$CJ?9?9?$CFs?5couldn?8t?5find@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0CO@IPGN@ReadyMonster?$CI?$CJ?9?9?$CFs?5couldn?8t?5find@ DB 'ReadyM'
	DB	'onster()--%s couldn''t find target "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DGMP@Can?8t?5Create?5Route?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BF@DGMP@Can?8t?5Create?5Route?$CB?6?$AA@ DB 'Can''t Create Route!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?StartPatrol@CBaseMonster@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_path$ = 8
_this$ = -4
?StartPatrol@CBaseMonster@@QAEXPAVCBaseEntity@@@Z PROC NEAR ; CBaseMonster::StartPatrol, COMDAT

; 2030 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2031 : 	m_pGoalEnt = path;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _path$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 2032 : 
; 2033 : 	if ( !m_pGoalEnt )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $L40398

; 2035 : 		ALERT(at_error, "ReadyMonster()--%s couldn't find target \"%s\"\n", STRING(pev->classname), STRING(pev->target));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+456]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CO@IPGN@ReadyMonster?$CI?$CJ?9?9?$CFs?5couldn?8t?5find@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 2037 : 	else

	jmp	SHORT $L40400
$L40398:

; 2039 : 		// Monster will start turning towards his destination
; 2040 : //		MakeIdealYaw ( m_pGoalEnt->GetAbsOrigin() );
; 2041 : 
; 2042 : 		// set the monster up to walk a path corner path. 
; 2043 : 		// !!!BUGBUG - this is a minor bit of a hack.
; 2044 : 		// JAYJAY
; 2045 : 		m_movementGoal = MOVEGOAL_PATHCORNER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2228], 16		; 00000010H

; 2046 : 			
; 2047 : 		if ( pev->movetype == MOVETYPE_FLY )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 5
	jne	SHORT $L40401

; 2048 : 			m_movementActivity = ACT_FLY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2252], 5

; 2049 : 		else

	jmp	SHORT $L40402
$L40401:

; 2050 : 			m_movementActivity = ACT_WALK;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2252], 3
$L40402:

; 2051 : 
; 2052 : 		if ( !FRefreshRoute() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FRefreshRoute@CBaseMonster@@QAEHXZ	; CBaseMonster::FRefreshRoute
	test	eax, eax
	jne	SHORT $L40403

; 2054 : 			ALERT ( at_aiconsole, "Can't Create Route!\n" );

	push	OFFSET FLAT:??_C@_0BF@DGMP@Can?8t?5Create?5Route?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L40403:

; 2056 : 		SetState( MONSTERSTATE_IDLE );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetState@CBaseMonster@@QAEXW4MONSTERSTATE@@@Z ; CBaseMonster::SetState

; 2057 : 		ChangeSchedule( GetScheduleOfType( SCHED_IDLE_WALK ) );

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+448]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeSchedule@CBaseMonster@@QAEXPAUSchedule_t@@@Z ; CBaseMonster::ChangeSchedule
$L40400:

; 2059 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartPatrol@CBaseMonster@@QAEXPAVCBaseEntity@@@Z ENDP	; CBaseMonster::StartPatrol
_TEXT	ENDS
PUBLIC	??_C@_0CO@JKDA@Monster?5?$CFs?5stuck?5in?5wall?9?9level?5@ ; `string'
PUBLIC	?FStringNull@@YAHH@Z				; FStringNull
PUBLIC	?StartMonster@CBaseMonster@@UAEXXZ		; CBaseMonster::StartMonster
EXTRN	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsOrigin
EXTRN	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z:NEAR ; UTIL_FindEntityByTargetname
;	COMDAT ??_C@_0CO@JKDA@Monster?5?$CFs?5stuck?5in?5wall?9?9level?5@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0CO@JKDA@Monster?5?$CFs?5stuck?5in?5wall?9?9level?5@ DB 'Monster %s'
	DB	' stuck in wall--level design error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?StartMonster@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_vecOrigin$40414 = -16
?StartMonster@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::StartMonster, COMDAT

; 2066 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2067 : 	// update capabilities
; 2068 : 	if ( LookupActivity ( ACT_RANGE_ATTACK1 ) != ACTIVITY_NOT_AVAILABLE )

	push	28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	cmp	eax, -1
	je	SHORT $L40409

; 2070 : 		m_afCapability |= bits_CAP_RANGE_ATTACK1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2304]
	or	ch, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2304], ecx
$L40409:

; 2072 : 	if ( LookupActivity ( ACT_RANGE_ATTACK2 ) != ACTIVITY_NOT_AVAILABLE )

	push	29					; 0000001dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	cmp	eax, -1
	je	SHORT $L40410

; 2074 : 		m_afCapability |= bits_CAP_RANGE_ATTACK2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2304]
	or	ch, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2304], ecx
$L40410:

; 2076 : 	if ( LookupActivity ( ACT_MELEE_ATTACK1 ) != ACTIVITY_NOT_AVAILABLE )

	push	30					; 0000001eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	cmp	eax, -1
	je	SHORT $L40411

; 2078 : 		m_afCapability |= bits_CAP_MELEE_ATTACK1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2304]
	or	ch, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2304], ecx
$L40411:

; 2080 : 	if ( LookupActivity ( ACT_MELEE_ATTACK2 ) != ACTIVITY_NOT_AVAILABLE )

	push	31					; 0000001fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	cmp	eax, -1
	je	SHORT $L40412

; 2082 : 		m_afCapability |= bits_CAP_MELEE_ATTACK2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2304]
	or	ch, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2304], ecx
$L40412:

; 2084 : 
; 2085 : 	// Raise monster off the floor one unit, then drop to floor
; 2086 : 	if ( pev->movetype != MOVETYPE_FLY && !FBitSet( pev->spawnflags, SF_MONSTER_FALL_TO_GROUND ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+264], 5
	je	$L40413
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, -2147483648			; 80000000H
	test	ecx, ecx
	jne	$L40413

; 2088 : 		Vector vecOrigin = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecOrigin$40414[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2089 : 		vecOrigin.z += 1;

	fld	DWORD PTR _vecOrigin$40414[ebp+8]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _vecOrigin$40414[ebp+8]

; 2090 : 		SetAbsOrigin( vecOrigin );

	lea	edx, DWORD PTR _vecOrigin$40414[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 2091 : 		UTIL_DropToFloor( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z ; UTIL_DropToFloor
	add	esp, 4

; 2092 : 
; 2093 : 		// Try to move the monster to make sure it's not stuck in a brush.
; 2094 : 		if (!WALK_MOVE ( ENT(pev), 0, 0, WALKMOVE_NORMAL ) && !FBitSet( pev->spawnflags, SF_MONSTER_NO_YELLOW_BLOBS))

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+108
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L40415
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 128				; 00000080H
	test	edx, edx
	jne	SHORT $L40415

; 2096 : 			ALERT(at_error, "Monster %s stuck in wall--level design error\n", STRING(pev->classname));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CO@JKDA@Monster?5?$CFs?5stuck?5in?5wall?9?9level?5@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2097 : 			pev->effects |= EF_BRIGHTFIELD;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L40415:

; 2100 : 	else 

	jmp	SHORT $L40417
$L40413:

; 2102 : 		pev->flags &= ~FL_ONGROUND;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ch, -3					; fffffffdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx
$L40417:

; 2104 : 
; 2105 : 	if ( !FStringNull(pev->target) )// this monster has a target

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+456]
	push	eax
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40418

; 2107 : 		StartPatrol(UTIL_FindEntityByTargetname( NULL, STRING( pev->target )));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+456]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartPatrol@CBaseMonster@@QAEXPAVCBaseEntity@@@Z ; CBaseMonster::StartPatrol
$L40418:

; 2109 : 
; 2110 : 	//SetState ( m_IdealMonsterState );
; 2111 : 	//SetActivity ( m_IdealActivity );
; 2112 : 
; 2113 : 	// Delay drop to floor to make sure each door in the level has had its chance to spawn
; 2114 : 	// Spread think times so that they don't all happen at the same time (Carmack)
; 2115 : 	SetThink ( CallMonsterThink );

	push	OFFSET FLAT:??_C@_0BB@EDJO@CallMonsterThink?$AA@ ; `string'
	push	OFFSET FLAT:?CallMonsterThink@CBaseMonster@@QAEXXZ ; CBaseMonster::CallMonsterThink
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 2116 : 	pev->nextthink += RANDOM_FLOAT(0.1, 0.4); // spread think times.

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+4]
	push	1053609165				; 3ecccccdH
	push	1036831949				; 3dcccccdH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR [esi+260]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+260]

; 2117 : 	
; 2118 : 	if ( !FStringNull(pev->targetname) )// wait until triggered

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+460]
	push	eax
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40421

; 2120 : 		SetState( MONSTERSTATE_IDLE );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetState@CBaseMonster@@QAEXW4MONSTERSTATE@@@Z ; CBaseMonster::SetState

; 2121 : 		// UNDONE: Some scripted sequence monsters don't have an idle?
; 2122 : 		SetActivity( ACT_IDLE );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+484]

; 2123 : 		ChangeSchedule( GetScheduleOfType( SCHED_WAIT_TRIGGER ) );

	push	34					; 00000022H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeSchedule@CBaseMonster@@QAEXPAUSchedule_t@@@Z ; CBaseMonster::ChangeSchedule
$L40421:

; 2125 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartMonster@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::StartMonster
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT
_iString$ = 8
?FStringNull@@YAHH@Z PROC NEAR				; FStringNull, COMDAT

; 201  : inline BOOL FStringNull(int iString)			{ return iString == iStringNull; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _iString$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStringNull@@YAHH@Z ENDP				; FStringNull
_TEXT	ENDS
PUBLIC	??_C@_0BL@FMEF@Movement?5completed?5twice?$CB?6?$AA@ ; `string'
PUBLIC	?TaskComplete@CBaseMonster@@QAEXXZ		; CBaseMonster::TaskComplete
;	COMDAT ??_C@_0BL@FMEF@Movement?5completed?5twice?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BL@FMEF@Movement?5completed?5twice?$CB?6?$AA@ DB 'Movement complet'
	DB	'ed twice!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?MovementComplete@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MovementComplete@CBaseMonster@@QAEXXZ PROC NEAR	; CBaseMonster::MovementComplete, COMDAT

; 2129 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2131 : 	{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2088]
	mov	DWORD PTR -8+[ebp], ecx
	cmp	DWORD PTR -8+[ebp], 3
	ja	SHORT $L40427
	mov	edx, DWORD PTR -8+[ebp]
	jmp	DWORD PTR $L42230[edx*4]
$L40430:

; 2132 : 	case TASKSTATUS_NEW:
; 2133 : 	case TASKSTATUS_RUNNING:
; 2134 : 		m_iTaskStatus = TASKSTATUS_RUNNING_TASK;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2088], 3

; 2135 : 		break;

	jmp	SHORT $L40427
$L40431:

; 2136 : 
; 2137 : 	case TASKSTATUS_RUNNING_MOVEMENT:
; 2138 : 		TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 2139 : 		break;

	jmp	SHORT $L40427
$L40432:

; 2140 : 	
; 2141 : 	case TASKSTATUS_RUNNING_TASK:
; 2142 : 		ALERT( at_error, "Movement completed twice!\n" );

	push	OFFSET FLAT:??_C@_0BL@FMEF@Movement?5completed?5twice?$CB?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L40427:

; 2148 : 	m_movementGoal = MOVEGOAL_NONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2228], 0

; 2149 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L42230:
	DD	$L40430
	DD	$L40430
	DD	$L40431
	DD	$L40432
?MovementComplete@CBaseMonster@@QAEXXZ ENDP		; CBaseMonster::MovementComplete
_TEXT	ENDS
;	COMDAT ?TaskComplete@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TaskComplete@CBaseMonster@@QAEXXZ PROC NEAR		; CBaseMonster::TaskComplete, COMDAT

; 226  : 		inline void TaskComplete( void ) { if ( !HasConditions(bits_COND_TASK_FAILED) ) m_iTaskStatus = TASKSTATUS_COMPLETE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1073741824				; 40000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	jne	SHORT $L36096
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2088], 4
$L36096:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TaskComplete@CBaseMonster@@QAEXXZ ENDP			; CBaseMonster::TaskComplete
_TEXT	ENDS
;	COMDAT ?TaskIsRunning@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?TaskIsRunning@CBaseMonster@@QAEHXZ PROC NEAR		; CBaseMonster::TaskIsRunning, COMDAT

; 2153 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2155 : 		 m_iTaskStatus != TASKSTATUS_RUNNING_MOVEMENT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2088], 4
	je	SHORT $L40439
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2088], 2
	je	SHORT $L40439

; 2156 : 		 return 1;

	mov	eax, 1
	jmp	SHORT $L40438
$L40439:

; 2157 : 
; 2158 : 	return 0;

	xor	eax, eax
$L40438:

; 2159 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TaskIsRunning@CBaseMonster@@QAEHXZ ENDP		; CBaseMonster::TaskIsRunning
_TEXT	ENDS
PUBLIC	?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z ; CBaseMonster::IRelationship
;	COMDAT ?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pTarget$ = 8
_this$ = -4
_iTargClass$ = -8
?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z PROC NEAR ; CBaseMonster::IRelationship, COMDAT

; 2166 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2167 : 	static int iEnemy[17][17] =
; 2168 : 	{			 //   NONE	MACH	PLYR	HPASS	HMIL	AMIL	APASS	AMONST	APREY	APRED	INSECT	PLRALY	PBWPN	ABWPN	FACT_A	FACT_B	FACT_C
; 2169 : 	/*NONE*/		{ R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO },
; 2170 : 	/*MACHINE*/		{ R_NO,	R_NO,	R_DL,	R_DL,	R_NO,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_NO,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL },
; 2171 : 	/*PLAYER*/		{ R_NO,	R_DL,	R_NO,	R_NO,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_NO,	R_NO,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL },
; 2172 : 	/*HUMANPASSIVE*/{ R_NO,	R_NO,	R_AL,	R_AL,	R_HT,	R_FR,	R_NO,	R_HT,	R_DL,	R_FR,	R_NO,	R_AL,	R_NO,	R_NO,	R_DL,	R_DL,	R_DL },
; 2173 : 	/*HUMANMILITAR*/{ R_NO,	R_NO,	R_HT,	R_DL,	R_NO,	R_HT,	R_DL,	R_DL,	R_DL,	R_DL,	R_NO,	R_HT,	R_NO,	R_NO,	R_DL,	R_DL,	R_DL },
; 2174 : 	/*ALIENMILITAR*/{ R_NO,	R_DL,	R_HT,	R_DL,	R_HT,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_DL,	R_NO,	R_NO,	R_DL,	R_DL,	R_DL },
; 2175 : 	/*ALIENPASSIVE*/{ R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_DL,	R_DL,	R_DL },
; 2176 : 	/*ALIENMONSTER*/{ R_NO,	R_DL,	R_DL,	R_DL,	R_DL,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_NO,	R_DL,	R_NO,	R_NO,	R_DL,	R_DL,	R_DL },
; 2177 : 	/*ALIENPREY   */{ R_NO,	R_NO,	R_DL,	R_DL,	R_DL,	R_NO,	R_NO,	R_NO,	R_NO,	R_FR,	R_NO,	R_DL,	R_NO,	R_NO,	R_DL,	R_DL,	R_DL },
; 2178 : 	/*ALIENPREDATO*/{ R_NO,	R_NO,	R_DL,	R_DL,	R_DL,	R_NO,	R_NO,	R_NO,	R_HT,	R_DL,	R_NO,	R_DL,	R_NO,	R_NO,	R_DL,	R_DL,	R_DL },
; 2179 : 	/*INSECT*/		{ R_FR,	R_FR,	R_FR,	R_FR,	R_FR,	R_NO,	R_FR,	R_FR,	R_FR,	R_FR,	R_NO,	R_FR,	R_NO,	R_NO,	R_FR,	R_FR,	R_FR },
; 2180 : 	/*PLAYERALLY*/	{ R_NO,	R_DL,	R_AL,	R_AL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_NO,	R_NO,	R_NO,	R_NO,	R_DL,	R_DL,	R_DL },
; 2181 : 	/*PBIOWEAPON*/	{ R_NO,	R_NO,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_NO,	R_DL,	R_NO,	R_DL,	R_DL,	R_DL,	R_DL },
; 2182 : 	/*ABIOWEAPON*/	{ R_NO,	R_NO,	R_DL,	R_DL,	R_DL,	R_AL,	R_NO,	R_DL,	R_DL,	R_NO,	R_NO,	R_DL,	R_DL,	R_NO,	R_DL,	R_DL,	R_DL },
; 2183 : 	/*FACTION_A*/   { R_NO,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_NO,	R_DL,	R_DL,	R_DL,	R_AL,	R_DL,	R_DL },
; 2184 : 	/*FACTION_B*/   { R_NO,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_NO,	R_DL,	R_DL,	R_DL,	R_DL,	R_AL,	R_DL },
; 2185 : 	/*FACTION_C*/   { R_NO,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_NO,	R_DL,	R_DL,	R_DL,	R_DL,	R_DL,	R_AL }
; 2186 : 	};
; 2187 : 
; 2188 : 	int iTargClass = pTarget->Classify();

	mov	eax, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [edx+68]
	mov	DWORD PTR _iTargClass$[ebp], eax

; 2189 : 
; 2190 : 	if (iTargClass == CLASS_PLAYER && m_iPlayerReact) //LRC

	cmp	DWORD PTR _iTargClass$[ebp], 2
	jne	SHORT $L40453
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2392], 0
	je	SHORT $L40453

; 2192 : 		if (m_iPlayerReact == 1) // Ignore player

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2392], 1
	jne	SHORT $L40448

; 2193 : 			return R_NO;

	xor	eax, eax
	jmp	SHORT $L40443
$L40448:

; 2194 : 		else if (m_iPlayerReact == 4)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2392], 4
	jne	SHORT $L40450

; 2195 : 			return R_HT;

	mov	eax, 2
	jmp	SHORT $L40443
$L40450:

; 2196 : 		else if (m_afMemory & bits_MEMORY_PROVOKED)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2280]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L40452

; 2197 : 			return R_HT;

	mov	eax, 2
	jmp	SHORT $L40443
$L40452:

; 2199 : 			return R_NO;

	xor	eax, eax
	jmp	SHORT $L40443
$L40453:

; 2201 : 
; 2202 : 	return iEnemy[ Classify() ][ pTarget->Classify() ];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+68]
	mov	esi, eax
	imul	esi, 68					; 00000044H
	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [edx+68]
	mov	eax, DWORD PTR _?iEnemy@?1??IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z@4PAY0BB@HA[esi+eax*4]
$L40443:

; 2203 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z ENDP ; CBaseMonster::IRelationship
_TEXT	ENDS
PUBLIC	?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z	; CBaseMonster::FindCover
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	??0gametrace_s@@QAE@XZ				; gametrace_s::gametrace_s
PUBLIC	??_C@_0DG@KACF@FindCover?5MinDist?5?$CI?$CF?40f?$CJ?5too?5clo@ ; `string'
PUBLIC	??_C@_0CA@KMIK@Graph?5not?5ready?5for?5findcover?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@KICA@FindCover?$CI?$CJ?5?9?5?$CFs?5has?5no?5nearest?5@ ; `string'
PUBLIC	?Node@CGraph@@QAEAAVCNode@@H@Z			; CGraph::Node
EXTRN	?PathLength@CGraph@@QAEMHHHH@Z:NEAR		; CGraph::PathLength
EXTRN	?HullIndex@CGraph@@QAEHPBVCBaseEntity@@@Z:NEAR	; CGraph::HullIndex
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
;	COMDAT ??_C@_0DG@KACF@FindCover?5MinDist?5?$CI?$CF?40f?$CJ?5too?5clo@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0DG@KACF@FindCover?5MinDist?5?$CI?$CF?40f?$CJ?5too?5clo@ DB 'FindCo'
	DB	'ver MinDist (%.0f) too close to MaxDist (%.0f)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KMIK@Graph?5not?5ready?5for?5findcover?$CB?6?$AA@
CONST	SEGMENT
??_C@_0CA@KMIK@Graph?5not?5ready?5for?5findcover?$CB?6?$AA@ DB 'Graph not'
	DB	' ready for findcover!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KICA@FindCover?$CI?$CJ?5?9?5?$CFs?5has?5no?5nearest?5@
CONST	SEGMENT
??_C@_0CH@KICA@FindCover?$CI?$CJ?5?9?5?$CFs?5has?5no?5nearest?5@ DB 'Find'
	DB	'Cover() - %s has no nearest node!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@8@3fff8000000000000000
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT ?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
_TEXT	SEGMENT
$T42239 = -112
$T42240 = -124
$T42241 = -136
_vecThreat$ = 8
_vecViewOffset$ = 20
_flMinDist$ = 32
_flMaxDist$ = 36
_this$ = -4
_i$ = -8
_iMyHullIndex$ = -12
_iMyNode$ = -16
_iThreatNode$ = -20
_flDist$ = -24
_vecLookersOffset$ = -36
_tr$ = -92
_nodeNumber$40481 = -96
_node$40482 = -100
?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z PROC NEAR	; CBaseMonster::FindCover, COMDAT

; 2219 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2220 : 	int i;
; 2221 : 	int iMyHullIndex;
; 2222 : 	int iMyNode;
; 2223 : 	int iThreatNode;
; 2224 : 	float flDist;
; 2225 : 	Vector	vecLookersOffset;

	lea	ecx, DWORD PTR _vecLookersOffset$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2226 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 2227 : 
; 2228 : 	if ( !flMaxDist )

	fld	DWORD PTR _flMaxDist$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40468

; 2230 : 		// user didn't supply a MaxDist, so work up a crazy one.
; 2231 : 		flMaxDist = 784;

	mov	DWORD PTR _flMaxDist$[ebp], 1145307136	; 44440000H
$L40468:

; 2233 : 
; 2234 : 	if ( flMinDist > 0.5 * flMaxDist)

	fld	DWORD PTR _flMinDist$[ebp]
	fld	DWORD PTR _flMaxDist$[ebp]
	fmul	QWORD PTR __real@8@3ffe8000000000000000
	fcompp
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40469

; 2236 : #if _DEBUG
; 2237 : 		ALERT ( at_console, "FindCover MinDist (%.0f) too close to MaxDist (%.0f)\n", flMinDist, flMaxDist );

	fld	DWORD PTR _flMaxDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _flMinDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0DG@KACF@FindCover?5MinDist?5?$CI?$CF?40f?$CJ?5too?5clo@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 24					; 00000018H

; 2238 : #endif
; 2239 : 		flMinDist = 0.5 * flMaxDist;

	fld	DWORD PTR _flMaxDist$[ebp]
	fmul	QWORD PTR __real@8@3ffe8000000000000000
	fstp	DWORD PTR _flMinDist$[ebp]
$L40469:

; 2241 : 
; 2242 : 	if ( !WorldGraph.m_fGraphPresent || !WorldGraph.m_fGraphPointersSet )

	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A, 0
	je	SHORT $L40472
	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A+4, 0
	jne	SHORT $L40471
$L40472:

; 2244 : 		ALERT ( at_aiconsole, "Graph not ready for findcover!\n" );

	push	OFFSET FLAT:??_C@_0CA@KMIK@Graph?5not?5ready?5for?5findcover?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2245 : 		return FALSE;

	xor	eax, eax
	jmp	$L40460
$L40471:

; 2247 : 
; 2248 : 	iMyNode = WorldGraph.FindNearestNode( GetAbsOrigin(), this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FindNearestNode@CGraph@@QAEHABVVector@@PAVCBaseEntity@@@Z ; CGraph::FindNearestNode
	mov	DWORD PTR _iMyNode$[ebp], eax

; 2249 : 	iThreatNode = WorldGraph.FindNearestNode ( vecThreat, this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecThreat$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FindNearestNode@CGraph@@QAEHABVVector@@PAVCBaseEntity@@@Z ; CGraph::FindNearestNode
	mov	DWORD PTR _iThreatNode$[ebp], eax

; 2250 : 	iMyHullIndex = WorldGraph.HullIndex( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?HullIndex@CGraph@@QAEHPBVCBaseEntity@@@Z ; CGraph::HullIndex
	mov	DWORD PTR _iMyHullIndex$[ebp], eax

; 2251 : 
; 2252 : 	if ( iMyNode == NO_NODE )

	cmp	DWORD PTR _iMyNode$[ebp], -1
	jne	SHORT $L40474

; 2254 : 		ALERT ( at_aiconsole, "FindCover() - %s has no nearest node!\n", STRING(pev->classname));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CH@KICA@FindCover?$CI?$CJ?5?9?5?$CFs?5has?5no?5nearest?5@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2255 : 		return FALSE;

	xor	eax, eax
	jmp	$L40460
$L40474:

; 2257 : 	if ( iThreatNode == NO_NODE )

	cmp	DWORD PTR _iThreatNode$[ebp], -1
	jne	SHORT $L40476

; 2259 : 		// ALERT ( at_aiconsole, "FindCover() - Threat has no nearest node!\n" );
; 2260 : 		iThreatNode = iMyNode;

	mov	ecx, DWORD PTR _iMyNode$[ebp]
	mov	DWORD PTR _iThreatNode$[ebp], ecx
$L40476:

; 2263 : 
; 2264 : 	vecLookersOffset = vecThreat + vecViewOffset;// calculate location of enemy's eyes

	lea	edx, DWORD PTR _vecViewOffset$[ebp]
	push	edx
	lea	eax, DWORD PTR $T42239[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecThreat$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecLookersOffset$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecLookersOffset$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecLookersOffset$[ebp+8], eax

; 2265 : 
; 2266 : 	// we'll do a rough sample to find nodes that are relatively nearby
; 2267 : 	for ( i = 0 ; i < WorldGraph.m_cNodes ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40478
$L40479:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L40478:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	jge	$L40480

; 2269 : 		int nodeNumber = (i + WorldGraph.m_iLastCoverSearch) % WorldGraph.m_cNodes;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+8392
	cdq
	idiv	DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	mov	DWORD PTR _nodeNumber$40481[ebp], edx

; 2270 : 
; 2271 : 		CNode &node = WorldGraph.Node( nodeNumber );

	mov	eax, DWORD PTR _nodeNumber$40481[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?Node@CGraph@@QAEAAVCNode@@H@Z		; CGraph::Node
	mov	DWORD PTR _node$40482[ebp], eax

; 2272 : 		WorldGraph.m_iLastCoverSearch = nodeNumber + 1; // next monster that searches for cover node will start where we left off here.

	mov	ecx, DWORD PTR _nodeNumber$40481[ebp]
	add	ecx, 1
	mov	DWORD PTR ?WorldGraph@@3VCGraph@@A+8392, ecx

; 2273 : 
; 2274 : 		// could use an optimization here!!
; 2275 : 		flDist = ( GetAbsOrigin() - node.m_vecOrigin ).Length();

	mov	edx, DWORD PTR _node$40482[ebp]
	push	edx
	lea	eax, DWORD PTR $T42240[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flDist$[ebp]

; 2276 : 
; 2277 : 		// DON'T do the trace check on a node that is farther away than a node that we've already found to 
; 2278 : 		// provide cover! Also make sure the node is within the mins/maxs of the search.
; 2279 : 		if ( flDist >= flMinDist && flDist < flMaxDist )

	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR _flMinDist$[ebp]
	fnstsw	ax
	test	ah, 1
	jne	$L40489
	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR _flMaxDist$[ebp]
	fnstsw	ax
	test	ah, 1
	je	$L40489

; 2281 : 			UTIL_TraceLine ( node.m_vecOrigin + vecViewOffset, vecLookersOffset, ignore_monsters, ignore_glass,  ENT(pev), &tr );

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	push	1
	lea	ecx, DWORD PTR _vecLookersOffset$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecViewOffset$[ebp]
	push	edx
	lea	eax, DWORD PTR $T42241[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$40482[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 24					; 00000018H

; 2282 : 
; 2283 : 			// if this node will block the threat's line of sight to me...
; 2284 : 			if ( tr.flFraction != 1.0 )

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L40489

; 2286 : 				// ..and is also closer to me than the threat, or the same distance from myself and the threat the node is good.
; 2287 : 				if ( ( iMyNode == iThreatNode ) || WorldGraph.PathLength( iMyNode, nodeNumber, iMyHullIndex, m_afCapability ) <= WorldGraph.PathLength( iThreatNode, nodeNumber, iMyHullIndex, m_afCapability ) )

	mov	ecx, DWORD PTR _iMyNode$[ebp]
	cmp	ecx, DWORD PTR _iThreatNode$[ebp]
	je	SHORT $L40488
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2304]
	push	eax
	mov	ecx, DWORD PTR _iMyHullIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nodeNumber$40481[ebp]
	push	edx
	mov	eax, DWORD PTR _iMyNode$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?PathLength@CGraph@@QAEMHHHH@Z		; CGraph::PathLength
	fstp	DWORD PTR -140+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2304]
	push	edx
	mov	eax, DWORD PTR _iMyHullIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nodeNumber$40481[ebp]
	push	ecx
	mov	edx, DWORD PTR _iThreatNode$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?PathLength@CGraph@@QAEMHHHH@Z		; CGraph::PathLength
	fcomp	DWORD PTR -140+[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40489
$L40488:

; 2289 : 					if ( FValidateCover ( node.m_vecOrigin ) && MoveToLocation( ACT_RUN, 0, node.m_vecOrigin ) )

	mov	eax, DWORD PTR _node$40482[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+512]
	test	eax, eax
	je	SHORT $L40489
	mov	eax, DWORD PTR _node$40482[ebp]
	push	eax
	push	0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveToLocation@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z ; CBaseMonster::MoveToLocation
	test	eax, eax
	je	SHORT $L40489

; 2291 : 						/*
; 2292 : 						MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );
; 2293 : 							WRITE_BYTE( TE_SHOWLINE);
; 2294 : 							
; 2295 : 							WRITE_COORD( node.m_vecOrigin.x );
; 2296 : 							WRITE_COORD( node.m_vecOrigin.y );
; 2297 : 							WRITE_COORD( node.m_vecOrigin.z );
; 2298 : 
; 2299 : 							WRITE_COORD( vecLookersOffset.x );
; 2300 : 							WRITE_COORD( vecLookersOffset.y );
; 2301 : 							WRITE_COORD( vecLookersOffset.z );
; 2302 : 						MESSAGE_END();
; 2303 : 						*/
; 2304 : 
; 2305 : 						return TRUE;

	mov	eax, 1
	jmp	SHORT $L40460
$L40489:

; 2310 : 	}

	jmp	$L40479
$L40480:

; 2311 : 	return FALSE;

	xor	eax, eax
$L40460:

; 2312 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z ENDP	; CBaseMonster::FindCover
_TEXT	ENDS
PUBLIC	??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@		; `string'
;	COMDAT ??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.h
CONST	SEGMENT
??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@ DB 'Bad Node!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?Node@CGraph@@QAEAAVCNode@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Node@CGraph@@QAEAAVCNode@@H@Z PROC NEAR		; CGraph::Node, COMDAT

; 210  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 211  : #ifdef _DEBUG
; 212  : 		if ( !m_pNodes || i < 0 || i > m_cNodes )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L36426
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L36426
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jle	SHORT $L36425
$L36426:

; 213  : 			ALERT( at_error, "Bad Node!\n" );

	push	OFFSET FLAT:??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L36425:

; 214  : #endif
; 215  : 		return m_pNodes[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	eax, edx

; 216  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Node@CGraph@@QAEAAVCNode@@H@Z ENDP			; CGraph::Node
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0gametrace_s@@QAE@XZ PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0gametrace_s@@QAE@XZ ENDP				; gametrace_s::gametrace_s
_TEXT	ENDS
PUBLIC	?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z ; CBaseMonster::BuildNearestRoute
PUBLIC	??_C@_0CI@FNFC@Graph?5not?5ready?5for?5BuildNearest@ ; `string'
PUBLIC	??_C@_0CP@DHMG@BuildNearestRoute?$CI?$CJ?5?9?5?$CFs?5has?5no?5@ ; `string'
EXTRN	?NextNodeInRoute@CGraph@@QAEHHHHH@Z:NEAR	; CGraph::NextNodeInRoute
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
;	COMDAT ??_C@_0CI@FNFC@Graph?5not?5ready?5for?5BuildNearest@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0CI@FNFC@Graph?5not?5ready?5for?5BuildNearest@ DB 'Graph not ready '
	DB	'for BuildNearestRoute!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DHMG@BuildNearestRoute?$CI?$CJ?5?9?5?$CFs?5has?5no?5@
CONST	SEGMENT
??_C@_0CP@DHMG@BuildNearestRoute?$CI?$CJ?5?9?5?$CFs?5has?5no?5@ DB 'Build'
	DB	'NearestRoute() - %s has no nearest node!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
_TEXT	SEGMENT
$T42250 = -108
$T42251 = -120
$T42252 = -132
_vecThreat$ = 8
_vecViewOffset$ = 20
_flMinDist$ = 32
_flMaxDist$ = 36
_this$ = -4
_i$ = -8
_iMyHullIndex$ = -12
_iMyNode$ = -16
_flDist$ = -20
_vecLookersOffset$ = -32
_tr$ = -88
_nodeNumber$40516 = -92
_node$40517 = -96
?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z PROC NEAR ; CBaseMonster::BuildNearestRoute, COMDAT

; 2325 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2326 : 	int i;
; 2327 : 	int iMyHullIndex;
; 2328 : 	int iMyNode;
; 2329 : 	float flDist;
; 2330 : 	Vector	vecLookersOffset;

	lea	ecx, DWORD PTR _vecLookersOffset$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2331 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 2332 : 
; 2333 : 	if ( !flMaxDist )

	fld	DWORD PTR _flMaxDist$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40505

; 2335 : 		// user didn't supply a MaxDist, so work up a crazy one.
; 2336 : 		flMaxDist = 784;

	mov	DWORD PTR _flMaxDist$[ebp], 1145307136	; 44440000H
$L40505:

; 2338 : 
; 2339 : 	if ( flMinDist > 0.5 * flMaxDist)

	fld	DWORD PTR _flMinDist$[ebp]
	fld	DWORD PTR _flMaxDist$[ebp]
	fmul	QWORD PTR __real@8@3ffe8000000000000000
	fcompp
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40506

; 2341 : #if _DEBUG
; 2342 : 		ALERT ( at_console, "FindCover MinDist (%.0f) too close to MaxDist (%.0f)\n", flMinDist, flMaxDist );

	fld	DWORD PTR _flMaxDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _flMinDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0DG@KACF@FindCover?5MinDist?5?$CI?$CF?40f?$CJ?5too?5clo@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 24					; 00000018H

; 2343 : #endif
; 2344 : 		flMinDist = 0.5 * flMaxDist;

	fld	DWORD PTR _flMaxDist$[ebp]
	fmul	QWORD PTR __real@8@3ffe8000000000000000
	fstp	DWORD PTR _flMinDist$[ebp]
$L40506:

; 2346 : 
; 2347 : 	if ( !WorldGraph.m_fGraphPresent || !WorldGraph.m_fGraphPointersSet )

	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A, 0
	je	SHORT $L40508
	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A+4, 0
	jne	SHORT $L40507
$L40508:

; 2349 : 		ALERT ( at_aiconsole, "Graph not ready for BuildNearestRoute!\n" );

	push	OFFSET FLAT:??_C@_0CI@FNFC@Graph?5not?5ready?5for?5BuildNearest@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2350 : 		return FALSE;

	xor	eax, eax
	jmp	$L40498
$L40507:

; 2352 : 
; 2353 : 	iMyNode = WorldGraph.FindNearestNode( GetAbsOrigin(), this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FindNearestNode@CGraph@@QAEHABVVector@@PAVCBaseEntity@@@Z ; CGraph::FindNearestNode
	mov	DWORD PTR _iMyNode$[ebp], eax

; 2354 : 	iMyHullIndex = WorldGraph.HullIndex( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?HullIndex@CGraph@@QAEHPBVCBaseEntity@@@Z ; CGraph::HullIndex
	mov	DWORD PTR _iMyHullIndex$[ebp], eax

; 2355 : 
; 2356 : 	if ( iMyNode == NO_NODE )

	cmp	DWORD PTR _iMyNode$[ebp], -1
	jne	SHORT $L40510

; 2358 : 		ALERT ( at_aiconsole, "BuildNearestRoute() - %s has no nearest node!\n", STRING(pev->classname));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CP@DHMG@BuildNearestRoute?$CI?$CJ?5?9?5?$CFs?5has?5no?5@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2359 : 		return FALSE;

	xor	eax, eax
	jmp	$L40498
$L40510:

; 2361 : 
; 2362 : 	vecLookersOffset = vecThreat + vecViewOffset;// calculate location of enemy's eyes

	lea	edx, DWORD PTR _vecViewOffset$[ebp]
	push	edx
	lea	eax, DWORD PTR $T42250[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecThreat$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecLookersOffset$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecLookersOffset$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecLookersOffset$[ebp+8], eax

; 2363 : 
; 2364 : 	// we'll do a rough sample to find nodes that are relatively nearby
; 2365 : 	for ( i = 0 ; i < WorldGraph.m_cNodes ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40513
$L40514:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L40513:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	jge	$L40515

; 2367 : 		int nodeNumber = (i + WorldGraph.m_iLastCoverSearch) % WorldGraph.m_cNodes;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+8392
	cdq
	idiv	DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	mov	DWORD PTR _nodeNumber$40516[ebp], edx

; 2368 : 
; 2369 : 		CNode &node = WorldGraph.Node( nodeNumber );

	mov	eax, DWORD PTR _nodeNumber$40516[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?Node@CGraph@@QAEAAVCNode@@H@Z		; CGraph::Node
	mov	DWORD PTR _node$40517[ebp], eax

; 2370 : 		WorldGraph.m_iLastCoverSearch = nodeNumber + 1; // next monster that searches for cover node will start where we left off here.

	mov	ecx, DWORD PTR _nodeNumber$40516[ebp]
	add	ecx, 1
	mov	DWORD PTR ?WorldGraph@@3VCGraph@@A+8392, ecx

; 2371 : 
; 2372 : 		// can I get there?
; 2373 : 		if (WorldGraph.NextNodeInRoute( iMyNode, nodeNumber, iMyHullIndex, 0 ) != iMyNode)

	push	0
	mov	edx, DWORD PTR _iMyHullIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _nodeNumber$40516[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMyNode$[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?NextNodeInRoute@CGraph@@QAEHHHHH@Z	; CGraph::NextNodeInRoute
	cmp	eax, DWORD PTR _iMyNode$[ebp]
	je	$L40523

; 2375 : 			flDist = ( vecThreat - node.m_vecOrigin ).Length();

	mov	edx, DWORD PTR _node$40517[ebp]
	push	edx
	lea	eax, DWORD PTR $T42251[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecThreat$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flDist$[ebp]

; 2376 : 
; 2377 : 			// is it close?
; 2378 : 			if ( flDist > flMinDist && flDist < flMaxDist)

	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR _flMinDist$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L40523
	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR _flMaxDist$[ebp]
	fnstsw	ax
	test	ah, 1
	je	$L40523

; 2380 : 				// can I see where I want to be from there?
; 2381 : 				UTIL_TraceLine( node.m_vecOrigin + pev->view_ofs, vecLookersOffset, ignore_monsters, edict(), &tr );

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	lea	edx, DWORD PTR _vecLookersOffset$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T42252[ebp]
	push	edx
	mov	ecx, DWORD PTR _node$40517[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 2382 : 
; 2383 : 				if (tr.flFraction == 1.0)

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40523

; 2385 : 					// try to actually get there
; 2386 : 					if ( BuildRoute ( node.m_vecOrigin, bits_MF_TO_LOCATION, NULL ) )

	push	0
	push	64					; 00000040H
	mov	eax, DWORD PTR _node$40517[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildRoute@CBaseMonster@@QAEHABVVector@@HPAVCBaseEntity@@@Z ; CBaseMonster::BuildRoute
	test	eax, eax
	je	SHORT $L40523

; 2388 : 						flMaxDist = flDist;

	mov	ecx, DWORD PTR _flDist$[ebp]
	mov	DWORD PTR _flMaxDist$[ebp], ecx

; 2389 : 						m_vecMoveGoal = node.m_vecOrigin;

	mov	edx, DWORD PTR _node$40517[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2240				; 000008c0H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 2390 : 						return TRUE; // UNDONE: keep looking for something closer!

	mov	eax, 1
	jmp	SHORT $L40498
$L40523:

; 2395 : 	}

	jmp	$L40514
$L40515:

; 2396 : 
; 2397 : 	return FALSE;

	xor	eax, eax
$L40498:

; 2398 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z ENDP ; CBaseMonster::BuildNearestRoute
_TEXT	ENDS
PUBLIC	?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ ; CBaseMonster::BestVisibleEnemy
;	COMDAT ?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
$T42255 = -36
$T42256 = -48
_this$ = -4
_pReturn$ = -8
_pNextEnt$ = -12
_iNearest$ = -16
_iDist$ = -20
_iBestRelationship$ = -24
?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ PROC NEAR ; CBaseMonster::BestVisibleEnemy, COMDAT

; 2412 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2413 : 	CBaseEntity	*pReturn;
; 2414 : 	CBaseEntity	*pNextEnt;
; 2415 : 	int			iNearest;
; 2416 : 	int			iDist;
; 2417 : 	int			iBestRelationship;
; 2418 : 
; 2419 : 	iNearest = 8192;// so first visible entity will become the closest.

	mov	DWORD PTR _iNearest$[ebp], 8192		; 00002000H

; 2420 : 	pNextEnt = m_pLink;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _pNextEnt$[ebp], ecx

; 2421 : 	pReturn = NULL;

	mov	DWORD PTR _pReturn$[ebp], 0

; 2422 : 	iBestRelationship = R_NO;

	mov	DWORD PTR _iBestRelationship$[ebp], 0
$L40534:

; 2423 : 
; 2424 : 	while ( pNextEnt != NULL )

	cmp	DWORD PTR _pNextEnt$[ebp], 0
	je	$L40535

; 2426 : 		if ( pNextEnt->IsAlive() )

	mov	edx, DWORD PTR _pNextEnt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pNextEnt$[ebp]
	call	DWORD PTR [eax+200]
	test	eax, eax
	je	$L40542

; 2428 : 			if ( IRelationship( pNextEnt) > iBestRelationship )

	mov	ecx, DWORD PTR _pNextEnt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+364]
	cmp	eax, DWORD PTR _iBestRelationship$[ebp]
	jle	SHORT $L40537

; 2430 : 				// this entity is disliked MORE than the entity that we 
; 2431 : 				// currently think is the best visible enemy. No need to do 
; 2432 : 				// a distance check, just get mad at this one for now.
; 2433 : 				iBestRelationship = IRelationship ( pNextEnt );

	mov	ecx, DWORD PTR _pNextEnt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+364]
	mov	DWORD PTR _iBestRelationship$[ebp], eax

; 2434 : 				iNearest = ( pNextEnt->GetAbsOrigin() - GetAbsOrigin() ).Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T42255[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pNextEnt$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	call	__ftol
	mov	DWORD PTR _iNearest$[ebp], eax

; 2435 : 				pReturn = pNextEnt;

	mov	edx, DWORD PTR _pNextEnt$[ebp]
	mov	DWORD PTR _pReturn$[ebp], edx

; 2437 : 			else if ( IRelationship( pNextEnt) == iBestRelationship )

	jmp	SHORT $L40542
$L40537:
	mov	eax, DWORD PTR _pNextEnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+364]
	cmp	eax, DWORD PTR _iBestRelationship$[ebp]
	jne	SHORT $L40542

; 2439 : 				// this entity is disliked just as much as the entity that
; 2440 : 				// we currently think is the best visible enemy, so we only
; 2441 : 				// get mad at it if it is closer.
; 2442 : 				iDist = ( pNextEnt->GetAbsOrigin() - GetAbsOrigin() ).Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T42256[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNextEnt$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	call	__ftol
	mov	DWORD PTR _iDist$[ebp], eax

; 2443 : 				
; 2444 : 				if ( iDist <= iNearest )

	mov	ecx, DWORD PTR _iDist$[ebp]
	cmp	ecx, DWORD PTR _iNearest$[ebp]
	jg	SHORT $L40542

; 2446 : 					iNearest = iDist;

	mov	edx, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _iNearest$[ebp], edx

; 2447 : 					iBestRelationship = IRelationship ( pNextEnt );

	mov	eax, DWORD PTR _pNextEnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+364]
	mov	DWORD PTR _iBestRelationship$[ebp], eax

; 2448 : 					pReturn = pNextEnt;

	mov	eax, DWORD PTR _pNextEnt$[ebp]
	mov	DWORD PTR _pReturn$[ebp], eax
$L40542:

; 2452 : 
; 2453 : 		pNextEnt = pNextEnt->m_pLink;

	mov	ecx, DWORD PTR _pNextEnt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _pNextEnt$[ebp], edx

; 2454 : 	}

	jmp	$L40534
$L40535:

; 2455 : 
; 2456 : 	return pReturn;

	mov	eax, DWORD PTR _pReturn$[ebp]

; 2457 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ ENDP ; CBaseMonster::BestVisibleEnemy
_TEXT	ENDS
;	COMDAT ?MakeIdealYaw@CBaseMonster@@QAEXVVector@@@Z
_TEXT	SEGMENT
$T42259 = -28
$T42260 = -40
$T42261 = -52
_vecTarget$ = 8
_this$ = -4
_vecProjection$ = -16
?MakeIdealYaw@CBaseMonster@@QAEXVVector@@@Z PROC NEAR	; CBaseMonster::MakeIdealYaw, COMDAT

; 2466 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2467 : 	Vector	vecProjection;

	lea	ecx, DWORD PTR _vecProjection$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2468 : 	
; 2469 : 	// strafing monster needs to face 90 degrees away from its goal
; 2470 : 	if ( m_movementActivity == ACT_STRAFE_LEFT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2252], 11		; 0000000bH
	jne	SHORT $L40548

; 2472 : 		vecProjection.x = -vecTarget.y;

	fld	DWORD PTR _vecTarget$[ebp+4]
	fchs
	fstp	DWORD PTR _vecProjection$[ebp]

; 2473 : 		vecProjection.y = vecTarget.x;

	mov	ecx, DWORD PTR _vecTarget$[ebp]
	mov	DWORD PTR _vecProjection$[ebp+4], ecx

; 2474 : 
; 2475 : 		pev->ideal_yaw = UTIL_VecToYaw( vecProjection - GetAbsOrigin() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T42259[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecProjection$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	call	?UTIL_VecToYaw@@YAMABVVector@@@Z	; UTIL_VecToYaw
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+172]

; 2477 : 	else if ( m_movementActivity == ACT_STRAFE_RIGHT )

	jmp	SHORT $L40553
$L40548:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2252], 12		; 0000000cH
	jne	SHORT $L40551

; 2479 : 		vecProjection.x = vecTarget.y;

	mov	eax, DWORD PTR _vecTarget$[ebp+4]
	mov	DWORD PTR _vecProjection$[ebp], eax

; 2480 : 		vecProjection.y = vecTarget.x;

	mov	ecx, DWORD PTR _vecTarget$[ebp]
	mov	DWORD PTR _vecProjection$[ebp+4], ecx

; 2481 : 
; 2482 : 		pev->ideal_yaw = UTIL_VecToYaw( vecProjection - GetAbsOrigin() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T42260[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecProjection$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	call	?UTIL_VecToYaw@@YAMABVVector@@@Z	; UTIL_VecToYaw
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+172]

; 2484 : 	else

	jmp	SHORT $L40553
$L40551:

; 2486 : 		pev->ideal_yaw = UTIL_VecToYaw ( vecTarget - GetAbsOrigin() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T42261[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecTarget$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	call	?UTIL_VecToYaw@@YAMABVVector@@@Z	; UTIL_VecToYaw
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+172]
$L40553:

; 2488 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MakeIdealYaw@CBaseMonster@@QAEXVVector@@@Z ENDP	; CBaseMonster::MakeIdealYaw
_TEXT	ENDS
PUBLIC	?FlYawDiff@CBaseMonster@@QAEMXZ			; CBaseMonster::FlYawDiff
EXTRN	?UTIL_AngleMod@@YAMM@Z:NEAR			; UTIL_AngleMod
EXTRN	?UTIL_AngleDiff@@YAMMM@Z:NEAR			; UTIL_AngleDiff
;	COMDAT ?FlYawDiff@CBaseMonster@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4
_flCurrentYaw$ = -8
?FlYawDiff@CBaseMonster@@QAEMXZ PROC NEAR		; CBaseMonster::FlYawDiff, COMDAT

; 2497 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2498 : 	float	flCurrentYaw;
; 2499 : 
; 2500 : 	flCurrentYaw = UTIL_AngleMod( GetAbsAngles().y );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	?UTIL_AngleMod@@YAMM@Z			; UTIL_AngleMod
	add	esp, 4
	fstp	DWORD PTR _flCurrentYaw$[ebp]

; 2501 : 
; 2502 : 	if ( flCurrentYaw == pev->ideal_yaw )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR _flCurrentYaw$[ebp]
	fcomp	DWORD PTR [edx+172]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40560

; 2504 : 		return 0;

	fld	DWORD PTR __real@4@00000000000000000000
	jmp	SHORT $L40558
$L40560:

; 2506 : 
; 2507 : 
; 2508 : 	return UTIL_AngleDiff( pev->ideal_yaw, flCurrentYaw );

	mov	eax, DWORD PTR _flCurrentYaw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+172]
	push	eax
	call	?UTIL_AngleDiff@@YAMMM@Z		; UTIL_AngleDiff
	add	esp, 8
$L40558:

; 2509 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FlYawDiff@CBaseMonster@@QAEMXZ ENDP			; CBaseMonster::FlYawDiff
_TEXT	ENDS
PUBLIC	__real@4@4002a000000000000000
PUBLIC	__real@4@4006b400000000000000
PUBLIC	__real@4@4007b400000000000000
PUBLIC	__real@4@c006b400000000000000
PUBLIC	?ChangeYaw@CBaseMonster@@UAEMH@Z		; CBaseMonster::ChangeYaw
EXTRN	?SetBoneController@CBaseAnimating@@QAEMHM@Z:NEAR ; CBaseAnimating::SetBoneController
EXTRN	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsAngles
;	COMDAT __real@4@4002a000000000000000
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
__real@4@4002a000000000000000 DD 041200000r	; 10
CONST	ENDS
;	COMDAT __real@4@4006b400000000000000
CONST	SEGMENT
__real@4@4006b400000000000000 DD 043340000r	; 180
CONST	ENDS
;	COMDAT __real@4@4007b400000000000000
CONST	SEGMENT
__real@4@4007b400000000000000 DD 043b40000r	; 360
CONST	ENDS
;	COMDAT __real@4@c006b400000000000000
CONST	SEGMENT
__real@4@c006b400000000000000 DD 0c3340000r	; -180
CONST	ENDS
;	COMDAT ?ChangeYaw@CBaseMonster@@UAEMH@Z
_TEXT	SEGMENT
_yawSpeed$ = 8
_this$ = -4
_ideal$ = -8
_current$ = -12
_move$ = -16
_speed$ = -20
_angles$ = -32
_yaw$40581 = -36
?ChangeYaw@CBaseMonster@@UAEMH@Z PROC NEAR		; CBaseMonster::ChangeYaw, COMDAT

; 2516 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2517 : 	float	ideal, current, move, speed;
; 2518 : 	Vector	angles = GetAbsAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2519 : 
; 2520 : 	current = UTIL_AngleMod( angles.y );

	mov	eax, DWORD PTR _angles$[ebp+4]
	push	eax
	call	?UTIL_AngleMod@@YAMM@Z			; UTIL_AngleMod
	add	esp, 4
	fstp	DWORD PTR _current$[ebp]

; 2521 : 	ideal = pev->ideal_yaw;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+172]
	mov	DWORD PTR _ideal$[ebp], eax

; 2522 : 	if (current != ideal)

	fld	DWORD PTR _current$[ebp]
	fcomp	DWORD PTR _ideal$[ebp]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L40570

; 2524 : 		speed = (float)yawSpeed * gpGlobals->frametime * 10;

	fild	DWORD PTR _yawSpeed$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fmul	DWORD PTR [ecx+4]
	fmul	DWORD PTR __real@4@4002a000000000000000
	fstp	DWORD PTR _speed$[ebp]

; 2525 : 		move = ideal - current;

	fld	DWORD PTR _ideal$[ebp]
	fsub	DWORD PTR _current$[ebp]
	fstp	DWORD PTR _move$[ebp]

; 2526 : 
; 2527 : 		if (ideal > current)

	fld	DWORD PTR _ideal$[ebp]
	fcomp	DWORD PTR _current$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40572

; 2529 : 			if (move >= 180)

	fld	DWORD PTR _move$[ebp]
	fcomp	DWORD PTR __real@4@4006b400000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40573

; 2530 : 				move = move - 360;

	fld	DWORD PTR _move$[ebp]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _move$[ebp]
$L40573:

; 2532 : 		else

	jmp	SHORT $L40575
$L40572:

; 2534 : 			if (move <= -180)

	fld	DWORD PTR _move$[ebp]
	fcomp	DWORD PTR __real@4@c006b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40575

; 2535 : 				move = move + 360;

	fld	DWORD PTR _move$[ebp]
	fadd	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _move$[ebp]
$L40575:

; 2537 : 
; 2538 : 		if (move > 0)

	fld	DWORD PTR _move$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40576

; 2540 : 			if (move > speed)

	fld	DWORD PTR _move$[ebp]
	fcomp	DWORD PTR _speed$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40577

; 2541 : 				move = speed;

	mov	edx, DWORD PTR _speed$[ebp]
	mov	DWORD PTR _move$[ebp], edx
$L40577:

; 2543 : 		else

	jmp	SHORT $L40579
$L40576:

; 2545 : 			if (move < -speed)

	fld	DWORD PTR _speed$[ebp]
	fchs
	fcomp	DWORD PTR _move$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40579

; 2546 : 				move = -speed;

	fld	DWORD PTR _speed$[ebp]
	fchs
	fstp	DWORD PTR _move$[ebp]
$L40579:

; 2548 : 		
; 2549 : 		angles.y = UTIL_AngleMod (current + move);

	fld	DWORD PTR _current$[ebp]
	fadd	DWORD PTR _move$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?UTIL_AngleMod@@YAMM@Z			; UTIL_AngleMod
	add	esp, 4
	fstp	DWORD PTR _angles$[ebp+4]

; 2550 : 
; 2551 : 		// turn head in desired direction only if they have a turnable head
; 2552 : 		if (m_afCapability & bits_CAP_TURN_HEAD)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2304]
	and	ecx, 1024				; 00000400H
	test	ecx, ecx
	je	SHORT $L40580

; 2554 : 			float yaw = pev->ideal_yaw - angles.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+172]
	fsub	DWORD PTR _angles$[ebp+4]
	fstp	DWORD PTR _yaw$40581[ebp]

; 2555 : 			if (yaw > 180) yaw -= 360;

	fld	DWORD PTR _yaw$40581[ebp]
	fcomp	DWORD PTR __real@4@4006b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40582
	fld	DWORD PTR _yaw$40581[ebp]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _yaw$40581[ebp]
$L40582:

; 2556 : 			if (yaw < -180) yaw += 360;

	fld	DWORD PTR _yaw$40581[ebp]
	fcomp	DWORD PTR __real@4@c006b400000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40583
	fld	DWORD PTR _yaw$40581[ebp]
	fadd	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _yaw$40581[ebp]
$L40583:

; 2557 : 			// yaw *= 0.8;
; 2558 : 			SetBoneController( 0, yaw );

	mov	ecx, DWORD PTR _yaw$40581[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBoneController@CBaseAnimating@@QAEMHM@Z ; CBaseAnimating::SetBoneController
	fstp	ST(0)
$L40580:

; 2560 : 
; 2561 : 		SetAbsAngles( angles );

	lea	edx, DWORD PTR _angles$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 2563 : 	else

	jmp	SHORT $L40584
$L40570:

; 2564 : 		move = 0;

	mov	DWORD PTR _move$[ebp], 0
$L40584:

; 2565 : 
; 2566 : 	return move;

	fld	DWORD PTR _move$[ebp]

; 2567 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeYaw@CBaseMonster@@UAEMH@Z ENDP			; CBaseMonster::ChangeYaw
_TEXT	ENDS
PUBLIC	?VecToYaw@CBaseMonster@@QAEMVVector@@@Z		; CBaseMonster::VecToYaw
;	COMDAT ?VecToYaw@CBaseMonster@@QAEMVVector@@@Z
_TEXT	SEGMENT
_vecDir$ = 8
_this$ = -4
?VecToYaw@CBaseMonster@@QAEMVVector@@@Z PROC NEAR	; CBaseMonster::VecToYaw, COMDAT

; 2574 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2575 : 	if (vecDir.x == 0 && vecDir.y == 0 && vecDir.z == 0)

	fld	DWORD PTR _vecDir$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40589
	fld	DWORD PTR _vecDir$[ebp+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40589
	fld	DWORD PTR _vecDir$[ebp+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40589

; 2576 : 		return GetAbsAngles().y;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	fld	DWORD PTR [eax+4]
	jmp	SHORT $L40588
$L40589:

; 2577 : 
; 2578 : 	return UTIL_VecToYaw( vecDir );

	lea	eax, DWORD PTR _vecDir$[ebp]
	push	eax
	call	?UTIL_VecToYaw@@YAMABVVector@@@Z	; UTIL_VecToYaw
	add	esp, 4
$L40588:

; 2579 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?VecToYaw@CBaseMonster@@QAEMVVector@@@Z ENDP		; CBaseMonster::VecToYaw
_TEXT	ENDS
PUBLIC	??_C@_0BF@BCJE@?$CFs?5has?5no?5view_ofs?$CB?6?$AA@ ; `string'
EXTRN	?GetEyePosition@@YAHPAXAAVVector@@@Z:NEAR	; GetEyePosition
;	COMDAT ??_C@_0BF@BCJE@?$CFs?5has?5no?5view_ofs?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BF@BCJE@?$CFs?5has?5no?5view_ofs?$CB?6?$AA@ DB '%s has no view_ofs'
	DB	'!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?SetEyePosition@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_vecEyePosition$ = -16
_pmodel$ = -20
?SetEyePosition@CBaseMonster@@QAEXXZ PROC NEAR		; CBaseMonster::SetEyePosition, COMDAT

; 2590 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2591 : 	Vector  vecEyePosition;

	lea	ecx, DWORD PTR _vecEyePosition$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2592 : 	void	*pmodel = GET_MODEL_PTR( ENT(pev) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+296
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax

; 2593 : 
; 2594 : 	if( GetEyePosition( pmodel, vecEyePosition ))

	lea	edx, DWORD PTR _vecEyePosition$[ebp]
	push	edx
	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	call	?GetEyePosition@@YAHPAXAAVVector@@@Z	; GetEyePosition
	add	esp, 8
	test	eax, eax
	je	SHORT $L40596

; 2596 : 		pev->view_ofs = vecEyePosition;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 372				; 00000174H
	mov	eax, DWORD PTR _vecEyePosition$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _vecEyePosition$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _vecEyePosition$[ebp+8]
	mov	DWORD PTR [edx+8], eax

; 2598 : 	else

	jmp	SHORT $L40597
$L40596:

; 2600 : 		ALERT ( at_aiconsole, "%s has no view_ofs!\n", STRING ( pev->classname ) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BF@BCJE@?$CFs?5has?5no?5view_ofs?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L40597:

; 2602 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetEyePosition@CBaseMonster@@QAEXXZ ENDP		; CBaseMonster::SetEyePosition
_TEXT	ENDS
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	?StepSound@CBaseMonster@@UAEXXZ			; CBaseMonster::StepSound
PUBLIC	??_C@_0BE@DAFA@player?1pl_step1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@HABK@player?1pl_step3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@NADP@player?1pl_step2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@BAOA@player?1pl_step4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@LBED@player?1pl_metal1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@PBAJ@player?1pl_metal3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@FBCM@player?1pl_metal2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@JBPD@player?1pl_metal4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@IGBB@player?1pl_dirt1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@MGFL@player?1pl_dirt3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@GGHO@player?1pl_dirt2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@KGKB@player?1pl_dirt4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@KCPJ@player?1pl_duct1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@OCLD@player?1pl_duct3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@ECJG@player?1pl_duct2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@ICEJ@player?1pl_duct4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@BEOK@player?1pl_grate1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@FEKA@player?1pl_grate3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@PEIF@player?1pl_grate2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@DEFK@player?1pl_grate4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@BHLL@player?1pl_tile1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@FHPB@player?1pl_tile3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@PHNE@player?1pl_tile2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@DHAL@player?1pl_tile4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@JHCO@player?1pl_tile5?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@DKOO@player?1pl_slosh1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@HKKE@player?1pl_slosh3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@NKIB@player?1pl_slosh2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@BKFO@player?1pl_slosh4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@IIKC@common?1npc_step1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@GIMN@common?1npc_step2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@MIOI@common?1npc_step3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@KIBC@common?1npc_step4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@CEPA@player?1pl_wade3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@EEAK@player?1pl_wade4?4wav?$AA@	; `string'
EXTRN	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z:NEAR	; EMIT_SOUND_DYN
EXTRN	?PM_FindTextureType@@YADPAD@Z:NEAR		; PM_FindTextureType
EXTRN	_memset:NEAR
EXTRN	_strcpy:NEAR
;	COMDAT ??_C@_0BE@DAFA@player?1pl_step1?4wav?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BE@DAFA@player?1pl_step1?4wav?$AA@ DB 'player/pl_step1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HABK@player?1pl_step3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@HABK@player?1pl_step3?4wav?$AA@ DB 'player/pl_step3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NADP@player?1pl_step2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@NADP@player?1pl_step2?4wav?$AA@ DB 'player/pl_step2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BAOA@player?1pl_step4?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@BAOA@player?1pl_step4?4wav?$AA@ DB 'player/pl_step4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LBED@player?1pl_metal1?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@LBED@player?1pl_metal1?4wav?$AA@ DB 'player/pl_metal1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PBAJ@player?1pl_metal3?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@PBAJ@player?1pl_metal3?4wav?$AA@ DB 'player/pl_metal3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FBCM@player?1pl_metal2?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@FBCM@player?1pl_metal2?4wav?$AA@ DB 'player/pl_metal2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JBPD@player?1pl_metal4?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@JBPD@player?1pl_metal4?4wav?$AA@ DB 'player/pl_metal4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IGBB@player?1pl_dirt1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@IGBB@player?1pl_dirt1?4wav?$AA@ DB 'player/pl_dirt1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGFL@player?1pl_dirt3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@MGFL@player?1pl_dirt3?4wav?$AA@ DB 'player/pl_dirt3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGHO@player?1pl_dirt2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@GGHO@player?1pl_dirt2?4wav?$AA@ DB 'player/pl_dirt2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KGKB@player?1pl_dirt4?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@KGKB@player?1pl_dirt4?4wav?$AA@ DB 'player/pl_dirt4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KCPJ@player?1pl_duct1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@KCPJ@player?1pl_duct1?4wav?$AA@ DB 'player/pl_duct1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OCLD@player?1pl_duct3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@OCLD@player?1pl_duct3?4wav?$AA@ DB 'player/pl_duct3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ECJG@player?1pl_duct2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@ECJG@player?1pl_duct2?4wav?$AA@ DB 'player/pl_duct2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ICEJ@player?1pl_duct4?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@ICEJ@player?1pl_duct4?4wav?$AA@ DB 'player/pl_duct4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BEOK@player?1pl_grate1?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@BEOK@player?1pl_grate1?4wav?$AA@ DB 'player/pl_grate1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FEKA@player?1pl_grate3?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@FEKA@player?1pl_grate3?4wav?$AA@ DB 'player/pl_grate3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PEIF@player?1pl_grate2?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@PEIF@player?1pl_grate2?4wav?$AA@ DB 'player/pl_grate2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DEFK@player?1pl_grate4?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@DEFK@player?1pl_grate4?4wav?$AA@ DB 'player/pl_grate4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BHLL@player?1pl_tile1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@BHLL@player?1pl_tile1?4wav?$AA@ DB 'player/pl_tile1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FHPB@player?1pl_tile3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@FHPB@player?1pl_tile3?4wav?$AA@ DB 'player/pl_tile3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PHNE@player?1pl_tile2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@PHNE@player?1pl_tile2?4wav?$AA@ DB 'player/pl_tile2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DHAL@player?1pl_tile4?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@DHAL@player?1pl_tile4?4wav?$AA@ DB 'player/pl_tile4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JHCO@player?1pl_tile5?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@JHCO@player?1pl_tile5?4wav?$AA@ DB 'player/pl_tile5.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DKOO@player?1pl_slosh1?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@DKOO@player?1pl_slosh1?4wav?$AA@ DB 'player/pl_slosh1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HKKE@player?1pl_slosh3?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@HKKE@player?1pl_slosh3?4wav?$AA@ DB 'player/pl_slosh3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NKIB@player?1pl_slosh2?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@NKIB@player?1pl_slosh2?4wav?$AA@ DB 'player/pl_slosh2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BKFO@player?1pl_slosh4?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@BKFO@player?1pl_slosh4?4wav?$AA@ DB 'player/pl_slosh4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IIKC@common?1npc_step1?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@IIKC@common?1npc_step1?4wav?$AA@ DB 'common/npc_step1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GIMN@common?1npc_step2?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@GIMN@common?1npc_step2?4wav?$AA@ DB 'common/npc_step2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MIOI@common?1npc_step3?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@MIOI@common?1npc_step3?4wav?$AA@ DB 'common/npc_step3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KIBC@common?1npc_step4?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@KIBC@common?1npc_step4?4wav?$AA@ DB 'common/npc_step4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@ DB 'player/pl_wade1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CEPA@player?1pl_wade3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@CEPA@player?1pl_wade3?4wav?$AA@ DB 'player/pl_wade3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@ DB 'player/pl_wade2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EEAK@player?1pl_wade4?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@EEAK@player?1pl_wade4?4wav?$AA@ DB 'player/pl_wade4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?StepSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
$T42280 = -196
$T42281 = -208
$T42282 = -220
$T42283 = -232
$T42284 = -244
$T42285 = -256
$T42286 = -268
$T42287 = -280
_this$ = -4
_chTextureType$ = -8
_fvol$ = -12
_szbuffer$ = -76
_rgsz$ = -108
_pTextureName$ = -112
_ptr$ = -168
_fattn$ = -172
_fWalking$ = -176
_cnt$ = -180
_pEntity$ = -184
?StepSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::StepSound, COMDAT

; 2611 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 420				; 000001a4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2612 : 	char chTextureType;
; 2613 : 	float fvol;
; 2614 : 	char szbuffer[64];
; 2615 : 	char *rgsz[8];
; 2616 : 	const char *pTextureName;
; 2617 : 	TraceResult ptr;

	lea	ecx, DWORD PTR _ptr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 2618 : 	float fattn = ATTN_NORM;

	mov	DWORD PTR _fattn$[ebp], 1061997773	; 3f4ccccdH

; 2619 : 	int fWalking;
; 2620 : 	int cnt;
; 2621 : 
; 2622 : 	UTIL_TraceLine( pev->origin + Vector( 0, 0, 8 ), pev->origin - Vector( 0, 0, 16 ), ignore_monsters, ENT( pev ), &ptr );

	lea	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	push	1098907648				; 41800000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T42280[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T42281[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 8
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	push	1090519040				; 41000000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T42282[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	edx, DWORD PTR $T42283[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 2623 : 	CBaseEntity *pEntity = CBaseEntity::Instance(ptr.pHit);

	mov	ecx, DWORD PTR _ptr$[ebp+48]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 2624 : 
; 2625 : 	memset( rgsz, 0, sizeof( rgsz ));

	push	32					; 00000020H
	push	0
	lea	edx, DWORD PTR _rgsz$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 2626 : 	pTextureName = NULL;// assume invalid

	mov	DWORD PTR _pTextureName$[ebp], 0

; 2627 : 	chTextureType = 0;	// defaulting to NPC step sounds

	mov	BYTE PTR _chTextureType$[ebp], 0

; 2628 : 
; 2629 : 	if ( pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	$L40618

; 2630 : 		pTextureName = TRACE_TEXTURE( ENT( pEntity->pev ), pev->origin + Vector( 0, 0, 8 ), pev->origin - Vector( 0, 0, 16 ));

	push	1098907648				; 41800000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T42284[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T42285[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 8
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	push	1090519040				; 41000000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T42286[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	edx, DWORD PTR $T42287[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+144
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTextureName$[ebp], eax
$L40618:

; 2631 : 
; 2632 : 	if( pTextureName )

	cmp	DWORD PTR _pTextureName$[ebp], 0
	je	SHORT $L40623

; 2634 : 		// strip leading '-0' or '+0~' or '{' or '!' 
; 2635 : 		if ( *pTextureName == '-' || *pTextureName == '+' )

	mov	eax, DWORD PTR _pTextureName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $L40625
	mov	edx, DWORD PTR _pTextureName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $L40624
$L40625:

; 2636 : 			pTextureName += 2;

	mov	ecx, DWORD PTR _pTextureName$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pTextureName$[ebp], ecx
$L40624:

; 2637 : 
; 2638 : 		if ( *pTextureName == '{' || *pTextureName == '!' || *pTextureName == '~' || *pTextureName == ' ' )

	mov	edx, DWORD PTR _pTextureName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 123				; 0000007bH
	je	SHORT $L40627
	mov	ecx, DWORD PTR _pTextureName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 33					; 00000021H
	je	SHORT $L40627
	mov	eax, DWORD PTR _pTextureName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 126				; 0000007eH
	je	SHORT $L40627
	mov	edx, DWORD PTR _pTextureName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $L40626
$L40627:

; 2639 : 			pTextureName++;

	mov	ecx, DWORD PTR _pTextureName$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pTextureName$[ebp], ecx
$L40626:

; 2640 : 		// '}}' 
; 2641 : 		strcpy( szbuffer, pTextureName );

	mov	edx, DWORD PTR _pTextureName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szbuffer$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2642 : 		szbuffer[CBTEXTURENAMEMAX - 1] = 0;

	mov	BYTE PTR _szbuffer$[ebp+12], 0

; 2643 : 
; 2644 : 		// get texture type 
; 2645 : 		chTextureType = PM_FindTextureType( szbuffer );

	lea	ecx, DWORD PTR _szbuffer$[ebp]
	push	ecx
	call	?PM_FindTextureType@@YADPAD@Z		; PM_FindTextureType
	add	esp, 4
	mov	BYTE PTR _chTextureType$[ebp], al
$L40623:

; 2647 : 
; 2648 : 	if ( m_Activity == ACT_WALK )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2068], 3
	jne	SHORT $L40628

; 2649 : 		fWalking = true;

	mov	DWORD PTR _fWalking$[ebp], 1

; 2650 : 	else fWalking = false;	

	jmp	SHORT $L40629
$L40628:
	mov	DWORD PTR _fWalking$[ebp], 0
$L40629:

; 2653 : 	{

	movsx	eax, BYTE PTR _chTextureType$[ebp]
	mov	DWORD PTR -284+[ebp], eax
	mov	ecx, DWORD PTR -284+[ebp]
	sub	ecx, 67					; 00000043H
	mov	DWORD PTR -284+[ebp], ecx
	cmp	DWORD PTR -284+[ebp], 19		; 00000013H
	ja	$L40670
	mov	eax, DWORD PTR -284+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L42306[eax]
	jmp	DWORD PTR $L42307[edx*4]
$L40634:

; 2654 : 	case CHAR_TEX_CONCRETE:
; 2655 : 		fvol = fWalking ? 0.2 : 0.5;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $L42288
	mov	DWORD PTR -292+[ebp], -1717986918	; 9999999aH
	mov	DWORD PTR -292+[ebp+4], 1070176665	; 3fc99999H
	jmp	SHORT $L42289
$L42288:
	mov	DWORD PTR -292+[ebp], 0
	mov	DWORD PTR -292+[ebp+4], 1071644672	; 3fe00000H
$L42289:
	fld	QWORD PTR -292+[ebp]
	fstp	DWORD PTR _fvol$[ebp]

; 2656 : 		rgsz[0] = "player/pl_step1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BE@DAFA@player?1pl_step1?4wav?$AA@ ; `string'

; 2657 : 		rgsz[1] = "player/pl_step3.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BE@HABK@player?1pl_step3?4wav?$AA@ ; `string'

; 2658 : 		rgsz[2] = "player/pl_step2.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BE@NADP@player?1pl_step2?4wav?$AA@ ; `string'

; 2659 : 		rgsz[3] = "player/pl_step4.wav";

	mov	DWORD PTR _rgsz$[ebp+12], OFFSET FLAT:??_C@_0BE@BAOA@player?1pl_step4?4wav?$AA@ ; `string'

; 2660 : 		cnt = 4;

	mov	DWORD PTR _cnt$[ebp], 4

; 2661 : 		break;

	jmp	$L40631
$L40639:

; 2662 : 	case CHAR_TEX_METAL:
; 2663 : 		fvol = fWalking ? 0.2 : 0.5;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $L42290
	mov	DWORD PTR -300+[ebp], -1717986918	; 9999999aH
	mov	DWORD PTR -300+[ebp+4], 1070176665	; 3fc99999H
	jmp	SHORT $L42291
$L42290:
	mov	DWORD PTR -300+[ebp], 0
	mov	DWORD PTR -300+[ebp+4], 1071644672	; 3fe00000H
$L42291:
	fld	QWORD PTR -300+[ebp]
	fstp	DWORD PTR _fvol$[ebp]

; 2664 : 		rgsz[0] = "player/pl_metal1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BF@LBED@player?1pl_metal1?4wav?$AA@ ; `string'

; 2665 : 		rgsz[1] = "player/pl_metal3.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BF@PBAJ@player?1pl_metal3?4wav?$AA@ ; `string'

; 2666 : 		rgsz[2] = "player/pl_metal2.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BF@FBCM@player?1pl_metal2?4wav?$AA@ ; `string'

; 2667 : 		rgsz[3] = "player/pl_metal4.wav";

	mov	DWORD PTR _rgsz$[ebp+12], OFFSET FLAT:??_C@_0BF@JBPD@player?1pl_metal4?4wav?$AA@ ; `string'

; 2668 : 		cnt = 4;

	mov	DWORD PTR _cnt$[ebp], 4

; 2669 : 		break;

	jmp	$L40631
$L40644:

; 2670 : 	case CHAR_TEX_DIRT:
; 2671 : 		fvol = fWalking ? 0.25 : 0.55;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $L42292
	mov	DWORD PTR -308+[ebp], 0
	mov	DWORD PTR -308+[ebp+4], 1070596096	; 3fd00000H
	jmp	SHORT $L42293
$L42292:
	mov	DWORD PTR -308+[ebp], -1717986918	; 9999999aH
	mov	DWORD PTR -308+[ebp+4], 1071749529	; 3fe19999H
$L42293:
	fld	QWORD PTR -308+[ebp]
	fstp	DWORD PTR _fvol$[ebp]

; 2672 : 		rgsz[0] = "player/pl_dirt1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BE@IGBB@player?1pl_dirt1?4wav?$AA@ ; `string'

; 2673 : 		rgsz[1] = "player/pl_dirt3.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BE@MGFL@player?1pl_dirt3?4wav?$AA@ ; `string'

; 2674 : 		rgsz[2] = "player/pl_dirt2.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BE@GGHO@player?1pl_dirt2?4wav?$AA@ ; `string'

; 2675 : 		rgsz[3] = "player/pl_dirt4.wav";

	mov	DWORD PTR _rgsz$[ebp+12], OFFSET FLAT:??_C@_0BE@KGKB@player?1pl_dirt4?4wav?$AA@ ; `string'

; 2676 : 		cnt = 4;

	mov	DWORD PTR _cnt$[ebp], 4

; 2677 : 		break;

	jmp	$L40631
$L40649:

; 2678 : 	case CHAR_TEX_VENT:
; 2679 : 		fvol = fWalking ? 0.4 : 0.7;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $L42294
	mov	DWORD PTR -316+[ebp], -1717986918	; 9999999aH
	mov	DWORD PTR -316+[ebp+4], 1071225241	; 3fd99999H
	jmp	SHORT $L42295
$L42294:
	mov	DWORD PTR -316+[ebp], 1717986918	; 66666666H
	mov	DWORD PTR -316+[ebp+4], 1072064102	; 3fe66666H
$L42295:
	fld	QWORD PTR -316+[ebp]
	fstp	DWORD PTR _fvol$[ebp]

; 2680 : 		rgsz[0] = "player/pl_duct1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BE@KCPJ@player?1pl_duct1?4wav?$AA@ ; `string'

; 2681 : 		rgsz[1] = "player/pl_duct3.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BE@OCLD@player?1pl_duct3?4wav?$AA@ ; `string'

; 2682 : 		rgsz[2] = "player/pl_duct2.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BE@ECJG@player?1pl_duct2?4wav?$AA@ ; `string'

; 2683 : 		rgsz[3] = "player/pl_duct4.wav";

	mov	DWORD PTR _rgsz$[ebp+12], OFFSET FLAT:??_C@_0BE@ICEJ@player?1pl_duct4?4wav?$AA@ ; `string'

; 2684 : 		cnt = 4;

	mov	DWORD PTR _cnt$[ebp], 4

; 2685 : 		break;

	jmp	$L40631
$L40654:

; 2686 : 	case CHAR_TEX_GRATE:
; 2687 : 		fvol = fWalking ? 0.2 : 0.5;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $L42296
	mov	DWORD PTR -324+[ebp], -1717986918	; 9999999aH
	mov	DWORD PTR -324+[ebp+4], 1070176665	; 3fc99999H
	jmp	SHORT $L42297
$L42296:
	mov	DWORD PTR -324+[ebp], 0
	mov	DWORD PTR -324+[ebp+4], 1071644672	; 3fe00000H
$L42297:
	fld	QWORD PTR -324+[ebp]
	fstp	DWORD PTR _fvol$[ebp]

; 2688 : 		rgsz[0] = "player/pl_grate1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BF@BEOK@player?1pl_grate1?4wav?$AA@ ; `string'

; 2689 : 		rgsz[1] = "player/pl_grate3.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BF@FEKA@player?1pl_grate3?4wav?$AA@ ; `string'

; 2690 : 		rgsz[2] = "player/pl_grate2.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BF@PEIF@player?1pl_grate2?4wav?$AA@ ; `string'

; 2691 : 		rgsz[3] = "player/pl_grate4.wav";

	mov	DWORD PTR _rgsz$[ebp+12], OFFSET FLAT:??_C@_0BF@DEFK@player?1pl_grate4?4wav?$AA@ ; `string'

; 2692 : 		cnt = 4;

	mov	DWORD PTR _cnt$[ebp], 4

; 2693 : 		break;

	jmp	$L40631
$L40659:

; 2694 : 	case CHAR_TEX_TILE:
; 2695 : 		fvol = fWalking ? 0.2 : 0.5;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $L42298
	mov	DWORD PTR -332+[ebp], -1717986918	; 9999999aH
	mov	DWORD PTR -332+[ebp+4], 1070176665	; 3fc99999H
	jmp	SHORT $L42299
$L42298:
	mov	DWORD PTR -332+[ebp], 0
	mov	DWORD PTR -332+[ebp+4], 1071644672	; 3fe00000H
$L42299:
	fld	QWORD PTR -332+[ebp]
	fstp	DWORD PTR _fvol$[ebp]

; 2696 : 		rgsz[0] = "player/pl_tile1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BE@BHLL@player?1pl_tile1?4wav?$AA@ ; `string'

; 2697 : 		rgsz[1] = "player/pl_tile3.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BE@FHPB@player?1pl_tile3?4wav?$AA@ ; `string'

; 2698 : 		rgsz[2] = "player/pl_tile2.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BE@PHNE@player?1pl_tile2?4wav?$AA@ ; `string'

; 2699 : 		rgsz[3] = "player/pl_tile4.wav";

	mov	DWORD PTR _rgsz$[ebp+12], OFFSET FLAT:??_C@_0BE@DHAL@player?1pl_tile4?4wav?$AA@ ; `string'

; 2700 : 		rgsz[4] = "player/pl_tile5.wav";

	mov	DWORD PTR _rgsz$[ebp+16], OFFSET FLAT:??_C@_0BE@JHCO@player?1pl_tile5?4wav?$AA@ ; `string'

; 2701 : 		cnt = 5;

	mov	DWORD PTR _cnt$[ebp], 5

; 2702 : 		break;

	jmp	$L40631
$L40665:

; 2703 : 	case CHAR_TEX_SLOSH:
; 2704 : 		fvol = fWalking ? 0.2 : 0.5;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $L42300
	mov	DWORD PTR -340+[ebp], -1717986918	; 9999999aH
	mov	DWORD PTR -340+[ebp+4], 1070176665	; 3fc99999H
	jmp	SHORT $L42301
$L42300:
	mov	DWORD PTR -340+[ebp], 0
	mov	DWORD PTR -340+[ebp+4], 1071644672	; 3fe00000H
$L42301:
	fld	QWORD PTR -340+[ebp]
	fstp	DWORD PTR _fvol$[ebp]

; 2705 : 		rgsz[0] = "player/pl_slosh1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BF@DKOO@player?1pl_slosh1?4wav?$AA@ ; `string'

; 2706 : 		rgsz[1] = "player/pl_slosh3.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BF@HKKE@player?1pl_slosh3?4wav?$AA@ ; `string'

; 2707 : 		rgsz[2] = "player/pl_slosh2.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BF@NKIB@player?1pl_slosh2?4wav?$AA@ ; `string'

; 2708 : 		rgsz[3] = "player/pl_slosh4.wav";

	mov	DWORD PTR _rgsz$[ebp+12], OFFSET FLAT:??_C@_0BF@BKFO@player?1pl_slosh4?4wav?$AA@ ; `string'

; 2709 : 		cnt = 4;

	mov	DWORD PTR _cnt$[ebp], 4

; 2710 : 		break;

	jmp	SHORT $L40631
$L40670:

; 2711 : 	default:	// default NPC sounds
; 2712 : 		fvol = fWalking ? 0.2 : 0.5;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $L42302
	mov	DWORD PTR -348+[ebp], -1717986918	; 9999999aH
	mov	DWORD PTR -348+[ebp+4], 1070176665	; 3fc99999H
	jmp	SHORT $L42303
$L42302:
	mov	DWORD PTR -348+[ebp], 0
	mov	DWORD PTR -348+[ebp+4], 1071644672	; 3fe00000H
$L42303:
	fld	QWORD PTR -348+[ebp]
	fstp	DWORD PTR _fvol$[ebp]

; 2713 : 		rgsz[0] = "common/npc_step1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BF@IIKC@common?1npc_step1?4wav?$AA@ ; `string'

; 2714 : 		rgsz[1] = "common/npc_step2.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BF@GIMN@common?1npc_step2?4wav?$AA@ ; `string'

; 2715 : 		rgsz[2] = "common/npc_step3.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BF@MIOI@common?1npc_step3?4wav?$AA@ ; `string'

; 2716 : 		rgsz[3] = "common/npc_step4.wav";

	mov	DWORD PTR _rgsz$[ebp+12], OFFSET FLAT:??_C@_0BF@KIBC@common?1npc_step4?4wav?$AA@ ; `string'

; 2717 : 		cnt = 4;

	mov	DWORD PTR _cnt$[ebp], 4
$L40631:

; 2720 : 
; 2721 : 	// wading in the water
; 2722 : 	if( pev->waterlevel == 1 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+448], 1
	jne	SHORT $L40675

; 2724 : 		fvol = fWalking ? 0.2 : 0.5;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $L42304
	mov	DWORD PTR -356+[ebp], -1717986918	; 9999999aH
	mov	DWORD PTR -356+[ebp+4], 1070176665	; 3fc99999H
	jmp	SHORT $L42305
$L42304:
	mov	DWORD PTR -356+[ebp], 0
	mov	DWORD PTR -356+[ebp+4], 1071644672	; 3fe00000H
$L42305:
	fld	QWORD PTR -356+[ebp]
	fstp	DWORD PTR _fvol$[ebp]

; 2725 : 		rgsz[0] = "player/pl_wade1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@ ; `string'

; 2726 : 		rgsz[1] = "player/pl_wade3.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BE@CEPA@player?1pl_wade3?4wav?$AA@ ; `string'

; 2727 : 		rgsz[2] = "player/pl_wade2.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@ ; `string'

; 2728 : 		rgsz[3] = "player/pl_wade4.wav";

	mov	DWORD PTR _rgsz$[ebp+12], OFFSET FLAT:??_C@_0BE@EEAK@player?1pl_wade4?4wav?$AA@ ; `string'

; 2729 : 		cnt = 4;

	mov	DWORD PTR _cnt$[ebp], 4
$L40675:

; 2731 : 
; 2732 : 	EMIT_SOUND_DYN( ENT( pev ), CHAN_BODY, rgsz[RANDOM_LONG(0, cnt-1)], fvol, fattn, 0, 96 + RANDOM_LONG( 0, 0xf ));

	push	15					; 0000000fH
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 96					; 00000060H
	push	eax
	push	0
	mov	eax, DWORD PTR _fattn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fvol$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cnt$[ebp]
	sub	edx, 1
	push	edx
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	eax, DWORD PTR _rgsz$[ebp+eax*4]
	push	eax
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 2733 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L42307:
	DD	$L40634
	DD	$L40644
	DD	$L40654
	DD	$L40639
	DD	$L40665
	DD	$L40659
	DD	$L40649
	DD	$L40670
$L42306:
	DB	0
	DB	1
	DB	7
	DB	7
	DB	2
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	3
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	4
	DB	5
	DB	7
	DB	6
?StepSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::StepSound
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
PUBLIC	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z		; EMIT_SOUND
PUBLIC	??_C@_0BB@KDHF@Death?5event?3?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0BI@HNIC@INVALID?5death?5event?3?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@ECKG@common?1npc_step?$AA@		; `string'
PUBLIC	??_C@_0BF@JCJ@common?1bodydrop3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@GJND@common?1bodydrop4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BG@CPHF@zombie?1claw_miss2?4wav?$AA@	; `string'
PUBLIC	??_C@_0CF@GMHE@Unhandled?5animation?5event?5?$CFd?5for@ ; `string'
PUBLIC	?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z ; CBaseMonster::HandleAnimEvent
EXTRN	?AllowInterrupt@CCineMonster@@QAEXH@Z:NEAR	; CCineMonster::AllowInterrupt
EXTRN	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z:NEAR ; SENTENCEG_PlayRndSz
EXTRN	?Q_strnicmp@@YAHPBD0H@Z:NEAR			; Q_strnicmp
EXTRN	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z:NEAR ; UTIL_FireTargets
;	COMDAT ??_C@_0BB@KDHF@Death?5event?3?5?$CFs?6?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BB@KDHF@Death?5event?3?5?$CFs?6?$AA@ DB 'Death event: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HNIC@INVALID?5death?5event?3?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BI@HNIC@INVALID?5death?5event?3?$CFs?6?$AA@ DB 'INVALID death even'
	DB	't:%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ECKG@common?1npc_step?$AA@
CONST	SEGMENT
??_C@_0BA@ECKG@common?1npc_step?$AA@ DB 'common/npc_step', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JCJ@common?1bodydrop3?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@JCJ@common?1bodydrop3?4wav?$AA@ DB 'common/bodydrop3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GJND@common?1bodydrop4?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@GJND@common?1bodydrop4?4wav?$AA@ DB 'common/bodydrop4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CPHF@zombie?1claw_miss2?4wav?$AA@
CONST	SEGMENT
??_C@_0BG@CPHF@zombie?1claw_miss2?4wav?$AA@ DB 'zombie/claw_miss2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GMHE@Unhandled?5animation?5event?5?$CFd?5for@
CONST	SEGMENT
??_C@_0CF@GMHE@Unhandled?5animation?5event?5?$CFd?5for@ DB 'Unhandled ani'
	DB	'mation event %d for %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT
_pEvent$ = 8
_this$ = -4
?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z PROC NEAR ; CBaseMonster::HandleAnimEvent, COMDAT

; 2736 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2738 : 	{

	mov	eax, DWORD PTR _pEvent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR -8+[ebp], ecx
	cmp	DWORD PTR -8+[ebp], 2001		; 000007d1H
	jg	SHORT $L42312
	cmp	DWORD PTR -8+[ebp], 2001		; 000007d1H
	je	$L40719
	mov	edx, DWORD PTR -8+[ebp]
	sub	edx, 1000				; 000003e8H
	mov	DWORD PTR -8+[ebp], edx
	cmp	DWORD PTR -8+[ebp], 10			; 0000000aH
	ja	$L40728
	mov	eax, DWORD PTR -8+[ebp]
	jmp	DWORD PTR $L42313[eax*4]
$L42312:
	cmp	DWORD PTR -8+[ebp], 2002		; 000007d2H
	je	$L40711
	cmp	DWORD PTR -8+[ebp], 2010		; 000007daH
	je	$L40725
	jmp	$L40728
$L40688:

; 2739 : 	case SCRIPT_EVENT_DEAD:
; 2740 : 		if ( m_MonsterState == MONSTERSTATE_SCRIPT )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2080], 6
	jne	SHORT $L40689

; 2742 : 			pev->deadflag = DEAD_DYING;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+368], 1

; 2743 : 			// Kill me now! (and fade out when CineCleanup() is called)
; 2744 : #if _DEBUG
; 2745 : 			ALERT( at_aiconsole, "Death event: %s\n", STRING(pev->classname) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BB@KDHF@Death?5event?3?5?$CFs?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2746 : #endif
; 2747 : 			pev->health = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+352], 0

; 2749 : #if _DEBUG
; 2750 : 		else

	jmp	SHORT $L40691
$L40689:

; 2751 : 			ALERT( at_aiconsole, "INVALID death event:%s\n", STRING(pev->classname) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BI@HNIC@INVALID?5death?5event?3?$CFs?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L40691:

; 2752 : #endif
; 2753 : 		break;

	jmp	$L40685
$L40693:

; 2754 : 	case SCRIPT_EVENT_NOT_DEAD:
; 2755 : 		if ( m_MonsterState == MONSTERSTATE_SCRIPT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2080], 6
	jne	SHORT $L40694

; 2757 : 			pev->deadflag = DEAD_NO;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+368], 0

; 2758 : 			// This is for life/death sequences where the player can determine whether a character is dead or alive after the script 
; 2759 : 			pev->health = pev->max_health;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+432]
	mov	DWORD PTR [eax+352], ecx
$L40694:

; 2761 : 		break;

	jmp	$L40685
$L40695:

; 2762 : 
; 2763 : 	case SCRIPT_EVENT_SOUND:			// Play a named wave file
; 2764 : 		if( !Q_strnicmp( pEvent->options, "common/npc_step", 15 ))

	push	15					; 0000000fH
	push	OFFSET FLAT:??_C@_0BA@ECKG@common?1npc_step?$AA@ ; `string'
	mov	edx, DWORD PTR _pEvent$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L40696

; 2765 : 			StepSound();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+608]

; 2766 : 		else EMIT_SOUND( edict(), CHAN_BODY, pEvent->options, 1.0, ATTN_IDLE );

	jmp	SHORT $L40698
$L40696:
	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _pEvent$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L40698:

; 2767 : 		break;

	jmp	$L40685
$L40700:

; 2768 : 
; 2769 : 	case SCRIPT_EVENT_SOUND_VOICE:
; 2770 : 		EMIT_SOUND( edict(), CHAN_VOICE, pEvent->options, 1.0, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	mov	edx, DWORD PTR _pEvent$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 2771 : 		break;

	jmp	$L40685
$L40702:

; 2772 : 
; 2773 : 	case SCRIPT_EVENT_SENTENCE_RND1:		// Play a named sentence group 33% of the time
; 2774 : 		if (RANDOM_LONG(0,2) == 0)

	push	2
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	jne	SHORT $L40703

; 2775 : 			break;

	jmp	$L40685
$L40703:

; 2778 : 		SENTENCEG_PlayRndSz( edict(), pEvent->options, 1.0, ATTN_IDLE, 0, 100 );

	push	100					; 00000064H
	push	0
	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _pEvent$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H

; 2779 : 		break;

	jmp	$L40685
$L40706:

; 2780 : 
; 2781 : 	case SCRIPT_EVENT_FIREEVENT:		// Fire a trigger
; 2782 : 		UTIL_FireTargets( pEvent->options, this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEvent$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 2783 : 		break;

	jmp	$L40685
$L40707:

; 2784 : 
; 2785 : 	case SCRIPT_EVENT_NOINTERRUPT:		// Can't be interrupted from now on
; 2786 : 		if ( m_pCine )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2384], 0
	je	SHORT $L40708

; 2787 : 			m_pCine->AllowInterrupt( FALSE );

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2384]
	call	?AllowInterrupt@CCineMonster@@QAEXH@Z	; CCineMonster::AllowInterrupt
$L40708:

; 2788 : 		break;

	jmp	$L40685
$L40709:

; 2789 : 
; 2790 : 	case SCRIPT_EVENT_CANINTERRUPT:		// OK to interrupt now
; 2791 : 		if ( m_pCine )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2384], 0
	je	SHORT $L40710

; 2792 : 			m_pCine->AllowInterrupt( TRUE );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+2384]
	call	?AllowInterrupt@CCineMonster@@QAEXH@Z	; CCineMonster::AllowInterrupt
$L40710:

; 2793 : 		break;

	jmp	$L40685
$L40711:

; 2794 : 
; 2795 : #if 0
; 2796 : 	case SCRIPT_EVENT_INAIR:			// Don't DROP_TO_FLOOR()
; 2797 : 	case SCRIPT_EVENT_ENDANIMATION:		// Set ending animation sequence to
; 2798 : 		break;
; 2799 : #endif
; 2800 : 
; 2801 : 	case MONSTER_EVENT_BODYDROP_HEAVY:
; 2802 : 		if ( pev->flags & FL_ONGROUND )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 512				; 00000200H
	test	ecx, ecx
	je	SHORT $L40716

; 2804 : 			if ( RANDOM_LONG( 0, 1 ) == 0 )

	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	jne	SHORT $L40713

; 2806 : 				EMIT_SOUND_DYN( ENT(pev), CHAN_BODY, "common/bodydrop3.wav", 1, ATTN_NORM, 0, 90 );

	push	90					; 0000005aH
	push	0
	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BF@JCJ@common?1bodydrop3?4wav?$AA@ ; `string'
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 2808 : 			else

	jmp	SHORT $L40716
$L40713:

; 2810 : 				EMIT_SOUND_DYN( ENT(pev), CHAN_BODY, "common/bodydrop4.wav", 1, ATTN_NORM, 0, 90 );

	push	90					; 0000005aH
	push	0
	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BF@GJND@common?1bodydrop4?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH
$L40716:

; 2813 : 		break;

	jmp	$L40685
$L40719:

; 2814 : 
; 2815 : 	case MONSTER_EVENT_BODYDROP_LIGHT:
; 2816 : 		if ( pev->flags & FL_ONGROUND )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	SHORT $L40723

; 2818 : 			if ( RANDOM_LONG( 0, 1 ) == 0 )

	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	jne	SHORT $L40721

; 2820 : 				EMIT_SOUND( ENT(pev), CHAN_BODY, "common/bodydrop3.wav", 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BF@JCJ@common?1bodydrop3?4wav?$AA@ ; `string'
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 2822 : 			else

	jmp	SHORT $L40723
$L40721:

; 2824 : 				EMIT_SOUND( ENT(pev), CHAN_BODY, "common/bodydrop4.wav", 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BF@GJND@common?1bodydrop4?4wav?$AA@ ; `string'
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L40723:

; 2827 : 		break;

	jmp	SHORT $L40685
$L40725:

; 2831 : 			// NO MONSTER may use this anim event unless that monster's precache precaches this sound!!!
; 2832 : 			EMIT_SOUND( ENT(pev), CHAN_BODY, "zombie/claw_miss2.wav", 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BG@CPHF@zombie?1claw_miss2?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 2833 : 			break;

	jmp	SHORT $L40685
$L40728:

; 2835 : 
; 2836 : 	default:
; 2837 : 		ALERT( at_aiconsole, "Unhandled animation event %d for %s\n", pEvent->event, STRING(pev->classname) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pEvent$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET FLAT:??_C@_0CF@GMHE@Unhandled?5animation?5event?5?$CFd?5for@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H
$L40685:

; 2841 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L42313:
	DD	$L40688
	DD	$L40707
	DD	$L40709
	DD	$L40706
	DD	$L40695
	DD	$L40703
	DD	$L40728
	DD	$L40728
	DD	$L40700
	DD	$L40702
	DD	$L40693
?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z ENDP ; CBaseMonster::HandleAnimEvent
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
_volume$ = 20
_attenuation$ = 24
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z PROC NEAR		; EMIT_SOUND, COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 610  : 	EMIT_SOUND_DYN( entity, channel, sample, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 611  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z ENDP		; EMIT_SOUND
_TEXT	ENDS
PUBLIC	?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ	; CBaseMonster::GetGunPosition
;	COMDAT ?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ
_TEXT	SEGMENT
$T42318 = -28
$T42319 = -40
$T42320 = -52
$T42321 = -64
$T42322 = -76
$T42323 = -88
___$ReturnUdt$ = 8
_this$ = -4
_vecSrc$ = -16
?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ PROC NEAR ; CBaseMonster::GetGunPosition, COMDAT

; 2847 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2848 : 	UTIL_MakeVectors(GetAbsAngles());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 2849 : 
; 2850 : 	Vector vecSrc = GetAbsOrigin() + gpGlobals->v_forward * m_HackedGunPos.y 
; 2851 : 				 + gpGlobals->v_right * m_HackedGunPos.x 
; 2852 : 				 + gpGlobals->v_up * m_HackedGunPos.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2372]
	push	ecx
	lea	edx, DWORD PTR $T42322[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 52					; 00000034H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T42323[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2364]
	push	edx
	lea	eax, DWORD PTR $T42320[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T42321[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2368]
	push	eax
	lea	ecx, DWORD PTR $T42318[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T42319[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2853 : 
; 2854 : 	return vecSrc;

	lea	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2855 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ ENDP	; CBaseMonster::GetGunPosition
_TEXT	ENDS
PUBLIC	??_C@_0BI@BJNE@No?5Path?5from?5?$CFd?5to?5?$CFd?$CB?6?$AA@ ; `string'
EXTRN	?FindShortestPath@CGraph@@QAEHPAHHHHH@Z:NEAR	; CGraph::FindShortestPath
;	COMDAT ??_C@_0BI@BJNE@No?5Path?5from?5?$CFd?5to?5?$CFd?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BI@BJNE@No?5Path?5from?5?$CFd?5to?5?$CFd?$CB?6?$AA@ DB 'No Path fr'
	DB	'om %d to %d!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?FGetNodeRoute@CBaseMonster@@QAEHVVector@@@Z
_TEXT	SEGMENT
_vecDest$ = 8
_this$ = -4
_iPath$ = -44
_iSrcNode$ = -48
_iDestNode$ = -52
_iResult$ = -56
_i$ = -60
_iNumToCopy$ = -64
_iNodeHull$ = -68
?FGetNodeRoute@CBaseMonster@@QAEHVVector@@@Z PROC NEAR	; CBaseMonster::FGetNodeRoute, COMDAT

; 2878 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2879 : 	int iPath[ MAX_PATH_SIZE ];
; 2880 : 	int iSrcNode, iDestNode;
; 2881 : 	int iResult;
; 2882 : 	int i;
; 2883 : 	int iNumToCopy;
; 2884 : 
; 2885 : 	iSrcNode = WorldGraph.FindNearestNode ( GetAbsOrigin(), this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FindNearestNode@CGraph@@QAEHABVVector@@PAVCBaseEntity@@@Z ; CGraph::FindNearestNode
	mov	DWORD PTR _iSrcNode$[ebp], eax

; 2886 : 	iDestNode = WorldGraph.FindNearestNode ( vecDest, this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecDest$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FindNearestNode@CGraph@@QAEHABVVector@@PAVCBaseEntity@@@Z ; CGraph::FindNearestNode
	mov	DWORD PTR _iDestNode$[ebp], eax

; 2887 : 
; 2888 : 	if ( iSrcNode == -1 )

	cmp	DWORD PTR _iSrcNode$[ebp], -1
	jne	SHORT $L40751

; 2890 : 		// no node nearest self
; 2891 : //		ALERT ( at_aiconsole, "FGetNodeRoute: No valid node near self!\n" );
; 2892 : 		return FALSE;

	xor	eax, eax
	jmp	$L40744
$L40751:

; 2894 : 	else if ( iDestNode == -1 )

	cmp	DWORD PTR _iDestNode$[ebp], -1
	jne	SHORT $L40753

; 2896 : 		// no node nearest target
; 2897 : //		ALERT ( at_aiconsole, "FGetNodeRoute: No valid node near target!\n" );
; 2898 : 		return FALSE;

	xor	eax, eax
	jmp	$L40744
$L40753:

; 2900 : 
; 2901 : 	// valid src and dest nodes were found, so it's safe to proceed with
; 2902 : 	// find shortest path
; 2903 : 	int iNodeHull = WorldGraph.HullIndex( this ); // make this a monster virtual function

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?HullIndex@CGraph@@QAEHPBVCBaseEntity@@@Z ; CGraph::HullIndex
	mov	DWORD PTR _iNodeHull$[ebp], eax

; 2904 : 	iResult = WorldGraph.FindShortestPath ( iPath, iSrcNode, iDestNode, iNodeHull, m_afCapability );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2304]
	push	edx
	mov	eax, DWORD PTR _iNodeHull$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDestNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iSrcNode$[ebp]
	push	edx
	lea	eax, DWORD PTR _iPath$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FindShortestPath@CGraph@@QAEHPAHHHHH@Z	; CGraph::FindShortestPath
	mov	DWORD PTR _iResult$[ebp], eax

; 2905 : 
; 2906 : 	if ( !iResult )

	cmp	DWORD PTR _iResult$[ebp], 0
	jne	SHORT $L40755

; 2908 : #if 1
; 2909 : 		ALERT ( at_aiconsole, "No Path from %d to %d!\n", iSrcNode, iDestNode );

	mov	ecx, DWORD PTR _iDestNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iSrcNode$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BI@BJNE@No?5Path?5from?5?$CFd?5to?5?$CFd?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 2910 : 		return FALSE;

	xor	eax, eax
	jmp	$L40744
$L40755:

; 2927 : 
; 2928 : 	// there's a valid path within iPath now, so now we will fill the route array
; 2929 : 	// up with as many of the waypoints as it will hold.
; 2930 : 	
; 2931 : 	// don't copy ROUTE_SIZE entries if the path returned is shorter
; 2932 : 	// than ROUTE_SIZE!!!
; 2933 : 	if ( iResult < ROUTE_SIZE )

	cmp	DWORD PTR _iResult$[ebp], 8
	jge	SHORT $L40757

; 2935 : 		iNumToCopy = iResult;

	mov	eax, DWORD PTR _iResult$[ebp]
	mov	DWORD PTR _iNumToCopy$[ebp], eax

; 2937 : 	else

	jmp	SHORT $L40758
$L40757:

; 2939 : 		iNumToCopy = ROUTE_SIZE;

	mov	DWORD PTR _iNumToCopy$[ebp], 8
$L40758:

; 2941 : 	
; 2942 : 	for ( i = 0 ; i < iNumToCopy; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40759
$L40760:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L40759:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _iNumToCopy$[ebp]
	jge	SHORT $L40761

; 2944 : 		m_Route[ i ].vecLocation = WorldGraph.m_pNodes[ iPath[ i ] ].m_vecOrigin;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _iPath$[ebp+eax*4]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	add	edx, ecx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+2100]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 2945 : 		m_Route[ i ].iType = bits_MF_TO_NODE;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+2112], 32		; 00000020H

; 2946 : 	}

	jmp	SHORT $L40760
$L40761:

; 2947 : 	
; 2948 : 	if ( iNumToCopy < ROUTE_SIZE )

	cmp	DWORD PTR _iNumToCopy$[ebp], 8
	jge	SHORT $L40762

; 2950 : 		m_Route[ iNumToCopy ].vecLocation = vecDest;

	mov	edx, DWORD PTR _iNumToCopy$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2100]
	mov	edx, DWORD PTR _vecDest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _vecDest$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _vecDest$[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 2951 : 		m_Route[ iNumToCopy ].iType |= bits_MF_IS_GOAL;

	mov	eax, DWORD PTR _iNumToCopy$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+2112]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _iNumToCopy$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+2112], edx
$L40762:

; 2953 : 
; 2954 : 	return TRUE;

	mov	eax, 1
$L40744:

; 2955 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?FGetNodeRoute@CBaseMonster@@QAEHVVector@@@Z ENDP	; CBaseMonster::FGetNodeRoute
_TEXT	ENDS
PUBLIC	?FindHintNode@CBaseMonster@@QAEHXZ		; CBaseMonster::FindHintNode
PUBLIC	??_C@_0CB@JKBN@find_hintnode?3?5graph?5not?5ready?$CB?6@ ; `string'
;	COMDAT ??_C@_0CB@JKBN@find_hintnode?3?5graph?5not?5ready?$CB?6@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0CB@JKBN@find_hintnode?3?5graph?5not?5ready?$CB?6@ DB 'find_hintnod'
	DB	'e: graph not ready!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?FindHintNode@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
$T42328 = -84
$T42329 = -96
_this$ = -4
_i$ = -8
_tr$ = -64
_nodeNumber$40775 = -68
_node$40776 = -72
?FindHintNode@CBaseMonster@@QAEHXZ PROC NEAR		; CBaseMonster::FindHintNode, COMDAT

; 2961 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2962 : 	int i;
; 2963 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 2964 : 
; 2965 : 	if ( !WorldGraph.m_fGraphPresent )

	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A, 0
	jne	SHORT $L40769

; 2967 : 		ALERT ( at_aiconsole, "find_hintnode: graph not ready!\n" );

	push	OFFSET FLAT:??_C@_0CB@JKBN@find_hintnode?3?5graph?5not?5ready?$CB?6@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2968 : 		return NO_NODE;

	or	eax, -1
	jmp	$L40766
$L40769:

; 2970 : 
; 2971 : 	if ( WorldGraph.m_iLastActiveIdleSearch >= WorldGraph.m_cNodes )

	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+8388
	cmp	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	jl	SHORT $L40771

; 2973 : 		WorldGraph.m_iLastActiveIdleSearch = 0;

	mov	DWORD PTR ?WorldGraph@@3VCGraph@@A+8388, 0
$L40771:

; 2975 : 
; 2976 : 	for ( i = 0; i < WorldGraph.m_cNodes ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40772
$L40773:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L40772:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	jge	$L40774

; 2978 : 		int nodeNumber = (i + WorldGraph.m_iLastActiveIdleSearch) % WorldGraph.m_cNodes;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+8388
	cdq
	idiv	DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	mov	DWORD PTR _nodeNumber$40775[ebp], edx

; 2979 : 		CNode &node = WorldGraph.Node( nodeNumber );

	mov	eax, DWORD PTR _nodeNumber$40775[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?Node@CGraph@@QAEAAVCNode@@H@Z		; CGraph::Node
	mov	DWORD PTR _node$40776[ebp], eax

; 2980 : 
; 2981 : 		if ( node.m_sHintType )

	mov	ecx, DWORD PTR _node$40776[ebp]
	movsx	edx, WORD PTR [ecx+80]
	test	edx, edx
	je	$L40783

; 2983 : 			// this node has a hint. Take it if it is visible, the monster likes it, and the monster has an animation to match the hint's activity.
; 2984 : 			if ( FValidateHintType ( node.m_sHintType ) )

	mov	eax, DWORD PTR _node$40776[ebp]
	mov	cx, WORD PTR [eax+80]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+532]
	test	eax, eax
	je	$L40783

; 2986 : 				if ( !node.m_sHintActivity || LookupActivity ( node.m_sHintActivity ) != ACTIVITY_NOT_AVAILABLE )

	mov	ecx, DWORD PTR _node$40776[ebp]
	movsx	edx, WORD PTR [ecx+82]
	test	edx, edx
	je	SHORT $L40780
	mov	eax, DWORD PTR _node$40776[ebp]
	movsx	ecx, WORD PTR [eax+82]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	cmp	eax, -1
	je	SHORT $L40783
$L40780:

; 2988 : 					UTIL_TraceLine ( EyePosition(), node.m_vecOrigin + pev->view_ofs, ignore_monsters, edict(), &tr );

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T42328[ebp]
	push	edx
	mov	ecx, DWORD PTR _node$40776[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	eax, DWORD PTR $T42329[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+308]
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 2989 : 
; 2990 : 					if ( tr.flFraction == 1.0 )

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40783

; 2992 : 						WorldGraph.m_iLastActiveIdleSearch = nodeNumber + 1; // next monster that searches for hint nodes will start where we left off.

	mov	eax, DWORD PTR _nodeNumber$40775[ebp]
	add	eax, 1
	mov	DWORD PTR ?WorldGraph@@3VCGraph@@A+8388, eax

; 2993 : 						return nodeNumber;// take it!

	mov	eax, DWORD PTR _nodeNumber$40775[ebp]
	jmp	SHORT $L40766
$L40783:

; 2998 : 	}

	jmp	$L40773
$L40774:

; 2999 : 
; 3000 : 	WorldGraph.m_iLastActiveIdleSearch = 0;// start at the top of the list for the next search.

	mov	DWORD PTR ?WorldGraph@@3VCGraph@@A+8388, 0

; 3001 : 
; 3002 : 	return NO_NODE;

	or	eax, -1
$L40766:

; 3003 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FindHintNode@CBaseMonster@@QAEHXZ ENDP			; CBaseMonster::FindHintNode
_TEXT	ENDS
PUBLIC	?InSquad@CSquadMonster@@QAEHXZ			; CSquadMonster::InSquad
PUBLIC	?IsLeader@CSquadMonster@@QAEHXZ			; CSquadMonster::IsLeader
PUBLIC	??_C@_04HPGM@?$CFs?3?5?$AA@			; `string'
PUBLIC	??_C@_0M@KHMA@State?3?5?$CFs?0?5?$AA@		; `string'
PUBLIC	??_C@_0O@PLOF@Activity?5?$CFs?0?5?$AA@		; `string'
PUBLIC	??_C@_07PCHH@Unknown?$AA@			; `string'
PUBLIC	??_C@_0O@CHAH@Schedule?5?$CFs?0?5?$AA@		; `string'
PUBLIC	??_C@_0BA@HOFF@Task?5?$CFd?5?$CI?$CD?$CFd?$CJ?0?5?$AA@ ; `string'
PUBLIC	??_C@_0O@DDHO@No?5Schedule?0?5?$AA@		; `string'
PUBLIC	??_C@_0N@FEEB@?6Enemy?5is?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_08FJLB@No?5enemy?$AA@			; `string'
PUBLIC	??_C@_08BADG@?5Moving?5?$AA@			; `string'
PUBLIC	??_C@_0BF@DMEN@?3?5Stopped?5for?5?$CF?42f?4?5?$AA@ ; `string'
PUBLIC	??_C@_0BE@FDPE@?3?5In?5stopped?5anim?4?5?$AA@	; `string'
PUBLIC	??_C@_04PPAE@not?5?$AA@				; `string'
PUBLIC	??_C@_0L@HPKL@In?5Squad?0?5?$AA@		; `string'
PUBLIC	??_C@_07KOPI@Leader?4?$AA@			; `string'
PUBLIC	??_C@_01BJG@?6?$AA@				; `string'
PUBLIC	??_C@_0BP@CHJM@Yaw?5speed?3?$CF3?41f?0Health?3?5?$CF3?41f?6?$AA@ ; `string'
PUBLIC	??_C@_0M@MCIH@?5PRISONER?$CB?5?$AA@		; `string'
PUBLIC	??_C@_0BA@DMBF@?5Pre?9Disaster?$CB?5?$AA@	; `string'
PUBLIC	?ReportAIState@CBaseMonster@@UAEXXZ		; CBaseMonster::ReportAIState
EXTRN	?activity_map@@3PAUactivity_map_t@@A:BYTE	; activity_map
EXTRN	?GetTask@CBaseMonster@@QAEPAUTask_t@@XZ:NEAR	; CBaseMonster::GetTask
;	COMDAT ??_C@_04HPGM@?$CFs?3?5?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_04HPGM@?$CFs?3?5?$AA@ DB '%s: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KHMA@State?3?5?$CFs?0?5?$AA@
CONST	SEGMENT
??_C@_0M@KHMA@State?3?5?$CFs?0?5?$AA@ DB 'State: %s, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PLOF@Activity?5?$CFs?0?5?$AA@
CONST	SEGMENT
??_C@_0O@PLOF@Activity?5?$CFs?0?5?$AA@ DB 'Activity %s, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PCHH@Unknown?$AA@
CONST	SEGMENT
??_C@_07PCHH@Unknown?$AA@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CHAH@Schedule?5?$CFs?0?5?$AA@
CONST	SEGMENT
??_C@_0O@CHAH@Schedule?5?$CFs?0?5?$AA@ DB 'Schedule %s, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HOFF@Task?5?$CFd?5?$CI?$CD?$CFd?$CJ?0?5?$AA@
CONST	SEGMENT
??_C@_0BA@HOFF@Task?5?$CFd?5?$CI?$CD?$CFd?$CJ?0?5?$AA@ DB 'Task %d (#%d),'
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DDHO@No?5Schedule?0?5?$AA@
CONST	SEGMENT
??_C@_0O@DDHO@No?5Schedule?0?5?$AA@ DB 'No Schedule, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FEEB@?6Enemy?5is?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0N@FEEB@?6Enemy?5is?5?$CFs?$AA@ DB 0aH, 'Enemy is %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJLB@No?5enemy?$AA@
CONST	SEGMENT
??_C@_08FJLB@No?5enemy?$AA@ DB 'No enemy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BADG@?5Moving?5?$AA@
CONST	SEGMENT
??_C@_08BADG@?5Moving?5?$AA@ DB ' Moving ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DMEN@?3?5Stopped?5for?5?$CF?42f?4?5?$AA@
CONST	SEGMENT
??_C@_0BF@DMEN@?3?5Stopped?5for?5?$CF?42f?4?5?$AA@ DB ': Stopped for %.2f'
	DB	'. ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FDPE@?3?5In?5stopped?5anim?4?5?$AA@
CONST	SEGMENT
??_C@_0BE@FDPE@?3?5In?5stopped?5anim?4?5?$AA@ DB ': In stopped anim. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PPAE@not?5?$AA@
CONST	SEGMENT
??_C@_04PPAE@not?5?$AA@ DB 'not ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HPKL@In?5Squad?0?5?$AA@
CONST	SEGMENT
??_C@_0L@HPKL@In?5Squad?0?5?$AA@ DB 'In Squad, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KOPI@Leader?4?$AA@
CONST	SEGMENT
??_C@_07KOPI@Leader?4?$AA@ DB 'Leader.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT
??_C@_01BJG@?6?$AA@ DB 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CHJM@Yaw?5speed?3?$CF3?41f?0Health?3?5?$CF3?41f?6?$AA@
CONST	SEGMENT
??_C@_0BP@CHJM@Yaw?5speed?3?$CF3?41f?0Health?3?5?$CF3?41f?6?$AA@ DB 'Yaw '
	DB	'speed:%3.1f,Health: %3.1f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MCIH@?5PRISONER?$CB?5?$AA@
CONST	SEGMENT
??_C@_0M@MCIH@?5PRISONER?$CB?5?$AA@ DB ' PRISONER! ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DMBF@?5Pre?9Disaster?$CB?5?$AA@
CONST	SEGMENT
??_C@_0BA@DMBF@?5Pre?9Disaster?$CB?5?$AA@ DB ' Pre-Disaster! ', 00H ; `string'
CONST	ENDS
;	COMDAT ?ReportAIState@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_level$ = -8
_i$ = -12
_pName$40811 = -16
_pTask$40815 = -20
_pSquadMonster$ = -24
?ReportAIState@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::ReportAIState, COMDAT

; 3007 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3008 : 	ALERT_TYPE level = at_console;

	mov	DWORD PTR _level$[ebp], 1

; 3009 : 
; 3010 : 	static const char *pStateNames[] = { "None", "Idle", "Combat", "Alert", "Hunt", "Prone", "Scripted", "Dead" };
; 3011 : 
; 3012 : 	ALERT( level, "%s: ", STRING(pev->classname) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_04HPGM@?$CFs?3?5?$AA@	; `string'
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 3013 : 	if ( (int)m_MonsterState < ARRAYSIZE(pStateNames) )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2080], 8
	jae	SHORT $L40801

; 3014 : 		ALERT( level, "State: %s, ", pStateNames[m_MonsterState] );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2080]
	mov	ecx, DWORD PTR _?pStateNames@?1??ReportAIState@CBaseMonster@@UAEXXZ@4PAPBDA[eax*4]
	push	ecx
	push	OFFSET FLAT:??_C@_0M@KHMA@State?3?5?$CFs?0?5?$AA@ ; `string'
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L40801:

; 3015 : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0
$L40805:

; 3016 : 	while ( activity_map[i].type != 0 )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?activity_map@@3PAUactivity_map_t@@A[eax*8], 0
	je	SHORT $L40806

; 3018 : 		if ( activity_map[i].type == (int)m_Activity )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?activity_map@@3PAUactivity_map_t@@A[ecx*8]
	cmp	eax, DWORD PTR [edx+2068]
	jne	SHORT $L40808

; 3020 : 			ALERT( level, "Activity %s, ", activity_map[i].name );

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?activity_map@@3PAUactivity_map_t@@A[ecx*8+4]
	push	edx
	push	OFFSET FLAT:??_C@_0O@PLOF@Activity?5?$CFs?0?5?$AA@ ; `string'
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 3021 : 			break;

	jmp	SHORT $L40806
$L40808:

; 3023 : 		i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 3024 : 	}

	jmp	SHORT $L40805
$L40806:

; 3025 : 
; 3026 : 	if ( m_pSchedule )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2092], 0
	je	SHORT $L40810

; 3028 : 		const char *pName = NULL;

	mov	DWORD PTR _pName$40811[ebp], 0

; 3029 : 		pName = m_pSchedule->pName;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2092]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _pName$40811[ebp], edx

; 3030 : 		if ( !pName )

	cmp	DWORD PTR _pName$40811[ebp], 0
	jne	SHORT $L40812

; 3031 : 			pName = "Unknown";

	mov	DWORD PTR _pName$40811[ebp], OFFSET FLAT:??_C@_07PCHH@Unknown?$AA@ ; `string'
$L40812:

; 3032 : 		ALERT( level, "Schedule %s, ", pName );

	mov	eax, DWORD PTR _pName$40811[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0O@CHAH@Schedule?5?$CFs?0?5?$AA@ ; `string'
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 3033 : 		Task_t *pTask = GetTask();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTask@CBaseMonster@@QAEPAUTask_t@@XZ	; CBaseMonster::GetTask
	mov	DWORD PTR _pTask$40815[ebp], eax

; 3034 : 		if ( pTask )

	cmp	DWORD PTR _pTask$40815[ebp], 0
	je	SHORT $L40816

; 3035 : 			ALERT( level, "Task %d (#%d), ", pTask->iTask, m_iScheduleIndex );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2096]
	push	eax
	mov	ecx, DWORD PTR _pTask$40815[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET FLAT:??_C@_0BA@HOFF@Task?5?$CFd?5?$CI?$CD?$CFd?$CJ?0?5?$AA@ ; `string'
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H
$L40816:

; 3037 : 	else

	jmp	SHORT $L40818
$L40810:

; 3038 : 		ALERT( level, "No Schedule, " );

	push	OFFSET FLAT:??_C@_0O@DDHO@No?5Schedule?0?5?$AA@ ; `string'
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L40818:

; 3039 : 
; 3040 : 	if ( m_hEnemy != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40820

; 3041 : 		ALERT( level, "\nEnemy is %s", STRING(m_hEnemy->pev->classname) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0N@FEEB@?6Enemy?5is?5?$CFs?$AA@ ; `string'
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 3042 : 	else

	jmp	SHORT $L40822
$L40820:

; 3043 : 		ALERT( level, "No enemy" );

	push	OFFSET FLAT:??_C@_08FJLB@No?5enemy?$AA@	; `string'
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L40822:

; 3044 : 
; 3045 : 	if ( IsMoving() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+164]
	test	eax, eax
	je	$L40829

; 3047 : 		ALERT( level, " Moving " );

	push	OFFSET FLAT:??_C@_08BADG@?5Moving?5?$AA@ ; `string'
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3048 : 		if ( m_flMoveWaitFinished > gpGlobals->time )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+2064]
	fcomp	DWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40826

; 3049 : 			ALERT( level, ": Stopped for %.2f. ", m_flMoveWaitFinished - gpGlobals->time );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+2064]
	fsub	DWORD PTR [ecx]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BF@DMEN@?3?5Stopped?5for?5?$CF?42f?4?5?$AA@ ; `string'
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 3050 : 		else if ( m_IdealActivity == GetStoppedActivity() )

	jmp	SHORT $L40829
$L40826:
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2072], eax
	jne	SHORT $L40829

; 3051 : 			ALERT( level, ": In stopped anim. " );

	push	OFFSET FLAT:??_C@_0BE@FDPE@?3?5In?5stopped?5anim?4?5?$AA@ ; `string'
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L40829:

; 3053 : 
; 3054 : 	CSquadMonster *pSquadMonster = MySquadMonsterPointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+128]
	mov	DWORD PTR _pSquadMonster$[ebp], eax

; 3055 : 
; 3056 : 	if ( pSquadMonster )

	cmp	DWORD PTR _pSquadMonster$[ebp], 0
	je	SHORT $L40832

; 3058 : 		if ( !pSquadMonster->InSquad() )

	mov	ecx, DWORD PTR _pSquadMonster$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	jne	SHORT $L40833

; 3060 : 			ALERT ( level, "not " );

	push	OFFSET FLAT:??_C@_04PPAE@not?5?$AA@	; `string'
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L40833:

; 3062 : 
; 3063 : 		ALERT ( level, "In Squad, " );

	push	OFFSET FLAT:??_C@_0L@HPKL@In?5Squad?0?5?$AA@ ; `string'
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3064 : 
; 3065 : 		if ( !pSquadMonster->IsLeader() )

	mov	ecx, DWORD PTR _pSquadMonster$[ebp]
	call	?IsLeader@CSquadMonster@@QAEHXZ		; CSquadMonster::IsLeader
	test	eax, eax
	jne	SHORT $L40836

; 3067 : 			ALERT ( level, "not " );

	push	OFFSET FLAT:??_C@_04PPAE@not?5?$AA@	; `string'
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L40836:

; 3069 : 
; 3070 : 		ALERT ( level, "Leader." );

	push	OFFSET FLAT:??_C@_07KOPI@Leader?4?$AA@	; `string'
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L40832:

; 3072 : 
; 3073 : 	ALERT( level, "\n" );

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3074 : 	ALERT( level, "Yaw speed:%3.1f,Health: %3.1f\n", pev->yaw_speed, pev->health );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+176]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BP@CHJM@Yaw?5speed?3?$CF3?41f?0Health?3?5?$CF3?41f?6?$AA@ ; `string'
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 24					; 00000018H

; 3075 : 	if ( pev->spawnflags & SF_MONSTER_PRISONER )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 16					; 00000010H
	test	eax, eax
	je	SHORT $L40840

; 3076 : 		ALERT( level, " PRISONER! " );

	push	OFFSET FLAT:??_C@_0M@MCIH@?5PRISONER?$CB?5?$AA@ ; `string'
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L40840:

; 3077 : 	if ( pev->spawnflags & SF_MONSTER_PREDISASTER )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	je	SHORT $L40842

; 3078 : 		ALERT( level, " Pre-Disaster! " );

	push	OFFSET FLAT:??_C@_0BA@DMBF@?5Pre?9Disaster?$CB?5?$AA@ ; `string'
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L40842:

; 3079 : 	ALERT( level, "\n" );

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3080 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReportAIState@CBaseMonster@@UAEXXZ ENDP		; CBaseMonster::ReportAIState
_TEXT	ENDS
;	COMDAT ?InSquad@CSquadMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?InSquad@CSquadMonster@@QAEHXZ PROC NEAR		; CSquadMonster::InSquad, COMDAT

; 93   : 	int InSquad ( void ) { return m_hSquadLeader != NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2396				; 0000095cH
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InSquad@CSquadMonster@@QAEHXZ ENDP			; CSquadMonster::InSquad
_TEXT	ENDS
;	COMDAT ?IsLeader@CSquadMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsLeader@CSquadMonster@@QAEHXZ PROC NEAR		; CSquadMonster::IsLeader, COMDAT

; 94   : 	int IsLeader ( void ) { return m_hSquadLeader == this; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2396				; 0000095cH
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	xor	ecx, ecx
	cmp	eax, DWORD PTR _this$[ebp]
	sete	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLeader@CSquadMonster@@QAEHXZ ENDP			; CSquadMonster::IsLeader
_TEXT	ENDS
PUBLIC	?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z ; CBaseMonster::KeyValue
PUBLIC	?AddWeapon@CBaseMonster@@QAEXH@Z		; CBaseMonster::AddWeapon
PUBLIC	??_C@_07LLGA@weapons?$AA@			; `string'
EXTRN	_atoi:NEAR
EXTRN	?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseToggle::KeyValue
;	COMDAT ??_C@_07LLGA@weapons?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_07LLGA@weapons?$AA@ DB 'weapons', 00H		; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
_weapons$40858 = -8
_i$40860 = -12
?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseMonster::KeyValue, COMDAT

; 3088 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3089 : 	if (FStrEq(pkvd->szKeyName, "TriggerTarget"))

	push	OFFSET FLAT:??_C@_0O@IGLO@TriggerTarget?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L40848

; 3091 : 		m_iszTriggerTarget = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2360], eax

; 3092 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 3094 : 	else if (FStrEq(pkvd->szKeyName, "TriggerCondition") )

	jmp	$L40865
$L40848:
	push	OFFSET FLAT:??_C@_0BB@DGBK@TriggerCondition?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L40850

; 3096 : 		m_iTriggerCondition = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2356], eax

; 3097 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 3099 : 	else if (FStrEq(pkvd->szKeyName, "m_iClass") ) //LRC

	jmp	$L40865
$L40850:
	push	OFFSET FLAT:??_C@_08IAEJ@m_iClass?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L40852

; 3101 : 		m_iClass = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2388], eax

; 3102 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 3104 : 	else if (FStrEq(pkvd->szKeyName, "m_iPlayerReact") ) //LRC

	jmp	$L40865
$L40852:
	push	OFFSET FLAT:??_C@_0P@DIIK@m_iPlayerReact?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L40854

; 3106 : 		m_iPlayerReact = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2392], eax

; 3107 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 3109 : 	else if (FStrEq(pkvd->szKeyName, "weapons") )

	jmp	$L40865
$L40854:
	push	OFFSET FLAT:??_C@_07LLGA@weapons?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L40856

; 3111 : 		int	weapons = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _weapons$40858[ebp], eax

; 3112 : 
; 3113 : 		if( weapons ) m_bHaveWeapons = TRUE;

	cmp	DWORD PTR _weapons$40858[ebp], 0
	je	SHORT $L40859
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2376], 1
$L40859:

; 3114 : 
; 3115 : 		// convert bits to weapons
; 3116 : 		for( int i = 0; i < 32; i++ )

	mov	DWORD PTR _i$40860[ebp], 0
	jmp	SHORT $L40861
$L40862:
	mov	edx, DWORD PTR _i$40860[ebp]
	add	edx, 1
	mov	DWORD PTR _i$40860[ebp], edx
$L40861:
	cmp	DWORD PTR _i$40860[ebp], 32		; 00000020H
	jge	SHORT $L40863

; 3118 : 			if( FBitSet( weapons, BIT( i )))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$40860[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _weapons$40858[ebp]
	and	ecx, eax
	test	ecx, ecx
	je	SHORT $L40864

; 3119 : 				AddWeapon( i );

	mov	edx, DWORD PTR _i$40860[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWeapon@CBaseMonster@@QAEXH@Z	; CBaseMonster::AddWeapon
$L40864:

; 3120 : 		}

	jmp	SHORT $L40862
$L40863:

; 3121 : 
; 3122 : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 3124 : 	else

	jmp	SHORT $L40865
$L40856:

; 3126 : 		CBaseToggle::KeyValue( pkvd );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z ; CBaseToggle::KeyValue
$L40865:

; 3128 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseMonster::KeyValue
_TEXT	ENDS
;	COMDAT ?AddWeapon@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4
_weaponnum$ = 8
?AddWeapon@CBaseMonster@@QAEXH@Z PROC NEAR		; CBaseMonster::AddWeapon, COMDAT

; 143  : 	void		AddWeapon( int weaponnum ) { SetBits( m_iWeapons[weaponnum >> 3], BIT( weaponnum & 7 )); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _weaponnum$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+eax+2348]
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	or	edx, eax
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	sar	ecx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+2348], dl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddWeapon@CBaseMonster@@QAEXH@Z ENDP			; CBaseMonster::AddWeapon
_TEXT	ENDS
PUBLIC	?FCheckAITrigger@CBaseMonster@@QAEHXZ		; CBaseMonster::FCheckAITrigger
PUBLIC	__real@4@40008000000000000000
PUBLIC	??_C@_0BI@DHEH@AI?5Trigger?5Fire?5Target?6?$AA@	; `string'
;	COMDAT ??_C@_0BI@DHEH@AI?5Trigger?5Fire?5Target?6?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BI@DHEH@AI?5Trigger?5Fire?5Target?6?$AA@ DB 'AI Trigger Fire Targe'
	DB	't', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@4@40008000000000000000
CONST	SEGMENT
__real@4@40008000000000000000 DD 040000000r	; 2
CONST	ENDS
;	COMDAT ?FCheckAITrigger@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_fFireTarget$ = -8
?FCheckAITrigger@CBaseMonster@@QAEHXZ PROC NEAR		; CBaseMonster::FCheckAITrigger, COMDAT

; 3138 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3139 : 	BOOL fFireTarget;
; 3140 : 
; 3141 : 	if ( m_iTriggerCondition == AITRIGGER_NONE )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2356], 0
	jne	SHORT $L40871

; 3143 : 		// no conditions, so this trigger is never fired.
; 3144 : 		return FALSE; 

	xor	eax, eax
	jmp	$L40869
$L40871:

; 3146 : 
; 3147 : 	fFireTarget = FALSE;

	mov	DWORD PTR _fFireTarget$[ebp], 0

; 3150 : 	{

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2356]
	mov	DWORD PTR -12+[ebp], edx
	mov	eax, DWORD PTR -12+[ebp]
	sub	eax, 1
	mov	DWORD PTR -12+[ebp], eax
	cmp	DWORD PTR -12+[ebp], 10			; 0000000aH
	ja	$L40873
	mov	ecx, DWORD PTR -12+[ebp]
	jmp	DWORD PTR $L42344[ecx*4]
$L40876:

; 3151 : 	case AITRIGGER_SEEPLAYER_ANGRY_AT_PLAYER:
; 3152 : 		if ( m_hEnemy != NULL && m_hEnemy->IsPlayer() && HasConditions ( bits_COND_SEE_ENEMY ) )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40877
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -16+[ebp], eax
	mov	edx, DWORD PTR -16+[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR -16+[ebp]
	call	DWORD PTR [eax+224]
	test	eax, eax
	je	SHORT $L40877
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L40877

; 3154 : 			fFireTarget = TRUE;

	mov	DWORD PTR _fFireTarget$[ebp], 1
$L40877:

; 3156 : 		break;

	jmp	$L40873
$L40878:

; 3157 : 	case AITRIGGER_SEEPLAYER_UNCONDITIONAL:
; 3158 : 		if ( HasConditions ( bits_COND_SEE_CLIENT ) )

	push	2097152					; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L40879

; 3160 : 			fFireTarget = TRUE;

	mov	DWORD PTR _fFireTarget$[ebp], 1
$L40879:

; 3162 : 		break;

	jmp	$L40873
$L40880:

; 3165 : 			 m_MonsterState != MONSTERSTATE_COMBAT	&& 
; 3166 : 			 m_MonsterState != MONSTERSTATE_PRONE	&& 
; 3167 : 			 m_MonsterState != MONSTERSTATE_SCRIPT)

	push	2097152					; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L40881
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2080], 2
	je	SHORT $L40881
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2080], 5
	je	SHORT $L40881
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2080], 6
	je	SHORT $L40881

; 3169 : 			fFireTarget = TRUE;

	mov	DWORD PTR _fFireTarget$[ebp], 1
$L40881:

; 3171 : 		break;

	jmp	$L40873
$L40882:

; 3172 : 	case AITRIGGER_TAKEDAMAGE:
; 3173 : 		if ( m_afConditions & ( bits_COND_LIGHT_DAMAGE | bits_COND_HEAVY_DAMAGE ) )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1956]
	and	edx, 768				; 00000300H
	test	edx, edx
	je	SHORT $L40883

; 3175 : 			fFireTarget = TRUE;

	mov	DWORD PTR _fFireTarget$[ebp], 1
$L40883:

; 3177 : 		break;

	jmp	$L40873
$L40884:

; 3178 : 	case AITRIGGER_DEATH:
; 3179 : 		if ( pev->deadflag != DEAD_NO )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	je	SHORT $L40885

; 3181 : 			fFireTarget = TRUE;

	mov	DWORD PTR _fFireTarget$[ebp], 1
$L40885:

; 3183 : 		break;

	jmp	$L40873
$L40886:

; 3184 : 	case AITRIGGER_HALFHEALTH:
; 3185 : 		if ( IsAlive() && pev->health <= ( pev->max_health / 2 ) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+200]
	test	eax, eax
	je	SHORT $L40887
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+432]
	fdiv	DWORD PTR __real@4@40008000000000000000
	fcomp	DWORD PTR [edx+352]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40887

; 3187 : 			fFireTarget = TRUE;

	mov	DWORD PTR _fFireTarget$[ebp], 1
$L40887:

; 3189 : 		break;

	jmp	$L40873
$L40888:

; 3190 : /*
; 3191 : 
; 3192 :   // !!!UNDONE - no persistant game state that allows us to track these two. 
; 3193 : 
; 3194 : 	case AITRIGGER_SQUADMEMBERDIE:
; 3195 : 		break;
; 3196 : 	case AITRIGGER_SQUADLEADERDIE:
; 3197 : 		break;
; 3198 : */
; 3199 : 	case AITRIGGER_HEARWORLD:
; 3200 : 		if ( m_afConditions & bits_COND_HEAR_SOUND && m_afSoundTypes & bits_SOUND_WORLD )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1956]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $L40889
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2260]
	and	edx, 2
	test	edx, edx
	je	SHORT $L40889

; 3202 : 			fFireTarget = TRUE;

	mov	DWORD PTR _fFireTarget$[ebp], 1
$L40889:

; 3204 : 		break;

	jmp	SHORT $L40873
$L40890:

; 3205 : 	case AITRIGGER_HEARPLAYER:
; 3206 : 		if ( m_afConditions & bits_COND_HEAR_SOUND && m_afSoundTypes & bits_SOUND_PLAYER )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1956]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L40891
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2260]
	and	eax, 4
	test	eax, eax
	je	SHORT $L40891

; 3208 : 			fFireTarget = TRUE;

	mov	DWORD PTR _fFireTarget$[ebp], 1
$L40891:

; 3210 : 		break;

	jmp	SHORT $L40873
$L40892:

; 3211 : 	case AITRIGGER_HEARCOMBAT:
; 3212 : 		if ( m_afConditions & bits_COND_HEAR_SOUND && m_afSoundTypes & bits_SOUND_COMBAT )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1956]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L40893
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2260]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L40893

; 3214 : 			fFireTarget = TRUE;

	mov	DWORD PTR _fFireTarget$[ebp], 1
$L40893:
$L40873:

; 3218 : 
; 3219 : 	if ( fFireTarget )

	cmp	DWORD PTR _fFireTarget$[ebp], 0
	je	SHORT $L40894

; 3221 : 		// fire the target, then set the trigger conditions to NONE so we don't fire again
; 3222 : 		ALERT ( at_aiconsole, "AI Trigger Fire Target\n" );

	push	OFFSET FLAT:??_C@_0BI@DHEH@AI?5Trigger?5Fire?5Target?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3223 : 		UTIL_FireTargets( STRING( m_iszTriggerTarget ), this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2360]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 3224 : 		m_iTriggerCondition = AITRIGGER_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2356], 0

; 3225 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L40869
$L40894:

; 3227 : 
; 3228 : 	return FALSE;

	xor	eax, eax
$L40869:

; 3229 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L42344:
	DD	$L40876
	DD	$L40882
	DD	$L40886
	DD	$L40884
	DD	$L40873
	DD	$L40873
	DD	$L40888
	DD	$L40890
	DD	$L40892
	DD	$L40878
	DD	$L40880
?FCheckAITrigger@CBaseMonster@@QAEHXZ ENDP		; CBaseMonster::FCheckAITrigger
_TEXT	ENDS
PUBLIC	?CanPlaySequence@CBaseMonster@@UAEHHH@Z		; CBaseMonster::CanPlaySequence
;	COMDAT ?CanPlaySequence@CBaseMonster@@UAEHHH@Z
_TEXT	SEGMENT
_fDisregardMonsterState$ = 8
_interruptLevel$ = 12
_this$ = -4
?CanPlaySequence@CBaseMonster@@UAEHHH@Z PROC NEAR	; CBaseMonster::CanPlaySequence, COMDAT

; 3239 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3240 : 	if ( m_pCine || !IsAlive() || m_MonsterState == MONSTERSTATE_PRONE )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2384], 0
	jne	SHORT $L40902
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	je	SHORT $L40902
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2080], 5
	jne	SHORT $L40901
$L40902:

; 3242 : 		// monster is already running a scripted sequence or dead!
; 3243 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L40900
$L40901:

; 3245 : 	
; 3246 : 	if ( fDisregardMonsterState )

	cmp	DWORD PTR _fDisregardMonsterState$[ebp], 0
	je	SHORT $L40903

; 3248 : 		// ok to go, no matter what the monster state. (scripted AI)
; 3249 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L40900
$L40903:

; 3251 : 
; 3252 : 	if ( m_MonsterState == MONSTERSTATE_NONE || m_MonsterState == MONSTERSTATE_IDLE || m_IdealMonsterState == MONSTERSTATE_IDLE )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2080], 0
	je	SHORT $L40905
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2080], 1
	je	SHORT $L40905
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2084], 1
	jne	SHORT $L40904
$L40905:

; 3254 : 		// ok to go, but only in these states
; 3255 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L40900
$L40904:

; 3257 : 	
; 3258 : 	if ( m_MonsterState == MONSTERSTATE_ALERT && interruptLevel >= SS_INTERRUPT_BY_NAME )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2080], 3
	jne	SHORT $L40906
	cmp	DWORD PTR _interruptLevel$[ebp], 1
	jl	SHORT $L40906

; 3259 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L40900
$L40906:

; 3260 : 
; 3261 : 	// unknown situation
; 3262 : 	return FALSE;

	xor	eax, eax
$L40900:

; 3263 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CanPlaySequence@CBaseMonster@@UAEHHH@Z ENDP		; CBaseMonster::CanPlaySequence
_TEXT	ENDS
PUBLIC	?FindLateralCover@CBaseMonster@@QAEHABVVector@@0@Z ; CBaseMonster::FindLateralCover
;	COMDAT ?FindLateralCover@CBaseMonster@@QAEHABVVector@@0@Z
_TEXT	SEGMENT
$T42349 = -136
$T42350 = -148
$T42351 = -160
$T42352 = -172
$T42353 = -184
$T42354 = -196
$T42355 = -208
_vecThreat$ = 8
_vecViewOffset$ = 12
_this$ = -4
_tr$ = -60
_vecBestOnLeft$ = -72
_vecBestOnRight$ = -84
_vecLeftTest$ = -96
_vecRightTest$ = -108
_vecStepRight$ = -120
_i$ = -124
?FindLateralCover@CBaseMonster@@QAEHABVVector@@0@Z PROC NEAR ; CBaseMonster::FindLateralCover, COMDAT

; 3275 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3276 : 	TraceResult	tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 3277 : 	Vector	vecBestOnLeft;

	lea	ecx, DWORD PTR _vecBestOnLeft$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 3278 : 	Vector	vecBestOnRight;

	lea	ecx, DWORD PTR _vecBestOnRight$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 3279 : 	Vector	vecLeftTest;

	lea	ecx, DWORD PTR _vecLeftTest$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 3280 : 	Vector	vecRightTest;

	lea	ecx, DWORD PTR _vecRightTest$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 3281 : 	Vector	vecStepRight;

	lea	ecx, DWORD PTR _vecStepRight$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 3282 : 	int		i;
; 3283 : 
; 3284 : 	UTIL_MakeVectors ( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 3285 : 	vecStepRight = gpGlobals->v_right * COVER_DELTA;

	push	1111490560				; 42400000H
	lea	eax, DWORD PTR $T42349[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecStepRight$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecStepRight$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecStepRight$[ebp+8], eax

; 3286 : 	vecStepRight.z = 0; 

	mov	DWORD PTR _vecStepRight$[ebp+8], 0

; 3287 : 	
; 3288 : 	vecLeftTest = vecRightTest = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecRightTest$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecRightTest$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecRightTest$[ebp+8], eax
	mov	ecx, DWORD PTR _vecRightTest$[ebp]
	mov	DWORD PTR _vecLeftTest$[ebp], ecx
	mov	edx, DWORD PTR _vecRightTest$[ebp+4]
	mov	DWORD PTR _vecLeftTest$[ebp+4], edx
	mov	eax, DWORD PTR _vecRightTest$[ebp+8]
	mov	DWORD PTR _vecLeftTest$[ebp+8], eax

; 3289 : 
; 3290 : 	for ( i = 0 ; i < COVER_CHECKS ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40922
$L40923:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L40922:
	cmp	DWORD PTR _i$[ebp], 5
	jge	$L40924

; 3292 : 		vecLeftTest = vecLeftTest - vecStepRight;

	lea	edx, DWORD PTR _vecStepRight$[ebp]
	push	edx
	lea	eax, DWORD PTR $T42350[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecLeftTest$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecLeftTest$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecLeftTest$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecLeftTest$[ebp+8], eax

; 3293 : 		vecRightTest = vecRightTest + vecStepRight;

	lea	ecx, DWORD PTR _vecStepRight$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T42351[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecRightTest$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecRightTest$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecRightTest$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecRightTest$[ebp+8], eax

; 3294 : 
; 3295 : 		// it's faster to check the SightEnt's visibility to the potential spot than to check the local move, so we do that first.
; 3296 : 		UTIL_TraceLine( vecThreat + vecViewOffset, vecLeftTest + pev->view_ofs, ignore_monsters, ignore_glass, ENT(pev)/*pentIgnore*/, &tr);

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 372				; 00000174H
	push	edx
	lea	eax, DWORD PTR $T42352[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecLeftTest$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _vecViewOffset$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T42353[ebp]
	push	edx
	mov	ecx, DWORD PTR _vecThreat$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 24					; 00000018H

; 3297 : 		
; 3298 : 		if (tr.flFraction != 1.0)

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L40931

; 3300 : 			if ( FValidateCover ( vecLeftTest ) && CheckLocalMove( GetAbsOrigin(), vecLeftTest, NULL, NULL ) == LOCALMOVE_VALID )

	lea	eax, DWORD PTR _vecLeftTest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+512]
	test	eax, eax
	je	SHORT $L40931
	push	0
	push	0
	lea	eax, DWORD PTR _vecLeftTest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+396]
	cmp	eax, 2
	jne	SHORT $L40931

; 3302 : 				if ( MoveToLocation( ACT_RUN, 0, vecLeftTest ) )

	lea	eax, DWORD PTR _vecLeftTest$[ebp]
	push	eax
	push	0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveToLocation@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z ; CBaseMonster::MoveToLocation
	test	eax, eax
	je	SHORT $L40931

; 3304 : 					return TRUE;

	mov	eax, 1
	jmp	$L40913
$L40931:

; 3308 : 		
; 3309 : 		// it's faster to check the SightEnt's visibility to the potential spot than to check the local move, so we do that first.
; 3310 : 		UTIL_TraceLine(vecThreat + vecViewOffset, vecRightTest + pev->view_ofs, ignore_monsters, ignore_glass, ENT(pev)/*pentIgnore*/, &tr);

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 372				; 00000174H
	push	edx
	lea	eax, DWORD PTR $T42354[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecRightTest$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _vecViewOffset$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T42355[ebp]
	push	edx
	mov	ecx, DWORD PTR _vecThreat$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 24					; 00000018H

; 3311 : 		
; 3312 : 		if ( tr.flFraction != 1.0 )

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L40936

; 3314 : 			if (  FValidateCover ( vecRightTest ) && CheckLocalMove( GetAbsOrigin(), vecRightTest, NULL, NULL ) == LOCALMOVE_VALID )

	lea	eax, DWORD PTR _vecRightTest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+512]
	test	eax, eax
	je	SHORT $L40936
	push	0
	push	0
	lea	eax, DWORD PTR _vecRightTest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+396]
	cmp	eax, 2
	jne	SHORT $L40936

; 3316 : 				if ( MoveToLocation( ACT_RUN, 0, vecRightTest ) )

	lea	eax, DWORD PTR _vecRightTest$[ebp]
	push	eax
	push	0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveToLocation@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z ; CBaseMonster::MoveToLocation
	test	eax, eax
	je	SHORT $L40936

; 3318 : 					return TRUE;

	mov	eax, 1
	jmp	SHORT $L40913
$L40936:

; 3322 : 	}

	jmp	$L40923
$L40924:

; 3323 : 
; 3324 : 	return FALSE;

	xor	eax, eax
$L40913:

; 3325 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FindLateralCover@CBaseMonster@@QAEHABVVector@@0@Z ENDP	; CBaseMonster::FindLateralCover
_TEXT	ENDS
PUBLIC	?ShootAtEnemy@CBaseMonster@@QAE?AVVector@@ABV2@@Z ; CBaseMonster::ShootAtEnemy
;	COMDAT ?ShootAtEnemy@CBaseMonster@@QAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
$T42358 = -20
$T42359 = -32
$T42360 = -44
$T42361 = -56
$T42362 = -68
_shootOrigin$ = 12
___$ReturnUdt$ = 8
_this$ = -4
_pEnemy$ = -8
?ShootAtEnemy@CBaseMonster@@QAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseMonster::ShootAtEnemy, COMDAT

; 3329 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3330 : 	CBaseEntity *pEnemy = m_hEnemy;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pEnemy$[ebp], eax

; 3331 : 
; 3332 : 	if ( pEnemy )

	cmp	DWORD PTR _pEnemy$[ebp], 0
	je	SHORT $L40943

; 3334 : 		return ( (pEnemy->BodyTarget( shootOrigin ) - pEnemy->GetAbsOrigin()) + m_vecEnemyLKP - shootOrigin ).Normalize();

	lea	eax, DWORD PTR $T42362[ebp]
	push	eax
	mov	ecx, DWORD PTR _shootOrigin$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T42361[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2288				; 000008f0H
	push	eax
	lea	ecx, DWORD PTR $T42360[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEnemy$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T42359[ebp]
	push	edx
	mov	eax, DWORD PTR _shootOrigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T42358[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEnemy$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEnemy$[ebp]
	call	DWORD PTR [eax+316]
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L40949
$L40943:

; 3337 : 		return gpGlobals->v_forward;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L40949:

; 3338 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShootAtEnemy@CBaseMonster@@QAE?AVVector@@ABV2@@Z ENDP	; CBaseMonster::ShootAtEnemy
_TEXT	ENDS
PUBLIC	?FacingIdeal@CBaseMonster@@QAEHXZ		; CBaseMonster::FacingIdeal
PUBLIC	__real@8@3ff7c49ba5e353f7d000
;	COMDAT __real@8@3ff7c49ba5e353f7d000
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
__real@8@3ff7c49ba5e353f7d000 DQ 03f789374bc6a7efar ; 0.006
CONST	ENDS
;	COMDAT ?FacingIdeal@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FacingIdeal@CBaseMonster@@QAEHXZ PROC NEAR		; CBaseMonster::FacingIdeal, COMDAT

; 3350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3351 : 	if ( fabs( FlYawDiff() ) <= 0.006 )//!!!BUGBUG - no magic numbers!!!

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlYawDiff@CBaseMonster@@QAEMXZ		; CBaseMonster::FlYawDiff
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3ff7c49ba5e353f7d000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40954

; 3353 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L40953
$L40954:

; 3355 : 
; 3356 : 	return FALSE;

	xor	eax, eax
$L40953:

; 3357 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FacingIdeal@CBaseMonster@@QAEHXZ ENDP			; CBaseMonster::FacingIdeal
_TEXT	ENDS
PUBLIC	?FCanActiveIdle@CBaseMonster@@UAEHXZ		; CBaseMonster::FCanActiveIdle
;	COMDAT ?FCanActiveIdle@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FCanActiveIdle@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::FCanActiveIdle, COMDAT

; 3363 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3364 : 	/*
; 3365 : 	if ( m_MonsterState == MONSTERSTATE_IDLE && m_IdealMonsterState == MONSTERSTATE_IDLE && !IsMoving() )
; 3366 : 	{
; 3367 : 		return TRUE;
; 3368 : 	}
; 3369 : 	*/
; 3370 : 	return FALSE;

	xor	eax, eax

; 3371 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FCanActiveIdle@CBaseMonster@@UAEHXZ ENDP		; CBaseMonster::FCanActiveIdle
_TEXT	ENDS
PUBLIC	?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z	; CBaseMonster::PlaySentence
;	COMDAT ?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
_TEXT	SEGMENT
_volume$ = 16
_attenuation$ = 20
_this$ = -4
_pszSentence$ = 8
?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z PROC NEAR	; CBaseMonster::PlaySentence, COMDAT

; 3375 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3376 : 	if ( pszSentence && IsAlive() )

	cmp	DWORD PTR _pszSentence$[ebp], 0
	je	SHORT $L40968
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	je	SHORT $L40968

; 3378 : 		if ( pszSentence[0] == '!' )

	mov	eax, DWORD PTR _pszSentence$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	jne	SHORT $L40967

; 3379 : 			EMIT_SOUND_DYN( edict(), CHAN_VOICE, pszSentence, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	edx, DWORD PTR _attenuation$[ebp]
	push	edx
	mov	eax, DWORD PTR _volume$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszSentence$[ebp]
	push	ecx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 3380 : 		else

	jmp	SHORT $L40968
$L40967:

; 3381 : 			SENTENCEG_PlayRndSz( edict(), pszSentence, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	edx, DWORD PTR _attenuation$[ebp]
	push	edx
	mov	eax, DWORD PTR _volume$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszSentence$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H
$L40968:

; 3383 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z ENDP		; CBaseMonster::PlaySentence
_TEXT	ENDS
PUBLIC	?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z ; CBaseMonster::PlayScriptedSentence
;	COMDAT ?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pszSentence$ = 8
_duration$ = 12
_volume$ = 16
_attenuation$ = 20
_this$ = -4
?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z PROC NEAR ; CBaseMonster::PlayScriptedSentence, COMDAT

; 3387 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3388 : 	PlaySentence( pszSentence, duration, volume, attenuation );

	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _duration$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszSentence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]

; 3389 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z ENDP ; CBaseMonster::PlayScriptedSentence
_TEXT	ENDS
PUBLIC	??_C@_0BA@LNFJ@common?1null?4wav?$AA@		; `string'
PUBLIC	?SentenceStop@CBaseMonster@@UAEXXZ		; CBaseMonster::SentenceStop
;	COMDAT ??_C@_0BA@LNFJ@common?1null?4wav?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BA@LNFJ@common?1null?4wav?$AA@ DB 'common/null.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?SentenceStop@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SentenceStop@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::SentenceStop, COMDAT

; 3393 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3394 : 	EMIT_SOUND( edict(), CHAN_VOICE, "common/null.wav", 1.0, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BA@LNFJ@common?1null?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 3395 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SentenceStop@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::SentenceStop
_TEXT	ENDS
PUBLIC	??_C@_04BAK@NULL?$AA@				; `string'
EXTRN	?SetSequenceBox@CBaseAnimating@@QAEXXZ:NEAR	; CBaseAnimating::SetSequenceBox
EXTRN	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalOrigin
;	COMDAT ??_C@_04BAK@NULL?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_04BAK@NULL?$AA@ DB 'NULL', 00H			; `string'
CONST	ENDS
;	COMDAT ?CorpseFallThink@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CorpseFallThink@CBaseMonster@@QAEXXZ PROC NEAR		; CBaseMonster::CorpseFallThink, COMDAT

; 3399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3400 : 	if ( pev->flags & FL_ONGROUND )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	SHORT $L40988

; 3402 : 		SetThink ( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 3403 : 
; 3404 : 		SetSequenceBox( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSequenceBox@CBaseAnimating@@QAEXXZ	; CBaseAnimating::SetSequenceBox

; 3405 : 		UTIL_SetOrigin( this, GetLocalOrigin());// link into world.

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 3407 : 	else

	jmp	SHORT $L40992
$L40988:

; 3408 : 		pev->nextthink = gpGlobals->time + 0.1;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+260]
$L40992:

; 3409 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CorpseFallThink@CBaseMonster@@QAEXXZ ENDP		; CBaseMonster::CorpseFallThink
_TEXT	ENDS
PUBLIC	?MonsterInitDead@CBaseMonster@@UAEXXZ		; CBaseMonster::MonsterInitDead
EXTRN	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z:NEAR ; UTIL_SetSize
;	COMDAT ?MonsterInitDead@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MonsterInitDead@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::MonsterInitDead, COMDAT

; 3413 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3414 : 	InitBoneControllers();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitBoneControllers@CBaseAnimating@@QAEXXZ ; CBaseAnimating::InitBoneControllers

; 3415 : 
; 3416 : 	pev->solid			= SOLID_BBOX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 2

; 3417 : 	pev->movetype		= MOVETYPE_TOSS;// so he'll fall to ground

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 6

; 3418 : 
; 3419 : 	pev->frame = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+304], 0

; 3420 : 	ResetSequenceInfo( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetSequenceInfo@CBaseAnimating@@QAEXXZ ; CBaseAnimating::ResetSequenceInfo

; 3421 : 	pev->framerate = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+312], 0

; 3422 : 	
; 3423 : 	// Copy health
; 3424 : 	pev->max_health		= pev->health;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+352]
	mov	DWORD PTR [edx+432], eax

; 3425 : 	pev->deadflag		= DEAD_DEAD;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+368], 2

; 3426 : 	
; 3427 : 	UTIL_SetSize(pev, g_vecZero, g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 3428 : 	UTIL_SetOrigin( this, GetLocalOrigin());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 3429 : 
; 3430 : 	// Setup health counters, etc.
; 3431 : 	BecomeDead();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+376]

; 3432 : 	SetThink( CorpseFallThink );

	push	OFFSET FLAT:??_C@_0BA@OIHI@CorpseFallThink?$AA@ ; `string'
	push	OFFSET FLAT:?CorpseFallThink@CBaseMonster@@QAEXXZ ; CBaseMonster::CorpseFallThink
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 3433 : 	pev->nextthink = gpGlobals->time + 0.5;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffe8000000000000000
	fst	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 3434 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MonsterInitDead@CBaseMonster@@UAEXXZ ENDP		; CBaseMonster::MonsterInitDead
_TEXT	ENDS
PUBLIC	?BBoxFlat@CBaseMonster@@QAEHXZ			; CBaseMonster::BBoxFlat
;	COMDAT ?BBoxFlat@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_tr$ = -60
_vecPoint$ = -72
_flXSize$ = -76
_flYSize$ = -80
_flLength$ = -84
_flLength2$ = -88
$T42381 = -100
$T42382 = -112
$T42383 = -124
$T42384 = -136
$T42385 = -148
$T42386 = -160
$T42387 = -172
$T42388 = -184
$T42389 = -196
$T42390 = -208
$T42391 = -220
$T42392 = -232
?BBoxFlat@CBaseMonster@@QAEHXZ PROC NEAR		; CBaseMonster::BBoxFlat, COMDAT

; 3442 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3443 : 	TraceResult	tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 3444 : 	Vector		vecPoint;

	lea	ecx, DWORD PTR _vecPoint$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 3445 : 	float		flXSize, flYSize;
; 3446 : 	float		flLength;
; 3447 : 	float		flLength2;
; 3448 : 
; 3449 : 	flXSize = pev->size.x / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+244]
	fdiv	DWORD PTR __real@4@40008000000000000000
	fstp	DWORD PTR _flXSize$[ebp]

; 3450 : 	flYSize = pev->size.y / 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+248]
	fdiv	DWORD PTR __real@4@40008000000000000000
	fstp	DWORD PTR _flYSize$[ebp]

; 3451 : 
; 3452 : 	vecPoint.x = GetAbsOrigin().x + flXSize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	fld	DWORD PTR _flXSize$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _vecPoint$[ebp]

; 3453 : 	vecPoint.y = GetAbsOrigin().y + flYSize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	fld	DWORD PTR _flYSize$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _vecPoint$[ebp+4]

; 3454 : 	vecPoint.z = GetAbsOrigin().z;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecPoint$[ebp+8], ecx

; 3455 : 
; 3456 : 	UTIL_TraceLine ( vecPoint, vecPoint - Vector ( 0, 0, 100 ), ignore_monsters, ENT(pev), &tr );

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	push	1120403456				; 42c80000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T42381[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	edx, DWORD PTR $T42382[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecPoint$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	eax, DWORD PTR _vecPoint$[ebp]
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 3457 : 	flLength = (vecPoint - tr.vecEndPos).Length();

	lea	ecx, DWORD PTR _tr$[ebp+20]
	push	ecx
	lea	edx, DWORD PTR $T42383[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecPoint$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLength$[ebp]

; 3458 : 
; 3459 : 	vecPoint.x = GetAbsOrigin().x - flXSize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	fld	DWORD PTR [eax]
	fsub	DWORD PTR _flXSize$[ebp]
	fstp	DWORD PTR _vecPoint$[ebp]

; 3460 : 	vecPoint.y = GetAbsOrigin().y - flYSize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR _flYSize$[ebp]
	fstp	DWORD PTR _vecPoint$[ebp+4]

; 3461 : 
; 3462 : 	UTIL_TraceLine ( vecPoint, vecPoint - Vector ( 0, 0, 100 ), ignore_monsters, ENT(pev), &tr );

	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	push	1120403456				; 42c80000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T42384[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T42385[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecPoint$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecPoint$[ebp]
	push	ecx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 3463 : 	flLength2 = (vecPoint - tr.vecEndPos).Length();

	lea	edx, DWORD PTR _tr$[ebp+20]
	push	edx
	lea	eax, DWORD PTR $T42386[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecPoint$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLength2$[ebp]

; 3464 : 	if ( flLength2 > flLength )

	fld	DWORD PTR _flLength2$[ebp]
	fcomp	DWORD PTR _flLength$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41015

; 3466 : 		return FALSE;

	xor	eax, eax
	jmp	$L41002
$L41015:

; 3468 : 	flLength = flLength2;

	mov	ecx, DWORD PTR _flLength2$[ebp]
	mov	DWORD PTR _flLength$[ebp], ecx

; 3469 : 
; 3470 : 	vecPoint.x = GetAbsOrigin().x - flXSize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	fld	DWORD PTR [eax]
	fsub	DWORD PTR _flXSize$[ebp]
	fstp	DWORD PTR _vecPoint$[ebp]

; 3471 : 	vecPoint.y = GetAbsOrigin().y + flYSize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	fld	DWORD PTR _flYSize$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _vecPoint$[ebp+4]

; 3472 : 	UTIL_TraceLine ( vecPoint, vecPoint - Vector ( 0, 0, 100 ), ignore_monsters, ENT(pev), &tr );

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	push	1120403456				; 42c80000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T42387[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	edx, DWORD PTR $T42388[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecPoint$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	eax, DWORD PTR _vecPoint$[ebp]
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 3473 : 	flLength2 = (vecPoint - tr.vecEndPos).Length();

	lea	ecx, DWORD PTR _tr$[ebp+20]
	push	ecx
	lea	edx, DWORD PTR $T42389[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecPoint$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLength2$[ebp]

; 3474 : 	if ( flLength2 > flLength )

	fld	DWORD PTR _flLength2$[ebp]
	fcomp	DWORD PTR _flLength$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41019

; 3476 : 		return FALSE;

	xor	eax, eax
	jmp	$L41002
$L41019:

; 3478 : 	flLength = flLength2;

	mov	eax, DWORD PTR _flLength2$[ebp]
	mov	DWORD PTR _flLength$[ebp], eax

; 3479 : 
; 3480 : 	vecPoint.x = GetAbsOrigin().x + flXSize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	fld	DWORD PTR _flXSize$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _vecPoint$[ebp]

; 3481 : 	vecPoint.y = GetAbsOrigin().y - flYSize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR _flYSize$[ebp]
	fstp	DWORD PTR _vecPoint$[ebp+4]

; 3482 : 	UTIL_TraceLine ( vecPoint, vecPoint - Vector ( 0, 0, 100 ), ignore_monsters, ENT(pev), &tr );

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	push	1120403456				; 42c80000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T42390[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T42391[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecPoint$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	edx, DWORD PTR _vecPoint$[ebp]
	push	edx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 3483 : 	flLength2 = (vecPoint - tr.vecEndPos).Length();

	lea	eax, DWORD PTR _tr$[ebp+20]
	push	eax
	lea	ecx, DWORD PTR $T42392[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecPoint$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLength2$[ebp]

; 3484 : 	if ( flLength2 > flLength )

	fld	DWORD PTR _flLength2$[ebp]
	fcomp	DWORD PTR _flLength$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41023

; 3486 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L41002
$L41023:

; 3488 : 	flLength = flLength2;

	mov	edx, DWORD PTR _flLength2$[ebp]
	mov	DWORD PTR _flLength$[ebp], edx

; 3489 : 
; 3490 : 	return TRUE;

	mov	eax, 1
$L41002:

; 3491 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BBoxFlat@CBaseMonster@@QAEHXZ ENDP			; CBaseMonster::BBoxFlat
_TEXT	ENDS
PUBLIC	?GetEnemy@CBaseMonster@@QAEHXZ			; CBaseMonster::GetEnemy
PUBLIC	?GetMonsterPointer@CBaseEntity@@SAPAVCBaseMonster@@PAUedict_s@@@Z ; CBaseEntity::GetMonsterPointer
;	COMDAT ?GetEnemy@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_pNewEnemy$ = -8
_pOwner$41034 = -12
?GetEnemy@CBaseMonster@@QAEHXZ PROC NEAR		; CBaseMonster::GetEnemy, COMDAT

; 3497 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3498 : 	CBaseEntity *pNewEnemy;
; 3499 : 
; 3500 : 	if ( HasConditions(bits_COND_SEE_HATE | bits_COND_SEE_DISLIKE | bits_COND_SEE_NEMESIS) )

	push	4194314					; 0040000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	$L41035

; 3502 : 		pNewEnemy = BestVisibleEnemy();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+384]
	mov	DWORD PTR _pNewEnemy$[ebp], eax

; 3503 : 
; 3504 : 		if ( pNewEnemy != m_hEnemy && pNewEnemy != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	cmp	DWORD PTR _pNewEnemy$[ebp], eax
	je	$L41035
	cmp	DWORD PTR _pNewEnemy$[ebp], 0
	je	$L41035

; 3506 : 			// DO NOT mess with the monster's m_hEnemy pointer unless the schedule the monster is currently running will be interrupted
; 3507 : 			// by COND_NEW_ENEMY. This will eliminate the problem of monsters getting a new enemy while they are in a schedule that doesn't care,
; 3508 : 			// and then not realizing it by the time they get to a schedule that does. I don't feel this is a good permanent fix. 
; 3509 : 
; 3510 : 			if ( m_pSchedule )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2092], 0
	je	$L41035

; 3512 : 				if ( m_pSchedule->iInterruptMask & bits_COND_NEW_ENEMY )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2092]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 65536				; 00010000H
	test	eax, eax
	je	SHORT $L41032

; 3514 : 					PushEnemy( m_hEnemy, m_vecEnemyLKP );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushEnemy@CBaseMonster@@QAEXPAVCBaseEntity@@AAVVector@@@Z ; CBaseMonster::PushEnemy

; 3515 : 					SetConditions(bits_COND_NEW_ENEMY);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions

; 3516 : 					m_hEnemy = pNewEnemy;

	mov	edx, DWORD PTR _pNewEnemy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 3517 : 					m_vecEnemyLKP = m_hEnemy->GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L41032:

; 3519 : 				// if the new enemy has an owner, take that one as well
; 3520 : 				if (pNewEnemy->pev->owner != NULL)

	mov	ecx, DWORD PTR _pNewEnemy$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+408], 0
	je	SHORT $L41035

; 3522 : 					CBaseEntity *pOwner = GetMonsterPointer( pNewEnemy->pev->owner );

	mov	eax, DWORD PTR _pNewEnemy$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+408]
	push	edx
	call	?GetMonsterPointer@CBaseEntity@@SAPAVCBaseMonster@@PAUedict_s@@@Z ; CBaseEntity::GetMonsterPointer
	add	esp, 4
	mov	DWORD PTR _pOwner$41034[ebp], eax

; 3523 : 					if ( pOwner && (pOwner->pev->flags & FL_MONSTER) && IRelationship( pOwner ) != R_NO )

	cmp	DWORD PTR _pOwner$41034[ebp], 0
	je	SHORT $L41035
	mov	eax, DWORD PTR _pOwner$41034[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 32					; 00000020H
	test	edx, edx
	je	SHORT $L41035
	mov	eax, DWORD PTR _pOwner$41034[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+364]
	test	eax, eax
	je	SHORT $L41035

; 3524 : 						PushEnemy( pOwner, m_vecEnemyLKP );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2288				; 000008f0H
	push	eax
	mov	ecx, DWORD PTR _pOwner$41034[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushEnemy@CBaseMonster@@QAEXPAVCBaseEntity@@AAVVector@@@Z ; CBaseMonster::PushEnemy
$L41035:

; 3529 : 
; 3530 : 	// remember old enemies
; 3531 : 	if (m_hEnemy == NULL && PopEnemy( ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $L41038
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PopEnemy@CBaseMonster@@QAEHXZ		; CBaseMonster::PopEnemy
	test	eax, eax
	je	SHORT $L41038

; 3533 : 		if ( m_pSchedule )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2092], 0
	je	SHORT $L41038

; 3535 : 			if ( m_pSchedule->iInterruptMask & bits_COND_NEW_ENEMY )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2092]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 65536				; 00010000H
	test	edx, edx
	je	SHORT $L41038

; 3537 : 				SetConditions(bits_COND_NEW_ENEMY);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
$L41038:

; 3541 : 
; 3542 : 	if ( m_hEnemy != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L41039

; 3544 : 		// monster has an enemy.
; 3545 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L41027
$L41039:

; 3547 : 
; 3548 : 	return FALSE;// monster has no enemy

	xor	eax, eax
$L41027:

; 3549 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEnemy@CBaseMonster@@QAEHXZ ENDP			; CBaseMonster::GetEnemy
_TEXT	ENDS
;	COMDAT ?GetMonsterPointer@CBaseEntity@@SAPAVCBaseMonster@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEntity$ = -4
_pentMonster$ = 8
?GetMonsterPointer@CBaseEntity@@SAPAVCBaseMonster@@PAUedict_s@@@Z PROC NEAR ; CBaseEntity::GetMonsterPointer, COMDAT

; 544  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 545  : 		CBaseEntity *pEntity = Instance( pentMonster );

	mov	eax, DWORD PTR _pentMonster$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 546  : 		if ( pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L35041

; 547  : 			return pEntity->MyMonsterPointer();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+124]
	jmp	SHORT $L35039
$L35041:

; 548  : 		return NULL;

	xor	eax, eax
$L35039:

; 549  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMonsterPointer@CBaseEntity@@SAPAVCBaseMonster@@PAUedict_s@@@Z ENDP ; CBaseEntity::GetMonsterPointer
_TEXT	ENDS
PUBLIC	??_C@_0BM@OMMM@DropItem?$CI?$CJ?5?9?5No?5item?5name?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@DAON@DropItem?$CI?$CJ?5?9?5Didn?8t?5create?$CB?6?$AA@ ; `string'
PUBLIC	?DropItem@CBaseMonster@@QAEPAVCBaseEntity@@PADABVVector@@1@Z ; CBaseMonster::DropItem
EXTRN	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalVelocity
EXTRN	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAvelocity
EXTRN	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z:NEAR ; CBaseEntity::Create
;	COMDAT ??_C@_0BM@OMMM@DropItem?$CI?$CJ?5?9?5No?5item?5name?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0BM@OMMM@DropItem?$CI?$CJ?5?9?5No?5item?5name?$CB?6?$AA@ DB 'DropIt'
	DB	'em() - No item name!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DAON@DropItem?$CI?$CJ?5?9?5Didn?8t?5create?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BN@DAON@DropItem?$CI?$CJ?5?9?5Didn?8t?5create?$CB?6?$AA@ DB 'DropI'
	DB	'tem() - Didn''t create!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?DropItem@CBaseMonster@@QAEPAVCBaseEntity@@PADABVVector@@1@Z
_TEXT	SEGMENT
_pszItemName$ = 8
_vecPos$ = 12
_vecAng$ = 16
_this$ = -4
_pItem$ = -8
$T42399 = -20
?DropItem@CBaseMonster@@QAEPAVCBaseEntity@@PADABVVector@@1@Z PROC NEAR ; CBaseMonster::DropItem, COMDAT

; 3556 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3557 : 	if ( !pszItemName )

	cmp	DWORD PTR _pszItemName$[ebp], 0
	jne	SHORT $L41046

; 3559 : 		ALERT ( at_console, "DropItem() - No item name!\n" );

	push	OFFSET FLAT:??_C@_0BM@OMMM@DropItem?$CI?$CJ?5?9?5No?5item?5name?$CB?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3560 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L41051
$L41046:

; 3562 : 
; 3563 : 	CBaseEntity *pItem = CBaseEntity::Create( pszItemName, vecPos, vecAng, edict() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	eax, DWORD PTR _vecAng$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszItemName$[ebp]
	push	edx
	call	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z ; CBaseEntity::Create
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pItem$[ebp], eax

; 3564 : 
; 3565 : 	if ( pItem )

	cmp	DWORD PTR _pItem$[ebp], 0
	je	SHORT $L41049

; 3567 : 		// do we want this behavior to be default?! (sjb)
; 3568 : 		pItem->SetLocalVelocity( GetAbsVelocity() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 3569 : 		pItem->SetLocalAvelocity( Vector ( 0, RANDOM_FLOAT( 0, 100 ), 0 ));

	push	0
	push	1120403456				; 42c80000H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	0
	lea	ecx, DWORD PTR $T42399[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 3570 : 		return pItem;

	mov	eax, DWORD PTR _pItem$[ebp]
	jmp	SHORT $L41051
$L41049:

; 3574 : 		ALERT ( at_console, "DropItem() - Didn't create!\n" );

	push	OFFSET FLAT:??_C@_0BN@DAON@DropItem?$CI?$CJ?5?9?5Didn?8t?5create?$CB?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3575 : 		return FALSE;

	xor	eax, eax
$L41051:

; 3577 : 
; 3578 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DropItem@CBaseMonster@@QAEPAVCBaseEntity@@PADABVVector@@1@Z ENDP ; CBaseMonster::DropItem
_TEXT	ENDS
PUBLIC	?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ		; CBaseMonster::ShouldFadeOnDeath
;	COMDAT ?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ PROC NEAR	; CBaseMonster::ShouldFadeOnDeath, COMDAT

; 3582 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3583 : 	// if flagged to fade out or I have an owner (I came from a monster spawner)
; 3584 : 	if ( (pev->spawnflags & SF_MONSTER_FADECORPSE) || !FNullEnt( pev->owner ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 512				; 00000200H
	test	edx, edx
	jne	SHORT $L41058
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+408]
	push	edx
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41057
$L41058:

; 3585 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L41056
$L41057:

; 3586 : 
; 3587 : 	return FALSE;

	xor	eax, eax
$L41056:

; 3588 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ ENDP		; CBaseMonster::ShouldFadeOnDeath
_TEXT	ENDS
;	COMDAT _$E41
_TEXT	SEGMENT
_$E41	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E40
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E41	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCMonsterTarget@@@@QAE@PBD@Z ; CEntityFactory<CMonsterTarget>::CEntityFactory<CMonsterTarget>
PUBLIC	??_C@_0P@MDCK@monster_target?$AA@		; `string'
_BSS	SEGMENT
	ALIGN	4

_monster_target DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0P@MDCK@monster_target?$AA@
; File z:\xashxtsrc\server\monsters\monsters.cpp
CONST	SEGMENT
??_C@_0P@MDCK@monster_target?$AA@ DB 'monster_target', 00H ; `string'
CONST	ENDS
;	COMDAT _$E40
_TEXT	SEGMENT
_$E40	PROC NEAR					; COMDAT

; 3602 : LINK_ENTITY_TO_CLASS( monster_target, CMonsterTarget );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0P@MDCK@monster_target?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_monster_target
	call	??0?$CEntityFactory@VCMonsterTarget@@@@QAE@PBD@Z ; CEntityFactory<CMonsterTarget>::CEntityFactory<CMonsterTarget>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E40	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CMonsterTarget@@UAEXXZ			; CMonsterTarget::Spawn
;	COMDAT ?Spawn@CMonsterTarget@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CMonsterTarget@@UAEXXZ PROC NEAR			; CMonsterTarget::Spawn, COMDAT

; 3605 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3606 : 	if( pev->spawnflags & SF_MONSTERTARGET_OFF )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1
	test	edx, edx
	je	SHORT $L41120

; 3607 : 		pev->health = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+352], 0

; 3608 : 	else

	jmp	SHORT $L41121
$L41120:

; 3609 : 		pev->health = 1; // Don't ignore me, I'm not dead. I'm quite well really. I think I'll go for a walk...

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+352], 1065353216		; 3f800000H
$L41121:

; 3610 : 
; 3611 : 	SetBits( pev->flags, FL_MONSTER );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+420], eax

; 3612 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CMonsterTarget@@UAEXXZ ENDP			; CMonsterTarget::Spawn
_TEXT	ENDS
PUBLIC	?KeyValue@CMonsterTarget@@UAEXPAUKeyValueData_s@@@Z ; CMonsterTarget::KeyValue
PUBLIC	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
;	COMDAT ?KeyValue@CMonsterTarget@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CMonsterTarget@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CMonsterTarget::KeyValue, COMDAT

; 3615 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3616 : 	if( FStrEq( pkvd->szKeyName, "m_iClass" ))

	push	OFFSET FLAT:??_C@_08IAEJ@m_iClass?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L41126

; 3618 : 		pev->frags = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	fild	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+356]

; 3619 : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 3621 : 	else

	jmp	SHORT $L41127
$L41126:

; 3623 : 		CBaseEntity::KeyValue( pkvd );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
$L41127:

; 3625 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CMonsterTarget@@UAEXPAUKeyValueData_s@@@Z ENDP ; CMonsterTarget::KeyValue
_TEXT	ENDS
PUBLIC	??_C@_06FOPF@parent?$AA@			; `string'
PUBLIC	??_C@_08IDGH@movewith?$AA@			; `string'
PUBLIC	??_C@_0M@FCIN@parentflags?$AA@			; `string'
PUBLIC	??_C@_05JCDO@style?$AA@				; `string'
PUBLIC	??_C@_0L@MCHI@reflection?$AA@			; `string'
PUBLIC	??_C@_0N@DCCA@vlight_cache?$AA@			; `string'
;	COMDAT ??_C@_06FOPF@parent?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_06FOPF@parent?$AA@ DB 'parent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT
??_C@_08IDGH@movewith?$AA@ DB 'movewith', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT
??_C@_0M@FCIN@parentflags?$AA@ DB 'parentflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT
??_C@_05JCDO@style?$AA@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT
??_C@_0L@MCHI@reflection?$AA@ DB 'reflection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT
??_C@_0N@DCCA@vlight_cache?$AA@ DB 'vlight_cache', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pkvd$ = 8
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseEntity::KeyValue, COMDAT

; 328  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 		// get support for spirit field too
; 330  : 		if( FStrEq( pkvd->szKeyName, "parent" ) || FStrEq( pkvd->szKeyName, "movewith" ))

	push	OFFSET FLAT:??_C@_06FOPF@parent?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L34875
	push	OFFSET FLAT:??_C@_08IDGH@movewith?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34874
$L34875:

; 332  : 			m_iParent = ALLOC_STRING(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 333  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 335  : 		else if( FStrEq( pkvd->szKeyName, "parentflags" ))

	jmp	$L34896
$L34874:
	push	OFFSET FLAT:??_C@_0M@FCIN@parentflags?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34879

; 337  : 			m_iParentFlags = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 338  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 340  : 		else if( FStrEq( pkvd->szKeyName, "style" ))

	jmp	$L34896
$L34879:
	push	OFFSET FLAT:??_C@_05JCDO@style?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34882

; 342  : 			m_iStyle = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 343  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 345  : 		else if( FStrEq( pkvd->szKeyName, "reflection" ))

	jmp	$L34896
$L34882:
	push	OFFSET FLAT:??_C@_0L@MCHI@reflection?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34885

; 348  : 			{

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L34891
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L34892
	jmp	SHORT $L34888
$L34891:

; 349  : 			case 1: pev->effects |= EF_NOREFLECT; break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
	jmp	SHORT $L34888
$L34892:

; 350  : 			case 2: pev->effects |= EF_REFLECTONLY; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L34888:

; 352  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 354  : 		else if( FStrEq(pkvd->szKeyName, "vlight_cache"))

	jmp	SHORT $L34896
$L34885:
	push	OFFSET FLAT:??_C@_0N@DCCA@vlight_cache?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34894

; 356  : 			pev->iuser3 = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+588], eax

; 357  : 			pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 359  : 		else pkvd->fHandled = FALSE;

	jmp	SHORT $L34896
$L34894:
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L34896:

; 360  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseEntity::KeyValue
_TEXT	ENDS
PUBLIC	?Use@CMonsterTarget@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CMonsterTarget::Use
EXTRN	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z:NEAR ; CBaseEntity::ShouldToggle
;	COMDAT ?Use@CMonsterTarget@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_useType$ = 16
_this$ = -4
?Use@CMonsterTarget@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CMonsterTarget::Use, COMDAT

; 3628 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3629 : 	if( ShouldToggle( useType ))

	mov	eax, DWORD PTR _useType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z ; CBaseEntity::ShouldToggle
	test	eax, eax
	je	SHORT $L41137

; 3631 : 		if( pev->health )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41136

; 3632 : 			pev->health = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+352], 0

; 3633 : 		else

	jmp	SHORT $L41137
$L41136:

; 3634 : 			pev->health = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+352], 1065353216		; 3f800000H
$L41137:

; 3636 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CMonsterTarget@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CMonsterTarget::Use
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCMonsterTarget@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CMonsterTarget>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCMonsterTarget@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CMonsterTarget>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCMonsterTarget@@@@UAEIXZ ; CEntityFactory<CMonsterTarget>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCMonsterTarget@@@@6B@	; CEntityFactory<CMonsterTarget>::`vftable'
PUBLIC	??0IEntityFactory@@QAE@XZ			; IEntityFactory::IEntityFactory
EXTRN	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ:NEAR ; EntityFactoryDictionary
;	COMDAT ??_7?$CEntityFactory@VCMonsterTarget@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCMonsterTarget@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCMonsterTarget@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CMonsterTarget>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCMonsterTarget@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCMonsterTarget@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCMonsterTarget@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCMonsterTarget@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CMonsterTarget>::CEntityFactory<CMonsterTarget>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCMonsterTarget@@@@6B@ ; CEntityFactory<CMonsterTarget>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCMonsterTarget@@@@QAE@PBD@Z ENDP	; CEntityFactory<CMonsterTarget>::CEntityFactory<CMonsterTarget>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCMonsterTarget@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCMonsterTarget@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CMonsterTarget>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCMonsterTarget@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CMonsterTarget>::Create
_TEXT	ENDS
EXTRN	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_Remove
;	COMDAT ?Destroy@?$CEntityFactory@VCMonsterTarget@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCMonsterTarget@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CMonsterTarget>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCMonsterTarget@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CMonsterTarget>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCMonsterTarget@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCMonsterTarget@@@@UAEIXZ PROC NEAR ; CEntityFactory<CMonsterTarget>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1764				; 000006e4H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCMonsterTarget@@@@UAEIXZ ENDP ; CEntityFactory<CMonsterTarget>::GetEntitySize
_TEXT	ENDS
PUBLIC	??_7IEntityFactory@@6B@				; IEntityFactory::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT
??_7IEntityFactory@@6B@ DD FLAT:__purecall		; IEntityFactory::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IEntityFactory@@QAE@XZ PROC NEAR			; IEntityFactory::IEntityFactory, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IEntityFactory@@6B@ ; IEntityFactory::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0IEntityFactory@@QAE@XZ ENDP				; IEntityFactory::IEntityFactory
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_this$ = -16
__$EHRec$ = -12
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
PUBLIC	??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
PUBLIC	??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
PUBLIC	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT
??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ DB '('
	DB	'Base() == NULL) || (&src < Base()) || (&src >= (Base() + Coun'
	DB	't()) )', 00H				; `string'
CONST	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L42448
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L42448
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L42448
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42448:

; 520  : 	return InsertBefore( m_Size, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseToggle@@2Udatamap_s@@A:BYTE	; CBaseToggle::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseToggle@@2Udatamap_s@@A ; CBaseToggle::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	??0CMonsterTarget@@QAE@XZ			; CMonsterTarget::CMonsterTarget
PUBLIC	?SetClassname@CBaseEntity@@QAEXPBD@Z		; CBaseEntity::SetClassname
PUBLIC	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z		; CBaseEntity::operator new
PUBLIC	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z		; CBaseEntity::operator delete
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T42453 = -20
$T42454 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L41182

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L41182:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L41184

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1764					; 000006e4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T42454[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T42454[ebp], 0
	je	SHORT $L42455
	mov	ecx, DWORD PTR $T42454[ebp]
	call	??0CMonsterTarget@@QAE@XZ		; CMonsterTarget::CMonsterTarget
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L42456
$L42455:
	mov	DWORD PTR -28+[ebp], 0
$L42456:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T42453[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T42453[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L41184:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T42454[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCMonsterTarget@@PAV1@PBD@Z ENDP	; GetClassPtr
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4
_pszClassName$ = 8
?SetClassname@CBaseEntity@@QAEXPBD@Z PROC NEAR		; CBaseEntity::SetClassname, COMDAT

; 302  : 	void		SetClassname( const char *pszClassName ) { pev->classname = MAKE_STRING( pszClassName ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClassname@CBaseEntity@@QAEXPBD@Z ENDP		; CBaseEntity::SetClassname
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT
_stAllocateBlock$ = 8
_pev$ = 12
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator new, COMDAT

; 489  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 490  : 		return (void *)ALLOC_PRIVATE(ENT(pev), stAllocateBlock);

	mov	eax, DWORD PTR _stAllocateBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+252
	add	esp, 8

; 491  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z ENDP		; CBaseEntity::operator new
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 12
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator delete, COMDAT

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 497  : 		pev->flags |= FL_KILLME;

	mov	eax, DWORD PTR _pev$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+420], ecx

; 498  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z ENDP		; CBaseEntity::operator delete
_TEXT	ENDS
PUBLIC	?EarPosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EarPosition
PUBLIC	?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z	; CBaseEntity::BodyTarget
PUBLIC	?IsPointSized@CBaseEntity@@UBEHXZ		; CBaseEntity::IsPointSized
PUBLIC	?Illumination@CBaseEntity@@UAEHXZ		; CBaseEntity::Illumination
PUBLIC	??0CBaseEntity@@QAE@XZ				; CBaseEntity::CBaseEntity
PUBLIC	?GetState@CMonsterTarget@@UAE?AW4STATE@@XZ	; CMonsterTarget::GetState
PUBLIC	?Classify@CMonsterTarget@@UAEHXZ		; CMonsterTarget::Classify
PUBLIC	??_7CMonsterTarget@@6B@				; CMonsterTarget::`vftable'
PUBLIC	?Precache@CBaseEntity@@UAEXXZ			; CBaseEntity::Precache
PUBLIC	?ObjectCaps@CBaseEntity@@UAEHXZ			; CBaseEntity::ObjectCaps
PUBLIC	?Activate@CBaseEntity@@UAEXXZ			; CBaseEntity::Activate
PUBLIC	?OnChangeLevel@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeLevel
PUBLIC	?OnTeleport@CBaseEntity@@UAEXXZ			; CBaseEntity::OnTeleport
PUBLIC	?PortalSleep@CBaseEntity@@UAEXM@Z		; CBaseEntity::PortalSleep
PUBLIC	?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ; CBaseEntity::StartMessage
PUBLIC	?GetPosition@CBaseEntity@@UAEMXZ		; CBaseEntity::GetPosition
PUBLIC	?OnChangeParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeParent
PUBLIC	?OnClearParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnClearParent
PUBLIC	?OnRemove@CBaseEntity@@UAEXXZ			; CBaseEntity::OnRemove
PUBLIC	?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z	; CBaseEntity::DeathNotice
PUBLIC	?IsRigidBody@CBaseEntity@@UAEHXZ		; CBaseEntity::IsRigidBody
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z	; CBaseEntity::GetState
PUBLIC	?BloodColor@CBaseEntity@@UAEHXZ			; CBaseEntity::BloodColor
PUBLIC	?IsTriggered@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::IsTriggered
PUBLIC	?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ; CBaseEntity::MyMonsterPointer
PUBLIC	?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ; CBaseEntity::MySquadMonsterPointer
PUBLIC	?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ	; CBaseEntity::GetVehicleDriver
PUBLIC	?GetToggleState@CBaseEntity@@UAEHXZ		; CBaseEntity::GetToggleState
PUBLIC	?AddPoints@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPoints
PUBLIC	?AddPointsToTeam@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPointsToTeam
PUBLIC	?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::AddPlayerItem
PUBLIC	?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::RemovePlayerItem
PUBLIC	?GiveAmmo@CBaseEntity@@UAEHHPADH@Z		; CBaseEntity::GiveAmmo
PUBLIC	?GetDelay@CBaseEntity@@UAEMXZ			; CBaseEntity::GetDelay
PUBLIC	?IsMoving@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMoving
PUBLIC	?OverrideReset@CBaseEntity@@UAEXXZ		; CBaseEntity::OverrideReset
PUBLIC	?TransferReset@CBaseEntity@@UAEXXZ		; CBaseEntity::TransferReset
PUBLIC	?SetToggleState@CBaseEntity@@UAEXH@Z		; CBaseEntity::SetToggleState
PUBLIC	?StartSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StartSneaking
PUBLIC	?StopSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StopSneaking
PUBLIC	?OnControls@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::OnControls
PUBLIC	?IsSneaking@CBaseEntity@@UAEHXZ			; CBaseEntity::IsSneaking
PUBLIC	?IsAlive@CBaseEntity@@UAEHXZ			; CBaseEntity::IsAlive
PUBLIC	?IsBSPModel@CBaseEntity@@UAEHXZ			; CBaseEntity::IsBSPModel
PUBLIC	?IsCustomModel@CBaseEntity@@UAEHXZ		; CBaseEntity::IsCustomModel
PUBLIC	?ReflectGauss@CBaseEntity@@UAEHXZ		; CBaseEntity::ReflectGauss
PUBLIC	?HasTarget@CBaseEntity@@UAEHH@Z			; CBaseEntity::HasTarget
PUBLIC	?IsPlayer@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPlayer
PUBLIC	?IsNetClient@CBaseEntity@@UAEHXZ		; CBaseEntity::IsNetClient
PUBLIC	?IsMonster@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMonster
PUBLIC	?IsPushable@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPushable
PUBLIC	?IsProjectile@CBaseEntity@@UAEHXZ		; CBaseEntity::IsProjectile
PUBLIC	?IsFuncScreen@CBaseEntity@@UAEHXZ		; CBaseEntity::IsFuncScreen
PUBLIC	?IsPortal@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPortal
PUBLIC	?IsTank@CBaseEntity@@UAEHXZ			; CBaseEntity::IsTank
PUBLIC	?IsMover@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMover
PUBLIC	?IsBreakable@CBaseEntity@@UAEHXZ		; CBaseEntity::IsBreakable
PUBLIC	?TeamID@CBaseEntity@@UAEPBDXZ			; CBaseEntity::TeamID
PUBLIC	?Think@CBaseEntity@@UAEXXZ			; CBaseEntity::Think
PUBLIC	?Touch@CBaseEntity@@UAEXPAV1@@Z			; CBaseEntity::Touch
PUBLIC	?Blocked@CBaseEntity@@UAEXPAV1@@Z		; CBaseEntity::Blocked
PUBLIC	?MoveDone@CBaseEntity@@UAEXXZ			; CBaseEntity::MoveDone
PUBLIC	?Respawn@CBaseEntity@@UAEPAV1@XZ		; CBaseEntity::Respawn
PUBLIC	?UpdateOwner@CBaseEntity@@UAEXXZ		; CBaseEntity::UpdateOwner
PUBLIC	?FBecomeProne@CBaseEntity@@UAEHXZ		; CBaseEntity::FBecomeProne
PUBLIC	?Center@CBaseEntity@@UAE?AVVector@@XZ		; CBaseEntity::Center
PUBLIC	?EyePosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EyePosition
EXTRN	?FVisible@CBaseEntity@@UAEHPAV1@@Z:NEAR		; CBaseEntity::FVisible
EXTRN	?FVisible@CBaseEntity@@UAEHABVVector@@@Z:NEAR	; CBaseEntity::FVisible
EXTRN	?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z:NEAR	; CBaseEntity::ShouldCollide
EXTRN	?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseEntity::GetDataDescMap
EXTRN	?Save@CBaseEntity@@UAEHAAVCSave@@@Z:NEAR	; CBaseEntity::Save
EXTRN	?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z:NEAR	; CBaseEntity::Restore
EXTRN	?SetObjectCollisionBox@CBaseEntity@@UAEXXZ:NEAR	; CBaseEntity::SetObjectCollisionBox
EXTRN	?SetNextThink@CBaseEntity@@UAEXM@Z:NEAR		; CBaseEntity::SetNextThink
EXTRN	?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceAttack
EXTRN	?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseEntity::TakeDamage
EXTRN	?TakeHealth@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeHealth
EXTRN	?TakeArmor@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeArmor
EXTRN	?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z:NEAR	; CBaseEntity::Killed
EXTRN	?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceBleed
EXTRN	?DamageDecal@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::DamageDecal
EXTRN	?IsInWorld@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::IsInWorld
EXTRN	?GetNextTarget@CBaseEntity@@UAEPAV1@XZ:NEAR	; CBaseEntity::GetNextTarget
;	COMDAT ??_7CMonsterTarget@@6B@
CONST	SEGMENT
??_7CMonsterTarget@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CMonsterTarget::`vftable'
	DD	FLAT:?Spawn@CMonsterTarget@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CMonsterTarget@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CMonsterTarget@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CMonsterTarget@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CMonsterTarget@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CMonsterTarget@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CMonsterTarget@@QAE@XZ PROC NEAR			; CMonsterTarget::CMonsterTarget, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CMonsterTarget@@6B@ ; CMonsterTarget::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CMonsterTarget@@QAE@XZ ENDP				; CMonsterTarget::CMonsterTarget
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Precache, COMDAT

; 326  : 	virtual void	Precache( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Precache
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ObjectCaps, COMDAT

; 364  : 	virtual int	ObjectCaps( void ) { return FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 2
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ObjectCaps
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Activate@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Activate, COMDAT

; 365  : 	virtual void	Activate( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Activate
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeLevel@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeLevel, COMDAT

; 366  : 	virtual void	OnChangeLevel( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeLevel@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnChangeLevel
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnTeleport@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnTeleport, COMDAT

; 367  : 	virtual void	OnTeleport( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnTeleport@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnTeleport
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4
?PortalSleep@CBaseEntity@@UAEXM@Z PROC NEAR		; CBaseEntity::PortalSleep, COMDAT

; 368  : 	virtual void	PortalSleep( float seconds ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PortalSleep@CBaseEntity@@UAEXM@Z ENDP			; CBaseEntity::PortalSleep
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CBaseEntity::StartMessage, COMDAT

; 369  :           virtual void	StartMessage( CBasePlayer *pPlayer ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ENDP	; CBaseEntity::StartMessage
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetPosition@CBaseEntity@@UAEMXZ PROC NEAR		; CBaseEntity::GetPosition, COMDAT

; 370  : 	virtual float	GetPosition( void ) { return 0.0f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPosition@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetPosition
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeParent, COMDAT

; 371  : 	virtual void	OnChangeParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CBaseEntity@@UAEXXZ ENDP		; CBaseEntity::OnChangeParent
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnClearParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnClearParent, COMDAT

; 372  : 	virtual void	OnClearParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnClearParent
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnRemove@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::OnRemove, COMDAT

; 373  : 	virtual void	OnRemove( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnRemove@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnRemove
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z PROC NEAR ; CBaseEntity::DeathNotice, COMDAT

; 386  : 	virtual void DeathNotice ( entvars_t *pevChild ) { } // monster maker children use this to tell the monster maker that they have died.

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z ENDP	; CBaseEntity::DeathNotice
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsRigidBody@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsRigidBody, COMDAT

; 387  : 	virtual BOOL IsRigidBody( void ) { return (m_iActorType == ACTOR_DYNAMIC); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	mov	eax, ecx
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsRigidBody@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsRigidBody
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z PROC NEAR	; CBaseEntity::GetState, COMDAT

; 401  : 	virtual STATE GetState ( CBaseEntity* pEnt ) { return GetState(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z ENDP	; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::BloodColor, COMDAT

; 408  : 	virtual int	BloodColor( void ) { return DONT_BLEED; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::BloodColor
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::IsTriggered, COMDAT

; 410  : 	virtual BOOL	IsTriggered( CBaseEntity *pActivator ) {return TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::IsTriggered
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ PROC NEAR ; CBaseEntity::MyMonsterPointer, COMDAT

; 411  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ENDP ; CBaseEntity::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ PROC NEAR ; CBaseEntity::MySquadMonsterPointer, COMDAT

; 412  : 	virtual CSquadMonster *MySquadMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ENDP ; CBaseEntity::MySquadMonsterPointer
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ PROC NEAR	; CBaseEntity::GetVehicleDriver, COMDAT

; 413  : 	virtual CBaseEntity *GetVehicleDriver( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ ENDP		; CBaseEntity::GetVehicleDriver
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::GetToggleState, COMDAT

; 414  : 	virtual int	GetToggleState( void ) { return TS_AT_TOP; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseEntity@@UAEHXZ ENDP		; CBaseEntity::GetToggleState
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPoints@CBaseEntity@@UAEXHH@Z PROC NEAR		; CBaseEntity::AddPoints, COMDAT

; 415  : 	virtual void	AddPoints( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPoints@CBaseEntity@@UAEXHH@Z ENDP			; CBaseEntity::AddPoints
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z PROC NEAR	; CBaseEntity::AddPointsToTeam, COMDAT

; 416  : 	virtual void	AddPointsToTeam( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z ENDP		; CBaseEntity::AddPointsToTeam
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::AddPlayerItem, COMDAT

; 417  : 	virtual BOOL	AddPlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::AddPlayerItem
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::RemovePlayerItem, COMDAT

; 418  : 	virtual BOOL	RemovePlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::RemovePlayerItem
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT
_this$ = -4
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z PROC NEAR		; CBaseEntity::GiveAmmo, COMDAT

; 419  : 	virtual int 	GiveAmmo( int iAmount, char *szName, int iMax ) { return -1; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z ENDP			; CBaseEntity::GiveAmmo
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseEntity@@UAEMXZ PROC NEAR			; CBaseEntity::GetDelay, COMDAT

; 420  : 	virtual float	GetDelay( void ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetDelay
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMoving, COMDAT

; 421  : 	virtual int	IsMoving( void ) { return GetAbsVelocity() != g_vecZero; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMoving
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OverrideReset, COMDAT

; 422  : 	virtual void	OverrideReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OverrideReset
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TransferReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::TransferReset, COMDAT

; 423  : 	virtual void	TransferReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransferReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::TransferReset
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?SetToggleState@CBaseEntity@@UAEXH@Z PROC NEAR		; CBaseEntity::SetToggleState, COMDAT

; 426  : 	virtual void	SetToggleState( int state ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetToggleState@CBaseEntity@@UAEXH@Z ENDP		; CBaseEntity::SetToggleState
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StartSneaking, COMDAT

; 427  : 	virtual void	StartSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StartSneaking
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StopSneaking, COMDAT

; 428  : 	virtual void	StopSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StopSneaking
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?OnControls@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::OnControls, COMDAT

; 429  : 	virtual BOOL	OnControls( CBaseEntity *pTest ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnControls@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::OnControls
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSneaking@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsSneaking, COMDAT

; 430  : 	virtual BOOL	IsSneaking( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSneaking@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsSneaking
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsAlive, COMDAT

; 431  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	jne	SHORT $L42543
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L42543
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L42544
$L42543:
	mov	DWORD PTR -8+[ebp], 0
$L42544:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsAlive
_TEXT	ENDS
EXTRN	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z:NEAR	; UTIL_GetModelType
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBSPModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBSPModel, COMDAT

; 432  : 	virtual BOOL	IsBSPModel( void ) { return UTIL_GetModelType( pev->modelindex ) == mod_brush; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBSPModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBSPModel
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsCustomModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsCustomModel, COMDAT

; 433  : 	virtual BOOL	IsCustomModel( void ) { return pev->solid == SOLID_CUSTOM; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+268], 5
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCustomModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsCustomModel
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ReflectGauss@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ReflectGauss, COMDAT

; 434  : 	virtual BOOL	ReflectGauss( void ) { return (( IsBSPModel() || IsCustomModel()) && !pev->takedamage ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	test	eax, eax
	jne	SHORT $L42551
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+208]
	test	eax, eax
	je	SHORT $L42552
$L42551:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L42552
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L42553
$L42552:
	mov	DWORD PTR -8+[ebp], 0
$L42553:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReflectGauss@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ReflectGauss
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_targetname$ = 8
?HasTarget@CBaseEntity@@UAEHH@Z PROC NEAR		; CBaseEntity::HasTarget, COMDAT

; 435  : 	virtual BOOL	HasTarget( string_t targetname ) { return FStrEq(STRING(targetname), STRING(pev->targetname) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _targetname$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasTarget@CBaseEntity@@UAEHH@Z ENDP			; CBaseEntity::HasTarget
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPlayer@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPlayer, COMDAT

; 437  : 	virtual BOOL	IsPlayer( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPlayer
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsNetClient@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsNetClient, COMDAT

; 438  : 	virtual BOOL	IsNetClient( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetClient@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsNetClient
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMonster@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsMonster, COMDAT

; 439  : 	virtual BOOL	IsMonster( void ) { return (pev->flags & FL_MONSTER ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+420]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMonster@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMonster
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPushable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsPushable, COMDAT

; 440  : 	virtual BOOL	IsPushable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPushable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPushable
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsProjectile@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsProjectile, COMDAT

; 441  : 	virtual BOOL	IsProjectile( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsProjectile@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsProjectile
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsFuncScreen@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsFuncScreen, COMDAT

; 442  : 	virtual BOOL	IsFuncScreen( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFuncScreen@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsFuncScreen
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPortal@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPortal, COMDAT

; 443  : 	virtual BOOL	IsPortal( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPortal@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPortal
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTank@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsTank, COMDAT

; 444  : 	virtual BOOL	IsTank( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTank@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsTank
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMover@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMover, COMDAT

; 445  : 	virtual BOOL	IsMover( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMover
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBreakable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBreakable, COMDAT

; 446  : 	virtual BOOL	IsBreakable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBreakable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBreakable
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?TeamID@CBaseEntity@@UAEPBDXZ PROC NEAR			; CBaseEntity::TeamID, COMDAT

; 447  : 	virtual const char	*TeamID( void ) { return ""; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TeamID@CBaseEntity@@UAEPBDXZ ENDP			; CBaseEntity::TeamID
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Think@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Think, COMDAT

; 458  : 	virtual void Think( void ) { if (m_pfnThink) (this->*m_pfnThink)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1744], 0
	je	SHORT $L35006
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1744]
$L35006:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Think
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Touch@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Touch, COMDAT

; 466  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 		if( m_pfnTouch )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1748], 0
	je	SHORT $L35012

; 468  : 			(this->*m_pfnTouch)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1748]
$L35012:

; 469  : 
; 470  : 		// forward the blocked event to our parent, if any.
; 471  : 		if( m_hParent != NULL && !m_isChaining )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35013
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1628]
	test	ecx, ecx
	jne	SHORT $L35013

; 472  : 			m_hParent->Touch( pOther );

	mov	edx, DWORD PTR _pOther$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+280]
$L35013:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Touch
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Blocked@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Blocked, COMDAT

; 476  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 		if( m_pfnBlocked )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1756], 0
	je	SHORT $L35016

; 478  : 			(this->*m_pfnBlocked)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1756]
$L35016:

; 479  : 
; 480  : 		// forward the blocked event to our parent, if any.
; 481  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35017

; 482  : 			m_hParent->Blocked( pOther );

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+284]
$L35017:

; 483  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Blocked
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MoveDone@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::MoveDone, COMDAT

; 485  : 	virtual void MoveDone( void ) { if( m_pfnMoveDone )(this->*m_pfnMoveDone)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1760], 0
	je	SHORT $L35020
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1760]
$L35020:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveDone@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::MoveDone
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?Respawn@CBaseEntity@@UAEPAV1@XZ PROC NEAR		; CBaseEntity::Respawn, COMDAT

; 513  : 	virtual CBaseEntity *Respawn( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Respawn@CBaseEntity@@UAEPAV1@XZ ENDP			; CBaseEntity::Respawn
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?UpdateOwner@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::UpdateOwner, COMDAT

; 705  : 	virtual	void UpdateOwner( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateOwner@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::UpdateOwner
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FBecomeProne@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::FBecomeProne, COMDAT

; 709  : 	virtual BOOL FBecomeProne( void ) {return FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FBecomeProne@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::FBecomeProne
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T42594 = -16
$T42595 = -28
?Center@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR		; CBaseEntity::Center, COMDAT

; 714  : 	virtual Vector Center( ) { return (pev->absmax + pev->absmin) * 0.5; }; // center point of entity

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T42595[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	push	edx
	lea	eax, DWORD PTR $T42594[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 208				; 000000d0H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Center@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::Center
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T42598 = -16
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EyePosition, COMDAT

; 715  : 	virtual Vector EyePosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of eyes

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T42598[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EyePosition
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T42601 = -16
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EarPosition, COMDAT

; 716  : 	virtual Vector EarPosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of ears

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T42601[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EarPosition
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T42604 = -16
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseEntity::BodyTarget, COMDAT

; 717  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ); };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T42604[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseEntity::BodyTarget
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPointSized@CBaseEntity@@UBEHXZ PROC NEAR		; CBaseEntity::IsPointSized, COMDAT

; 718  : 	virtual BOOL IsPointSized() const { return (pev->size == g_vecZero) ? true : false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	setne	al
	and	eax, 255				; 000000ffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPointSized@CBaseEntity@@UBEHXZ ENDP			; CBaseEntity::IsPointSized
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Illumination@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::Illumination, COMDAT

; 720  : 	virtual int Illumination( ) { return GETENTITYILLUM( ENT( pev ) ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+60
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Illumination@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Illumination
_TEXT	ENDS
;	COMDAT ?GetState@CMonsterTarget@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CMonsterTarget@@UAE?AW4STATE@@XZ PROC NEAR	; CMonsterTarget::GetState, COMDAT

; 3598 : 	STATE GetState( void ) { return pev->health ? STATE_ON : STATE_OFF; };

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L42611
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L42612
$L42611:
	mov	DWORD PTR -8+[ebp], 0
$L42612:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CMonsterTarget@@UAE?AW4STATE@@XZ ENDP		; CMonsterTarget::GetState
_TEXT	ENDS
;	COMDAT ?Classify@CMonsterTarget@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CMonsterTarget@@UAEHXZ PROC NEAR		; CMonsterTarget::Classify, COMDAT

; 3599 : 	int Classify( void ) { return pev->frags; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+356]
	call	__ftol
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CMonsterTarget@@UAEHXZ ENDP			; CMonsterTarget::Classify
_TEXT	ENDS
PUBLIC	??_7CBaseEntity@@6B@				; CBaseEntity::`vftable'
PUBLIC	?Spawn@CBaseEntity@@UAEXXZ			; CBaseEntity::Spawn
PUBLIC	?Classify@CBaseEntity@@UAEHXZ			; CBaseEntity::Classify
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@XZ		; CBaseEntity::GetState
PUBLIC	?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z	; CBaseEntity::Use
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	??0CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::CMeshDesc
EXTRN	??1CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::~CMeshDesc
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT
??_7CBaseEntity@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CBaseEntity::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseEntity@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseEntity@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseEntity@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseEntity@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseEntity@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??0CMeshDesc@@QAE@XZ			; CMeshDesc::CMeshDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1632				; 00000660H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseEntity@@6B@ ; CBaseEntity::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseEntity@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	ret	0
__ehhandler$??0CBaseEntity@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseEntity@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::CBaseEntity
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Spawn, COMDAT

; 325  : 	virtual void	Spawn( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Spawn
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::Classify, COMDAT

; 385  : 	virtual int Classify ( void ) { return CLASS_NONE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Classify
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseEntity::GetState, COMDAT

; 398  : 	virtual STATE GetState ( void ) { return STATE_OFF; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ ENDP		; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
_pActivator$ = 8
_pCaller$ = 12
_useType$ = 16
_value$ = 20
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z PROC NEAR	; CBaseEntity::Use, COMDAT

; 461  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 		if (m_pfnUse) (this->*m_pfnUse)( pActivator, pCaller, useType, value );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1752], 0
	je	SHORT $L35009
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCaller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1752]
$L35009:

; 463  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z ENDP	; CBaseEntity::Use
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
PUBLIC	?CopyConstruct@@YAXPAPADABQAD@Z			; CopyConstruct
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ DB '('
	DB	'elem == Count()) || IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L42638
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L42638
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L42638
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42638:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L42639
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42639
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42639:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAPADABQAD@Z		; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC NEAR		; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L42644
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42644:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L41224

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L41224:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PADH@@QAE@XZ PROC NEAR			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
_TEXT	ENDS
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC NEAR		; CUtlMemory<char *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42649
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42649:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42650
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42650:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC NEAR		; CUtlMemory<char *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42653
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42653:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC NEAR	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L42660
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L42660
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L42661
$L42660:
	mov	DWORD PTR -8+[ebp], 0
$L42661:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAPAD@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L41257:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41258

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAD@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L41257
$L41258:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ		; CUtlMemory<char *,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@PADH@@QAEXH@Z		; CUtlMemory<char *,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L41267

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@PADH@@QAEXH@Z	; CUtlMemory<char *,int>::Grow
$L41267:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
_TEXT	ENDS
PUBLIC	??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
EXTRN	_memmove:NEAR
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ DB 'I'
	DB	'sValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 )', 00H ; `string'
CONST	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42668
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L42668
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L42668
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42668:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L41276
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L41276

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L41276:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
_src$ = 12
$T42671 = -4
?CopyConstruct@@YAXPAPADABQAD@Z PROC NEAR		; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T42671[ebp], eax
	cmp	DWORD PTR $T42671[ebp], 0
	je	SHORT $L42672
	mov	ecx, DWORD PTR $T42671[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T42671[ebp]
	mov	DWORD PTR -8+[ebp], ecx
	jmp	SHORT $L42673
$L42672:
	mov	DWORD PTR -8+[ebp], 0
$L42673:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyConstruct@@YAXPAPADABQAD@Z ENDP			; CopyConstruct
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC NEAR	; CUtlMemory<char *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L42678
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L42678
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L42679
$L42678:
	mov	DWORD PTR -8+[ebp], 0
$L42679:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC NEAR		; CUtlMemory<char *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41290

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L41291

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L41291:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L41290:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR	; CUtlMemory<char *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ PROC NEAR	; CUtlMemory<char *,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ ENDP		; CUtlMemory<char *,int>::NumAllocated
_TEXT	ENDS
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@PADH@@QAEXH@Z PROC NEAR		; CUtlMemory<char *,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L42688
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42688:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41305

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L42689
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42689:

; 567  : 		return;

	jmp	$L41302
$L41305:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	4
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L41325

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L41317
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L41317

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L41325
$L41317:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L41321

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L42690
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42690:

; 589  : 				return;

	jmp	$L41302
$L41321:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L41325

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L41321
$L41325:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L41328

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L42691
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42691:

; 603  : 	else

	jmp	SHORT $L42692
$L41328:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L42692
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42692:
$L41302:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@PADH@@QAEXH@Z ENDP			; CUtlMemory<char *,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L28985

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L28990
$L28985:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L28987

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L28987:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L28990

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L28987
$L28990:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR ; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAD@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAD@Z ENDP				; Destruct
_TEXT	ENDS
END
