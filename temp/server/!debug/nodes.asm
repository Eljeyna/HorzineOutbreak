	TITLE	Z:\XashXTSRC\server\monsters\nodes.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OJHA@Bad?5link?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09KHFJ@info_node?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@NGKI@info_node_air?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@PCAE@?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5nod@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HMCI@func_door?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@DIJK@func_door_rotating?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BFDL@func_button?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GHEL@func_rot_button?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@ECCH@Unsupported?5PathEnt?3?6?8?$CFs?8?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@LJED@Graph?5not?5ready?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HDML@dead?5path?5ent?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@KFIJ@func_breakable?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@LCEE@Unhandled?5Ent?5in?5Path?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@DJMB@Route?5Failure?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@KCOI@HashLinks?5is?5broken?5from?5?$CFd?5to?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@OKDC@Can?8t?5build?5a?5path?0?5iStart?5is?5?$CFd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@LACO@Can?8t?5show?5connections?5for?5node?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@NOPM@?$CK?$CKNo?5Connections?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@JDEK@No?5Nodes?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PBCE@?$CK?$CKLinkVisibleNodes?3?6can?8t?5write?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EO@NCEO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@JHNE@LinkVisibleNodes?5?9?5Initial?5Conne@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@JNEM@Node?5?$CD?$CF4d?3?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03OALE@?$CF4d?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@FCCH@?5?5Entity?5on?5connection?3?5?$CFs?0?5name@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0ED@CBNC@?$CK?$CKLinkVisibleNodes?3?6Node?5?$CFd?5has?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@JFJG@?$CK?$CK?5NODE?5?$CFd?5HAS?5NodeLinks?5?$DO?5MAX_N@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0ED@OLC@?$CK?$CKLinkVisibleNodes?3?6TotalLinks?5?$DO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@IIDG@?$CK?$CKNO?5INITIAL?5LINKS?$CK?$CK?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EN@KOPM@?6?$CF4d?5Total?5Initial?5Connections?5?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@JJGD@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@IEJJ@InLine?5Rejection?3?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EMKK@Node?5?$CF3d?3?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@KPNC@REJECTED?5NODE?5?$CF3d?5through?5Node?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@PFEE@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EJCJ@testhull?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DCGK@CTestHull?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@EDK@CallBuildNodeGraph?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BGNE@ShowBadNode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NKNA@DropDelay?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GCML@PathFind?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@DMHA@models?1player?4mdl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@FEFN@Node?5Graph?5out?5of?5Date?4?5Rebuildi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08BJLI@hinttype?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08KABI@activity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@DFEH@cNodes?5?$DO?5MAX_NODES?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@DEBH@?$CK?$CKCould?5not?5malloc?5TempPool?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@LPHH@maps?1?$CFs?4nrp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@BCMP@Node?5Graph?5Report?5for?5map?3?5?5?$CFs?4b@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@JELK@?$CFd?5Total?5Nodes?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@FMMD@Node?$CD?5?5?5?5?5?5?5?5?5?$CF4d?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@GAAC@Location?5?5?5?5?5?5?$CF4d?0?$CF4d?0?$CF4d?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@IKID@HintType?3?5?5?5?5?5?$CF4d?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@EIDE@HintActivity?3?5?$CF4d?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@EPAC@HintYaw?3?5?5?5?5?5?5?$CF4f?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@PMEA@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JJJH@?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@MGAF@?$CK?$CKConnectVisibleNodes?5FAILED?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@BPJN@Walk?5Rejection?3?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GDCA@Node?5?$CF4d?3?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OHEO@OFFGROUND?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@BJIG@?$CK?$CK?$CK?$CK?5j?5?$DN?5?$CFd?5?$CK?$CK?$CK?$CK?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LPFE@NODE_SMALL_HULL?5step?5?$CFf?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GN@NODE_HUMAN_HULL?5step?5?$CFf?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EJDC@NODE_LARGE_HULL?5step?5?$CFf?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@DEFK@Rejected?5Node?5?$CF3d?5?9?5Unreachable?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09ECJA@Any?5Hull?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FD@OAIO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@FKJF@Couldn?8t?5malloc?5LinkPool?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FD@BEFM@?6?6?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFHC@Link?5Pairings?3?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DF@ECLH@WARNING?3?5Node?5?$CF3d?5does?5not?5conne@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@GHBB@?6All?5Connections?5are?5Paired?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IKOB@Total?5Number?5of?5Connections?5in?5P@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@LCPH@Connection?5Pool?3?5?$CFd?5bytes?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@CALM@?$CFd?5Nodes?0?5?$CFd?5Connections?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06JCEA@Done?4?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09FMFO@No?5Path?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HMFC@?$CFd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07HNLK@Error?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@OFK@Queue?5is?5full?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@HBDC@maps?1?$CFs?4bsp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@GMNG@maps?1graphs?1?$CFs?4nod?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@IGOK@?$CK?$CKERROR?$CK?$CK?5Graph?5version?5is?5?$CFd?0?5e@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@HBMP@?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5lin@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@OPG@?$CK?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5en@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@DIDD@?$CK?$CK?$CKERROR?$CK?$CK?6Counldn?8t?5malloc?5?$CFd?5r@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@BEAH@?$CK?$CK?$CKERROR?$CK?$CK?6Counldn?8t?5malloc?5?$CFd?5h@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EB@DHAP@?$CK?$CK?$CKWARNING?$CK?$CK?$CK?3Node?5graph?5was?5lon@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@FHCN@Write?5LUMP_AINODEGRAPH?5to?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LHJL@model?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@LJKI@?$CK?$CKCould?5not?5find?5model?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@KLJO@?4NOD?5File?5will?5be?5updated?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@OAFF@Couldn?8t?5allocated?5Link?5Lookup?5T@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@LFII@Couldn?8t?5allocated?5node?5ordering@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@CKJO@Nodes?5need?5sorting?5?$CI?$CFd?0?$CFd?$CJ?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KDEG@Size?5of?5Routes?5?$DN?5?$CFd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09FPNM@No?5link?4?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@CPJK@Routing?5is?5inconsistent?$CB?$CB?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MINJ@?$CI?$CFd?5to?5?$CFd?5?$HM?$CFd?1?$CFd?$CJ1?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CPCE@?$CFd?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@GLCK@?6?$CI?$CFd?5to?5?$CFd?5?$HM?$CFd?1?$CFd?$CJ2?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@DMHE@node_viewer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@IDJE@node_viewer_human?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILEJ@node_viewer_fly?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@BACI@node_viewer_large?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@LEBC@CNodeViewer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LKM@DrawThink?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@FJHD@No?5nearby?5node?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DENB@basenode?5?$CFd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09IHHN@?$CFd?5nodes?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector2D@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector2D@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Make2D@Vector@@QBE?AVVector2D@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FIND_ENTITY_BY_TARGET@@YAPAUedict_s@@PAU1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_CenterPrintAll@@YAXPBD0000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseToggle@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseToggle@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stop@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScheduleChange@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanPlaySentence@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetYawSpeed@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CoverRadius@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckAmmo@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HearingSensitivity@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrescheduleThink@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AlertSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IdleSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PainSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopFollowing@CBaseMonster@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@CVirtualFS@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@CVirtualFS@@QAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CVirtualFS@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CVirtualFS@@QAE@PBEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CVirtualFS@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Read@CVirtualFS@@QAEIPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Write@CVirtualFS@@QAEIPBXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Insert@CVirtualFS@@QAEIPBXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Print@CVirtualFS@@QAEIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IPrint@CVirtualFS@@QAEIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Printf@CVirtualFS@@QAAIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IPrintf@CVirtualFS@@QAAIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VPrintf@CVirtualFS@@QAEIPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IVPrintf@CVirtualFS@@QAEIPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Getc@CVirtualFS@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Gets@CVirtualFS@@QAEHPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Seek@CVirtualFS@@QAEHIH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CapIndex@CGraph@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Node@CGraph@@QAEAAVCNode@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Link@CGraph@@QAEAAVCLink@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NodeLink@CGraph@@QAEAAVCLink@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?INodeLink@CGraph@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CNodeEnt@@EAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Full@CQueue@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Full@CQueuePriority@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@CQueuePriority@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E21
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGraph@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CACHE_ENTRY@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E23
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E26
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E27
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitGraph@CGraph@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocNodes@CGraph@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinkEntForLink@CGraph@@QAEPAUentvars_s@@PAVCLink@@PAVCNode@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HandleLinkEnt@CGraph@@QAEHHPAUentvars_s@@HW4NODEQUERY@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HullIndex@CGraph@@QAEHPBVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NodeType@CGraph@@QAEHPBVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PathLength@CGraph@@QAEMHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextNodeInRoute@CGraph@@QAEHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindShortestPath@CGraph@@QAEHPAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Hash@@YAKPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcBounds@@YAXAAH0HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CALC_RANGE@@YAHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRange@@YAXAAH0HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckNode@CGraph@@QAEXVVector@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindNearestNode@CGraph@@QAEHABVVector@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindNearestNode@CGraph@@QAEHABVVector@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShowNodeConnections@CGraph@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinkVisibleNodes@CGraph@@QAEHPAVCLink@@PAVCVirtualFS@@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RejectInlineLinks@CGraph@@QAEHPAVCLink@@PAVCVirtualFS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CTestHull@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E30
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E31
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CTestHull@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CTestHull@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E33
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E34
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E37
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CTestHull@@QAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DropDelay@CTestHull@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CNodeEnt@@EAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CNodeEnt@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShowBadNode@CTestHull@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CallBuildNodeGraph@CTestHull@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildNodeGraph@CTestHull@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PathFind@CTestHull@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CStack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Push@CStack@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Pop@CStack@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Top@CStack@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyToArray@CStack@@QAEXPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CQueue@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Insert@CQueue@@QAEXHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@CQueue@@QAEHAAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CQueuePriority@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Insert@CQueuePriority@@QAEXHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@CQueuePriority@@QAEHAAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Heap_SiftDown@CQueuePriority@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Heap_SiftUp@CQueuePriority@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FLoadGraph@CGraph@@QAEHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FSaveGraph@CGraph@@QAEHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FSetGraphPointers@CGraph@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckNODFile@CGraph@@QAEHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HashInsert@CGraph@@QAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HashSearch@CGraph@@QAEXHHAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HashChoosePrimes@CGraph@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SortNodes@CGraph@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNode@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildLinkLookups@CGraph@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildRegionTables@CGraph@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ComputeStaticRoutingTables@CGraph@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TestRoutingTables@CGraph@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E40
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E42
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E43
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E45
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E46
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E49
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CNodeViewer@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CNodeViewer@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E51
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E52
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CNodeViewer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindNodeConnections@CNodeViewer@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNode@CNodeViewer@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawThink@CNodeViewer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCNodeEnt@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCNodeEnt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCNodeEnt@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCNodeEnt@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCTestHull@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCTestHull@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCTestHull@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCTestHull@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCNodeViewer@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCNodeViewer@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCNodeViewer@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCNodeViewer@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTestHull@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNodeEnt@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNodeViewer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseMonster@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseMonster@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseToggle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseToggle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WayPoint_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseAnimating@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCNodeEnt@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CNodeEnt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCTestHull@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseMonster@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseToggle@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CTestHull@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CNodeViewer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCNodeViewer@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?WorldGraph@@3VCGraph@@A			; WorldGraph
PUBLIC	?Primes@@3PAHA					; Primes
PUBLIC	?m_DataMap@CTestHull@@2Udatamap_s@@A		; CTestHull::m_DataMap
PUBLIC	?m_DataMap@CNodeViewer@@2Udatamap_s@@A		; CNodeViewer::m_DataMap
PUBLIC	??_C@_09DCGK@CTestHull?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CTestHull_DataDescInit@@3PAUdatamap_s@@A ; CTestHull_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0M@LEBC@CNodeViewer?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CNodeViewer_DataDescInit@@3PAUdatamap_s@@A ; CNodeViewer_DataDescInit::g_DataMapHolder
_BSS	SEGMENT
?WorldGraph@@3VCGraph@@A DB 020ccH DUP (?)		; WorldGraph
?g_DataMapHolder@CTestHull_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CTestHull_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CNodeViewer_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CNodeViewer_DataDescInit::g_DataMapHolder
_BSS	ENDS
CRT$XCU	SEGMENT
_$S22	DD	FLAT:_$E21
_$S25	DD	FLAT:_$E24
_$S28	DD	FLAT:_$E27
_$S32	DD	FLAT:_$E31
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CTestHull@@2Udatamap_s@@A DD 00H		; CTestHull::m_DataMap
	DD	00H
	DD	FLAT:??_C@_09DCGK@CTestHull?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S35	DD	FLAT:_$E34
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	012H
	ORG $+92
?Primes@@3PAHA DD 01H					; Primes
	DD	02H
	DD	03H
	DD	05H
	DD	07H
	DD	0bH
	DD	0dH
	DD	011H
	DD	013H
	DD	017H
	DD	01dH
	DD	01fH
	DD	025H
	DD	029H
	DD	02bH
	DD	02fH
	DD	035H
	DD	03bH
	DD	03dH
	DD	043H
	DD	047H
	DD	049H
	DD	04fH
	DD	053H
	DD	059H
	DD	061H
	DD	065H
	DD	067H
	DD	06bH
	DD	06dH
	DD	071H
	DD	07fH
	DD	083H
	DD	089H
	DD	08bH
	DD	095H
	DD	097H
	DD	09dH
	DD	0a3H
	DD	0a7H
	DD	0adH
	DD	0b3H
	DD	0b5H
	DD	0bfH
	DD	0c1H
	DD	0c5H
	DD	0c7H
	DD	0d3H
	DD	0dfH
	DD	0e3H
	DD	0e5H
	DD	0e9H
	DD	0efH
	DD	0f1H
	DD	0fbH
	DD	0101H
	DD	0107H
	DD	010dH
	DD	010fH
	DD	0115H
	DD	0119H
	DD	011bH
	DD	0125H
	DD	0133H
	DD	0137H
	DD	0139H
	DD	013dH
	DD	014bH
	DD	0151H
	DD	015bH
	DD	015dH
	DD	0161H
	DD	0167H
	DD	016fH
	DD	0175H
	DD	017bH
	DD	017fH
	DD	0185H
	DD	018dH
	DD	0191H
	DD	0199H
	DD	01a3H
	DD	01a5H
	DD	01afH
	DD	01b1H
	DD	01b7H
	DD	01bbH
	DD	01c1H
	DD	01c9H
	DD	01cdH
	DD	01cfH
	DD	01d3H
	DD	01dfH
	DD	01e7H
	DD	01ebH
	DD	01f3H
	DD	01f7H
	DD	01fdH
	DD	0209H
	DD	020bH
	DD	021dH
	DD	0223H
	DD	022dH
	DD	0233H
	DD	0239H
	DD	023bH
	DD	0241H
	DD	024bH
	DD	0251H
	DD	0257H
	DD	0259H
	DD	025fH
	DD	0265H
	DD	0269H
	DD	026bH
	DD	0277H
	DD	0281H
	DD	0283H
	DD	0287H
	DD	028dH
	DD	0293H
	DD	0295H
	DD	02a1H
	DD	02a5H
	DD	02abH
	DD	02b3H
	DD	02bdH
	DD	02c5H
	DD	02cfH
	DD	02d7H
	DD	02ddH
	DD	02e3H
	DD	02e7H
	DD	02efH
	DD	02f5H
	DD	02f9H
	DD	0301H
	DD	0305H
	DD	0313H
	DD	031dH
	DD	0329H
	DD	032bH
	DD	0335H
	DD	0337H
	DD	033bH
	DD	033dH
	DD	0347H
	DD	0355H
	DD	0359H
	DD	035bH
	DD	035fH
	DD	036dH
	DD	0371H
	DD	0373H
	DD	0377H
	DD	038bH
	DD	038fH
	DD	0397H
	DD	03a1H
	DD	03a9H
	DD	03adH
	DD	03b3H
	DD	03b9H
	DD	03c7H
	DD	03cbH
	DD	03d1H
	DD	03d7H
	DD	03dfH
	DD	03e5H
	DD	03f1H
	DD	03f5H
	DD	03fbH
	DD	03fdH
	DD	0407H
	DD	0409H
	DD	040fH
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S41	DD	FLAT:_$E40
_$S44	DD	FLAT:_$E43
_$S47	DD	FLAT:_$E46
_$S50	DD	FLAT:_$E49
CRT$XCU	ENDS
_DATA	SEGMENT
	ORG $+4
?m_DataMap@CNodeViewer@@2Udatamap_s@@A DD 00H		; CNodeViewer::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0M@LEBC@CNodeViewer?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S53	DD	FLAT:_$E52
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	012H
	ORG $+20
_DATA	ENDS
;	COMDAT ??_C@_09DCGK@CTestHull?$AA@
CONST	SEGMENT
??_C@_09DCGK@CTestHull?$AA@ DB 'CTestHull', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LEBC@CNodeViewer?$AA@
CONST	SEGMENT
??_C@_0M@LEBC@CNodeViewer?$AA@ DB 'CNodeViewer', 00H	; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0CVirtualFS@@QAE@XZ				; CVirtualFS::CVirtualFS
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_memset:NEAR
;	COMDAT ??0CVirtualFS@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
$T39795 = -8
??0CVirtualFS@@QAE@XZ PROC NEAR				; CVirtualFS::CVirtualFS, COMDAT

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 	m_iBuffSize = FS_MEM_BLOCK; // can be resized later

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 65535		; 0000ffffH

; 44   : 	m_pBuffer = new byte[m_iBuffSize];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T39795[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T39795[ebp]
	mov	DWORD PTR [eax], ecx

; 45   : 	memset( m_pBuffer, 0, m_iBuffSize );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 46   : 	m_iLength = m_iOffset = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 47   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CVirtualFS@@QAE@XZ ENDP				; CVirtualFS::CVirtualFS
_TEXT	ENDS
PUBLIC	??0CVirtualFS@@QAE@PBEI@Z			; CVirtualFS::CVirtualFS
EXTRN	_memcpy:NEAR
;	COMDAT ??0CVirtualFS@@QAE@PBEI@Z
_TEXT	SEGMENT
_file$ = 8
_size$ = 12
_this$ = -4
$T39798 = -8
??0CVirtualFS@@QAE@PBEI@Z PROC NEAR			; CVirtualFS::CVirtualFS, COMDAT

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 	if( !file || size <= 0 )

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $L36277
	cmp	DWORD PTR _size$[ebp], 0
	ja	SHORT $L36276
$L36277:

; 53   : 		m_iBuffSize = m_iOffset = m_iLength = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 54   : 		m_pBuffer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 55   : 		return;

	jmp	SHORT $L36275
$L36276:

; 57   : 
; 58   : 	m_iLength = m_iBuffSize = size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 59   : 	m_pBuffer = new byte[m_iBuffSize];	

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T39798[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T39798[ebp]
	mov	DWORD PTR [ecx], edx

; 60   : 	memcpy( m_pBuffer, file, m_iBuffSize );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 61   : 	m_iOffset = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
$L36275:

; 62   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0CVirtualFS@@QAE@PBEI@Z ENDP				; CVirtualFS::CVirtualFS
_TEXT	ENDS
PUBLIC	??1CVirtualFS@@QAE@XZ				; CVirtualFS::~CVirtualFS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ??1CVirtualFS@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
$T39801 = -8
??1CVirtualFS@@QAE@XZ PROC NEAR				; CVirtualFS::~CVirtualFS, COMDAT

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	delete [] m_pBuffer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T39801[ebp], ecx
	mov	edx, DWORD PTR $T39801[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 67   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CVirtualFS@@QAE@XZ ENDP				; CVirtualFS::~CVirtualFS
_TEXT	ENDS
PUBLIC	?Read@CVirtualFS@@QAEIPADI@Z			; CVirtualFS::Read
;	COMDAT ?Read@CVirtualFS@@QAEIPADI@Z
_TEXT	SEGMENT
_out$ = 8
_size$ = 12
_this$ = -4
_read_size$ = -8
_reduced_size$36295 = -12
?Read@CVirtualFS@@QAEIPADI@Z PROC NEAR			; CVirtualFS::Read, COMDAT

; 70   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 	if( !m_pBuffer || !out || size <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L36290
	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $L36290
	cmp	DWORD PTR _size$[ebp], 0
	ja	SHORT $L36289
$L36290:

; 72   : 		return 0;

	xor	eax, eax
	jmp	$L36288
$L36289:

; 73   : 
; 74   : 	// check for enough room
; 75   : 	if( m_iOffset >= m_iLength )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+12]
	jb	SHORT $L36291

; 76   : 		return 0; // hit EOF

	xor	eax, eax
	jmp	$L36288
$L36291:

; 77   : 
; 78   : 	size_t read_size = 0;

	mov	DWORD PTR _read_size$[ebp], 0

; 79   : 
; 80   : 	if( m_iOffset + size <= m_iLength )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+12]
	ja	SHORT $L36293

; 82   : 		memcpy( out, m_pBuffer + m_iOffset, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	push	eax
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 83   : 		m_iOffset += size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 84   : 		read_size = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _read_size$[ebp], eax

; 86   : 	else

	jmp	SHORT $L36294
$L36293:

; 88   : 		int reduced_size = m_iLength - m_iOffset;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _reduced_size$36295[ebp], eax

; 89   : 		memcpy( out, m_pBuffer + m_iOffset, reduced_size );

	mov	ecx, DWORD PTR _reduced_size$36295[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	push	eax
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 90   : 		m_iOffset += reduced_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _reduced_size$36295[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 91   : 		read_size = reduced_size;

	mov	eax, DWORD PTR _reduced_size$36295[ebp]
	mov	DWORD PTR _read_size$[ebp], eax
$L36294:

; 93   : 
; 94   : 	return read_size;

	mov	eax, DWORD PTR _read_size$[ebp]
$L36288:

; 95   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Read@CVirtualFS@@QAEIPADI@Z ENDP			; CVirtualFS::Read
_TEXT	ENDS
PUBLIC	?Write@CVirtualFS@@QAEIPBXI@Z			; CVirtualFS::Write
EXTRN	_realloc:NEAR
;	COMDAT ?Write@CVirtualFS@@QAEIPBXI@Z
_TEXT	SEGMENT
_in$ = 8
_size$ = 12
_this$ = -4
_newsize$36303 = -8
?Write@CVirtualFS@@QAEIPBXI@Z PROC NEAR			; CVirtualFS::Write, COMDAT

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 	if( !m_pBuffer ) return -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L36301
	or	eax, -1
	jmp	$L36300
$L36301:

; 100  : 
; 101  : 	if( m_iOffset + size >= m_iBuffSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+4]
	jb	SHORT $L36304

; 103  : 		size_t newsize = m_iOffset + size + FS_MEM_BLOCK;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _size$[ebp]
	lea	ecx, DWORD PTR [edx+eax+65535]
	mov	DWORD PTR _newsize$36303[ebp], ecx

; 104  : 
; 105  : 		if( m_iBuffSize < newsize )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _newsize$36303[ebp]
	jae	SHORT $L36304

; 107  : 			// reallocate buffer now
; 108  : 			m_pBuffer = (byte *)realloc( m_pBuffer, newsize );

	mov	ecx, DWORD PTR _newsize$36303[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 109  : 			memset( m_pBuffer + m_iBuffSize, 0, newsize - m_iBuffSize );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newsize$36303[ebp]
	sub	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 110  : 			m_iBuffSize = newsize; // update buffsize

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newsize$36303[ebp]
	mov	DWORD PTR [ecx+4], edx
$L36304:

; 113  : 
; 114  : 	// write into buffer
; 115  : 	memcpy( m_pBuffer + m_iOffset, in, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 116  : 	m_iOffset += size;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 117  : 
; 118  : 	if( m_iOffset > m_iLength ) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	cmp	ecx, DWORD PTR [eax+12]
	jbe	SHORT $L36306

; 119  : 		m_iLength = m_iOffset;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+12], ecx
$L36306:

; 120  : 
; 121  : 	return m_iLength;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
$L36300:

; 122  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Write@CVirtualFS@@QAEIPBXI@Z ENDP			; CVirtualFS::Write
_TEXT	ENDS
PUBLIC	?Insert@CVirtualFS@@QAEIPBXI@Z			; CVirtualFS::Insert
;	COMDAT ?Insert@CVirtualFS@@QAEIPBXI@Z
_TEXT	SEGMENT
_in$ = 8
_size$ = 12
_this$ = -4
_newsize$36314 = -8
_rp_size$ = -12
_backup$ = -16
$T39808 = -20
$T39809 = -24
?Insert@CVirtualFS@@QAEIPBXI@Z PROC NEAR		; CVirtualFS::Insert, COMDAT

; 125  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 126  : 	if( !m_pBuffer ) return -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L36312
	or	eax, -1
	jmp	$L36311
$L36312:

; 127  : 
; 128  : 	if( m_iLength + size >= m_iBuffSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+4]
	jb	SHORT $L36315

; 130  : 		size_t newsize = m_iLength + size + FS_MEM_BLOCK;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _size$[ebp]
	lea	ecx, DWORD PTR [edx+eax+65535]
	mov	DWORD PTR _newsize$36314[ebp], ecx

; 131  : 
; 132  : 		if( m_iBuffSize < newsize )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _newsize$36314[ebp]
	jae	SHORT $L36315

; 134  : 			// reallocate buffer now
; 135  : 			m_pBuffer = (byte *)realloc( m_pBuffer, newsize );

	mov	ecx, DWORD PTR _newsize$36314[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 136  : 			memset( m_pBuffer + m_iBuffSize, 0, newsize - m_iBuffSize );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newsize$36314[ebp]
	sub	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 137  : 			m_iBuffSize = newsize; // update buffsize

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newsize$36314[ebp]
	mov	DWORD PTR [ecx+4], edx
$L36315:

; 140  : 
; 141  : 	// backup right part
; 142  : 	size_t rp_size = m_iLength - m_iOffset;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _rp_size$[ebp], edx

; 143  : 	byte *backup = new byte[rp_size];

	mov	eax, DWORD PTR _rp_size$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T39808[ebp], eax
	mov	ecx, DWORD PTR $T39808[ebp]
	mov	DWORD PTR _backup$[ebp], ecx

; 144  : 	memcpy( backup, m_pBuffer + m_iOffset, rp_size );

	mov	edx, DWORD PTR _rp_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	push	ecx
	mov	eax, DWORD PTR _backup$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 145  : 
; 146  : 	// insert into buffer
; 147  : 	memcpy( m_pBuffer + m_iOffset, in, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 148  : 	m_iOffset += size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 149  : 
; 150  : 	// write right part buffer
; 151  : 	memcpy( m_pBuffer + m_iOffset, backup, rp_size );

	mov	eax, DWORD PTR _rp_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _backup$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 152  : 	delete [] backup;

	mov	edx, DWORD PTR _backup$[ebp]
	mov	DWORD PTR $T39809[ebp], edx
	mov	eax, DWORD PTR $T39809[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 153  : 
; 154  : 	if(( m_iOffset + rp_size ) > m_iLength ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _rp_size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+12]
	jbe	SHORT $L36322

; 155  : 		m_iLength = m_iOffset + rp_size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _rp_size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$L36322:

; 156  : 
; 157  : 	return m_iLength;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
$L36311:

; 158  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@CVirtualFS@@QAEIPBXI@Z ENDP			; CVirtualFS::Insert
_TEXT	ENDS
PUBLIC	?Print@CVirtualFS@@QAEIPBD@Z			; CVirtualFS::Print
EXTRN	?Q_strlen@@YAHPBD@Z:NEAR			; Q_strlen
;	COMDAT ?Print@CVirtualFS@@QAEIPBD@Z
_TEXT	SEGMENT
_message$ = 8
_this$ = -4
?Print@CVirtualFS@@QAEIPBD@Z PROC NEAR			; CVirtualFS::Print, COMDAT

; 161  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 162  : 	return Write( message, Q_strlen( message ));

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Write

; 163  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Print@CVirtualFS@@QAEIPBD@Z ENDP			; CVirtualFS::Print
_TEXT	ENDS
PUBLIC	?IPrint@CVirtualFS@@QAEIPBD@Z			; CVirtualFS::IPrint
;	COMDAT ?IPrint@CVirtualFS@@QAEIPBD@Z
_TEXT	SEGMENT
_message$ = 8
_this$ = -4
?IPrint@CVirtualFS@@QAEIPBD@Z PROC NEAR			; CVirtualFS::IPrint, COMDAT

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 	return Insert( message, Q_strlen( message ));

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Insert

; 168  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IPrint@CVirtualFS@@QAEIPBD@Z ENDP			; CVirtualFS::IPrint
_TEXT	ENDS
PUBLIC	?Printf@CVirtualFS@@QAAIPBDZZ			; CVirtualFS::Printf
PUBLIC	?VPrintf@CVirtualFS@@QAEIPBDPAD@Z		; CVirtualFS::VPrintf
;	COMDAT ?Printf@CVirtualFS@@QAAIPBDZZ
_TEXT	SEGMENT
_fmt$ = 12
_this$ = 8
_result$ = -4
_args$ = -8
?Printf@CVirtualFS@@QAAIPBDZZ PROC NEAR			; CVirtualFS::Printf, COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 172  : 	size_t result;
; 173  : 	va_list args;
; 174  : 
; 175  : 	va_start( args, fmt );

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 176  : 	result = VPrintf( fmt, args );

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fmt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VPrintf@CVirtualFS@@QAEIPBDPAD@Z	; CVirtualFS::VPrintf
	mov	DWORD PTR _result$[ebp], eax

; 177  : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 178  : 
; 179  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 180  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Printf@CVirtualFS@@QAAIPBDZZ ENDP			; CVirtualFS::Printf
_TEXT	ENDS
PUBLIC	?IPrintf@CVirtualFS@@QAAIPBDZZ			; CVirtualFS::IPrintf
PUBLIC	?IVPrintf@CVirtualFS@@QAEIPBDPAD@Z		; CVirtualFS::IVPrintf
;	COMDAT ?IPrintf@CVirtualFS@@QAAIPBDZZ
_TEXT	SEGMENT
_fmt$ = 12
_this$ = 8
_result$ = -4
_args$ = -8
?IPrintf@CVirtualFS@@QAAIPBDZZ PROC NEAR		; CVirtualFS::IPrintf, COMDAT

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 184  : 	size_t result;
; 185  : 	va_list args;
; 186  : 
; 187  : 	va_start( args, fmt );

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 188  : 	result = IVPrintf( fmt, args );

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fmt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IVPrintf@CVirtualFS@@QAEIPBDPAD@Z	; CVirtualFS::IVPrintf
	mov	DWORD PTR _result$[ebp], eax

; 189  : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 190  : 
; 191  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 192  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IPrintf@CVirtualFS@@QAAIPBDZZ ENDP			; CVirtualFS::IPrintf
_TEXT	ENDS
EXTRN	?Q_vsnprintf@@YAHPADIPBD0@Z:NEAR		; Q_vsnprintf
;	COMDAT ?VPrintf@CVirtualFS@@QAEIPBDPAD@Z
_TEXT	SEGMENT
_fmt$ = 8
_ap$ = 12
_this$ = -4
_buff_size$ = -8
_tempbuff$ = -12
_len$ = -16
$T39820 = -20
$T39821 = -24
$T39822 = -28
?VPrintf@CVirtualFS@@QAEIPBDPAD@Z PROC NEAR		; CVirtualFS::VPrintf, COMDAT

; 195  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 196  : 	size_t	buff_size = FS_MSG_BLOCK;

	mov	DWORD PTR _buff_size$[ebp], 8192	; 00002000H
$L36362:

; 197  : 	char	*tempbuff;
; 198  : 	size_t	len;
; 199  : 
; 200  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $L36363

; 202  : 		tempbuff = new char[buff_size];

	mov	ecx, DWORD PTR _buff_size$[ebp]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T39820[ebp], eax
	mov	edx, DWORD PTR $T39820[ebp]
	mov	DWORD PTR _tempbuff$[ebp], edx

; 203  : 		len = Q_vsprintf( tempbuff, fmt, ap );

	mov	eax, DWORD PTR _ap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	push	99999					; 0001869fH
	mov	edx, DWORD PTR _tempbuff$[ebp]
	push	edx
	call	?Q_vsnprintf@@YAHPADIPBD0@Z		; Q_vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 204  : 		if( len >= 0 && len < buff_size )

	cmp	DWORD PTR _len$[ebp], 0
	jb	SHORT $L36366
	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _buff_size$[ebp]
	jae	SHORT $L36366

; 205  : 			break;

	jmp	SHORT $L36363
$L36366:

; 206  : 		delete [] tempbuff;

	mov	ecx, DWORD PTR _tempbuff$[ebp]
	mov	DWORD PTR $T39821[ebp], ecx
	mov	edx, DWORD PTR $T39821[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 207  : 		buff_size <<= 1;

	mov	eax, DWORD PTR _buff_size$[ebp]
	shl	eax, 1
	mov	DWORD PTR _buff_size$[ebp], eax

; 208  : 	}

	jmp	SHORT $L36362
$L36363:

; 209  : 
; 210  : 	len = Write( tempbuff, len );

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tempbuff$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Write
	mov	DWORD PTR _len$[ebp], eax

; 211  : 	delete [] tempbuff;

	mov	eax, DWORD PTR _tempbuff$[ebp]
	mov	DWORD PTR $T39822[ebp], eax
	mov	ecx, DWORD PTR $T39822[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 212  : 
; 213  : 	return len;

	mov	eax, DWORD PTR _len$[ebp]

; 214  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?VPrintf@CVirtualFS@@QAEIPBDPAD@Z ENDP			; CVirtualFS::VPrintf
_TEXT	ENDS
;	COMDAT ?IVPrintf@CVirtualFS@@QAEIPBDPAD@Z
_TEXT	SEGMENT
_fmt$ = 8
_ap$ = 12
_this$ = -4
_buff_size$ = -8
_tempbuff$ = -12
_len$ = -16
$T39825 = -20
$T39826 = -24
$T39827 = -28
?IVPrintf@CVirtualFS@@QAEIPBDPAD@Z PROC NEAR		; CVirtualFS::IVPrintf, COMDAT

; 217  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 218  : 	size_t	buff_size = FS_MSG_BLOCK;

	mov	DWORD PTR _buff_size$[ebp], 8192	; 00002000H
$L36378:

; 219  : 	char	*tempbuff;
; 220  : 	size_t	len;
; 221  : 
; 222  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $L36379

; 224  : 		tempbuff = new char[buff_size];

	mov	ecx, DWORD PTR _buff_size$[ebp]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T39825[ebp], eax
	mov	edx, DWORD PTR $T39825[ebp]
	mov	DWORD PTR _tempbuff$[ebp], edx

; 225  : 		len = Q_vsprintf( tempbuff, fmt, ap );

	mov	eax, DWORD PTR _ap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	push	99999					; 0001869fH
	mov	edx, DWORD PTR _tempbuff$[ebp]
	push	edx
	call	?Q_vsnprintf@@YAHPADIPBD0@Z		; Q_vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 226  : 		if( len >= 0 && len < buff_size )

	cmp	DWORD PTR _len$[ebp], 0
	jb	SHORT $L36382
	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _buff_size$[ebp]
	jae	SHORT $L36382

; 227  : 			break;

	jmp	SHORT $L36379
$L36382:

; 228  : 		delete [] tempbuff;

	mov	ecx, DWORD PTR _tempbuff$[ebp]
	mov	DWORD PTR $T39826[ebp], ecx
	mov	edx, DWORD PTR $T39826[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 229  : 		buff_size <<= 1;

	mov	eax, DWORD PTR _buff_size$[ebp]
	shl	eax, 1
	mov	DWORD PTR _buff_size$[ebp], eax

; 230  : 	}

	jmp	SHORT $L36378
$L36379:

; 231  : 
; 232  : 	len = Insert( tempbuff, len );

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tempbuff$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Insert
	mov	DWORD PTR _len$[ebp], eax

; 233  : 	delete [] tempbuff;

	mov	eax, DWORD PTR _tempbuff$[ebp]
	mov	DWORD PTR $T39827[ebp], eax
	mov	ecx, DWORD PTR $T39827[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 234  : 
; 235  : 	return len;

	mov	eax, DWORD PTR _len$[ebp]

; 236  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?IVPrintf@CVirtualFS@@QAEIPBDPAD@Z ENDP			; CVirtualFS::IVPrintf
_TEXT	ENDS
PUBLIC	?Getc@CVirtualFS@@QAEHXZ			; CVirtualFS::Getc
;	COMDAT ?Getc@CVirtualFS@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_c$ = -8
?Getc@CVirtualFS@@QAEHXZ PROC NEAR			; CVirtualFS::Getc, COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 240  : 	char c;
; 241  : 
; 242  : 	if( !Read( &c, 1 ))

	push	1
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CVirtualFS@@QAEIPADI@Z		; CVirtualFS::Read
	test	eax, eax
	jne	SHORT $L36390

; 243  : 		return EOF;

	or	eax, -1
	jmp	SHORT $L36388
$L36390:

; 244  : 	return (byte)c;

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 255				; 000000ffH
$L36388:

; 245  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Getc@CVirtualFS@@QAEHXZ ENDP				; CVirtualFS::Getc
_TEXT	ENDS
PUBLIC	?Seek@CVirtualFS@@QAEHIH@Z			; CVirtualFS::Seek
PUBLIC	?Gets@CVirtualFS@@QAEHPADI@Z			; CVirtualFS::Gets
;	COMDAT ?Gets@CVirtualFS@@QAEHPADI@Z
_TEXT	SEGMENT
_string$ = 8
_size$ = 12
_this$ = -4
_end$ = -8
_c$ = -12
?Gets@CVirtualFS@@QAEHPADI@Z PROC NEAR			; CVirtualFS::Gets, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 249  : 	size_t	end = 0;

	mov	DWORD PTR _end$[ebp], 0
$L36400:

; 250  : 	int	c;
; 251  : 
; 252  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $L36401

; 254  : 		c = Getc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Getc@CVirtualFS@@QAEHXZ		; CVirtualFS::Getc
	mov	DWORD PTR _c$[ebp], eax

; 255  : 
; 256  : 		if( c == '\r' || c == '\n' || c < 0 )

	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	je	SHORT $L36403
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $L36403
	cmp	DWORD PTR _c$[ebp], 0
	jge	SHORT $L36402
$L36403:

; 257  : 			break;

	jmp	SHORT $L36401
$L36402:

; 258  : 
; 259  : 		if( end < ( size - 1 ))

	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _end$[ebp], ecx
	jae	SHORT $L36404

; 260  : 			string[end++] = c;

	mov	edx, DWORD PTR _string$[ebp]
	add	edx, DWORD PTR _end$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _end$[ebp]
	add	ecx, 1
	mov	DWORD PTR _end$[ebp], ecx
$L36404:

; 261  : 	}

	jmp	SHORT $L36400
$L36401:

; 262  : 
; 263  : 	string[end] = 0;

	mov	edx, DWORD PTR _string$[ebp]
	add	edx, DWORD PTR _end$[ebp]
	mov	BYTE PTR [edx], 0

; 264  : 
; 265  : 	// remove \n following \r
; 266  : 	if( c == '\r' )

	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	jne	SHORT $L36406

; 268  : 		c = Getc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Getc@CVirtualFS@@QAEHXZ		; CVirtualFS::Getc
	mov	DWORD PTR _c$[ebp], eax

; 269  : 		if( c != '\n' ) Seek( -1, SEEK_CUR ); // rewind

	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $L36406
	push	1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Seek@CVirtualFS@@QAEHIH@Z		; CVirtualFS::Seek
$L36406:

; 271  : 
; 272  : 	return c;

	mov	eax, DWORD PTR _c$[ebp]

; 273  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Gets@CVirtualFS@@QAEHPADI@Z ENDP			; CVirtualFS::Gets
_TEXT	ENDS
;	COMDAT ?Seek@CVirtualFS@@QAEHIH@Z
_TEXT	SEGMENT
_offset$ = 8
_whence$ = 12
_this$ = -4
?Seek@CVirtualFS@@QAEHIH@Z PROC NEAR			; CVirtualFS::Seek, COMDAT

; 276  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 279  : 	{

	mov	eax, DWORD PTR _whence$[ebp]
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 0
	je	SHORT $L36417
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L36416
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L36418
	jmp	SHORT $L36419
$L36416:

; 280  : 	case SEEK_CUR:
; 281  : 		offset += m_iOffset;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _offset$[ebp]
	add	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _offset$[ebp], edx

; 282  : 		break;

	jmp	SHORT $L36413
$L36417:

; 283  : 	case SEEK_SET:
; 284  : 		break;

	jmp	SHORT $L36413
$L36418:

; 285  : 	case SEEK_END:
; 286  : 		offset += m_iLength;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	add	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _offset$[ebp], ecx

; 287  : 		break;

	jmp	SHORT $L36413
$L36419:

; 288  : 	default: 
; 289  : 		return -1;

	or	eax, -1
	jmp	SHORT $L36411
$L36413:

; 291  : 
; 292  : 	if(( offset < 0 ) || ( offset > m_iLength ))

	cmp	DWORD PTR _offset$[ebp], 0
	jb	SHORT $L36421
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _offset$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jbe	SHORT $L36420
$L36421:

; 293  : 		return -1;

	or	eax, -1
	jmp	SHORT $L36411
$L36420:

; 294  : 
; 295  : 	m_iOffset = offset;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 296  : 
; 297  : 	return 0;

	xor	eax, eax
$L36411:

; 298  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Seek@CVirtualFS@@QAEHIH@Z ENDP				; CVirtualFS::Seek
_TEXT	ENDS
;	COMDAT _$E21
_TEXT	SEGMENT
_$E21	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E20
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E21	ENDP
_TEXT	ENDS
PUBLIC	??0CGraph@@QAE@XZ				; CGraph::CGraph
;	COMDAT _$E20
_TEXT	SEGMENT
_$E20	PROC NEAR					; COMDAT

; 40   : CGraph	WorldGraph;

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	??0CGraph@@QAE@XZ			; CGraph::CGraph
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E20	ENDP
_TEXT	ENDS
PUBLIC	??0CACHE_ENTRY@@QAE@XZ				; CACHE_ENTRY::CACHE_ENTRY
;	COMDAT ??0CGraph@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CGraph@@QAE@XZ PROC NEAR				; CGraph::CGraph, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0CACHE_ENTRY@@QAE@XZ	; CACHE_ENTRY::CACHE_ENTRY
	push	128					; 00000080H
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 6268				; 0000187cH
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CGraph@@QAE@XZ ENDP					; CGraph::CGraph
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
;	COMDAT ??0CACHE_ENTRY@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CACHE_ENTRY@@QAE@XZ PROC NEAR			; CACHE_ENTRY::CACHE_ENTRY, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CACHE_ENTRY@@QAE@XZ ENDP				; CACHE_ENTRY::CACHE_ENTRY
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
;	COMDAT _$E24
_TEXT	SEGMENT
_$E24	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E23
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E24	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCNodeEnt@@@@QAE@PBD@Z	; CEntityFactory<CNodeEnt>::CEntityFactory<CNodeEnt>
PUBLIC	??_C@_09KHFJ@info_node?$AA@			; `string'
_BSS	SEGMENT
_info_node DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09KHFJ@info_node?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_09KHFJ@info_node?$AA@ DB 'info_node', 00H		; `string'
CONST	ENDS
;	COMDAT _$E23
_TEXT	SEGMENT
_$E23	PROC NEAR					; COMDAT

; 42   : LINK_ENTITY_TO_CLASS( info_node, CNodeEnt );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_09KHFJ@info_node?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_info_node
	call	??0?$CEntityFactory@VCNodeEnt@@@@QAE@PBD@Z ; CEntityFactory<CNodeEnt>::CEntityFactory<CNodeEnt>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E23	ENDP
_TEXT	ENDS
;	COMDAT _$E27
_TEXT	SEGMENT
_$E27	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E26
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E27	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@NGKI@info_node_air?$AA@		; `string'
_BSS	SEGMENT
_info_node_air DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@NGKI@info_node_air?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0O@NGKI@info_node_air?$AA@ DB 'info_node_air', 00H ; `string'
CONST	ENDS
;	COMDAT _$E26
_TEXT	SEGMENT
_$E26	PROC NEAR					; COMDAT

; 43   : LINK_ENTITY_TO_CLASS( info_node_air, CNodeEnt );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0O@NGKI@info_node_air?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_info_node_air
	call	??0?$CEntityFactory@VCNodeEnt@@@@QAE@PBD@Z ; CEntityFactory<CNodeEnt>::CEntityFactory<CNodeEnt>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E26	ENDP
_TEXT	ENDS
PUBLIC	?InitGraph@CGraph@@QAEXXZ			; CGraph::InitGraph
EXTRN	_free:NEAR
;	COMDAT ?InitGraph@CGraph@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?InitGraph@CGraph@@QAEXXZ PROC NEAR			; CGraph::InitGraph, COMDAT

; 51   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 52   : 
; 53   : 	// Make the graph unavailable
; 54   : 	//
; 55   : 	m_fGraphPresent = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 56   : 	m_fGraphPointersSet = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 57   : 	m_fRoutingComplete = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 58   : 
; 59   : 	// Free the link pool
; 60   : 	//
; 61   : 	if ( m_pLinkPool )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L37248

; 63   : 		free ( m_pLinkPool );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_free
	add	esp, 4

; 64   : 		m_pLinkPool = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
$L37248:

; 66   : 		
; 67   : 	// Free the node info
; 68   : 	//
; 69   : 	if ( m_pNodes )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L37249

; 71   : 		free ( m_pNodes );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_free
	add	esp, 4

; 72   : 		m_pNodes = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L37249:

; 74   : 
; 75   : 	if ( m_di )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $L37250

; 77   : 		free ( m_di );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_free
	add	esp, 4

; 78   : 		m_di = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 0
$L37250:

; 80   : 
; 81   : 	// Free the routing info.
; 82   : 	//
; 83   : 	if ( m_pRouteInfo )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $L37251

; 85   : 		free ( m_pRouteInfo );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_free
	add	esp, 4

; 86   : 		m_pRouteInfo = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
$L37251:

; 88   : 
; 89   : 	if (m_pHashLinks)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8380], 0
	je	SHORT $L37252

; 91   : 		free(m_pHashLinks);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8380]
	push	eax
	call	_free
	add	esp, 4

; 92   : 		m_pHashLinks = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8380], 0
$L37252:

; 94   : 
; 95   : 	// Zero node and link counts
; 96   : 	//
; 97   : 	m_cNodes = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0

; 98   : 	m_cLinks = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 99   : 	m_nRouteInfo = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 100  : 
; 101  : 	m_iLastActiveIdleSearch = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8388], 0

; 102  : 	m_iLastCoverSearch = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8392], 0

; 103  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitGraph@CGraph@@QAEXXZ ENDP				; CGraph::InitGraph
_TEXT	ENDS
PUBLIC	??_C@_0CF@PCAE@?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5nod@ ; `string'
PUBLIC	?AllocNodes@CGraph@@QAEHXZ			; CGraph::AllocNodes
EXTRN	_calloc:NEAR
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
;	COMDAT ??_C@_0CF@PCAE@?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5nod@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0CF@PCAE@?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5nod@ DB '*'
	DB	'*ERROR**', 0aH, 'Couldn''t malloc %d nodes!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?AllocNodes@CGraph@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?AllocNodes@CGraph@@QAEHXZ PROC NEAR			; CGraph::AllocNodes, COMDAT

; 111  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 112  : //  malloc all of the nodes
; 113  : 	WorldGraph.m_pNodes = (CNode *)calloc ( sizeof ( CNode ), MAX_NODES );

	push	1024					; 00000400H
	push	88					; 00000058H
	call	_calloc
	add	esp, 8
	mov	DWORD PTR ?WorldGraph@@3VCGraph@@A+12, eax

; 114  : 
; 115  : // could not malloc space for all the nodes!
; 116  : 	if ( !WorldGraph.m_pNodes )

	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A+12, 0
	jne	SHORT $L37259

; 118  : 		ALERT ( at_aiconsole, "**ERROR**\nCouldn't malloc %d nodes!\n", WorldGraph.m_cNodes );

	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	push	eax
	push	OFFSET FLAT:??_C@_0CF@PCAE@?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5nod@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 119  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L37256
$L37259:

; 121  : 
; 122  : 	return TRUE;

	mov	eax, 1
$L37256:

; 123  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AllocNodes@CGraph@@QAEHXZ ENDP				; CGraph::AllocNodes
_TEXT	ENDS
PUBLIC	??_C@_09HMCI@func_door?$AA@			; `string'
PUBLIC	??_C@_0BD@DIJK@func_door_rotating?$AA@		; `string'
PUBLIC	??_C@_0M@BFDL@func_button?$AA@			; `string'
PUBLIC	??_C@_0BA@GHEL@func_rot_button?$AA@		; `string'
PUBLIC	??_C@_0BL@ECCH@Unsupported?5PathEnt?3?6?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??0gametrace_s@@QAE@XZ				; gametrace_s::gametrace_s
PUBLIC	?FIND_ENTITY_BY_TARGET@@YAPAUedict_s@@PAU1@PBD@Z ; FIND_ENTITY_BY_TARGET
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
PUBLIC	?FNullEnt@@YAHPBUedict_s@@@Z			; FNullEnt
PUBLIC	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z		; FClassnameIs
PUBLIC	?LinkEntForLink@CGraph@@QAEPAUentvars_s@@PAVCLink@@PAVCNode@@@Z ; CGraph::LinkEntForLink
EXTRN	?VecBModelOrigin@@YA?AVVector@@PAUentvars_s@@@Z:NEAR ; VecBModelOrigin
EXTRN	?g_pBodyQueueHead@@3PAUedict_s@@A:DWORD		; g_pBodyQueueHead
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
;	COMDAT ??_C@_09HMCI@func_door?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_09HMCI@func_door?$AA@ DB 'func_door', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DIJK@func_door_rotating?$AA@
CONST	SEGMENT
??_C@_0BD@DIJK@func_door_rotating?$AA@ DB 'func_door_rotating', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BFDL@func_button?$AA@
CONST	SEGMENT
??_C@_0M@BFDL@func_button?$AA@ DB 'func_button', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GHEL@func_rot_button?$AA@
CONST	SEGMENT
??_C@_0BA@GHEL@func_rot_button?$AA@ DB 'func_rot_button', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ECCH@Unsupported?5PathEnt?3?6?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BL@ECCH@Unsupported?5PathEnt?3?6?8?$CFs?8?6?$AA@ DB 'Unsupported P'
	DB	'athEnt:', 0aH, '''%s''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?LinkEntForLink@CGraph@@QAEPAUentvars_s@@PAVCLink@@PAVCNode@@@Z
_TEXT	SEGMENT
_pLink$ = 8
_pNode$ = 12
_this$ = -4
_pentSearch$ = -8
_pentTrigger$ = -12
_pevTrigger$ = -16
_pevLinkEnt$ = -20
_tr$ = -76
$T39858 = -88
?LinkEntForLink@CGraph@@QAEPAUentvars_s@@PAVCLink@@PAVCNode@@@Z PROC NEAR ; CGraph::LinkEntForLink, COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 	edict_t	*pentSearch;
; 141  : 	edict_t	*pentTrigger;
; 142  : 	entvars_t		*pevTrigger;
; 143  : 	entvars_t		*pevLinkEnt;
; 144  : 	TraceResult	tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 145  : 	
; 146  : 	pevLinkEnt = pLink->m_pLinkEnt;

	mov	eax, DWORD PTR _pLink$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pevLinkEnt$[ebp], ecx

; 147  : 	if ( !pevLinkEnt )

	cmp	DWORD PTR _pevLinkEnt$[ebp], 0
	jne	SHORT $L37271

; 148  : 		return NULL;

	xor	eax, eax
	jmp	$L37287
$L37271:

; 149  : 
; 150  : 	pentSearch = NULL;// start search at the top of the ent list.

	mov	DWORD PTR _pentSearch$[ebp], 0

; 151  : 			
; 152  : 	if ( FClassnameIs ( pevLinkEnt, "func_door" ) || FClassnameIs ( pevLinkEnt, "func_door_rotating" ) )

	push	OFFSET FLAT:??_C@_09HMCI@func_door?$AA@	; `string'
	mov	edx, DWORD PTR _pevLinkEnt$[ebp]
	push	edx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	jne	SHORT $L37273
	push	OFFSET FLAT:??_C@_0BD@DIJK@func_door_rotating?$AA@ ; `string'
	mov	eax, DWORD PTR _pevLinkEnt$[ebp]
	push	eax
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	$L37272
$L37273:

; 154  : 
; 155  : 		///!!!UNDONE - check for TOGGLE or STAY open doors here. If a door is in the way, and is 
; 156  : 		// TOGGLE or STAY OPEN, even monsters that can't open doors can go that way.
; 157  : 
; 158  : 		if ( ( pevLinkEnt->spawnflags & SF_DOOR_USE_ONLY ) )

	mov	ecx, DWORD PTR _pevLinkEnt$[ebp]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 256				; 00000100H
	test	edx, edx
	je	SHORT $L37276

; 160  : 			return pevLinkEnt;

	mov	eax, DWORD PTR _pevLinkEnt$[ebp]
	jmp	$L37287
$L37276:

; 162  : 
; 163  : 		while ( 1 )

	mov	eax, 1
	test	eax, eax
	je	$L37279

; 165  : 			pentTrigger = FIND_ENTITY_BY_TARGET ( pentSearch, STRING( pevLinkEnt->targetname ) );// find the button or trigger

	mov	ecx, DWORD PTR _pevLinkEnt$[ebp]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pentSearch$[ebp]
	push	eax
	call	?FIND_ENTITY_BY_TARGET@@YAPAUedict_s@@PAU1@PBD@Z ; FIND_ENTITY_BY_TARGET
	add	esp, 8
	mov	DWORD PTR _pentTrigger$[ebp], eax

; 166  : 
; 167  : 			if ( FNullEnt( pentTrigger ) )

	mov	ecx, DWORD PTR _pentTrigger$[ebp]
	push	ecx
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L37280

; 169  : 
; 170  : 				// right now this is a problem among auto-open doors, or any door that opens through the use 
; 171  : 				// of a trigger brush. Trigger brushes have no models, and don't show up in searches. Just allow
; 172  : 				// monsters to open these sorts of doors for now. 
; 173  : 				return pevLinkEnt;

	mov	eax, DWORD PTR _pevLinkEnt$[ebp]
	jmp	$L37287
$L37280:

; 175  : 			
; 176  : 			pentSearch = pentTrigger;

	mov	edx, DWORD PTR _pentTrigger$[ebp]
	mov	DWORD PTR _pentSearch$[ebp], edx

; 177  : 			pevTrigger = VARS( pentTrigger );

	mov	eax, DWORD PTR _pentTrigger$[ebp]
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pevTrigger$[ebp], eax

; 178  : 			
; 179  : 			if ( FClassnameIs(pevTrigger, "func_button") || FClassnameIs(pevTrigger, "func_rot_button" ) )

	push	OFFSET FLAT:??_C@_0M@BFDL@func_button?$AA@ ; `string'
	mov	ecx, DWORD PTR _pevTrigger$[ebp]
	push	ecx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	jne	SHORT $L37282
	push	OFFSET FLAT:??_C@_0BA@GHEL@func_rot_button?$AA@ ; `string'
	mov	edx, DWORD PTR _pevTrigger$[ebp]
	push	edx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L37286
$L37282:

; 181  : 
; 182  : 				// trace from the node to the trigger, make sure it's one we can see from the node.
; 183  : 				// !!!HACKHACK Use bodyqueue here cause there are no ents we really wish to ignore!
; 184  : 				UTIL_TraceLine ( pNode->m_vecOrigin, VecBModelOrigin( pevTrigger ), ignore_monsters, g_pBodyQueueHead, &tr );

	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?g_pBodyQueueHead@@3PAUedict_s@@A ; g_pBodyQueueHead
	push	ecx
	push	1
	mov	edx, DWORD PTR _pevTrigger$[ebp]
	push	edx
	lea	eax, DWORD PTR $T39858[ebp]
	push	eax
	call	?VecBModelOrigin@@YA?AVVector@@PAUentvars_s@@@Z ; VecBModelOrigin
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pNode$[ebp]
	push	ecx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 185  : 
; 186  : 
; 187  : 				if ( VARS(tr.pHit) == pevTrigger )

	mov	edx, DWORD PTR _tr$[ebp+48]
	push	edx
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	cmp	eax, DWORD PTR _pevTrigger$[ebp]
	jne	SHORT $L37286

; 189  : 					return VARS( tr.pHit );

	mov	eax, DWORD PTR _tr$[ebp+48]
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	jmp	SHORT $L37287
$L37286:

; 192  : 		}

	jmp	$L37276
$L37279:

; 194  : 	else

	jmp	SHORT $L37287
$L37272:

; 196  : 		ALERT ( at_aiconsole, "Unsupported PathEnt:\n'%s'\n", STRING ( pevLinkEnt->classname ) );

	mov	ecx, DWORD PTR _pevLinkEnt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BL@ECCH@Unsupported?5PathEnt?3?6?8?$CFs?8?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 197  : 		return NULL;

	xor	eax, eax
$L37287:

; 199  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?LinkEntForLink@CGraph@@QAEPAUentvars_s@@PAVCLink@@PAVCNode@@@Z ENDP ; CGraph::LinkEntForLink
_TEXT	ENDS
PUBLIC	??_C@_06CCPD@target?$AA@			; `string'
;	COMDAT ??_C@_06CCPD@target?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_06CCPD@target?$AA@ DB 'target', 00H		; `string'
CONST	ENDS
;	COMDAT ?FIND_ENTITY_BY_TARGET@@YAPAUedict_s@@PAU1@PBD@Z
_TEXT	SEGMENT
_entStart$ = 8
_pszName$ = 12
?FIND_ENTITY_BY_TARGET@@YAPAUedict_s@@PAU1@PBD@Z PROC NEAR ; FIND_ENTITY_BY_TARGET, COMDAT

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 121  : 	return FIND_ENTITY_BY_STRING(entStart, "target", pszName);

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_06CCPD@target?$AA@	; `string'
	mov	ecx, DWORD PTR _entStart$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+56
	add	esp, 12					; 0000000cH

; 122  : }	

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FIND_ENTITY_BY_TARGET@@YAPAUedict_s@@PAU1@PBD@Z ENDP	; FIND_ENTITY_BY_TARGET
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC NEAR		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32448

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L32447
$L32448:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$L32447:

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?FNullEnt@@YAHPBUedict_s@@@Z PROC NEAR			; FNullEnt, COMDAT

; 195  : inline BOOL FNullEnt(const edict_t* pent)	{ return pent == NULL || FNullEnt(OFFSET(pent)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L39865
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39865
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L39866
$L39865:
	mov	DWORD PTR -4+[ebp], 1
$L39866:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPBUedict_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
PUBLIC	?FNullEnt@@YAHPAUentvars_s@@@Z			; FNullEnt
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT
_pev$ = 8
_szClassname$ = 12
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z PROC NEAR		; FClassnameIs, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 295  : 	if( FNullEnt( pev )) return FALSE;

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L32565
	xor	eax, eax
	jmp	SHORT $L32564
$L32565:

; 296  : 	return FStrEq( STRING( pev->classname ), szClassname );

	mov	ecx, DWORD PTR _szClassname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pev$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
$L32564:

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z ENDP		; FClassnameIs
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?FNullEnt@@YAHPAUentvars_s@@@Z PROC NEAR		; FNullEnt, COMDAT

; 196  : inline BOOL FNullEnt(entvars_t* pev)				{ return pev == NULL || FNullEnt(OFFSET(pev)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pev$[ebp], 0
	je	SHORT $L39875
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39875
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L39876
$L39875:
	mov	DWORD PTR -4+[ebp], 1
$L39876:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAUentvars_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
PUBLIC	??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad pev in OFFSET()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?OFFSET@@YAHPAUentvars_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L32439

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32439:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0gametrace_s@@QAE@XZ PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0gametrace_s@@QAE@XZ ENDP				; gametrace_s::gametrace_s
_TEXT	ENDS
PUBLIC	??_C@_0BC@LJED@Graph?5not?5ready?$CB?6?$AA@	; `string'
PUBLIC	??_C@_0BA@HDML@dead?5path?5ent?$CB?6?$AA@	; `string'
PUBLIC	??_C@_0P@KFIJ@func_breakable?$AA@		; `string'
PUBLIC	??_C@_0BK@LCEE@Unhandled?5Ent?5in?5Path?5?$CFs?6?$AA@ ; `string'
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z	; CBaseEntity::Instance
PUBLIC	?HandleLinkEnt@CGraph@@QAEHHPAUentvars_s@@HW4NODEQUERY@1@@Z ; CGraph::HandleLinkEnt
;	COMDAT ??_C@_0BC@LJED@Graph?5not?5ready?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BC@LJED@Graph?5not?5ready?$CB?6?$AA@ DB 'Graph not ready!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HDML@dead?5path?5ent?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BA@HDML@dead?5path?5ent?$CB?6?$AA@ DB 'dead path ent!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KFIJ@func_breakable?$AA@
CONST	SEGMENT
??_C@_0P@KFIJ@func_breakable?$AA@ DB 'func_breakable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LCEE@Unhandled?5Ent?5in?5Path?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BK@LCEE@Unhandled?5Ent?5in?5Path?5?$CFs?6?$AA@ DB 'Unhandled Ent i'
	DB	'n Path %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?HandleLinkEnt@CGraph@@QAEHHPAUentvars_s@@HW4NODEQUERY@1@@Z
_TEXT	SEGMENT
_pevLinkEnt$ = 12
_afCapMask$ = 16
_queryType$ = 20
_this$ = -4
_pentWorld$ = -8
_pDoor$ = -12
_tr$ = -68
?HandleLinkEnt@CGraph@@QAEHHPAUentvars_s@@HW4NODEQUERY@1@@Z PROC NEAR ; CGraph::HandleLinkEnt, COMDAT

; 208  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 209  : 	edict_t  *pentWorld;
; 210  : 	CBaseEntity	*pDoor;
; 211  : 	TraceResult	tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 212  : 
; 213  : 	if ( !m_fGraphPresent || !m_fGraphPointersSet )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L37302
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L37301
$L37302:

; 215  : 		ALERT ( at_aiconsole, "Graph not ready!\n" );

	push	OFFSET FLAT:??_C@_0BC@LJED@Graph?5not?5ready?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 216  : 		return FALSE;

	xor	eax, eax
	jmp	$L37297
$L37301:

; 218  : 
; 219  : 	if ( FNullEnt ( pevLinkEnt ) )

	mov	edx, DWORD PTR _pevLinkEnt$[ebp]
	push	edx
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L37304

; 221  : 		ALERT ( at_aiconsole, "dead path ent!\n" );

	push	OFFSET FLAT:??_C@_0BA@HDML@dead?5path?5ent?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 222  : 		return TRUE;

	mov	eax, 1
	jmp	$L37297
$L37304:

; 224  : 	pentWorld = NULL;

	mov	DWORD PTR _pentWorld$[ebp], 0

; 225  : 
; 226  : // func_door
; 227  : 	if ( FClassnameIs( pevLinkEnt, "func_door" ) || FClassnameIs( pevLinkEnt, "func_door_rotating" ) )

	push	OFFSET FLAT:??_C@_09HMCI@func_door?$AA@	; `string'
	mov	eax, DWORD PTR _pevLinkEnt$[ebp]
	push	eax
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	jne	SHORT $L37307
	push	OFFSET FLAT:??_C@_0BD@DIJK@func_door_rotating?$AA@ ; `string'
	mov	ecx, DWORD PTR _pevLinkEnt$[ebp]
	push	ecx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	$L37306
$L37307:

; 229  : 
; 230  : 		pDoor = ( CBaseEntity::Instance( pevLinkEnt ) );

	mov	edx, DWORD PTR _pevLinkEnt$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pDoor$[ebp], eax

; 231  : 
; 232  : 		if ( ( pevLinkEnt->spawnflags & SF_DOOR_USE_ONLY ) ) 

	mov	eax, DWORD PTR _pevLinkEnt$[ebp]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	je	SHORT $L37308

; 234  : 
; 235  : 			if  ( ( afCapMask & bits_CAP_OPEN_DOORS ) )

	mov	edx, DWORD PTR _afCapMask$[ebp]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	SHORT $L37309

; 237  : 				return TRUE;

	mov	eax, 1
	jmp	$L37297
$L37309:

; 241  : 				// monster should try for it if the door is open and looks as if it will stay that way
; 242  : 				if ( pDoor->GetToggleState()== TS_AT_TOP && ( pevLinkEnt->spawnflags & SF_DOOR_NO_AUTO_RETURN ) )

	mov	eax, DWORD PTR _pDoor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pDoor$[ebp]
	call	DWORD PTR [edx+136]
	test	eax, eax
	jne	SHORT $L37311
	mov	eax, DWORD PTR _pevLinkEnt$[ebp]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 32					; 00000020H
	test	ecx, ecx
	je	SHORT $L37311

; 244  : 					return TRUE;

	mov	eax, 1
	jmp	$L37297
$L37311:

; 246  : 
; 247  : 				return FALSE;

	xor	eax, eax
	jmp	$L37297
$L37308:

; 252  : 			
; 253  : 			// monster should try for it if the door is open and looks as if it will stay that way
; 254  : 			if ( pDoor->GetToggleState() == TS_AT_TOP && ( pevLinkEnt->spawnflags & SF_DOOR_NO_AUTO_RETURN ) )

	mov	edx, DWORD PTR _pDoor$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pDoor$[ebp]
	call	DWORD PTR [eax+136]
	test	eax, eax
	jne	SHORT $L37313
	mov	ecx, DWORD PTR _pevLinkEnt$[ebp]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 32					; 00000020H
	test	edx, edx
	je	SHORT $L37313

; 256  : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $L37297
$L37313:

; 258  : 			if  ( ( afCapMask & bits_CAP_OPEN_DOORS ) )

	mov	eax, DWORD PTR _afCapMask$[ebp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $L37315

; 260  : 				if ( !( pevLinkEnt->spawnflags & SF_DOOR_NOMONSTERS ) || queryType == NODEGRAPH_STATIC )

	mov	ecx, DWORD PTR _pevLinkEnt$[ebp]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	SHORT $L37316
	cmp	DWORD PTR _queryType$[ebp], 1
	jne	SHORT $L37315
$L37316:

; 261  : 					return TRUE;

	mov	eax, 1
	jmp	SHORT $L37297
$L37315:

; 263  : 
; 264  : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L37297
$L37306:

; 267  : // func_breakable	
; 268  : 	else if ( FClassnameIs( pevLinkEnt, "func_breakable" ) && queryType == NODEGRAPH_STATIC )

	push	OFFSET FLAT:??_C@_0P@KFIJ@func_breakable?$AA@ ; `string'
	mov	eax, DWORD PTR _pevLinkEnt$[ebp]
	push	eax
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L37318
	cmp	DWORD PTR _queryType$[ebp], 1
	jne	SHORT $L37318

; 270  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L37297
$L37318:

; 274  : 		ALERT ( at_aiconsole, "Unhandled Ent in Path %s\n", STRING( pevLinkEnt->classname ) );

	mov	ecx, DWORD PTR _pevLinkEnt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BK@LCEE@Unhandled?5Ent?5in?5Path?5?$CFs?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 275  : 		return FALSE;

	xor	eax, eax
$L37297:

; 277  : 
; 278  : 	return FALSE;
; 279  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?HandleLinkEnt@CGraph@@QAEHHPAUentvars_s@@HW4NODEQUERY@1@@Z ENDP ; CGraph::HandleLinkEnt
_TEXT	ENDS
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z PROC NEAR ; CBaseEntity::Instance, COMDAT

; 533  : 	static CBaseEntity *Instance( entvars_t *pev ) { return Instance( ENT( pev ) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
PUBLIC	?HullIndex@CGraph@@QAEHPBVCBaseEntity@@@Z	; CGraph::HullIndex
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
EXTRN	__fltused:NEAR
;	COMDAT ?HullIndex@CGraph@@QAEHPBVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
$T39897 = -16
$T39898 = -28
$T39899 = -40
?HullIndex@CGraph@@QAEHPBVCBaseEntity@@@Z PROC NEAR	; CGraph::HullIndex, COMDAT

; 434  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 435  : 	if ( pEntity->pev->movetype == MOVETYPE_FLY)

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+264], 5
	jne	SHORT $L37326

; 436  : 		return NODE_FLY_HULL;

	mov	eax, 3
	jmp	$L37325
$L37326:

; 437  : 
; 438  : 	if ( pEntity->pev->mins == Vector( -12, -12, 0 ) )

	push	0
	push	-1052770304				; c1400000H
	push	-1052770304				; c1400000H
	lea	ecx, DWORD PTR $T39897[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 220				; 000000dcH
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L37328

; 439  : 		return NODE_SMALL_HULL;

	xor	eax, eax
	jmp	SHORT $L37325
$L37328:

; 440  : 	else if ( pEntity->pev->mins == VEC_HUMAN_HULL_MIN )

	push	0
	push	-1048576000				; c1800000H
	push	-1048576000				; c1800000H
	lea	ecx, DWORD PTR $T39898[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 220				; 000000dcH
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L37331

; 441  : 		return NODE_HUMAN_HULL;

	mov	eax, 1
	jmp	SHORT $L37325
$L37331:

; 442  : 	else if ( pEntity->pev->mins == Vector ( -32, -32, 0 ) )

	push	0
	push	-1040187392				; c2000000H
	push	-1040187392				; c2000000H
	lea	ecx, DWORD PTR $T39899[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 220				; 000000dcH
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L37334

; 443  : 		return NODE_LARGE_HULL;

	mov	eax, 2
	jmp	SHORT $L37325
$L37334:

; 444  : 
; 445  : //	ALERT ( at_aiconsole, "Unknown Hull Mins!\n" );
; 446  : 	return NODE_HUMAN_HULL;

	mov	eax, 1
$L37325:

; 447  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HullIndex@CGraph@@QAEHPBVCBaseEntity@@@Z ENDP		; CGraph::HullIndex
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39905
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39905
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39905
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39906
$L39905:
	mov	DWORD PTR -8+[ebp], 0
$L39906:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
PUBLIC	?NodeType@CGraph@@QAEHPBVCBaseEntity@@@Z	; CGraph::NodeType
;	COMDAT ?NodeType@CGraph@@QAEHPBVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?NodeType@CGraph@@QAEHPBVCBaseEntity@@@Z PROC NEAR	; CGraph::NodeType, COMDAT

; 451  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 452  : 	if ( pEntity->pev->movetype == MOVETYPE_FLY)

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+264], 5
	jne	SHORT $L37341

; 454  : 		if (pEntity->pev->waterlevel != 0)

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+448], 0
	je	SHORT $L37340

; 456  : 			return bits_NODE_WATER;

	mov	eax, 4
	jmp	SHORT $L37338
$L37340:

; 460  : 			return bits_NODE_AIR;

	mov	eax, 2
	jmp	SHORT $L37338
$L37341:

; 463  : 	return bits_NODE_LAND;

	mov	eax, 1
$L37338:

; 464  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?NodeType@CGraph@@QAEHPBVCBaseEntity@@@Z ENDP		; CGraph::NodeType
_TEXT	ENDS
PUBLIC	?HashSearch@CGraph@@QAEXHHAAH@Z			; CGraph::HashSearch
PUBLIC	?CapIndex@CGraph@@QAEHH@Z			; CGraph::CapIndex
PUBLIC	?Link@CGraph@@QAEAAVCLink@@H@Z			; CGraph::Link
PUBLIC	??_C@_0P@DJMB@Route?5Failure?6?$AA@		; `string'
PUBLIC	??_C@_0CE@KCOI@HashLinks?5is?5broken?5from?5?$CFd?5to?5?$CF@ ; `string'
PUBLIC	?PathLength@CGraph@@QAEMHHHH@Z			; CGraph::PathLength
PUBLIC	?NextNodeInRoute@CGraph@@QAEHHHHH@Z		; CGraph::NextNodeInRoute
PUBLIC	__real@4@00000000000000000000
;	COMDAT ??_C@_0P@DJMB@Route?5Failure?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0P@DJMB@Route?5Failure?6?$AA@ DB 'Route Failure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KCOI@HashLinks?5is?5broken?5from?5?$CFd?5to?5?$CF@
CONST	SEGMENT
??_C@_0CE@KCOI@HashLinks?5is?5broken?5from?5?$CFd?5to?5?$CF@ DB 'HashLink'
	DB	's is broken from %d to %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@4@00000000000000000000
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT ?PathLength@CGraph@@QAEMHHHH@Z
_TEXT	SEGMENT
_iStart$ = 8
_iDest$ = 12
_iHull$ = 16
_afCapMask$ = 20
_this$ = -4
_distance$ = -8
_iNext$ = -12
_iMaxLoop$ = -16
_iCurrentNode$ = -20
_iCap$ = -24
_iLink$37360 = -28
_link$37363 = -32
?PathLength@CGraph@@QAEMHHHH@Z PROC NEAR		; CGraph::PathLength, COMDAT

; 469  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 470  : 	float	distance = 0;

	mov	DWORD PTR _distance$[ebp], 0

; 471  : 	int		iNext;
; 472  : 
; 473  : 	int		iMaxLoop = m_cNodes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _iMaxLoop$[ebp], ecx

; 474  : 
; 475  : 	int iCurrentNode = iStart;

	mov	edx, DWORD PTR _iStart$[ebp]
	mov	DWORD PTR _iCurrentNode$[ebp], edx

; 476  : 	int iCap = CapIndex( afCapMask );

	mov	eax, DWORD PTR _afCapMask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CapIndex@CGraph@@QAEHH@Z		; CGraph::CapIndex
	mov	DWORD PTR _iCap$[ebp], eax
$L37355:

; 477  : 
; 478  : 	while (iCurrentNode != iDest)

	mov	ecx, DWORD PTR _iCurrentNode$[ebp]
	cmp	ecx, DWORD PTR _iDest$[ebp]
	je	$L37356

; 480  : 		if (iMaxLoop-- <= 0)

	mov	edx, DWORD PTR _iMaxLoop$[ebp]
	mov	eax, DWORD PTR _iMaxLoop$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iMaxLoop$[ebp], eax
	test	edx, edx
	jg	SHORT $L37357

; 482  : 			ALERT( at_console, "Route Failure\n" );

	push	OFFSET FLAT:??_C@_0P@DJMB@Route?5Failure?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 483  : 			return 0;

	fld	DWORD PTR __real@4@00000000000000000000
	jmp	$L37348
$L37357:

; 485  : 
; 486  : 		iNext = NextNodeInRoute( iCurrentNode, iDest, iHull, iCap );

	mov	ecx, DWORD PTR _iCap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iHull$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iCurrentNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextNodeInRoute@CGraph@@QAEHHHHH@Z	; CGraph::NextNodeInRoute
	mov	DWORD PTR _iNext$[ebp], eax

; 487  : 		if (iCurrentNode == iNext)

	mov	edx, DWORD PTR _iCurrentNode$[ebp]
	cmp	edx, DWORD PTR _iNext$[ebp]
	jne	SHORT $L37359

; 489  : 			//ALERT(at_aiconsole, "SVD: Can't get there from here..\n");
; 490  : 			return 0;

	fld	DWORD PTR __real@4@00000000000000000000
	jmp	SHORT $L37348
$L37359:

; 494  : 		HashSearch(iCurrentNode, iNext, iLink);

	lea	eax, DWORD PTR _iLink$37360[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iCurrentNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HashSearch@CGraph@@QAEXHHAAH@Z		; CGraph::HashSearch

; 495  : 		if (iLink < 0)

	cmp	DWORD PTR _iLink$37360[ebp], 0
	jge	SHORT $L37361

; 497  : 			ALERT(at_console, "HashLinks is broken from %d to %d.\n", iCurrentNode, iDest);

	mov	eax, DWORD PTR _iDest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iCurrentNode$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CE@KCOI@HashLinks?5is?5broken?5from?5?$CFd?5to?5?$CF@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 498  : 			return 0;

	fld	DWORD PTR __real@4@00000000000000000000
	jmp	SHORT $L37348
$L37361:

; 500  : 		CLink &link = Link(iLink);

	mov	edx, DWORD PTR _iLink$37360[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Link@CGraph@@QAEAAVCLink@@H@Z		; CGraph::Link
	mov	DWORD PTR _link$37363[ebp], eax

; 501  : 		distance += link.m_flWeight;

	mov	eax, DWORD PTR _link$37363[ebp]
	fld	DWORD PTR _distance$[ebp]
	fadd	DWORD PTR [eax+20]
	fstp	DWORD PTR _distance$[ebp]

; 502  : 
; 503  : 		iCurrentNode = iNext;

	mov	ecx, DWORD PTR _iNext$[ebp]
	mov	DWORD PTR _iCurrentNode$[ebp], ecx

; 504  : 	}

	jmp	$L37355
$L37356:

; 505  : 
; 506  : 	return distance;

	fld	DWORD PTR _distance$[ebp]
$L37348:

; 507  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?PathLength@CGraph@@QAEMHHHH@Z ENDP			; CGraph::PathLength
_TEXT	ENDS
;	COMDAT ?CapIndex@CGraph@@QAEHH@Z
_TEXT	SEGMENT
_afCapMask$ = 8
_this$ = -4
?CapIndex@CGraph@@QAEHH@Z PROC NEAR			; CGraph::CapIndex, COMDAT

; 202  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 		if (afCapMask & (bits_CAP_OPEN_DOORS | bits_CAP_AUTO_DOORS | bits_CAP_USE)) 

	mov	eax, DWORD PTR _afCapMask$[ebp]
	and	eax, 832				; 00000340H
	test	eax, eax
	je	SHORT $L36906

; 204  : 			return 1; 

	mov	eax, 1
	jmp	SHORT $L36905
$L36906:

; 205  : 		return 0; 

	xor	eax, eax
$L36905:

; 206  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CapIndex@CGraph@@QAEHH@Z ENDP				; CGraph::CapIndex
_TEXT	ENDS
PUBLIC	??_C@_0L@OJHA@Bad?5link?$CB?6?$AA@		; `string'
;	COMDAT ??_C@_0L@OJHA@Bad?5link?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.h
CONST	SEGMENT
??_C@_0L@OJHA@Bad?5link?$CB?6?$AA@ DB 'Bad link!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?Link@CGraph@@QAEAAVCLink@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Link@CGraph@@QAEAAVCLink@@H@Z PROC NEAR		; CGraph::Link, COMDAT

; 219  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 220  : #ifdef _DEBUG
; 221  : 		if ( !m_pLinkPool || i < 0 || i > m_cLinks )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L36915
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L36915
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jle	SHORT $L36914
$L36915:

; 222  : 			ALERT( at_error, "Bad link!\n" );

	push	OFFSET FLAT:??_C@_0L@OJHA@Bad?5link?$CB?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L36914:

; 223  : #endif
; 224  : 		return m_pLinkPool[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	eax, edx

; 225  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Link@CGraph@@QAEAAVCLink@@H@Z ENDP			; CGraph::Link
_TEXT	ENDS
;	COMDAT ?NextNodeInRoute@CGraph@@QAEHHHHH@Z
_TEXT	SEGMENT
_iCurrentNode$ = 8
_iDest$ = 12
_iHull$ = 16
_iCap$ = 20
_this$ = -4
_iNext$ = -8
_nCount$ = -12
_pRoute$ = -16
_ch$37377 = -20
?NextNodeInRoute@CGraph@@QAEHHHHH@Z PROC NEAR		; CGraph::NextNodeInRoute, COMDAT

; 512  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 513  : 	int iNext = iCurrentNode;

	mov	eax, DWORD PTR _iCurrentNode$[ebp]
	mov	DWORD PTR _iNext$[ebp], eax

; 514  : 	int nCount = iDest+1;

	mov	ecx, DWORD PTR _iDest$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nCount$[ebp], ecx

; 515  : 	char *pRoute = m_pRouteInfo + m_pNodes[ iCurrentNode ].m_pNextBestNode[iHull][iCap];

	mov	edx, DWORD PTR _iCurrentNode$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, edx
	mov	edx, DWORD PTR _iHull$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _iCap$[ebp]
	add	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pRoute$[ebp], edx
$L37375:

; 516  : 
; 517  : 	// Until we decode the next best node
; 518  : 	//
; 519  : 	while (nCount > 0)

	cmp	DWORD PTR _nCount$[ebp], 0
	jle	$L37376

; 521  : 		char ch = *pRoute++;

	mov	edx, DWORD PTR _pRoute$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _ch$37377[ebp], al
	mov	ecx, DWORD PTR _pRoute$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pRoute$[ebp], ecx

; 522  : 		//ALERT(at_aiconsole, "C(%d)", ch);
; 523  : 		if (ch < 0)

	movsx	edx, BYTE PTR _ch$37377[ebp]
	test	edx, edx
	jge	SHORT $L37378

; 525  : 			// Sequence phrase
; 526  : 			//
; 527  : 			ch = -ch;

	movsx	eax, BYTE PTR _ch$37377[ebp]
	neg	eax
	mov	BYTE PTR _ch$37377[ebp], al

; 528  : 			if (nCount <= ch)

	movsx	ecx, BYTE PTR _ch$37377[ebp]
	cmp	DWORD PTR _nCount$[ebp], ecx
	jg	SHORT $L37379

; 530  : 				iNext = iDest;

	mov	edx, DWORD PTR _iDest$[ebp]
	mov	DWORD PTR _iNext$[ebp], edx

; 531  : 				nCount = 0;

	mov	DWORD PTR _nCount$[ebp], 0

; 534  : 			else

	jmp	SHORT $L37380
$L37379:

; 536  : 				//ALERT(at_aiconsole, "SEQ: nCount + ch (%d + %d)\n", nCount, ch);
; 537  : 				nCount = nCount - ch;

	movsx	eax, BYTE PTR _ch$37377[ebp]
	mov	ecx, DWORD PTR _nCount$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _nCount$[ebp], ecx
$L37380:

; 540  : 		else

	jmp	SHORT $L37381
$L37378:

; 542  : 			//ALERT(at_aiconsole, "C(%d)", *pRoute);
; 543  : 
; 544  : 			// Repeat phrase
; 545  : 			//
; 546  : 			if (nCount <= ch+1)

	movsx	edx, BYTE PTR _ch$37377[ebp]
	add	edx, 1
	cmp	DWORD PTR _nCount$[ebp], edx
	jg	SHORT $L37382

; 548  : 				iNext = iCurrentNode + *pRoute;

	mov	eax, DWORD PTR _pRoute$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _iCurrentNode$[ebp]
	add	edx, ecx
	mov	DWORD PTR _iNext$[ebp], edx

; 549  : 				if (iNext >= m_cNodes) iNext -= m_cNodes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iNext$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jl	SHORT $L37383
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iNext$[ebp]
	sub	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _iNext$[ebp], eax

; 550  : 				else if (iNext < 0) iNext += m_cNodes;

	jmp	SHORT $L37385
$L37383:
	cmp	DWORD PTR _iNext$[ebp], 0
	jge	SHORT $L37385
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iNext$[ebp]
	add	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _iNext$[ebp], edx
$L37385:

; 551  : 				nCount = 0;

	mov	DWORD PTR _nCount$[ebp], 0

; 554  : 			else

	jmp	SHORT $L37386
$L37382:

; 556  : 				//ALERT(at_aiconsole, "REP: nCount - ch+1 (%d - %d+1)\n", nCount, ch);
; 557  : 				nCount = nCount - ch - 1;

	movsx	eax, BYTE PTR _ch$37377[ebp]
	mov	ecx, DWORD PTR _nCount$[ebp]
	sub	ecx, eax
	sub	ecx, 1
	mov	DWORD PTR _nCount$[ebp], ecx
$L37386:

; 559  : 			pRoute++;

	mov	edx, DWORD PTR _pRoute$[ebp]
	add	edx, 1
	mov	DWORD PTR _pRoute$[ebp], edx
$L37381:

; 561  : 	}

	jmp	$L37375
$L37376:

; 562  : 
; 563  : 	return iNext;

	mov	eax, DWORD PTR _iNext$[ebp]

; 564  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?NextNodeInRoute@CGraph@@QAEHHHHH@Z ENDP		; CGraph::NextNodeInRoute
_TEXT	ENDS
PUBLIC	?INodeLink@CGraph@@QAEHHH@Z			; CGraph::INodeLink
PUBLIC	??0CQueuePriority@@QAE@XZ			; CQueuePriority::CQueuePriority
PUBLIC	?Empty@CQueuePriority@@QAEHXZ			; CQueuePriority::Empty
PUBLIC	?Insert@CQueuePriority@@QAEXHM@Z		; CQueuePriority::Insert
PUBLIC	?Remove@CQueuePriority@@QAEHAAM@Z		; CQueuePriority::Remove
PUBLIC	??_C@_0CD@OKDC@Can?8t?5build?5a?5path?0?5iStart?5is?5?$CFd@ ; `string'
PUBLIC	?FindShortestPath@CGraph@@QAEHPAHHHHH@Z		; CGraph::FindShortestPath
PUBLIC	__real@8@bffe8000000000000000
PUBLIC	__real@8@3ff583126e978d4fe000
;	COMDAT ??_C@_0CD@OKDC@Can?8t?5build?5a?5path?0?5iStart?5is?5?$CFd@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0CD@OKDC@Can?8t?5build?5a?5path?0?5iStart?5is?5?$CFd@ DB 'Can''t bu'
	DB	'ild a path, iStart is %d!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@8@bffe8000000000000000
CONST	SEGMENT
__real@8@bffe8000000000000000 DQ 0bfe0000000000000r ; -0.5
CONST	ENDS
;	COMDAT __real@8@3ff583126e978d4fe000
CONST	SEGMENT
__real@8@3ff583126e978d4fe000 DQ 03f50624dd2f1a9fcr ; 0.001
CONST	ENDS
;	COMDAT ?FindShortestPath@CGraph@@QAEHPAHHHHH@Z
_TEXT	SEGMENT
_piPath$ = 8
_iStart$ = 12
_iDest$ = 16
_iHull$ = 20
_afCapMask$ = 24
_this$ = -4
_iVisitNode$ = -8
_iCurrentNode$ = -12
_iNumPathNodes$ = -16
_iHullMask$ = -20
_iCap$37406 = -24
_iNext$37407 = -28
_queue$37414 = -832
_i$37423 = -836
_flCurrentDistance$37430 = -840
_pCurrentNode$37432 = -844
_flOurDistance$37439 = -848
?FindShortestPath@CGraph@@QAEHPAHHHHH@Z PROC NEAR	; CGraph::FindShortestPath, COMDAT

; 575  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 916				; 00000394H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 576  : 	int		iVisitNode;
; 577  : 	int		iCurrentNode;
; 578  : 	int		iNumPathNodes;
; 579  : 	int		iHullMask;
; 580  : 
; 581  : 	if ( !m_fGraphPresent || !m_fGraphPointersSet )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L37400
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L37399
$L37400:

; 583  : 		ALERT ( at_aiconsole, "Graph not ready!\n" );

	push	OFFSET FLAT:??_C@_0BC@LJED@Graph?5not?5ready?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 584  : 		return FALSE;

	xor	eax, eax
	jmp	$L37394
$L37399:

; 586  : 	
; 587  : 	if ( iStart < 0 || iStart > m_cNodes )

	cmp	DWORD PTR _iStart$[ebp], 0
	jl	SHORT $L37402
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iStart$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jle	SHORT $L37401
$L37402:

; 589  : 		ALERT ( at_aiconsole, "Can't build a path, iStart is %d!\n", iStart );

	mov	ecx, DWORD PTR _iStart$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CD@OKDC@Can?8t?5build?5a?5path?0?5iStart?5is?5?$CFd@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 590  : 		return FALSE;

	xor	eax, eax
	jmp	$L37394
$L37401:

; 592  : 
; 593  : 	if (iStart == iDest)

	mov	edx, DWORD PTR _iStart$[ebp]
	cmp	edx, DWORD PTR _iDest$[ebp]
	jne	SHORT $L37404

; 595  : 		piPath[0] = iStart;

	mov	eax, DWORD PTR _piPath$[ebp]
	mov	ecx, DWORD PTR _iStart$[ebp]
	mov	DWORD PTR [eax], ecx

; 596  : 		piPath[1] = iDest;

	mov	edx, DWORD PTR _piPath$[ebp]
	mov	eax, DWORD PTR _iDest$[ebp]
	mov	DWORD PTR [edx+4], eax

; 597  : 		return 2;

	mov	eax, 2
	jmp	$L37394
$L37404:

; 599  : 
; 600  : 	// Is routing information present.
; 601  : 	//
; 602  : 	if (m_fRoutingComplete)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	$L37405

; 604  : 		int iCap = CapIndex( afCapMask );

	mov	edx, DWORD PTR _afCapMask$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CapIndex@CGraph@@QAEHH@Z		; CGraph::CapIndex
	mov	DWORD PTR _iCap$37406[ebp], eax

; 605  : 
; 606  : 		iNumPathNodes = 0;

	mov	DWORD PTR _iNumPathNodes$[ebp], 0

; 607  : 		piPath[iNumPathNodes++] = iStart;

	mov	eax, DWORD PTR _iNumPathNodes$[ebp]
	mov	ecx, DWORD PTR _piPath$[ebp]
	mov	edx, DWORD PTR _iStart$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _iNumPathNodes$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumPathNodes$[ebp], eax

; 608  : 		iCurrentNode = iStart;

	mov	ecx, DWORD PTR _iStart$[ebp]
	mov	DWORD PTR _iCurrentNode$[ebp], ecx
$L37409:

; 609  : 		int iNext;
; 610  : 
; 611  : 		//ALERT(at_aiconsole, "GOAL: %d to %d\n", iStart, iDest);
; 612  : 
; 613  : 		// Until we arrive at the destination
; 614  : 		//
; 615  : 		while (iCurrentNode != iDest)

	mov	edx, DWORD PTR _iCurrentNode$[ebp]
	cmp	edx, DWORD PTR _iDest$[ebp]
	je	SHORT $L37410

; 617  : 			iNext = NextNodeInRoute( iCurrentNode, iDest, iHull, iCap );

	mov	eax, DWORD PTR _iCap$37406[ebp]
	push	eax
	mov	ecx, DWORD PTR _iHull$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDest$[ebp]
	push	edx
	mov	eax, DWORD PTR _iCurrentNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextNodeInRoute@CGraph@@QAEHHHHH@Z	; CGraph::NextNodeInRoute
	mov	DWORD PTR _iNext$37407[ebp], eax

; 618  : 			if (iCurrentNode == iNext)

	mov	ecx, DWORD PTR _iCurrentNode$[ebp]
	cmp	ecx, DWORD PTR _iNext$37407[ebp]
	jne	SHORT $L37411

; 620  : 				//ALERT(at_aiconsole, "SVD: Can't get there from here..\n");
; 621  : 				return 0;

	xor	eax, eax
	jmp	$L37394
$L37411:

; 624  : 			if (iNumPathNodes >= MAX_PATH_SIZE) 

	cmp	DWORD PTR _iNumPathNodes$[ebp], 10	; 0000000aH
	jl	SHORT $L37412

; 626  : 				//ALERT(at_aiconsole, "SVD: Don't return the entire path.\n");
; 627  : 				break;

	jmp	SHORT $L37410
$L37412:

; 629  : 			piPath[iNumPathNodes++] = iNext;

	mov	edx, DWORD PTR _iNumPathNodes$[ebp]
	mov	eax, DWORD PTR _piPath$[ebp]
	mov	ecx, DWORD PTR _iNext$37407[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, DWORD PTR _iNumPathNodes$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumPathNodes$[ebp], edx

; 630  : 			iCurrentNode = iNext;

	mov	eax, DWORD PTR _iNext$37407[ebp]
	mov	DWORD PTR _iCurrentNode$[ebp], eax

; 631  : 		}

	jmp	SHORT $L37409
$L37410:

; 634  : 	else

	jmp	$L37448
$L37405:

; 636  : 		CQueuePriority	queue;

	lea	ecx, DWORD PTR _queue$37414[ebp]
	call	??0CQueuePriority@@QAE@XZ		; CQueuePriority::CQueuePriority

; 639  : 		{

	mov	ecx, DWORD PTR _iHull$[ebp]
	mov	DWORD PTR -852+[ebp], ecx
	cmp	DWORD PTR -852+[ebp], 3
	ja	SHORT $L37416
	mov	edx, DWORD PTR -852+[ebp]
	jmp	DWORD PTR $L39925[edx*4]
$L37419:

; 640  : 		case NODE_SMALL_HULL:
; 641  : 			iHullMask = bits_LINK_SMALL_HULL;

	mov	DWORD PTR _iHullMask$[ebp], 1

; 642  : 			break;

	jmp	SHORT $L37416
$L37420:

; 643  : 		case NODE_HUMAN_HULL:
; 644  : 			iHullMask = bits_LINK_HUMAN_HULL;

	mov	DWORD PTR _iHullMask$[ebp], 2

; 645  : 			break;

	jmp	SHORT $L37416
$L37421:

; 646  : 		case NODE_LARGE_HULL:
; 647  : 			iHullMask = bits_LINK_LARGE_HULL;

	mov	DWORD PTR _iHullMask$[ebp], 4

; 648  : 			break;

	jmp	SHORT $L37416
$L37422:

; 649  : 		case NODE_FLY_HULL:
; 650  : 			iHullMask = bits_LINK_FLY_HULL;

	mov	DWORD PTR _iHullMask$[ebp], 8
$L37416:

; 653  : 
; 654  : 		// Mark all the nodes as unvisited.
; 655  : 		//
; 656  : 		for ( int i = 0; i < m_cNodes; i++)

	mov	DWORD PTR _i$37423[ebp], 0
	jmp	SHORT $L37424
$L37425:
	mov	eax, DWORD PTR _i$37423[ebp]
	add	eax, 1
	mov	DWORD PTR _i$37423[ebp], eax
$L37424:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$37423[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L37426

; 658  : 			m_pNodes[ i ].m_flClosestSoFar = -1.0;

	mov	eax, DWORD PTR _i$37423[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+eax+72], -1082130432	; bf800000H

; 659  : 		}

	jmp	SHORT $L37425
$L37426:

; 660  : 
; 661  : 		m_pNodes[ iStart ].m_flClosestSoFar = 0.0;

	mov	eax, DWORD PTR _iStart$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+eax+72], 0

; 662  : 		m_pNodes[ iStart ].m_iPreviousNode = iStart;// tag this as the origin node

	mov	eax, DWORD PTR _iStart$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _iStart$[ebp]
	mov	DWORD PTR [edx+eax+76], ecx

; 663  : 		queue.Insert( iStart, 0.0 );// insert start node 

	push	0
	mov	edx, DWORD PTR _iStart$[ebp]
	push	edx
	lea	ecx, DWORD PTR _queue$37414[ebp]
	call	?Insert@CQueuePriority@@QAEXHM@Z	; CQueuePriority::Insert
$L37428:

; 664  : 		
; 665  : 		while ( !queue.Empty() )

	lea	ecx, DWORD PTR _queue$37414[ebp]
	call	?Empty@CQueuePriority@@QAEHXZ		; CQueuePriority::Empty
	test	eax, eax
	jne	$L37429

; 667  : 			// now pull a node out of the queue
; 668  : 			float flCurrentDistance;
; 669  : 			iCurrentNode = queue.Remove(flCurrentDistance);

	lea	eax, DWORD PTR _flCurrentDistance$37430[ebp]
	push	eax
	lea	ecx, DWORD PTR _queue$37414[ebp]
	call	?Remove@CQueuePriority@@QAEHAAM@Z	; CQueuePriority::Remove
	mov	DWORD PTR _iCurrentNode$[ebp], eax

; 670  : 
; 671  : 			// For straight-line weights, the following Shortcut works. For arbitrary weights,
; 672  : 			// it doesn't.
; 673  : 			//
; 674  : 			if (iCurrentNode == iDest) break;

	mov	ecx, DWORD PTR _iCurrentNode$[ebp]
	cmp	ecx, DWORD PTR _iDest$[ebp]
	jne	SHORT $L37431
	jmp	$L37429
$L37431:

; 675  : 
; 676  : 			CNode *pCurrentNode = &m_pNodes[ iCurrentNode ];

	mov	edx, DWORD PTR _iCurrentNode$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, edx
	mov	DWORD PTR _pCurrentNode$37432[ebp], ecx

; 677  : 			
; 678  : 			for ( i = 0 ; i < pCurrentNode->m_cNumLinks ; i++ )

	mov	DWORD PTR _i$37423[ebp], 0
	jmp	SHORT $L37433
$L37434:
	mov	edx, DWORD PTR _i$37423[ebp]
	add	edx, 1
	mov	DWORD PTR _i$37423[ebp], edx
$L37433:
	mov	eax, DWORD PTR _pCurrentNode$37432[ebp]
	mov	ecx, DWORD PTR _i$37423[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	$L37435

; 680  : 				
; 681  : 				iVisitNode = INodeLink ( iCurrentNode, i );

	mov	edx, DWORD PTR _i$37423[ebp]
	push	edx
	mov	eax, DWORD PTR _iCurrentNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?INodeLink@CGraph@@QAEHHH@Z		; CGraph::INodeLink
	mov	DWORD PTR _iVisitNode$[ebp], eax

; 682  : 				if ( ( m_pLinkPool[  m_pNodes[ iCurrentNode ].m_iFirstLink + i ].m_afLinkInfo & iHullMask ) != iHullMask )

	mov	ecx, DWORD PTR _iCurrentNode$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx+36]
	add	ecx, DWORD PTR _i$37423[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+ecx+16]
	and	ecx, DWORD PTR _iHullMask$[ebp]
	cmp	ecx, DWORD PTR _iHullMask$[ebp]
	je	SHORT $L37436

; 684  : 					//ALERT ( at_aiconsole, "fat ass %d/%d\n",m_pLinkPool[ m_pNodes[ iCurrentNode ].m_iFirstLink + i ].m_afLinkInfo, iMonsterHull );
; 685  : 					continue;

	jmp	SHORT $L37434
$L37436:

; 687  : 				// check the connection from the current node to the node we're about to mark visited and push into the queue				
; 688  : 				if ( m_pLinkPool[ m_pNodes[ iCurrentNode ].m_iFirstLink + i ].m_pLinkEnt != NULL )

	mov	edx, DWORD PTR _iCurrentNode$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx+36]
	add	edx, DWORD PTR _i$37423[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+edx+8], 0
	je	SHORT $L37438

; 690  : 					
; 691  : 					if ( !HandleLinkEnt ( iCurrentNode, m_pLinkPool[ m_pNodes[ iCurrentNode ].m_iFirstLink + i ].m_pLinkEnt, afCapMask, NODEGRAPH_STATIC ) )

	push	1
	mov	edx, DWORD PTR _afCapMask$[ebp]
	push	edx
	mov	eax, DWORD PTR _iCurrentNode$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax+36]
	add	eax, DWORD PTR _i$37423[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+eax+8]
	push	eax
	mov	ecx, DWORD PTR _iCurrentNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleLinkEnt@CGraph@@QAEHHPAUentvars_s@@HW4NODEQUERY@1@@Z ; CGraph::HandleLinkEnt
	test	eax, eax
	jne	SHORT $L37438

; 693  : 						continue;

	jmp	$L37434
$L37438:

; 696  : 				float flOurDistance = flCurrentDistance + m_pLinkPool[ m_pNodes[ iCurrentNode ].m_iFirstLink + i].m_flWeight;

	mov	edx, DWORD PTR _iCurrentNode$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx+36]
	add	edx, DWORD PTR _i$37423[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	fld	DWORD PTR _flCurrentDistance$37430[ebp]
	fadd	DWORD PTR [ecx+edx+20]
	fstp	DWORD PTR _flOurDistance$37439[ebp]

; 698  : 				   || flOurDistance < m_pNodes[ iVisitNode ].m_flClosestSoFar - 0.001 )

	mov	edx, DWORD PTR _iVisitNode$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	fld	DWORD PTR [ecx+edx+72]
	fcomp	QWORD PTR __real@8@bffe8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L37441
	fld	DWORD PTR _flOurDistance$37439[ebp]
	mov	edx, DWORD PTR _iVisitNode$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	fld	DWORD PTR [ecx+edx+72]
	fsub	QWORD PTR __real@8@3ff583126e978d4fe000
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37440
$L37441:

; 700  : 					m_pNodes[iVisitNode].m_flClosestSoFar = flOurDistance;

	mov	edx, DWORD PTR _iVisitNode$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _flOurDistance$37439[ebp]
	mov	DWORD PTR [ecx+edx+72], eax

; 701  : 					m_pNodes[iVisitNode].m_iPreviousNode = iCurrentNode;

	mov	ecx, DWORD PTR _iVisitNode$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _iCurrentNode$[ebp]
	mov	DWORD PTR [eax+ecx+76], edx

; 702  : 
; 703  : 					queue.Insert ( iVisitNode, flOurDistance );

	mov	eax, DWORD PTR _flOurDistance$37439[ebp]
	push	eax
	mov	ecx, DWORD PTR _iVisitNode$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _queue$37414[ebp]
	call	?Insert@CQueuePriority@@QAEXHM@Z	; CQueuePriority::Insert
$L37440:

; 705  : 			}

	jmp	$L37434
$L37435:

; 706  : 		}

	jmp	$L37428
$L37429:

; 707  : 		if ( m_pNodes[iDest].m_flClosestSoFar < -0.5 )

	mov	edx, DWORD PTR _iDest$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	fld	DWORD PTR [ecx+edx+72]
	fcomp	QWORD PTR __real@8@bffe8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37442

; 709  : 			return 0;

	xor	eax, eax
	jmp	$L37394
$L37442:

; 711  : 
; 712  : 	// the queue is not empty
; 713  : 		
; 714  : 		// now we must walk backwards through the m_iPreviousNode field, and count how many connections there are in the path
; 715  : 		iCurrentNode = iDest;

	mov	edx, DWORD PTR _iDest$[ebp]
	mov	DWORD PTR _iCurrentNode$[ebp], edx

; 716  : 		iNumPathNodes = 1;// count the dest

	mov	DWORD PTR _iNumPathNodes$[ebp], 1
$L37444:

; 717  : 		
; 718  : 		while ( iCurrentNode != iStart )

	mov	eax, DWORD PTR _iCurrentNode$[ebp]
	cmp	eax, DWORD PTR _iStart$[ebp]
	je	SHORT $L37445

; 720  : 			iNumPathNodes++;

	mov	ecx, DWORD PTR _iNumPathNodes$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumPathNodes$[ebp], ecx

; 721  : 			iCurrentNode = m_pNodes[ iCurrentNode ].m_iPreviousNode;

	mov	edx, DWORD PTR _iCurrentNode$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx+76]
	mov	DWORD PTR _iCurrentNode$[ebp], edx

; 722  : 		}

	jmp	SHORT $L37444
$L37445:

; 723  : 
; 724  : 		iCurrentNode = iDest;

	mov	eax, DWORD PTR _iDest$[ebp]
	mov	DWORD PTR _iCurrentNode$[ebp], eax

; 725  : 		for ( i = iNumPathNodes - 1 ; i >= 0 ; i-- )

	mov	ecx, DWORD PTR _iNumPathNodes$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$37423[ebp], ecx
	jmp	SHORT $L37446
$L37447:
	mov	edx, DWORD PTR _i$37423[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$37423[ebp], edx
$L37446:
	cmp	DWORD PTR _i$37423[ebp], 0
	jl	SHORT $L37448

; 727  : 			piPath[ i ] = iCurrentNode;

	mov	eax, DWORD PTR _i$37423[ebp]
	mov	ecx, DWORD PTR _piPath$[ebp]
	mov	edx, DWORD PTR _iCurrentNode$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 728  : 			iCurrentNode = m_pNodes [ iCurrentNode ].m_iPreviousNode;

	mov	eax, DWORD PTR _iCurrentNode$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax+76]
	mov	DWORD PTR _iCurrentNode$[ebp], eax

; 729  : 		}

	jmp	SHORT $L37447
$L37448:

; 731  : 
; 732  : #if 0
; 733  : 
; 734  : 	if (m_fRoutingComplete)
; 735  : 	{
; 736  : 		// This will draw the entire path that was generated for the monster.
; 737  : 
; 738  : 		for ( int i = 0 ; i < iNumPathNodes - 1 ; i++ )
; 739  : 		{
; 740  : 			MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );
; 741  : 				WRITE_BYTE( TE_SHOWLINE);
; 742  : 				
; 743  : 				WRITE_COORD( m_pNodes[ piPath[ i ] ].m_vecOrigin.x );
; 744  : 				WRITE_COORD( m_pNodes[ piPath[ i ] ].m_vecOrigin.y );
; 745  : 				WRITE_COORD( m_pNodes[ piPath[ i ] ].m_vecOrigin.z + NODE_HEIGHT );
; 746  : 
; 747  : 				WRITE_COORD( m_pNodes[ piPath[ i + 1 ] ].m_vecOrigin.x );
; 748  : 				WRITE_COORD( m_pNodes[ piPath[ i + 1 ] ].m_vecOrigin.y );
; 749  : 				WRITE_COORD( m_pNodes[ piPath[ i + 1 ] ].m_vecOrigin.z + NODE_HEIGHT );
; 750  : 			MESSAGE_END();
; 751  : 		}
; 752  : 	}
; 753  : 
; 754  : #endif
; 755  : #if 0 // MAZE map
; 756  : 	MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );
; 757  : 		WRITE_BYTE( TE_SHOWLINE);
; 758  : 		
; 759  : 		WRITE_COORD( m_pNodes[ 4 ].m_vecOrigin.x );
; 760  : 		WRITE_COORD( m_pNodes[ 4 ].m_vecOrigin.y );
; 761  : 		WRITE_COORD( m_pNodes[ 4 ].m_vecOrigin.z + NODE_HEIGHT );
; 762  : 
; 763  : 		WRITE_COORD( m_pNodes[ 9 ].m_vecOrigin.x );
; 764  : 		WRITE_COORD( m_pNodes[ 9 ].m_vecOrigin.y );
; 765  : 		WRITE_COORD( m_pNodes[ 9 ].m_vecOrigin.z + NODE_HEIGHT );
; 766  : 	MESSAGE_END();
; 767  : #endif
; 768  : 
; 769  : 	return iNumPathNodes;

	mov	eax, DWORD PTR _iNumPathNodes$[ebp]
$L37394:

; 770  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L39925:
	DD	$L37419
	DD	$L37420
	DD	$L37421
	DD	$L37422
?FindShortestPath@CGraph@@QAEHPAHHHHH@Z ENDP		; CGraph::FindShortestPath
_TEXT	ENDS
PUBLIC	?NodeLink@CGraph@@QAEAAVCLink@@HH@Z		; CGraph::NodeLink
;	COMDAT ?INodeLink@CGraph@@QAEHHH@Z
_TEXT	SEGMENT
_iNode$ = 8
_iLink$ = 12
_this$ = -4
?INodeLink@CGraph@@QAEHHH@Z PROC NEAR			; CGraph::INodeLink, COMDAT

; 238  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 		return NodeLink( iNode, iLink ).m_iDestNode;

	mov	eax, DWORD PTR _iLink$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NodeLink@CGraph@@QAEAAVCLink@@HH@Z	; CGraph::NodeLink
	mov	eax, DWORD PTR [eax+4]

; 240  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?INodeLink@CGraph@@QAEHHH@Z ENDP			; CGraph::INodeLink
_TEXT	ENDS
PUBLIC	?Node@CGraph@@QAEAAVCNode@@H@Z			; CGraph::Node
;	COMDAT ?NodeLink@CGraph@@QAEAAVCLink@@HH@Z
_TEXT	SEGMENT
_iNode$ = 8
_iLink$ = 12
_this$ = -4
?NodeLink@CGraph@@QAEAAVCLink@@HH@Z PROC NEAR		; CGraph::NodeLink, COMDAT

; 228  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 229  : 		return Link( Node( iNode ).m_iFirstLink + iLink );

	mov	eax, DWORD PTR _iNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Node@CGraph@@QAEAAVCNode@@H@Z		; CGraph::Node
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, DWORD PTR _iLink$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Link@CGraph@@QAEAAVCLink@@H@Z		; CGraph::Link

; 230  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?NodeLink@CGraph@@QAEAAVCLink@@HH@Z ENDP		; CGraph::NodeLink
_TEXT	ENDS
PUBLIC	??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@		; `string'
;	COMDAT ??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.h
CONST	SEGMENT
??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@ DB 'Bad Node!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?Node@CGraph@@QAEAAVCNode@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Node@CGraph@@QAEAAVCNode@@H@Z PROC NEAR		; CGraph::Node, COMDAT

; 210  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 211  : #ifdef _DEBUG
; 212  : 		if ( !m_pNodes || i < 0 || i > m_cNodes )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L36910
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L36910
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jle	SHORT $L36909
$L36910:

; 213  : 			ALERT( at_error, "Bad Node!\n" );

	push	OFFSET FLAT:??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L36909:

; 214  : #endif
; 215  : 		return m_pNodes[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	eax, edx

; 216  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Node@CGraph@@QAEAAVCNode@@H@Z ENDP			; CGraph::Node
_TEXT	ENDS
;	COMDAT ?Empty@CQueuePriority@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Empty@CQueuePriority@@QAEHXZ PROC NEAR			; CQueuePriority::Empty, COMDAT

; 331  : 	inline int Empty ( void ) { return ( m_cSize == 0 ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	sete	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Empty@CQueuePriority@@QAEHXZ ENDP			; CQueuePriority::Empty
_TEXT	ENDS
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	?CALC_RANGE@@YAHHHH@Z				; CALC_RANGE
PUBLIC	?UpdateRange@@YAXAAH0HH@Z			; UpdateRange
PUBLIC	?CheckNode@CGraph@@QAEXVVector@@H@Z		; CGraph::CheckNode
EXTRN	__ftol:NEAR
;	COMDAT __real@8@3fff8000000000000000
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT ?CheckNode@CGraph@@QAEXVVector@@H@Z
_TEXT	SEGMENT
$T39936 = -76
_vecOrigin$ = 8
_iNode$ = 20
_this$ = -4
_flDist$ = -8
_tr$37487 = -64
?CheckNode@CGraph@@QAEXVVector@@H@Z PROC NEAR		; CGraph::CheckNode, COMDAT

; 812  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 813  :     // Have we already seen this point before?.
; 814  :     //
; 815  :     if (m_di[iNode].m_CheckedEvent == m_CheckedCounter) return;

	mov	eax, DWORD PTR _iNode$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+eax+12]
	cmp	edx, DWORD PTR [ecx+6240]
	jne	SHORT $L37483
	jmp	$L37482
$L37483:

; 816  :     m_di[iNode].m_CheckedEvent = m_CheckedCounter;

	mov	eax, DWORD PTR _iNode$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+6240]
	mov	DWORD PTR [edx+eax+12], ecx

; 817  : 
; 818  : 	float flDist = ( vecOrigin - m_pNodes[ iNode ].m_vecOriginPeek ).Length();

	mov	edx, DWORD PTR _iNode$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	lea	edx, DWORD PTR [ecx+edx+12]
	push	edx
	lea	eax, DWORD PTR $T39936[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecOrigin$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flDist$[ebp]

; 819  : 
; 820  : 	if ( flDist < m_flShortest )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR [ecx+6184]
	fnstsw	ax
	test	ah, 1
	je	$L37488

; 822  : 		TraceResult tr;

	lea	ecx, DWORD PTR _tr$37487[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 823  : 
; 824  : 		// make sure that vecOrigin can trace to this node!
; 825  : 		UTIL_TraceLine ( vecOrigin, m_pNodes[ iNode ].m_vecOriginPeek, ignore_monsters, 0, &tr );

	lea	edx, DWORD PTR _tr$37487[ebp]
	push	edx
	push	0
	push	1
	mov	eax, DWORD PTR _iNode$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax+12]
	push	eax
	lea	ecx, DWORD PTR _vecOrigin$[ebp]
	push	ecx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 826  : 
; 827  : 		if ( tr.flFraction == 1.0 )

	fld	DWORD PTR _tr$37487[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	$L37488

; 829  : 			m_iNearest = iNode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iNode$[ebp]
	mov	DWORD PTR [edx+6188], eax

; 830  : 			m_flShortest = flDist;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _flDist$[ebp]
	mov	DWORD PTR [ecx+6184], edx

; 831  : 
; 832  : 			UpdateRange(m_minX, m_maxX, CALC_RANGE(vecOrigin.x, m_RegionMin[0], m_RegionMax[0]), m_pNodes[iNode].m_Region[0]);

	mov	eax, DWORD PTR _iNode$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+eax+24]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+6256]
	call	__ftol
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+6244]
	call	__ftol
	push	eax
	fld	DWORD PTR _vecOrigin$[ebp]
	call	__ftol
	push	eax
	call	?CALC_RANGE@@YAHHHH@Z			; CALC_RANGE
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6204				; 0000183cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 6192				; 00001830H
	push	edx
	call	?UpdateRange@@YAXAAH0HH@Z		; UpdateRange
	add	esp, 16					; 00000010H

; 833  : 			UpdateRange(m_minY, m_maxY, CALC_RANGE(vecOrigin.y, m_RegionMin[1], m_RegionMax[1]), m_pNodes[iNode].m_Region[1]);

	mov	eax, DWORD PTR _iNode$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+eax+25]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+6260]
	call	__ftol
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+6248]
	call	__ftol
	push	eax
	fld	DWORD PTR _vecOrigin$[ebp+4]
	call	__ftol
	push	eax
	call	?CALC_RANGE@@YAHHHH@Z			; CALC_RANGE
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6208				; 00001840H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 6196				; 00001834H
	push	edx
	call	?UpdateRange@@YAXAAH0HH@Z		; UpdateRange
	add	esp, 16					; 00000010H

; 834  : 			UpdateRange(m_minZ, m_maxZ, CALC_RANGE(vecOrigin.z, m_RegionMin[2], m_RegionMax[2]), m_pNodes[iNode].m_Region[2]);

	mov	eax, DWORD PTR _iNode$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+eax+26]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+6264]
	call	__ftol
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+6252]
	call	__ftol
	push	eax
	fld	DWORD PTR _vecOrigin$[ebp+8]
	call	__ftol
	push	eax
	call	?CALC_RANGE@@YAHHHH@Z			; CALC_RANGE
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6212				; 00001844H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 6200				; 00001838H
	push	edx
	call	?UpdateRange@@YAXAAH0HH@Z		; UpdateRange
	add	esp, 16					; 00000010H

; 835  : 
; 836  : 			// From maxCircle, calculate maximum bounds box. All points must be
; 837  : 			// simultaneously inside all bounds of the box.
; 838  : 			//
; 839  : 			m_minBoxX = CALC_RANGE(vecOrigin.x - flDist, m_RegionMin[0], m_RegionMax[0]);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+6256]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+6244]
	call	__ftol
	push	eax
	fld	DWORD PTR _vecOrigin$[ebp]
	fsub	DWORD PTR _flDist$[ebp]
	call	__ftol
	push	eax
	call	?CALC_RANGE@@YAHHHH@Z			; CALC_RANGE
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+6216], eax

; 840  : 			m_maxBoxX = CALC_RANGE(vecOrigin.x + flDist, m_RegionMin[0], m_RegionMax[0]);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+6256]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+6244]
	call	__ftol
	push	eax
	fld	DWORD PTR _vecOrigin$[ebp]
	fadd	DWORD PTR _flDist$[ebp]
	call	__ftol
	push	eax
	call	?CALC_RANGE@@YAHHHH@Z			; CALC_RANGE
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+6228], eax

; 841  : 			m_minBoxY = CALC_RANGE(vecOrigin.y - flDist, m_RegionMin[1], m_RegionMax[1]);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+6260]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+6248]
	call	__ftol
	push	eax
	fld	DWORD PTR _vecOrigin$[ebp+4]
	fsub	DWORD PTR _flDist$[ebp]
	call	__ftol
	push	eax
	call	?CALC_RANGE@@YAHHHH@Z			; CALC_RANGE
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+6220], eax

; 842  : 			m_maxBoxY = CALC_RANGE(vecOrigin.y + flDist, m_RegionMin[1], m_RegionMax[1]);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+6260]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+6248]
	call	__ftol
	push	eax
	fld	DWORD PTR _vecOrigin$[ebp+4]
	fadd	DWORD PTR _flDist$[ebp]
	call	__ftol
	push	eax
	call	?CALC_RANGE@@YAHHHH@Z			; CALC_RANGE
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+6232], eax

; 843  : 			m_minBoxZ = CALC_RANGE(vecOrigin.z - flDist, m_RegionMin[2], m_RegionMax[2]);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+6264]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+6252]
	call	__ftol
	push	eax
	fld	DWORD PTR _vecOrigin$[ebp+8]
	fsub	DWORD PTR _flDist$[ebp]
	call	__ftol
	push	eax
	call	?CALC_RANGE@@YAHHHH@Z			; CALC_RANGE
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+6224], eax

; 844  : 			m_maxBoxZ = CALC_RANGE(vecOrigin.z + flDist, m_RegionMin[2], m_RegionMax[2]);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+6264]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+6252]
	call	__ftol
	push	eax
	fld	DWORD PTR _vecOrigin$[ebp+8]
	fadd	DWORD PTR _flDist$[ebp]
	call	__ftol
	push	eax
	call	?CALC_RANGE@@YAHHHH@Z			; CALC_RANGE
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+6236], eax
$L37488:
$L37482:

; 847  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CheckNode@CGraph@@QAEXVVector@@H@Z ENDP		; CGraph::CheckNode
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
$T39942 = -16
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39942[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
EXTRN	_sqrt:NEAR
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
;	COMDAT ?CALC_RANGE@@YAHHHH@Z
_TEXT	SEGMENT
_x$ = 8
_lower$ = 12
_upper$ = 16
?CALC_RANGE@@YAHHHH@Z PROC NEAR				; CALC_RANGE, COMDAT

; 798  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 799  : 	return NUM_RANGES*(x-lower)/((upper-lower+1));

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, DWORD PTR _lower$[ebp]
	shl	eax, 8
	mov	ecx, DWORD PTR _upper$[ebp]
	sub	ecx, DWORD PTR _lower$[ebp]
	add	ecx, 1
	cdq
	idiv	ecx

; 800  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CALC_RANGE@@YAHHHH@Z ENDP				; CALC_RANGE
_TEXT	ENDS
PUBLIC	?CalcBounds@@YAXAAH0HH@Z			; CalcBounds
;	COMDAT ?UpdateRange@@YAXAAH0HH@Z
_TEXT	SEGMENT
_minValue$ = 8
_maxValue$ = 12
_Goal$ = 16
_Best$ = 20
_Lower$ = -4
_Upper$ = -8
?UpdateRange@@YAXAAH0HH@Z PROC NEAR			; UpdateRange, COMDAT

; 804  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 805  :     int Lower, Upper;
; 806  :     CalcBounds(Lower, Upper, Goal, Best);

	mov	eax, DWORD PTR _Best$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Goal$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Upper$[ebp]
	push	edx
	lea	eax, DWORD PTR _Lower$[ebp]
	push	eax
	call	?CalcBounds@@YAXAAH0HH@Z		; CalcBounds
	add	esp, 16					; 00000010H

; 807  :     if (Upper < maxValue) maxValue = Upper;

	mov	ecx, DWORD PTR _maxValue$[ebp]
	mov	edx, DWORD PTR _Upper$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $L37476
	mov	eax, DWORD PTR _maxValue$[ebp]
	mov	ecx, DWORD PTR _Upper$[ebp]
	mov	DWORD PTR [eax], ecx
$L37476:

; 808  :     if (minValue < Lower) minValue = Lower;

	mov	edx, DWORD PTR _minValue$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _Lower$[ebp]
	jge	SHORT $L37477
	mov	ecx, DWORD PTR _minValue$[ebp]
	mov	edx, DWORD PTR _Lower$[ebp]
	mov	DWORD PTR [ecx], edx
$L37477:

; 809  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateRange@@YAXAAH0HH@Z ENDP				; UpdateRange
_TEXT	ENDS
;	COMDAT ?CalcBounds@@YAXAAH0HH@Z
_TEXT	SEGMENT
_Lower$ = 8
_Upper$ = 12
_Goal$ = 16
_Best$ = 20
_Temp$ = -4
?CalcBounds@@YAXAAH0HH@Z PROC NEAR			; CalcBounds, COMDAT

; 781  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 782  :     int Temp = 2*Goal - Best;

	mov	eax, DWORD PTR _Goal$[ebp]
	shl	eax, 1
	sub	eax, DWORD PTR _Best$[ebp]
	mov	DWORD PTR _Temp$[ebp], eax

; 783  :     if (Best > Goal)

	mov	ecx, DWORD PTR _Best$[ebp]
	cmp	ecx, DWORD PTR _Goal$[ebp]
	jle	SHORT $L37461

; 785  :         Lower = Q_max(0, Temp);

	xor	edx, edx
	cmp	DWORD PTR _Temp$[ebp], 0
	setl	dl
	dec	edx
	and	edx, DWORD PTR _Temp$[ebp]
	mov	eax, DWORD PTR _Lower$[ebp]
	mov	DWORD PTR [eax], edx

; 786  :         Upper = Best;

	mov	ecx, DWORD PTR _Upper$[ebp]
	mov	edx, DWORD PTR _Best$[ebp]
	mov	DWORD PTR [ecx], edx

; 788  :     else

	jmp	SHORT $L37462
$L37461:

; 790  :         Upper = Q_min(255, Temp);

	cmp	DWORD PTR _Temp$[ebp], 255		; 000000ffH
	jle	SHORT $L39953
	mov	DWORD PTR -8+[ebp], 255			; 000000ffH
	jmp	SHORT $L39954
$L39953:
	mov	eax, DWORD PTR _Temp$[ebp]
	mov	DWORD PTR -8+[ebp], eax
$L39954:
	mov	ecx, DWORD PTR _Upper$[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR [ecx], edx

; 791  :         Lower = Best;

	mov	eax, DWORD PTR _Lower$[ebp]
	mov	ecx, DWORD PTR _Best$[ebp]
	mov	DWORD PTR [eax], ecx
$L37462:

; 793  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CalcBounds@@YAXAAH0HH@Z ENDP				; CalcBounds
_TEXT	ENDS
PUBLIC	?FindNearestNode@CGraph@@QAEHABVVector@@PAVCBaseEntity@@@Z ; CGraph::FindNearestNode
PUBLIC	?FindNearestNode@CGraph@@QAEHABVVector@@H@Z	; CGraph::FindNearestNode
;	COMDAT ?FindNearestNode@CGraph@@QAEHABVVector@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT
_vecOrigin$ = 8
_pEntity$ = 12
_this$ = -4
?FindNearestNode@CGraph@@QAEHABVVector@@PAVCBaseEntity@@@Z PROC NEAR ; CGraph::FindNearestNode, COMDAT

; 855  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 856  : 	return FindNearestNode( vecOrigin, NodeType( pEntity ) );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NodeType@CGraph@@QAEHPBVCBaseEntity@@@Z ; CGraph::NodeType
	push	eax
	mov	ecx, DWORD PTR _vecOrigin$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindNearestNode@CGraph@@QAEHABVVector@@H@Z ; CGraph::FindNearestNode

; 857  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FindNearestNode@CGraph@@QAEHABVVector@@PAVCBaseEntity@@@Z ENDP ; CGraph::FindNearestNode
_TEXT	ENDS
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	?Hash@@YAKPAXH@Z				; Hash
;	COMDAT ?FindNearestNode@CGraph@@QAEHABVVector@@H@Z
_TEXT	SEGMENT
_vecOrigin$ = 8
_afNodeTypes$ = 12
_this$ = -4
_i$ = -8
_tr$ = -64
_iHash$ = -68
_i$37509 = -72
_halfX$ = -76
_halfY$ = -80
_halfZ$ = -84
_j$ = -88
_rgY$37524 = -92
_rgZ$37527 = -96
_rgZ$37538 = -100
_rgX$37541 = -104
_rgX$37552 = -108
_rgY$37555 = -112
_rgY$37566 = -116
_rgZ$37569 = -120
_rgZ$37580 = -124
_rgX$37583 = -128
_rgX$37594 = -132
_rgY$37597 = -136
?FindNearestNode@CGraph@@QAEHABVVector@@H@Z PROC NEAR	; CGraph::FindNearestNode, COMDAT

; 860  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 861  : 	int	i;
; 862  : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 863  : 
; 864  : 	if ( !m_fGraphPresent || !m_fGraphPointersSet )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L37502
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L37501
$L37502:

; 866  : 		ALERT ( at_aiconsole, "Graph not ready!\n" );

	push	OFFSET FLAT:??_C@_0BC@LJED@Graph?5not?5ready?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 867  : 		return -1;

	or	eax, -1
	jmp	$L37498
$L37501:

; 869  : 
; 870  : 	// Check with the cache
; 871  : 	//
; 872  : 	ULONG iHash = (CACHE_SIZE-1) & Hash((void *)(const float *)vecOrigin, sizeof(vecOrigin));

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _vecOrigin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	?Hash@@YAKPAXH@Z			; Hash
	add	esp, 8
	and	eax, 127				; 0000007fH
	mov	DWORD PTR _iHash$[ebp], eax

; 873  : 	if (m_Cache[iHash].v == vecOrigin)

	mov	edx, DWORD PTR _vecOrigin$[ebp]
	push	edx
	mov	eax, DWORD PTR _iHash$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+6268]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L37506

; 875  : 		//ALERT(at_aiconsole, "Cache Hit.\n");
; 876  : 		return m_Cache[iHash].n;

	mov	edx, DWORD PTR _iHash$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+edx+6280]
	jmp	$L37498
$L37506:

; 882  : 
; 883  : 	// Mark all points as unchecked.
; 884  : 	//
; 885  : 	m_CheckedCounter++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+6240]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+6240], edx

; 886  : 	if (m_CheckedCounter == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+6240], 0
	jne	SHORT $L37508

; 888  : 		for (int i = 0; i < m_cNodes; i++)

	mov	DWORD PTR _i$37509[ebp], 0
	jmp	SHORT $L37510
$L37511:
	mov	edx, DWORD PTR _i$37509[ebp]
	add	edx, 1
	mov	DWORD PTR _i$37509[ebp], edx
$L37510:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$37509[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	SHORT $L37512

; 890  : 			m_di[i].m_CheckedEvent = 0;

	mov	edx, DWORD PTR _i$37509[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+edx+12], 0

; 891  : 		}

	jmp	SHORT $L37511
$L37512:

; 892  : 		m_CheckedCounter++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+6240]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+6240], eax
$L37508:

; 894  : 
; 895  : 	m_iNearest = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+6188], -1

; 896  : 	m_flShortest = 999999.0; // just a big number.

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+6184], 1232348144	; 497423f0H

; 897  : 
; 898  : 	// If we can find a visible point, then let CalcBounds set the limits, but if
; 899  : 	// we have no visible point at all to start with, then don't restrict the limits.
; 900  : 	//
; 901  : #if 1
; 902  : 	m_minX = 0; m_maxX = 255;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+6192], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+6204], 255		; 000000ffH

; 903  : 	m_minY = 0; m_maxY = 255;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+6196], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+6208], 255		; 000000ffH

; 904  : 	m_minZ = 0; m_maxZ = 255;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+6200], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+6212], 255		; 000000ffH

; 905  : 	m_minBoxX = 0; m_maxBoxX = 255;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+6216], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+6228], 255		; 000000ffH

; 906  : 	m_minBoxY = 0; m_maxBoxY = 255;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+6220], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+6232], 255		; 000000ffH

; 907  : 	m_minBoxZ = 0; m_maxBoxZ = 255;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+6224], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+6236], 255		; 000000ffH

; 908  : #else
; 909  : 	m_minBoxX = CALC_RANGE(vecOrigin.x - flDist, m_RegionMin[0], m_RegionMax[0]);
; 910  : 	m_maxBoxX = CALC_RANGE(vecOrigin.x + flDist, m_RegionMin[0], m_RegionMax[0]);
; 911  : 	m_minBoxY = CALC_RANGE(vecOrigin.y - flDist, m_RegionMin[1], m_RegionMax[1]);
; 912  : 	m_maxBoxY = CALC_RANGE(vecOrigin.y + flDist, m_RegionMin[1], m_RegionMax[1]);
; 913  : 	m_minBoxZ = CALC_RANGE(vecOrigin.z - flDist, m_RegionMin[2], m_RegionMax[2]);
; 914  : 	m_maxBoxZ = CALC_RANGE(vecOrigin.z + flDist, m_RegionMin[2], m_RegionMax[2])
; 915  :     CalcBounds(m_minX, m_maxX, CALC_RANGE(vecOrigin.x, m_RegionMin[0], m_RegionMax[0]), m_pNodes[m_iNearest].m_Region[0]);
; 916  :     CalcBounds(m_minY, m_maxY, CALC_RANGE(vecOrigin.y, m_RegionMin[1], m_RegionMax[1]), m_pNodes[m_iNearest].m_Region[1]);
; 917  :     CalcBounds(m_minZ, m_maxZ, CALC_RANGE(vecOrigin.z, m_RegionMin[2], m_RegionMax[2]), m_pNodes[m_iNearest].m_Region[2]);
; 918  : #endif
; 919  : 
; 920  :     int halfX = (m_minX+m_maxX)/2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+6192]
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+6204]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _halfX$[ebp], eax

; 921  :     int halfY = (m_minY+m_maxY)/2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+6196]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+6208]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _halfY$[ebp], eax

; 922  :     int halfZ = (m_minZ+m_maxZ)/2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+6200]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+6212]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _halfZ$[ebp], eax

; 923  : 
; 924  :     int j;
; 925  : 
; 926  :     for (i = halfX; i >= m_minX; i--)

	mov	edx, DWORD PTR _halfX$[ebp]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $L37517
$L37518:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L37517:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+6192]
	jl	$L37519

; 928  :         for (j = m_RangeStart[0][i]; j <= m_RangeEnd[0][i]; j++)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+40]
	mov	DWORD PTR _j$[ebp], edx
	jmp	SHORT $L37520
$L37521:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L37520:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+ecx*4+3112]
	jg	$L37522

; 930  : 			if (!(m_pNodes[m_di[j].m_SortedBy[0]].m_afNodeInfo & afNodeTypes)) continue;

	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx+28]
	and	ecx, DWORD PTR _afNodeTypes$[ebp]
	test	ecx, ecx
	jne	SHORT $L37523
	jmp	SHORT $L37521
$L37523:

; 931  : 
; 932  : 			int rgY = m_pNodes[m_di[j].m_SortedBy[0]].m_Region[1];

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+edx+25]
	mov	DWORD PTR _rgY$37524[ebp], eax

; 933  : 			if (rgY > m_maxBoxY) break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgY$37524[ebp]
	cmp	edx, DWORD PTR [ecx+6232]
	jle	SHORT $L37525
	jmp	$L37522
$L37525:

; 934  :             if (rgY < m_minBoxY) continue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgY$37524[ebp]
	cmp	ecx, DWORD PTR [eax+6220]
	jge	SHORT $L37526
	jmp	$L37521
$L37526:

; 935  : 
; 936  : 			int rgZ = m_pNodes[m_di[j].m_SortedBy[0]].m_Region[2];

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+edx+26]
	mov	DWORD PTR _rgZ$37527[ebp], eax

; 937  :             if (rgZ < m_minBoxZ) continue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgZ$37527[ebp]
	cmp	edx, DWORD PTR [ecx+6224]
	jge	SHORT $L37528
	jmp	$L37521
$L37528:

; 938  :             if (rgZ > m_maxBoxZ) continue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgZ$37527[ebp]
	cmp	ecx, DWORD PTR [eax+6236]
	jle	SHORT $L37529
	jmp	$L37521
$L37529:

; 939  :             CheckNode(vecOrigin, m_di[j].m_SortedBy[0]);

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	eax, DWORD PTR _vecOrigin$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckNode@CGraph@@QAEXVVector@@H@Z	; CGraph::CheckNode

; 940  :         }

	jmp	$L37521
$L37522:

; 941  :     }

	jmp	$L37518
$L37519:

; 942  : 
; 943  :     for (i = Q_max(m_minY,halfY+1); i <= m_maxY; i++)

	mov	ecx, DWORD PTR _halfY$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+6196], ecx
	jle	SHORT $L39960
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+6196]
	mov	DWORD PTR -164+[ebp], ecx
	jmp	SHORT $L39961
$L39960:
	mov	edx, DWORD PTR _halfY$[ebp]
	add	edx, 1
	mov	DWORD PTR -164+[ebp], edx
$L39961:
	mov	eax, DWORD PTR -164+[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L37531
$L37532:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L37531:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+6208]
	jg	$L37533

; 945  :         for (j = m_RangeStart[1][i]; j <= m_RangeEnd[1][i]; j++)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1064]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L37534
$L37535:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L37534:
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4+4136]
	jg	$L37536

; 947  : 			if (!(m_pNodes[m_di[j].m_SortedBy[1]].m_afNodeInfo & afNodeTypes)) continue;

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx+4]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx+28]
	and	edx, DWORD PTR _afNodeTypes$[ebp]
	test	edx, edx
	jne	SHORT $L37537
	jmp	SHORT $L37535
$L37537:

; 948  : 
; 949  : 			int rgZ = m_pNodes[m_di[j].m_SortedBy[1]].m_Region[2];

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax+4]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+eax+26]
	mov	DWORD PTR _rgZ$37538[ebp], ecx

; 950  :             if (rgZ > m_maxBoxZ) break;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rgZ$37538[ebp]
	cmp	eax, DWORD PTR [edx+6236]
	jle	SHORT $L37539
	jmp	$L37536
$L37539:

; 951  :             if (rgZ < m_minBoxZ) continue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgZ$37538[ebp]
	cmp	edx, DWORD PTR [ecx+6224]
	jge	SHORT $L37540
	jmp	$L37535
$L37540:

; 952  : 			int rgX = m_pNodes[m_di[j].m_SortedBy[1]].m_Region[0];

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax+4]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+eax+24]
	mov	DWORD PTR _rgX$37541[ebp], ecx

; 953  :             if (rgX < m_minBoxX) continue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rgX$37541[ebp]
	cmp	eax, DWORD PTR [edx+6216]
	jge	SHORT $L37542
	jmp	$L37535
$L37542:

; 954  :             if (rgX > m_maxBoxX) continue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgX$37541[ebp]
	cmp	edx, DWORD PTR [ecx+6228]
	jle	SHORT $L37543
	jmp	$L37535
$L37543:

; 955  :             CheckNode(vecOrigin, m_di[j].m_SortedBy[1]);

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax+4]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR _vecOrigin$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckNode@CGraph@@QAEXVVector@@H@Z	; CGraph::CheckNode

; 956  :         }

	jmp	$L37535
$L37536:

; 957  :     }

	jmp	$L37532
$L37533:

; 958  : 
; 959  :     for (i = Q_min(m_maxZ,halfZ); i >= m_minZ; i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+6212]
	cmp	ecx, DWORD PTR _halfZ$[ebp]
	jge	SHORT $L39963
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+6212]
	mov	DWORD PTR -168+[ebp], eax
	jmp	SHORT $L39964
$L39963:
	mov	ecx, DWORD PTR _halfZ$[ebp]
	mov	DWORD PTR -168+[ebp], ecx
$L39964:
	mov	edx, DWORD PTR -168+[ebp]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $L37545
$L37546:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L37545:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+6200]
	jl	$L37547

; 961  :         for (j = m_RangeStart[2][i]; j <= m_RangeEnd[2][i]; j++)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2088]
	mov	DWORD PTR _j$[ebp], edx
	jmp	SHORT $L37548
$L37549:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L37548:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+ecx*4+5160]
	jg	$L37550

; 963  : 			if (!(m_pNodes[m_di[j].m_SortedBy[2]].m_afNodeInfo & afNodeTypes)) continue;

	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx+8]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx+28]
	and	ecx, DWORD PTR _afNodeTypes$[ebp]
	test	ecx, ecx
	jne	SHORT $L37551
	jmp	SHORT $L37549
$L37551:

; 964  : 
; 965  : 			int rgX = m_pNodes[m_di[j].m_SortedBy[2]].m_Region[0];

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx+8]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+edx+24]
	mov	DWORD PTR _rgX$37552[ebp], eax

; 966  :             if (rgX > m_maxBoxX) break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgX$37552[ebp]
	cmp	edx, DWORD PTR [ecx+6228]
	jle	SHORT $L37553
	jmp	$L37550
$L37553:

; 967  :             if (rgX < m_minBoxX) continue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgX$37552[ebp]
	cmp	ecx, DWORD PTR [eax+6216]
	jge	SHORT $L37554
	jmp	$L37549
$L37554:

; 968  : 			int rgY = m_pNodes[m_di[j].m_SortedBy[2]].m_Region[1];

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx+8]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+edx+25]
	mov	DWORD PTR _rgY$37555[ebp], eax

; 969  :             if (rgY < m_minBoxY) continue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgY$37555[ebp]
	cmp	edx, DWORD PTR [ecx+6220]
	jge	SHORT $L37556
	jmp	$L37549
$L37556:

; 970  : 			if (rgY > m_maxBoxY) continue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgY$37555[ebp]
	cmp	ecx, DWORD PTR [eax+6232]
	jle	SHORT $L37557
	jmp	$L37549
$L37557:

; 971  :             CheckNode(vecOrigin, m_di[j].m_SortedBy[2]);

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx+8]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	eax, DWORD PTR _vecOrigin$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckNode@CGraph@@QAEXVVector@@H@Z	; CGraph::CheckNode

; 972  :         }

	jmp	$L37549
$L37550:

; 973  :     }

	jmp	$L37546
$L37547:

; 974  : 
; 975  :     for (i = Q_max(m_minX,halfX+1); i <= m_maxX; i++)

	mov	ecx, DWORD PTR _halfX$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+6192], ecx
	jle	SHORT $L39966
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+6192]
	mov	DWORD PTR -172+[ebp], ecx
	jmp	SHORT $L39967
$L39966:
	mov	edx, DWORD PTR _halfX$[ebp]
	add	edx, 1
	mov	DWORD PTR -172+[ebp], edx
$L39967:
	mov	eax, DWORD PTR -172+[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L37559
$L37560:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L37559:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+6204]
	jg	$L37561

; 977  :         for (j = m_RangeStart[0][i]; j <= m_RangeEnd[0][i]; j++)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+40]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L37562
$L37563:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L37562:
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4+3112]
	jg	$L37564

; 979  : 			if (!(m_pNodes[m_di[j].m_SortedBy[0]].m_afNodeInfo & afNodeTypes)) continue;

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx+28]
	and	edx, DWORD PTR _afNodeTypes$[ebp]
	test	edx, edx
	jne	SHORT $L37565
	jmp	SHORT $L37563
$L37565:

; 980  : 
; 981  : 			int rgY = m_pNodes[m_di[j].m_SortedBy[0]].m_Region[1];

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+eax+25]
	mov	DWORD PTR _rgY$37566[ebp], ecx

; 982  : 			if (rgY > m_maxBoxY) break;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rgY$37566[ebp]
	cmp	eax, DWORD PTR [edx+6232]
	jle	SHORT $L37567
	jmp	$L37564
$L37567:

; 983  :             if (rgY < m_minBoxY) continue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgY$37566[ebp]
	cmp	edx, DWORD PTR [ecx+6220]
	jge	SHORT $L37568
	jmp	$L37563
$L37568:

; 984  : 
; 985  : 			int rgZ = m_pNodes[m_di[j].m_SortedBy[0]].m_Region[2];

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+eax+26]
	mov	DWORD PTR _rgZ$37569[ebp], ecx

; 986  :             if (rgZ < m_minBoxZ) continue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rgZ$37569[ebp]
	cmp	eax, DWORD PTR [edx+6224]
	jge	SHORT $L37570
	jmp	$L37563
$L37570:

; 987  :             if (rgZ > m_maxBoxZ) continue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgZ$37569[ebp]
	cmp	edx, DWORD PTR [ecx+6236]
	jle	SHORT $L37571
	jmp	$L37563
$L37571:

; 988  :             CheckNode(vecOrigin, m_di[j].m_SortedBy[0]);

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR _vecOrigin$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckNode@CGraph@@QAEXVVector@@H@Z	; CGraph::CheckNode

; 989  :         }

	jmp	$L37563
$L37564:

; 990  :     }

	jmp	$L37560
$L37561:

; 991  : 
; 992  :     for (i = Q_min(m_maxY,halfY); i >= m_minY; i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+6208]
	cmp	ecx, DWORD PTR _halfY$[ebp]
	jge	SHORT $L39969
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+6208]
	mov	DWORD PTR -176+[ebp], eax
	jmp	SHORT $L39970
$L39969:
	mov	ecx, DWORD PTR _halfY$[ebp]
	mov	DWORD PTR -176+[ebp], ecx
$L39970:
	mov	edx, DWORD PTR -176+[ebp]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $L37573
$L37574:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L37573:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+6196]
	jl	$L37575

; 994  :         for (j = m_RangeStart[1][i]; j <= m_RangeEnd[1][i]; j++)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+1064]
	mov	DWORD PTR _j$[ebp], edx
	jmp	SHORT $L37576
$L37577:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L37576:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+ecx*4+4136]
	jg	$L37578

; 996  : 			if (!(m_pNodes[m_di[j].m_SortedBy[1]].m_afNodeInfo & afNodeTypes)) continue;

	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx+4]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx+28]
	and	ecx, DWORD PTR _afNodeTypes$[ebp]
	test	ecx, ecx
	jne	SHORT $L37579
	jmp	SHORT $L37577
$L37579:

; 997  : 
; 998  : 			int rgZ = m_pNodes[m_di[j].m_SortedBy[1]].m_Region[2];

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx+4]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+edx+26]
	mov	DWORD PTR _rgZ$37580[ebp], eax

; 999  :             if (rgZ > m_maxBoxZ) break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgZ$37580[ebp]
	cmp	edx, DWORD PTR [ecx+6236]
	jle	SHORT $L37581
	jmp	$L37578
$L37581:

; 1000 :             if (rgZ < m_minBoxZ) continue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgZ$37580[ebp]
	cmp	ecx, DWORD PTR [eax+6224]
	jge	SHORT $L37582
	jmp	$L37577
$L37582:

; 1001 : 			int rgX = m_pNodes[m_di[j].m_SortedBy[1]].m_Region[0];

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx+4]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+edx+24]
	mov	DWORD PTR _rgX$37583[ebp], eax

; 1002 :             if (rgX < m_minBoxX) continue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgX$37583[ebp]
	cmp	edx, DWORD PTR [ecx+6216]
	jge	SHORT $L37584
	jmp	$L37577
$L37584:

; 1003 :             if (rgX > m_maxBoxX) continue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgX$37583[ebp]
	cmp	ecx, DWORD PTR [eax+6228]
	jle	SHORT $L37585
	jmp	$L37577
$L37585:

; 1004 :             CheckNode(vecOrigin, m_di[j].m_SortedBy[1]);

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx+4]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	eax, DWORD PTR _vecOrigin$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckNode@CGraph@@QAEXVVector@@H@Z	; CGraph::CheckNode

; 1005 :         }

	jmp	$L37577
$L37578:

; 1006 :     }

	jmp	$L37574
$L37575:

; 1007 : 
; 1008 :     for (i = Q_max(m_minZ,halfZ+1); i <= m_maxZ; i++)

	mov	ecx, DWORD PTR _halfZ$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+6200], ecx
	jle	SHORT $L39972
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+6200]
	mov	DWORD PTR -180+[ebp], ecx
	jmp	SHORT $L39973
$L39972:
	mov	edx, DWORD PTR _halfZ$[ebp]
	add	edx, 1
	mov	DWORD PTR -180+[ebp], edx
$L39973:
	mov	eax, DWORD PTR -180+[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L37587
$L37588:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L37587:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+6212]
	jg	$L37589

; 1010 :         for (j = m_RangeStart[2][i]; j <= m_RangeEnd[2][i]; j++)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+2088]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L37590
$L37591:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L37590:
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4+5160]
	jg	$L37592

; 1012 : 			if (!(m_pNodes[m_di[j].m_SortedBy[2]].m_afNodeInfo & afNodeTypes)) continue;

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx+8]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx+28]
	and	edx, DWORD PTR _afNodeTypes$[ebp]
	test	edx, edx
	jne	SHORT $L37593
	jmp	SHORT $L37591
$L37593:

; 1013 : 
; 1014 : 			int rgX = m_pNodes[m_di[j].m_SortedBy[2]].m_Region[0];

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax+8]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+eax+24]
	mov	DWORD PTR _rgX$37594[ebp], ecx

; 1015 :             if (rgX > m_maxBoxX) break;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rgX$37594[ebp]
	cmp	eax, DWORD PTR [edx+6228]
	jle	SHORT $L37595
	jmp	$L37592
$L37595:

; 1016 :             if (rgX < m_minBoxX) continue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgX$37594[ebp]
	cmp	edx, DWORD PTR [ecx+6216]
	jge	SHORT $L37596
	jmp	$L37591
$L37596:

; 1017 : 			int rgY = m_pNodes[m_di[j].m_SortedBy[2]].m_Region[1];

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax+8]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+eax+25]
	mov	DWORD PTR _rgY$37597[ebp], ecx

; 1018 :             if (rgY < m_minBoxY) continue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rgY$37597[ebp]
	cmp	eax, DWORD PTR [edx+6220]
	jge	SHORT $L37598
	jmp	$L37591
$L37598:

; 1019 : 			if (rgY > m_maxBoxY) continue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgY$37597[ebp]
	cmp	edx, DWORD PTR [ecx+6232]
	jle	SHORT $L37599
	jmp	$L37591
$L37599:

; 1020 :             CheckNode(vecOrigin, m_di[j].m_SortedBy[2]);

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax+8]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR _vecOrigin$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckNode@CGraph@@QAEXVVector@@H@Z	; CGraph::CheckNode

; 1021 :         }

	jmp	$L37591
$L37592:

; 1022 :     }

	jmp	$L37588
$L37589:

; 1023 : 
; 1024 : #if 0
; 1025 : 	// Verify our answers.
; 1026 : 	//
; 1027 : 	int iNearestCheck = -1;
; 1028 : 	m_flShortest = 8192;// find nodes within this radius
; 1029 : 
; 1030 : 	for ( i = 0 ; i < m_cNodes ; i++ )
; 1031 : 	{
; 1032 : 		float flDist = ( vecOrigin - m_pNodes[ i ].m_vecOriginPeek ).Length();
; 1033 : 
; 1034 : 		if ( flDist < m_flShortest )
; 1035 : 		{
; 1036 : 			// make sure that vecOrigin can trace to this node!
; 1037 : 			UTIL_TraceLine ( vecOrigin, m_pNodes[ i ].m_vecOriginPeek, ignore_monsters, 0, &tr );
; 1038 : 
; 1039 : 			if ( tr.flFraction == 1.0 )
; 1040 : 			{
; 1041 : 				iNearestCheck = i;
; 1042 : 				m_flShortest = flDist;
; 1043 : 			}
; 1044 : 		}
; 1045 : 	}
; 1046 : 
; 1047 : 	if (iNearestCheck != m_iNearest)
; 1048 : 	{
; 1049 : 		ALERT( at_aiconsole, "NOT closest %d(%f,%f,%f) %d(%f,%f,%f).\n",
; 1050 : 			iNearestCheck,
; 1051 : 			m_pNodes[iNearestCheck].m_vecOriginPeek.x,
; 1052 : 			m_pNodes[iNearestCheck].m_vecOriginPeek.y,
; 1053 : 			m_pNodes[iNearestCheck].m_vecOriginPeek.z,
; 1054 : 			m_iNearest,
; 1055 : 			(m_iNearest == -1?0.0:m_pNodes[m_iNearest].m_vecOriginPeek.x),
; 1056 : 			(m_iNearest == -1?0.0:m_pNodes[m_iNearest].m_vecOriginPeek.y),
; 1057 : 			(m_iNearest == -1?0.0:m_pNodes[m_iNearest].m_vecOriginPeek.z));
; 1058 : 	}
; 1059 : 	if (m_iNearest == -1)
; 1060 : 	{
; 1061 : 		ALERT(at_aiconsole, "All that work for nothing.\n");
; 1062 : 	}
; 1063 : #endif
; 1064 : 	m_Cache[iHash].v = vecOrigin;

	mov	eax, DWORD PTR _vecOrigin$[ebp]
	mov	ecx, DWORD PTR _iHash$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+6268]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1065 : 	m_Cache[iHash].n = m_iNearest;

	mov	ecx, DWORD PTR _iHash$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+6188]
	mov	WORD PTR [edx+ecx+6280], ax

; 1066 : 	return m_iNearest;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+6188]
$L37498:

; 1067 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FindNearestNode@CGraph@@QAEHABVVector@@H@Z ENDP	; CGraph::FindNearestNode
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QBEPBMXZ PROC NEAR				; Vector::operator float const *, COMDAT

; 229  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
;	COMDAT ?Hash@@YAKPAXH@Z
_TEXT	SEGMENT
_p$ = 8
_len$ = 12
_ulCrc$ = -4
?Hash@@YAKPAXH@Z PROC NEAR				; Hash, COMDAT

; 773  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 774  : 	CRC32_t ulCrc;
; 775  : 	CRC32_INIT(&ulCrc);

	lea	eax, DWORD PTR _ulCrc$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+344
	add	esp, 4

; 776  : 	CRC32_PROCESS_BUFFER(&ulCrc, p, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	lea	eax, DWORD PTR _ulCrc$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+348
	add	esp, 12					; 0000000cH

; 777  : 	return CRC32_FINAL(ulCrc);

	mov	ecx, DWORD PTR _ulCrc$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+356
	add	esp, 4

; 778  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Hash@@YAKPAXH@Z ENDP					; Hash
_TEXT	ENDS
PUBLIC	__real@4@40028000000000000000
PUBLIC	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z		; MESSAGE_BEGIN
PUBLIC	??_C@_0CE@LACO@Can?8t?5show?5connections?5for?5node?5@ ; `string'
PUBLIC	??_C@_0BD@NOPM@?$CK?$CKNo?5Connections?$CB?6?$AA@ ; `string'
PUBLIC	?ShowNodeConnections@CGraph@@QAEXH@Z		; CGraph::ShowNodeConnections
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	?UTIL_ParticleEffect@@YAXABVVector@@0KK@Z:NEAR	; UTIL_ParticleEffect
;	COMDAT ??_C@_0CE@LACO@Can?8t?5show?5connections?5for?5node?5@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0CE@LACO@Can?8t?5show?5connections?5for?5node?5@ DB 'Can''t show co'
	DB	'nnections for node %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NOPM@?$CK?$CKNo?5Connections?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BD@NOPM@?$CK?$CKNo?5Connections?$CB?6?$AA@ DB '**No Connections!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __real@4@40028000000000000000
CONST	SEGMENT
__real@4@40028000000000000000 DD 041000000r	; 8
CONST	ENDS
;	COMDAT ?ShowNodeConnections@CGraph@@QAEXH@Z
_TEXT	SEGMENT
_iNode$ = 8
_this$ = -4
_vecSpot$ = -16
_pNode$ = -20
_pLinkNode$ = -24
_i$ = -28
?ShowNodeConnections@CGraph@@QAEXH@Z PROC NEAR		; CGraph::ShowNodeConnections, COMDAT

; 1074 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1075 : 	Vector	vecSpot;

	lea	ecx, DWORD PTR _vecSpot$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1076 : 	CNode	*pNode;
; 1077 : 	CNode	*pLinkNode;
; 1078 : 	int	i;
; 1079 : 
; 1080 : 	if ( !m_fGraphPresent || !m_fGraphPointersSet )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L37610
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L37609
$L37610:

; 1082 : 		ALERT ( at_aiconsole, "Graph not ready!\n" );

	push	OFFSET FLAT:??_C@_0BC@LJED@Graph?5not?5ready?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1083 : 		return;

	jmp	$L37604
$L37609:

; 1085 : 
; 1086 : 	if ( iNode < 0 )

	cmp	DWORD PTR _iNode$[ebp], 0
	jge	SHORT $L37611

; 1088 : 		ALERT( at_aiconsole, "Can't show connections for node %d\n", iNode );

	mov	edx, DWORD PTR _iNode$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CE@LACO@Can?8t?5show?5connections?5for?5node?5@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1089 : 		return;

	jmp	$L37604
$L37611:

; 1091 : 
; 1092 : 	pNode = &m_pNodes[ iNode ];

	mov	eax, DWORD PTR _iNode$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	DWORD PTR _pNode$[ebp], edx

; 1093 : 
; 1094 : 	UTIL_ParticleEffect( pNode->m_vecOrigin, g_vecZero, 255, 20 );// show node position

	push	20					; 00000014H
	push	255					; 000000ffH
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _pNode$[ebp]
	push	eax
	call	?UTIL_ParticleEffect@@YAXABVVector@@0KK@Z ; UTIL_ParticleEffect
	add	esp, 16					; 00000010H

; 1095 : 	
; 1096 : 	if ( pNode->m_cNumLinks <= 0 )

	mov	ecx, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	jg	SHORT $L37613

; 1098 : 		ALERT ( at_aiconsole, "**No Connections!\n" );

	push	OFFSET FLAT:??_C@_0BD@NOPM@?$CK?$CKNo?5Connections?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L37613:

; 1100 : 
; 1101 : 	for ( i = 0 ; i < pNode->m_cNumLinks ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L37615
$L37616:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L37615:
	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	$L37617

; 1103 : 		
; 1104 : 		pLinkNode = &Node( NodeLink( iNode, i).m_iDestNode );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _iNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NodeLink@CGraph@@QAEAAVCLink@@HH@Z	; CGraph::NodeLink
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Node@CGraph@@QAEAAVCNode@@H@Z		; CGraph::Node
	mov	DWORD PTR _pLinkNode$[ebp], eax

; 1105 : 		vecSpot = pLinkNode->m_vecOrigin;

	mov	edx, DWORD PTR _pLinkNode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _vecSpot$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _vecSpot$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _vecSpot$[ebp+8], edx

; 1106 : 
; 1107 : 		MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );

	push	0
	push	0
	push	23					; 00000017H
	push	0
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1108 : 			WRITE_BYTE( TE_SHOWLINE);

	push	102					; 00000066H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1109 : 			
; 1110 : 			WRITE_COORD( m_pNodes[ iNode ].m_vecOrigin.x );

	mov	eax, DWORD PTR _iNode$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1111 : 			WRITE_COORD( m_pNodes[ iNode ].m_vecOrigin.y );

	mov	ecx, DWORD PTR _iNode$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1112 : 			WRITE_COORD( m_pNodes[ iNode ].m_vecOrigin.z + NODE_HEIGHT );

	mov	edx, DWORD PTR _iNode$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	fld	DWORD PTR [ecx+edx+8]
	fadd	DWORD PTR __real@4@40028000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1113 : 
; 1114 : 			WRITE_COORD( vecSpot.x );

	mov	edx, DWORD PTR _vecSpot$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1115 : 			WRITE_COORD( vecSpot.y );

	mov	eax, DWORD PTR _vecSpot$[ebp+4]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1116 : 			WRITE_COORD( vecSpot.z + NODE_HEIGHT );

	fld	DWORD PTR _vecSpot$[ebp+8]
	fadd	DWORD PTR __real@4@40028000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1117 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 1118 : 
; 1119 : 	}

	jmp	$L37616
$L37617:
$L37604:

; 1120 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ShowNodeConnections@CGraph@@QAEXH@Z ENDP		; CGraph::ShowNodeConnections
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_type$ = 12
_pOrigin$ = 16
_ed$ = 20
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z PROC NEAR	; MESSAGE_BEGIN, COMDAT

; 72   : inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin = NULL, edict_t *ed = NULL ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 73   : 	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ed);

	mov	eax, DWORD PTR _ed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+184
	add	esp, 16					; 00000010H

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z ENDP		; MESSAGE_BEGIN
_TEXT	ENDS
PUBLIC	??_C@_0L@JDEK@No?5Nodes?$CB?6?$AA@		; `string'
PUBLIC	??_C@_0CJ@PBCE@?$CK?$CKLinkVisibleNodes?3?6can?8t?5write?5@ ; `string'
PUBLIC	??_C@_0EO@NCEO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_0CI@JHNE@LinkVisibleNodes?5?9?5Initial?5Conne@ ; `string'
PUBLIC	??_C@_0N@JNEM@Node?5?$CD?$CF4d?3?6?6?$AA@	; `string'
PUBLIC	??_C@_03OALE@?$CF4d?$AA@			; `string'
PUBLIC	??_C@_0DA@FCCH@?5?5Entity?5on?5connection?3?5?$CFs?0?5name@ ; `string'
PUBLIC	??_C@_01BJG@?6?$AA@				; `string'
PUBLIC	??_C@_0ED@CBNC@?$CK?$CKLinkVisibleNodes?3?6Node?5?$CFd?5has?5@ ; `string'
PUBLIC	??_C@_0DG@JFJG@?$CK?$CK?5NODE?5?$CFd?5HAS?5NodeLinks?5?$DO?5MAX_N@ ; `string'
PUBLIC	??_C@_0ED@OLC@?$CK?$CKLinkVisibleNodes?3?6TotalLinks?5?$DO@ ; `string'
PUBLIC	??_C@_0BG@IIDG@?$CK?$CKNO?5INITIAL?5LINKS?$CK?$CK?6?$AA@ ; `string'
PUBLIC	??_C@_0EN@KOPM@?6?$CF4d?5Total?5Initial?5Connections?5?9@ ; `string'
PUBLIC	??_C@_0FA@JJGD@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	?LinkVisibleNodes@CGraph@@QAEHPAVCLink@@PAVCVirtualFS@@PAH@Z ; CGraph::LinkVisibleNodes
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
EXTRN	?g_pWorld@@3PAVCBaseEntity@@A:DWORD		; g_pWorld
;	COMDAT ??_C@_0L@JDEK@No?5Nodes?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0L@JDEK@No?5Nodes?$CB?6?$AA@ DB 'No Nodes!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PBCE@?$CK?$CKLinkVisibleNodes?3?6can?8t?5write?5@
CONST	SEGMENT
??_C@_0CJ@PBCE@?$CK?$CKLinkVisibleNodes?3?6can?8t?5write?5@ DB '**LinkVis'
	DB	'ibleNodes:', 0aH, 'can''t write to file.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@NCEO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0EO@NCEO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'-------------------------------------------------------------'
	DB	'--------------', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JHNE@LinkVisibleNodes?5?9?5Initial?5Conne@
CONST	SEGMENT
??_C@_0CI@JHNE@LinkVisibleNodes?5?9?5Initial?5Conne@ DB 'LinkVisibleNodes'
	DB	' - Initial Connections', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JNEM@Node?5?$CD?$CF4d?3?6?6?$AA@
CONST	SEGMENT
??_C@_0N@JNEM@Node?5?$CD?$CF4d?3?6?6?$AA@ DB 'Node #%4d:', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OALE@?$CF4d?$AA@
CONST	SEGMENT
??_C@_03OALE@?$CF4d?$AA@ DB '%4d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FCCH@?5?5Entity?5on?5connection?3?5?$CFs?0?5name@
CONST	SEGMENT
??_C@_0DA@FCCH@?5?5Entity?5on?5connection?3?5?$CFs?0?5name@ DB '  Entity '
	DB	'on connection: %s, name: %s  Model: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT
??_C@_01BJG@?6?$AA@ DB 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@CBNC@?$CK?$CKLinkVisibleNodes?3?6Node?5?$CFd?5has?5@
CONST	SEGMENT
??_C@_0ED@CBNC@?$CK?$CKLinkVisibleNodes?3?6Node?5?$CFd?5has?5@ DB '**Link'
	DB	'VisibleNodes:', 0aH, 'Node %d has NodeLinks > MAX_NODE_INITIA'
	DB	'L_LINKS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JFJG@?$CK?$CK?5NODE?5?$CFd?5HAS?5NodeLinks?5?$DO?5MAX_N@
CONST	SEGMENT
??_C@_0DG@JFJG@?$CK?$CK?5NODE?5?$CFd?5HAS?5NodeLinks?5?$DO?5MAX_N@ DB '**'
	DB	' NODE %d HAS NodeLinks > MAX_NODE_INITIAL_LINKS **', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@OLC@?$CK?$CKLinkVisibleNodes?3?6TotalLinks?5?$DO@
CONST	SEGMENT
??_C@_0ED@OLC@?$CK?$CKLinkVisibleNodes?3?6TotalLinks?5?$DO@ DB '**LinkVis'
	DB	'ibleNodes:', 0aH, 'TotalLinks > MAX_NODE_INITIAL_LINKS * NUMN'
	DB	'ODES', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IIDG@?$CK?$CKNO?5INITIAL?5LINKS?$CK?$CK?6?$AA@
CONST	SEGMENT
??_C@_0BG@IIDG@?$CK?$CKNO?5INITIAL?5LINKS?$CK?$CK?6?$AA@ DB '**NO INITIAL'
	DB	' LINKS**', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@KOPM@?6?$CF4d?5Total?5Initial?5Connections?5?9@
CONST	SEGMENT
??_C@_0EN@KOPM@?6?$CF4d?5Total?5Initial?5Connections?5?9@ DB 0aH, '%4d To'
	DB	'tal Initial Connections - %4d Maximum connections for a singl'
	DB	'e node.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@JJGD@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0FA@JJGD@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'-------------------------------------------------------------'
	DB	'--------------', 0aH, 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?LinkVisibleNodes@CGraph@@QAEHPAVCLink@@PAVCVirtualFS@@PAH@Z
_TEXT	SEGMENT
_pLinkPool$ = 8
_file$ = 12
_piBadNode$ = 16
_this$ = -4
_i$ = -8
_j$ = -12
_z$ = -16
_pTraceEnt$ = -20
_cTotalLinks$ = -24
_cLinksThisNode$ = -28
_cMaxInitialLinks$ = -32
_tr$ = -88
?LinkVisibleNodes@CGraph@@QAEHPAVCLink@@PAVCVirtualFS@@PAH@Z PROC NEAR ; CGraph::LinkVisibleNodes, COMDAT

; 1134 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1135 : 	int		i,j,z;
; 1136 : 	edict_t		*pTraceEnt;
; 1137 : 	int		cTotalLinks, cLinksThisNode, cMaxInitialLinks;
; 1138 : 	TraceResult	tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1139 : 	
; 1140 : 	// !!!BUGBUG - this function returns 0 if there is a problem in the middle of connecting the graph
; 1141 : 	// it also returns 0 if none of the nodes in a level can see each other. piBadNode is ALWAYS read
; 1142 : 	// by BuildNodeGraph() if this function returns a 0, so make sure that it doesn't get some random
; 1143 : 	// number back.
; 1144 : 	*piBadNode = 0;

	mov	eax, DWORD PTR _piBadNode$[ebp]
	mov	DWORD PTR [eax], 0

; 1145 : 
; 1146 : 	if ( m_cNodes <= 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jg	SHORT $L37632

; 1148 : 		ALERT ( at_aiconsole, "No Nodes!\n" );

	push	OFFSET FLAT:??_C@_0L@JDEK@No?5Nodes?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1149 : 		return FALSE;

	xor	eax, eax
	jmp	$L37623
$L37632:

; 1151 : 
; 1152 : 	// if the file pointer is bad, don't blow up, just don't write the
; 1153 : 	// file.
; 1154 : 	if ( !file )

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $L37634

; 1156 : 		ALERT ( at_aiconsole, "**LinkVisibleNodes:\ncan't write to file." );

	push	OFFSET FLAT:??_C@_0CJ@PBCE@?$CK?$CKLinkVisibleNodes?3?6can?8t?5write?5@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1158 : 	else

	jmp	SHORT $L37636
$L37634:

; 1160 : 		file->Printf( "----------------------------------------------------------------------------\n" );

	push	OFFSET FLAT:??_C@_0EO@NCEO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1161 : 		file->Printf( "LinkVisibleNodes - Initial Connections\n" );

	push	OFFSET FLAT:??_C@_0CI@JHNE@LinkVisibleNodes?5?9?5Initial?5Conne@ ; `string'
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1162 : 		file->Printf( "----------------------------------------------------------------------------\n" );

	push	OFFSET FLAT:??_C@_0EO@NCEO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8
$L37636:

; 1164 : 
; 1165 : 	cTotalLinks = 0;// start with no connections

	mov	DWORD PTR _cTotalLinks$[ebp], 0

; 1166 : 	
; 1167 : 	// to keep track of the maximum number of initial links any node had so far.
; 1168 : 	// this lets us keep an eye on MAX_NODE_INITIAL_LINKS to ensure that we are
; 1169 : 	// being generous enough.
; 1170 : 	cMaxInitialLinks = 0;

	mov	DWORD PTR _cMaxInitialLinks$[ebp], 0

; 1171 : 
; 1172 : 	for ( i = 0 ; i < m_cNodes ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L37639
$L37640:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L37639:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	$L37641

; 1174 : 		cLinksThisNode = 0;// reset this count for each node.

	mov	DWORD PTR _cLinksThisNode$[ebp], 0

; 1175 : 
; 1176 : 		if ( file )

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $L37642

; 1178 : 			file->Printf( "Node #%4d:\n\n", i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0N@JNEM@Node?5?$CD?$CF4d?3?6?6?$AA@ ; `string'
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH
$L37642:

; 1180 : 
; 1181 : 		for ( z = 0 ; z < MAX_NODE_INITIAL_LINKS ; z++ )

	mov	DWORD PTR _z$[ebp], 0
	jmp	SHORT $L37644
$L37645:
	mov	ecx, DWORD PTR _z$[ebp]
	add	ecx, 1
	mov	DWORD PTR _z$[ebp], ecx
$L37644:
	cmp	DWORD PTR _z$[ebp], 128			; 00000080H
	jge	SHORT $L37646

; 1183 : 			// clear out the important fields in the link pool for this node
; 1184 : 			pLinkPool [ cTotalLinks + z ].m_iSrcNode = i;// so each link knows which node it originates from

	mov	edx, DWORD PTR _cTotalLinks$[ebp]
	add	edx, DWORD PTR _z$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pLinkPool$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+edx], ecx

; 1185 : 			pLinkPool [ cTotalLinks + z ].m_iDestNode = 0;

	mov	edx, DWORD PTR _cTotalLinks$[ebp]
	add	edx, DWORD PTR _z$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pLinkPool$[ebp]
	mov	DWORD PTR [eax+edx+4], 0

; 1186 : 			pLinkPool [ cTotalLinks + z ].m_pLinkEnt = NULL;

	mov	ecx, DWORD PTR _cTotalLinks$[ebp]
	add	ecx, DWORD PTR _z$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pLinkPool$[ebp]
	mov	DWORD PTR [edx+ecx+8], 0

; 1187 : 		}

	jmp	SHORT $L37645
$L37646:

; 1188 : 
; 1189 : 		m_pNodes [ i ].m_iFirstLink = cTotalLinks;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _cTotalLinks$[ebp]
	mov	DWORD PTR [edx+eax+36], ecx

; 1190 : 
; 1191 : 		// now build a list of every other node that this node can see
; 1192 : 		for ( j = 0 ; j < m_cNodes ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L37647
$L37648:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L37647:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	$L37649

; 1194 : 			if ( j == i )

	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _i$[ebp]
	jne	SHORT $L37650

; 1196 : 				continue;

	jmp	SHORT $L37648
$L37650:

; 1198 : 
; 1199 : #if 0
; 1200 : 			if ( (m_pNodes[ i ].m_afNodeInfo & bits_NODE_WATER) != (m_pNodes[ j ].m_afNodeInfo & bits_NODE_WATER) )
; 1201 : 			{
; 1202 : 				// don't connect water nodes to air nodes or land nodes. It just wouldn't be prudent at this juncture.
; 1203 : 				continue;
; 1204 : 			}
; 1205 : #else
; 1206 : 			if ( (m_pNodes[ i ].m_afNodeInfo & bits_NODE_GROUP_REALM) != (m_pNodes[ j ].m_afNodeInfo & bits_NODE_GROUP_REALM) )

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax+28]
	and	eax, 7
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+ecx+28]
	and	ecx, 7
	cmp	eax, ecx
	je	SHORT $L37651

; 1208 : 				// don't connect air nodes to water nodes to land nodes. It just wouldn't be prudent at this juncture.
; 1209 : 				continue;

	jmp	SHORT $L37648
$L37651:

; 1211 : #endif
; 1212 : 
; 1213 : 			tr.pHit = NULL;// clear every time so we don't get stuck with last trace's hit ent

	mov	DWORD PTR _tr$[ebp+48], 0

; 1214 : 			pTraceEnt = 0;

	mov	DWORD PTR _pTraceEnt$[ebp], 0

; 1215 : 
; 1216 : 			UTIL_TraceLine ( m_pNodes[ i ].m_vecOrigin,
; 1217 : 							 m_pNodes[ j ].m_vecOrigin,
; 1218 : 							 ignore_monsters,
; 1219 : 							 g_pBodyQueueHead,//!!!HACKHACK no real ent to supply here, using a global we don't care about
; 1220 : 							 &tr );

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_pBodyQueueHead@@3PAUedict_s@@A ; g_pBodyQueueHead
	push	eax
	push	1
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, ecx
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 1221 : 			
; 1222 : 			
; 1223 : 			if ( tr.fStartSolid )

	cmp	DWORD PTR _tr$[ebp+4], 0
	je	SHORT $L37652

; 1224 : 				continue;

	jmp	$L37648
$L37652:

; 1225 : 
; 1226 : 			if ( tr.flFraction != 1.0 )

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L37656

; 1228 : 				
; 1229 : 				pTraceEnt = tr.pHit;// store the ent that the trace hit, for comparison

	mov	ecx, DWORD PTR _tr$[ebp+48]
	mov	DWORD PTR _pTraceEnt$[ebp], ecx

; 1230 : 	
; 1231 : 				UTIL_TraceLine ( m_pNodes[ j ].m_vecOrigin,
; 1232 : 								 m_pNodes[ i ].m_vecOrigin,
; 1233 : 								 ignore_monsters,
; 1234 : 								 g_pBodyQueueHead,//!!!HACKHACK no real ent to supply here, using a global we don't care about
; 1235 : 								 &tr );

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_pBodyQueueHead@@3PAUedict_s@@A ; g_pBodyQueueHead
	push	eax
	push	1
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, ecx
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 1236 : 
; 1237 : 				
; 1238 : // there is a solid_bsp ent in the way of these two nodes, so we must record several things about in order to keep
; 1239 : // track of it in the pathfinding code, as well as through save and restore of the node graph. ANY data that is manipulated 
; 1240 : // as part of the process of adding a LINKENT to a connection here must also be done in CGraph::SetGraphPointers, where reloaded
; 1241 : // graphs are prepared for use.
; 1242 : 				if ( tr.pHit == pTraceEnt && tr.pHit != g_pWorld->edict() )

	mov	ecx, DWORD PTR _tr$[ebp+48]
	cmp	ecx, DWORD PTR _pTraceEnt$[ebp]
	jne	$L37654
	mov	ecx, DWORD PTR ?g_pWorld@@3PAVCBaseEntity@@A ; g_pWorld
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	cmp	DWORD PTR _tr$[ebp+48], eax
	je	$L37654

; 1244 : 					// get a pointer
; 1245 : 					pLinkPool [ cTotalLinks ].m_pLinkEnt = VARS( tr.pHit );

	mov	edx, DWORD PTR _tr$[ebp+48]
	push	edx
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	ecx, DWORD PTR _cTotalLinks$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pLinkPool$[ebp]
	mov	DWORD PTR [edx+ecx+8], eax

; 1246 : 
; 1247 : 					// record the modelname, so that we can save/load node trees
; 1248 : 					memcpy( pLinkPool [ cTotalLinks ].m_szLinkEntModelname, STRING( VARS(tr.pHit)->model ), 4 );

	push	4
	mov	eax, DWORD PTR _tr$[ebp+48]
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	ecx, DWORD PTR [eax+184]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _cTotalLinks$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pLinkPool$[ebp]
	lea	ecx, DWORD PTR [eax+edx+12]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1249 : 
; 1250 : 					// set the flag for this ent that indicates that it is attached to the world graph
; 1251 : 					// if this ent is removed from the world, it must also be removed from the connections
; 1252 : 					// that it formerly blocked.
; 1253 : 					if ( !FBitSet( VARS( tr.pHit )->flags, FL_GRAPHED ) )

	mov	edx, DWORD PTR _tr$[ebp+48]
	push	edx
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	eax, DWORD PTR [eax+420]
	and	eax, 65536				; 00010000H
	test	eax, eax
	jne	SHORT $L37655

; 1255 : 						VARS( tr.pHit )->flags += FL_GRAPHED;

	mov	ecx, DWORD PTR _tr$[ebp+48]
	push	ecx
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	add	eax, 420				; 000001a4H
	mov	DWORD PTR -92+[ebp], eax
	mov	edx, DWORD PTR -92+[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 65536				; 00010000H
	mov	ecx, DWORD PTR -92+[ebp]
	mov	DWORD PTR [ecx], eax
$L37655:

; 1258 : 				else

	jmp	SHORT $L37656
$L37654:

; 1260 : 					continue;

	jmp	$L37648
$L37656:

; 1263 : 
; 1264 : 			if ( file )

	cmp	DWORD PTR _file$[ebp], 0
	je	$L37657

; 1266 : 				file->Printf( "%4d", j );

	mov	edx, DWORD PTR _j$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_03OALE@?$CF4d?$AA@	; `string'
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 1267 : 
; 1268 : 				if ( !FNullEnt( pLinkPool[ cTotalLinks ].m_pLinkEnt ) )

	mov	ecx, DWORD PTR _cTotalLinks$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pLinkPool$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L37659

; 1270 : 					// record info about the ent in the way, if any.
; 1271 : 					file->Printf( "  Entity on connection: %s, name: %s  Model: %s", STRING( VARS( pTraceEnt )->classname ), STRING ( VARS( pTraceEnt )->targetname ), STRING ( VARS(tr.pHit)->model ) );

	mov	ecx, DWORD PTR _tr$[ebp+48]
	push	ecx
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	edx, DWORD PTR [eax+184]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pTraceEnt$[ebp]
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	ecx, DWORD PTR [eax+460]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pTraceEnt$[ebp]
	push	edx
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0DA@FCCH@?5?5Entity?5on?5connection?3?5?$CFs?0?5name@ ; `string'
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 20					; 00000014H
$L37659:

; 1273 : 				
; 1274 : 				file->Printf( "\n", j );

	mov	edx, DWORD PTR _j$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH
$L37657:

; 1276 : 
; 1277 : 			pLinkPool [ cTotalLinks ].m_iDestNode = j;

	mov	ecx, DWORD PTR _cTotalLinks$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pLinkPool$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+ecx+4], eax

; 1278 : 			cLinksThisNode++;

	mov	ecx, DWORD PTR _cLinksThisNode$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cLinksThisNode$[ebp], ecx

; 1279 : 			cTotalLinks++;

	mov	edx, DWORD PTR _cTotalLinks$[ebp]
	add	edx, 1
	mov	DWORD PTR _cTotalLinks$[ebp], edx

; 1280 : 
; 1281 : 			// If we hit this, either a level designer is placing too many nodes in the same area, or 
; 1282 : 			// we need to allow for a larger initial link pool.
; 1283 : 			if ( cLinksThisNode == MAX_NODE_INITIAL_LINKS )

	cmp	DWORD PTR _cLinksThisNode$[ebp], 128	; 00000080H
	jne	SHORT $L37662

; 1285 : 				ALERT ( at_aiconsole, "**LinkVisibleNodes:\nNode %d has NodeLinks > MAX_NODE_INITIAL_LINKS", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0ED@CBNC@?$CK?$CKLinkVisibleNodes?3?6Node?5?$CFd?5has?5@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1286 : 				if( file ) file->Printf( "** NODE %d HAS NodeLinks > MAX_NODE_INITIAL_LINKS **\n", i );

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $L37664
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0DG@JFJG@?$CK?$CK?5NODE?5?$CFd?5HAS?5NodeLinks?5?$DO?5MAX_N@ ; `string'
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH
$L37664:

; 1287 : 				*piBadNode = i;

	mov	eax, DWORD PTR _piBadNode$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax], ecx

; 1288 : 				return	FALSE;

	xor	eax, eax
	jmp	$L37623
$L37662:

; 1290 : 			else if ( cTotalLinks > MAX_NODE_INITIAL_LINKS * m_cNodes )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shl	eax, 7
	cmp	DWORD PTR _cTotalLinks$[ebp], eax
	jle	SHORT $L37667

; 1292 : 				// this is paranoia
; 1293 : 				ALERT ( at_aiconsole, "**LinkVisibleNodes:\nTotalLinks > MAX_NODE_INITIAL_LINKS * NUMNODES" );

	push	OFFSET FLAT:??_C@_0ED@OLC@?$CK?$CKLinkVisibleNodes?3?6TotalLinks?5?$DO@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1294 : 				*piBadNode = i;

	mov	ecx, DWORD PTR _piBadNode$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx], edx

; 1295 : 				return	FALSE;

	xor	eax, eax
	jmp	$L37623
$L37667:

; 1297 : 
; 1298 : 			if ( cLinksThisNode == 0 && file )

	cmp	DWORD PTR _cLinksThisNode$[ebp], 0
	jne	SHORT $L37669
	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $L37669

; 1300 : 				file->Printf( "**NO INITIAL LINKS**\n" );

	push	OFFSET FLAT:??_C@_0BG@IIDG@?$CK?$CKNO?5INITIAL?5LINKS?$CK?$CK?6?$AA@ ; `string'
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8
$L37669:

; 1302 : 
; 1303 : 			// record the connection info in the link pool
; 1304 : 			WorldGraph.m_pNodes [ i ].m_cNumLinks = cLinksThisNode;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	eax, DWORD PTR _cLinksThisNode$[ebp]
	mov	DWORD PTR [edx+ecx+32], eax

; 1305 : 			
; 1306 : 			// keep track of the most initial links ANY node had, so we can figure out
; 1307 : 			// if we have a large enough default link pool
; 1308 : 			if ( cLinksThisNode > cMaxInitialLinks )

	mov	ecx, DWORD PTR _cLinksThisNode$[ebp]
	cmp	ecx, DWORD PTR _cMaxInitialLinks$[ebp]
	jle	SHORT $L37671

; 1310 : 				cMaxInitialLinks = cLinksThisNode;

	mov	edx, DWORD PTR _cLinksThisNode$[ebp]
	mov	DWORD PTR _cMaxInitialLinks$[ebp], edx
$L37671:

; 1312 : 		}

	jmp	$L37648
$L37649:

; 1313 : 		
; 1314 : 
; 1315 : 		if ( file )

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $L37672

; 1317 : 			file->Printf( "----------------------------------------------------------------------------\n" );

	push	OFFSET FLAT:??_C@_0EO@NCEO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8
$L37672:

; 1319 : 	}

	jmp	$L37640
$L37641:

; 1320 : 
; 1321 : 	if ( file )

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $L37673

; 1323 : 		file->Printf( "\n%4d Total Initial Connections - %4d Maximum connections for a single node.\n", cTotalLinks, cMaxInitialLinks );

	mov	ecx, DWORD PTR _cMaxInitialLinks$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cTotalLinks$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0EN@KOPM@?6?$CF4d?5Total?5Initial?5Connections?5?9@ ; `string'
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 16					; 00000010H

; 1324 : 		file->Printf( "----------------------------------------------------------------------------\n\n\n" );

	push	OFFSET FLAT:??_C@_0FA@JJGD@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8
$L37673:

; 1326 : 
; 1327 : 	return cTotalLinks;

	mov	eax, DWORD PTR _cTotalLinks$[ebp]
$L37623:

; 1328 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?LinkVisibleNodes@CGraph@@QAEHPAVCLink@@PAVCVirtualFS@@PAH@Z ENDP ; CGraph::LinkVisibleNodes
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
PUBLIC	?Length@Vector2D@@QBEMXZ			; Vector2D::Length
PUBLIC	?Normalize@Vector2D@@QBE?AV1@XZ			; Vector2D::Normalize
PUBLIC	__real@8@3ffeff7ced916872b000
PUBLIC	?DotProduct@@YAMABVVector2D@@0@Z		; DotProduct
PUBLIC	?Make2D@Vector@@QBE?AVVector2D@@XZ		; Vector::Make2D
PUBLIC	??_C@_0BD@IEJJ@InLine?5Rejection?3?6?$AA@	; `string'
PUBLIC	??_C@_0L@EMKK@Node?5?$CF3d?3?6?$AA@		; `string'
PUBLIC	??_C@_0CP@KPNC@REJECTED?5NODE?5?$CF3d?5through?5Node?5?$CF@ ; `string'
PUBLIC	??_C@_0EP@PFEE@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	?RejectInlineLinks@CGraph@@QAEHPAVCLink@@PAVCVirtualFS@@@Z ; CGraph::RejectInlineLinks
PUBLIC	??0Vector2D@@QAE@XZ				; Vector2D::Vector2D
;	COMDAT ??_C@_0BD@IEJJ@InLine?5Rejection?3?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BD@IEJJ@InLine?5Rejection?3?6?$AA@ DB 'InLine Rejection:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EMKK@Node?5?$CF3d?3?6?$AA@
CONST	SEGMENT
??_C@_0L@EMKK@Node?5?$CF3d?3?6?$AA@ DB 'Node %3d:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@KPNC@REJECTED?5NODE?5?$CF3d?5through?5Node?5?$CF@
CONST	SEGMENT
??_C@_0CP@KPNC@REJECTED?5NODE?5?$CF3d?5through?5Node?5?$CF@ DB 'REJECTED '
	DB	'NODE %3d through Node %3d, Dot = %8f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@PFEE@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0EP@PFEE@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'-------------------------------------------------------------'
	DB	'--------------', 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@8@3ffeff7ced916872b000
CONST	SEGMENT
__real@8@3ffeff7ced916872b000 DQ 03fefef9db22d0e56r ; 0.998
CONST	ENDS
;	COMDAT ?RejectInlineLinks@CGraph@@QAEHPAVCLink@@PAVCVirtualFS@@@Z
_TEXT	SEGMENT
$T39991 = -72
$T39992 = -80
$T39993 = -88
$T39994 = -100
$T39995 = -108
$T39996 = -116
_pLinkPool$ = 8
_file$ = 12
_this$ = -4
_i$ = -8
_j$ = -12
_k$ = -16
_cRejectedLinks$ = -20
_fRestartLoop$ = -24
_pSrcNode$ = -28
_pCheckNode$ = -32
_pTestNode$ = -36
_flDistToTestNode$ = -40
_flDistToCheckNode$ = -44
_vec2DirToTestNode$ = -52
_vec2DirToCheckNode$ = -60
?RejectInlineLinks@CGraph@@QAEHPAVCLink@@PAVCVirtualFS@@@Z PROC NEAR ; CGraph::RejectInlineLinks, COMDAT

; 1337 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1338 : 	int		i,j,k;
; 1339 : 
; 1340 : 	int		cRejectedLinks;
; 1341 : 
; 1342 : 	BOOL	fRestartLoop;// have to restart the J loop if we eliminate a link.
; 1343 : 
; 1344 : 	CNode	*pSrcNode;
; 1345 : 	CNode	*pCheckNode;// the node we are testing for (one of pSrcNode's connections)
; 1346 : 	CNode	*pTestNode;// the node we are checking against ( also one of pSrcNode's connections)
; 1347 : 
; 1348 : 	float	flDistToTestNode, flDistToCheckNode;
; 1349 : 
; 1350 : 	Vector2D	vec2DirToTestNode, vec2DirToCheckNode;

	lea	ecx, DWORD PTR _vec2DirToTestNode$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D
	lea	ecx, DWORD PTR _vec2DirToCheckNode$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 1351 : 
; 1352 : 	if ( file )

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $L37693

; 1354 : 		file->Printf( "----------------------------------------------------------------------------\n" );

	push	OFFSET FLAT:??_C@_0EO@NCEO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1355 : 		file->Printf( "InLine Rejection:\n" );

	push	OFFSET FLAT:??_C@_0BD@IEJJ@InLine?5Rejection?3?6?$AA@ ; `string'
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1356 : 		file->Printf( "----------------------------------------------------------------------------\n" );

	push	OFFSET FLAT:??_C@_0EO@NCEO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8
$L37693:

; 1358 : 
; 1359 : 	cRejectedLinks = 0;

	mov	DWORD PTR _cRejectedLinks$[ebp], 0

; 1360 : 
; 1361 : 	for ( i = 0 ; i < m_cNodes ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L37695
$L37696:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L37695:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$L37697

; 1363 : 		pSrcNode = &m_pNodes[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	DWORD PTR _pSrcNode$[ebp], edx

; 1364 : 
; 1365 : 		if ( file )

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $L37698

; 1367 : 			file->Printf( "Node %3d:\n", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@EMKK@Node?5?$CF3d?3?6?$AA@ ; `string'
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH
$L37698:

; 1369 : 
; 1370 : 		for ( j = 0 ; j < pSrcNode->m_cNumLinks ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L37700
$L37701:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L37700:
	mov	eax, DWORD PTR _pSrcNode$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	$L37702

; 1372 : 			pCheckNode = &m_pNodes[ pLinkPool[ pSrcNode->m_iFirstLink + j ].m_iDestNode ];

	mov	edx, DWORD PTR _pSrcNode$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, DWORD PTR _j$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _pLinkPool$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, edx
	mov	DWORD PTR _pCheckNode$[ebp], ecx

; 1373 : 
; 1374 : 			vec2DirToCheckNode = ( pCheckNode->m_vecOrigin - pSrcNode->m_vecOrigin ).Make2D(); 

	lea	edx, DWORD PTR $T39992[ebp]
	push	edx
	mov	eax, DWORD PTR _pSrcNode$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T39991[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCheckNode$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Make2D@Vector@@QBE?AVVector2D@@XZ	; Vector::Make2D
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _vec2DirToCheckNode$[ebp], edx
	mov	DWORD PTR _vec2DirToCheckNode$[ebp+4], eax

; 1375 : 			flDistToCheckNode = vec2DirToCheckNode.Length();

	lea	ecx, DWORD PTR _vec2DirToCheckNode$[ebp]
	call	?Length@Vector2D@@QBEMXZ		; Vector2D::Length
	fstp	DWORD PTR _flDistToCheckNode$[ebp]

; 1376 : 			vec2DirToCheckNode = vec2DirToCheckNode.Normalize();

	lea	ecx, DWORD PTR $T39993[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vec2DirToCheckNode$[ebp]
	call	?Normalize@Vector2D@@QBE?AV1@XZ		; Vector2D::Normalize
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _vec2DirToCheckNode$[ebp], edx
	mov	DWORD PTR _vec2DirToCheckNode$[ebp+4], eax

; 1377 : 
; 1378 : 			pLinkPool[ pSrcNode->m_iFirstLink + j ].m_flWeight = flDistToCheckNode;

	mov	ecx, DWORD PTR _pSrcNode$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, DWORD PTR _j$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pLinkPool$[ebp]
	mov	ecx, DWORD PTR _flDistToCheckNode$[ebp]
	mov	DWORD PTR [eax+edx+20], ecx

; 1379 : 
; 1380 : 			fRestartLoop = FALSE;

	mov	DWORD PTR _fRestartLoop$[ebp], 0

; 1381 : 			for ( k = 0 ; k < pSrcNode->m_cNumLinks && !fRestartLoop ; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L37706
$L37707:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$L37706:
	mov	eax, DWORD PTR _pSrcNode$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	$L37708
	cmp	DWORD PTR _fRestartLoop$[ebp], 0
	jne	$L37708

; 1383 : 				if ( k == j )

	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _j$[ebp]
	jne	SHORT $L37709

; 1385 : 					// don't check against same node
; 1386 : 					continue;

	jmp	SHORT $L37707
$L37709:

; 1388 : 
; 1389 : 				pTestNode = &m_pNodes [ pLinkPool[ pSrcNode->m_iFirstLink + k ].m_iDestNode ];

	mov	eax, DWORD PTR _pSrcNode$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, DWORD PTR _k$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pLinkPool$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	DWORD PTR _pTestNode$[ebp], edx

; 1390 : 
; 1391 : 				vec2DirToTestNode = ( pTestNode->m_vecOrigin - pSrcNode->m_vecOrigin ).Make2D(); 

	lea	eax, DWORD PTR $T39995[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSrcNode$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T39994[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTestNode$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Make2D@Vector@@QBE?AVVector2D@@XZ	; Vector::Make2D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vec2DirToTestNode$[ebp], ecx
	mov	DWORD PTR _vec2DirToTestNode$[ebp+4], edx

; 1392 : 
; 1393 : 				flDistToTestNode = vec2DirToTestNode.Length();

	lea	ecx, DWORD PTR _vec2DirToTestNode$[ebp]
	call	?Length@Vector2D@@QBEMXZ		; Vector2D::Length
	fstp	DWORD PTR _flDistToTestNode$[ebp]

; 1394 : 				vec2DirToTestNode = vec2DirToTestNode.Normalize();

	lea	eax, DWORD PTR $T39996[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec2DirToTestNode$[ebp]
	call	?Normalize@Vector2D@@QBE?AV1@XZ		; Vector2D::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vec2DirToTestNode$[ebp], ecx
	mov	DWORD PTR _vec2DirToTestNode$[ebp+4], edx

; 1395 : 
; 1396 : 				if ( DotProduct ( vec2DirToCheckNode, vec2DirToTestNode ) >= 0.998 )

	lea	eax, DWORD PTR _vec2DirToTestNode$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec2DirToCheckNode$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector2D@@0@Z	; DotProduct
	add	esp, 8
	fcomp	QWORD PTR __real@8@3ffeff7ced916872b000
	fnstsw	ax
	test	ah, 1
	jne	$L37714

; 1398 : 					// there's a chance that TestNode intersects the line to CheckNode. If so, we should disconnect the link to CheckNode. 
; 1399 : 					if ( flDistToTestNode < flDistToCheckNode )

	fld	DWORD PTR _flDistToTestNode$[ebp]
	fcomp	DWORD PTR _flDistToCheckNode$[ebp]
	fnstsw	ax
	test	ah, 1
	je	$L37714

; 1401 : 						if ( file )

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $L37715

; 1403 : 							file->Printf( "REJECTED NODE %3d through Node %3d, Dot = %8f\n", pLinkPool[ pSrcNode->m_iFirstLink + j ].m_iDestNode, pLinkPool[ pSrcNode->m_iFirstLink + k ].m_iDestNode, DotProduct ( vec2DirToCheckNode, vec2DirToTestNode ) );

	lea	edx, DWORD PTR _vec2DirToTestNode$[ebp]
	push	edx
	lea	eax, DWORD PTR _vec2DirToCheckNode$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector2D@@0@Z	; DotProduct
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _pSrcNode$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, DWORD PTR _k$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pLinkPool$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	mov	edx, DWORD PTR _pSrcNode$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, DWORD PTR _j$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _pLinkPool$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	push	edx
	push	OFFSET FLAT:??_C@_0CP@KPNC@REJECTED?5NODE?5?$CF3d?5through?5Node?5?$CF@ ; `string'
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 24					; 00000018H
$L37715:

; 1405 : 
; 1406 : 						pLinkPool[ pSrcNode->m_iFirstLink + j ] = pLinkPool[ pSrcNode->m_iFirstLink + ( pSrcNode->m_cNumLinks - 1 ) ];

	mov	ecx, DWORD PTR _pSrcNode$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _pSrcNode$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	lea	edx, DWORD PTR [ecx+edx-1]
	imul	edx, 24					; 00000018H
	mov	esi, DWORD PTR _pLinkPool$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR _pSrcNode$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edi, DWORD PTR _pLinkPool$[ebp]
	add	edi, ecx
	mov	ecx, 6
	rep movsd

; 1407 : 						pSrcNode->m_cNumLinks--;

	mov	edx, DWORD PTR _pSrcNode$[ebp]
	mov	eax, DWORD PTR [edx+32]
	sub	eax, 1
	mov	ecx, DWORD PTR _pSrcNode$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 1408 : 						j--;

	mov	edx, DWORD PTR _j$[ebp]
	sub	edx, 1
	mov	DWORD PTR _j$[ebp], edx

; 1409 : 
; 1410 : 						cRejectedLinks++;// keeping track of how many links are cut, so that we can return that value.

	mov	eax, DWORD PTR _cRejectedLinks$[ebp]
	add	eax, 1
	mov	DWORD PTR _cRejectedLinks$[ebp], eax

; 1411 : 
; 1412 : 						fRestartLoop = TRUE;

	mov	DWORD PTR _fRestartLoop$[ebp], 1
$L37714:

; 1415 : 			}

	jmp	$L37707
$L37708:

; 1416 : 		}

	jmp	$L37701
$L37702:

; 1417 : 
; 1418 : 		if ( file )

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $L37717

; 1420 : 			file->Printf( "----------------------------------------------------------------------------\n\n" );

	push	OFFSET FLAT:??_C@_0EP@PFEE@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8
$L37717:

; 1422 : 	}

	jmp	$L37696
$L37697:

; 1423 : 
; 1424 : 	return cRejectedLinks;

	mov	eax, DWORD PTR _cRejectedLinks$[ebp]

; 1425 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?RejectInlineLinks@CGraph@@QAEHPAVCLink@@PAVCVirtualFS@@@Z ENDP ; CGraph::RejectInlineLinks
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector2D@@QAE@XZ PROC NEAR				; Vector2D::Vector2D, COMDAT

; 57   : 	inline Vector2D(void) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector2D@@QAE@XZ ENDP				; Vector2D::Vector2D
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector2D@@QBEMXZ PROC NEAR			; Vector2D::Length, COMDAT

; 101  : 	inline float Length(void) const { return sqrt(x*x + y*y ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector2D@@QBEMXZ ENDP				; Vector2D::Length
_TEXT	ENDS
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	??0Vector2D@@QAE@MM@Z				; Vector2D::Vector2D
;	COMDAT __real@4@3fff8000000000000000
; File z:\xashxtsrc\game_shared\vector.h
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT ?Normalize@Vector2D@@QBE?AV1@XZ
_TEXT	SEGMENT
$T40005 = -24
$T40006 = -32
___$ReturnUdt$ = 8
_this$ = -4
_vec2$ = -12
_flLen$ = -16
?Normalize@Vector2D@@QBE?AV1@XZ PROC NEAR		; Vector2D::Normalize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		Vector2D vec2;

	lea	ecx, DWORD PTR _vec2$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 105  : 
; 106  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector2D@@QBEMXZ		; Vector2D::Length
	fstp	DWORD PTR _flLen$[ebp]

; 107  : 		if ( flLen == 0 )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L24660

; 109  : 			return Vector2D( 0, 0 );

	push	0
	push	0
	lea	ecx, DWORD PTR $T40005[ebp]
	call	??0Vector2D@@QAE@MM@Z			; Vector2D::Vector2D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L24662
$L24660:

; 113  : 			flLen = 1 / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 114  : 			return Vector2D( x * flLen, y * flLen );

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40006[ebp]
	call	??0Vector2D@@QAE@MM@Z			; Vector2D::Vector2D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L24662:

; 116  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector2D@@QBE?AV1@XZ ENDP			; Vector2D::Normalize
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT
_this$ = -4
_X$ = 8
_Y$ = 12
??0Vector2D@@QAE@MM@Z PROC NEAR				; Vector2D::Vector2D, COMDAT

; 58   : 	inline Vector2D(float X, float Y) { x = X; y = Y; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0Vector2D@@QAE@MM@Z ENDP				; Vector2D::Vector2D
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector2D@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProduct@@YAMABVVector2D@@0@Z PROC NEAR		; DotProduct, COMDAT

; 122  : inline float DotProduct(const Vector2D& a, const Vector2D& b) { return( a.x*b.x + a.y*b.y ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector2D@@0@Z ENDP			; DotProduct
_TEXT	ENDS
;	COMDAT ?Make2D@Vector@@QBE?AVVector2D@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_Vec2$ = -12
?Make2D@Vector@@QBE?AVVector2D@@XZ PROC NEAR		; Vector::Make2D, COMDAT

; 275  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 276  : 		Vector2D	Vec2;

	lea	ecx, DWORD PTR _Vec2$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 277  : 		Vec2.x = x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _Vec2$[ebp], ecx

; 278  : 		Vec2.y = y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _Vec2$[ebp+4], eax

; 279  : 		return Vec2;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _Vec2$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _Vec2$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 280  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Make2D@Vector@@QBE?AVVector2D@@XZ ENDP			; Vector::Make2D
_TEXT	ENDS
;	COMDAT _$E31
_TEXT	SEGMENT
_$E31	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E30
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E31	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCTestHull@@@@QAE@PBD@Z	; CEntityFactory<CTestHull>::CEntityFactory<CTestHull>
PUBLIC	??_C@_08EJCJ@testhull?$AA@			; `string'
_BSS	SEGMENT
_testhull DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_08EJCJ@testhull?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_08EJCJ@testhull?$AA@ DB 'testhull', 00H		; `string'
CONST	ENDS
;	COMDAT _$E30
_TEXT	SEGMENT
_$E30	PROC NEAR					; COMDAT

; 1448 : LINK_ENTITY_TO_CLASS( testhull, CTestHull );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_08EJCJ@testhull?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_testhull
	call	??0?$CEntityFactory@VCTestHull@@@@QAE@PBD@Z ; CEntityFactory<CTestHull>::CEntityFactory<CTestHull>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E30	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CTestHull@@UAEPAUdatamap_s@@XZ	; CTestHull::GetDataDescMap
;	COMDAT ?GetDataDescMap@CTestHull@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CTestHull@@UAEPAUdatamap_s@@XZ PROC NEAR ; CTestHull::GetDataDescMap, COMDAT

; 1450 : BEGIN_DATADESC( CTestHull )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CTestHull@@2Udatamap_s@@A ; CTestHull::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CTestHull@@UAEPAUdatamap_s@@XZ ENDP	; CTestHull::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CTestHull@@SAPAUdatamap_s@@XZ	; CTestHull::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CTestHull@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CTestHull@@SAPAUdatamap_s@@XZ PROC NEAR	; CTestHull::GetBaseMap, COMDAT

; 1450 : BEGIN_DATADESC( CTestHull )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CTestHull@@SAPAUdatamap_s@@XZ ENDP		; CTestHull::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E34
_TEXT	SEGMENT
_$E34	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E33
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E34	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z	; DataMapInit
;	COMDAT _$E33
_TEXT	SEGMENT
_$E33	PROC NEAR					; COMDAT

; 1450 : BEGIN_DATADESC( CTestHull )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CTestHull_DataDescInit@@3PAUdatamap_s@@A, eax ; CTestHull_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E33	ENDP
_TEXT	ENDS
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
PUBLIC	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
PUBLIC	?CallBuildNodeGraph@CTestHull@@QAEXXZ		; CTestHull::CallBuildNodeGraph
PUBLIC	?ShowBadNode@CTestHull@@QAEXXZ			; CTestHull::ShowBadNode
PUBLIC	?DropDelay@CTestHull@@QAEXXZ			; CTestHull::DropDelay
PUBLIC	?PathFind@CTestHull@@QAEXXZ			; CTestHull::PathFind
PUBLIC	??_C@_0BD@EDK@CallBuildNodeGraph?$AA@		; `string'
PUBLIC	??_C@_0M@BGNE@ShowBadNode?$AA@			; `string'
PUBLIC	??_C@_09NKNA@DropDelay?$AA@			; `string'
PUBLIC	??_C@_08GCML@PathFind?$AA@			; `string'
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BD@EDK@CallBuildNodeGraph?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BD@EDK@CallBuildNodeGraph?$AA@ DB 'CallBuildNodeGraph', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BGNE@ShowBadNode?$AA@
CONST	SEGMENT
??_C@_0M@BGNE@ShowBadNode?$AA@ DB 'ShowBadNode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NKNA@DropDelay?$AA@
CONST	SEGMENT
??_C@_09NKNA@DropDelay?$AA@ DB 'DropDelay', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GCML@PathFind?$AA@
CONST	SEGMENT
??_C@_08GCML@PathFind?$AA@ DB 'PathFind', 00H		; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z PROC NEAR ; DataMapInit, COMDAT

; 1450 : BEGIN_DATADESC( CTestHull )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L37828
	mov	cl, BYTE PTR _?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_09DCGK@CTestHull?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E37
	call	_atexit
	add	esp, 4
$L37828:
	call	?GetBaseMap@CTestHull@@SAPAUdatamap_s@@XZ ; CTestHull::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CTestHull@@2Udatamap_s@@A+12, eax

; 1451 : 	DEFINE_FUNCTION( CallBuildNodeGraph ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L37832
	mov	al, BYTE PTR _?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_0BD@EDK@CallBuildNodeGraph?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+28, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+32, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+36, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+38, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+40, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+44, OFFSET FLAT:?CallBuildNodeGraph@CTestHull@@QAEXXZ ; CTestHull::CallBuildNodeGraph

; 1452 : 	DEFINE_FUNCTION( ShowBadNode ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+48, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0M@BGNE@ShowBadNode?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+52, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+56, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+60, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+62, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+64, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+68, OFFSET FLAT:?ShowBadNode@CTestHull@@QAEXXZ ; CTestHull::ShowBadNode

; 1453 : 	DEFINE_FUNCTION( DropDelay ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+72, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_09NKNA@DropDelay?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+76, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+80, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+84, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+86, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+88, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+92, OFFSET FLAT:?DropDelay@CTestHull@@QAEXXZ ; CTestHull::DropDelay

; 1454 : 	DEFINE_FUNCTION( PathFind ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+96, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_08GCML@PathFind?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+100, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+104, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+108, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+110, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+112, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+116, OFFSET FLAT:?PathFind@CTestHull@@QAEXXZ ; CTestHull::PathFind
$L37832:

; 1455 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L37845
	mov	DWORD PTR ?m_DataMap@CTestHull@@2Udatamap_s@@A+4, 4
	mov	DWORD PTR ?m_DataMap@CTestHull@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L37846
$L37845:
	mov	DWORD PTR ?m_DataMap@CTestHull@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CTestHull@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4PAUtypedescription_s@@A
$L37846:
	mov	eax, OFFSET FLAT:?m_DataMap@CTestHull@@2Udatamap_s@@A ; CTestHull::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z ENDP	; DataMapInit
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
EXTRN	_strlen:NEAR
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_pszBase$ = 8
_this$ = -4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC NEAR	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
PUBLIC	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
PUBLIC	??_C@_04NHIK@?$CFs?3?3?$AA@			; `string'
EXTRN	_strcat:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
; File z:\xashxtsrc\common\datamap.h
CONST	SEGMENT
??_C@_04NHIK@?$CFs?3?3?$AA@ DB '%s::', 00H		; `string'
CONST	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT
$T40034 = -12
_pszIdentifier$ = 8
_this$ = -4
_pBuf$ = -8
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z PROC NEAR ; CDatadescGeneratedNameHolder::GenerateName, COMDAT

; 205  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		char *pBuf = new char[m_nLenBase + strlen(pszIdentifier) + 1];

	mov	eax, DWORD PTR _pszIdentifier$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax+1]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T40034[ebp], eax
	mov	ecx, DWORD PTR $T40034[ebp]
	mov	DWORD PTR _pBuf$[ebp], ecx

; 207  : 		sprintf( pBuf, "%s::", m_pszBase );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_04NHIK@?$CFs?3?3?$AA@	; `string'
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 208  : 		strcat( pBuf, pszIdentifier );

	mov	edx, DWORD PTR _pszIdentifier$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 209  : 		m_Names.AddToTail( pBuf );

	lea	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail

; 210  : 		return pBuf;

	mov	eax, DWORD PTR _pBuf$[ebp]

; 211  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ENDP ; CDatadescGeneratedNameHolder::GenerateName
_TEXT	ENDS
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E37
_TEXT	SEGMENT
_$E37	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTestHull@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E37	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File z:\xashxtsrc\common\datamap.h
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
$T40039 = -24
__$EHRec$ = -12
_this$ = -16
_i$ = -20
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC NEAR	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L30214
$L30215:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L30214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L30216

; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T40039[ebp], edx
	mov	eax, DWORD PTR $T40039[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 		}

	jmp	SHORT $L30215
$L30216:

; 202  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	ret	0
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
PUBLIC	?Spawn@CTestHull@@QAEXPAUentvars_s@@@Z		; CTestHull::Spawn
PUBLIC	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
PUBLIC	??_C@_0BC@DMHA@models?1player?4mdl?$AA@		; `string'
PUBLIC	??_C@_0L@KHDH@SUB_Remove?$AA@			; `string'
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
EXTRN	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z:NEAR ; UTIL_SetSize
EXTRN	?SUB_Remove@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::SUB_Remove
;	COMDAT ??_C@_0BC@DMHA@models?1player?4mdl?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BC@DMHA@models?1player?4mdl?$AA@ DB 'models/player.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
CONST	SEGMENT
??_C@_0L@KHDH@SUB_Remove?$AA@ DB 'SUB_Remove', 00H	; `string'
CONST	ENDS
;	COMDAT ?Spawn@CTestHull@@QAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
$T40053 = -16
$T40054 = -28
_this$ = -4
?Spawn@CTestHull@@QAEXPAUentvars_s@@@Z PROC NEAR	; CTestHull::Spawn, COMDAT

; 1461 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1462 : 	SET_MODEL(ENT(pev), "models/player.mdl");

	push	OFFSET FLAT:??_C@_0BC@DMHA@models?1player?4mdl?$AA@ ; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 1463 : 	UTIL_SetSize(pev, VEC_HUMAN_HULL_MIN, VEC_HUMAN_HULL_MAX);

	push	1116733440				; 42900000H
	push	1098907648				; 41800000H
	push	1098907648				; 41800000H
	lea	ecx, DWORD PTR $T40053[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	push	0
	push	-1048576000				; c1800000H
	push	-1048576000				; c1800000H
	lea	ecx, DWORD PTR $T40054[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 1464 : 
; 1465 : 	pev->solid			= SOLID_SLIDEBOX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 3

; 1466 : 	pev->movetype		= MOVETYPE_STEP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 4

; 1467 : 	pev->health			= 50;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+352], 1112014848		; 42480000H

; 1468 : 	pev->yaw_speed		= 8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+176], 1090519040		; 41000000H

; 1469 : 
; 1470 : 	if ( WorldGraph.m_fGraphPresent )

	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A, 0
	je	SHORT $L37855

; 1472 : 		// graph loaded from disk, so we don't need the test hull
; 1473 : 		SetThink ( SUB_Remove );

	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1474 : 		pev->nextthink = gpGlobals->time;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+260], eax

; 1476 : 	else

	jmp	SHORT $L37859
$L37855:

; 1478 : 		SetThink ( DropDelay );

	push	OFFSET FLAT:??_C@_09NKNA@DropDelay?$AA@	; `string'
	push	OFFSET FLAT:?DropDelay@CTestHull@@QAEXXZ ; CTestHull::DropDelay
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1479 : 		pev->nextthink = gpGlobals->time + 1;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+260]
$L37859:

; 1481 : 
; 1482 : 	// Make this invisible
; 1483 : 	// UNDONE: Shouldn't we just use EF_NODRAW?  This doesn't need to go to the client.
; 1484 : 	pev->rendermode = kRenderTransTexture;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+328], 2

; 1485 : 	pev->renderamt = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+332], 0

; 1486 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Spawn@CTestHull@@QAEXPAUentvars_s@@@Z ENDP		; CTestHull::Spawn
_TEXT	ENDS
PUBLIC	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z	; CBaseEntity::FunctionCheck
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::ThinkSet, COMDAT

; 560  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 		m_pfnThink = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1744], ecx

; 562  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnThink)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1744]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 563  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 564  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP	; CBaseEntity::ThinkSet
_TEXT	ENDS
PUBLIC	??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:NEAR ; UTIL_FunctionToName
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ DB 'F'
	DB	'UNCTION NOT IN TABLE!: %s:%s (%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT
_this$ = -4
_pFunction$ = 8
_name$ = 12
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z PROC NEAR	; CBaseEntity::FunctionCheck, COMDAT

; 554  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 		if (pFunction && !UTIL_FunctionToName( GetDataDescMap(), pFunction ) )

	cmp	DWORD PTR _pFunction$[ebp], 0
	je	SHORT $L35044
	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	test	eax, eax
	jne	SHORT $L35044

; 556  : 			ALERT( at_warning, "FUNCTION NOT IN TABLE!: %s:%s (%08lx)\n", GetClassname(), name, (unsigned long)pFunction );

	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L35044:

; 557  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ENDP		; CBaseEntity::FunctionCheck
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
PUBLIC	?UTIL_CenterPrintAll@@YAXPBD0000@Z		; UTIL_CenterPrintAll
PUBLIC	??_C@_0CG@FEFN@Node?5Graph?5out?5of?5Date?4?5Rebuildi@ ; `string'
EXTRN	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z:NEAR ; UTIL_SetOrigin
;	COMDAT ??_C@_0CG@FEFN@Node?5Graph?5out?5of?5Date?4?5Rebuildi@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0CG@FEFN@Node?5Graph?5out?5of?5Date?4?5Rebuildi@ DB 'Node Graph out'
	DB	' of Date. Rebuilding...', 00H		; `string'
CONST	ENDS
;	COMDAT ?DropDelay@CTestHull@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DropDelay@CTestHull@@QAEXXZ PROC NEAR			; CTestHull::DropDelay, COMDAT

; 1493 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1494 : 	UTIL_CenterPrintAll( "Node Graph out of Date. Rebuilding..." );

	push	0
	push	0
	push	0
	push	0
	push	OFFSET FLAT:??_C@_0CG@FEFN@Node?5Graph?5out?5of?5Date?4?5Rebuildi@ ; `string'
	call	?UTIL_CenterPrintAll@@YAXPBD0000@Z	; UTIL_CenterPrintAll
	add	esp, 20					; 00000014H

; 1495 : 
; 1496 : 	UTIL_SetOrigin ( this, WorldGraph.m_pNodes[ 0 ].m_vecOrigin );

	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 1497 : 
; 1498 : 	SetThink ( CallBuildNodeGraph );

	push	OFFSET FLAT:??_C@_0BD@EDK@CallBuildNodeGraph?$AA@ ; `string'
	push	OFFSET FLAT:?CallBuildNodeGraph@CTestHull@@QAEXXZ ; CTestHull::CallBuildNodeGraph
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1499 : 
; 1500 : 	pev->nextthink = gpGlobals->time + 1;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+260]

; 1501 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DropDelay@CTestHull@@QAEXXZ ENDP			; CTestHull::DropDelay
_TEXT	ENDS
EXTRN	?UTIL_ClientPrintAll@@YAXHPBD0000@Z:NEAR	; UTIL_ClientPrintAll
;	COMDAT ?UTIL_CenterPrintAll@@YAXPBD0000@Z
_TEXT	SEGMENT
_msg_name$ = 8
_param1$ = 12
_param2$ = 16
_param3$ = 20
_param4$ = 24
?UTIL_CenterPrintAll@@YAXPBD0000@Z PROC NEAR		; UTIL_CenterPrintAll, COMDAT

; 422  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 423  : 	UTIL_ClientPrintAll( HUD_PRINTCENTER, msg_name, param1, param2, param3, param4 );

	mov	eax, DWORD PTR _param4$[ebp]
	push	eax
	mov	ecx, DWORD PTR _param3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _param2$[ebp]
	push	edx
	mov	eax, DWORD PTR _param1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg_name$[ebp]
	push	ecx
	push	4
	call	?UTIL_ClientPrintAll@@YAXHPBD0000@Z	; UTIL_ClientPrintAll
	add	esp, 24					; 00000018H

; 424  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_CenterPrintAll@@YAXPBD0000@Z ENDP			; UTIL_CenterPrintAll
_TEXT	ENDS
PUBLIC	?KeyValue@CNodeEnt@@EAEXPAUKeyValueData_s@@@Z	; CNodeEnt::KeyValue
PUBLIC	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
PUBLIC	??_C@_08BJLI@hinttype?$AA@			; `string'
PUBLIC	??_C@_08KABI@activity?$AA@			; `string'
EXTRN	_atoi:NEAR
;	COMDAT ??_C@_08BJLI@hinttype?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_08BJLI@hinttype?$AA@ DB 'hinttype', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KABI@activity?$AA@
CONST	SEGMENT
??_C@_08KABI@activity?$AA@ DB 'activity', 00H		; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CNodeEnt@@EAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CNodeEnt@@EAEXPAUKeyValueData_s@@@Z PROC NEAR	; CNodeEnt::KeyValue, COMDAT

; 1508 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1509 : 	if (FStrEq(pkvd->szKeyName, "hinttype"))

	push	OFFSET FLAT:??_C@_08BJLI@hinttype?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37873

; 1511 : 		m_sHintType = (short)atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1764], ax

; 1512 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1
$L37873:

; 1514 : 
; 1515 : 	if (FStrEq(pkvd->szKeyName, "activity"))

	push	OFFSET FLAT:??_C@_08KABI@activity?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37876

; 1517 : 		m_sHintActivity = (short)atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1766], ax

; 1518 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1520 : 	else

	jmp	SHORT $L37879
$L37876:

; 1521 : 		CBaseEntity::KeyValue( pkvd );

	mov	eax, DWORD PTR _pkvd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
$L37879:

; 1522 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CNodeEnt@@EAEXPAUKeyValueData_s@@@Z ENDP	; CNodeEnt::KeyValue
_TEXT	ENDS
PUBLIC	??_C@_06FOPF@parent?$AA@			; `string'
PUBLIC	??_C@_08IDGH@movewith?$AA@			; `string'
PUBLIC	??_C@_0M@FCIN@parentflags?$AA@			; `string'
PUBLIC	??_C@_05JCDO@style?$AA@				; `string'
PUBLIC	??_C@_0L@MCHI@reflection?$AA@			; `string'
PUBLIC	??_C@_0N@DCCA@vlight_cache?$AA@			; `string'
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
;	COMDAT ??_C@_06FOPF@parent?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_06FOPF@parent?$AA@ DB 'parent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT
??_C@_08IDGH@movewith?$AA@ DB 'movewith', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT
??_C@_0M@FCIN@parentflags?$AA@ DB 'parentflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT
??_C@_05JCDO@style?$AA@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT
??_C@_0L@MCHI@reflection?$AA@ DB 'reflection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT
??_C@_0N@DCCA@vlight_cache?$AA@ DB 'vlight_cache', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pkvd$ = 8
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseEntity::KeyValue, COMDAT

; 328  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 		// get support for spirit field too
; 330  : 		if( FStrEq( pkvd->szKeyName, "parent" ) || FStrEq( pkvd->szKeyName, "movewith" ))

	push	OFFSET FLAT:??_C@_06FOPF@parent?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L34875
	push	OFFSET FLAT:??_C@_08IDGH@movewith?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34874
$L34875:

; 332  : 			m_iParent = ALLOC_STRING(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 333  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 335  : 		else if( FStrEq( pkvd->szKeyName, "parentflags" ))

	jmp	$L34896
$L34874:
	push	OFFSET FLAT:??_C@_0M@FCIN@parentflags?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34879

; 337  : 			m_iParentFlags = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 338  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 340  : 		else if( FStrEq( pkvd->szKeyName, "style" ))

	jmp	$L34896
$L34879:
	push	OFFSET FLAT:??_C@_05JCDO@style?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34882

; 342  : 			m_iStyle = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 343  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 345  : 		else if( FStrEq( pkvd->szKeyName, "reflection" ))

	jmp	$L34896
$L34882:
	push	OFFSET FLAT:??_C@_0L@MCHI@reflection?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34885

; 348  : 			{

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L34891
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L34892
	jmp	SHORT $L34888
$L34891:

; 349  : 			case 1: pev->effects |= EF_NOREFLECT; break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
	jmp	SHORT $L34888
$L34892:

; 350  : 			case 2: pev->effects |= EF_REFLECTONLY; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L34888:

; 352  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 354  : 		else if( FStrEq(pkvd->szKeyName, "vlight_cache"))

	jmp	SHORT $L34896
$L34885:
	push	OFFSET FLAT:??_C@_0N@DCCA@vlight_cache?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34894

; 356  : 			pev->iuser3 = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+588], eax

; 357  : 			pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 359  : 		else pkvd->fHandled = FALSE;

	jmp	SHORT $L34896
$L34894:
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L34896:

; 360  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseEntity::KeyValue
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z		; GetClassPtr
PUBLIC	??_C@_0BE@DFEH@cNodes?5?$DO?5MAX_NODES?6?$AA@	; `string'
PUBLIC	?Spawn@CNodeEnt@@EAEXXZ				; CNodeEnt::Spawn
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
EXTRN	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsAngles
;	COMDAT ??_C@_0BE@DFEH@cNodes?5?$DO?5MAX_NODES?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BE@DFEH@cNodes?5?$DO?5MAX_NODES?6?$AA@ DB 'cNodes > MAX_NODES', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?Spawn@CNodeEnt@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pHull$37886 = -8
?Spawn@CNodeEnt@@EAEXXZ PROC NEAR			; CNodeEnt::Spawn, COMDAT

; 1527 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1528 : 	pev->movetype = MOVETYPE_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 0

; 1529 : 	pev->solid = SOLID_NOT;// always solid_not 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 0

; 1530 : 
; 1531 : 	if ( WorldGraph.m_fGraphPresent )

	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A, 0
	je	SHORT $L37884

; 1533 : 		// graph loaded from disk, so discard all these node ents as soon as they spawn
; 1534 : 		REMOVE_ENTITY( edict() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+88
	add	esp, 4

; 1535 : 		return;

	jmp	$L37883
$L37884:

; 1537 : 
; 1538 : 	if ( WorldGraph.m_cNodes == 0 )

	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A+24, 0
	jne	SHORT $L37885

; 1540 : 		// this is the first node to spawn, spawn the test hull entity that builds and walks the node tree
; 1541 : 		CTestHull *pHull = GetClassPtr((CTestHull *)NULL);

	push	0
	call	?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z	; GetClassPtr
	add	esp, 4
	mov	DWORD PTR _pHull$37886[ebp], eax

; 1542 : 		pHull->Spawn( pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _pHull$37886[ebp]
	call	?Spawn@CTestHull@@QAEXPAUentvars_s@@@Z	; CTestHull::Spawn
$L37885:

; 1544 : 
; 1545 : 	if ( WorldGraph.m_cNodes >= MAX_NODES )

	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A+24, 1024 ; 00000400H
	jl	SHORT $L37892

; 1547 : 		ALERT ( at_aiconsole, "cNodes > MAX_NODES\n" );

	push	OFFSET FLAT:??_C@_0BE@DFEH@cNodes?5?$DO?5MAX_NODES?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1548 : 		return;

	jmp	$L37883
$L37892:

; 1552 : 	WorldGraph.m_pNodes[ WorldGraph.m_cNodes ].m_vecOrigin = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	add	edx, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	add	edx, ecx
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	lea	eax, DWORD PTR [ecx+eax+12]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 1553 : 	WorldGraph.m_pNodes[ WorldGraph.m_cNodes ].m_flHintYaw = GetAbsAngles().y;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx+84], eax

; 1554 : 	WorldGraph.m_pNodes[ WorldGraph.m_cNodes ].m_sHintType = m_sHintType;

	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+1764]
	mov	WORD PTR [edx+ecx+80], ax

; 1555 : 	WorldGraph.m_pNodes[ WorldGraph.m_cNodes ].m_sHintActivity = m_sHintActivity;

	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+1766]
	mov	WORD PTR [edx+ecx+82], ax

; 1556 : 
; 1557 : 	if (FClassnameIs( pev, "info_node_air" ))

	push	OFFSET FLAT:??_C@_0O@NGKI@info_node_air?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L37894

; 1558 : 		WorldGraph.m_pNodes[ WorldGraph.m_cNodes ].m_afNodeInfo = bits_NODE_AIR;

	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	DWORD PTR [ecx+eax+28], 2

; 1559 : 	else

	jmp	SHORT $L37895
$L37894:

; 1560 : 		WorldGraph.m_pNodes[ WorldGraph.m_cNodes ].m_afNodeInfo = 0;

	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	DWORD PTR [eax+edx+28], 0
$L37895:

; 1561 : 
; 1562 : 	WorldGraph.m_cNodes++;

	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	add	ecx, 1
	mov	DWORD PTR ?WorldGraph@@3VCGraph@@A+24, ecx

; 1563 : 
; 1564 : 	REMOVE_ENTITY( edict() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+88
	add	esp, 4
$L37883:

; 1565 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CNodeEnt@@EAEXXZ ENDP				; CNodeEnt::Spawn
_TEXT	ENDS
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	__real@4@40018000000000000000
PUBLIC	__real@8@3ffbccccccccccccd000
EXTRN	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsAngles
EXTRN	?UTIL_MakeVectors@@YAXABVVector@@@Z:NEAR	; UTIL_MakeVectors
;	COMDAT __real@4@40018000000000000000
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
__real@4@40018000000000000000 DD 040800000r	; 4
CONST	ENDS
;	COMDAT __real@8@3ffbccccccccccccd000
CONST	SEGMENT
__real@8@3ffbccccccccccccd000 DQ 03fb999999999999ar ; 0.1
CONST	ENDS
;	COMDAT ?ShowBadNode@CTestHull@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_absOrigin$ = -16
_absAngles$ = -28
$T40073 = -40
$T40074 = -52
$T40075 = -64
$T40076 = -76
$T40077 = -88
$T40078 = -100
$T40079 = -112
$T40080 = -124
?ShowBadNode@CTestHull@@QAEXXZ PROC NEAR		; CTestHull::ShowBadNode, COMDAT

; 1574 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1575 : 	Vector absOrigin = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _absOrigin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1576 : 	Vector absAngles = GetAbsAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _absAngles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1577 : 
; 1578 : 	pev->movetype = MOVETYPE_FLY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 5

; 1579 : 	absAngles.y += 4;

	fld	DWORD PTR _absAngles$[ebp+4]
	fadd	DWORD PTR __real@4@40018000000000000000
	fstp	DWORD PTR _absAngles$[ebp+4]

; 1580 : 	SetAbsAngles( absAngles );

	lea	edx, DWORD PTR _absAngles$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 1581 : 
; 1582 : 	UTIL_MakeVectors ( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 1583 : 
; 1584 : 	UTIL_ParticleEffect ( absOrigin, g_vecZero, 255, 25 );

	push	25					; 00000019H
	push	255					; 000000ffH
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	eax, DWORD PTR _absOrigin$[ebp]
	push	eax
	call	?UTIL_ParticleEffect@@YAXABVVector@@0KK@Z ; UTIL_ParticleEffect
	add	esp, 16					; 00000010H

; 1585 : 	UTIL_ParticleEffect ( absOrigin + gpGlobals->v_forward * 64, g_vecZero, 255, 25 );

	push	25					; 00000019H
	push	255					; 000000ffH
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	push	1115684864				; 42800000H
	lea	ecx, DWORD PTR $T40073[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T40074[ebp]
	push	edx
	lea	ecx, DWORD PTR _absOrigin$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	call	?UTIL_ParticleEffect@@YAXABVVector@@0KK@Z ; UTIL_ParticleEffect
	add	esp, 16					; 00000010H

; 1586 : 	UTIL_ParticleEffect ( absOrigin - gpGlobals->v_forward * 64, g_vecZero, 255, 25 );

	push	25					; 00000019H
	push	255					; 000000ffH
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	push	1115684864				; 42800000H
	lea	eax, DWORD PTR $T40075[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T40076[ebp]
	push	ecx
	lea	ecx, DWORD PTR _absOrigin$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	call	?UTIL_ParticleEffect@@YAXABVVector@@0KK@Z ; UTIL_ParticleEffect
	add	esp, 16					; 00000010H

; 1587 : 	UTIL_ParticleEffect ( absOrigin + gpGlobals->v_right * 64, g_vecZero, 255, 25 );

	push	25					; 00000019H
	push	255					; 000000ffH
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	push	1115684864				; 42800000H
	lea	edx, DWORD PTR $T40077[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40078[ebp]
	push	eax
	lea	ecx, DWORD PTR _absOrigin$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	call	?UTIL_ParticleEffect@@YAXABVVector@@0KK@Z ; UTIL_ParticleEffect
	add	esp, 16					; 00000010H

; 1588 : 	UTIL_ParticleEffect ( absOrigin - gpGlobals->v_right * 64, g_vecZero, 255, 25 );

	push	25					; 00000019H
	push	255					; 000000ffH
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	push	1115684864				; 42800000H
	lea	ecx, DWORD PTR $T40079[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T40080[ebp]
	push	edx
	lea	ecx, DWORD PTR _absOrigin$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	call	?UTIL_ParticleEffect@@YAXABVVector@@0KK@Z ; UTIL_ParticleEffect
	add	esp, 16					; 00000010H

; 1589 : 
; 1590 : 	pev->nextthink = gpGlobals->time + 0.1;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -128+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 1591 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowBadNode@CTestHull@@QAEXXZ ENDP			; CTestHull::ShowBadNode
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
$T40087 = -16
___$ReturnUdt$ = 8
_this$ = -4
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40087[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
$T40090 = -16
___$ReturnUdt$ = 8
_this$ = -4
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40090[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
PUBLIC	?BuildNodeGraph@CTestHull@@QAEXXZ		; CTestHull::BuildNodeGraph
EXTRN	?gTouchDisabled@@3HA:DWORD			; gTouchDisabled
;	COMDAT ?CallBuildNodeGraph@CTestHull@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CallBuildNodeGraph@CTestHull@@QAEXXZ PROC NEAR		; CTestHull::CallBuildNodeGraph, COMDAT

; 1595 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1596 : 	// TOUCH HACK -- Don't allow this entity to call anyone's "touch" function
; 1597 : 	gTouchDisabled = TRUE;

	mov	DWORD PTR ?gTouchDisabled@@3HA, 1	; gTouchDisabled

; 1598 : 	BuildNodeGraph();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildNodeGraph@CTestHull@@QAEXXZ	; CTestHull::BuildNodeGraph

; 1599 : 	gTouchDisabled = FALSE;

	mov	DWORD PTR ?gTouchDisabled@@3HA, 0	; gTouchDisabled

; 1600 : 	// Undo TOUCH HACK
; 1601 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CallBuildNodeGraph@CTestHull@@QAEXXZ ENDP		; CTestHull::CallBuildNodeGraph
_TEXT	ENDS
PUBLIC	?BuildLinkLookups@CGraph@@QAEXXZ		; CGraph::BuildLinkLookups
PUBLIC	?SortNodes@CGraph@@QAEXXZ			; CGraph::SortNodes
PUBLIC	??_C@_0BO@DEBH@?$CK?$CKCould?5not?5malloc?5TempPool?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0M@LPHH@maps?1?$CFs?4nrp?$AA@		; `string'
PUBLIC	??_C@_0CE@BCMP@Node?5Graph?5Report?5for?5map?3?5?5?$CFs?4b@ ; `string'
PUBLIC	??_C@_0BB@JELK@?$CFd?5Total?5Nodes?6?6?$AA@	; `string'
PUBLIC	??_C@_0BD@FMMD@Node?$CD?5?5?5?5?5?5?5?5?5?$CF4d?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@GAAC@Location?5?5?5?5?5?5?$CF4d?0?$CF4d?0?$CF4d?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@IKID@HintType?3?5?5?5?5?5?$CF4d?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@EIDE@HintActivity?3?5?$CF4d?6?$AA@	; `string'
PUBLIC	??_C@_0BD@EPAC@HintYaw?3?5?5?5?5?5?5?$CF4f?6?$AA@ ; `string'
PUBLIC	??_C@_0FB@PMEA@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_02JJJH@?6?6?$AA@				; `string'
PUBLIC	??_C@_0BP@MGAF@?$CK?$CKConnectVisibleNodes?5FAILED?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BB@BPJN@Walk?5Rejection?3?6?$AA@		; `string'
PUBLIC	??_C@_0M@GDCA@Node?5?$CF4d?3?6?6?$AA@		; `string'
PUBLIC	??_C@_0M@OHEO@OFFGROUND?$CB?6?$AA@		; `string'
PUBLIC	??_C@_0BC@BJIG@?$CK?$CK?$CK?$CK?5j?5?$DN?5?$CFd?5?$CK?$CK?$CK?$CK?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@LPFE@NODE_SMALL_HULL?5step?5?$CFf?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@GN@NODE_HUMAN_HULL?5step?5?$CFf?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@EJDC@NODE_LARGE_HULL?5step?5?$CFf?6?$AA@ ; `string'
PUBLIC	??_C@_0CE@DEFK@Rejected?5Node?5?$CF3d?5?9?5Unreachable?5@ ; `string'
PUBLIC	??_C@_09ECJA@Any?5Hull?6?$AA@			; `string'
PUBLIC	??_C@_0FD@OAIO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_0BL@FKJF@Couldn?8t?5malloc?5LinkPool?$CB?6?$AA@ ; `string'
PUBLIC	__real@4@40058000000000000000
PUBLIC	??_C@_0FD@BEFM@?6?6?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_0BA@JFHC@Link?5Pairings?3?6?$AA@		; `string'
PUBLIC	??_C@_0DF@ECLH@WARNING?3?5Node?5?$CF3d?5does?5not?5conne@ ; `string'
PUBLIC	?Length2D@Vector@@QBEMXZ			; Vector::Length2D
PUBLIC	??_C@_0BO@GHBB@?6All?5Connections?5are?5Paired?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CJ@IKOB@Total?5Number?5of?5Connections?5in?5P@ ; `string'
PUBLIC	??_C@_0BL@LCPH@Connection?5Pool?3?5?$CFd?5bytes?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@CALM@?$CFd?5Nodes?0?5?$CFd?5Connections?6?$AA@ ; `string'
PUBLIC	??_C@_06JCEA@Done?4?6?$AA@			; `string'
PUBLIC	?GetBuffer@CVirtualFS@@QAEPADXZ			; CVirtualFS::GetBuffer
PUBLIC	?GetSize@CVirtualFS@@QAEIXZ			; CVirtualFS::GetSize
PUBLIC	?FSaveGraph@CGraph@@QAEHPAD@Z			; CGraph::FSaveGraph
PUBLIC	?BuildRegionTables@CGraph@@QAEXXZ		; CGraph::BuildRegionTables
PUBLIC	?ComputeStaticRoutingTables@CGraph@@QAEXXZ	; CGraph::ComputeStaticRoutingTables
EXTRN	?UTIL_PointContents@@YAHABVVector@@@Z:NEAR	; UTIL_PointContents
EXTRN	?Q_snprintf@@YAHPADIPBDZZ:NEAR			; Q_snprintf
EXTRN	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsOrigin
EXTRN	?UTIL_VecToYaw@@YAMABVVector@@@Z:NEAR		; UTIL_VecToYaw
EXTRN	?g_physfuncs@@3Userver_physics_api_s@@A:BYTE	; g_physfuncs
EXTRN	?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceHull
;	COMDAT ??_C@_0BO@DEBH@?$CK?$CKCould?5not?5malloc?5TempPool?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BO@DEBH@?$CK?$CKCould?5not?5malloc?5TempPool?$CB?6?$AA@ DB '**Coul'
	DB	'd not malloc TempPool!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LPHH@maps?1?$CFs?4nrp?$AA@
CONST	SEGMENT
??_C@_0M@LPHH@maps?1?$CFs?4nrp?$AA@ DB 'maps/%s.nrp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BCMP@Node?5Graph?5Report?5for?5map?3?5?5?$CFs?4b@
CONST	SEGMENT
??_C@_0CE@BCMP@Node?5Graph?5Report?5for?5map?3?5?5?$CFs?4b@ DB 'Node Grap'
	DB	'h Report for map:  %s.bsp', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JELK@?$CFd?5Total?5Nodes?6?6?$AA@
CONST	SEGMENT
??_C@_0BB@JELK@?$CFd?5Total?5Nodes?6?6?$AA@ DB '%d Total Nodes', 0aH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FMMD@Node?$CD?5?5?5?5?5?5?5?5?5?$CF4d?6?$AA@
CONST	SEGMENT
??_C@_0BD@FMMD@Node?$CD?5?5?5?5?5?5?5?5?5?$CF4d?6?$AA@ DB 'Node#         '
	DB	'%4d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GAAC@Location?5?5?5?5?5?5?$CF4d?0?$CF4d?0?$CF4d?6?$AA@
CONST	SEGMENT
??_C@_0BL@GAAC@Location?5?5?5?5?5?5?$CF4d?0?$CF4d?0?$CF4d?6?$AA@ DB 'Loca'
	DB	'tion      %4d,%4d,%4d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IKID@HintType?3?5?5?5?5?5?$CF4d?6?$AA@
CONST	SEGMENT
??_C@_0BD@IKID@HintType?3?5?5?5?5?5?$CF4d?6?$AA@ DB 'HintType:     %4d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EIDE@HintActivity?3?5?$CF4d?6?$AA@
CONST	SEGMENT
??_C@_0BD@EIDE@HintActivity?3?5?$CF4d?6?$AA@ DB 'HintActivity: %4d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EPAC@HintYaw?3?5?5?5?5?5?5?$CF4f?6?$AA@
CONST	SEGMENT
??_C@_0BD@EPAC@HintYaw?3?5?5?5?5?5?5?$CF4f?6?$AA@ DB 'HintYaw:      %4f', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@PMEA@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0FB@PMEA@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'-------------------------------------------------------------'
	DB	'-----------------', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JJJH@?6?6?$AA@
CONST	SEGMENT
??_C@_02JJJH@?6?6?$AA@ DB 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MGAF@?$CK?$CKConnectVisibleNodes?5FAILED?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BP@MGAF@?$CK?$CKConnectVisibleNodes?5FAILED?$CB?6?$AA@ DB '**Conne'
	DB	'ctVisibleNodes FAILED!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BPJN@Walk?5Rejection?3?6?$AA@
CONST	SEGMENT
??_C@_0BB@BPJN@Walk?5Rejection?3?6?$AA@ DB 'Walk Rejection:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GDCA@Node?5?$CF4d?3?6?6?$AA@
CONST	SEGMENT
??_C@_0M@GDCA@Node?5?$CF4d?3?6?6?$AA@ DB 'Node %4d:', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OHEO@OFFGROUND?$CB?6?$AA@
CONST	SEGMENT
??_C@_0M@OHEO@OFFGROUND?$CB?6?$AA@ DB 'OFFGROUND!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BJIG@?$CK?$CK?$CK?$CK?5j?5?$DN?5?$CFd?5?$CK?$CK?$CK?$CK?6?$AA@
CONST	SEGMENT
??_C@_0BC@BJIG@?$CK?$CK?$CK?$CK?5j?5?$DN?5?$CFd?5?$CK?$CK?$CK?$CK?6?$AA@ DB '*'
	DB	'*** j = %d ****', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LPFE@NODE_SMALL_HULL?5step?5?$CFf?6?$AA@
CONST	SEGMENT
??_C@_0BJ@LPFE@NODE_SMALL_HULL?5step?5?$CFf?6?$AA@ DB 'NODE_SMALL_HULL st'
	DB	'ep %f', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GN@NODE_HUMAN_HULL?5step?5?$CFf?6?$AA@
CONST	SEGMENT
??_C@_0BJ@GN@NODE_HUMAN_HULL?5step?5?$CFf?6?$AA@ DB 'NODE_HUMAN_HULL step'
	DB	' %f', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EJDC@NODE_LARGE_HULL?5step?5?$CFf?6?$AA@
CONST	SEGMENT
??_C@_0BJ@EJDC@NODE_LARGE_HULL?5step?5?$CFf?6?$AA@ DB 'NODE_LARGE_HULL st'
	DB	'ep %f', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DEFK@Rejected?5Node?5?$CF3d?5?9?5Unreachable?5@
CONST	SEGMENT
??_C@_0CE@DEFK@Rejected?5Node?5?$CF3d?5?9?5Unreachable?5@ DB 'Rejected No'
	DB	'de %3d - Unreachable by ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ECJA@Any?5Hull?6?$AA@
CONST	SEGMENT
??_C@_09ECJA@Any?5Hull?6?$AA@ DB 'Any Hull', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@OAIO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0FD@OAIO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'-------------------------------------------------------------'
	DB	'-----------------', 0aH, 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FKJF@Couldn?8t?5malloc?5LinkPool?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BL@FKJF@Couldn?8t?5malloc?5LinkPool?$CB?6?$AA@ DB 'Couldn''t mallo'
	DB	'c LinkPool!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@BEFM@?6?6?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0FD@BEFM@?6?6?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB 0aH
	DB	0aH, '--------------------------------------------------------'
	DB	'-----------------------', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFHC@Link?5Pairings?3?6?$AA@
CONST	SEGMENT
??_C@_0BA@JFHC@Link?5Pairings?3?6?$AA@ DB 'Link Pairings:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@ECLH@WARNING?3?5Node?5?$CF3d?5does?5not?5conne@
CONST	SEGMENT
??_C@_0DF@ECLH@WARNING?3?5Node?5?$CF3d?5does?5not?5conne@ DB 'WARNING: No'
	DB	'de %3d does not connect back to Node %3d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GHBB@?6All?5Connections?5are?5Paired?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BO@GHBB@?6All?5Connections?5are?5Paired?$CB?6?$AA@ DB 0aH, 'All Co'
	DB	'nnections are Paired!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IKOB@Total?5Number?5of?5Connections?5in?5P@
CONST	SEGMENT
??_C@_0CJ@IKOB@Total?5Number?5of?5Connections?5in?5P@ DB 'Total Number of'
	DB	' Connections in Pool: %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LCPH@Connection?5Pool?3?5?$CFd?5bytes?6?$AA@
CONST	SEGMENT
??_C@_0BL@LCPH@Connection?5Pool?3?5?$CFd?5bytes?6?$AA@ DB 'Connection Poo'
	DB	'l: %d bytes', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CALM@?$CFd?5Nodes?0?5?$CFd?5Connections?6?$AA@
CONST	SEGMENT
??_C@_0BK@CALM@?$CFd?5Nodes?0?5?$CFd?5Connections?6?$AA@ DB '%d Nodes, %d'
	DB	' Connections', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06JCEA@Done?4?6?$AA@
CONST	SEGMENT
??_C@_06JCEA@Done?4?6?$AA@ DB 'Done.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@4@40058000000000000000
CONST	SEGMENT
__real@4@40058000000000000000 DD 042800000r	; 64
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?BuildNodeGraph@CTestHull@@QAEXXZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?BuildNodeGraph@CTestHull@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?BuildNodeGraph@CTestHull@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildNodeGraph@CTestHull@@QAEXXZ$0
xdata$x	ENDS
;	COMDAT ?BuildNodeGraph@CTestHull@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16
_tr$ = -72
_file$ = -88
_szNrpFilename$ = -348
_pTempPool$ = -352
_pSrcNode$ = -356
_pDestNode$ = -360
_fSkipRemainingHulls$ = -364
_fPairsValid$ = -368
_i$ = -372
_j$ = -376
_hull$ = -380
_iBadNode$ = -384
_cMaxInitialLinks$ = -388
_cMaxValidLinks$ = -392
_iPoolIndex$ = -396
_cPoolLinks$ = -400
_vecDirToCheckNode$ = -412
_vecDirToTestNode$ = -424
_vecStepCheckDir$ = -436
_vecTraceSpot$ = -448
_vecSpot$ = -460
_vec2DirToCheckNode$ = -468
_vec2DirToTestNode$ = -476
_vec2StepCheckDir$ = -484
_vec2TraceSpot$ = -492
_vec2Spot$ = -500
_flYaw$ = -504
_flDist$ = -508
_step$ = -512
_tr$37977 = -568
_trEnt$37980 = -624
_SaveFlags$38025 = -628
_MoveMode$38026 = -632
_fWalkFailed$38030 = -636
_stepSize$38034 = -640
$T40095 = -720
$T40096 = -732
$T40097 = -744
$T40098 = -756
$T40099 = -768
_tr$38051 = -696
$T40100 = -780
$T40101 = -792
$T40102 = -804
$T40103 = -816
$T40104 = -828
$T40105 = -840
$T40106 = -852
$T40107 = -864
$T40108 = -876
$T40109 = -888
$T40110 = -900
$T40111 = -912
$T40112 = -924
$T40113 = -936
__$EHRec$ = -12
_iFinalPoolIndex$ = -700
_iOldFirstLink$ = -704
_iLink$38083 = -708
?BuildNodeGraph@CTestHull@@QAEXXZ PROC NEAR		; CTestHull::BuildNodeGraph, COMDAT

; 1612 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BuildNodeGraph@CTestHull@@QAEXXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 996				; 000003e4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1613 : 	TraceResult	tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1614 : 	CVirtualFS	file;

	lea	ecx, DWORD PTR _file$[ebp]
	call	??0CVirtualFS@@QAE@XZ			; CVirtualFS::CVirtualFS
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1615 : 
; 1616 : 	char		szNrpFilename [MAX_PATH];// text node report filename
; 1617 : 
; 1618 : 	CLink		*pTempPool; // temporary link pool 
; 1619 : 
; 1620 : 	CNode		*pSrcNode;// node we're currently working with
; 1621 : 	CNode		*pDestNode;// the other node in comparison operations
; 1622 : 
; 1623 : 	BOOL		fSkipRemainingHulls;//if smallest hull can't fit, don't check any others
; 1624 : 	BOOL		fPairsValid;// are all links in the graph evenly paired?
; 1625 : 
; 1626 : 	int		i, j, hull;
; 1627 : 
; 1628 : 	int		iBadNode;// this is the node that caused graph generation to fail
; 1629 : 
; 1630 : 	int		cMaxInitialLinks = 0;

	mov	DWORD PTR _cMaxInitialLinks$[ebp], 0

; 1631 : 	int		cMaxValidLinks	= 0;

	mov	DWORD PTR _cMaxValidLinks$[ebp], 0

; 1632 : 
; 1633 : 	int		iPoolIndex = 0;

	mov	DWORD PTR _iPoolIndex$[ebp], 0

; 1634 : 	int		cPoolLinks;// number of links in the pool.
; 1635 : 
; 1636 : 	Vector	vecDirToCheckNode;

	lea	ecx, DWORD PTR _vecDirToCheckNode$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1637 : 	Vector	vecDirToTestNode;

	lea	ecx, DWORD PTR _vecDirToTestNode$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1638 : 	Vector	vecStepCheckDir;

	lea	ecx, DWORD PTR _vecStepCheckDir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1639 : 	Vector	vecTraceSpot;

	lea	ecx, DWORD PTR _vecTraceSpot$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1640 : 	Vector  vecSpot;

	lea	ecx, DWORD PTR _vecSpot$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1641 : 
; 1642 : 	Vector2D	vec2DirToCheckNode;

	lea	ecx, DWORD PTR _vec2DirToCheckNode$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 1643 : 	Vector2D	vec2DirToTestNode;

	lea	ecx, DWORD PTR _vec2DirToTestNode$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 1644 : 	Vector2D	vec2StepCheckDir;

	lea	ecx, DWORD PTR _vec2StepCheckDir$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 1645 : 	Vector2D	vec2TraceSpot;

	lea	ecx, DWORD PTR _vec2TraceSpot$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 1646 : 	Vector2D	vec2Spot;

	lea	ecx, DWORD PTR _vec2Spot$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 1647 : 
; 1648 : 	float	flYaw;// use this stuff to walk the hull between nodes
; 1649 : 	float	flDist;
; 1650 : 	int		step;
; 1651 : 
; 1652 : 	SetThink ( SUB_Remove );// no matter what happens, the hull gets rid of itself.

	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1653 : 	pev->nextthink = gpGlobals->time;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+260], eax

; 1654 : 
; 1655 : 	// malloc a swollen temporary connection pool that we trim down after we know exactly how many connections there are.
; 1656 : 	pTempPool = (CLink *)calloc ( sizeof ( CLink ) , ( WorldGraph.m_cNodes * MAX_NODE_INITIAL_LINKS ) );

	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	shl	ecx, 7
	push	ecx
	push	24					; 00000018H
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _pTempPool$[ebp], eax

; 1657 : 	if ( !pTempPool )

	cmp	DWORD PTR _pTempPool$[ebp], 0
	jne	SHORT $L37952

; 1659 : 		ALERT ( at_aiconsole, "**Could not malloc TempPool!\n" );

	push	OFFSET FLAT:??_C@_0BO@DEBH@?$CK?$CKCould?5not?5malloc?5TempPool?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1660 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	jmp	$L37918
$L37952:

; 1662 : 
; 1663 : 	Q_snprintf( szNrpFilename, sizeof( szNrpFilename ), "maps/%s.nrp", STRING( gpGlobals->mapname ));

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0M@LPHH@maps?1?$CFs?4nrp?$AA@ ; `string'
	push	260					; 00000104H
	lea	ecx, DWORD PTR _szNrpFilename$[ebp]
	push	ecx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 1664 : 
; 1665 : 	file.Printf( "Node Graph Report for map:  %s.bsp\n", STRING(gpGlobals->mapname) );

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CE@BCMP@Node?5Graph?5Report?5for?5map?3?5?5?$CFs?4b@ ; `string'
	lea	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 1666 : 	file.Printf( "%d Total Nodes\n\n", WorldGraph.m_cNodes );

	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	push	edx
	push	OFFSET FLAT:??_C@_0BB@JELK@?$CFd?5Total?5Nodes?6?6?$AA@ ; `string'
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 1667 : 
; 1668 : 	for ( i = 0 ; i < WorldGraph.m_cNodes ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L37957
$L37958:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L37957:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	jge	$L37959

; 1670 : 		// print all node numbers and their locations to the file.
; 1671 : 		WorldGraph.m_pNodes[ i ].m_cNumLinks = 0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	DWORD PTR [ecx+eax+32], 0

; 1672 : 		WorldGraph.m_pNodes[ i ].m_iFirstLink = 0;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	DWORD PTR [eax+edx+36], 0

; 1673 : 		memset(WorldGraph.m_pNodes[ i ].m_pNextBestNode, 0, sizeof(WorldGraph.m_pNodes[ i ].m_pNextBestNode));

	push	32					; 00000020H
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	lea	eax, DWORD PTR [edx+ecx+40]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1674 : 
; 1675 : 		file.Printf( "Node#         %4d\n", i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BD@FMMD@Node?$CD?5?5?5?5?5?5?5?5?5?$CF4d?6?$AA@ ; `string'
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 1676 : 		file.Printf( "Location      %4d,%4d,%4d\n",(int)WorldGraph.m_pNodes[ i ].m_vecOrigin.x, (int)WorldGraph.m_pNodes[ i ].m_vecOrigin.y, (int)WorldGraph.m_pNodes[ i ].m_vecOrigin.z );

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	fld	DWORD PTR [ecx+eax+8]
	call	__ftol
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	fld	DWORD PTR [eax+edx+4]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	fld	DWORD PTR [edx+ecx]
	call	__ftol
	push	eax
	push	OFFSET FLAT:??_C@_0BL@GAAC@Location?5?5?5?5?5?5?$CF4d?0?$CF4d?0?$CF4d?6?$AA@ ; `string'
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 20					; 00000014H

; 1677 : 		file.Printf( "HintType:     %4d\n", WorldGraph.m_pNodes[ i ].m_sHintType );

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	movsx	eax, WORD PTR [edx+ecx+80]
	push	eax
	push	OFFSET FLAT:??_C@_0BD@IKID@HintType?3?5?5?5?5?5?$CF4d?6?$AA@ ; `string'
	lea	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 1678 : 		file.Printf( "HintActivity: %4d\n", WorldGraph.m_pNodes[ i ].m_sHintActivity );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	movsx	ecx, WORD PTR [eax+edx+82]
	push	ecx
	push	OFFSET FLAT:??_C@_0BD@EIDE@HintActivity?3?5?$CF4d?6?$AA@ ; `string'
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 1679 : 		file.Printf( "HintYaw:      %4f\n", WorldGraph.m_pNodes[ i ].m_flHintYaw );

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	fld	DWORD PTR [ecx+eax+84]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BD@EPAC@HintYaw?3?5?5?5?5?5?5?$CF4f?6?$AA@ ; `string'
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 16					; 00000010H

; 1680 : 		file.Printf( "-------------------------------------------------------------------------------\n" );

	push	OFFSET FLAT:??_C@_0FB@PMEA@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1681 : 	}

	jmp	$L37958
$L37959:

; 1682 : 
; 1683 : 	file.Printf( "\n\n" );

	push	OFFSET FLAT:??_C@_02JJJH@?6?6?$AA@	; `string'
	lea	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1684 : 
; 1685 : 	// Automatically recognize WATER nodes and drop the LAND nodes to the floor.
; 1686 : 	//
; 1687 : 	for ( i = 0; i < WorldGraph.m_cNodes; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L37970
$L37971:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L37970:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	jge	$L37972

; 1689 : 		if (WorldGraph.m_pNodes[ i ].m_afNodeInfo & bits_NODE_AIR)

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	eax, DWORD PTR [edx+ecx+28]
	and	eax, 2
	test	eax, eax
	je	SHORT $L37973

; 1693 : 		else if (UTIL_PointContents(WorldGraph.m_pNodes[ i ].m_vecOrigin) == CONTENTS_WATER)

	jmp	$L37976
$L37973:
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	add	edx, ecx
	push	edx
	call	?UTIL_PointContents@@YAHABVVector@@@Z	; UTIL_PointContents
	add	esp, 4
	cmp	eax, -3					; fffffffdH
	jne	SHORT $L37975

; 1695 : 			WorldGraph.m_pNodes[ i ].m_afNodeInfo |= bits_NODE_WATER;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	edx, DWORD PTR [ecx+eax+28]
	or	edx, 4
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	DWORD PTR [ecx+eax+28], edx

; 1697 : 		else

	jmp	$L37976
$L37975:

; 1699 : 			WorldGraph.m_pNodes[ i ].m_afNodeInfo |= bits_NODE_LAND;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	ecx, DWORD PTR [eax+edx+28]
	or	ecx, 1
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	DWORD PTR [eax+edx+28], ecx

; 1700 : 
; 1701 : 			// trace to the ground, then pop up 8 units and place node there to make it
; 1702 : 			// easier for them to connect (think stairs, chairs, and bumps in the floor).
; 1703 : 			// After the routing is done, push them back down.
; 1704 : 			//
; 1705 : 			TraceResult	tr;

	lea	ecx, DWORD PTR _tr$37977[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1706 : 
; 1707 : 			UTIL_TraceLine ( WorldGraph.m_pNodes[i].m_vecOrigin,
; 1708 : 							 WorldGraph.m_pNodes[i].m_vecOrigin - Vector ( 0, 0, 384 ),
; 1709 : 							 ignore_monsters,
; 1710 : 							 g_pBodyQueueHead,//!!!HACKHACK no real ent to supply here, using a global we don't care about
; 1711 : 							 &tr );

	lea	ecx, DWORD PTR _tr$37977[ebp]
	push	ecx
	mov	edx, DWORD PTR ?g_pBodyQueueHead@@3PAUedict_s@@A ; g_pBodyQueueHead
	push	edx
	push	1
	push	1136656384				; 43c00000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T40095[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T40096[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	add	ecx, edx
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	add	ecx, eax
	push	ecx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 1712 : 
; 1713 : 			// This trace is ONLY used if we hit an entity flagged with FL_WORLDBRUSH
; 1714 : 			TraceResult	trEnt;

	lea	ecx, DWORD PTR _trEnt$37980[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1715 : 			UTIL_TraceLine ( WorldGraph.m_pNodes[i].m_vecOrigin,
; 1716 : 				 WorldGraph.m_pNodes[i].m_vecOrigin - Vector ( 0, 0, 384 ),
; 1717 : 				 dont_ignore_monsters,
; 1718 : 				 g_pBodyQueueHead,//!!!HACKHACK no real ent to supply here, using a global we don't care about
; 1719 : 				 &trEnt );

	lea	edx, DWORD PTR _trEnt$37980[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_pBodyQueueHead@@3PAUedict_s@@A ; g_pBodyQueueHead
	push	eax
	push	0
	push	1136656384				; 43c00000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T40097[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T40098[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	add	ecx, edx
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	add	ecx, eax
	push	ecx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 1720 : 
; 1721 : 			
; 1722 : 			// Did we hit something closer than the floor?
; 1723 : 			if ( trEnt.flFraction < tr.flFraction )

	fld	DWORD PTR _trEnt$37980[ebp+16]
	fcomp	DWORD PTR _tr$37977[ebp+16]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37984

; 1725 : 				// If it was a world brush entity, copy the node location
; 1726 : 				if ( trEnt.pHit && (trEnt.pHit->v.flags & FL_WORLDBRUSH) )

	cmp	DWORD PTR _trEnt$37980[ebp+48], 0
	je	SHORT $L37984
	mov	edx, DWORD PTR _trEnt$37980[ebp+48]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	je	SHORT $L37984

; 1727 : 					tr.vecEndPos = trEnt.vecEndPos;

	mov	ecx, DWORD PTR _trEnt$37980[ebp+20]
	mov	DWORD PTR _tr$37977[ebp+20], ecx
	mov	edx, DWORD PTR _trEnt$37980[ebp+24]
	mov	DWORD PTR _tr$37977[ebp+24], edx
	mov	eax, DWORD PTR _trEnt$37980[ebp+28]
	mov	DWORD PTR _tr$37977[ebp+28], eax
$L37984:

; 1731 : 				WorldGraph.m_pNodes[i].m_vecOrigin.z = tr.vecEndPos.z + NODE_HEIGHT;

	fld	DWORD PTR _tr$37977[ebp+28]
	fadd	DWORD PTR __real@4@40028000000000000000
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	fstp	DWORD PTR [edx+ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	esi, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	eax, DWORD PTR [esi+eax+8]
	mov	DWORD PTR [edx+ecx+20], eax
$L37976:

; 1733 : 	}

	jmp	$L37971
$L37972:

; 1734 : 
; 1735 : 	cPoolLinks = WorldGraph.LinkVisibleNodes( pTempPool, &file, &iBadNode );

	lea	ecx, DWORD PTR _iBadNode$[ebp]
	push	ecx
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTempPool$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?LinkVisibleNodes@CGraph@@QAEHPAVCLink@@PAVCVirtualFS@@PAH@Z ; CGraph::LinkVisibleNodes
	mov	DWORD PTR _cPoolLinks$[ebp], eax

; 1736 : 	
; 1737 : 	if ( !cPoolLinks )

	cmp	DWORD PTR _cPoolLinks$[ebp], 0
	jne	$L37985

; 1739 : 		ALERT ( at_aiconsole, "**ConnectVisibleNodes FAILED!\n" );

	push	OFFSET FLAT:??_C@_0BP@MGAF@?$CK?$CKConnectVisibleNodes?5FAILED?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1740 : 		
; 1741 : 		SetThink ( ShowBadNode );// send the hull off to show the offending node.

	push	OFFSET FLAT:??_C@_0M@BGNE@ShowBadNode?$AA@ ; `string'
	push	OFFSET FLAT:?ShowBadNode@CTestHull@@QAEXXZ ; CTestHull::ShowBadNode
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1742 : 		SetAbsOrigin( WorldGraph.m_pNodes[ iBadNode ].m_vecOrigin );

	mov	ecx, DWORD PTR _iBadNode$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	add	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 1743 : 		
; 1744 : 		if ( pTempPool )

	cmp	DWORD PTR _pTempPool$[ebp], 0
	je	SHORT $L37989

; 1746 : 			free ( pTempPool );

	mov	eax, DWORD PTR _pTempPool$[ebp]
	push	eax
	call	_free
	add	esp, 4
$L37989:

; 1748 : 
; 1749 : 		// dump the report onto disk
; 1750 : 		SAVE_FILE( szNrpFilename, file.GetBuffer(), file.GetSize( ));

	lea	ecx, DWORD PTR _file$[ebp]
	call	?GetSize@CVirtualFS@@QAEIXZ		; CVirtualFS::GetSize
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?GetBuffer@CVirtualFS@@QAEPADXZ		; CVirtualFS::GetBuffer
	push	eax
	lea	ecx, DWORD PTR _szNrpFilename$[ebp]
	push	ecx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+112
	add	esp, 12					; 0000000cH

; 1751 : 
; 1752 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	jmp	$L37918
$L37985:

; 1754 : 
; 1755 : // send the walkhull to all of this node's connections now. We'll do this here since
; 1756 : // so much of it relies on being able to control the test hull.
; 1757 : 	file.Printf( "----------------------------------------------------------------------------\n" );

	push	OFFSET FLAT:??_C@_0EO@NCEO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1758 : 	file.Printf( "Walk Rejection:\n");

	push	OFFSET FLAT:??_C@_0BB@BPJN@Walk?5Rejection?3?6?$AA@ ; `string'
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1759 : 
; 1760 : 	for ( i = 0 ; i < WorldGraph.m_cNodes ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L37991
$L37992:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L37991:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	jge	$L37993

; 1762 : 		pSrcNode = &WorldGraph.m_pNodes[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	add	ecx, eax
	mov	DWORD PTR _pSrcNode$[ebp], ecx

; 1763 : 
; 1764 : 		file.Printf( "-------------------------------------------------------------------------------\n");

	push	OFFSET FLAT:??_C@_0FB@PMEA@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1765 : 		file.Printf( "Node %4d:\n\n", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0M@GDCA@Node?5?$CF4d?3?6?6?$AA@ ; `string'
	lea	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 1766 : 		
; 1767 : 		for ( j = 0 ; j < pSrcNode->m_cNumLinks ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L37995
$L37996:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L37995:
	mov	eax, DWORD PTR _pSrcNode$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	$L37997

; 1769 : 			// assume that all hulls can walk this link, then eliminate the ones that can't.
; 1770 : 			pTempPool [ pSrcNode->m_iFirstLink + j ].m_afLinkInfo = bits_LINK_SMALL_HULL | bits_LINK_HUMAN_HULL | bits_LINK_LARGE_HULL | bits_LINK_FLY_HULL;

	mov	edx, DWORD PTR _pSrcNode$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, DWORD PTR _j$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _pTempPool$[ebp]
	mov	DWORD PTR [ecx+eax+16], 15		; 0000000fH

; 1771 : 
; 1772 : 
; 1773 : 			// do a check for each hull size.
; 1774 : 			
; 1775 : 			// if we can't fit a tiny hull through a connection, no other hulls with fit either, so we 
; 1776 : 			// should just fall out of the loop. Do so by setting the SkipRemainingHulls flag.
; 1777 : 			fSkipRemainingHulls = FALSE;

	mov	DWORD PTR _fSkipRemainingHulls$[ebp], 0

; 1778 : 			for ( hull = 0 ; hull < MAX_NODE_HULLS; hull++ )

	mov	DWORD PTR _hull$[ebp], 0
	jmp	SHORT $L37998
$L37999:
	mov	edx, DWORD PTR _hull$[ebp]
	add	edx, 1
	mov	DWORD PTR _hull$[ebp], edx
$L37998:
	cmp	DWORD PTR _hull$[ebp], 4
	jge	$L38000

; 1780 : 				if (fSkipRemainingHulls && (hull == NODE_HUMAN_HULL || hull == NODE_LARGE_HULL)) // skip the remaining walk hulls

	cmp	DWORD PTR _fSkipRemainingHulls$[ebp], 0
	je	SHORT $L38001
	cmp	DWORD PTR _hull$[ebp], 1
	je	SHORT $L38002
	cmp	DWORD PTR _hull$[ebp], 2
	jne	SHORT $L38001
$L38002:

; 1781 : 					continue;

	jmp	SHORT $L37999
$L38001:

; 1784 : 				{

	mov	eax, DWORD PTR _hull$[ebp]
	mov	DWORD PTR -940+[ebp], eax
	cmp	DWORD PTR -940+[ebp], 3
	ja	$L38004
	mov	ecx, DWORD PTR -940+[ebp]
	jmp	DWORD PTR $L40120[ecx*4]
$L38007:

; 1785 : 				case NODE_SMALL_HULL:
; 1786 : 					UTIL_SetSize(pev, Vector(-12, -12, 0), Vector(12, 12, 24));

	push	1103101952				; 41c00000H
	push	1094713344				; 41400000H
	push	1094713344				; 41400000H
	lea	ecx, DWORD PTR $T40099[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	push	0
	push	-1052770304				; c1400000H
	push	-1052770304				; c1400000H
	lea	ecx, DWORD PTR $T40100[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 1787 : 					break;

	jmp	$L38004
$L38010:

; 1788 : 				case NODE_HUMAN_HULL:
; 1789 : 					UTIL_SetSize(pev, VEC_HUMAN_HULL_MIN, VEC_HUMAN_HULL_MAX );

	push	1116733440				; 42900000H
	push	1098907648				; 41800000H
	push	1098907648				; 41800000H
	lea	ecx, DWORD PTR $T40101[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	push	0
	push	-1048576000				; c1800000H
	push	-1048576000				; c1800000H
	lea	ecx, DWORD PTR $T40102[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 1790 : 					break;

	jmp	$L38004
$L38013:

; 1791 : 				case NODE_LARGE_HULL:
; 1792 : 					UTIL_SetSize(pev, Vector(-32, -32, 0), Vector(32, 32, 64));

	push	1115684864				; 42800000H
	push	1107296256				; 42000000H
	push	1107296256				; 42000000H
	lea	ecx, DWORD PTR $T40103[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	push	0
	push	-1040187392				; c2000000H
	push	-1040187392				; c2000000H
	lea	ecx, DWORD PTR $T40104[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 1793 : 					break;

	jmp	SHORT $L38004
$L38016:

; 1794 : 				case NODE_FLY_HULL:
; 1795 : 					UTIL_SetSize(pev, Vector(-32, -32, 0), Vector(32, 32, 64));

	push	1115684864				; 42800000H
	push	1107296256				; 42000000H
	push	1107296256				; 42000000H
	lea	ecx, DWORD PTR $T40105[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	push	0
	push	-1040187392				; c2000000H
	push	-1040187392				; c2000000H
	lea	ecx, DWORD PTR $T40106[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH
$L38004:

; 1799 : 
; 1800 : 				UTIL_SetOrigin ( this, pSrcNode->m_vecOrigin );// place the hull on the node

	mov	ecx, DWORD PTR _pSrcNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 1801 : 
; 1802 : 				if ( !FBitSet ( pev->flags, FL_ONGROUND ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	jne	SHORT $L38019

; 1804 : 					ALERT ( at_aiconsole, "OFFGROUND!\n" );

	push	OFFSET FLAT:??_C@_0M@OHEO@OFFGROUND?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L38019:

; 1806 : 
; 1807 : 				// now build a yaw that points to the dest node, and get the distance.
; 1808 : 				if ( j < 0 )

	cmp	DWORD PTR _j$[ebp], 0
	jge	SHORT $L38021

; 1810 : 					ALERT ( at_aiconsole, "**** j = %d ****\n", j );

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BC@BJIG@?$CK?$CK?$CK?$CK?5j?5?$DN?5?$CFd?5?$CK?$CK?$CK?$CK?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1811 : 					if ( pTempPool )

	cmp	DWORD PTR _pTempPool$[ebp], 0
	je	SHORT $L38023

; 1813 : 						free ( pTempPool );

	mov	ecx, DWORD PTR _pTempPool$[ebp]
	push	ecx
	call	_free
	add	esp, 4
$L38023:

; 1815 : 
; 1816 : 					// dump the report onto disk
; 1817 : 					SAVE_FILE( szNrpFilename, file.GetBuffer(), file.GetSize( ));

	lea	ecx, DWORD PTR _file$[ebp]
	call	?GetSize@CVirtualFS@@QAEIXZ		; CVirtualFS::GetSize
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?GetBuffer@CVirtualFS@@QAEPADXZ		; CVirtualFS::GetBuffer
	push	eax
	lea	edx, DWORD PTR _szNrpFilename$[ebp]
	push	edx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+112
	add	esp, 12					; 0000000cH

; 1818 : 					return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	jmp	$L37918
$L38021:

; 1820 : 				
; 1821 : 				pDestNode = &WorldGraph.m_pNodes [ pTempPool[ pSrcNode->m_iFirstLink + j ].m_iDestNode ];

	mov	eax, DWORD PTR _pSrcNode$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pTempPool$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	add	ecx, eax
	mov	DWORD PTR _pDestNode$[ebp], ecx

; 1822 : 
; 1823 : 				vecSpot = pDestNode->m_vecOrigin;

	mov	edx, DWORD PTR _pDestNode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _vecSpot$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _vecSpot$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _vecSpot$[ebp+8], edx

; 1824 : 
; 1825 : 				if (hull < NODE_FLY_HULL)

	cmp	DWORD PTR _hull$[ebp], 3
	jge	$L38024

; 1827 : 					int SaveFlags = pev->flags;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	mov	DWORD PTR _SaveFlags$38025[ebp], edx

; 1828 : 					int MoveMode = WALKMOVE_WORLDONLY;

	mov	DWORD PTR _MoveMode$38026[ebp], 1

; 1829 : 					if (pSrcNode->m_afNodeInfo & bits_NODE_WATER)

	mov	eax, DWORD PTR _pSrcNode$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 4
	test	ecx, ecx
	je	SHORT $L38027

; 1831 : 						pev->flags |= FL_SWIM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx

; 1832 : 						MoveMode = WALKMOVE_NORMAL;

	mov	DWORD PTR _MoveMode$38026[ebp], 0
$L38027:

; 1834 : 
; 1835 : 					flYaw = UTIL_VecToYaw ( pDestNode->m_vecOrigin - GetAbsOrigin() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T40107[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDestNode$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	call	?UTIL_VecToYaw@@YAMABVVector@@@Z	; UTIL_VecToYaw
	add	esp, 4
	fstp	DWORD PTR _flYaw$[ebp]

; 1836 : 
; 1837 : 					flDist = ( vecSpot - GetAbsOrigin() ).Length2D();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T40108[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecSpot$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length2D@Vector@@QBEMXZ		; Vector::Length2D
	fstp	DWORD PTR _flDist$[ebp]

; 1838 : 
; 1839 : 					int fWalkFailed = FALSE;

	mov	DWORD PTR _fWalkFailed$38030[ebp], 0

; 1840 : 
; 1841 : 					// in this loop we take tiny steps from the current node to the nodes that it links to, one at a time.
; 1842 : 					for ( step = 0 ; step < flDist && !fWalkFailed ; step += HULL_STEP_SIZE )

	mov	DWORD PTR _step$[ebp], 0
	jmp	SHORT $L38031
$L38032:
	mov	eax, DWORD PTR _step$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _step$[ebp], eax
$L38031:
	fild	DWORD PTR _step$[ebp]
	fcomp	DWORD PTR _flDist$[ebp]
	fnstsw	ax
	test	ah, 1
	je	$L38033
	cmp	DWORD PTR _fWalkFailed$38030[ebp], 0
	jne	$L38033

; 1844 : 						float stepSize = HULL_STEP_SIZE;

	mov	DWORD PTR _stepSize$38034[ebp], 1098907648 ; 41800000H

; 1845 : 
; 1846 : 						if ( (step + stepSize) >= (flDist-1) )

	fild	DWORD PTR _step$[ebp]
	fadd	DWORD PTR _stepSize$38034[ebp]
	fld	DWORD PTR _flDist$[ebp]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38035

; 1847 : 							stepSize = (flDist - step) - 1;

	fild	DWORD PTR _step$[ebp]
	fsubr	DWORD PTR _flDist$[ebp]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _stepSize$38034[ebp]
$L38035:

; 1848 : 
; 1849 : 						if ( !WALK_MOVE( ENT(pev), flYaw, stepSize, MoveMode ) )

	mov	ecx, DWORD PTR _MoveMode$38026[ebp]
	push	ecx
	mov	edx, DWORD PTR _stepSize$38034[ebp]
	push	edx
	mov	eax, DWORD PTR _flYaw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+108
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L38036

; 1851 : 
; 1852 : 							fWalkFailed = TRUE;

	mov	DWORD PTR _fWalkFailed$38030[ebp], 1

; 1853 : 							break;

	jmp	SHORT $L38033
$L38036:

; 1855 : 					}

	jmp	$L38032
$L38033:

; 1856 : 
; 1857 : 					if (!fWalkFailed && (GetAbsOrigin() - vecSpot).Length() > 64)

	cmp	DWORD PTR _fWalkFailed$38030[ebp], 0
	jne	SHORT $L38038
	lea	eax, DWORD PTR _vecSpot$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40109[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fcomp	DWORD PTR __real@4@40058000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38038

; 1859 : 						// ALERT( at_console, "bogus walk\n");
; 1860 : 						// we thought we 
; 1861 : 						fWalkFailed = TRUE;

	mov	DWORD PTR _fWalkFailed$38030[ebp], 1
$L38038:

; 1863 : 
; 1864 : 					if (fWalkFailed)

	cmp	DWORD PTR _fWalkFailed$38030[ebp], 0
	je	$L38041

; 1871 : 						{

	mov	edx, DWORD PTR _hull$[ebp]
	mov	DWORD PTR -944+[ebp], edx
	cmp	DWORD PTR -944+[ebp], 0
	je	SHORT $L38044
	cmp	DWORD PTR -944+[ebp], 1
	je	SHORT $L38046
	cmp	DWORD PTR -944+[ebp], 2
	je	$L38048
	jmp	$L38041
$L38044:

; 1872 : 						case NODE_SMALL_HULL:	// if this hull can't fit, nothing can, so drop the connection
; 1873 : 							file.Printf( "NODE_SMALL_HULL step %f\n", step );

	mov	eax, DWORD PTR _step$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BJ@LPFE@NODE_SMALL_HULL?5step?5?$CFf?6?$AA@ ; `string'
	lea	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 1874 : 							pTempPool[ pSrcNode->m_iFirstLink + j ].m_afLinkInfo &= ~(bits_LINK_SMALL_HULL | bits_LINK_HUMAN_HULL | bits_LINK_LARGE_HULL);

	mov	edx, DWORD PTR _pSrcNode$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, DWORD PTR _j$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _pTempPool$[ebp]
	mov	edx, DWORD PTR [ecx+eax+16]
	and	edx, -8					; fffffff8H
	mov	eax, DWORD PTR _pSrcNode$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 24					; 00000018H
	mov	eax, DWORD PTR _pTempPool$[ebp]
	mov	DWORD PTR [eax+ecx+16], edx

; 1875 : 							fSkipRemainingHulls = TRUE;// don't bother checking larger hulls

	mov	DWORD PTR _fSkipRemainingHulls$[ebp], 1

; 1876 : 							break;

	jmp	$L38041
$L38046:

; 1877 : 						case NODE_HUMAN_HULL:
; 1878 : 							file.Printf( "NODE_HUMAN_HULL step %f\n", step );

	mov	ecx, DWORD PTR _step$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BJ@GN@NODE_HUMAN_HULL?5step?5?$CFf?6?$AA@ ; `string'
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 1879 : 							pTempPool[ pSrcNode->m_iFirstLink + j ].m_afLinkInfo &= ~(bits_LINK_HUMAN_HULL | bits_LINK_LARGE_HULL);

	mov	eax, DWORD PTR _pSrcNode$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pTempPool$[ebp]
	mov	eax, DWORD PTR [edx+ecx+16]
	and	al, -7					; fffffff9H
	mov	ecx, DWORD PTR _pSrcNode$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, DWORD PTR _j$[ebp]
	imul	edx, 24					; 00000018H
	mov	ecx, DWORD PTR _pTempPool$[ebp]
	mov	DWORD PTR [ecx+edx+16], eax

; 1880 : 							fSkipRemainingHulls = TRUE;// don't bother checking larger hulls

	mov	DWORD PTR _fSkipRemainingHulls$[ebp], 1

; 1881 : 							break;

	jmp	SHORT $L38041
$L38048:

; 1882 : 						case NODE_LARGE_HULL:
; 1883 : 							file.Printf( "NODE_LARGE_HULL step %f\n", step );

	mov	edx, DWORD PTR _step$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BJ@EJDC@NODE_LARGE_HULL?5step?5?$CFf?6?$AA@ ; `string'
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 1884 : 							pTempPool[ pSrcNode->m_iFirstLink + j ].m_afLinkInfo &= ~bits_LINK_LARGE_HULL;

	mov	ecx, DWORD PTR _pSrcNode$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, DWORD PTR _j$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pTempPool$[ebp]
	mov	ecx, DWORD PTR [eax+edx+16]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _pSrcNode$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, DWORD PTR _j$[ebp]
	imul	eax, 24					; 00000018H
	mov	edx, DWORD PTR _pTempPool$[ebp]
	mov	DWORD PTR [edx+eax+16], ecx
$L38041:

; 1888 : 					pev->flags = SaveFlags;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _SaveFlags$38025[ebp]
	mov	DWORD PTR [ecx+420], edx

; 1890 : 				else

	jmp	$L38056
$L38024:

; 1892 : 					TraceResult tr;

	lea	ecx, DWORD PTR _tr$38051[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1893 : 
; 1894 : 					UTIL_TraceHull( pSrcNode->m_vecOrigin + Vector( 0, 0, 32 ), pDestNode->m_vecOriginPeek + Vector( 0, 0, 32 ), ignore_monsters, large_hull, ENT( pev ), &tr );

	lea	eax, DWORD PTR _tr$38051[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	2
	push	1
	push	1107296256				; 42000000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T40110[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T40111[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDestNode$[ebp]
	add	ecx, 12					; 0000000cH
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	push	1107296256				; 42000000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T40112[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T40113[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pSrcNode$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	call	?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceHull
	add	esp, 24					; 00000018H

; 1895 : 					if (tr.fStartSolid || tr.flFraction < 1.0)

	cmp	DWORD PTR _tr$38051[ebp+4], 0
	jne	SHORT $L38057
	fld	DWORD PTR _tr$38051[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38056
$L38057:

; 1897 : 						pTempPool[ pSrcNode->m_iFirstLink + j ].m_afLinkInfo &= ~bits_LINK_FLY_HULL;

	mov	edx, DWORD PTR _pSrcNode$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, DWORD PTR _j$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _pTempPool$[ebp]
	mov	edx, DWORD PTR [ecx+eax+16]
	and	edx, -9					; fffffff7H
	mov	eax, DWORD PTR _pSrcNode$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 24					; 00000018H
	mov	eax, DWORD PTR _pTempPool$[ebp]
	mov	DWORD PTR [eax+ecx+16], edx
$L38056:

; 1900 : 			}

	jmp	$L37999
$L38000:

; 1901 : 
; 1902 : 			if (pTempPool[ pSrcNode->m_iFirstLink + j ].m_afLinkInfo == 0)

	mov	ecx, DWORD PTR _pSrcNode$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, DWORD PTR _j$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pTempPool$[ebp]
	cmp	DWORD PTR [eax+edx+16], 0
	jne	$L38058

; 1904 : 				file.Printf( "Rejected Node %3d - Unreachable by ", pTempPool [ pSrcNode->m_iFirstLink + j ].m_iDestNode );

	mov	ecx, DWORD PTR _pSrcNode$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, DWORD PTR _j$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pTempPool$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	push	OFFSET FLAT:??_C@_0CE@DEFK@Rejected?5Node?5?$CF3d?5?9?5Unreachable?5@ ; `string'
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 1905 : 				pTempPool[ pSrcNode->m_iFirstLink + j ] = pTempPool [ pSrcNode->m_iFirstLink + ( pSrcNode->m_cNumLinks - 1 ) ];

	mov	eax, DWORD PTR _pSrcNode$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _pSrcNode$[ebp]
	mov	eax, DWORD PTR [edx+36]
	lea	ecx, DWORD PTR [eax+ecx-1]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _pTempPool$[ebp]
	add	esi, ecx
	mov	edx, DWORD PTR _pSrcNode$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, DWORD PTR _j$[ebp]
	imul	eax, 24					; 00000018H
	mov	edi, DWORD PTR _pTempPool$[ebp]
	add	edi, eax
	mov	ecx, 6
	rep movsd

; 1906 : 				file.Printf( "Any Hull\n" );

	push	OFFSET FLAT:??_C@_09ECJA@Any?5Hull?6?$AA@ ; `string'
	lea	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1907 : 				
; 1908 : 				pSrcNode->m_cNumLinks--;

	mov	edx, DWORD PTR _pSrcNode$[ebp]
	mov	eax, DWORD PTR [edx+32]
	sub	eax, 1
	mov	ecx, DWORD PTR _pSrcNode$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 1909 : 				cPoolLinks--;// we just removed a link, so decrement the total number of links in the pool.

	mov	edx, DWORD PTR _cPoolLinks$[ebp]
	sub	edx, 1
	mov	DWORD PTR _cPoolLinks$[ebp], edx

; 1910 : 				j--;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L38058:

; 1912 : 
; 1913 : 		}

	jmp	$L37996
$L37997:

; 1914 : 	}

	jmp	$L37992
$L37993:

; 1915 : 	file.Printf( "-------------------------------------------------------------------------------\n\n\n");

	push	OFFSET FLAT:??_C@_0FD@OAIO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	lea	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1916 : 
; 1917 : 	cPoolLinks -= WorldGraph.RejectInlineLinks ( pTempPool, &file );

	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTempPool$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?RejectInlineLinks@CGraph@@QAEHPAVCLink@@PAVCVirtualFS@@@Z ; CGraph::RejectInlineLinks
	mov	ecx, DWORD PTR _cPoolLinks$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _cPoolLinks$[ebp], ecx

; 1918 : 
; 1919 : 	// now malloc a pool just large enough to hold the links that are actually used
; 1920 : 	WorldGraph.m_pLinkPool = (CLink *) calloc ( sizeof ( CLink ), cPoolLinks );

	mov	edx, DWORD PTR _cPoolLinks$[ebp]
	push	edx
	push	24					; 00000018H
	call	_calloc
	add	esp, 8
	mov	DWORD PTR ?WorldGraph@@3VCGraph@@A+16, eax

; 1921 : 
; 1922 : 	if ( !WorldGraph.m_pLinkPool )

	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A+16, 0
	jne	SHORT $L38064

; 1924 : 		// couldn't make the link pool!
; 1925 : 		ALERT ( at_aiconsole, "Couldn't malloc LinkPool!\n" );

	push	OFFSET FLAT:??_C@_0BL@FKJF@Couldn?8t?5malloc?5LinkPool?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1926 : 		if ( pTempPool )

	cmp	DWORD PTR _pTempPool$[ebp], 0
	je	SHORT $L38066

; 1928 : 			free ( pTempPool );

	mov	eax, DWORD PTR _pTempPool$[ebp]
	push	eax
	call	_free
	add	esp, 4
$L38066:

; 1930 : 
; 1931 : 		// dump the report onto disk
; 1932 : 		SAVE_FILE( szNrpFilename, file.GetBuffer(), file.GetSize( ));

	lea	ecx, DWORD PTR _file$[ebp]
	call	?GetSize@CVirtualFS@@QAEIXZ		; CVirtualFS::GetSize
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?GetBuffer@CVirtualFS@@QAEPADXZ		; CVirtualFS::GetBuffer
	push	eax
	lea	ecx, DWORD PTR _szNrpFilename$[ebp]
	push	ecx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+112
	add	esp, 12					; 0000000cH

; 1933 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	jmp	$L37918
$L38064:

; 1935 : 	WorldGraph.m_cLinks = cPoolLinks;

	mov	edx, DWORD PTR _cPoolLinks$[ebp]
	mov	DWORD PTR ?WorldGraph@@3VCGraph@@A+28, edx

; 1936 : 
; 1937 : 	// copy only the used portions of the TempPool into the graph's link pool
; 1938 : 	int iFinalPoolIndex = 0;

	mov	DWORD PTR _iFinalPoolIndex$[ebp], 0

; 1939 : 	int iOldFirstLink;
; 1940 : 
; 1941 : 	for ( i = 0 ; i < WorldGraph.m_cNodes ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38069
$L38070:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38069:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	jge	$L38071

; 1943 : 		iOldFirstLink = WorldGraph.m_pNodes[ i ].m_iFirstLink;// store this, because we have to re-assign it before entering the copy loop

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	ecx, DWORD PTR [eax+edx+36]
	mov	DWORD PTR _iOldFirstLink$[ebp], ecx

; 1944 : 
; 1945 : 		WorldGraph.m_pNodes[ i ].m_iFirstLink = iFinalPoolIndex;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	ecx, DWORD PTR _iFinalPoolIndex$[ebp]
	mov	DWORD PTR [eax+edx+36], ecx

; 1946 : 
; 1947 : 		for ( j = 0 ; j < WorldGraph.m_pNodes[ i ].m_cNumLinks ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L38072
$L38073:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L38072:
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+32]
	jge	SHORT $L38074

; 1949 : 			WorldGraph.m_pLinkPool[ iFinalPoolIndex++ ] = pTempPool[ iOldFirstLink + j ];

	mov	eax, DWORD PTR _iOldFirstLink$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _pTempPool$[ebp]
	add	esi, eax
	mov	ecx, DWORD PTR _iFinalPoolIndex$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edi, DWORD PTR ?WorldGraph@@3VCGraph@@A+16
	add	edi, ecx
	mov	ecx, 6
	rep movsd
	mov	edx, DWORD PTR _iFinalPoolIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _iFinalPoolIndex$[ebp], edx

; 1950 : 		}

	jmp	SHORT $L38073
$L38074:

; 1951 : 	}

	jmp	$L38070
$L38071:

; 1952 : 	
; 1953 : 	// Node sorting numbers linked nodes close to each other
; 1954 : 	//
; 1955 : 	WorldGraph.SortNodes();

	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?SortNodes@CGraph@@QAEXXZ		; CGraph::SortNodes

; 1956 : 
; 1957 : 	// This is used for HashSearch
; 1958 : 	//
; 1959 : 	WorldGraph.BuildLinkLookups();

	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?BuildLinkLookups@CGraph@@QAEXXZ	; CGraph::BuildLinkLookups

; 1960 : 
; 1961 : 	fPairsValid = TRUE; // assume that the connection pairs are all valid to start

	mov	DWORD PTR _fPairsValid$[ebp], 1

; 1962 : 
; 1963 : 	file.Printf( "\n\n-------------------------------------------------------------------------------\n");

	push	OFFSET FLAT:??_C@_0FD@BEFM@?6?6?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1964 : 	file.Printf( "Link Pairings:\n");

	push	OFFSET FLAT:??_C@_0BA@JFHC@Link?5Pairings?3?6?$AA@ ; `string'
	lea	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1965 : 
; 1966 : // link integrity check. The idea here is that if Node A links to Node B, node B should
; 1967 : // link to node A. If not, we have a situation that prevents us from using a basic 
; 1968 : // optimization in the FindNearestLink function. 
; 1969 : 	for ( i = 0 ; i < WorldGraph.m_cNodes ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38077
$L38078:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L38077:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	jge	$L38079

; 1971 : 		for ( j = 0 ; j < WorldGraph.m_pNodes[ i ].m_cNumLinks ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L38080
$L38081:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L38080:
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+32]
	jge	SHORT $L38082

; 1973 : 			int iLink;
; 1974 : 			WorldGraph.HashSearch(WorldGraph.INodeLink(i,j), i, iLink);

	lea	edx, DWORD PTR _iLink$38083[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?INodeLink@CGraph@@QAEHHH@Z		; CGraph::INodeLink
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?HashSearch@CGraph@@QAEXHHAAH@Z		; CGraph::HashSearch

; 1975 : 			if (iLink < 0)

	cmp	DWORD PTR _iLink$38083[ebp], 0
	jge	SHORT $L38084

; 1977 : 				fPairsValid = FALSE;// unmatched link pair.

	mov	DWORD PTR _fPairsValid$[ebp], 0

; 1978 : 				file.Printf( "WARNING: Node %3d does not connect back to Node %3d\n", WorldGraph.INodeLink(i, j), i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?INodeLink@CGraph@@QAEHHH@Z		; CGraph::INodeLink
	push	eax
	push	OFFSET FLAT:??_C@_0DF@ECLH@WARNING?3?5Node?5?$CF3d?5does?5not?5conne@ ; `string'
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 16					; 00000010H
$L38084:

; 1980 : 		}

	jmp	$L38081
$L38082:

; 1981 : 	}

	jmp	$L38078
$L38079:

; 1982 : 
; 1983 : 	// !!!LATER - if all connections are properly paired, when can enable an optimization in the pathfinding code
; 1984 : 	// (in the find nearest line function)
; 1985 : 	if ( fPairsValid )

	cmp	DWORD PTR _fPairsValid$[ebp], 0
	je	SHORT $L38086

; 1987 : 		file.Printf( "\nAll Connections are Paired!\n");

	push	OFFSET FLAT:??_C@_0BO@GHBB@?6All?5Connections?5are?5Paired?$CB?6?$AA@ ; `string'
	lea	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8
$L38086:

; 1989 : 
; 1990 : 	file.Printf( "-------------------------------------------------------------------------------\n");

	push	OFFSET FLAT:??_C@_0FB@PMEA@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1991 : 	file.Printf( "\n\n-------------------------------------------------------------------------------\n");

	push	OFFSET FLAT:??_C@_0FD@BEFM@?6?6?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1992 : 	file.Printf( "Total Number of Connections in Pool: %d\n", cPoolLinks );

	mov	ecx, DWORD PTR _cPoolLinks$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CJ@IKOB@Total?5Number?5of?5Connections?5in?5P@ ; `string'
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 1993 : 	file.Printf( "-------------------------------------------------------------------------------\n");

	push	OFFSET FLAT:??_C@_0FB@PMEA@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1994 : 	file.Printf( "Connection Pool: %d bytes\n", sizeof ( CLink ) * cPoolLinks );

	mov	ecx, DWORD PTR _cPoolLinks$[ebp]
	imul	ecx, 24					; 00000018H
	push	ecx
	push	OFFSET FLAT:??_C@_0BL@LCPH@Connection?5Pool?3?5?$CFd?5bytes?6?$AA@ ; `string'
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 12					; 0000000cH

; 1995 : 	file.Printf( "-------------------------------------------------------------------------------\n");

	push	OFFSET FLAT:??_C@_0FB@PMEA@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?Printf@CVirtualFS@@QAAIPBDZZ		; CVirtualFS::Printf
	add	esp, 8

; 1996 : 
; 1997 : 
; 1998 : 	ALERT ( at_aiconsole, "%d Nodes, %d Connections\n", WorldGraph.m_cNodes, cPoolLinks );

	mov	ecx, DWORD PTR _cPoolLinks$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	push	edx
	push	OFFSET FLAT:??_C@_0BK@CALM@?$CFd?5Nodes?0?5?$CFd?5Connections?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 1999 : 	
; 2000 : 	// This is used for FindNearestNode
; 2001 : 	//
; 2002 : 	WorldGraph.BuildRegionTables();

	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?BuildRegionTables@CGraph@@QAEXXZ	; CGraph::BuildRegionTables

; 2003 : 
; 2004 : 
; 2005 : 	// Push all of the LAND nodes down to the ground now. Leave the water and air nodes alone.
; 2006 : 	//
; 2007 : 	for ( i = 0 ; i < WorldGraph.m_cNodes ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38092
$L38093:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38092:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	jge	SHORT $L38094

; 2009 : 		if ((WorldGraph.m_pNodes[ i ].m_afNodeInfo & bits_NODE_LAND))

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	ecx, DWORD PTR [eax+edx+28]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L38095

; 2011 : 			WorldGraph.m_pNodes[ i ].m_vecOrigin.z -= NODE_HEIGHT;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	fld	DWORD PTR [eax+edx+8]
	fsub	DWORD PTR __real@4@40028000000000000000
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	fstp	DWORD PTR [edx+ecx+8]
$L38095:

; 2013 : 	}

	jmp	SHORT $L38093
$L38094:

; 2014 : 
; 2015 : 	if ( pTempPool )

	cmp	DWORD PTR _pTempPool$[ebp], 0
	je	SHORT $L38096

; 2017 : 		// free the temp pool
; 2018 : 		free ( pTempPool );

	mov	eax, DWORD PTR _pTempPool$[ebp]
	push	eax
	call	_free
	add	esp, 4
$L38096:

; 2020 : 
; 2021 : 	// dump the report onto disk
; 2022 : 	SAVE_FILE( szNrpFilename, file.GetBuffer(), file.GetSize( ));

	lea	ecx, DWORD PTR _file$[ebp]
	call	?GetSize@CVirtualFS@@QAEIXZ		; CVirtualFS::GetSize
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?GetBuffer@CVirtualFS@@QAEPADXZ		; CVirtualFS::GetBuffer
	push	eax
	lea	ecx, DWORD PTR _szNrpFilename$[ebp]
	push	ecx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+112
	add	esp, 12					; 0000000cH

; 2023 : 
; 2024 : 	// We now have some graphing capabilities.
; 2025 : 	//
; 2026 : 	WorldGraph.m_fGraphPresent = TRUE;//graph is in memory.

	mov	DWORD PTR ?WorldGraph@@3VCGraph@@A, 1

; 2027 : 	WorldGraph.m_fGraphPointersSet = TRUE;// since the graph was generated, the pointers are ready

	mov	DWORD PTR ?WorldGraph@@3VCGraph@@A+4, 1

; 2028 : 	WorldGraph.m_fRoutingComplete = FALSE; // Optimal routes aren't computed, yet.

	mov	DWORD PTR ?WorldGraph@@3VCGraph@@A+8, 0

; 2029 : 
; 2030 : 	// Compute and compress the routing information.
; 2031 : 	//
; 2032 : 	WorldGraph.ComputeStaticRoutingTables();

	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?ComputeStaticRoutingTables@CGraph@@QAEXXZ ; CGraph::ComputeStaticRoutingTables

; 2033 : 
; 2034 : 	// save the node graph for this level	
; 2035 : 	WorldGraph.FSaveGraph( (char *)STRING( gpGlobals->mapname ) );

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FSaveGraph@CGraph@@QAEHPAD@Z		; CGraph::FSaveGraph

; 2036 : 	ALERT( at_console, "Done.\n");

	push	OFFSET FLAT:??_C@_06JCEA@Done?4?6?$AA@	; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2037 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
$L37918:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L40120:
	DD	$L38007
	DD	$L38010
	DD	$L38013
	DD	$L38016
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BuildNodeGraph@CTestHull@@QAEXXZ$0:
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	ret	0
__ehhandler$?BuildNodeGraph@CTestHull@@QAEXXZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?BuildNodeGraph@CTestHull@@QAEXXZ
	jmp	___CxxFrameHandler
text$x	ENDS
?BuildNodeGraph@CTestHull@@QAEXXZ ENDP			; CTestHull::BuildNodeGraph
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length2D@Vector@@QBEMXZ PROC NEAR			; Vector::Length2D, COMDAT

; 282  : 	inline float Length2D(void) const { return sqrt(x*x + y*y); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length2D@Vector@@QBEMXZ ENDP				; Vector::Length2D
_TEXT	ENDS
;	COMDAT ?GetBuffer@CVirtualFS@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4
?GetBuffer@CVirtualFS@@QAEPADXZ PROC NEAR		; CVirtualFS::GetBuffer, COMDAT

; 27   : 	char *GetBuffer( void ) { return (char *)m_pBuffer; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuffer@CVirtualFS@@QAEPADXZ ENDP			; CVirtualFS::GetBuffer
_TEXT	ENDS
;	COMDAT ?GetSize@CVirtualFS@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetSize@CVirtualFS@@QAEIXZ PROC NEAR			; CVirtualFS::GetSize, COMDAT

; 28   : 	size_t GetSize( void ) { return m_iLength; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@CVirtualFS@@QAEIXZ ENDP			; CVirtualFS::GetSize
_TEXT	ENDS
PUBLIC	??_C@_09FMFO@No?5Path?$CB?6?$AA@		; `string'
PUBLIC	??_C@_03HMFC@?$CFd?6?$AA@			; `string'
;	COMDAT ??_C@_09FMFO@No?5Path?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_09FMFO@No?5Path?$CB?6?$AA@ DB 'No Path!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HMFC@?$CFd?6?$AA@
CONST	SEGMENT
??_C@_03HMFC@?$CFd?6?$AA@ DB '%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?PathFind@CTestHull@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_iPath$ = -204
_iPathSize$ = -208
_i$ = -212
_pNode$ = -216
_pNextNode$ = -220
?PathFind@CTestHull@@QAEXXZ PROC NEAR			; CTestHull::PathFind, COMDAT

; 2044 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2045 : 	int	iPath[ 50 ];
; 2046 : 	int	iPathSize;
; 2047 : 	int	i;
; 2048 : 	CNode	*pNode, *pNextNode;
; 2049 : 
; 2050 : 	if ( !WorldGraph.m_fGraphPresent || !WorldGraph.m_fGraphPointersSet )

	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A, 0
	je	SHORT $L38109
	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A+4, 0
	jne	SHORT $L38108
$L38109:

; 2052 : 		ALERT ( at_aiconsole, "Graph not ready!\n" );

	push	OFFSET FLAT:??_C@_0BC@LJED@Graph?5not?5ready?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2053 : 		return;

	jmp	$L38102
$L38108:

; 2055 : 
; 2056 : 	iPathSize = WorldGraph.FindShortestPath ( iPath, 0, 19, 0, 0 ); // UNDONE use hull constant

	push	0
	push	0
	push	19					; 00000013H
	push	0
	lea	eax, DWORD PTR _iPath$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FindShortestPath@CGraph@@QAEHPAHHHHH@Z	; CGraph::FindShortestPath
	mov	DWORD PTR _iPathSize$[ebp], eax

; 2057 : 
; 2058 : 	if ( !iPathSize )

	cmp	DWORD PTR _iPathSize$[ebp], 0
	jne	SHORT $L38110

; 2060 : 		ALERT ( at_aiconsole, "No Path!\n" );

	push	OFFSET FLAT:??_C@_09FMFO@No?5Path?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2061 : 		return;

	jmp	$L38102
$L38110:

; 2063 : 	
; 2064 : 	ALERT ( at_aiconsole, "%d\n", iPathSize );

	mov	ecx, DWORD PTR _iPathSize$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_03HMFC@?$CFd?6?$AA@	; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2065 : 
; 2066 : 	pNode = &WorldGraph.m_pNodes[ iPath [ 0 ] ];

	mov	edx, DWORD PTR _iPath$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	add	eax, edx
	mov	DWORD PTR _pNode$[ebp], eax

; 2067 : 
; 2068 : 	for ( i = 0 ; i < iPathSize - 1 ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38113
$L38114:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L38113:
	mov	edx, DWORD PTR _iPathSize$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _i$[ebp], edx
	jge	$L38115

; 2070 : 
; 2071 : 		pNextNode = &WorldGraph.m_pNodes[ iPath [ i + 1 ] ];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _iPath$[ebp+eax*4+4]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	add	edx, ecx
	mov	DWORD PTR _pNextNode$[ebp], edx

; 2072 : 
; 2073 : 		MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );

	push	0
	push	0
	push	23					; 00000017H
	push	0
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 2074 : 			WRITE_BYTE( TE_SHOWLINE);

	push	102					; 00000066H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2075 : 			
; 2076 : 			WRITE_COORD( pNode->m_vecOrigin.x );

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2077 : 			WRITE_COORD( pNode->m_vecOrigin.y );

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2078 : 			WRITE_COORD( pNode->m_vecOrigin.z + NODE_HEIGHT );

	mov	ecx, DWORD PTR _pNode$[ebp]
	fld	DWORD PTR [ecx+8]
	fadd	DWORD PTR __real@4@40028000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2079 : 
; 2080 : 			WRITE_COORD( pNextNode->m_vecOrigin.x);

	mov	edx, DWORD PTR _pNextNode$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2081 : 			WRITE_COORD( pNextNode->m_vecOrigin.y);

	mov	ecx, DWORD PTR _pNextNode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2082 : 			WRITE_COORD( pNextNode->m_vecOrigin.z + NODE_HEIGHT);

	mov	eax, DWORD PTR _pNextNode$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR __real@4@40028000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2083 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 2084 : 
; 2085 : 		pNode = pNextNode;

	mov	ecx, DWORD PTR _pNextNode$[ebp]
	mov	DWORD PTR _pNode$[ebp], ecx

; 2086 : 	}

	jmp	$L38114
$L38115:
$L38102:

; 2087 : 
; 2088 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PathFind@CTestHull@@QAEXXZ ENDP			; CTestHull::PathFind
_TEXT	ENDS
PUBLIC	??0CStack@@QAE@XZ				; CStack::CStack
;	COMDAT ??0CStack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CStack@@QAE@XZ PROC NEAR				; CStack::CStack, COMDAT

; 2095 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2096 : 	m_level = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+400], 0

; 2097 : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CStack@@QAE@XZ ENDP					; CStack::CStack
_TEXT	ENDS
PUBLIC	?Push@CStack@@QAEXH@Z				; CStack::Push
PUBLIC	??_C@_07HNLK@Error?$CB?6?$AA@			; `string'
EXTRN	_printf:NEAR
;	COMDAT ??_C@_07HNLK@Error?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_07HNLK@Error?$CB?6?$AA@ DB 'Error!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?Push@CStack@@QAEXH@Z
_TEXT	SEGMENT
_value$ = 8
_this$ = -4
?Push@CStack@@QAEXH@Z PROC NEAR				; CStack::Push, COMDAT

; 2103 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2104 : 	if ( m_level >= MAX_STACK_NODES )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+400], 100		; 00000064H
	jl	SHORT $L38124

; 2106 : 		printf("Error!\n");

	push	OFFSET FLAT:??_C@_07HNLK@Error?$CB?6?$AA@ ; `string'
	call	_printf
	add	esp, 4

; 2107 : 		return;

	jmp	SHORT $L38123
$L38124:

; 2109 : 	m_stack[m_level] = value;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 2110 : 	m_level++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+400], eax
$L38123:

; 2111 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Push@CStack@@QAEXH@Z ENDP				; CStack::Push
_TEXT	ENDS
PUBLIC	?Pop@CStack@@QAEHXZ				; CStack::Pop
;	COMDAT ?Pop@CStack@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Pop@CStack@@QAEHXZ PROC NEAR				; CStack::Pop, COMDAT

; 2117 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2118 : 	if ( m_level <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+400], 0
	jg	SHORT $L38130

; 2119 : 		return -1;

	or	eax, -1
	jmp	SHORT $L38129
$L38130:

; 2120 : 
; 2121 : 	m_level--;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+400], edx

; 2122 : 	return m_stack[ m_level ];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
$L38129:

; 2123 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Pop@CStack@@QAEHXZ ENDP				; CStack::Pop
_TEXT	ENDS
PUBLIC	?Top@CStack@@QAEHXZ				; CStack::Top
;	COMDAT ?Top@CStack@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Top@CStack@@QAEHXZ PROC NEAR				; CStack::Top, COMDAT

; 2129 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2130 : 	return m_stack[ m_level - 1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4-4]

; 2131 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Top@CStack@@QAEHXZ ENDP				; CStack::Top
_TEXT	ENDS
PUBLIC	?CopyToArray@CStack@@QAEXPAH@Z			; CStack::CopyToArray
;	COMDAT ?CopyToArray@CStack@@QAEXPAH@Z
_TEXT	SEGMENT
_piArray$ = 8
_this$ = -4
_i$ = -8
?CopyToArray@CStack@@QAEXPAH@Z PROC NEAR		; CStack::CopyToArray, COMDAT

; 2137 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2138 : 	int	i;
; 2139 : 
; 2140 : 	for ( i = 0 ; i < m_level ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38140
$L38141:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38140:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+400]
	jge	SHORT $L38142

; 2142 : 		piArray[ i ] = m_stack[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _piArray$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 2143 : 	}

	jmp	SHORT $L38141
$L38142:

; 2144 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CopyToArray@CStack@@QAEXPAH@Z ENDP			; CStack::CopyToArray
_TEXT	ENDS
PUBLIC	??0CQueue@@QAE@XZ				; CQueue::CQueue
;	COMDAT ??0CQueue@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CQueue@@QAE@XZ PROC NEAR				; CQueue::CQueue, COMDAT

; 2150 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2151 : 	m_cSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 2152 : 	m_head = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+804], 0

; 2153 : 	m_tail = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+808], -1

; 2154 : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CQueue@@QAE@XZ ENDP					; CQueue::CQueue
_TEXT	ENDS
PUBLIC	?Full@CQueue@@QAEHXZ				; CQueue::Full
PUBLIC	?Insert@CQueue@@QAEXHM@Z			; CQueue::Insert
PUBLIC	??_C@_0BA@OFK@Queue?5is?5full?$CB?6?$AA@	; `string'
;	COMDAT ??_C@_0BA@OFK@Queue?5is?5full?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BA@OFK@Queue?5is?5full?$CB?6?$AA@ DB 'Queue is full!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?Insert@CQueue@@QAEXHM@Z
_TEXT	SEGMENT
_iValue$ = 8
_fPriority$ = 12
_this$ = -4
?Insert@CQueue@@QAEXHM@Z PROC NEAR			; CQueue::Insert, COMDAT

; 2160 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2161 : 
; 2162 : 	if ( Full() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Full@CQueue@@QAEHXZ			; CQueue::Full
	test	eax, eax
	je	SHORT $L38152

; 2164 : 		printf ( "Queue is full!\n" );

	push	OFFSET FLAT:??_C@_0BA@OFK@Queue?5is?5full?$CB?6?$AA@ ; `string'
	call	_printf
	add	esp, 4

; 2165 : 		return;

	jmp	SHORT $L38151
$L38152:

; 2167 : 
; 2168 : 	m_tail++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+808], ecx

; 2169 : 
; 2170 : 	if ( m_tail == MAX_STACK_NODES )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+808], 100		; 00000064H
	jne	SHORT $L38154

; 2172 : 		m_tail = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+808], 0
$L38154:

; 2174 : 
; 2175 : 	m_queue[ m_tail ].Id = iValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 2176 : 	m_queue[ m_tail ].Priority = fPriority;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _fPriority$[ebp]
	mov	DWORD PTR [edx+ecx*8+8], eax

; 2177 : 	m_cSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx
$L38151:

; 2178 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@CQueue@@QAEXHM@Z ENDP				; CQueue::Insert
_TEXT	ENDS
;	COMDAT ?Full@CQueue@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Full@CQueue@@QAEHXZ PROC NEAR				; CQueue::Full, COMDAT

; 303  : 	inline int Full ( void ) { return ( m_cSize == MAX_STACK_NODES ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 100			; 00000064H
	sete	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Full@CQueue@@QAEHXZ ENDP				; CQueue::Full
_TEXT	ENDS
PUBLIC	?Remove@CQueue@@QAEHAAM@Z			; CQueue::Remove
;	COMDAT ?Remove@CQueue@@QAEHAAM@Z
_TEXT	SEGMENT
_fPriority$ = 8
_this$ = -4
?Remove@CQueue@@QAEHAAM@Z PROC NEAR			; CQueue::Remove, COMDAT

; 2184 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2185 : 	if ( m_head == MAX_STACK_NODES )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+804], 100		; 00000064H
	jne	SHORT $L38159

; 2187 : 		m_head = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+804], 0
$L38159:

; 2189 : 
; 2190 : 	m_cSize--;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 2191 : 	fPriority = m_queue[ m_head ].Priority;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+804]
	mov	ecx, DWORD PTR _fPriority$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*8+8]
	mov	DWORD PTR [ecx], eax

; 2192 : 	return m_queue[ m_head++ ].Id;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+804]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+edx*8+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+804]
	add	edx, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+804], edx

; 2193 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@CQueue@@QAEHAAM@Z ENDP				; CQueue::Remove
_TEXT	ENDS
;	COMDAT ??0CQueuePriority@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CQueuePriority@@QAE@XZ PROC NEAR			; CQueuePriority::CQueuePriority, COMDAT

; 2199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2200 : 	m_cSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 2201 : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CQueuePriority@@QAE@XZ ENDP				; CQueuePriority::CQueuePriority
_TEXT	ENDS
PUBLIC	?Full@CQueuePriority@@QAEHXZ			; CQueuePriority::Full
PUBLIC	?Heap_SiftUp@CQueuePriority@@AAEXXZ		; CQueuePriority::Heap_SiftUp
;	COMDAT ?Insert@CQueuePriority@@QAEXHM@Z
_TEXT	SEGMENT
_iValue$ = 8
_fPriority$ = 12
_this$ = -4
?Insert@CQueuePriority@@QAEXHM@Z PROC NEAR		; CQueuePriority::Insert, COMDAT

; 2207 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2208 : 
; 2209 : 	if ( Full() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Full@CQueuePriority@@QAEHXZ		; CQueuePriority::Full
	test	eax, eax
	je	SHORT $L38169

; 2211 : 		printf ( "Queue is full!\n" );

	push	OFFSET FLAT:??_C@_0BA@OFK@Queue?5is?5full?$CB?6?$AA@ ; `string'
	call	_printf
	add	esp, 4

; 2212 : 		return;

	jmp	SHORT $L38168
$L38169:

; 2214 : 
; 2215 :     m_heap[ m_cSize ].Priority = fPriority;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _fPriority$[ebp]
	mov	DWORD PTR [edx+ecx*8+8], eax

; 2216 : 	m_heap[ m_cSize ].Id = iValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 2217 :     m_cSize++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 2218 :     Heap_SiftUp();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Heap_SiftUp@CQueuePriority@@AAEXXZ	; CQueuePriority::Heap_SiftUp
$L38168:

; 2219 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@CQueuePriority@@QAEXHM@Z ENDP			; CQueuePriority::Insert
_TEXT	ENDS
;	COMDAT ?Full@CQueuePriority@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Full@CQueuePriority@@QAEHXZ PROC NEAR			; CQueuePriority::Full, COMDAT

; 330  : 	inline int Full ( void ) { return ( m_cSize == MAX_STACK_NODES ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 100			; 00000064H
	sete	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Full@CQueuePriority@@QAEHXZ ENDP			; CQueuePriority::Full
_TEXT	ENDS
PUBLIC	?Heap_SiftDown@CQueuePriority@@AAEXH@Z		; CQueuePriority::Heap_SiftDown
;	COMDAT ?Remove@CQueuePriority@@QAEHAAM@Z
_TEXT	SEGMENT
_fPriority$ = 8
_this$ = -4
_iReturn$ = -8
?Remove@CQueuePriority@@QAEHAAM@Z PROC NEAR		; CQueuePriority::Remove, COMDAT

; 2226 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2227 : 	int iReturn = m_heap[ 0 ].Id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _iReturn$[ebp], ecx

; 2228 : 	fPriority = m_heap[ 0 ].Priority;

	mov	edx, DWORD PTR _fPriority$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 2229 : 
; 2230 : 	m_cSize--;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 2231 : 
; 2232 : 	m_heap[ 0 ] = m_heap[ m_cSize ];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	mov	eax, DWORD PTR [ecx+eax*8+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax

; 2233 : 
; 2234 :     Heap_SiftDown(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Heap_SiftDown@CQueuePriority@@AAEXH@Z	; CQueuePriority::Heap_SiftDown

; 2235 :     return iReturn;

	mov	eax, DWORD PTR _iReturn$[ebp]

; 2236 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@CQueuePriority@@QAEHAAM@Z ENDP			; CQueuePriority::Remove
_TEXT	ENDS
;	COMDAT ?Heap_SiftDown@CQueuePriority@@AAEXH@Z
_TEXT	SEGMENT
_iSubRoot$ = 8
_this$ = -4
_parent$ = -8
_child$ = -12
_Ref$ = -20
_rightchild$38188 = -24
?Heap_SiftDown@CQueuePriority@@AAEXH@Z PROC NEAR	; CQueuePriority::Heap_SiftDown, COMDAT

; 2243 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2244 : 	int parent = iSubRoot;

	mov	eax, DWORD PTR _iSubRoot$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 2245 : 	int child = HEAP_LEFT_CHILD(parent);

	mov	ecx, DWORD PTR _parent$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+1]
	mov	DWORD PTR _child$[ebp], edx

; 2246 : 
; 2247 : 	struct tag_HEAP_NODE Ref = m_heap[ parent ];

	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	mov	eax, DWORD PTR [ecx+eax*8+8]
	mov	DWORD PTR _Ref$[ebp], edx
	mov	DWORD PTR _Ref$[ebp+4], eax
$L38186:

; 2248 : 
; 2249 :     while (child < m_cSize)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _child$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $L38187

; 2251 : 		int rightchild = HEAP_RIGHT_CHILD(parent);

	mov	eax, DWORD PTR _parent$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR _rightchild$38188[ebp], ecx

; 2252 : 		if (rightchild < m_cSize)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rightchild$38188[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $L38190

; 2254 : 			if ( m_heap[ rightchild ].Priority < m_heap[ child ].Priority )

	mov	ecx, DWORD PTR _rightchild$38188[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _child$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+ecx*8+8]
	fcomp	DWORD PTR [esi+eax*8+8]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38190

; 2256 : 				child = rightchild;

	mov	ecx, DWORD PTR _rightchild$38188[ebp]
	mov	DWORD PTR _child$[ebp], ecx
$L38190:

; 2259 : 		if ( Ref.Priority <= m_heap[ child ].Priority )

	mov	edx, DWORD PTR _child$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _Ref$[ebp+4]
	fcomp	DWORD PTR [eax+edx*8+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38191

; 2260 : 			break;

	jmp	SHORT $L38187
$L38191:

; 2261 : 
; 2262 : 		m_heap[ parent ] = m_heap[ child ];

	mov	ecx, DWORD PTR _child$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	mov	ecx, DWORD PTR [edx+ecx*8+8]
	mov	edx, DWORD PTR _parent$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	DWORD PTR [esi+edx*8+4], eax
	mov	DWORD PTR [esi+edx*8+8], ecx

; 2263 : 		parent = child;

	mov	eax, DWORD PTR _child$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 2264 : 		child = HEAP_LEFT_CHILD(parent);

	mov	ecx, DWORD PTR _parent$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+1]
	mov	DWORD PTR _child$[ebp], edx

; 2265 : 	}

	jmp	$L38186
$L38187:

; 2266 : 	m_heap[ parent ] = Ref;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Ref$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx
	mov	edx, DWORD PTR _Ref$[ebp+4]
	mov	DWORD PTR [ecx+eax*8+8], edx

; 2267 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Heap_SiftDown@CQueuePriority@@AAEXH@Z ENDP		; CQueuePriority::Heap_SiftDown
_TEXT	ENDS
;	COMDAT ?Heap_SiftUp@CQueuePriority@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4
_child$ = -8
_parent$38200 = -12
_Tmp$38202 = -20
?Heap_SiftUp@CQueuePriority@@AAEXXZ PROC NEAR		; CQueuePriority::Heap_SiftUp, COMDAT

; 2270 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 	int child = m_cSize-1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _child$[ebp], ecx
$L38198:

; 2272 : 	while (child)

	cmp	DWORD PTR _child$[ebp], 0
	je	SHORT $L38199

; 2274 : 		int parent = HEAP_PARENT(child);

	mov	eax, DWORD PTR _child$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _parent$38200[ebp], eax

; 2275 : 		if ( m_heap[ parent ].Priority <= m_heap[ child ].Priority )

	mov	edx, DWORD PTR _parent$38200[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _child$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+edx*8+8]
	fcomp	DWORD PTR [esi+ecx*8+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38201

; 2276 : 			break;

	jmp	SHORT $L38199
$L38201:

; 2279 : 		Tmp = m_heap[ child ];

	mov	edx, DWORD PTR _child$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	mov	edx, DWORD PTR [eax+edx*8+8]
	mov	DWORD PTR _Tmp$38202[ebp], ecx
	mov	DWORD PTR _Tmp$38202[ebp+4], edx

; 2280 : 		m_heap[ child ] = m_heap[ parent ];

	mov	eax, DWORD PTR _parent$38200[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	mov	eax, DWORD PTR [ecx+eax*8+8]
	mov	ecx, DWORD PTR _child$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	DWORD PTR [esi+ecx*8+4], edx
	mov	DWORD PTR [esi+ecx*8+8], eax

; 2281 : 		m_heap[ parent ] = Tmp;

	mov	edx, DWORD PTR _parent$38200[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Tmp$38202[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx
	mov	ecx, DWORD PTR _Tmp$38202[ebp+4]
	mov	DWORD PTR [eax+edx*8+8], ecx

; 2282 : 
; 2283 : 		child = parent;

	mov	edx, DWORD PTR _parent$38200[ebp]
	mov	DWORD PTR _child$[ebp], edx

; 2284 : 	}

	jmp	SHORT $L38198
$L38199:

; 2285 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Heap_SiftUp@CQueuePriority@@AAEXXZ ENDP		; CQueuePriority::Heap_SiftUp
_TEXT	ENDS
PUBLIC	??_C@_0M@HBDC@maps?1?$CFs?4bsp?$AA@		; `string'
PUBLIC	??_C@_0BD@GMNG@maps?1graphs?1?$CFs?4nod?$AA@	; `string'
PUBLIC	??_C@_0CM@IGOK@?$CK?$CKERROR?$CK?$CK?5Graph?5version?5is?5?$CFd?0?5e@ ; `string'
PUBLIC	??_C@_0CE@HBMP@?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5lin@ ; `string'
PUBLIC	??_C@_0DG@OPG@?$CK?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5en@ ; `string'
PUBLIC	??_C@_0CN@DIDD@?$CK?$CK?$CKERROR?$CK?$CK?6Counldn?8t?5malloc?5?$CFd?5r@ ; `string'
PUBLIC	??_C@_0DB@BEAH@?$CK?$CK?$CKERROR?$CK?$CK?6Counldn?8t?5malloc?5?$CFd?5h@ ; `string'
PUBLIC	??_C@_0EB@DHAP@?$CK?$CK?$CKWARNING?$CK?$CK?$CK?3Node?5graph?5was?5lon@ ; `string'
PUBLIC	?FLoadGraph@CGraph@@QAEHPAD@Z			; CGraph::FLoadGraph
;	COMDAT ??_C@_0M@HBDC@maps?1?$CFs?4bsp?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0M@HBDC@maps?1?$CFs?4bsp?$AA@ DB 'maps/%s.bsp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GMNG@maps?1graphs?1?$CFs?4nod?$AA@
CONST	SEGMENT
??_C@_0BD@GMNG@maps?1graphs?1?$CFs?4nod?$AA@ DB 'maps/graphs/%s.nod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IGOK@?$CK?$CKERROR?$CK?$CK?5Graph?5version?5is?5?$CFd?0?5e@
CONST	SEGMENT
??_C@_0CM@IGOK@?$CK?$CKERROR?$CK?$CK?5Graph?5version?5is?5?$CFd?0?5e@ DB '*'
	DB	'*ERROR** Graph version is %d, expected %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HBMP@?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5lin@
CONST	SEGMENT
??_C@_0CE@HBMP@?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5lin@ DB '*'
	DB	'*ERROR**', 0aH, 'Couldn''t malloc %d link!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@OPG@?$CK?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5en@
CONST	SEGMENT
??_C@_0DG@OPG@?$CK?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5en@ DB '*'
	DB	'**ERROR**', 0aH, 'Couldn''t malloc %d entries sorting nodes!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DIDD@?$CK?$CK?$CKERROR?$CK?$CK?6Counldn?8t?5malloc?5?$CFd?5r@
CONST	SEGMENT
??_C@_0CN@DIDD@?$CK?$CK?$CKERROR?$CK?$CK?6Counldn?8t?5malloc?5?$CFd?5r@ DB '*'
	DB	'**ERROR**', 0aH, 'Counldn''t malloc %d route bytes!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BEAH@?$CK?$CK?$CKERROR?$CK?$CK?6Counldn?8t?5malloc?5?$CFd?5h@
CONST	SEGMENT
??_C@_0DB@BEAH@?$CK?$CK?$CKERROR?$CK?$CK?6Counldn?8t?5malloc?5?$CFd?5h@ DB '*'
	DB	'**ERROR**', 0aH, 'Counldn''t malloc %d hash link bytes!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@DHAP@?$CK?$CK?$CKWARNING?$CK?$CK?$CK?3Node?5graph?5was?5lon@
CONST	SEGMENT
??_C@_0EB@DHAP@?$CK?$CK?$CKWARNING?$CK?$CK?$CK?3Node?5graph?5was?5lon@ DB '*'
	DB	'**WARNING***:Node graph was longer than expected by %d bytes.'
	DB	'!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?FLoadGraph@CGraph@@QAEHPAD@Z
_TEXT	SEGMENT
_szMapName$ = 8
_this$ = -4
_szFilename$ = -264
_iVersion$ = -268
_iResult$ = -272
_length$ = -276
_aMemFile$ = -280
_pMemFile$ = -284
_i$38270 = -288
?FLoadGraph@CGraph@@QAEHPAD@Z PROC NEAR			; CGraph::FLoadGraph, COMDAT

; 2294 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2295 : 	char	szFilename[MAX_PATH];
; 2296 : 	int	iVersion;
; 2297 : 	int	iResult;
; 2298 : 	int	length;
; 2299 : 	byte	*aMemFile;
; 2300 : 	byte	*pMemFile;
; 2301 : 
; 2302 : 	Q_snprintf( szFilename, sizeof( szFilename ), "maps/%s.bsp", szMapName );

	mov	eax, DWORD PTR _szMapName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0M@HBDC@maps?1?$CFs?4bsp?$AA@ ; `string'
	push	260					; 00000104H
	lea	ecx, DWORD PTR _szFilename$[ebp]
	push	ecx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 2303 : 
; 2304 : 	iResult = MAP_READ_LUMP( szFilename, LUMP_AINODEGRAPH, (void **)&aMemFile, &length );

	lea	edx, DWORD PTR _length$[ebp]
	push	edx
	lea	eax, DWORD PTR _aMemFile$[ebp]
	push	eax
	push	7
	lea	ecx, DWORD PTR _szFilename$[ebp]
	push	ecx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+104
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iResult$[ebp], eax

; 2305 : 
; 2306 : 	if( iResult != LUMP_LOAD_OK )

	cmp	DWORD PTR _iResult$[ebp], 0
	je	SHORT $L38215

; 2308 : 		// this map doesn't support including new lumps. fallback to old method
; 2309 : 		Q_snprintf( szFilename, sizeof( szFilename ), "maps/graphs/%s.nod", szMapName );

	mov	edx, DWORD PTR _szMapName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BD@GMNG@maps?1graphs?1?$CFs?4nod?$AA@ ; `string'
	push	260					; 00000104H
	lea	eax, DWORD PTR _szFilename$[ebp]
	push	eax
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 2310 : 
; 2311 : 		aMemFile = LOAD_FILE( szFilename, &length );

	lea	ecx, DWORD PTR _length$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFilename$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+380
	add	esp, 8
	mov	DWORD PTR _aMemFile$[ebp], eax
$L38215:

; 2313 : 
; 2314 : 	pMemFile = aMemFile;

	mov	eax, DWORD PTR _aMemFile$[ebp]
	mov	DWORD PTR _pMemFile$[ebp], eax

; 2315 : 
; 2316 : 	if( !aMemFile )

	cmp	DWORD PTR _aMemFile$[ebp], 0
	jne	SHORT $L38217

; 2318 : 		// nodegraph is completely missed
; 2319 : 		return FALSE;

	xor	eax, eax
	jmp	$L38206
$L38217:

; 2323 : 		// Read the graph version number
; 2324 : 		//
; 2325 : 		length -= sizeof(int);

	mov	ecx, DWORD PTR _length$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _length$[ebp], ecx

; 2326 : 		if (length < 0) goto ShortFile;

	cmp	DWORD PTR _length$[ebp], 0
	jge	SHORT $L38220
	jmp	$L38222
$L38220:

; 2327 : 		memcpy(&iVersion, pMemFile, sizeof(int));

	push	4
	mov	edx, DWORD PTR _pMemFile$[ebp]
	push	edx
	lea	eax, DWORD PTR _iVersion$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2328 : 		pMemFile += sizeof(int);

	mov	ecx, DWORD PTR _pMemFile$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pMemFile$[ebp], ecx

; 2329 : 
; 2330 : 		if ( iVersion != GRAPH_VERSION )

	cmp	DWORD PTR _iVersion$[ebp], 16		; 00000010H
	je	SHORT $L38226

; 2332 : 			// This file was written by a different build of the dll!
; 2333 : 			//
; 2334 : 			ALERT ( at_aiconsole, "**ERROR** Graph version is %d, expected %d\n",iVersion, GRAPH_VERSION );

	push	16					; 00000010H
	mov	edx, DWORD PTR _iVersion$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CM@IGOK@?$CK?$CKERROR?$CK?$CK?5Graph?5version?5is?5?$CFd?0?5e@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 2335 : 			goto ShortFile;

	jmp	$L38229
$L38226:

; 2337 : 
; 2338 : 		// Read the graph class
; 2339 : 		//
; 2340 : 		length -= sizeof(CGraph);

	mov	eax, DWORD PTR _length$[ebp]
	sub	eax, 8396				; 000020ccH
	mov	DWORD PTR _length$[ebp], eax

; 2341 : 		if (length < 0) goto ShortFile;

	cmp	DWORD PTR _length$[ebp], 0
	jge	SHORT $L38231
	jmp	$L38232
$L38231:

; 2342 : 		memcpy(this, pMemFile, sizeof(CGraph));

	push	8396					; 000020ccH
	mov	ecx, DWORD PTR _pMemFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2343 : 		pMemFile += sizeof(CGraph);

	mov	eax, DWORD PTR _pMemFile$[ebp]
	add	eax, 8396				; 000020ccH
	mov	DWORD PTR _pMemFile$[ebp], eax

; 2344 : 
; 2345 : 		// Set the pointers to zero, just in case we run out of memory.
; 2346 : 		//
; 2347 : 		m_pNodes     = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 2348 : 		m_pLinkPool  = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 2349 : 		m_di         = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 2350 : 		m_pRouteInfo = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 2351 : 		m_pHashLinks = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8380], 0

; 2352 : 
; 2353 : 
; 2354 : 		// Malloc for the nodes
; 2355 : 		//
; 2356 : 		m_pNodes = ( CNode * )calloc ( sizeof ( CNode ), m_cNodes );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	88					; 00000058H
	call	_calloc
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax

; 2357 : 
; 2358 : 		if ( !m_pNodes )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $L38237

; 2360 : 			ALERT ( at_aiconsole, "**ERROR**\nCouldn't malloc %d nodes!\n", m_cNodes );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET FLAT:??_C@_0CF@PCAE@?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5nod@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2361 : 			goto NoMemory;

	jmp	$L38239
$L38237:

; 2363 : 
; 2364 : 		// Read in all the nodes
; 2365 : 		//
; 2366 : 		length -= sizeof(CNode) * m_cNodes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _length$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _length$[ebp], edx

; 2367 : 		if (length < 0) goto ShortFile;

	cmp	DWORD PTR _length$[ebp], 0
	jge	SHORT $L38241
	jmp	$L38242
$L38241:

; 2368 : 		memcpy(m_pNodes, pMemFile, sizeof(CNode)*m_cNodes);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, 88					; 00000058H
	push	ecx
	mov	edx, DWORD PTR _pMemFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2369 : 		pMemFile += sizeof(CNode) * m_cNodes;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _pMemFile$[ebp]
	add	ecx, eax
	mov	DWORD PTR _pMemFile$[ebp], ecx

; 2370 : 
; 2371 : 		
; 2372 : 		// Malloc for the link pool
; 2373 : 		//
; 2374 : 		m_pLinkPool = ( CLink * )calloc ( sizeof ( CLink ), m_cLinks );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	push	24					; 00000018H
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 2375 : 
; 2376 : 		if ( !m_pLinkPool )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $L38247

; 2378 : 			ALERT ( at_aiconsole, "**ERROR**\nCouldn't malloc %d link!\n", m_cLinks );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	push	OFFSET FLAT:??_C@_0CE@HBMP@?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5lin@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2379 : 			goto NoMemory;

	jmp	$L38249
$L38247:

; 2381 : 
; 2382 : 		// Read in all the links
; 2383 : 		//
; 2384 : 		length -= sizeof(CLink)*m_cLinks;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _length$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _length$[ebp], ecx

; 2385 : 		if (length < 0) goto ShortFile;

	cmp	DWORD PTR _length$[ebp], 0
	jge	SHORT $L38251
	jmp	$L38252
$L38251:

; 2386 : 		memcpy(m_pLinkPool, pMemFile, sizeof(CLink)*m_cLinks);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	imul	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _pMemFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2387 : 		pMemFile += sizeof(CLink)*m_cLinks;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pMemFile$[ebp]
	add	eax, edx
	mov	DWORD PTR _pMemFile$[ebp], eax

; 2388 : 
; 2389 : 		// Malloc for the sorting info.
; 2390 : 		//
; 2391 : 		m_di = (DIST_INFO *)calloc( sizeof(DIST_INFO), m_cNodes );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	16					; 00000010H
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 2392 : 		if ( !m_di )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $L38257

; 2394 : 			ALERT ( at_aiconsole, "***ERROR**\nCouldn't malloc %d entries sorting nodes!\n", m_cNodes );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET FLAT:??_C@_0DG@OPG@?$CK?$CK?$CKERROR?$CK?$CK?6Couldn?8t?5malloc?5?$CFd?5en@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2395 : 			goto NoMemory;

	jmp	$L38259
$L38257:

; 2397 : 
; 2398 : 		// Read it in.
; 2399 : 		//
; 2400 : 		length -= sizeof(DIST_INFO)*m_cNodes;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shl	eax, 4
	mov	ecx, DWORD PTR _length$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _length$[ebp], ecx

; 2401 : 		if (length < 0) goto ShortFile;

	cmp	DWORD PTR _length$[ebp], 0
	jge	SHORT $L38261
	jmp	$L38262
$L38261:

; 2402 : 		memcpy(m_di, pMemFile, sizeof(DIST_INFO)*m_cNodes);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _pMemFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2403 : 		pMemFile += sizeof(DIST_INFO)*m_cNodes;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	shl	edx, 4
	mov	eax, DWORD PTR _pMemFile$[ebp]
	add	eax, edx
	mov	DWORD PTR _pMemFile$[ebp], eax

; 2404 : 
; 2405 : 		// Malloc for the routing info.
; 2406 : 		//
; 2407 : 		m_fRoutingComplete = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 2408 : 		m_pRouteInfo = (char *)calloc( sizeof(char), m_nRouteInfo );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	push	1
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 2409 : 		if ( !m_pRouteInfo )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $L38267

; 2411 : 			ALERT ( at_aiconsole, "***ERROR**\nCounldn't malloc %d route bytes!\n", m_nRouteInfo );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	push	OFFSET FLAT:??_C@_0CN@DIDD@?$CK?$CK?$CKERROR?$CK?$CK?6Counldn?8t?5malloc?5?$CFd?5r@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2412 : 			goto NoMemory;

	jmp	$L38269
$L38267:

; 2414 : 		m_CheckedCounter = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+6240], 0

; 2415 : 		for (int i = 0; i < m_cNodes; i++)

	mov	DWORD PTR _i$38270[ebp], 0
	jmp	SHORT $L38271
$L38272:
	mov	eax, DWORD PTR _i$38270[ebp]
	add	eax, 1
	mov	DWORD PTR _i$38270[ebp], eax
$L38271:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$38270[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L38273

; 2417 : 			m_di[i].m_CheckedEvent = 0;

	mov	eax, DWORD PTR _i$38270[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+eax+12], 0

; 2418 : 		}

	jmp	SHORT $L38272
$L38273:

; 2419 : 		
; 2420 : 		// Read in the route information.
; 2421 : 		//
; 2422 : 		length -= sizeof(char)*m_nRouteInfo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _length$[ebp]
	sub	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _length$[ebp], ecx

; 2423 : 		if (length < 0) goto ShortFile;

	cmp	DWORD PTR _length$[ebp], 0
	jge	SHORT $L38275
	jmp	$L38276
$L38275:

; 2424 : 		memcpy(m_pRouteInfo, pMemFile, sizeof(char)*m_nRouteInfo);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _pMemFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2425 : 		pMemFile += sizeof(char)*m_nRouteInfo;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pMemFile$[ebp]
	add	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _pMemFile$[ebp], edx

; 2426 : 		m_fRoutingComplete = TRUE;;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 2427 : 
; 2428 : 		// malloc for the hash links
; 2429 : 		//
; 2430 : 		m_pHashLinks = (short *)calloc(sizeof(short), m_nHashLinks);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8384]
	push	edx
	push	2
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8380], eax

; 2431 : 		if (!m_pHashLinks)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8380], 0
	jne	SHORT $L38281

; 2433 : 			ALERT ( at_aiconsole, "***ERROR**\nCounldn't malloc %d hash link bytes!\n", m_nHashLinks );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8384]
	push	ecx
	push	OFFSET FLAT:??_C@_0DB@BEAH@?$CK?$CK?$CKERROR?$CK?$CK?6Counldn?8t?5malloc?5?$CFd?5h@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2434 : 			goto NoMemory;

	jmp	$L38283
$L38281:

; 2436 : 
; 2437 : 		// Read in the hash link information
; 2438 : 		//
; 2439 : 		length -= sizeof(short)*m_nHashLinks;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8384]
	shl	eax, 1
	mov	ecx, DWORD PTR _length$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _length$[ebp], ecx

; 2440 : 		if (length < 0) goto ShortFile;

	cmp	DWORD PTR _length$[ebp], 0
	jge	SHORT $L38285
	jmp	$L38286
$L38285:

; 2441 : 		memcpy(m_pHashLinks, pMemFile, sizeof(short)*m_nHashLinks);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8384]
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pMemFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8380]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2442 : 		pMemFile += sizeof(short)*m_nHashLinks;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8384]
	mov	eax, DWORD PTR _pMemFile$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _pMemFile$[ebp], ecx

; 2443 : 
; 2444 : 		// Set the graph present flag, clear the pointers set flag
; 2445 : 		//
; 2446 : 		m_fGraphPresent = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 1

; 2447 : 		m_fGraphPointersSet = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 2448 : 		
; 2449 : 		FREE_FILE(aMemFile);

	mov	ecx, DWORD PTR _aMemFile$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+384
	add	esp, 4

; 2450 : 
; 2451 : 		if (length != 0)

	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $L38289

; 2453 : 			ALERT ( at_aiconsole, "***WARNING***:Node graph was longer than expected by %d bytes.!\n", length);

	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0EB@DHAP@?$CK?$CK?$CKWARNING?$CK?$CK?$CK?3Node?5graph?5was?5lon@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L38289:

; 2455 : 
; 2456 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L38206
$ShortFile$38221:
$NoMemory$38238:

; 2458 : 
; 2459 : ShortFile:
; 2460 : NoMemory:
; 2461 : 	FREE_FILE(aMemFile);

	mov	eax, DWORD PTR _aMemFile$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+384
	add	esp, 4

; 2462 : 	return FALSE;

	xor	eax, eax
	jmp	SHORT $L38206
$L38286:

; 2463 : }

	jmp	SHORT $ShortFile$38221
$L38283:
	jmp	SHORT $NoMemory$38238
$L38276:
	jmp	SHORT $ShortFile$38221
$L38269:
	jmp	SHORT $NoMemory$38238
$L38262:
	jmp	SHORT $ShortFile$38221
$L38259:
	jmp	SHORT $NoMemory$38238
$L38252:
	jmp	SHORT $ShortFile$38221
$L38249:
	jmp	SHORT $NoMemory$38238
$L38242:
	jmp	SHORT $ShortFile$38221
$L38239:
	jmp	SHORT $NoMemory$38238
$L38232:
	jmp	SHORT $ShortFile$38221
$L38229:
	jmp	SHORT $ShortFile$38221
$L38222:
	jmp	SHORT $ShortFile$38221
$L38206:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FLoadGraph@CGraph@@QAEHPAD@Z ENDP			; CGraph::FLoadGraph
_TEXT	ENDS
PUBLIC	??_C@_0BO@FHCN@Write?5LUMP_AINODEGRAPH?5to?5?$CFs?6?$AA@ ; `string'
;	COMDAT ??_C@_0BO@FHCN@Write?5LUMP_AINODEGRAPH?5to?5?$CFs?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BO@FHCN@Write?5LUMP_AINODEGRAPH?5to?5?$CFs?6?$AA@ DB 'Write LUMP_A'
	DB	'INODEGRAPH to %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?FSaveGraph@CGraph@@QAEHPAD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?FSaveGraph@CGraph@@QAEHPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?FSaveGraph@CGraph@@QAEHPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FSaveGraph@CGraph@@QAEHPAD@Z$0
xdata$x	ENDS
;	COMDAT ?FSaveGraph@CGraph@@QAEHPAD@Z
_TEXT	SEGMENT
$T40166 = -304
$T40167 = -308
$T40168 = -312
$T40169 = -316
__$EHRec$ = -12
_szMapName$ = 8
_this$ = -16
_iVersion$ = -20
_szFilename$ = -280
_file$ = -296
_iResult$ = -300
?FSaveGraph@CGraph@@QAEHPAD@Z PROC NEAR			; CGraph::FSaveGraph, COMDAT

; 2470 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FSaveGraph@CGraph@@QAEHPAD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 368				; 00000170H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2471 : 	int		iVersion = GRAPH_VERSION;

	mov	DWORD PTR _iVersion$[ebp], 16		; 00000010H

; 2472 : 	char		szFilename[MAX_PATH];
; 2473 : 	CVirtualFS	file;

	lea	ecx, DWORD PTR _file$[ebp]
	call	??0CVirtualFS@@QAE@XZ			; CVirtualFS::CVirtualFS
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2474 : 
; 2475 : 	if ( !m_fGraphPresent || !m_fGraphPointersSet )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L38300
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L38299
$L38300:

; 2477 : 		// protect us in the case that the node graph isn't available or built
; 2478 : 		ALERT ( at_aiconsole, "Graph not ready!\n" );

	push	OFFSET FLAT:??_C@_0BC@LJED@Graph?5not?5ready?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2479 : 		return FALSE;

	mov	DWORD PTR $T40166[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	mov	eax, DWORD PTR $T40166[ebp]
	jmp	$L38294
$L38299:

; 2481 : 
; 2482 : 	Q_snprintf( szFilename, sizeof( szFilename ), "maps/%s.bsp", szMapName );

	mov	edx, DWORD PTR _szMapName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0M@HBDC@maps?1?$CFs?4bsp?$AA@ ; `string'
	push	260					; 00000104H
	lea	eax, DWORD PTR _szFilename$[ebp]
	push	eax
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 2483 : 	ALERT ( at_aiconsole, "Write LUMP_AINODEGRAPH to %s\n", szFilename );

	lea	ecx, DWORD PTR _szFilename$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BO@FHCN@Write?5LUMP_AINODEGRAPH?5to?5?$CFs?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2484 : 
; 2485 : 	// write the version
; 2486 : 	file.Write( &iVersion, sizeof( int ));

	push	4
	lea	edx, DWORD PTR _iVersion$[ebp]
	push	edx
	lea	ecx, DWORD PTR _file$[ebp]
	call	?Write@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Write

; 2487 : 
; 2488 : 	// write the CGraph class
; 2489 : 	file.Write( this, sizeof( CGraph ));

	push	8396					; 000020ccH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?Write@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Write

; 2490 : 
; 2491 : 	// write the nodes
; 2492 : 	file.Write( m_pNodes, sizeof( CNode ) * m_cNodes );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	imul	edx, 88					; 00000058H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	lea	ecx, DWORD PTR _file$[ebp]
	call	?Write@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Write

; 2493 : 
; 2494 : 	// write the links
; 2495 : 	file.Write( m_pLinkPool, sizeof( CLink ) * m_cLinks );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	imul	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	lea	ecx, DWORD PTR _file$[ebp]
	call	?Write@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Write

; 2496 : 
; 2497 : 	file.Write( m_di, sizeof( DIST_INFO ) * m_cNodes );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?Write@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Write

; 2498 : 
; 2499 : 	// Write the route info.
; 2500 : 	if( m_pRouteInfo && m_nRouteInfo )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $L38308
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $L38308

; 2502 : 		file.Write( m_pRouteInfo, m_nRouteInfo );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?Write@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Write
$L38308:

; 2504 : 
; 2505 : 	if( m_pHashLinks && m_nHashLinks )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8380], 0
	je	SHORT $L38309
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8384], 0
	je	SHORT $L38309

; 2507 : 		file.Write( m_pHashLinks, sizeof( short ) * m_nHashLinks );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8384]
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8380]
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?Write@CVirtualFS@@QAEIPBXI@Z		; CVirtualFS::Write
$L38309:

; 2509 : 
; 2510 : 	// dump into real file
; 2511 : 	int iResult = MAP_SAVE_LUMP( szFilename, LUMP_AINODEGRAPH, file.GetBuffer(), file.GetSize( ));

	lea	ecx, DWORD PTR _file$[ebp]
	call	?GetSize@CVirtualFS@@QAEIXZ		; CVirtualFS::GetSize
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?GetBuffer@CVirtualFS@@QAEPADXZ		; CVirtualFS::GetBuffer
	push	eax
	push	7
	lea	ecx, DWORD PTR _szFilename$[ebp]
	push	ecx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+108
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iResult$[ebp], eax

; 2512 : 
; 2513 : 	if( iResult != LUMP_SAVE_OK )

	cmp	DWORD PTR _iResult$[ebp], 0
	je	$L38312

; 2515 : 		// this map doesn't support including new lumps. fallback to old method
; 2516 : 		Q_snprintf( szFilename, sizeof( szFilename ), "maps/graphs/%s.nod", szMapName ); 

	mov	edx, DWORD PTR _szMapName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BD@GMNG@maps?1graphs?1?$CFs?4nod?$AA@ ; `string'
	push	260					; 00000104H
	lea	eax, DWORD PTR _szFilename$[ebp]
	push	eax
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 2517 : 
; 2518 : 		if( SAVE_FILE( szFilename, file.GetBuffer(), file.GetSize( )))

	lea	ecx, DWORD PTR _file$[ebp]
	call	?GetSize@CVirtualFS@@QAEIXZ		; CVirtualFS::GetSize
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?GetBuffer@CVirtualFS@@QAEPADXZ		; CVirtualFS::GetBuffer
	push	eax
	lea	ecx, DWORD PTR _szFilename$[ebp]
	push	ecx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+112
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L38313

; 2519 : 			return true;

	mov	DWORD PTR $T40167[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	mov	eax, DWORD PTR $T40167[ebp]
	jmp	SHORT $L38294
$L38313:

; 2520 : 		return false;

	mov	DWORD PTR $T40168[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	mov	eax, DWORD PTR $T40168[ebp]
	jmp	SHORT $L38294
$L38312:

; 2522 : 
; 2523 : 	return (iResult == LUMP_SAVE_OK) ? true : false;

	cmp	DWORD PTR _iResult$[ebp], 0
	sete	dl
	and	edx, 255				; 000000ffH
	mov	DWORD PTR $T40169[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	mov	eax, DWORD PTR $T40169[ebp]
$L38294:

; 2524 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FSaveGraph@CGraph@@QAEHPAD@Z$0:
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CVirtualFS@@QAE@XZ			; CVirtualFS::~CVirtualFS
	ret	0
__ehhandler$?FSaveGraph@CGraph@@QAEHPAD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?FSaveGraph@CGraph@@QAEHPAD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?FSaveGraph@CGraph@@QAEHPAD@Z ENDP			; CGraph::FSaveGraph
PUBLIC	??_C@_05LHJL@model?$AA@				; `string'
PUBLIC	??_C@_0BL@LJKI@?$CK?$CKCould?5not?5find?5model?5?$CFs?6?$AA@ ; `string'
PUBLIC	?FSetGraphPointers@CGraph@@QAEHXZ		; CGraph::FSetGraphPointers
EXTRN	?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z:NEAR ; UTIL_FindEntityByString
;	COMDAT ??_C@_05LHJL@model?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_05LHJL@model?$AA@ DB 'model', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LJKI@?$CK?$CKCould?5not?5find?5model?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BL@LJKI@?$CK?$CKCould?5not?5find?5model?5?$CFs?6?$AA@ DB '**Could '
	DB	'not find model %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?FSetGraphPointers@CGraph@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
_pLinkEnt$ = -12
_name$38327 = -20
?FSetGraphPointers@CGraph@@QAEHXZ PROC NEAR		; CGraph::FSetGraphPointers, COMDAT

; 2534 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2535 : 	int	i;
; 2536 : 	CBaseEntity	*pLinkEnt;
; 2537 : 
; 2538 : 	for ( i = 0 ; i < m_cLinks ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38323
$L38324:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38323:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jge	$L38325

; 2540 : 		
; 2541 : 		if ( m_pLinkPool[ i ].m_pLinkEnt != NULL )

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR [edx+eax+8], 0
	je	$L38332

; 2543 : 			char name[5];
; 2544 : 			// when graphs are saved, any valid pointers are will be non-zero, signifying that we should
; 2545 : 			// reset those pointers upon reloading. Any pointers that were NULL when the graph was saved
; 2546 : 			// will be NULL when reloaded, and will ignored by this function.
; 2547 : 
; 2548 : 			// m_szLinkEntModelname is not necessarily NULL terminated (so we can store it in a more alignment-friendly 4 bytes)
; 2549 : 			memcpy( name, m_pLinkPool[ i ].m_szLinkEntModelname, 4 );

	push	4
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax+12]
	push	eax
	lea	ecx, DWORD PTR _name$38327[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2550 : 			name[4] = 0;

	mov	BYTE PTR _name$38327[ebp+4], 0

; 2551 : 			pLinkEnt =  UTIL_FindEntityByString( NULL, "model", name );

	lea	edx, DWORD PTR _name$38327[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_05LHJL@model?$AA@	; `string'
	push	0
	call	?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z ; UTIL_FindEntityByString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLinkEnt$[ebp], eax

; 2552 : 
; 2553 : 			if ( !pLinkEnt )

	cmp	DWORD PTR _pLinkEnt$[ebp], 0
	jne	SHORT $L38329

; 2555 : 			// the ent isn't around anymore? Either there is a major problem, or it was removed from the world
; 2556 : 			// ( like a func_breakable that's been destroyed or something ). Make sure that LinkEnt is null.
; 2557 : 				ALERT ( at_aiconsole, "**Could not find model %s\n", name );

	lea	eax, DWORD PTR _name$38327[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BL@LJKI@?$CK?$CKCould?5not?5find?5model?5?$CFs?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2558 : 				m_pLinkPool[ i ].m_pLinkEnt = NULL;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+ecx+8], 0

; 2560 : 			else

	jmp	SHORT $L38332
$L38329:

; 2562 : 				m_pLinkPool[ i ].m_pLinkEnt = pLinkEnt->pev;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _pLinkEnt$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+ecx+8], edx

; 2563 : 
; 2564 : 				if ( !FBitSet( m_pLinkPool[ i ].m_pLinkEnt->flags, FL_GRAPHED ) )

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+eax+8]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 65536				; 00010000H
	test	ecx, ecx
	jne	SHORT $L38332

; 2566 : 					m_pLinkPool[ i ].m_pLinkEnt->flags += FL_GRAPHED;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+edx+8]
	mov	eax, DWORD PTR [edx+420]
	add	eax, 65536				; 00010000H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR [ecx+420], eax
$L38332:

; 2570 : 	}

	jmp	$L38324
$L38325:

; 2571 : 
; 2572 : 	// the pointers are now set.
; 2573 : 	m_fGraphPointersSet = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 1

; 2574 : 	return TRUE;

	mov	eax, 1

; 2575 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FSetGraphPointers@CGraph@@QAEHXZ ENDP			; CGraph::FSetGraphPointers
_TEXT	ENDS
PUBLIC	??_C@_0BM@KLJO@?4NOD?5File?5will?5be?5updated?6?6?$AA@ ; `string'
PUBLIC	?CheckNODFile@CGraph@@QAEHPAD@Z			; CGraph::CheckNODFile
;	COMDAT ??_C@_0BM@KLJO@?4NOD?5File?5will?5be?5updated?6?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BM@KLJO@?4NOD?5File?5will?5be?5updated?6?6?$AA@ DB '.NOD File will'
	DB	' be updated', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?CheckNODFile@CGraph@@QAEHPAD@Z
_TEXT	SEGMENT
_szMapName$ = 8
_this$ = -4
_retValue$ = -8
_szBspFilename$ = -268
_szGraphFilename$ = -528
_iCompare$ = -532
?CheckNODFile@CGraph@@QAEHPAD@Z PROC NEAR		; CGraph::CheckNODFile, COMDAT

; 2593 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 596				; 00000254H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2594 : 	int	retValue;
; 2595 : 
; 2596 : 	char	szBspFilename[MAX_PATH];
; 2597 : 	char	szGraphFilename[MAX_PATH];
; 2598 : 
; 2599 : 	Q_snprintf( szBspFilename, sizeof( szBspFilename ), "maps/%s.bsp", szMapName );

	mov	eax, DWORD PTR _szMapName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0M@HBDC@maps?1?$CFs?4bsp?$AA@ ; `string'
	push	260					; 00000104H
	lea	ecx, DWORD PTR _szBspFilename$[ebp]
	push	ecx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 2600 : 	retValue = MAP_CHECK_LUMP( szBspFilename, LUMP_AINODEGRAPH, NULL );

	push	0
	push	7
	lea	edx, DWORD PTR _szBspFilename$[ebp]
	push	edx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+100
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _retValue$[ebp], eax

; 2601 : 
; 2602 : 	if( retValue == LUMP_LOAD_OK )

	cmp	DWORD PTR _retValue$[ebp], 0
	jne	SHORT $L38340

; 2603 : 		return true;

	mov	eax, 1
	jmp	$L38336
$L38340:

; 2604 : 	else if( retValue == LUMP_LOAD_NOT_EXIST )

	cmp	DWORD PTR _retValue$[ebp], 6
	jne	SHORT $L38342

; 2605 : 		return false;

	xor	eax, eax
	jmp	$L38336
$L38342:

; 2606 : 
; 2607 : 	Q_snprintf( szBspFilename, sizeof( szBspFilename ), "maps/%s.bsp", szMapName );

	mov	eax, DWORD PTR _szMapName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0M@HBDC@maps?1?$CFs?4bsp?$AA@ ; `string'
	push	260					; 00000104H
	lea	ecx, DWORD PTR _szBspFilename$[ebp]
	push	ecx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 2608 : 	Q_snprintf( szGraphFilename, sizeof( szBspFilename ), "maps/graphs/%s.nod", szMapName );

	mov	edx, DWORD PTR _szMapName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BD@GMNG@maps?1graphs?1?$CFs?4nod?$AA@ ; `string'
	push	260					; 00000104H
	lea	eax, DWORD PTR _szGraphFilename$[ebp]
	push	eax
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 2609 : 
; 2610 : 	retValue = TRUE;

	mov	DWORD PTR _retValue$[ebp], 1

; 2611 : 
; 2612 : 	int iCompare;
; 2613 : 
; 2614 : 	if (COMPARE_FILE_TIME(szBspFilename, szGraphFilename, &iCompare))

	lea	ecx, DWORD PTR _iCompare$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szGraphFilename$[ebp]
	push	edx
	lea	eax, DWORD PTR _szBspFilename$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+392
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L38344

; 2616 : 		if ( iCompare > 0 )

	cmp	DWORD PTR _iCompare$[ebp], 0
	jle	SHORT $L38345

; 2618 : 			// BSP file is newer.
; 2619 : 			ALERT ( at_aiconsole, ".NOD File will be updated\n\n" );

	push	OFFSET FLAT:??_C@_0BM@KLJO@?4NOD?5File?5will?5be?5updated?6?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2620 : 			retValue = FALSE;

	mov	DWORD PTR _retValue$[ebp], 0
$L38345:

; 2623 : 	else

	jmp	SHORT $L38347
$L38344:

; 2625 : 		retValue = FALSE;

	mov	DWORD PTR _retValue$[ebp], 0
$L38347:

; 2627 : 
; 2628 : 	return retValue;

	mov	eax, DWORD PTR _retValue$[ebp]
$L38336:

; 2629 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CheckNODFile@CGraph@@QAEHPAD@Z ENDP			; CGraph::CheckNODFile
_TEXT	ENDS
PUBLIC	?HashInsert@CGraph@@QAEXHHH@Z			; CGraph::HashInsert
;	COMDAT ?HashInsert@CGraph@@QAEXHHH@Z
_TEXT	SEGMENT
_iSrcNode$ = 8
_iDestNode$ = 12
_iKey$ = 16
_this$ = -4
_np$ = -8
_dwHash$ = -12
_di$ = -16
_i$ = -20
?HashInsert@CGraph@@QAEXHHH@Z PROC NEAR			; CGraph::HashInsert, COMDAT

; 2640 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2641 : 	struct tagNodePair np;
; 2642 : 
; 2643 : 	np.iSrc  = iSrcNode;

	mov	ax, WORD PTR _iSrcNode$[ebp]
	mov	WORD PTR _np$[ebp], ax

; 2644 : 	np.iDest = iDestNode;

	mov	cx, WORD PTR _iDestNode$[ebp]
	mov	WORD PTR _np$[ebp+2], cx

; 2645 : 	CRC32_t dwHash;
; 2646 : 	CRC32_INIT(&dwHash);

	lea	edx, DWORD PTR _dwHash$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+344
	add	esp, 4

; 2647 : 	CRC32_PROCESS_BUFFER(&dwHash, &np, sizeof(np));

	push	4
	lea	eax, DWORD PTR _np$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwHash$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+348
	add	esp, 12					; 0000000cH

; 2648 : 	dwHash = CRC32_FINAL(dwHash);

	mov	edx, DWORD PTR _dwHash$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+356
	add	esp, 4
	mov	DWORD PTR _dwHash$[ebp], eax

; 2649 : 
; 2650 :     int di = m_HashPrimes[dwHash&15];

	mov	eax, DWORD PTR _dwHash$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8316]
	mov	DWORD PTR _di$[ebp], edx

; 2651 :     int i = (dwHash >> 4) % m_nHashLinks;

	mov	eax, DWORD PTR _dwHash$[ebp]
	shr	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8384]
	mov	DWORD PTR _i$[ebp], edx
$L38370:

; 2652 :     while (m_pHashLinks[i] != ENTRY_STATE_EMPTY)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8380]
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	cmp	edx, -1
	je	SHORT $L38371

; 2654 :         i += di;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _di$[ebp]
	mov	DWORD PTR _i$[ebp], eax

; 2655 :         if (i >= m_nHashLinks) i -= m_nHashLinks;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+8384]
	jl	SHORT $L38372
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, DWORD PTR [eax+8384]
	mov	DWORD PTR _i$[ebp], ecx
$L38372:

; 2656 :     }

	jmp	SHORT $L38370
$L38371:

; 2657 : 	m_pHashLinks[i] = iKey;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8380]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	dx, WORD PTR _iKey$[ebp]
	mov	WORD PTR [eax+ecx*2], dx

; 2658 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?HashInsert@CGraph@@QAEXHHH@Z ENDP			; CGraph::HashInsert
_TEXT	ENDS
;	COMDAT ?HashSearch@CGraph@@QAEXHHAAH@Z
_TEXT	SEGMENT
_iSrcNode$ = 8
_iDestNode$ = 12
_iKey$ = 16
_this$ = -4
_np$ = -8
_dwHash$ = -12
_di$ = -16
_i$ = -20
_link$38386 = -24
?HashSearch@CGraph@@QAEXHHAAH@Z PROC NEAR		; CGraph::HashSearch, COMDAT

; 2661 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2662 : 	struct tagNodePair np;
; 2663 : 
; 2664 : 	np.iSrc  = iSrcNode;

	mov	ax, WORD PTR _iSrcNode$[ebp]
	mov	WORD PTR _np$[ebp], ax

; 2665 : 	np.iDest = iDestNode;

	mov	cx, WORD PTR _iDestNode$[ebp]
	mov	WORD PTR _np$[ebp+2], cx

; 2666 : 	CRC32_t dwHash;
; 2667 : 	CRC32_INIT(&dwHash);

	lea	edx, DWORD PTR _dwHash$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+344
	add	esp, 4

; 2668 : 	CRC32_PROCESS_BUFFER(&dwHash, &np, sizeof(np));

	push	4
	lea	eax, DWORD PTR _np$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwHash$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+348
	add	esp, 12					; 0000000cH

; 2669 : 	dwHash = CRC32_FINAL(dwHash);

	mov	edx, DWORD PTR _dwHash$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+356
	add	esp, 4
	mov	DWORD PTR _dwHash$[ebp], eax

; 2670 : 
; 2671 :     int di = m_HashPrimes[dwHash&15];

	mov	eax, DWORD PTR _dwHash$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8316]
	mov	DWORD PTR _di$[ebp], edx

; 2672 :     int i = (dwHash >> 4) % m_nHashLinks;

	mov	eax, DWORD PTR _dwHash$[ebp]
	shr	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8384]
	mov	DWORD PTR _i$[ebp], edx
$L38384:

; 2673 :     while (m_pHashLinks[i] != ENTRY_STATE_EMPTY)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8380]
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	cmp	edx, -1
	je	SHORT $L38385

; 2675 : 		CLink &link = Link(m_pHashLinks[i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8380]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Link@CGraph@@QAEAAVCLink@@H@Z		; CGraph::Link
	mov	DWORD PTR _link$38386[ebp], eax

; 2676 :         if (iSrcNode == link.m_iSrcNode && iDestNode == link.m_iDestNode)

	mov	ecx, DWORD PTR _link$38386[ebp]
	mov	edx, DWORD PTR _iSrcNode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $L38387
	mov	eax, DWORD PTR _link$38386[ebp]
	mov	ecx, DWORD PTR _iDestNode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L38387

; 2678 : 			break;

	jmp	SHORT $L38385
$L38387:

; 2682 :             i += di;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, DWORD PTR _di$[ebp]
	mov	DWORD PTR _i$[ebp], edx

; 2683 :             if (i >= m_nHashLinks) i -= m_nHashLinks;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+8384]
	jl	SHORT $L38389
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, DWORD PTR [edx+8384]
	mov	DWORD PTR _i$[ebp], eax
$L38389:

; 2685 :     }

	jmp	SHORT $L38384
$L38385:

; 2686 : 	iKey = m_pHashLinks[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8380]
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	mov	edx, DWORD PTR _iKey$[ebp]
	mov	DWORD PTR [edx], ecx

; 2687 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?HashSearch@CGraph@@QAEXHHAAH@Z ENDP			; CGraph::HashSearch
_TEXT	ENDS
PUBLIC	?HashChoosePrimes@CGraph@@QAEXH@Z		; CGraph::HashChoosePrimes
;	COMDAT ?HashChoosePrimes@CGraph@@QAEXH@Z
_TEXT	SEGMENT
_TableSize$ = 8
_this$ = -4
_LargestPrime$ = -8
_Spacing$ = -12
_iZone$ = -16
_iPrime$ = -20
_Lower$38404 = -24
_jPrime$38405 = -28
_Upper$38410 = -32
_Pick$38420 = -36
_Temp$38421 = -40
?HashChoosePrimes@CGraph@@QAEXH@Z PROC NEAR		; CGraph::HashChoosePrimes, COMDAT

; 2705 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2706 :     int LargestPrime = TableSize/2;

	mov	eax, DWORD PTR _TableSize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _LargestPrime$[ebp], eax

; 2707 :     if (LargestPrime > Primes[NUMBER_OF_PRIMES-2])

	mov	eax, DWORD PTR _LargestPrime$[ebp]
	cmp	eax, DWORD PTR ?Primes@@3PAHA+700
	jle	SHORT $L38397

; 2709 :         LargestPrime = Primes[NUMBER_OF_PRIMES-2];

	mov	ecx, DWORD PTR ?Primes@@3PAHA+700
	mov	DWORD PTR _LargestPrime$[ebp], ecx
$L38397:

; 2711 :     int Spacing = LargestPrime/16;

	mov	eax, DWORD PTR _LargestPrime$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	DWORD PTR _Spacing$[ebp], eax

; 2712 : 
; 2713 :     // Pick a set primes that are evenly spaced from (0 to LargestPrime)
; 2714 :     // We divide this interval into 16 equal sized zones. We want to find
; 2715 :     // one prime number that best represents that zone.
; 2716 :     //
; 2717 :     for (int iZone = 1, iPrime = 0; iPrime < 16; iZone += Spacing)

	mov	DWORD PTR _iZone$[ebp], 1
	mov	DWORD PTR _iPrime$[ebp], 0
	jmp	SHORT $L38401
$L38402:
	mov	edx, DWORD PTR _iZone$[ebp]
	add	edx, DWORD PTR _Spacing$[ebp]
	mov	DWORD PTR _iZone$[ebp], edx
$L38401:
	cmp	DWORD PTR _iPrime$[ebp], 16		; 00000010H
	jge	$L38403

; 2719 :         // Search for a prime number that is less than the target zone
; 2720 :         // number given by iZone.
; 2721 :         //
; 2722 :         int Lower = Primes[0];

	mov	eax, DWORD PTR ?Primes@@3PAHA
	mov	DWORD PTR _Lower$38404[ebp], eax

; 2723 :         for (int jPrime = 0; Primes[jPrime] != 0; jPrime++)

	mov	DWORD PTR _jPrime$38405[ebp], 0
	jmp	SHORT $L38406
$L38407:
	mov	ecx, DWORD PTR _jPrime$38405[ebp]
	add	ecx, 1
	mov	DWORD PTR _jPrime$38405[ebp], ecx
$L38406:
	mov	edx, DWORD PTR _jPrime$38405[ebp]
	cmp	DWORD PTR ?Primes@@3PAHA[edx*4], 0
	je	$L38408

; 2725 :             if (jPrime != 0 && TableSize % Primes[jPrime] == 0) continue;

	cmp	DWORD PTR _jPrime$38405[ebp], 0
	je	SHORT $L38409
	mov	ecx, DWORD PTR _jPrime$38405[ebp]
	mov	eax, DWORD PTR _TableSize$[ebp]
	cdq
	idiv	DWORD PTR ?Primes@@3PAHA[ecx*4]
	test	edx, edx
	jne	SHORT $L38409
	jmp	SHORT $L38407
$L38409:

; 2726 :             int Upper = Primes[jPrime];

	mov	edx, DWORD PTR _jPrime$38405[ebp]
	mov	eax, DWORD PTR ?Primes@@3PAHA[edx*4]
	mov	DWORD PTR _Upper$38410[ebp], eax

; 2727 :             if (Lower <= iZone && iZone <= Upper)

	mov	ecx, DWORD PTR _Lower$38404[ebp]
	cmp	ecx, DWORD PTR _iZone$[ebp]
	jg	SHORT $L38411
	mov	edx, DWORD PTR _iZone$[ebp]
	cmp	edx, DWORD PTR _Upper$38410[ebp]
	jg	SHORT $L38411

; 2729 :                 // Choose the closest lower prime number.
; 2730 :                 //
; 2731 :                 if (iZone - Lower <= Upper - iZone)

	mov	eax, DWORD PTR _iZone$[ebp]
	sub	eax, DWORD PTR _Lower$38404[ebp]
	mov	ecx, DWORD PTR _Upper$38410[ebp]
	sub	ecx, DWORD PTR _iZone$[ebp]
	cmp	eax, ecx
	jg	SHORT $L38412

; 2733 :                     m_HashPrimes[iPrime++] = Lower;

	mov	edx, DWORD PTR _iPrime$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Lower$38404[ebp]
	mov	DWORD PTR [eax+edx*4+8316], ecx
	mov	edx, DWORD PTR _iPrime$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPrime$[ebp], edx

; 2735 :                 else

	jmp	SHORT $L38413
$L38412:

; 2737 :                     m_HashPrimes[iPrime++] = Upper;

	mov	eax, DWORD PTR _iPrime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Upper$38410[ebp]
	mov	DWORD PTR [ecx+eax*4+8316], edx
	mov	eax, DWORD PTR _iPrime$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPrime$[ebp], eax
$L38413:

; 2739 :                 break;

	jmp	SHORT $L38408
$L38411:

; 2741 :             Lower = Upper;

	mov	ecx, DWORD PTR _Upper$38410[ebp]
	mov	DWORD PTR _Lower$38404[ebp], ecx

; 2742 :         }

	jmp	$L38407
$L38408:

; 2743 :     }

	jmp	$L38402
$L38403:

; 2744 : 
; 2745 :     // Alternate negative and positive numbers
; 2746 :     //
; 2747 :     for (iPrime = 0; iPrime < 16; iPrime += 2)

	mov	DWORD PTR _iPrime$[ebp], 0
	jmp	SHORT $L38414
$L38415:
	mov	edx, DWORD PTR _iPrime$[ebp]
	add	edx, 2
	mov	DWORD PTR _iPrime$[ebp], edx
$L38414:
	cmp	DWORD PTR _iPrime$[ebp], 16		; 00000010H
	jge	SHORT $L38416

; 2749 :         m_HashPrimes[iPrime] = TableSize-m_HashPrimes[iPrime];

	mov	eax, DWORD PTR _iPrime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _TableSize$[ebp]
	sub	edx, DWORD PTR [ecx+eax*4+8316]
	mov	eax, DWORD PTR _iPrime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+8316], edx

; 2750 :     }

	jmp	SHORT $L38415
$L38416:

; 2751 : 
; 2752 :     // Shuffle the set of primes to reduce correlation with bits in
; 2753 :     // hash key.
; 2754 :     //
; 2755 :     for (iPrime = 0; iPrime < 16-1; iPrime++)

	mov	DWORD PTR _iPrime$[ebp], 0
	jmp	SHORT $L38417
$L38418:
	mov	edx, DWORD PTR _iPrime$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPrime$[ebp], edx
$L38417:
	cmp	DWORD PTR _iPrime$[ebp], 15		; 0000000fH
	jge	SHORT $L38419

; 2757 :         int Pick = RANDOM_LONG(0, 15-iPrime);

	mov	eax, 15					; 0000000fH
	sub	eax, DWORD PTR _iPrime$[ebp]
	push	eax
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR _Pick$38420[ebp], eax

; 2758 :         int Temp = m_HashPrimes[Pick];

	mov	ecx, DWORD PTR _Pick$38420[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+8316]
	mov	DWORD PTR _Temp$38421[ebp], eax

; 2759 :         m_HashPrimes[Pick] = m_HashPrimes[15-iPrime];

	mov	ecx, 15					; 0000000fH
	sub	ecx, DWORD PTR _iPrime$[ebp]
	mov	edx, DWORD PTR _Pick$38420[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+8316]
	mov	DWORD PTR [eax+edx*4+8316], ecx

; 2760 :         m_HashPrimes[15-iPrime] = Temp;

	mov	edx, 15					; 0000000fH
	sub	edx, DWORD PTR _iPrime$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Temp$38421[ebp]
	mov	DWORD PTR [eax+edx*4+8316], ecx

; 2761 :     }

	jmp	SHORT $L38418
$L38419:

; 2762 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HashChoosePrimes@CGraph@@QAEXH@Z ENDP			; CGraph::HashChoosePrimes
_TEXT	ENDS
PUBLIC	??0CNode@@QAE@ABV0@@Z				; CNode::CNode
;	COMDAT ?SortNodes@CGraph@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_iNodeCnt$ = -8
_i$ = -12
_j$38435 = -16
_iDestNode$38439 = -20
_iDestNode$38454 = -24
_TempNode$38455 = -112
?SortNodes@CGraph@@QAEXXZ PROC NEAR			; CGraph::SortNodes, COMDAT

; 2768 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2769 : 	// We are using m_iPreviousNode to be the new node number.
; 2770 : 	// After assigning new node numbers to everything, we move
; 2771 : 	// things and patchup the links.
; 2772 : 	//
; 2773 : 	int iNodeCnt = 0;

	mov	DWORD PTR _iNodeCnt$[ebp], 0

; 2774 : 	m_pNodes[0].m_iPreviousNode = iNodeCnt++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _iNodeCnt$[ebp]
	mov	DWORD PTR [ecx+76], edx
	mov	eax, DWORD PTR _iNodeCnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNodeCnt$[ebp], eax

; 2775 : 	for (int i = 1; i < m_cNodes; i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L38429
$L38430:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L38429:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $L38431

; 2777 : 		m_pNodes[i].m_iPreviousNode = UNNUMBERED_NODE;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+ecx+76], -1

; 2778 : 	}

	jmp	SHORT $L38430
$L38431:

; 2779 : 
; 2780 : 	for (i = 0; i < m_cNodes; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38432
$L38433:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L38432:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $L38434

; 2782 : 		// Run through all of this node's neighbors
; 2783 : 		//
; 2784 : 		for (int j = 0 ; j < m_pNodes[i].m_cNumLinks; j++ )

	mov	DWORD PTR _j$38435[ebp], 0
	jmp	SHORT $L38436
$L38437:
	mov	ecx, DWORD PTR _j$38435[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$38435[ebp], ecx
$L38436:
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _j$38435[ebp]
	cmp	eax, DWORD PTR [ecx+edx+32]
	jge	SHORT $L38438

; 2786 : 			int iDestNode = INodeLink(i, j);

	mov	ecx, DWORD PTR _j$38435[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?INodeLink@CGraph@@QAEHHH@Z		; CGraph::INodeLink
	mov	DWORD PTR _iDestNode$38439[ebp], eax

; 2787 : 			if (m_pNodes[iDestNode].m_iPreviousNode == UNNUMBERED_NODE)

	mov	eax, DWORD PTR _iDestNode$38439[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	DWORD PTR [edx+eax+76], -1
	jne	SHORT $L38440

; 2789 : 				m_pNodes[iDestNode].m_iPreviousNode = iNodeCnt++;

	mov	eax, DWORD PTR _iDestNode$38439[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _iNodeCnt$[ebp]
	mov	DWORD PTR [edx+eax+76], ecx
	mov	edx, DWORD PTR _iNodeCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNodeCnt$[ebp], edx
$L38440:

; 2791 : 		}

	jmp	SHORT $L38437
$L38438:

; 2792 : 	}

	jmp	$L38433
$L38434:

; 2793 : 
; 2794 : 	// Assign remaining node numbers to unlinked nodes.
; 2795 : 	//
; 2796 : 	for (i = 0; i < m_cNodes; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38441
$L38442:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38441:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L38443

; 2798 : 		if (m_pNodes[i].m_iPreviousNode == UNNUMBERED_NODE)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	DWORD PTR [edx+eax+76], -1
	jne	SHORT $L38444

; 2800 : 			m_pNodes[i].m_iPreviousNode = iNodeCnt++;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _iNodeCnt$[ebp]
	mov	DWORD PTR [edx+eax+76], ecx
	mov	edx, DWORD PTR _iNodeCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNodeCnt$[ebp], edx
$L38444:

; 2802 : 	}

	jmp	SHORT $L38442
$L38443:

; 2803 : 
; 2804 : 	// Alter links to reflect new node numbers.
; 2805 : 	//
; 2806 : 	for (i = 0; i < m_cLinks; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38445
$L38446:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38445:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $L38447

; 2808 : 		m_pLinkPool[i].m_iSrcNode  = m_pNodes[m_pLinkPool[i].m_iSrcNode].m_iPreviousNode;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+eax]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [edx+eax+76]
	mov	DWORD PTR [esi+ecx], edx

; 2809 : 		m_pLinkPool[i].m_iDestNode = m_pNodes[m_pLinkPool[i].m_iDestNode].m_iPreviousNode;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+eax+4]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [edx+eax+76]
	mov	DWORD PTR [esi+ecx+4], edx

; 2810 : 	}

	jmp	SHORT $L38446
$L38447:

; 2811 : 
; 2812 : 	// Rearrange nodes to reflect new node numbering.
; 2813 : 	//
; 2814 : 	for (i = 0; i < m_cNodes; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38448
$L38449:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38448:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$L38450
$L38452:

; 2816 : 		while (m_pNodes[i].m_iPreviousNode != i)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax+76]
	cmp	eax, DWORD PTR _i$[ebp]
	je	SHORT $L38453

; 2818 : 			// Move current node off to where it should be, and bring
; 2819 : 			// that other node back into the current slot.
; 2820 : 			//
; 2821 : 			int iDestNode = m_pNodes[i].m_iPreviousNode;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx+76]
	mov	DWORD PTR _iDestNode$38454[ebp], ecx

; 2822 : 			CNode TempNode = m_pNodes[iDestNode];

	mov	edx, DWORD PTR _iDestNode$38454[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, edx
	push	ecx
	lea	ecx, DWORD PTR _TempNode$38455[ebp]
	call	??0CNode@@QAE@ABV0@@Z			; CNode::CNode

; 2823 : 			m_pNodes[iDestNode] = m_pNodes[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, edx
	mov	ecx, DWORD PTR _iDestNode$38454[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR [edx+12]
	add	edi, ecx
	mov	ecx, 22					; 00000016H
	rep movsd

; 2824 : 			m_pNodes[i] = TempNode;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR [ecx+12]
	add	edi, eax
	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _TempNode$38455[ebp]
	rep movsd

; 2825 : 		}

	jmp	SHORT $L38452
$L38453:

; 2826 : 	}

	jmp	$L38449
$L38450:

; 2827 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SortNodes@CGraph@@QAEXXZ ENDP				; CGraph::SortNodes
_TEXT	ENDS
;	COMDAT ??0CNode@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0CNode@@QAE@ABV0@@Z PROC NEAR				; CNode::CNode, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	cx, WORD PTR [edx]
	mov	WORD PTR [eax], cx
	mov	dl, BYTE PTR [edx+2]
	mov	BYTE PTR [eax+2], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 40					; 00000028H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 40					; 00000028H
	mov	ecx, 8
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+72], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dx, WORD PTR [ecx+80]
	mov	WORD PTR [eax+80], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dx, WORD PTR [ecx+82]
	mov	WORD PTR [eax+82], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CNode@@QAE@ABV0@@Z ENDP				; CNode::CNode
_TEXT	ENDS
PUBLIC	??_C@_0CH@OAFF@Couldn?8t?5allocated?5Link?5Lookup?5T@ ; `string'
;	COMDAT ??_C@_0CH@OAFF@Couldn?8t?5allocated?5Link?5Lookup?5T@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0CH@OAFF@Couldn?8t?5allocated?5Link?5Lookup?5T@ DB 'Couldn''t alloc'
	DB	'ated Link Lookup Table.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?BuildLinkLookups@CGraph@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
_link$38474 = -12
?BuildLinkLookups@CGraph@@QAEXXZ PROC NEAR		; CGraph::BuildLinkLookups, COMDAT

; 2830 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2831 : 	m_nHashLinks = 3*m_cLinks/2 + 3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	imul	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8384], eax

; 2832 : 
; 2833 : 	HashChoosePrimes(m_nHashLinks);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8384]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HashChoosePrimes@CGraph@@QAEXH@Z	; CGraph::HashChoosePrimes

; 2834 : 	m_pHashLinks = (short *)calloc(sizeof(short), m_nHashLinks);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8384]
	push	edx
	push	2
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8380], eax

; 2835 : 	if (!m_pHashLinks)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8380], 0
	jne	SHORT $L38465

; 2837 : 		ALERT(at_aiconsole, "Couldn't allocated Link Lookup Table.\n");

	push	OFFSET FLAT:??_C@_0CH@OAFF@Couldn?8t?5allocated?5Link?5Lookup?5T@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2838 : 		return;

	jmp	SHORT $L38462
$L38465:

; 2840 : 	for (int i = 0; i < m_nHashLinks; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38468
$L38469:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38468:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+8384]
	jge	SHORT $L38470

; 2842 : 		m_pHashLinks[i] = ENTRY_STATE_EMPTY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8380]
	mov	edx, DWORD PTR _i$[ebp]
	mov	WORD PTR [ecx+edx*2], -1

; 2843 : 	}

	jmp	SHORT $L38469
$L38470:

; 2844 : 
; 2845 : 	for (i = 0; i < m_cLinks; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38471
$L38472:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38471:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $L38473

; 2847 : 		CLink &link = Link(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Link@CGraph@@QAEAAVCLink@@H@Z		; CGraph::Link
	mov	DWORD PTR _link$38474[ebp], eax

; 2848 : 		HashInsert(link.m_iSrcNode, link.m_iDestNode, i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _link$38474[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _link$38474[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HashInsert@CGraph@@QAEXHHH@Z		; CGraph::HashInsert

; 2849 : 	}

	jmp	SHORT $L38472
$L38473:
$L38462:

; 2850 : #if 0
; 2851 : 	for (i = 0; i < m_cLinks; i++)
; 2852 : 	{
; 2853 : 		CLink &link = Link(i);
; 2854 : 		int iKey;
; 2855 : 		HashSearch(link.m_iSrcNode, link.m_iDestNode, iKey);
; 2856 : 		if (iKey != i)
; 2857 : 		{
; 2858 : 			ALERT(at_aiconsole, "HashLinks don't match (%d versus %d)\n", i, iKey);
; 2859 : 		}
; 2860 : 	}
; 2861 : #endif
; 2862 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildLinkLookups@CGraph@@QAEXXZ ENDP			; CGraph::BuildLinkLookups
_TEXT	ENDS
PUBLIC	??_C@_0CJ@LFII@Couldn?8t?5allocated?5node?5ordering@ ; `string'
;	COMDAT ??_C@_0CJ@LFII@Couldn?8t?5allocated?5node?5ordering@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0CJ@LFII@Couldn?8t?5allocated?5node?5ordering@ DB 'Couldn''t alloca'
	DB	'ted node ordering array.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?BuildRegionTables@CGraph@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
_j$38503 = -12
_jNode$38513 = -16
_jCodeX$38514 = -20
_jCodeY$38515 = -24
_jCodeZ$38516 = -28
_jCode$38517 = -32
_k$38525 = -36
_kNode$38529 = -40
_kCodeX$38530 = -44
_kCodeY$38531 = -48
_kCodeZ$38532 = -52
_kCode$38533 = -56
_Tmp$38542 = -60
_CodeX$38546 = -64
_CodeY$38547 = -68
_CodeZ$38548 = -72
?BuildRegionTables@CGraph@@QAEXXZ PROC NEAR		; CGraph::BuildRegionTables, COMDAT

; 2865 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2866 : 	if (m_di) free(m_di);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $L38479
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_free
	add	esp, 4
$L38479:

; 2867 : 
; 2868 : 	// Go ahead and setup for range searching the nodes for FindNearestNodes
; 2869 : 	//
; 2870 : 	m_di = (DIST_INFO *)calloc(sizeof(DIST_INFO), m_cNodes);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	16					; 00000010H
	call	_calloc
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], eax

; 2871 : 	if (!m_di)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $L38482

; 2873 : 		ALERT(at_aiconsole, "Couldn't allocated node ordering array.\n");

	push	OFFSET FLAT:??_C@_0CJ@LFII@Couldn?8t?5allocated?5node?5ordering@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2874 : 		return;

	jmp	$L38478
$L38482:

; 2876 : 
; 2877 : 	// Calculate regions for all the nodes.
; 2878 : 	//
; 2879 : 	//
; 2880 : 	for (int i = 0; i < 3; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38485
$L38486:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L38485:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $L38487

; 2882 : 		m_RegionMin[i] =  999999999.0; // just a big number out there;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+6244], 1315859240	; 4e6e6b28H

; 2883 : 		m_RegionMax[i] = -999999999.0; // just a big number out there;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+6256], -831624408	; ce6e6b28H

; 2884 : 	}

	jmp	SHORT $L38486
$L38487:

; 2885 : 	for (i = 0; i < m_cNodes; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38488
$L38489:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38488:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$L38490

; 2887 : 		if (m_pNodes[i].m_vecOrigin.x < m_RegionMin[0])

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+eax]
	fcomp	DWORD PTR [ecx+6244]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38491

; 2888 : 			m_RegionMin[0] = m_pNodes[i].m_vecOrigin.x;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+6244], ecx
$L38491:

; 2889 : 		if (m_pNodes[i].m_vecOrigin.y < m_RegionMin[1])

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+edx+4]
	fcomp	DWORD PTR [eax+6248]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38492

; 2890 : 			m_RegionMin[1] = m_pNodes[i].m_vecOrigin.y;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR [edx+6248], eax
$L38492:

; 2891 : 		if (m_pNodes[i].m_vecOrigin.z < m_RegionMin[2])

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+ecx+8]
	fcomp	DWORD PTR [edx+6252]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38493

; 2892 : 			m_RegionMin[2] = m_pNodes[i].m_vecOrigin.z;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [ecx+6252], edx
$L38493:

; 2893 : 
; 2894 : 		if (m_pNodes[i].m_vecOrigin.x > m_RegionMax[0])

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+eax]
	fcomp	DWORD PTR [ecx+6256]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38494

; 2895 : 			m_RegionMax[0] = m_pNodes[i].m_vecOrigin.x;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+6256], ecx
$L38494:

; 2896 : 		if (m_pNodes[i].m_vecOrigin.y > m_RegionMax[1])

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+edx+4]
	fcomp	DWORD PTR [eax+6260]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38495

; 2897 : 			m_RegionMax[1] = m_pNodes[i].m_vecOrigin.y;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR [edx+6260], eax
$L38495:

; 2898 : 		if (m_pNodes[i].m_vecOrigin.z > m_RegionMax[2])

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+ecx+8]
	fcomp	DWORD PTR [edx+6264]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38496

; 2899 : 			m_RegionMax[2] = m_pNodes[i].m_vecOrigin.z;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [ecx+6264], edx
$L38496:

; 2900 : 	}

	jmp	$L38489
$L38490:

; 2901 : 	for (i = 0; i < m_cNodes; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38497
$L38498:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38497:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$L38499

; 2903 : 		m_pNodes[i].m_Region[0] = CALC_RANGE(m_pNodes[i].m_vecOrigin.x, m_RegionMin[0], m_RegionMax[0]);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+6256]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+6244]
	call	__ftol
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	fld	DWORD PTR [ecx+edx]
	call	__ftol
	push	eax
	call	?CALC_RANGE@@YAHHHH@Z			; CALC_RANGE
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	BYTE PTR [ecx+edx+24], al

; 2904 : 		m_pNodes[i].m_Region[1] = CALC_RANGE(m_pNodes[i].m_vecOrigin.y, m_RegionMin[1], m_RegionMax[1]);

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+6260]
	call	__ftol
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+6248]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	fld	DWORD PTR [eax+ecx+4]
	call	__ftol
	push	eax
	call	?CALC_RANGE@@YAHHHH@Z			; CALC_RANGE
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	BYTE PTR [edx+ecx+25], al

; 2905 : 		m_pNodes[i].m_Region[2] = CALC_RANGE(m_pNodes[i].m_vecOrigin.z, m_RegionMin[2], m_RegionMax[2]);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+6264]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+6252]
	call	__ftol
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	fld	DWORD PTR [ecx+edx+8]
	call	__ftol
	push	eax
	call	?CALC_RANGE@@YAHHHH@Z			; CALC_RANGE
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	BYTE PTR [ecx+edx+26], al

; 2906 : 	}

	jmp	$L38498
$L38499:

; 2907 : 
; 2908 : 	for (i = 0; i < 3; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38500
$L38501:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L38500:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$L38502

; 2910 : 		for (int j = 0; j < NUM_RANGES; j++)

	mov	DWORD PTR _j$38503[ebp], 0
	jmp	SHORT $L38504
$L38505:
	mov	eax, DWORD PTR _j$38503[ebp]
	add	eax, 1
	mov	DWORD PTR _j$38503[ebp], eax
$L38504:
	cmp	DWORD PTR _j$38503[ebp], 256		; 00000100H
	jge	SHORT $L38506

; 2912 : 			m_RangeStart[i][j] = 255;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+40]
	mov	ecx, DWORD PTR _j$38503[ebp]
	mov	DWORD PTR [eax+ecx*4], 255		; 000000ffH

; 2913 : 			m_RangeEnd[i][j] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+3112]
	mov	edx, DWORD PTR _j$38503[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 2914 : 		}

	jmp	SHORT $L38505
$L38506:

; 2915 : 		for (j = 0; j < m_cNodes; j++)

	mov	DWORD PTR _j$38503[ebp], 0
	jmp	SHORT $L38507
$L38508:
	mov	eax, DWORD PTR _j$38503[ebp]
	add	eax, 1
	mov	DWORD PTR _j$38503[ebp], eax
$L38507:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _j$38503[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L38509

; 2917 : 			m_di[j].m_SortedBy[i] = j;

	mov	eax, DWORD PTR _j$38503[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, eax
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _j$38503[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 2918 : 		}

	jmp	SHORT $L38508
$L38509:

; 2919 : 
; 2920 : 		for (j = 0; j < m_cNodes - 1; j++)

	mov	DWORD PTR _j$38503[ebp], 0
	jmp	SHORT $L38510
$L38511:
	mov	edx, DWORD PTR _j$38503[ebp]
	add	edx, 1
	mov	DWORD PTR _j$38503[ebp], edx
$L38510:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, 1
	cmp	DWORD PTR _j$38503[ebp], ecx
	jge	$L38512

; 2922 : 			int jNode = m_di[j].m_SortedBy[i];

	mov	edx, DWORD PTR _j$38503[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, edx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _jNode$38513[ebp], eax

; 2923 : 			int jCodeX = m_pNodes[jNode].m_Region[0];

	mov	ecx, DWORD PTR _jNode$38513[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	xor	edx, edx
	mov	dl, BYTE PTR [eax+ecx+24]
	mov	DWORD PTR _jCodeX$38514[ebp], edx

; 2924 : 			int jCodeY = m_pNodes[jNode].m_Region[1];

	mov	eax, DWORD PTR _jNode$38513[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+eax+25]
	mov	DWORD PTR _jCodeY$38515[ebp], ecx

; 2925 : 			int jCodeZ = m_pNodes[jNode].m_Region[2];

	mov	edx, DWORD PTR _jNode$38513[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+edx+26]
	mov	DWORD PTR _jCodeZ$38516[ebp], eax

; 2928 : 			{

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR -76+[ebp], ecx
	cmp	DWORD PTR -76+[ebp], 0
	je	SHORT $L38522
	cmp	DWORD PTR -76+[ebp], 1
	je	SHORT $L38523
	cmp	DWORD PTR -76+[ebp], 2
	je	SHORT $L38524
	jmp	SHORT $L38519
$L38522:

; 2929 : 			case 0:
; 2930 : 				jCode = (jCodeX << 16) + (jCodeY << 8) + jCodeZ;

	mov	edx, DWORD PTR _jCodeX$38514[ebp]
	shl	edx, 16					; 00000010H
	mov	eax, DWORD PTR _jCodeY$38515[ebp]
	shl	eax, 8
	mov	ecx, DWORD PTR _jCodeZ$38516[ebp]
	add	ecx, edx
	add	eax, ecx
	mov	DWORD PTR _jCode$38517[ebp], eax

; 2931 : 				break;

	jmp	SHORT $L38519
$L38523:

; 2932 : 			case 1:
; 2933 : 				jCode = (jCodeY << 16) + (jCodeZ << 8) + jCodeX;

	mov	edx, DWORD PTR _jCodeY$38515[ebp]
	shl	edx, 16					; 00000010H
	mov	eax, DWORD PTR _jCodeZ$38516[ebp]
	shl	eax, 8
	mov	ecx, DWORD PTR _jCodeX$38514[ebp]
	add	ecx, edx
	add	eax, ecx
	mov	DWORD PTR _jCode$38517[ebp], eax

; 2934 : 				break;

	jmp	SHORT $L38519
$L38524:

; 2935 : 			case 2:
; 2936 : 				jCode = (jCodeZ << 16) + (jCodeX << 8) + jCodeY;

	mov	edx, DWORD PTR _jCodeZ$38516[ebp]
	shl	edx, 16					; 00000010H
	mov	eax, DWORD PTR _jCodeX$38514[ebp]
	shl	eax, 8
	mov	ecx, DWORD PTR _jCodeY$38515[ebp]
	add	ecx, edx
	add	eax, ecx
	mov	DWORD PTR _jCode$38517[ebp], eax
$L38519:

; 2939 : 
; 2940 : 			for (int k = j+1; k < m_cNodes; k++)

	mov	edx, DWORD PTR _j$38503[ebp]
	add	edx, 1
	mov	DWORD PTR _k$38525[ebp], edx
	jmp	SHORT $L38526
$L38527:
	mov	eax, DWORD PTR _k$38525[ebp]
	add	eax, 1
	mov	DWORD PTR _k$38525[ebp], eax
$L38526:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _k$38525[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$L38528

; 2942 : 				int kNode = m_di[k].m_SortedBy[i];

	mov	eax, DWORD PTR _k$38525[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, eax
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _kNode$38529[ebp], ecx

; 2943 : 				int kCodeX = m_pNodes[kNode].m_Region[0];

	mov	edx, DWORD PTR _kNode$38529[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+edx+24]
	mov	DWORD PTR _kCodeX$38530[ebp], eax

; 2944 : 				int kCodeY = m_pNodes[kNode].m_Region[1];

	mov	ecx, DWORD PTR _kNode$38529[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	xor	edx, edx
	mov	dl, BYTE PTR [eax+ecx+25]
	mov	DWORD PTR _kCodeY$38531[ebp], edx

; 2945 : 				int kCodeZ = m_pNodes[kNode].m_Region[2];

	mov	eax, DWORD PTR _kNode$38529[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+eax+26]
	mov	DWORD PTR _kCodeZ$38532[ebp], ecx

; 2948 : 				{

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR -80+[ebp], edx
	cmp	DWORD PTR -80+[ebp], 0
	je	SHORT $L38538
	cmp	DWORD PTR -80+[ebp], 1
	je	SHORT $L38539
	cmp	DWORD PTR -80+[ebp], 2
	je	SHORT $L38540
	jmp	SHORT $L38535
$L38538:

; 2949 : 				case 0:
; 2950 : 					kCode = (kCodeX << 16) + (kCodeY << 8) + kCodeZ;

	mov	eax, DWORD PTR _kCodeX$38530[ebp]
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _kCodeY$38531[ebp]
	shl	ecx, 8
	mov	edx, DWORD PTR _kCodeZ$38532[ebp]
	add	edx, eax
	add	ecx, edx
	mov	DWORD PTR _kCode$38533[ebp], ecx

; 2951 : 					break;

	jmp	SHORT $L38535
$L38539:

; 2952 : 				case 1:
; 2953 : 					kCode = (kCodeY << 16) + (kCodeZ << 8) + kCodeX;

	mov	eax, DWORD PTR _kCodeY$38531[ebp]
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _kCodeZ$38532[ebp]
	shl	ecx, 8
	mov	edx, DWORD PTR _kCodeX$38530[ebp]
	add	edx, eax
	add	ecx, edx
	mov	DWORD PTR _kCode$38533[ebp], ecx

; 2954 : 					break;

	jmp	SHORT $L38535
$L38540:

; 2955 : 				case 2:
; 2956 : 					kCode = (kCodeZ << 16) + (kCodeX << 8) + kCodeY;

	mov	eax, DWORD PTR _kCodeZ$38532[ebp]
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _kCodeX$38530[ebp]
	shl	ecx, 8
	mov	edx, DWORD PTR _kCodeY$38531[ebp]
	add	edx, eax
	add	ecx, edx
	mov	DWORD PTR _kCode$38533[ebp], ecx
$L38535:

; 2959 : 
; 2960 : 				if (kCode < jCode)

	mov	eax, DWORD PTR _kCode$38533[ebp]
	cmp	eax, DWORD PTR _jCode$38517[ebp]
	jge	SHORT $L38541

; 2962 : 					// Swap j and k entries.
; 2963 : 					//
; 2964 : 					int Tmp = m_di[j].m_SortedBy[i];

	mov	ecx, DWORD PTR _j$38503[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, ecx
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _Tmp$38542[ebp], edx

; 2965 : 					m_di[j].m_SortedBy[i] = m_di[k].m_SortedBy[i];

	mov	eax, DWORD PTR _k$38525[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, eax
	mov	eax, DWORD PTR _j$38503[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	add	ecx, eax
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 2966 : 					m_di[k].m_SortedBy[i] = Tmp;

	mov	eax, DWORD PTR _k$38525[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, eax
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _Tmp$38542[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
$L38541:

; 2968 : 			}

	jmp	$L38527
$L38528:

; 2969 : 		}

	jmp	$L38511
$L38512:

; 2970 : 	}

	jmp	$L38501
$L38502:

; 2971 : 
; 2972 : 	// Generate lookup tables.
; 2973 : 	//
; 2974 : 	for (i = 0; i < m_cNodes; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38543
$L38544:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L38543:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	$L38545

; 2976 : 		int CodeX = m_pNodes[m_di[i].m_SortedBy[0]].m_Region[0];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+edx+24]
	mov	DWORD PTR _CodeX$38546[ebp], eax

; 2977 : 		int CodeY = m_pNodes[m_di[i].m_SortedBy[1]].m_Region[1];

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx+4]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	xor	edx, edx
	mov	dl, BYTE PTR [eax+ecx+25]
	mov	DWORD PTR _CodeY$38547[ebp], edx

; 2978 : 		int CodeZ = m_pNodes[m_di[i].m_SortedBy[2]].m_Region[2];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax+8]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+eax+26]
	mov	DWORD PTR _CodeZ$38548[ebp], ecx

; 2979 : 
; 2980 :         if (i < m_RangeStart[0][CodeX])

	mov	edx, DWORD PTR _CodeX$38546[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4+40]
	jge	SHORT $L38549

; 2982 :             m_RangeStart[0][CodeX] = i;

	mov	edx, DWORD PTR _CodeX$38546[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+edx*4+40], ecx
$L38549:

; 2984 :         if (i < m_RangeStart[1][CodeY])

	mov	edx, DWORD PTR _CodeY$38547[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4+1064]
	jge	SHORT $L38550

; 2986 :             m_RangeStart[1][CodeY] = i;

	mov	edx, DWORD PTR _CodeY$38547[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+edx*4+1064], ecx
$L38550:

; 2988 :         if (i < m_RangeStart[2][CodeZ])

	mov	edx, DWORD PTR _CodeZ$38548[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4+2088]
	jge	SHORT $L38551

; 2990 :             m_RangeStart[2][CodeZ] = i;

	mov	edx, DWORD PTR _CodeZ$38548[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+edx*4+2088], ecx
$L38551:

; 2992 :         if (m_RangeEnd[0][CodeX] < i)

	mov	edx, DWORD PTR _CodeX$38546[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+3112]
	cmp	ecx, DWORD PTR _i$[ebp]
	jge	SHORT $L38552

; 2994 :             m_RangeEnd[0][CodeX] = i;

	mov	edx, DWORD PTR _CodeX$38546[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+edx*4+3112], ecx
$L38552:

; 2996 :         if (m_RangeEnd[1][CodeY] < i)

	mov	edx, DWORD PTR _CodeY$38547[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4136]
	cmp	ecx, DWORD PTR _i$[ebp]
	jge	SHORT $L38553

; 2998 :             m_RangeEnd[1][CodeY] = i;

	mov	edx, DWORD PTR _CodeY$38547[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+edx*4+4136], ecx
$L38553:

; 3000 :         if (m_RangeEnd[2][CodeZ] < i)

	mov	edx, DWORD PTR _CodeZ$38548[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+5160]
	cmp	ecx, DWORD PTR _i$[ebp]
	jge	SHORT $L38554

; 3002 :             m_RangeEnd[2][CodeZ] = i;

	mov	edx, DWORD PTR _CodeZ$38548[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+edx*4+5160], ecx
$L38554:

; 3004 : 	}

	jmp	$L38544
$L38545:

; 3005 : 
; 3006 : 	// Initialize the cache.
; 3007 : 	//
; 3008 : 	memset(m_Cache, 0, sizeof(m_Cache));

	push	2048					; 00000800H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 6268				; 0000187cH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$L38478:

; 3009 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildRegionTables@CGraph@@QAEXXZ ENDP			; CGraph::BuildRegionTables
_TEXT	ENDS
PUBLIC	??_C@_0BN@CKJO@Nodes?5need?5sorting?5?$CI?$CFd?0?$CFd?$CJ?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@KDEG@Size?5of?5Routes?5?$DN?5?$CFd?6?$AA@ ; `string'
EXTRN	_memcmp:NEAR
;	COMDAT ??_C@_0BN@CKJO@Nodes?5need?5sorting?5?$CI?$CFd?0?$CFd?$CJ?$CB?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BN@CKJO@Nodes?5need?5sorting?5?$CI?$CFd?0?$CFd?$CJ?$CB?6?$AA@ DB 'N'
	DB	'odes need sorting (%d,%d)!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KDEG@Size?5of?5Routes?5?$DN?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BF@KDEG@Size?5of?5Routes?5?$DN?5?$CFd?6?$AA@ DB 'Size of Routes = '
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?ComputeStaticRoutingTables@CGraph@@QAEXXZ
_TEXT	SEGMENT
$T40197 = -152
$T40198 = -156
$T40199 = -160
$T40200 = -164
$T40205 = -168
$T40206 = -172
$T40207 = -176
$T40208 = -180
_this$ = -4
_nRoutes$ = -8
_Routes$ = -12
_pMyPath$ = -16
_BestNextNodes$ = -20
_pRoute$ = -24
_nTotalCompressedSize$38574 = -28
_iHull$38575 = -32
_iCap$38579 = -36
_iCapMask$38583 = -40
_iFrom$38590 = -44
_iTo$38594 = -48
_iTo$38601 = -52
_cPathSize$38606 = -56
_iNode$38608 = -60
_iStart$38612 = -64
_iNext$38613 = -68
_iNode1$38614 = -72
_iEnd$38618 = -76
_iTo$38623 = -80
_iLastNode$38627 = -84
_cSequence$38628 = -88
_cRepeats$38629 = -92
_CompressedSize$38630 = -96
_p$38631 = -100
_i$38632 = -104
_CanRepeat$38636 = -108
_CanSequence$38637 = -112
_a$38641 = -116
_b$38642 = -120
_c$38643 = -124
_a$38663 = -128
_b$38664 = -132
_c$38665 = -136
_nRoute$38673 = -140
_i$38675 = -144
_Tmp$38682 = -148
?ComputeStaticRoutingTables@CGraph@@QAEXXZ PROC NEAR	; CGraph::ComputeStaticRoutingTables, COMDAT

; 3012 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3013 : 	int nRoutes = m_cNodes*m_cNodes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+24]
	imul	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _nRoutes$[ebp], edx

; 3014 : #define FROM_TO(x,y) ((x)*m_cNodes+(y))
; 3015 : 	short *Routes = new short[nRoutes];

	mov	eax, DWORD PTR _nRoutes$[ebp]
	shl	eax, 1
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T40197[ebp], eax
	mov	ecx, DWORD PTR $T40197[ebp]
	mov	DWORD PTR _Routes$[ebp], ecx

; 3016 : 
; 3017 : 	int *pMyPath = new int[m_cNodes];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T40198[ebp], eax
	mov	ecx, DWORD PTR $T40198[ebp]
	mov	DWORD PTR _pMyPath$[ebp], ecx

; 3018 : 	unsigned short *BestNextNodes = new unsigned short[m_cNodes];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shl	eax, 1
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T40199[ebp], eax
	mov	ecx, DWORD PTR $T40199[ebp]
	mov	DWORD PTR _BestNextNodes$[ebp], ecx

; 3019 : 	char *pRoute = new char[m_cNodes*2];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shl	eax, 1
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T40200[ebp], eax
	mov	ecx, DWORD PTR $T40200[ebp]
	mov	DWORD PTR _pRoute$[ebp], ecx

; 3020 : 
; 3021 : 
; 3022 : 	if (Routes && pMyPath && BestNextNodes && pRoute)

	cmp	DWORD PTR _Routes$[ebp], 0
	je	$L38573
	cmp	DWORD PTR _pMyPath$[ebp], 0
	je	$L38573
	cmp	DWORD PTR _BestNextNodes$[ebp], 0
	je	$L38573
	cmp	DWORD PTR _pRoute$[ebp], 0
	je	$L38573

; 3024 : 		int nTotalCompressedSize = 0;

	mov	DWORD PTR _nTotalCompressedSize$38574[ebp], 0

; 3025 : 		for (int iHull = 0; iHull < MAX_NODE_HULLS; iHull++)

	mov	DWORD PTR _iHull$38575[ebp], 0
	jmp	SHORT $L38576
$L38577:
	mov	edx, DWORD PTR _iHull$38575[ebp]
	add	edx, 1
	mov	DWORD PTR _iHull$38575[ebp], edx
$L38576:
	cmp	DWORD PTR _iHull$38575[ebp], 4
	jge	$L38578

; 3027 : 			for (int iCap = 0; iCap < 2; iCap++)

	mov	DWORD PTR _iCap$38579[ebp], 0
	jmp	SHORT $L38580
$L38581:
	mov	eax, DWORD PTR _iCap$38579[ebp]
	add	eax, 1
	mov	DWORD PTR _iCap$38579[ebp], eax
$L38580:
	cmp	DWORD PTR _iCap$38579[ebp], 2
	jge	$L38582

; 3031 : 				{

	mov	ecx, DWORD PTR _iCap$38579[ebp]
	mov	DWORD PTR -184+[ebp], ecx
	cmp	DWORD PTR -184+[ebp], 0
	je	SHORT $L38588
	cmp	DWORD PTR -184+[ebp], 1
	je	SHORT $L38589
	jmp	SHORT $L38585
$L38588:

; 3032 : 				case 0:
; 3033 : 					iCapMask = 0;

	mov	DWORD PTR _iCapMask$38583[ebp], 0

; 3034 : 					break;

	jmp	SHORT $L38585
$L38589:

; 3035 : 
; 3036 : 				case 1:
; 3037 : 					iCapMask = bits_CAP_OPEN_DOORS | bits_CAP_AUTO_DOORS | bits_CAP_USE;

	mov	DWORD PTR _iCapMask$38583[ebp], 832	; 00000340H
$L38585:

; 3040 : 
; 3041 : 
; 3042 : 				// Initialize Routing table to uncalculated.
; 3043 : 				//
; 3044 : 				for (int iFrom = 0; iFrom < m_cNodes; iFrom++)

	mov	DWORD PTR _iFrom$38590[ebp], 0
	jmp	SHORT $L38591
$L38592:
	mov	edx, DWORD PTR _iFrom$38590[ebp]
	add	edx, 1
	mov	DWORD PTR _iFrom$38590[ebp], edx
$L38591:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iFrom$38590[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	SHORT $L38593

; 3046 : 					for (int iTo = 0; iTo < m_cNodes; iTo++)

	mov	DWORD PTR _iTo$38594[ebp], 0
	jmp	SHORT $L38595
$L38596:
	mov	edx, DWORD PTR _iTo$38594[ebp]
	add	edx, 1
	mov	DWORD PTR _iTo$38594[ebp], edx
$L38595:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iTo$38594[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	SHORT $L38597

; 3048 : 						Routes[FROM_TO(iFrom, iTo)] = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iFrom$38590[ebp]
	imul	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR _iTo$38594[ebp]
	mov	ecx, DWORD PTR _Routes$[ebp]
	mov	WORD PTR [ecx+eax*2], -1

; 3049 : 					}

	jmp	SHORT $L38596
$L38597:

; 3050 : 				}

	jmp	SHORT $L38592
$L38593:

; 3051 : 
; 3052 : 				for (iFrom = 0; iFrom < m_cNodes; iFrom++)

	mov	DWORD PTR _iFrom$38590[ebp], 0
	jmp	SHORT $L38598
$L38599:
	mov	edx, DWORD PTR _iFrom$38590[ebp]
	add	edx, 1
	mov	DWORD PTR _iFrom$38590[ebp], edx
$L38598:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iFrom$38590[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	$L38600

; 3054 : 					for (int iTo = m_cNodes-1; iTo >= 0; iTo--)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	sub	eax, 1
	mov	DWORD PTR _iTo$38601[ebp], eax
	jmp	SHORT $L38602
$L38603:
	mov	ecx, DWORD PTR _iTo$38601[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iTo$38601[ebp], ecx
$L38602:
	cmp	DWORD PTR _iTo$38601[ebp], 0
	jl	$L38604

; 3056 : 						if (Routes[FROM_TO(iFrom, iTo)] != -1) continue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iFrom$38590[ebp]
	imul	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR _iTo$38601[ebp]
	mov	ecx, DWORD PTR _Routes$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	cmp	edx, -1
	je	SHORT $L38605
	jmp	SHORT $L38603
$L38605:

; 3057 : 
; 3058 : 						int cPathSize = FindShortestPath(pMyPath, iFrom, iTo, iHull, iCapMask);

	mov	eax, DWORD PTR _iCapMask$38583[ebp]
	push	eax
	mov	ecx, DWORD PTR _iHull$38575[ebp]
	push	ecx
	mov	edx, DWORD PTR _iTo$38601[ebp]
	push	edx
	mov	eax, DWORD PTR _iFrom$38590[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMyPath$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindShortestPath@CGraph@@QAEHPAHHHHH@Z	; CGraph::FindShortestPath
	mov	DWORD PTR _cPathSize$38606[ebp], eax

; 3059 : 
; 3060 : 						// Use the computed path to update the routing table.
; 3061 : 						//
; 3062 : 						if (cPathSize > 1)

	cmp	DWORD PTR _cPathSize$38606[ebp], 1
	jle	SHORT $L38607

; 3064 : 							for (int iNode = 0; iNode < cPathSize-1; iNode++)

	mov	DWORD PTR _iNode$38608[ebp], 0
	jmp	SHORT $L38609
$L38610:
	mov	edx, DWORD PTR _iNode$38608[ebp]
	add	edx, 1
	mov	DWORD PTR _iNode$38608[ebp], edx
$L38609:
	mov	eax, DWORD PTR _cPathSize$38606[ebp]
	sub	eax, 1
	cmp	DWORD PTR _iNode$38608[ebp], eax
	jge	SHORT $L38611

; 3066 : 								int iStart = pMyPath[iNode];

	mov	ecx, DWORD PTR _iNode$38608[ebp]
	mov	edx, DWORD PTR _pMyPath$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _iStart$38612[ebp], eax

; 3067 : 								int iNext  = pMyPath[iNode+1];

	mov	ecx, DWORD PTR _iNode$38608[ebp]
	mov	edx, DWORD PTR _pMyPath$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	mov	DWORD PTR _iNext$38613[ebp], eax

; 3068 : 								for (int iNode1 = iNode+1; iNode1 < cPathSize; iNode1++)

	mov	ecx, DWORD PTR _iNode$38608[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNode1$38614[ebp], ecx
	jmp	SHORT $L38615
$L38616:
	mov	edx, DWORD PTR _iNode1$38614[ebp]
	add	edx, 1
	mov	DWORD PTR _iNode1$38614[ebp], edx
$L38615:
	mov	eax, DWORD PTR _iNode1$38614[ebp]
	cmp	eax, DWORD PTR _cPathSize$38606[ebp]
	jge	SHORT $L38617

; 3070 : 									int iEnd = pMyPath[iNode1];

	mov	ecx, DWORD PTR _iNode1$38614[ebp]
	mov	edx, DWORD PTR _pMyPath$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _iEnd$38618[ebp], eax

; 3071 : 									Routes[FROM_TO(iStart, iEnd)] = iNext;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iStart$38612[ebp]
	imul	edx, DWORD PTR [ecx+24]
	add	edx, DWORD PTR _iEnd$38618[ebp]
	mov	eax, DWORD PTR _Routes$[ebp]
	mov	cx, WORD PTR _iNext$38613[ebp]
	mov	WORD PTR [eax+edx*2], cx

; 3072 : 								}

	jmp	SHORT $L38616
$L38617:

; 3073 : 							}

	jmp	SHORT $L38610
$L38611:

; 3092 : 						else

	jmp	SHORT $L38619
$L38607:

; 3094 : 							Routes[FROM_TO(iFrom, iTo)] = iFrom;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iFrom$38590[ebp]
	imul	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR _iTo$38601[ebp]
	mov	ecx, DWORD PTR _Routes$[ebp]
	mov	dx, WORD PTR _iFrom$38590[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 3095 : 							Routes[FROM_TO(iTo, iFrom)] = iTo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iTo$38601[ebp]
	imul	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _iFrom$38590[ebp]
	mov	edx, DWORD PTR _Routes$[ebp]
	mov	ax, WORD PTR _iTo$38601[ebp]
	mov	WORD PTR [edx+ecx*2], ax
$L38619:

; 3097 : 					}

	jmp	$L38603
$L38604:

; 3098 : 				}

	jmp	$L38599
$L38600:

; 3099 : 
; 3100 : 				for (iFrom = 0; iFrom < m_cNodes; iFrom++)

	mov	DWORD PTR _iFrom$38590[ebp], 0
	jmp	SHORT $L38620
$L38621:
	mov	ecx, DWORD PTR _iFrom$38590[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFrom$38590[ebp], ecx
$L38620:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iFrom$38590[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	$L38622

; 3102 : 					for (int iTo = 0; iTo < m_cNodes; iTo++)

	mov	DWORD PTR _iTo$38623[ebp], 0
	jmp	SHORT $L38624
$L38625:
	mov	ecx, DWORD PTR _iTo$38623[ebp]
	add	ecx, 1
	mov	DWORD PTR _iTo$38623[ebp], ecx
$L38624:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iTo$38623[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $L38626

; 3104 : 						BestNextNodes[iTo] = Routes[FROM_TO(iFrom, iTo)];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iFrom$38590[ebp]
	imul	edx, DWORD PTR [ecx+24]
	add	edx, DWORD PTR _iTo$38623[ebp]
	mov	eax, DWORD PTR _iTo$38623[ebp]
	mov	ecx, DWORD PTR _BestNextNodes$[ebp]
	mov	esi, DWORD PTR _Routes$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [ecx+eax*2], dx

; 3105 : 					}

	jmp	SHORT $L38625
$L38626:

; 3106 : 
; 3107 : 					// Compress this node's routing table.
; 3108 : 					//
; 3109 : 					int iLastNode = 9999999; // just really big.

	mov	DWORD PTR _iLastNode$38627[ebp], 9999999 ; 0098967fH

; 3110 : 					int cSequence = 0;

	mov	DWORD PTR _cSequence$38628[ebp], 0

; 3111 : 					int cRepeats = 0;

	mov	DWORD PTR _cRepeats$38629[ebp], 0

; 3112 : 					int CompressedSize = 0;

	mov	DWORD PTR _CompressedSize$38630[ebp], 0

; 3113 : 					char *p = pRoute;

	mov	eax, DWORD PTR _pRoute$[ebp]
	mov	DWORD PTR _p$38631[ebp], eax

; 3114 : 					for (int i = 0; i < m_cNodes; i++)

	mov	DWORD PTR _i$38632[ebp], 0
	jmp	SHORT $L38633
$L38634:
	mov	ecx, DWORD PTR _i$38632[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$38632[ebp], ecx
$L38633:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$38632[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	$L38635

; 3116 : 						BOOL CanRepeat = ((BestNextNodes[i] == iLastNode) && cRepeats < 127);

	mov	ecx, DWORD PTR _i$38632[ebp]
	mov	edx, DWORD PTR _BestNextNodes$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+ecx*2]
	cmp	eax, DWORD PTR _iLastNode$38627[ebp]
	jne	SHORT $L40201
	cmp	DWORD PTR _cRepeats$38629[ebp], 127	; 0000007fH
	jge	SHORT $L40201
	mov	DWORD PTR -188+[ebp], 1
	jmp	SHORT $L40202
$L40201:
	mov	DWORD PTR -188+[ebp], 0
$L40202:
	mov	ecx, DWORD PTR -188+[ebp]
	mov	DWORD PTR _CanRepeat$38636[ebp], ecx

; 3117 : 						BOOL CanSequence = (BestNextNodes[i] == i && cSequence < 128);

	mov	edx, DWORD PTR _i$38632[ebp]
	mov	eax, DWORD PTR _BestNextNodes$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+edx*2]
	cmp	ecx, DWORD PTR _i$38632[ebp]
	jne	SHORT $L40203
	cmp	DWORD PTR _cSequence$38628[ebp], 128	; 00000080H
	jge	SHORT $L40203
	mov	DWORD PTR -192+[ebp], 1
	jmp	SHORT $L40204
$L40203:
	mov	DWORD PTR -192+[ebp], 0
$L40204:
	mov	edx, DWORD PTR -192+[ebp]
	mov	DWORD PTR _CanSequence$38637[ebp], edx

; 3118 : 
; 3119 : 						if (cRepeats)

	cmp	DWORD PTR _cRepeats$38629[ebp], 0
	je	$L38638

; 3121 : 							if (CanRepeat)

	cmp	DWORD PTR _CanRepeat$38636[ebp], 0
	je	SHORT $L38639

; 3123 : 								cRepeats++;

	mov	eax, DWORD PTR _cRepeats$38629[ebp]
	add	eax, 1
	mov	DWORD PTR _cRepeats$38629[ebp], eax

; 3125 : 							else

	jmp	$L38652
$L38639:

; 3127 : 								// Emit the repeat phrase.
; 3128 : 								//
; 3129 : 								CompressedSize += 2; // (count-1, iLastNode-i)

	mov	ecx, DWORD PTR _CompressedSize$38630[ebp]
	add	ecx, 2
	mov	DWORD PTR _CompressedSize$38630[ebp], ecx

; 3130 : 								*p++ = cRepeats - 1;

	mov	edx, DWORD PTR _cRepeats$38629[ebp]
	sub	edx, 1
	mov	eax, DWORD PTR _p$38631[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _p$38631[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$38631[ebp], ecx

; 3131 : 								int a = iLastNode - iFrom;

	mov	edx, DWORD PTR _iLastNode$38627[ebp]
	sub	edx, DWORD PTR _iFrom$38590[ebp]
	mov	DWORD PTR _a$38641[ebp], edx

; 3132 : 								int b = iLastNode - iFrom + m_cNodes;

	mov	eax, DWORD PTR _iLastNode$38627[ebp]
	sub	eax, DWORD PTR _iFrom$38590[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR _b$38642[ebp], eax

; 3133 : 								int c = iLastNode - iFrom - m_cNodes;

	mov	edx, DWORD PTR _iLastNode$38627[ebp]
	sub	edx, DWORD PTR _iFrom$38590[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	sub	edx, DWORD PTR [eax+24]
	mov	DWORD PTR _c$38643[ebp], edx

; 3134 : 								if (-128 <= a && a <= 127)

	cmp	DWORD PTR _a$38641[ebp], -128		; ffffff80H
	jl	SHORT $L38644
	cmp	DWORD PTR _a$38641[ebp], 127		; 0000007fH
	jg	SHORT $L38644

; 3136 : 									*p++ = a;

	mov	ecx, DWORD PTR _p$38631[ebp]
	mov	dl, BYTE PTR _a$38641[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _p$38631[ebp]
	add	eax, 1
	mov	DWORD PTR _p$38631[ebp], eax

; 3138 : 								else if (-128 <= b && b <= 127)

	jmp	SHORT $L38649
$L38644:
	cmp	DWORD PTR _b$38642[ebp], -128		; ffffff80H
	jl	SHORT $L38646
	cmp	DWORD PTR _b$38642[ebp], 127		; 0000007fH
	jg	SHORT $L38646

; 3140 : 									*p++ = b;

	mov	ecx, DWORD PTR _p$38631[ebp]
	mov	dl, BYTE PTR _b$38642[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _p$38631[ebp]
	add	eax, 1
	mov	DWORD PTR _p$38631[ebp], eax

; 3142 : 								else if (-128 <= c && c <= 127)

	jmp	SHORT $L38649
$L38646:
	cmp	DWORD PTR _c$38643[ebp], -128		; ffffff80H
	jl	SHORT $L38648
	cmp	DWORD PTR _c$38643[ebp], 127		; 0000007fH
	jg	SHORT $L38648

; 3144 : 									*p++ = c;

	mov	ecx, DWORD PTR _p$38631[ebp]
	mov	dl, BYTE PTR _c$38643[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _p$38631[ebp]
	add	eax, 1
	mov	DWORD PTR _p$38631[ebp], eax

; 3146 : 								else

	jmp	SHORT $L38649
$L38648:

; 3148 : 									ALERT( at_aiconsole, "Nodes need sorting (%d,%d)!\n", iLastNode, iFrom);

	mov	ecx, DWORD PTR _iFrom$38590[ebp]
	push	ecx
	mov	edx, DWORD PTR _iLastNode$38627[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BN@CKJO@Nodes?5need?5sorting?5?$CI?$CFd?0?$CFd?$CJ?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H
$L38649:

; 3150 : 								cRepeats = 0;

	mov	DWORD PTR _cRepeats$38629[ebp], 0

; 3151 : 
; 3152 : 								if (CanSequence)

	cmp	DWORD PTR _CanSequence$38637[ebp], 0
	je	SHORT $L38651

; 3154 : 									// Start a sequence.
; 3155 : 									//
; 3156 : 									cSequence++;

	mov	eax, DWORD PTR _cSequence$38628[ebp]
	add	eax, 1
	mov	DWORD PTR _cSequence$38628[ebp], eax

; 3158 : 								else

	jmp	SHORT $L38652
$L38651:

; 3160 : 									// Start another repeat.
; 3161 : 									//
; 3162 : 									cRepeats++;

	mov	ecx, DWORD PTR _cRepeats$38629[ebp]
	add	ecx, 1
	mov	DWORD PTR _cRepeats$38629[ebp], ecx
$L38652:

; 3166 : 						else if (cSequence)

	jmp	SHORT $L38661
$L38638:
	cmp	DWORD PTR _cSequence$38628[ebp], 0
	je	SHORT $L38654

; 3168 : 							if (CanSequence)

	cmp	DWORD PTR _CanSequence$38637[ebp], 0
	je	SHORT $L38655

; 3170 : 								cSequence++;

	mov	edx, DWORD PTR _cSequence$38628[ebp]
	add	edx, 1
	mov	DWORD PTR _cSequence$38628[ebp], edx

; 3172 : 							else

	jmp	SHORT $L38658
$L38655:

; 3174 : 								// It may be advantageous to combine
; 3175 : 								// a single-entry sequence phrase with the
; 3176 : 								// next repeat phrase.
; 3177 : 								//
; 3178 : 								if (cSequence == 1 && CanRepeat)

	cmp	DWORD PTR _cSequence$38628[ebp], 1
	jne	SHORT $L38657
	cmp	DWORD PTR _CanRepeat$38636[ebp], 0
	je	SHORT $L38657

; 3180 : 									// Combine with repeat phrase.
; 3181 : 									//
; 3182 : 									cRepeats = 2;

	mov	DWORD PTR _cRepeats$38629[ebp], 2

; 3183 : 									cSequence = 0;

	mov	DWORD PTR _cSequence$38628[ebp], 0

; 3185 : 								else

	jmp	SHORT $L38658
$L38657:

; 3187 : 									// Emit the sequence phrase.
; 3188 : 									//
; 3189 : 									CompressedSize += 1; // (-count)

	mov	eax, DWORD PTR _CompressedSize$38630[ebp]
	add	eax, 1
	mov	DWORD PTR _CompressedSize$38630[ebp], eax

; 3190 : 									*p++ = -cSequence;

	mov	ecx, DWORD PTR _cSequence$38628[ebp]
	neg	ecx
	mov	edx, DWORD PTR _p$38631[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _p$38631[ebp]
	add	eax, 1
	mov	DWORD PTR _p$38631[ebp], eax

; 3191 : 									cSequence = 0;

	mov	DWORD PTR _cSequence$38628[ebp], 0

; 3192 : 
; 3193 : 									// Start a repeat sequence.
; 3194 : 									//
; 3195 : 									cRepeats++;

	mov	ecx, DWORD PTR _cRepeats$38629[ebp]
	add	ecx, 1
	mov	DWORD PTR _cRepeats$38629[ebp], ecx
$L38658:

; 3199 : 						else

	jmp	SHORT $L38661
$L38654:

; 3201 : 							if (CanSequence)

	cmp	DWORD PTR _CanSequence$38637[ebp], 0
	je	SHORT $L38660

; 3203 : 								// Start a sequence phrase.
; 3204 : 								//
; 3205 : 								cSequence++;

	mov	edx, DWORD PTR _cSequence$38628[ebp]
	add	edx, 1
	mov	DWORD PTR _cSequence$38628[ebp], edx

; 3207 : 							else

	jmp	SHORT $L38661
$L38660:

; 3209 : 								// Start a repeat sequence.
; 3210 : 								//
; 3211 : 								cRepeats++;

	mov	eax, DWORD PTR _cRepeats$38629[ebp]
	add	eax, 1
	mov	DWORD PTR _cRepeats$38629[ebp], eax
$L38661:

; 3214 : 						iLastNode = BestNextNodes[i];

	mov	ecx, DWORD PTR _i$38632[ebp]
	mov	edx, DWORD PTR _BestNextNodes$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+ecx*2]
	mov	DWORD PTR _iLastNode$38627[ebp], eax

; 3215 : 					}

	jmp	$L38634
$L38635:

; 3216 : 					if (cRepeats)

	cmp	DWORD PTR _cRepeats$38629[ebp], 0
	je	$L38671

; 3218 : 						// Emit the repeat phrase.
; 3219 : 						//
; 3220 : 						CompressedSize += 2;

	mov	ecx, DWORD PTR _CompressedSize$38630[ebp]
	add	ecx, 2
	mov	DWORD PTR _CompressedSize$38630[ebp], ecx

; 3221 : 						*p++ = cRepeats - 1;

	mov	edx, DWORD PTR _cRepeats$38629[ebp]
	sub	edx, 1
	mov	eax, DWORD PTR _p$38631[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _p$38631[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$38631[ebp], ecx

; 3222 : #if 0
; 3223 : 						iLastNode = iFrom + *pRoute;
; 3224 : 						if (iLastNode >= m_cNodes) iLastNode -= m_cNodes;
; 3225 : 						else if (iLastNode < 0) iLastNode += m_cNodes;
; 3226 : #endif
; 3227 : 						int a = iLastNode - iFrom;

	mov	edx, DWORD PTR _iLastNode$38627[ebp]
	sub	edx, DWORD PTR _iFrom$38590[ebp]
	mov	DWORD PTR _a$38663[ebp], edx

; 3228 : 						int b = iLastNode - iFrom + m_cNodes;

	mov	eax, DWORD PTR _iLastNode$38627[ebp]
	sub	eax, DWORD PTR _iFrom$38590[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR _b$38664[ebp], eax

; 3229 : 						int c = iLastNode - iFrom - m_cNodes;

	mov	edx, DWORD PTR _iLastNode$38627[ebp]
	sub	edx, DWORD PTR _iFrom$38590[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	sub	edx, DWORD PTR [eax+24]
	mov	DWORD PTR _c$38665[ebp], edx

; 3230 : 						if (-128 <= a && a <= 127)

	cmp	DWORD PTR _a$38663[ebp], -128		; ffffff80H
	jl	SHORT $L38666
	cmp	DWORD PTR _a$38663[ebp], 127		; 0000007fH
	jg	SHORT $L38666

; 3232 : 							*p++ = a;

	mov	ecx, DWORD PTR _p$38631[ebp]
	mov	dl, BYTE PTR _a$38663[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _p$38631[ebp]
	add	eax, 1
	mov	DWORD PTR _p$38631[ebp], eax

; 3234 : 						else if (-128 <= b && b <= 127)

	jmp	SHORT $L38671
$L38666:
	cmp	DWORD PTR _b$38664[ebp], -128		; ffffff80H
	jl	SHORT $L38668
	cmp	DWORD PTR _b$38664[ebp], 127		; 0000007fH
	jg	SHORT $L38668

; 3236 : 							*p++ = b;

	mov	ecx, DWORD PTR _p$38631[ebp]
	mov	dl, BYTE PTR _b$38664[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _p$38631[ebp]
	add	eax, 1
	mov	DWORD PTR _p$38631[ebp], eax

; 3238 : 						else if (-128 <= c && c <= 127)

	jmp	SHORT $L38671
$L38668:
	cmp	DWORD PTR _c$38665[ebp], -128		; ffffff80H
	jl	SHORT $L38670
	cmp	DWORD PTR _c$38665[ebp], 127		; 0000007fH
	jg	SHORT $L38670

; 3240 : 							*p++ = c;

	mov	ecx, DWORD PTR _p$38631[ebp]
	mov	dl, BYTE PTR _c$38665[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _p$38631[ebp]
	add	eax, 1
	mov	DWORD PTR _p$38631[ebp], eax

; 3242 : 						else

	jmp	SHORT $L38671
$L38670:

; 3244 : 							ALERT( at_aiconsole, "Nodes need sorting (%d,%d)!\n", iLastNode, iFrom);

	mov	ecx, DWORD PTR _iFrom$38590[ebp]
	push	ecx
	mov	edx, DWORD PTR _iLastNode$38627[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BN@CKJO@Nodes?5need?5sorting?5?$CI?$CFd?0?$CFd?$CJ?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H
$L38671:

; 3247 : 					if (cSequence)

	cmp	DWORD PTR _cSequence$38628[ebp], 0
	je	SHORT $L38672

; 3249 : 						// Emit the Sequence phrase.
; 3250 : 						//
; 3251 : 						CompressedSize += 1;

	mov	eax, DWORD PTR _CompressedSize$38630[ebp]
	add	eax, 1
	mov	DWORD PTR _CompressedSize$38630[ebp], eax

; 3252 : 						*p++ = -cSequence;

	mov	ecx, DWORD PTR _cSequence$38628[ebp]
	neg	ecx
	mov	edx, DWORD PTR _p$38631[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _p$38631[ebp]
	add	eax, 1
	mov	DWORD PTR _p$38631[ebp], eax
$L38672:

; 3254 : 
; 3255 : 					// Go find a place to store this thing and point to it.
; 3256 : 					//
; 3257 : 					int nRoute = p - pRoute;

	mov	ecx, DWORD PTR _p$38631[ebp]
	sub	ecx, DWORD PTR _pRoute$[ebp]
	mov	DWORD PTR _nRoute$38673[ebp], ecx

; 3258 : 					if (m_pRouteInfo)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	$L38674

; 3260 : 						for (int i = 0; i < m_nRouteInfo - nRoute; i++)

	mov	DWORD PTR _i$38675[ebp], 0
	jmp	SHORT $L38676
$L38677:
	mov	eax, DWORD PTR _i$38675[ebp]
	add	eax, 1
	mov	DWORD PTR _i$38675[ebp], eax
$L38676:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	sub	edx, DWORD PTR _nRoute$38673[ebp]
	cmp	DWORD PTR _i$38675[ebp], edx
	jge	SHORT $L38678

; 3262 : 							if (memcmp(m_pRouteInfo + i, pRoute, nRoute) == 0)

	mov	eax, DWORD PTR _nRoute$38673[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRoute$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, DWORD PTR _i$38675[ebp]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L38679

; 3264 : 								break;

	jmp	SHORT $L38678
$L38679:

; 3266 : 						}

	jmp	SHORT $L38677
$L38678:

; 3267 : 						if (i < m_nRouteInfo - nRoute)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	sub	edx, DWORD PTR _nRoute$38673[ebp]
	cmp	DWORD PTR _i$38675[ebp], edx
	jge	SHORT $L38680

; 3269 : 							m_pNodes[ iFrom ].m_pNextBestNode[iHull][iCap] = i;

	mov	eax, DWORD PTR _iFrom$38590[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, DWORD PTR _iHull$38575[ebp]
	lea	ecx, DWORD PTR [edx+eax*8+40]
	mov	edx, DWORD PTR _iCap$38579[ebp]
	mov	eax, DWORD PTR _i$38675[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 3271 : 						else

	jmp	$L38681
$L38680:

; 3273 : 							char *Tmp = (char *)calloc(sizeof(char), (m_nRouteInfo + nRoute));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, DWORD PTR _nRoute$38673[ebp]
	push	edx
	push	1
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _Tmp$38682[ebp], eax

; 3274 : 							memcpy(Tmp, m_pRouteInfo, m_nRouteInfo);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _Tmp$38682[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3275 : 							free(m_pRouteInfo);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_free
	add	esp, 4

; 3276 : 							m_pRouteInfo = Tmp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Tmp$38682[ebp]
	mov	DWORD PTR [ecx+20], edx

; 3277 : 							memcpy(m_pRouteInfo + m_nRouteInfo, pRoute, nRoute);

	mov	eax, DWORD PTR _nRoute$38673[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRoute$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+32]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3278 : 							m_pNodes[ iFrom ].m_pNextBestNode[iHull][iCap] = m_nRouteInfo;

	mov	edx, DWORD PTR _iFrom$38590[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, edx
	mov	edx, DWORD PTR _iHull$38575[ebp]
	lea	eax, DWORD PTR [ecx+edx*8+40]
	mov	ecx, DWORD PTR _iCap$38579[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+32]
	mov	DWORD PTR [eax+ecx*4], edx

; 3279 : 							m_nRouteInfo += nRoute;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, DWORD PTR _nRoute$38673[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 3280 : 							nTotalCompressedSize += CompressedSize;

	mov	eax, DWORD PTR _nTotalCompressedSize$38574[ebp]
	add	eax, DWORD PTR _CompressedSize$38630[ebp]
	mov	DWORD PTR _nTotalCompressedSize$38574[ebp], eax
$L38681:

; 3283 : 					else

	jmp	SHORT $L38685
$L38674:

; 3285 : 						m_nRouteInfo = nRoute;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nRoute$38673[ebp]
	mov	DWORD PTR [ecx+32], edx

; 3286 : 						m_pRouteInfo = (char *)calloc(sizeof(char), nRoute);

	mov	eax, DWORD PTR _nRoute$38673[ebp]
	push	eax
	push	1
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 3287 : 						memcpy(m_pRouteInfo, pRoute, nRoute);

	mov	edx, DWORD PTR _nRoute$38673[ebp]
	push	edx
	mov	eax, DWORD PTR _pRoute$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3288 : 						m_pNodes[ iFrom ].m_pNextBestNode[iHull][iCap] = 0;

	mov	eax, DWORD PTR _iFrom$38590[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, DWORD PTR _iHull$38575[ebp]
	lea	ecx, DWORD PTR [edx+eax*8+40]
	mov	edx, DWORD PTR _iCap$38579[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 3289 : 						nTotalCompressedSize += CompressedSize;

	mov	eax, DWORD PTR _nTotalCompressedSize$38574[ebp]
	add	eax, DWORD PTR _CompressedSize$38630[ebp]
	mov	DWORD PTR _nTotalCompressedSize$38574[ebp], eax
$L38685:

; 3291 : 				}

	jmp	$L38621
$L38622:

; 3292 : 			}

	jmp	$L38581
$L38582:

; 3293 : 		}		

	jmp	$L38577
$L38578:

; 3294 : 		ALERT( at_aiconsole, "Size of Routes = %d\n", nTotalCompressedSize);

	mov	ecx, DWORD PTR _nTotalCompressedSize$38574[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BF@KDEG@Size?5of?5Routes?5?$DN?5?$CFd?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L38573:

; 3296 : 	if (Routes) delete Routes;

	cmp	DWORD PTR _Routes$[ebp], 0
	je	SHORT $L38689
	mov	edx, DWORD PTR _Routes$[ebp]
	mov	DWORD PTR $T40205[ebp], edx
	mov	eax, DWORD PTR $T40205[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L38689:

; 3297 : 	if (BestNextNodes) delete BestNextNodes;

	cmp	DWORD PTR _BestNextNodes$[ebp], 0
	je	SHORT $L38691
	mov	ecx, DWORD PTR _BestNextNodes$[ebp]
	mov	DWORD PTR $T40206[ebp], ecx
	mov	edx, DWORD PTR $T40206[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L38691:

; 3298 : 	if (pRoute) delete pRoute;

	cmp	DWORD PTR _pRoute$[ebp], 0
	je	SHORT $L38693
	mov	eax, DWORD PTR _pRoute$[ebp]
	mov	DWORD PTR $T40207[ebp], eax
	mov	ecx, DWORD PTR $T40207[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L38693:

; 3299 : 	if (pMyPath) delete pMyPath;

	cmp	DWORD PTR _pMyPath$[ebp], 0
	je	SHORT $L38695
	mov	edx, DWORD PTR _pMyPath$[ebp]
	mov	DWORD PTR $T40208[ebp], edx
	mov	eax, DWORD PTR $T40208[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L38695:

; 3300 : 	Routes = 0;

	mov	DWORD PTR _Routes$[ebp], 0

; 3301 : 	BestNextNodes = 0;

	mov	DWORD PTR _BestNextNodes$[ebp], 0

; 3302 : 	pRoute = 0;

	mov	DWORD PTR _pRoute$[ebp], 0

; 3303 : 	pMyPath = 0;

	mov	DWORD PTR _pMyPath$[ebp], 0

; 3304 : 
; 3305 : #if 0
; 3306 : 	TestRoutingTables();
; 3307 : #endif
; 3308 : 	m_fRoutingComplete = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1

; 3309 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ComputeStaticRoutingTables@CGraph@@QAEXXZ ENDP		; CGraph::ComputeStaticRoutingTables
_TEXT	ENDS
PUBLIC	??_C@_09FPNM@No?5link?4?6?$AA@			; `string'
PUBLIC	??_C@_0BM@CPJK@Routing?5is?5inconsistent?$CB?$CB?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@MINJ@?$CI?$CFd?5to?5?$CFd?5?$HM?$CFd?1?$CFd?$CJ1?3?$AA@ ; `string'
PUBLIC	??_C@_03CPCE@?$CFd?5?$AA@			; `string'
PUBLIC	??_C@_0BF@GLCK@?6?$CI?$CFd?5to?5?$CFd?5?$HM?$CFd?1?$CFd?$CJ2?3?$AA@ ; `string'
PUBLIC	?TestRoutingTables@CGraph@@QAEXXZ		; CGraph::TestRoutingTables
EXTRN	_fabs:NEAR
;	COMDAT ??_C@_09FPNM@No?5link?4?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_09FPNM@No?5link?4?6?$AA@ DB 'No link.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CPJK@Routing?5is?5inconsistent?$CB?$CB?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BM@CPJK@Routing?5is?5inconsistent?$CB?$CB?$CB?6?$AA@ DB 'Routing i'
	DB	's inconsistent!!!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MINJ@?$CI?$CFd?5to?5?$CFd?5?$HM?$CFd?1?$CFd?$CJ1?3?$AA@
CONST	SEGMENT
??_C@_0BE@MINJ@?$CI?$CFd?5to?5?$CFd?5?$HM?$CFd?1?$CFd?$CJ1?3?$AA@ DB '(%d'
	DB	' to %d |%d/%d)1:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CPCE@?$CFd?5?$AA@
CONST	SEGMENT
??_C@_03CPCE@?$CFd?5?$AA@ DB '%d ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GLCK@?6?$CI?$CFd?5to?5?$CFd?5?$HM?$CFd?1?$CFd?$CJ2?3?$AA@
CONST	SEGMENT
??_C@_0BF@GLCK@?6?$CI?$CFd?5to?5?$CFd?5?$HM?$CFd?1?$CFd?$CJ2?3?$AA@ DB 0aH
	DB	'(%d to %d |%d/%d)2:', 00H			; `string'
CONST	ENDS
;	COMDAT ?TestRoutingTables@CGraph@@QAEXXZ
_TEXT	SEGMENT
$T40211 = -84
$T40212 = -88
$T40213 = -92
$T40214 = -96
_this$ = -4
_pMyPath$ = -8
_pMyPath2$ = -12
_iHull$38708 = -16
_iCap$38712 = -20
_iCapMask$38716 = -24
_iFrom$38723 = -28
_iTo$38727 = -32
_cPathSize1$38731 = -36
_cPathSize2$38732 = -40
_flDistance1$38734 = -44
_i$38735 = -48
_iVisitNode$38740 = -52
_bFound$38741 = -56
_iLink$38742 = -60
_flDistance2$38749 = -64
_iVisitNode$38754 = -68
_bFound$38755 = -72
_iLink$38756 = -76
_i$38765 = -80
?TestRoutingTables@CGraph@@QAEXXZ PROC NEAR		; CGraph::TestRoutingTables, COMDAT

; 3314 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3315 : 	int *pMyPath = new int[m_cNodes];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T40211[ebp], eax
	mov	edx, DWORD PTR $T40211[ebp]
	mov	DWORD PTR _pMyPath$[ebp], edx

; 3316 : 	int *pMyPath2 = new int[m_cNodes];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T40212[ebp], eax
	mov	edx, DWORD PTR $T40212[ebp]
	mov	DWORD PTR _pMyPath2$[ebp], edx

; 3317 : 	if (pMyPath && pMyPath2)

	cmp	DWORD PTR _pMyPath$[ebp], 0
	je	$EnoughSaid$38774
	cmp	DWORD PTR _pMyPath2$[ebp], 0
	je	$EnoughSaid$38774

; 3319 : 		for (int iHull = 0; iHull < MAX_NODE_HULLS; iHull++)

	mov	DWORD PTR _iHull$38708[ebp], 0
	jmp	SHORT $L38709
$L38710:
	mov	eax, DWORD PTR _iHull$38708[ebp]
	add	eax, 1
	mov	DWORD PTR _iHull$38708[ebp], eax
$L38709:
	cmp	DWORD PTR _iHull$38708[ebp], 4
	jge	$EnoughSaid$38774

; 3321 : 			for (int iCap = 0; iCap < 2; iCap++)

	mov	DWORD PTR _iCap$38712[ebp], 0
	jmp	SHORT $L38713
$L38714:
	mov	ecx, DWORD PTR _iCap$38712[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCap$38712[ebp], ecx
$L38713:
	cmp	DWORD PTR _iCap$38712[ebp], 2
	jge	$L38715

; 3325 : 				{

	mov	edx, DWORD PTR _iCap$38712[ebp]
	mov	DWORD PTR -100+[ebp], edx
	cmp	DWORD PTR -100+[ebp], 0
	je	SHORT $L38721
	cmp	DWORD PTR -100+[ebp], 1
	je	SHORT $L38722
	jmp	SHORT $L38718
$L38721:

; 3326 : 				case 0:
; 3327 : 					iCapMask = 0;

	mov	DWORD PTR _iCapMask$38716[ebp], 0

; 3328 : 					break;

	jmp	SHORT $L38718
$L38722:

; 3329 : 
; 3330 : 				case 1:
; 3331 : 					iCapMask = bits_CAP_OPEN_DOORS | bits_CAP_AUTO_DOORS | bits_CAP_USE;

	mov	DWORD PTR _iCapMask$38716[ebp], 832	; 00000340H
$L38718:

; 3334 : 
; 3335 : 				for (int iFrom = 0; iFrom < m_cNodes; iFrom++)

	mov	DWORD PTR _iFrom$38723[ebp], 0
	jmp	SHORT $L38724
$L38725:
	mov	eax, DWORD PTR _iFrom$38723[ebp]
	add	eax, 1
	mov	DWORD PTR _iFrom$38723[ebp], eax
$L38724:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iFrom$38723[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$L38726

; 3337 : 					for (int iTo = 0; iTo < m_cNodes; iTo++)

	mov	DWORD PTR _iTo$38727[ebp], 0
	jmp	SHORT $L38728
$L38729:
	mov	eax, DWORD PTR _iTo$38727[ebp]
	add	eax, 1
	mov	DWORD PTR _iTo$38727[ebp], eax
$L38728:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iTo$38727[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$L38730

; 3339 : 						m_fRoutingComplete = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 3340 : 						int cPathSize1 = FindShortestPath(pMyPath, iFrom, iTo, iHull, iCapMask);

	mov	ecx, DWORD PTR _iCapMask$38716[ebp]
	push	ecx
	mov	edx, DWORD PTR _iHull$38708[ebp]
	push	edx
	mov	eax, DWORD PTR _iTo$38727[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFrom$38723[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMyPath$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindShortestPath@CGraph@@QAEHPAHHHHH@Z	; CGraph::FindShortestPath
	mov	DWORD PTR _cPathSize1$38731[ebp], eax

; 3341 : 						m_fRoutingComplete = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 3342 : 						int cPathSize2 = FindShortestPath(pMyPath2, iFrom, iTo, iHull, iCapMask);

	mov	ecx, DWORD PTR _iCapMask$38716[ebp]
	push	ecx
	mov	edx, DWORD PTR _iHull$38708[ebp]
	push	edx
	mov	eax, DWORD PTR _iTo$38727[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFrom$38723[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMyPath2$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindShortestPath@CGraph@@QAEHPAHHHHH@Z	; CGraph::FindShortestPath
	mov	DWORD PTR _cPathSize2$38732[ebp], eax

; 3343 : 
; 3344 : 						// Unless we can look at the entire path, we can verify that it's correct.
; 3345 : 						//
; 3346 : 						if (cPathSize2 == MAX_PATH_SIZE) continue;

	cmp	DWORD PTR _cPathSize2$38732[ebp], 10	; 0000000aH
	jne	SHORT $L38733
	jmp	SHORT $L38729
$L38733:

; 3347 : 
; 3348 : 						// Compare distances.
; 3349 : 						//
; 3350 : #if 1
; 3351 : 						float flDistance1 = 0.0;

	mov	DWORD PTR _flDistance1$38734[ebp], 0

; 3352 : 						for (int i = 0; i < cPathSize1-1; i++)

	mov	DWORD PTR _i$38735[ebp], 0
	jmp	SHORT $L38736
$L38737:
	mov	eax, DWORD PTR _i$38735[ebp]
	add	eax, 1
	mov	DWORD PTR _i$38735[ebp], eax
$L38736:
	mov	ecx, DWORD PTR _cPathSize1$38731[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _i$38735[ebp], ecx
	jge	$L38738

; 3354 : 							// Find the link from pMyPath[i] to pMyPath[i+1]
; 3355 : 							//
; 3356 : 							if (pMyPath[i] == pMyPath[i+1]) continue;

	mov	edx, DWORD PTR _i$38735[ebp]
	mov	eax, DWORD PTR _pMyPath$[ebp]
	mov	ecx, DWORD PTR _i$38735[ebp]
	mov	esi, DWORD PTR _pMyPath$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	cmp	edx, DWORD PTR [esi+ecx*4+4]
	jne	SHORT $L38739
	jmp	SHORT $L38737
$L38739:

; 3358 : 							BOOL bFound = FALSE;

	mov	DWORD PTR _bFound$38741[ebp], 0

; 3359 : 							for (int iLink = 0; iLink < m_pNodes[pMyPath[i]].m_cNumLinks; iLink++)

	mov	DWORD PTR _iLink$38742[ebp], 0
	jmp	SHORT $L38743
$L38744:
	mov	eax, DWORD PTR _iLink$38742[ebp]
	add	eax, 1
	mov	DWORD PTR _iLink$38742[ebp], eax
$L38743:
	mov	ecx, DWORD PTR _i$38735[ebp]
	mov	edx, DWORD PTR _pMyPath$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _iLink$38742[ebp]
	cmp	ecx, DWORD PTR [edx+eax+32]
	jge	SHORT $L38745

; 3361 : 								iVisitNode = INodeLink ( pMyPath[i], iLink );

	mov	edx, DWORD PTR _iLink$38742[ebp]
	push	edx
	mov	eax, DWORD PTR _i$38735[ebp]
	mov	ecx, DWORD PTR _pMyPath$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?INodeLink@CGraph@@QAEHHH@Z		; CGraph::INodeLink
	mov	DWORD PTR _iVisitNode$38740[ebp], eax

; 3362 : 								if (iVisitNode == pMyPath[i+1])

	mov	eax, DWORD PTR _i$38735[ebp]
	mov	ecx, DWORD PTR _pMyPath$[ebp]
	mov	edx, DWORD PTR _iVisitNode$38740[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4+4]
	jne	SHORT $L38746

; 3364 : 									flDistance1 += m_pLinkPool[ m_pNodes[ pMyPath[i] ].m_iFirstLink + iLink].m_flWeight;

	mov	eax, DWORD PTR _i$38735[ebp]
	mov	ecx, DWORD PTR _pMyPath$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx+36]
	add	edx, DWORD PTR _iLink$38742[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	fld	DWORD PTR _flDistance1$38734[ebp]
	fadd	DWORD PTR [ecx+edx+20]
	fstp	DWORD PTR _flDistance1$38734[ebp]

; 3365 : 									bFound = TRUE;

	mov	DWORD PTR _bFound$38741[ebp], 1

; 3366 : 									break;

	jmp	SHORT $L38745
$L38746:

; 3368 : 							}

	jmp	$L38744
$L38745:

; 3369 : 							if (!bFound)

	cmp	DWORD PTR _bFound$38741[ebp], 0
	jne	SHORT $L38747

; 3371 : 								ALERT(at_aiconsole, "No link.\n");

	push	OFFSET FLAT:??_C@_09FPNM@No?5link?4?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L38747:

; 3373 : 						}

	jmp	$L38737
$L38738:

; 3374 : 
; 3375 : 						float flDistance2 = 0.0;

	mov	DWORD PTR _flDistance2$38749[ebp], 0

; 3376 : 						for (i = 0; i < cPathSize2-1; i++)

	mov	DWORD PTR _i$38735[ebp], 0
	jmp	SHORT $L38750
$L38751:
	mov	edx, DWORD PTR _i$38735[ebp]
	add	edx, 1
	mov	DWORD PTR _i$38735[ebp], edx
$L38750:
	mov	eax, DWORD PTR _cPathSize2$38732[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$38735[ebp], eax
	jge	$L38752

; 3378 : 							// Find the link from pMyPath2[i] to pMyPath2[i+1]
; 3379 : 							//
; 3380 : 							if (pMyPath2[i] == pMyPath2[i+1]) continue;

	mov	ecx, DWORD PTR _i$38735[ebp]
	mov	edx, DWORD PTR _pMyPath2$[ebp]
	mov	eax, DWORD PTR _i$38735[ebp]
	mov	esi, DWORD PTR _pMyPath2$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	cmp	ecx, DWORD PTR [esi+eax*4+4]
	jne	SHORT $L38753
	jmp	SHORT $L38751
$L38753:

; 3382 : 							BOOL bFound = FALSE;

	mov	DWORD PTR _bFound$38755[ebp], 0

; 3383 : 							for (int iLink = 0; iLink < m_pNodes[pMyPath2[i]].m_cNumLinks; iLink++)

	mov	DWORD PTR _iLink$38756[ebp], 0
	jmp	SHORT $L38757
$L38758:
	mov	edx, DWORD PTR _iLink$38756[ebp]
	add	edx, 1
	mov	DWORD PTR _iLink$38756[ebp], edx
$L38757:
	mov	eax, DWORD PTR _i$38735[ebp]
	mov	ecx, DWORD PTR _pMyPath2$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _iLink$38756[ebp]
	cmp	eax, DWORD PTR [ecx+edx+32]
	jge	SHORT $L38759

; 3385 : 								iVisitNode = INodeLink ( pMyPath2[i], iLink );

	mov	ecx, DWORD PTR _iLink$38756[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$38735[ebp]
	mov	eax, DWORD PTR _pMyPath2$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?INodeLink@CGraph@@QAEHHH@Z		; CGraph::INodeLink
	mov	DWORD PTR _iVisitNode$38754[ebp], eax

; 3386 : 								if (iVisitNode == pMyPath2[i+1])

	mov	edx, DWORD PTR _i$38735[ebp]
	mov	eax, DWORD PTR _pMyPath2$[ebp]
	mov	ecx, DWORD PTR _iVisitNode$38754[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4+4]
	jne	SHORT $L38760

; 3388 : 									flDistance2 += m_pLinkPool[ m_pNodes[ pMyPath2[i] ].m_iFirstLink + iLink].m_flWeight;

	mov	edx, DWORD PTR _i$38735[ebp]
	mov	eax, DWORD PTR _pMyPath2$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx+36]
	add	ecx, DWORD PTR _iLink$38756[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	fld	DWORD PTR _flDistance2$38749[ebp]
	fadd	DWORD PTR [eax+ecx+20]
	fstp	DWORD PTR _flDistance2$38749[ebp]

; 3389 : 									bFound = TRUE;

	mov	DWORD PTR _bFound$38755[ebp], 1

; 3390 : 									break;

	jmp	SHORT $L38759
$L38760:

; 3392 : 							}

	jmp	$L38758
$L38759:

; 3393 : 							if (!bFound)

	cmp	DWORD PTR _bFound$38755[ebp], 0
	jne	SHORT $L38761

; 3395 : 								ALERT(at_aiconsole, "No link.\n");

	push	OFFSET FLAT:??_C@_09FPNM@No?5link?4?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L38761:

; 3397 : 						}

	jmp	$L38751
$L38752:

; 3398 : 						if (fabs(flDistance1 - flDistance2) > 0.10)

	fld	DWORD PTR _flDistance1$38734[ebp]
	fsub	DWORD PTR _flDistance2$38749[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3ffbccccccccccccd000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L38762

; 3400 : #else
; 3401 : 						if (cPathSize1 != cPathSize2 || memcmp(pMyPath, pMyPath2, sizeof(int)*cPathSize1) != 0)
; 3402 : 						{
; 3403 : #endif
; 3404 : 							ALERT(at_aiconsole, "Routing is inconsistent!!!\n");

	push	OFFSET FLAT:??_C@_0BM@CPJK@Routing?5is?5inconsistent?$CB?$CB?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3405 : 							ALERT(at_aiconsole, "(%d to %d |%d/%d)1:", iFrom, iTo, iHull, iCap);

	mov	ecx, DWORD PTR _iCap$38712[ebp]
	push	ecx
	mov	edx, DWORD PTR _iHull$38708[ebp]
	push	edx
	mov	eax, DWORD PTR _iTo$38727[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFrom$38723[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BE@MINJ@?$CI?$CFd?5to?5?$CFd?5?$HM?$CFd?1?$CFd?$CJ1?3?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 24					; 00000018H

; 3406 : 							for (int i = 0; i < cPathSize1; i++)

	mov	DWORD PTR _i$38765[ebp], 0
	jmp	SHORT $L38766
$L38767:
	mov	edx, DWORD PTR _i$38765[ebp]
	add	edx, 1
	mov	DWORD PTR _i$38765[ebp], edx
$L38766:
	mov	eax, DWORD PTR _i$38765[ebp]
	cmp	eax, DWORD PTR _cPathSize1$38731[ebp]
	jge	SHORT $L38768

; 3408 : 								ALERT(at_aiconsole, "%d ", pMyPath[i]);

	mov	ecx, DWORD PTR _i$38765[ebp]
	mov	edx, DWORD PTR _pMyPath$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	push	OFFSET FLAT:??_C@_03CPCE@?$CFd?5?$AA@	; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 3409 : 							}

	jmp	SHORT $L38767
$L38768:

; 3410 : 							ALERT(at_aiconsole, "\n(%d to %d |%d/%d)2:", iFrom, iTo, iHull, iCap);

	mov	ecx, DWORD PTR _iCap$38712[ebp]
	push	ecx
	mov	edx, DWORD PTR _iHull$38708[ebp]
	push	edx
	mov	eax, DWORD PTR _iTo$38727[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFrom$38723[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BF@GLCK@?6?$CI?$CFd?5to?5?$CFd?5?$HM?$CFd?1?$CFd?$CJ2?3?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 24					; 00000018H

; 3411 : 							for (i = 0; i < cPathSize2; i++)

	mov	DWORD PTR _i$38765[ebp], 0
	jmp	SHORT $L38771
$L38772:
	mov	edx, DWORD PTR _i$38765[ebp]
	add	edx, 1
	mov	DWORD PTR _i$38765[ebp], edx
$L38771:
	mov	eax, DWORD PTR _i$38765[ebp]
	cmp	eax, DWORD PTR _cPathSize2$38732[ebp]
	jge	SHORT $L38773

; 3413 : 								ALERT(at_aiconsole, "%d ", pMyPath2[i]);

	mov	ecx, DWORD PTR _i$38765[ebp]
	mov	edx, DWORD PTR _pMyPath2$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	push	OFFSET FLAT:??_C@_03CPCE@?$CFd?5?$AA@	; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 3414 : 							}

	jmp	SHORT $L38772
$L38773:

; 3415 : 							ALERT(at_aiconsole, "\n");

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3416 : 							m_fRoutingComplete = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 3417 : 							cPathSize1 = FindShortestPath(pMyPath, iFrom, iTo, iHull, iCapMask);

	mov	edx, DWORD PTR _iCapMask$38716[ebp]
	push	edx
	mov	eax, DWORD PTR _iHull$38708[ebp]
	push	eax
	mov	ecx, DWORD PTR _iTo$38727[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFrom$38723[ebp]
	push	edx
	mov	eax, DWORD PTR _pMyPath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindShortestPath@CGraph@@QAEHPAHHHHH@Z	; CGraph::FindShortestPath
	mov	DWORD PTR _cPathSize1$38731[ebp], eax

; 3418 : 							m_fRoutingComplete = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1

; 3419 : 							cPathSize2 = FindShortestPath(pMyPath2, iFrom, iTo, iHull, iCapMask);

	mov	edx, DWORD PTR _iCapMask$38716[ebp]
	push	edx
	mov	eax, DWORD PTR _iHull$38708[ebp]
	push	eax
	mov	ecx, DWORD PTR _iTo$38727[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFrom$38723[ebp]
	push	edx
	mov	eax, DWORD PTR _pMyPath2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindShortestPath@CGraph@@QAEHPAHHHHH@Z	; CGraph::FindShortestPath
	mov	DWORD PTR _cPathSize2$38732[ebp], eax

; 3420 : 							goto EnoughSaid;

	jmp	SHORT $L38775
$L38762:

; 3422 : 					}

	jmp	$L38729
$L38730:

; 3423 : 				}

	jmp	$L38725
$L38726:

; 3424 : 			}

	jmp	$L38714
$L38715:

; 3425 : 		}

	jmp	$L38710
$EnoughSaid$38774:

; 3429 : 
; 3430 : 	if (pMyPath) delete pMyPath;

	cmp	DWORD PTR _pMyPath$[ebp], 0
	je	SHORT $L38776
	mov	ecx, DWORD PTR _pMyPath$[ebp]
	mov	DWORD PTR $T40213[ebp], ecx
	mov	edx, DWORD PTR $T40213[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L38776:

; 3431 : 	if (pMyPath2) delete pMyPath2;

	cmp	DWORD PTR _pMyPath2$[ebp], 0
	je	SHORT $L38778
	mov	eax, DWORD PTR _pMyPath2$[ebp]
	mov	DWORD PTR $T40214[ebp], eax
	mov	ecx, DWORD PTR $T40214[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L38778:

; 3432 : 	pMyPath = 0;

	mov	DWORD PTR _pMyPath$[ebp], 0

; 3433 : 	pMyPath2 = 0;

	mov	DWORD PTR _pMyPath2$[ebp], 0

; 3434 : }

	jmp	SHORT $L38700
$L38775:
	jmp	SHORT $EnoughSaid$38774
$L38700:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TestRoutingTables@CGraph@@QAEXXZ ENDP			; CGraph::TestRoutingTables
_TEXT	ENDS
;	COMDAT _$E40
_TEXT	SEGMENT
_$E40	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E39
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E40	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCNodeViewer@@@@QAE@PBD@Z	; CEntityFactory<CNodeViewer>::CEntityFactory<CNodeViewer>
PUBLIC	??_C@_0M@DMHE@node_viewer?$AA@			; `string'
_BSS	SEGMENT
	ALIGN	4

_node_viewer DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0M@DMHE@node_viewer?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0M@DMHE@node_viewer?$AA@ DB 'node_viewer', 00H	; `string'
CONST	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT
_$E39	PROC NEAR					; COMDAT

; 3472 : LINK_ENTITY_TO_CLASS( node_viewer, CNodeViewer );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0M@DMHE@node_viewer?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_node_viewer
	call	??0?$CEntityFactory@VCNodeViewer@@@@QAE@PBD@Z ; CEntityFactory<CNodeViewer>::CEntityFactory<CNodeViewer>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E39	ENDP
_TEXT	ENDS
;	COMDAT _$E43
_TEXT	SEGMENT
_$E43	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E42
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E43	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@IDJE@node_viewer_human?$AA@		; `string'
_BSS	SEGMENT
_node_viewer_human DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BC@IDJE@node_viewer_human?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BC@IDJE@node_viewer_human?$AA@ DB 'node_viewer_human', 00H ; `string'
CONST	ENDS
;	COMDAT _$E42
_TEXT	SEGMENT
_$E42	PROC NEAR					; COMDAT

; 3473 : LINK_ENTITY_TO_CLASS( node_viewer_human, CNodeViewer );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BC@IDJE@node_viewer_human?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_node_viewer_human
	call	??0?$CEntityFactory@VCNodeViewer@@@@QAE@PBD@Z ; CEntityFactory<CNodeViewer>::CEntityFactory<CNodeViewer>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E42	ENDP
_TEXT	ENDS
;	COMDAT _$E46
_TEXT	SEGMENT
_$E46	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E45
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E46	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@ILEJ@node_viewer_fly?$AA@		; `string'
_BSS	SEGMENT
_node_viewer_fly DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BA@ILEJ@node_viewer_fly?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BA@ILEJ@node_viewer_fly?$AA@ DB 'node_viewer_fly', 00H ; `string'
CONST	ENDS
;	COMDAT _$E45
_TEXT	SEGMENT
_$E45	PROC NEAR					; COMDAT

; 3474 : LINK_ENTITY_TO_CLASS( node_viewer_fly, CNodeViewer );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BA@ILEJ@node_viewer_fly?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_node_viewer_fly
	call	??0?$CEntityFactory@VCNodeViewer@@@@QAE@PBD@Z ; CEntityFactory<CNodeViewer>::CEntityFactory<CNodeViewer>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E45	ENDP
_TEXT	ENDS
;	COMDAT _$E49
_TEXT	SEGMENT
_$E49	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E48
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E49	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@BACI@node_viewer_large?$AA@		; `string'
_BSS	SEGMENT
_node_viewer_large DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BC@BACI@node_viewer_large?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BC@BACI@node_viewer_large?$AA@ DB 'node_viewer_large', 00H ; `string'
CONST	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT
_$E48	PROC NEAR					; COMDAT

; 3475 : LINK_ENTITY_TO_CLASS( node_viewer_large, CNodeViewer );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BC@BACI@node_viewer_large?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_node_viewer_large
	call	??0?$CEntityFactory@VCNodeViewer@@@@QAE@PBD@Z ; CEntityFactory<CNodeViewer>::CEntityFactory<CNodeViewer>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E48	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CNodeViewer@@UAEPAUdatamap_s@@XZ ; CNodeViewer::GetDataDescMap
;	COMDAT ?GetDataDescMap@CNodeViewer@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CNodeViewer@@UAEPAUdatamap_s@@XZ PROC NEAR ; CNodeViewer::GetDataDescMap, COMDAT

; 3477 : BEGIN_DATADESC( CNodeViewer )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CNodeViewer@@2Udatamap_s@@A ; CNodeViewer::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CNodeViewer@@UAEPAUdatamap_s@@XZ ENDP	; CNodeViewer::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CNodeViewer@@SAPAUdatamap_s@@XZ	; CNodeViewer::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CNodeViewer@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CNodeViewer@@SAPAUdatamap_s@@XZ PROC NEAR	; CNodeViewer::GetBaseMap, COMDAT

; 3477 : BEGIN_DATADESC( CNodeViewer )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CNodeViewer@@SAPAUdatamap_s@@XZ ENDP	; CNodeViewer::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E52
_TEXT	SEGMENT
_$E52	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E51
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E52	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z ; DataMapInit
;	COMDAT _$E51
_TEXT	SEGMENT
_$E51	PROC NEAR					; COMDAT

; 3477 : BEGIN_DATADESC( CNodeViewer )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CNodeViewer_DataDescInit@@3PAUdatamap_s@@A, eax ; CNodeViewer_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E51	ENDP
_TEXT	ENDS
PUBLIC	??_C@_09LKM@DrawThink?$AA@			; `string'
PUBLIC	?DrawThink@CNodeViewer@@QAEXXZ			; CNodeViewer::DrawThink
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09LKM@DrawThink?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_09LKM@DrawThink?$AA@ DB 'DrawThink', 00H		; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z PROC NEAR ; DataMapInit, COMDAT

; 3477 : BEGIN_DATADESC( CNodeViewer )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L38910
	mov	cl, BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0M@LEBC@CNodeViewer?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E55
	call	_atexit
	add	esp, 4
$L38910:
	call	?GetBaseMap@CNodeViewer@@SAPAUdatamap_s@@XZ ; CNodeViewer::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CNodeViewer@@2Udatamap_s@@A+12, eax

; 3478 : 	DEFINE_FUNCTION( DrawThink ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	SHORT $L38914
	mov	al, BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_09LKM@DrawThink?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4PAUtypedescription_s@@A+28, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4PAUtypedescription_s@@A+32, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4PAUtypedescription_s@@A+36, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4PAUtypedescription_s@@A+38, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4PAUtypedescription_s@@A+40, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4PAUtypedescription_s@@A+44, OFFSET FLAT:?DrawThink@CNodeViewer@@QAEXXZ ; CNodeViewer::DrawThink
$L38914:

; 3479 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L38918
	mov	DWORD PTR ?m_DataMap@CNodeViewer@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CNodeViewer@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L38919
$L38918:
	mov	DWORD PTR ?m_DataMap@CNodeViewer@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CNodeViewer@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4PAUtypedescription_s@@A
$L38919:
	mov	eax, OFFSET FLAT:?m_DataMap@CNodeViewer@@2Udatamap_s@@A ; CNodeViewer::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z ENDP	; DataMapInit
_TEXT	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT
_$E55	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCNodeViewer@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E55	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@FJHD@No?5nearby?5node?6?$AA@		; `string'
PUBLIC	??_C@_0N@DENB@basenode?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_09IHHN@?$CFd?5nodes?6?$AA@		; `string'
PUBLIC	?Spawn@CNodeViewer@@UAEXXZ			; CNodeViewer::Spawn
PUBLIC	?FindNodeConnections@CNodeViewer@@QAEXH@Z	; CNodeViewer::FindNodeConnections
PUBLIC	?AddNode@CNodeViewer@@QAEXHH@Z			; CNodeViewer::AddNode
EXTRN	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_Remove
;	COMDAT ??_C@_0BA@FJHD@No?5nearby?5node?6?$AA@
; File z:\xashxtsrc\server\monsters\nodes.cpp
CONST	SEGMENT
??_C@_0BA@FJHD@No?5nearby?5node?6?$AA@ DB 'No nearby node', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DENB@basenode?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0N@DENB@basenode?5?$CFd?6?$AA@ DB 'basenode %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IHHN@?$CFd?5nodes?6?$AA@
CONST	SEGMENT
??_C@_09IHHN@?$CFd?5nodes?6?$AA@ DB '%d nodes', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?Spawn@CNodeViewer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$38937 = -8
_start$38942 = -12
_end$38943 = -16
$T40245 = -28
$T40246 = -40
$T40247 = -52
?Spawn@CNodeViewer@@UAEXXZ PROC NEAR			; CNodeViewer::Spawn, COMDAT

; 3483 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3484 : 	if ( !WorldGraph.m_fGraphPresent || !WorldGraph.m_fGraphPointersSet )

	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A, 0
	je	SHORT $L38925
	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A+4, 0
	jne	SHORT $L38924
$L38925:

; 3486 : 		ALERT ( at_console, "Graph not ready!\n" );

	push	OFFSET FLAT:??_C@_0BC@LJED@Graph?5not?5ready?$CB?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3487 : 		UTIL_Remove( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 3488 : 		return;

	jmp	$L38923
$L38924:

; 3490 : 
; 3491 : 
; 3492 : 	if (FClassnameIs( pev, "node_viewer_fly"))

	push	OFFSET FLAT:??_C@_0BA@ILEJ@node_viewer_fly?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L38926

; 3494 : 		m_iHull = NODE_FLY_HULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2800], 3

; 3495 : 		m_afNodeType = bits_NODE_AIR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2804], 2

; 3496 : 		m_vecColor = Vector( 160, 100, 255 );

	push	1132396544				; 437f0000H
	push	1120403456				; 42c80000H
	push	1126170624				; 43200000H
	lea	ecx, DWORD PTR $T40245[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2808				; 00000af8H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 3498 : 	else if (FClassnameIs( pev, "node_viewer_large"))

	jmp	$L38931
$L38926:
	push	OFFSET FLAT:??_C@_0BC@BACI@node_viewer_large?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L38929

; 3500 : 		m_iHull = NODE_LARGE_HULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2800], 2

; 3501 : 		m_afNodeType = bits_NODE_LAND | bits_NODE_WATER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2804], 5

; 3502 : 		m_vecColor = Vector( 100, 255, 160 );

	push	1126170624				; 43200000H
	push	1132396544				; 437f0000H
	push	1120403456				; 42c80000H
	lea	ecx, DWORD PTR $T40246[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2808				; 00000af8H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 3504 : 	else

	jmp	SHORT $L38931
$L38929:

; 3506 : 		m_iHull = NODE_HUMAN_HULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2800], 1

; 3507 : 		m_afNodeType = bits_NODE_LAND | bits_NODE_WATER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2804], 5

; 3508 : 		m_vecColor = Vector( 255, 160, 100 );

	push	1120403456				; 42c80000H
	push	1126170624				; 43200000H
	push	1132396544				; 437f0000H
	lea	ecx, DWORD PTR $T40247[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2808				; 00000af8H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L38931:

; 3510 : 
; 3511 : 
; 3512 : 	m_iBaseNode = WorldGraph.FindNearestNode ( GetAbsOrigin(), m_afNodeType );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2804]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FindNearestNode@CGraph@@QAEHABVVector@@H@Z ; CGraph::FindNearestNode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1764], eax

; 3513 : 
; 3514 : 	if ( m_iBaseNode < 0 )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1764], 0
	jge	SHORT $L38933

; 3516 : 		ALERT( at_console, "No nearby node\n" );

	push	OFFSET FLAT:??_C@_0BA@FJHD@No?5nearby?5node?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3517 : 		return;

	jmp	$L38923
$L38933:

; 3519 : 
; 3520 : 	m_nVisited = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1772], 0

; 3521 : 
; 3522 : 	ALERT( at_aiconsole, "basenode %d\n", m_iBaseNode );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1764]
	push	edx
	push	OFFSET FLAT:??_C@_0N@DENB@basenode?5?$CFd?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 3523 : 
; 3524 : 	if (WorldGraph.m_cNodes < 128)

	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A+24, 128 ; 00000080H
	jge	SHORT $L38936

; 3526 : 		for (int i = 0; i < WorldGraph.m_cNodes; i++)

	mov	DWORD PTR _i$38937[ebp], 0
	jmp	SHORT $L38938
$L38939:
	mov	eax, DWORD PTR _i$38937[ebp]
	add	eax, 1
	mov	DWORD PTR _i$38937[ebp], eax
$L38938:
	mov	ecx, DWORD PTR _i$38937[ebp]
	cmp	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+24
	jge	SHORT $L38940

; 3528 : 			AddNode( i, WorldGraph.NextNodeInRoute( i, m_iBaseNode, m_iHull, 0 ));

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2800]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1764]
	push	edx
	mov	eax, DWORD PTR _i$38937[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?NextNodeInRoute@CGraph@@QAEHHHHH@Z	; CGraph::NextNodeInRoute
	push	eax
	mov	ecx, DWORD PTR _i$38937[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddNode@CNodeViewer@@QAEXHH@Z		; CNodeViewer::AddNode

; 3529 : 		}

	jmp	SHORT $L38939
$L38940:

; 3531 : 	else

	jmp	$L38946
$L38936:

; 3533 : 		// do a depth traversal
; 3534 : 		FindNodeConnections( m_iBaseNode );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1764]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindNodeConnections@CNodeViewer@@QAEXH@Z ; CNodeViewer::FindNodeConnections

; 3535 : 
; 3536 : 		int start = 0;

	mov	DWORD PTR _start$38942[ebp], 0
$L38944:

; 3539 : 			end = m_nVisited;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1772]
	mov	DWORD PTR _end$38943[ebp], edx

; 3540 : 			// ALERT( at_console, "%d :", m_nVisited );
; 3541 : 			for (end = m_nVisited; start < end; start++)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1772]
	mov	DWORD PTR _end$38943[ebp], ecx
	jmp	SHORT $L38947
$L38948:
	mov	edx, DWORD PTR _start$38942[ebp]
	add	edx, 1
	mov	DWORD PTR _start$38942[ebp], edx
$L38947:
	mov	eax, DWORD PTR _start$38942[ebp]
	cmp	eax, DWORD PTR _end$38943[ebp]
	jge	SHORT $L38949

; 3543 : 				FindNodeConnections( m_aFrom[start] );

	mov	ecx, DWORD PTR _start$38942[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1776]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindNodeConnections@CNodeViewer@@QAEXH@Z ; CNodeViewer::FindNodeConnections

; 3544 : 				FindNodeConnections( m_aTo[start] );

	mov	ecx, DWORD PTR _start$38942[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+2288]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindNodeConnections@CNodeViewer@@QAEXH@Z ; CNodeViewer::FindNodeConnections

; 3545 : 			}

	jmp	SHORT $L38948
$L38949:

; 3546 : 		} while (end != m_nVisited);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _end$38943[ebp]
	cmp	edx, DWORD PTR [ecx+1772]
	jne	SHORT $L38944
$L38946:

; 3548 : 
; 3549 : 	ALERT( at_aiconsole, "%d nodes\n", m_nVisited );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1772]
	push	ecx
	push	OFFSET FLAT:??_C@_09IHHN@?$CFd?5nodes?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 3550 : 
; 3551 : 	m_iDraw = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1768], 0

; 3552 : 	SetThink( DrawThink );

	push	OFFSET FLAT:??_C@_09LKM@DrawThink?$AA@	; `string'
	push	OFFSET FLAT:?DrawThink@CNodeViewer@@QAEXXZ ; CNodeViewer::DrawThink
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 3553 : 	pev->nextthink = gpGlobals->time;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+260], eax
$L38923:

; 3554 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CNodeViewer@@UAEXXZ ENDP				; CNodeViewer::Spawn
_TEXT	ENDS
;	COMDAT ?FindNodeConnections@CNodeViewer@@QAEXH@Z
_TEXT	SEGMENT
_iNode$ = 8
_this$ = -4
_i$ = -8
_pToLink$38961 = -12
?FindNodeConnections@CNodeViewer@@QAEXH@Z PROC NEAR	; CNodeViewer::FindNodeConnections, COMDAT

; 3558 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3559 : 	AddNode( iNode, WorldGraph.NextNodeInRoute( iNode, m_iBaseNode, m_iHull, 0 ));

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2800]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1764]
	push	eax
	mov	ecx, DWORD PTR _iNode$[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?NextNodeInRoute@CGraph@@QAEHHHHH@Z	; CGraph::NextNodeInRoute
	push	eax
	mov	edx, DWORD PTR _iNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddNode@CNodeViewer@@QAEXHH@Z		; CNodeViewer::AddNode

; 3560 : 	for ( int i = 0 ; i < WorldGraph.m_pNodes[ iNode ].m_cNumLinks ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38958
$L38959:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38958:
	mov	ecx, DWORD PTR _iNode$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+32]
	jge	SHORT $L38960

; 3562 : 		CLink *pToLink = &WorldGraph.NodeLink( iNode, i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNode$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?NodeLink@CGraph@@QAEAAVCLink@@HH@Z	; CGraph::NodeLink
	mov	DWORD PTR _pToLink$38961[ebp], eax

; 3563 : 		AddNode( pToLink->m_iDestNode, WorldGraph.NextNodeInRoute( pToLink->m_iDestNode, m_iBaseNode, m_iHull, 0 ));

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2800]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1764]
	push	eax
	mov	ecx, DWORD PTR _pToLink$38961[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?NextNodeInRoute@CGraph@@QAEHHHHH@Z	; CGraph::NextNodeInRoute
	push	eax
	mov	eax, DWORD PTR _pToLink$38961[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddNode@CNodeViewer@@QAEXHH@Z		; CNodeViewer::AddNode

; 3564 : 	}

	jmp	SHORT $L38959
$L38960:

; 3565 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FindNodeConnections@CNodeViewer@@QAEXH@Z ENDP		; CNodeViewer::FindNodeConnections
_TEXT	ENDS
;	COMDAT ?AddNode@CNodeViewer@@QAEXHH@Z
_TEXT	SEGMENT
_iFrom$ = 8
_iTo$ = 12
_this$ = -4
_i$38970 = -8
?AddNode@CNodeViewer@@QAEXHH@Z PROC NEAR		; CNodeViewer::AddNode, COMDAT

; 3568 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3569 : 	if (m_nVisited >= 128)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1772], 128		; 00000080H
	jl	SHORT $L38967

; 3571 : 		return;

	jmp	$L38966
$L38967:

; 3575 : 		if (iFrom == iTo)

	mov	ecx, DWORD PTR _iFrom$[ebp]
	cmp	ecx, DWORD PTR _iTo$[ebp]
	jne	SHORT $L38969

; 3576 : 			return;

	jmp	$L38966
$L38969:

; 3577 : 
; 3578 : 		for (int i = 0; i < m_nVisited; i++)

	mov	DWORD PTR _i$38970[ebp], 0
	jmp	SHORT $L38971
$L38972:
	mov	edx, DWORD PTR _i$38970[ebp]
	add	edx, 1
	mov	DWORD PTR _i$38970[ebp], edx
$L38971:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$38970[ebp]
	cmp	ecx, DWORD PTR [eax+1772]
	jge	SHORT $L38973

; 3580 : 			if (m_aFrom[i] == iFrom && m_aTo[i] == iTo)

	mov	edx, DWORD PTR _i$38970[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+1776]
	cmp	ecx, DWORD PTR _iFrom$[ebp]
	jne	SHORT $L38974
	mov	edx, DWORD PTR _i$38970[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+2288]
	cmp	ecx, DWORD PTR _iTo$[ebp]
	jne	SHORT $L38974

; 3581 : 				return;

	jmp	SHORT $L38966
$L38974:

; 3582 : 			if (m_aFrom[i] == iTo && m_aTo[i] == iFrom)

	mov	edx, DWORD PTR _i$38970[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+1776]
	cmp	ecx, DWORD PTR _iTo$[ebp]
	jne	SHORT $L38975
	mov	edx, DWORD PTR _i$38970[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+2288]
	cmp	ecx, DWORD PTR _iFrom$[ebp]
	jne	SHORT $L38975

; 3583 : 				return;

	jmp	SHORT $L38966
$L38975:

; 3584 : 		}

	jmp	SHORT $L38972
$L38973:

; 3585 : 		m_aFrom[m_nVisited] = iFrom;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1772]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iFrom$[ebp]
	mov	DWORD PTR [ecx+eax*4+1776], edx

; 3586 : 		m_aTo[m_nVisited] = iTo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1772]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iTo$[ebp]
	mov	DWORD PTR [edx+ecx*4+2288], eax

; 3587 : 		m_nVisited++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1772]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1772], edx
$L38966:

; 3589 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddNode@CNodeViewer@@QAEXHH@Z ENDP			; CNodeViewer::AddNode
_TEXT	ENDS
EXTRN	?g_sModelIndexLaser@@3FA:WORD			; g_sModelIndexLaser
;	COMDAT ?DrawThink@CNodeViewer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?DrawThink@CNodeViewer@@QAEXXZ PROC NEAR		; CNodeViewer::DrawThink, COMDAT

; 3593 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3594 : 	pev->nextthink = gpGlobals->time;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+260], eax

; 3595 : 
; 3596 : 	for (int i = 0; i < 10; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38981
$L38982:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L38981:
	cmp	DWORD PTR _i$[ebp], 10			; 0000000aH
	jge	$L38983

; 3598 : 		if (m_iDraw == m_nVisited)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1768]
	cmp	ecx, DWORD PTR [eax+1772]
	jne	SHORT $L38984

; 3600 : 			UTIL_Remove( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 3601 : 			return;

	jmp	$L38979
$L38984:

; 3605 : 		MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );

	push	0
	push	0
	push	23					; 00000017H
	push	0
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 3606 : 			WRITE_BYTE( TE_BEAMPOINTS );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3607 : 			WRITE_COORD( WorldGraph.m_pNodes[ m_aFrom[m_iDraw] ].m_vecOrigin.x );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1768]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1776]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 3608 : 			WRITE_COORD( WorldGraph.m_pNodes[ m_aFrom[m_iDraw] ].m_vecOrigin.y );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1768]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1776]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	edx, DWORD PTR [ecx+eax+4]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 3609 : 			WRITE_COORD( WorldGraph.m_pNodes[ m_aFrom[m_iDraw] ].m_vecOrigin.z + NODE_HEIGHT );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1768]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1776]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	fld	DWORD PTR [ecx+eax+8]
	fadd	DWORD PTR __real@4@40028000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 3610 : 
; 3611 : 			WRITE_COORD( WorldGraph.m_pNodes[ m_aTo[m_iDraw] ].m_vecOrigin.x );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1768]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2288]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 3612 : 			WRITE_COORD( WorldGraph.m_pNodes[ m_aTo[m_iDraw] ].m_vecOrigin.y );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1768]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2288]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	mov	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 3613 : 			WRITE_COORD( WorldGraph.m_pNodes[ m_aTo[m_iDraw] ].m_vecOrigin.z + NODE_HEIGHT );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1768]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2288]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+12
	fld	DWORD PTR [eax+edx+8]
	fadd	DWORD PTR __real@4@40028000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 3614 : 			WRITE_SHORT( g_sModelIndexLaser );

	movsx	ecx, WORD PTR ?g_sModelIndexLaser@@3FA	; g_sModelIndexLaser
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 3615 : 			WRITE_BYTE( 0 ); // framerate

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3616 : 			WRITE_BYTE( 0 ); // framerate

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3617 : 			WRITE_BYTE( 250 ); // life

	push	250					; 000000faH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3618 : 			WRITE_BYTE( 40 );  // width

	push	40					; 00000028H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3619 : 			WRITE_BYTE( 0 );   // noise

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3620 : 			WRITE_BYTE( m_vecColor.x );   // r, g, b

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+2808]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3621 : 			WRITE_BYTE( m_vecColor.y );   // r, g, b

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+2812]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3622 : 			WRITE_BYTE( m_vecColor.z );   // r, g, b

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+2816]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3623 : 			WRITE_BYTE( 128 );	// brightness

	push	128					; 00000080H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3624 : 			WRITE_BYTE( 0 );		// speed

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3625 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 3626 : 
; 3627 : 		m_iDraw++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1768]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1768], eax

; 3628 : 	}

	jmp	$L38982
$L38983:
$L38979:

; 3629 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawThink@CNodeViewer@@QAEXXZ ENDP			; CNodeViewer::DrawThink
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCNodeEnt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CNodeEnt>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCNodeEnt@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CNodeEnt>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCNodeEnt@@@@UAEIXZ ; CEntityFactory<CNodeEnt>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCNodeEnt@@@@6B@		; CEntityFactory<CNodeEnt>::`vftable'
PUBLIC	??0IEntityFactory@@QAE@XZ			; IEntityFactory::IEntityFactory
EXTRN	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ:NEAR ; EntityFactoryDictionary
;	COMDAT ??_7?$CEntityFactory@VCNodeEnt@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCNodeEnt@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCNodeEnt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CNodeEnt>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCNodeEnt@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCNodeEnt@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCNodeEnt@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCNodeEnt@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CNodeEnt>::CEntityFactory<CNodeEnt>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCNodeEnt@@@@6B@ ; CEntityFactory<CNodeEnt>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCNodeEnt@@@@QAE@PBD@Z ENDP		; CEntityFactory<CNodeEnt>::CEntityFactory<CNodeEnt>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z		; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCNodeEnt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCNodeEnt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CNodeEnt>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z	; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCNodeEnt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CNodeEnt>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCNodeEnt@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCNodeEnt@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CNodeEnt>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCNodeEnt@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CNodeEnt>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCNodeEnt@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCNodeEnt@@@@UAEIXZ PROC NEAR ; CEntityFactory<CNodeEnt>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1768				; 000006e8H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCNodeEnt@@@@UAEIXZ ENDP ; CEntityFactory<CNodeEnt>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCTestHull@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CTestHull>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCTestHull@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CTestHull>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCTestHull@@@@UAEIXZ ; CEntityFactory<CTestHull>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCTestHull@@@@6B@		; CEntityFactory<CTestHull>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCTestHull@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCTestHull@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCTestHull@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CTestHull>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCTestHull@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCTestHull@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCTestHull@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCTestHull@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CTestHull>::CEntityFactory<CTestHull>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCTestHull@@@@6B@ ; CEntityFactory<CTestHull>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCTestHull@@@@QAE@PBD@Z ENDP	; CEntityFactory<CTestHull>::CEntityFactory<CTestHull>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCTestHull@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCTestHull@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CTestHull>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCTestHull@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CTestHull>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCTestHull@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCTestHull@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CTestHull>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCTestHull@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CTestHull>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCTestHull@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCTestHull@@@@UAEIXZ PROC NEAR ; CEntityFactory<CTestHull>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 2408				; 00000968H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCTestHull@@@@UAEIXZ ENDP ; CEntityFactory<CTestHull>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCNodeViewer@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CNodeViewer>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCNodeViewer@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CNodeViewer>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCNodeViewer@@@@UAEIXZ ; CEntityFactory<CNodeViewer>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCNodeViewer@@@@6B@	; CEntityFactory<CNodeViewer>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCNodeViewer@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCNodeViewer@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCNodeViewer@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CNodeViewer>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCNodeViewer@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCNodeViewer@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCNodeViewer@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCNodeViewer@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CNodeViewer>::CEntityFactory<CNodeViewer>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCNodeViewer@@@@6B@ ; CEntityFactory<CNodeViewer>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCNodeViewer@@@@QAE@PBD@Z ENDP	; CEntityFactory<CNodeViewer>::CEntityFactory<CNodeViewer>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCNodeViewer@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCNodeViewer@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CNodeViewer>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCNodeViewer@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CNodeViewer>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCNodeViewer@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCNodeViewer@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CNodeViewer>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCNodeViewer@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CNodeViewer>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCNodeViewer@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCNodeViewer@@@@UAEIXZ PROC NEAR ; CEntityFactory<CNodeViewer>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 2820				; 00000b04H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCNodeViewer@@@@UAEIXZ ENDP ; CEntityFactory<CNodeViewer>::GetEntitySize
_TEXT	ENDS
PUBLIC	??_7IEntityFactory@@6B@				; IEntityFactory::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT
??_7IEntityFactory@@6B@ DD FLAT:__purecall		; IEntityFactory::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IEntityFactory@@QAE@XZ PROC NEAR			; IEntityFactory::IEntityFactory, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IEntityFactory@@6B@ ; IEntityFactory::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0IEntityFactory@@QAE@XZ ENDP				; IEntityFactory::IEntityFactory
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_this$ = -16
__$EHRec$ = -12
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
PUBLIC	??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
PUBLIC	??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
PUBLIC	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT
??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ DB '('
	DB	'Base() == NULL) || (&src < Base()) || (&src >= (Base() + Coun'
	DB	't()) )', 00H				; `string'
CONST	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L40304
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L40304
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L40304
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40304:

; 520  : 	return InsertBefore( m_Size, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseMonster@@2Udatamap_s@@A:BYTE	; CBaseMonster::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseMonster@@2Udatamap_s@@A ; CBaseMonster::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z		; CBaseEntity::operator new
PUBLIC	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z		; CBaseEntity::operator delete
PUBLIC	??0CTestHull@@QAE@XZ				; CTestHull::CTestHull
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z
_TEXT	SEGMENT
_a$ = 8
_pev$ = -16
$T40309 = -20
$T40310 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z PROC NEAR		; GetClassPtr, COMDAT

; 1073 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1074 : 	entvars_t *pev = (entvars_t *)a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1075 : 
; 1076 : 	// allocate entity if necessary
; 1077 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39062

; 1078 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39062:

; 1079 : 
; 1080 : 	// get the private data
; 1081 : 	a = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 1082 : 
; 1083 : 	if (a == NULL) 

	cmp	DWORD PTR _a$[ebp], 0
	jne	SHORT $L39064

; 1085 : 		// allocate private data 
; 1086 : 		a = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2408					; 00000968H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40310[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40310[ebp], 0
	je	SHORT $L40311
	mov	ecx, DWORD PTR $T40310[ebp]
	call	??0CTestHull@@QAE@XZ			; CTestHull::CTestHull
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40312
$L40311:
	mov	DWORD PTR -28+[ebp], 0
$L40312:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40309[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40309[ebp]
	mov	DWORD PTR _a$[ebp], ecx

; 1087 : 		a->pev = pev;

	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39064:

; 1089 : 	return a;

	mov	eax, DWORD PTR _a$[ebp]

; 1090 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40310[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCTestHull@@PAV1@@Z ENDP		; GetClassPtr
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT
_stAllocateBlock$ = 8
_pev$ = 12
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator new, COMDAT

; 489  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 490  : 		return (void *)ALLOC_PRIVATE(ENT(pev), stAllocateBlock);

	mov	eax, DWORD PTR _stAllocateBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+252
	add	esp, 8

; 491  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z ENDP		; CBaseEntity::operator new
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 12
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator delete, COMDAT

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 497  : 		pev->flags |= FL_KILLME;

	mov	eax, DWORD PTR _pev$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+420], ecx

; 498  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z ENDP		; CBaseEntity::operator delete
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseEntity@@2Udatamap_s@@A:BYTE	; CBaseEntity::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseEntity@@2Udatamap_s@@A ; CBaseEntity::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	??0CNodeEnt@@QAE@XZ				; CNodeEnt::CNodeEnt
PUBLIC	?SetClassname@CBaseEntity@@QAEXPBD@Z		; CBaseEntity::SetClassname
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T40328 = -20
$T40329 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39074

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39074:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39076

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1768					; 000006e8H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40329[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40329[ebp], 0
	je	SHORT $L40330
	mov	ecx, DWORD PTR $T40329[ebp]
	call	??0CNodeEnt@@QAE@XZ			; CNodeEnt::CNodeEnt
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40331
$L40330:
	mov	DWORD PTR -28+[ebp], 0
$L40331:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40328[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40328[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39076:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40329[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCNodeEnt@@PAV1@PBD@Z ENDP		; GetClassPtr
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4
_pszClassName$ = 8
?SetClassname@CBaseEntity@@QAEXPBD@Z PROC NEAR		; CBaseEntity::SetClassname, COMDAT

; 302  : 	void		SetClassname( const char *pszClassName ) { pev->classname = MAKE_STRING( pszClassName ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClassname@CBaseEntity@@QAEXPBD@Z ENDP		; CBaseEntity::SetClassname
_TEXT	ENDS
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T40343 = -20
$T40344 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39085

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39085:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39087

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2408					; 00000968H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40344[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40344[ebp], 0
	je	SHORT $L40345
	mov	ecx, DWORD PTR $T40344[ebp]
	call	??0CTestHull@@QAE@XZ			; CTestHull::CTestHull
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40346
$L40345:
	mov	DWORD PTR -28+[ebp], 0
$L40346:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40343[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40343[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39087:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40344[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCTestHull@@PAV1@PBD@Z ENDP		; GetClassPtr
PUBLIC	??0CNodeViewer@@QAE@XZ				; CNodeViewer::CNodeViewer
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T40356 = -20
$T40357 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39096

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39096:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39098

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2820					; 00000b04H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40357[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40357[ebp], 0
	je	SHORT $L40358
	mov	ecx, DWORD PTR $T40357[ebp]
	call	??0CNodeViewer@@QAE@XZ			; CNodeViewer::CNodeViewer
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40359
$L40358:
	mov	DWORD PTR -28+[ebp], 0
$L40359:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40356[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40356[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39098:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40357[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCNodeViewer@@PAV1@PBD@Z ENDP		; GetClassPtr
PUBLIC	?EarPosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EarPosition
PUBLIC	?SetYawSpeed@CBaseMonster@@UAEXXZ		; CBaseMonster::SetYawSpeed
PUBLIC	?IsPointSized@CBaseEntity@@UBEHXZ		; CBaseEntity::IsPointSized
PUBLIC	?Illumination@CBaseEntity@@UAEHXZ		; CBaseEntity::Illumination
PUBLIC	?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z	; CBaseMonster::FValidateCover
PUBLIC	?CoverRadius@CBaseMonster@@UAEMXZ		; CBaseMonster::CoverRadius
PUBLIC	?CheckAmmo@CBaseMonster@@UAEXXZ			; CBaseMonster::CheckAmmo
PUBLIC	?HearingSensitivity@CBaseMonster@@UAEMXZ	; CBaseMonster::HearingSensitivity
PUBLIC	?PrescheduleThink@CBaseMonster@@UAEXXZ		; CBaseMonster::PrescheduleThink
PUBLIC	?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z	; CBaseMonster::BodyTarget
PUBLIC	?IsMoving@CBaseMonster@@UAEHXZ			; CBaseMonster::IsMoving
PUBLIC	?DeathSound@CBaseMonster@@UAEXXZ		; CBaseMonster::DeathSound
PUBLIC	?AlertSound@CBaseMonster@@UAEXXZ		; CBaseMonster::AlertSound
PUBLIC	?IdleSound@CBaseMonster@@UAEXXZ			; CBaseMonster::IdleSound
PUBLIC	?PainSound@CBaseMonster@@UAEXXZ			; CBaseMonster::PainSound
PUBLIC	?StopFollowing@CBaseMonster@@UAEXH@Z		; CBaseMonster::StopFollowing
PUBLIC	??0CBaseMonster@@QAE@XZ				; CBaseMonster::CBaseMonster
PUBLIC	??1CBaseMonster@@QAE@XZ				; CBaseMonster::~CBaseMonster
PUBLIC	?GetToggleState@CBaseToggle@@UAEHXZ		; CBaseToggle::GetToggleState
PUBLIC	?GetDelay@CBaseToggle@@UAEMXZ			; CBaseToggle::GetDelay
PUBLIC	?Spawn@CBaseEntity@@UAEXXZ			; CBaseEntity::Spawn
PUBLIC	?Precache@CBaseEntity@@UAEXXZ			; CBaseEntity::Precache
PUBLIC	?Activate@CBaseEntity@@UAEXXZ			; CBaseEntity::Activate
PUBLIC	?OnChangeLevel@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeLevel
PUBLIC	?OnTeleport@CBaseEntity@@UAEXXZ			; CBaseEntity::OnTeleport
PUBLIC	?PortalSleep@CBaseEntity@@UAEXM@Z		; CBaseEntity::PortalSleep
PUBLIC	?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ; CBaseEntity::StartMessage
PUBLIC	?GetPosition@CBaseEntity@@UAEMXZ		; CBaseEntity::GetPosition
PUBLIC	?OnChangeParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeParent
PUBLIC	?OnClearParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnClearParent
PUBLIC	?OnRemove@CBaseEntity@@UAEXXZ			; CBaseEntity::OnRemove
PUBLIC	?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z	; CBaseEntity::DeathNotice
PUBLIC	?IsRigidBody@CBaseEntity@@UAEHXZ		; CBaseEntity::IsRigidBody
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z	; CBaseEntity::GetState
PUBLIC	?IsTriggered@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::IsTriggered
PUBLIC	?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ; CBaseEntity::MySquadMonsterPointer
PUBLIC	?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ	; CBaseEntity::GetVehicleDriver
PUBLIC	?AddPoints@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPoints
PUBLIC	?AddPointsToTeam@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPointsToTeam
PUBLIC	?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::AddPlayerItem
PUBLIC	?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::RemovePlayerItem
PUBLIC	?GiveAmmo@CBaseEntity@@UAEHHPADH@Z		; CBaseEntity::GiveAmmo
PUBLIC	?OverrideReset@CBaseEntity@@UAEXXZ		; CBaseEntity::OverrideReset
PUBLIC	?TransferReset@CBaseEntity@@UAEXXZ		; CBaseEntity::TransferReset
PUBLIC	?SetToggleState@CBaseEntity@@UAEXH@Z		; CBaseEntity::SetToggleState
PUBLIC	?StartSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StartSneaking
PUBLIC	?StopSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StopSneaking
PUBLIC	?OnControls@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::OnControls
PUBLIC	?IsSneaking@CBaseEntity@@UAEHXZ			; CBaseEntity::IsSneaking
PUBLIC	?IsBSPModel@CBaseEntity@@UAEHXZ			; CBaseEntity::IsBSPModel
PUBLIC	?IsCustomModel@CBaseEntity@@UAEHXZ		; CBaseEntity::IsCustomModel
PUBLIC	?ReflectGauss@CBaseEntity@@UAEHXZ		; CBaseEntity::ReflectGauss
PUBLIC	?HasTarget@CBaseEntity@@UAEHH@Z			; CBaseEntity::HasTarget
PUBLIC	?IsPlayer@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPlayer
PUBLIC	?IsNetClient@CBaseEntity@@UAEHXZ		; CBaseEntity::IsNetClient
PUBLIC	?IsMonster@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMonster
PUBLIC	?IsPushable@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPushable
PUBLIC	?Classify@CBaseMonster@@UAEHXZ			; CBaseMonster::Classify
PUBLIC	?IsProjectile@CBaseEntity@@UAEHXZ		; CBaseEntity::IsProjectile
PUBLIC	?BloodColor@CBaseMonster@@UAEHXZ		; CBaseMonster::BloodColor
PUBLIC	?IsFuncScreen@CBaseEntity@@UAEHXZ		; CBaseEntity::IsFuncScreen
PUBLIC	?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ	; CBaseMonster::MyMonsterPointer
PUBLIC	?IsPortal@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPortal
PUBLIC	?IsTank@CBaseEntity@@UAEHXZ			; CBaseEntity::IsTank
PUBLIC	?IsMover@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMover
PUBLIC	?IsBreakable@CBaseEntity@@UAEHXZ		; CBaseEntity::IsBreakable
PUBLIC	?IsAlive@CBaseMonster@@UAEHXZ			; CBaseMonster::IsAlive
PUBLIC	?TeamID@CBaseEntity@@UAEPBDXZ			; CBaseEntity::TeamID
PUBLIC	?Think@CBaseEntity@@UAEXXZ			; CBaseEntity::Think
PUBLIC	?ObjectCaps@CTestHull@@UAEHXZ			; CTestHull::ObjectCaps
PUBLIC	?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z	; CBaseEntity::Use
PUBLIC	?Touch@CBaseEntity@@UAEXPAV1@@Z			; CBaseEntity::Touch
PUBLIC	?Blocked@CBaseEntity@@UAEXPAV1@@Z		; CBaseEntity::Blocked
PUBLIC	??_7CTestHull@@6B@				; CTestHull::`vftable'
PUBLIC	?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ ; CBaseMonster::GetStoppedActivity
PUBLIC	?Stop@CBaseMonster@@UAEXXZ			; CBaseMonster::Stop
PUBLIC	?Respawn@CBaseEntity@@UAEPAV1@XZ		; CBaseEntity::Respawn
PUBLIC	?ScheduleChange@CBaseMonster@@UAEXXZ		; CBaseMonster::ScheduleChange
PUBLIC	?CanPlaySentence@CBaseMonster@@UAEHH@Z		; CBaseMonster::CanPlaySentence
PUBLIC	?UpdateOwner@CBaseEntity@@UAEXXZ		; CBaseEntity::UpdateOwner
PUBLIC	?Center@CBaseEntity@@UAE?AVVector@@XZ		; CBaseEntity::Center
PUBLIC	?EyePosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EyePosition
EXTRN	?FVisible@CBaseEntity@@UAEHPAV1@@Z:NEAR		; CBaseEntity::FVisible
EXTRN	?FVisible@CBaseEntity@@UAEHABVVector@@@Z:NEAR	; CBaseEntity::FVisible
EXTRN	?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z:NEAR ; CBaseMonster::BuildNearestRoute
EXTRN	?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z:NEAR	; CBaseEntity::ShouldCollide
EXTRN	?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z:NEAR ; CBaseMonster::FindCover
EXTRN	?FCanCheckAttacks@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::FCanCheckAttacks
EXTRN	?IgnoreConditions@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::IgnoreConditions
EXTRN	?FValidateHintType@CBaseMonster@@UAEHF@Z:NEAR	; CBaseMonster::FValidateHintType
EXTRN	?FCanActiveIdle@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::FCanActiveIdle
EXTRN	?ISoundMask@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::ISoundMask
EXTRN	?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ:NEAR	; CBaseMonster::PBestSound
EXTRN	?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ:NEAR	; CBaseMonster::PBestScent
EXTRN	?FBecomeProne@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::FBecomeProne
EXTRN	?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z:NEAR ; CBaseMonster::BarnacleVictimBitten
EXTRN	?BarnacleVictimReleased@CBaseMonster@@UAEXXZ:NEAR ; CBaseMonster::BarnacleVictimReleased
EXTRN	?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseMonster::TraceAttack
EXTRN	?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ:NEAR ; CBaseMonster::GetDeathActivity
EXTRN	?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z:NEAR ; CBaseMonster::Killed
EXTRN	?GibMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::GibMonster
EXTRN	?DamageDecal@CBaseMonster@@UAEHH@Z:NEAR		; CBaseMonster::DamageDecal
EXTRN	?HasHumanGibs@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::HasHumanGibs
EXTRN	?HasAlienGibs@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::HasAlienGibs
EXTRN	?FadeMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::FadeMonster
EXTRN	?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ:NEAR ; CBaseMonster::GetGunPosition
EXTRN	?TakeHealth@CBaseMonster@@UAEHMH@Z:NEAR		; CBaseMonster::TakeHealth
EXTRN	?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseMonster::TakeDamage
EXTRN	?StepSound@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::StepSound
EXTRN	?GetState@CBaseToggle@@UAE?AW4STATE@@XZ:NEAR	; CBaseToggle::GetState
EXTRN	?MoveDone@CBaseToggle@@UAEXXZ:NEAR		; CBaseToggle::MoveDone
EXTRN	?Save@CBaseEntity@@UAEHAAVCSave@@@Z:NEAR	; CBaseEntity::Save
EXTRN	?SetObjectCollisionBox@CBaseEntity@@UAEXXZ:NEAR	; CBaseEntity::SetObjectCollisionBox
EXTRN	?SetNextThink@CBaseEntity@@UAEXM@Z:NEAR		; CBaseEntity::SetNextThink
EXTRN	?TakeArmor@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeArmor
EXTRN	?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceBleed
EXTRN	?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseMonster::KeyValue
EXTRN	?IsInWorld@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::IsInWorld
EXTRN	?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z:NEAR	; CBaseMonster::Restore
EXTRN	?Look@CBaseMonster@@UAEXH@Z:NEAR		; CBaseMonster::Look
EXTRN	?RunAI@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::RunAI
EXTRN	?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::ShouldFadeOnDeath
EXTRN	?GetNextTarget@CBaseEntity@@UAEPAV1@XZ:NEAR	; CBaseEntity::GetNextTarget
EXTRN	?ChangeYaw@CBaseMonster@@UAEMH@Z:NEAR		; CBaseMonster::ChangeYaw
EXTRN	?MonsterThink@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::MonsterThink
EXTRN	?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::IRelationship
EXTRN	?MonsterInit@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::MonsterInit
EXTRN	?MonsterInitDead@CBaseMonster@@UAEXXZ:NEAR	; CBaseMonster::MonsterInitDead
EXTRN	?BecomeDead@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::BecomeDead
EXTRN	?StartMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::StartMonster
EXTRN	?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ:NEAR ; CBaseMonster::BestVisibleEnemy
EXTRN	?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::FInViewCone
EXTRN	?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z:NEAR ; CBaseMonster::FInViewCone
EXTRN	?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z:NEAR ; CBaseMonster::HandleAnimEvent
EXTRN	?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z:NEAR ; CBaseMonster::CheckLocalMove
EXTRN	?Move@CBaseMonster@@UAEXM@Z:NEAR		; CBaseMonster::Move
EXTRN	?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z:NEAR ; CBaseMonster::MoveExecute
EXTRN	?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z:NEAR	; CBaseMonster::ShouldAdvanceRoute
EXTRN	?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckRangeAttack1
EXTRN	?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckRangeAttack2
EXTRN	?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckMeleeAttack1
EXTRN	?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckMeleeAttack2
EXTRN	?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z:NEAR ; CBaseMonster::ScheduleFromName
EXTRN	?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z:NEAR	; CBaseMonster::StartTask
EXTRN	?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z:NEAR	; CBaseMonster::RunTask
EXTRN	?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z:NEAR ; CBaseMonster::GetScheduleOfType
EXTRN	?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ:NEAR ; CBaseMonster::GetSchedule
EXTRN	?CanPlaySequence@CBaseMonster@@UAEHHH@Z:NEAR	; CBaseMonster::CanPlaySequence
EXTRN	?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z:NEAR	; CBaseMonster::PlaySentence
EXTRN	?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::PlayScriptedSentence
EXTRN	?SentenceStop@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::SentenceStop
EXTRN	?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ:NEAR ; CBaseMonster::GetIdealState
EXTRN	?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z:NEAR ; CBaseMonster::SetActivity
EXTRN	?ReportAIState@CBaseMonster@@UAEXXZ:NEAR	; CBaseMonster::ReportAIState
EXTRN	?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::CheckEnemy
EXTRN	?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z:NEAR ; CBaseMonster::FTriangulate
;	COMDAT ??_7CTestHull@@6B@
CONST	SEGMENT
??_7CTestHull@@6B@ DD FLAT:?GetDataDescMap@CTestHull@@UAEPAUdatamap_s@@XZ ; CTestHull::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CTestHull@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseMonster@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseMonster@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseMonster@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseMonster@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseMonster@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CBaseMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CBaseMonster@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CBaseMonster@@UAEHXZ
	DD	FLAT:?CheckAmmo@CBaseMonster@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CBaseMonster@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?PainSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CTestHull@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CTestHull@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CTestHull@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CTestHull@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CTestHull@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CTestHull@@QAE@XZ PROC NEAR				; CTestHull::CTestHull, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CTestHull@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseMonster@@QAE@XZ			; CBaseMonster::CBaseMonster
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2396				; 0000095cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CTestHull@@6B@ ; CTestHull::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CTestHull@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseMonster@@QAE@XZ			; CBaseMonster::~CBaseMonster
	ret	0
__ehhandler$??0CTestHull@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CTestHull@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CTestHull@@QAE@XZ ENDP				; CTestHull::CTestHull
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Spawn, COMDAT

; 325  : 	virtual void	Spawn( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Spawn
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Precache, COMDAT

; 326  : 	virtual void	Precache( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Precache
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Activate@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Activate, COMDAT

; 365  : 	virtual void	Activate( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Activate
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeLevel@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeLevel, COMDAT

; 366  : 	virtual void	OnChangeLevel( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeLevel@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnChangeLevel
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnTeleport@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnTeleport, COMDAT

; 367  : 	virtual void	OnTeleport( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnTeleport@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnTeleport
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4
?PortalSleep@CBaseEntity@@UAEXM@Z PROC NEAR		; CBaseEntity::PortalSleep, COMDAT

; 368  : 	virtual void	PortalSleep( float seconds ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PortalSleep@CBaseEntity@@UAEXM@Z ENDP			; CBaseEntity::PortalSleep
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CBaseEntity::StartMessage, COMDAT

; 369  :           virtual void	StartMessage( CBasePlayer *pPlayer ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ENDP	; CBaseEntity::StartMessage
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetPosition@CBaseEntity@@UAEMXZ PROC NEAR		; CBaseEntity::GetPosition, COMDAT

; 370  : 	virtual float	GetPosition( void ) { return 0.0f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPosition@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetPosition
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeParent, COMDAT

; 371  : 	virtual void	OnChangeParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CBaseEntity@@UAEXXZ ENDP		; CBaseEntity::OnChangeParent
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnClearParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnClearParent, COMDAT

; 372  : 	virtual void	OnClearParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnClearParent
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnRemove@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::OnRemove, COMDAT

; 373  : 	virtual void	OnRemove( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnRemove@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnRemove
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z PROC NEAR ; CBaseEntity::DeathNotice, COMDAT

; 386  : 	virtual void DeathNotice ( entvars_t *pevChild ) { } // monster maker children use this to tell the monster maker that they have died.

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z ENDP	; CBaseEntity::DeathNotice
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsRigidBody@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsRigidBody, COMDAT

; 387  : 	virtual BOOL IsRigidBody( void ) { return (m_iActorType == ACTOR_DYNAMIC); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	mov	eax, ecx
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsRigidBody@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsRigidBody
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z PROC NEAR	; CBaseEntity::GetState, COMDAT

; 401  : 	virtual STATE GetState ( CBaseEntity* pEnt ) { return GetState(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z ENDP	; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::IsTriggered, COMDAT

; 410  : 	virtual BOOL	IsTriggered( CBaseEntity *pActivator ) {return TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::IsTriggered
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ PROC NEAR ; CBaseEntity::MySquadMonsterPointer, COMDAT

; 412  : 	virtual CSquadMonster *MySquadMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ENDP ; CBaseEntity::MySquadMonsterPointer
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ PROC NEAR	; CBaseEntity::GetVehicleDriver, COMDAT

; 413  : 	virtual CBaseEntity *GetVehicleDriver( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ ENDP		; CBaseEntity::GetVehicleDriver
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPoints@CBaseEntity@@UAEXHH@Z PROC NEAR		; CBaseEntity::AddPoints, COMDAT

; 415  : 	virtual void	AddPoints( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPoints@CBaseEntity@@UAEXHH@Z ENDP			; CBaseEntity::AddPoints
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z PROC NEAR	; CBaseEntity::AddPointsToTeam, COMDAT

; 416  : 	virtual void	AddPointsToTeam( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z ENDP		; CBaseEntity::AddPointsToTeam
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::AddPlayerItem, COMDAT

; 417  : 	virtual BOOL	AddPlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::AddPlayerItem
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::RemovePlayerItem, COMDAT

; 418  : 	virtual BOOL	RemovePlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::RemovePlayerItem
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT
_this$ = -4
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z PROC NEAR		; CBaseEntity::GiveAmmo, COMDAT

; 419  : 	virtual int 	GiveAmmo( int iAmount, char *szName, int iMax ) { return -1; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z ENDP			; CBaseEntity::GiveAmmo
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OverrideReset, COMDAT

; 422  : 	virtual void	OverrideReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OverrideReset
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TransferReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::TransferReset, COMDAT

; 423  : 	virtual void	TransferReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransferReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::TransferReset
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?SetToggleState@CBaseEntity@@UAEXH@Z PROC NEAR		; CBaseEntity::SetToggleState, COMDAT

; 426  : 	virtual void	SetToggleState( int state ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetToggleState@CBaseEntity@@UAEXH@Z ENDP		; CBaseEntity::SetToggleState
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StartSneaking, COMDAT

; 427  : 	virtual void	StartSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StartSneaking
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StopSneaking, COMDAT

; 428  : 	virtual void	StopSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StopSneaking
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?OnControls@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::OnControls, COMDAT

; 429  : 	virtual BOOL	OnControls( CBaseEntity *pTest ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnControls@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::OnControls
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSneaking@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsSneaking, COMDAT

; 430  : 	virtual BOOL	IsSneaking( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSneaking@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsSneaking
_TEXT	ENDS
EXTRN	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z:NEAR	; UTIL_GetModelType
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBSPModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBSPModel, COMDAT

; 432  : 	virtual BOOL	IsBSPModel( void ) { return UTIL_GetModelType( pev->modelindex ) == mod_brush; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBSPModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBSPModel
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsCustomModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsCustomModel, COMDAT

; 433  : 	virtual BOOL	IsCustomModel( void ) { return pev->solid == SOLID_CUSTOM; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+268], 5
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCustomModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsCustomModel
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ReflectGauss@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ReflectGauss, COMDAT

; 434  : 	virtual BOOL	ReflectGauss( void ) { return (( IsBSPModel() || IsCustomModel()) && !pev->takedamage ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	test	eax, eax
	jne	SHORT $L40440
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+208]
	test	eax, eax
	je	SHORT $L40441
$L40440:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40441
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40442
$L40441:
	mov	DWORD PTR -8+[ebp], 0
$L40442:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReflectGauss@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ReflectGauss
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_targetname$ = 8
?HasTarget@CBaseEntity@@UAEHH@Z PROC NEAR		; CBaseEntity::HasTarget, COMDAT

; 435  : 	virtual BOOL	HasTarget( string_t targetname ) { return FStrEq(STRING(targetname), STRING(pev->targetname) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _targetname$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasTarget@CBaseEntity@@UAEHH@Z ENDP			; CBaseEntity::HasTarget
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPlayer@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPlayer, COMDAT

; 437  : 	virtual BOOL	IsPlayer( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPlayer
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsNetClient@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsNetClient, COMDAT

; 438  : 	virtual BOOL	IsNetClient( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetClient@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsNetClient
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMonster@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsMonster, COMDAT

; 439  : 	virtual BOOL	IsMonster( void ) { return (pev->flags & FL_MONSTER ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+420]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMonster@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMonster
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPushable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsPushable, COMDAT

; 440  : 	virtual BOOL	IsPushable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPushable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPushable
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsProjectile@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsProjectile, COMDAT

; 441  : 	virtual BOOL	IsProjectile( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsProjectile@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsProjectile
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsFuncScreen@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsFuncScreen, COMDAT

; 442  : 	virtual BOOL	IsFuncScreen( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFuncScreen@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsFuncScreen
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPortal@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPortal, COMDAT

; 443  : 	virtual BOOL	IsPortal( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPortal@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPortal
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTank@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsTank, COMDAT

; 444  : 	virtual BOOL	IsTank( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTank@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsTank
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMover@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMover, COMDAT

; 445  : 	virtual BOOL	IsMover( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMover
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBreakable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBreakable, COMDAT

; 446  : 	virtual BOOL	IsBreakable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBreakable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBreakable
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?TeamID@CBaseEntity@@UAEPBDXZ PROC NEAR			; CBaseEntity::TeamID, COMDAT

; 447  : 	virtual const char	*TeamID( void ) { return ""; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TeamID@CBaseEntity@@UAEPBDXZ ENDP			; CBaseEntity::TeamID
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Think@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Think, COMDAT

; 458  : 	virtual void Think( void ) { if (m_pfnThink) (this->*m_pfnThink)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1744], 0
	je	SHORT $L35006
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1744]
$L35006:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Think
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
_pActivator$ = 8
_pCaller$ = 12
_useType$ = 16
_value$ = 20
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z PROC NEAR	; CBaseEntity::Use, COMDAT

; 461  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 		if (m_pfnUse) (this->*m_pfnUse)( pActivator, pCaller, useType, value );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1752], 0
	je	SHORT $L35009
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCaller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1752]
$L35009:

; 463  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z ENDP	; CBaseEntity::Use
_TEXT	ENDS
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Touch@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Touch, COMDAT

; 466  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 		if( m_pfnTouch )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1748], 0
	je	SHORT $L35012

; 468  : 			(this->*m_pfnTouch)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1748]
$L35012:

; 469  : 
; 470  : 		// forward the blocked event to our parent, if any.
; 471  : 		if( m_hParent != NULL && !m_isChaining )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35013
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1628]
	test	ecx, ecx
	jne	SHORT $L35013

; 472  : 			m_hParent->Touch( pOther );

	mov	edx, DWORD PTR _pOther$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+280]
$L35013:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Touch
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator->, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Blocked@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Blocked, COMDAT

; 476  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 		if( m_pfnBlocked )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1756], 0
	je	SHORT $L35016

; 478  : 			(this->*m_pfnBlocked)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1756]
$L35016:

; 479  : 
; 480  : 		// forward the blocked event to our parent, if any.
; 481  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35017

; 482  : 			m_hParent->Blocked( pOther );

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+284]
$L35017:

; 483  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Blocked
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?Respawn@CBaseEntity@@UAEPAV1@XZ PROC NEAR		; CBaseEntity::Respawn, COMDAT

; 513  : 	virtual CBaseEntity *Respawn( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Respawn@CBaseEntity@@UAEPAV1@XZ ENDP			; CBaseEntity::Respawn
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?UpdateOwner@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::UpdateOwner, COMDAT

; 705  : 	virtual	void UpdateOwner( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateOwner@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::UpdateOwner
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40487 = -16
$T40488 = -28
?Center@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR		; CBaseEntity::Center, COMDAT

; 714  : 	virtual Vector Center( ) { return (pev->absmax + pev->absmin) * 0.5; }; // center point of entity

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T40488[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	push	edx
	lea	eax, DWORD PTR $T40487[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 208				; 000000d0H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Center@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::Center
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40491 = -16
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EyePosition, COMDAT

; 715  : 	virtual Vector EyePosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of eyes

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T40491[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EyePosition
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40494 = -16
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EarPosition, COMDAT

; 716  : 	virtual Vector EarPosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of ears

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T40494[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EarPosition
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPointSized@CBaseEntity@@UBEHXZ PROC NEAR		; CBaseEntity::IsPointSized, COMDAT

; 718  : 	virtual BOOL IsPointSized() const { return (pev->size == g_vecZero) ? true : false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	setne	al
	and	eax, 255				; 000000ffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPointSized@CBaseEntity@@UBEHXZ ENDP			; CBaseEntity::IsPointSized
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Illumination@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::Illumination, COMDAT

; 720  : 	virtual int Illumination( ) { return GETENTITYILLUM( ENT( pev ) ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+60
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Illumination@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Illumination
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseToggle@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseToggle@@UAEHXZ PROC NEAR		; CBaseToggle::GetToggleState, COMDAT

; 978  : 	virtual int GetToggleState( void ) { return m_toggle_state; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1816]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseToggle@@UAEHXZ ENDP		; CBaseToggle::GetToggleState
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseToggle@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseToggle@@UAEMXZ PROC NEAR			; CBaseToggle::GetDelay, COMDAT

; 979  : 	virtual float GetDelay( void ) { return m_flWait; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1764]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseToggle@@UAEMXZ ENDP			; CBaseToggle::GetDelay
_TEXT	ENDS
;	COMDAT ?Classify@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::Classify, COMDAT

; 130  : 	virtual int	Classify( void ) { return m_iClass ? m_iClass : CLASS_NONE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2388], 0
	je	SHORT $L40505
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2388]
	mov	DWORD PTR -8+[ebp], edx
	jmp	SHORT $L40506
$L40505:
	mov	DWORD PTR -8+[ebp], 0
$L40506:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::Classify
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::BloodColor, COMDAT

; 132  : 	virtual int	 BloodColor( void ) { return m_bloodColor; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+2328]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::BloodColor
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ PROC NEAR	; CBaseMonster::MyMonsterPointer, COMDAT

; 134  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return this; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ ENDP		; CBaseMonster::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseMonster@@UAEHXZ PROC NEAR			; CBaseMonster::IsAlive, COMDAT

; 139  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag != DEAD_DEAD); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+368], 2
	setne	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::IsAlive
_TEXT	ENDS
;	COMDAT ?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ PROC NEAR ; CBaseMonster::GetStoppedActivity, COMDAT

; 175  : 		virtual Activity GetStoppedActivity( void ) { return ACT_IDLE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ ENDP ; CBaseMonster::GetStoppedActivity
_TEXT	ENDS
;	COMDAT ?Stop@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Stop@CBaseMonster@@UAEXXZ PROC NEAR			; CBaseMonster::Stop, COMDAT

; 176  : 		virtual void Stop( void ) { m_IdealActivity = GetStoppedActivity(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2072], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@CBaseMonster@@UAEXXZ ENDP				; CBaseMonster::Stop
_TEXT	ENDS
;	COMDAT ?ScheduleChange@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ScheduleChange@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::ScheduleChange, COMDAT

; 203  : 		virtual void ScheduleChange( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ScheduleChange@CBaseMonster@@UAEXXZ ENDP		; CBaseMonster::ScheduleChange
_TEXT	ENDS
;	COMDAT ?CanPlaySentence@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
?CanPlaySentence@CBaseMonster@@UAEHH@Z PROC NEAR	; CBaseMonster::CanPlaySentence, COMDAT

; 206  : 		virtual int CanPlaySentence( BOOL fDisregardState ) { return IsAlive(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CanPlaySentence@CBaseMonster@@UAEHH@Z ENDP		; CBaseMonster::CanPlaySentence
_TEXT	ENDS
;	COMDAT ?SetYawSpeed@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SetYawSpeed@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::SetYawSpeed, COMDAT

; 241  : 		virtual void SetYawSpeed ( void ) { return; };// allows different yaw_speeds for each activity

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetYawSpeed@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::SetYawSpeed
_TEXT	ENDS
;	COMDAT ?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4
?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z PROC NEAR ; CBaseMonster::FValidateCover, COMDAT

; 249  : 		virtual BOOL FValidateCover ( const Vector &vecCoverLocation ) { return TRUE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z ENDP	; CBaseMonster::FValidateCover
_TEXT	ENDS
PUBLIC	__real@4@4008c400000000000000
;	COMDAT __real@4@4008c400000000000000
; File z:\xashxtsrc\server\monsters\basemonster.h
CONST	SEGMENT
__real@4@4008c400000000000000 DD 044440000r	; 784
CONST	ENDS
;	COMDAT ?CoverRadius@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?CoverRadius@CBaseMonster@@UAEMXZ PROC NEAR		; CBaseMonster::CoverRadius, COMDAT

; 250  : 		virtual float CoverRadius( void ) { return 784; } // Default cover radius

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@4008c400000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CoverRadius@CBaseMonster@@UAEMXZ ENDP			; CBaseMonster::CoverRadius
_TEXT	ENDS
;	COMDAT ?CheckAmmo@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CheckAmmo@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::CheckAmmo, COMDAT

; 253  : 		virtual void CheckAmmo( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckAmmo@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::CheckAmmo
_TEXT	ENDS
;	COMDAT ?HearingSensitivity@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?HearingSensitivity@CBaseMonster@@UAEMXZ PROC NEAR	; CBaseMonster::HearingSensitivity, COMDAT

; 278  : 		virtual float HearingSensitivity( void ) { return 1.0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@3fff8000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HearingSensitivity@CBaseMonster@@UAEMXZ ENDP		; CBaseMonster::HearingSensitivity
_TEXT	ENDS
;	COMDAT ?PrescheduleThink@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PrescheduleThink@CBaseMonster@@UAEXXZ PROC NEAR	; CBaseMonster::PrescheduleThink, COMDAT

; 298  : 		virtual void PrescheduleThink( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrescheduleThink@CBaseMonster@@UAEXXZ ENDP		; CBaseMonster::PrescheduleThink
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40537 = -16
$T40538 = -28
$T40539 = -40
$T40540 = -52
$T40541 = -64
?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseMonster::BodyTarget, COMDAT

; 318  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ) * 0.75 + EyePosition() * 0.25; };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1048576000				; 3e800000H
	lea	eax, DWORD PTR $T40540[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40539[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+308]
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T40541[ebp]
	push	ecx
	push	1061158912				; 3f400000H
	lea	edx, DWORD PTR $T40538[ebp]
	push	edx
	lea	eax, DWORD PTR $T40537[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseMonster::BodyTarget
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::IsMoving, COMDAT

; 328  : 	virtual int		IsMoving( void ) { return m_movementGoal != MOVEGOAL_NONE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+2228], 0
	setne	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::IsMoving
_TEXT	ENDS
;	COMDAT ?DeathSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DeathSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::DeathSound, COMDAT

; 333  : 	virtual void DeathSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DeathSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::DeathSound
_TEXT	ENDS
;	COMDAT ?AlertSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?AlertSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::AlertSound, COMDAT

; 334  : 	virtual void AlertSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AlertSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::AlertSound
_TEXT	ENDS
;	COMDAT ?IdleSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?IdleSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::IdleSound, COMDAT

; 335  : 	virtual void IdleSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IdleSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::IdleSound
_TEXT	ENDS
;	COMDAT ?PainSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PainSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::PainSound, COMDAT

; 336  : 	virtual void PainSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PainSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::PainSound
_TEXT	ENDS
;	COMDAT ?StopFollowing@CBaseMonster@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?StopFollowing@CBaseMonster@@UAEXH@Z PROC NEAR		; CBaseMonster::StopFollowing, COMDAT

; 339  : 	virtual void StopFollowing( BOOL clearSchedule ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StopFollowing@CBaseMonster@@UAEXH@Z ENDP		; CBaseMonster::StopFollowing
_TEXT	ENDS
PUBLIC	?ObjectCaps@CBaseEntity@@UAEHXZ			; CBaseEntity::ObjectCaps
;	COMDAT ?ObjectCaps@CTestHull@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CTestHull@@UAEHXZ PROC NEAR			; CTestHull::ObjectCaps, COMDAT

; 1436 : 	virtual int ObjectCaps( void ) { return BaseClass :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CTestHull@@UAEHXZ ENDP			; CTestHull::ObjectCaps
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ObjectCaps, COMDAT

; 364  : 	virtual int	ObjectCaps( void ) { return FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 2
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ObjectCaps
_TEXT	ENDS
PUBLIC	?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z	; CBaseEntity::BodyTarget
PUBLIC	??0CBaseEntity@@QAE@XZ				; CBaseEntity::CBaseEntity
PUBLIC	?ObjectCaps@CNodeEnt@@EAEHXZ			; CNodeEnt::ObjectCaps
PUBLIC	??_7CNodeEnt@@6B@				; CNodeEnt::`vftable'
PUBLIC	?Classify@CBaseEntity@@UAEHXZ			; CBaseEntity::Classify
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@XZ		; CBaseEntity::GetState
PUBLIC	?BloodColor@CBaseEntity@@UAEHXZ			; CBaseEntity::BloodColor
PUBLIC	?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ; CBaseEntity::MyMonsterPointer
PUBLIC	?GetToggleState@CBaseEntity@@UAEHXZ		; CBaseEntity::GetToggleState
PUBLIC	?GetDelay@CBaseEntity@@UAEMXZ			; CBaseEntity::GetDelay
PUBLIC	?IsMoving@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMoving
PUBLIC	?IsAlive@CBaseEntity@@UAEHXZ			; CBaseEntity::IsAlive
PUBLIC	?MoveDone@CBaseEntity@@UAEXXZ			; CBaseEntity::MoveDone
PUBLIC	?FBecomeProne@CBaseEntity@@UAEHXZ		; CBaseEntity::FBecomeProne
EXTRN	?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseEntity::GetDataDescMap
EXTRN	?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z:NEAR	; CBaseEntity::Restore
EXTRN	?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceAttack
EXTRN	?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseEntity::TakeDamage
EXTRN	?TakeHealth@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeHealth
EXTRN	?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z:NEAR	; CBaseEntity::Killed
EXTRN	?DamageDecal@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::DamageDecal
;	COMDAT ??_7CNodeEnt@@6B@
CONST	SEGMENT
??_7CNodeEnt@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CNodeEnt::`vftable'
	DD	FLAT:?Spawn@CNodeEnt@@EAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CNodeEnt@@EAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CNodeEnt@@EAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CNodeEnt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CNodeEnt@@QAE@XZ PROC NEAR				; CNodeEnt::CNodeEnt, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CNodeEnt@@6B@ ; CNodeEnt::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CNodeEnt@@QAE@XZ ENDP				; CNodeEnt::CNodeEnt
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::Classify, COMDAT

; 385  : 	virtual int Classify ( void ) { return CLASS_NONE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Classify
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseEntity::GetState, COMDAT

; 398  : 	virtual STATE GetState ( void ) { return STATE_OFF; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ ENDP		; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::BloodColor, COMDAT

; 408  : 	virtual int	BloodColor( void ) { return DONT_BLEED; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::BloodColor
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ PROC NEAR ; CBaseEntity::MyMonsterPointer, COMDAT

; 411  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ENDP ; CBaseEntity::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::GetToggleState, COMDAT

; 414  : 	virtual int	GetToggleState( void ) { return TS_AT_TOP; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseEntity@@UAEHXZ ENDP		; CBaseEntity::GetToggleState
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseEntity@@UAEMXZ PROC NEAR			; CBaseEntity::GetDelay, COMDAT

; 420  : 	virtual float	GetDelay( void ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetDelay
_TEXT	ENDS
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMoving, COMDAT

; 421  : 	virtual int	IsMoving( void ) { return GetAbsVelocity() != g_vecZero; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMoving
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsAlive, COMDAT

; 431  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	jne	SHORT $L40579
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40579
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40580
$L40579:
	mov	DWORD PTR -8+[ebp], 0
$L40580:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsAlive
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MoveDone@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::MoveDone, COMDAT

; 485  : 	virtual void MoveDone( void ) { if( m_pfnMoveDone )(this->*m_pfnMoveDone)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1760], 0
	je	SHORT $L35020
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1760]
$L35020:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveDone@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::MoveDone
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FBecomeProne@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::FBecomeProne, COMDAT

; 709  : 	virtual BOOL FBecomeProne( void ) {return FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FBecomeProne@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::FBecomeProne
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40587 = -16
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseEntity::BodyTarget, COMDAT

; 717  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ); };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T40587[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseEntity::BodyTarget
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CNodeEnt@@EAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CNodeEnt@@EAEHXZ PROC NEAR			; CNodeEnt::ObjectCaps, COMDAT

; 268  : 	virtual int	ObjectCaps( void ) { return CBaseEntity :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CNodeEnt@@EAEHXZ ENDP			; CNodeEnt::ObjectCaps
_TEXT	ENDS
PUBLIC	??1CBaseEntity@@QAE@XZ				; CBaseEntity::~CBaseEntity
PUBLIC	??_7CNodeViewer@@6B@				; CNodeViewer::`vftable'
;	COMDAT ??_7CNodeViewer@@6B@
CONST	SEGMENT
??_7CNodeViewer@@6B@ DD FLAT:?GetDataDescMap@CNodeViewer@@UAEPAUdatamap_s@@XZ ; CNodeViewer::`vftable'
	DD	FLAT:?Spawn@CNodeViewer@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CNodeViewer@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CNodeViewer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CNodeViewer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CNodeViewer@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CNodeViewer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CNodeViewer@@QAE@XZ PROC NEAR			; CNodeViewer::CNodeViewer, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CNodeViewer@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2808				; 00000af8H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CNodeViewer@@6B@ ; CNodeViewer::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CNodeViewer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseEntity@@QAE@XZ			; CBaseEntity::~CBaseEntity
	ret	0
__ehhandler$??0CNodeViewer@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CNodeViewer@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CNodeViewer@@QAE@XZ ENDP				; CNodeViewer::CNodeViewer
PUBLIC	??0WayPoint_t@@QAE@XZ				; WayPoint_t::WayPoint_t
PUBLIC	??_7CBaseMonster@@6B@				; CBaseMonster::`vftable'
PUBLIC	??0CBaseToggle@@QAE@XZ				; CBaseToggle::CBaseToggle
PUBLIC	??1CBaseToggle@@QAE@XZ				; CBaseToggle::~CBaseToggle
EXTRN	?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseMonster::GetDataDescMap
;	COMDAT ??_7CBaseMonster@@6B@
CONST	SEGMENT
??_7CBaseMonster@@6B@ DD FLAT:?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ ; CBaseMonster::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseMonster@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseMonster@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseMonster@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseMonster@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseMonster@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CBaseMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CBaseMonster@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CBaseMonster@@UAEHXZ
	DD	FLAT:?CheckAmmo@CBaseMonster@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CBaseMonster@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?PainSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseMonster@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseMonster@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseMonster@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseMonster@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseMonster@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseMonster@@QAE@XZ PROC NEAR			; CBaseMonster::CBaseMonster, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseMonster@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseToggle@@QAE@XZ			; CBaseToggle::CBaseToggle
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2008				; 000007d8H
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0WayPoint_t@@QAE@XZ	; WayPoint_t::WayPoint_t
	push	8
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2100				; 00000834H
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2240				; 000008c0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2264				; 000008d8H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2364				; 0000093cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET FLAT:??_7CBaseMonster@@6B@ ; CBaseMonster::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseMonster@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseToggle@@QAE@XZ			; CBaseToggle::~CBaseToggle
	ret	0
__ehhandler$??0CBaseMonster@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseMonster@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseMonster@@QAE@XZ ENDP				; CBaseMonster::CBaseMonster
;	COMDAT ??1CBaseMonster@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseMonster@@QAE@XZ PROC NEAR			; CBaseMonster::~CBaseMonster, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseToggle@@QAE@XZ			; CBaseToggle::~CBaseToggle
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseMonster@@QAE@XZ ENDP				; CBaseMonster::~CBaseMonster
_TEXT	ENDS
PUBLIC	??_7CBaseEntity@@6B@				; CBaseEntity::`vftable'
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	??0CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::CMeshDesc
EXTRN	??1CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::~CMeshDesc
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT
??_7CBaseEntity@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CBaseEntity::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseEntity@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseEntity@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseEntity@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseEntity@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseEntity@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??0CMeshDesc@@QAE@XZ			; CMeshDesc::CMeshDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1632				; 00000660H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseEntity@@6B@ ; CBaseEntity::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseEntity@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	ret	0
__ehhandler$??0CBaseEntity@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseEntity@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::CBaseEntity
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::~CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::~CBaseEntity
_TEXT	ENDS
PUBLIC	?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z ; CBaseAnimating::HandleAnimEvent
PUBLIC	??0CBaseAnimating@@QAE@XZ			; CBaseAnimating::CBaseAnimating
PUBLIC	??1CBaseAnimating@@QAE@XZ			; CBaseAnimating::~CBaseAnimating
PUBLIC	??_7CBaseToggle@@6B@				; CBaseToggle::`vftable'
EXTRN	?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseToggle::KeyValue
EXTRN	?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z:NEAR	; CBaseToggle::Restore
EXTRN	?GetDataDescMap@CBaseToggle@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseToggle::GetDataDescMap
;	COMDAT ??_7CBaseToggle@@6B@
CONST	SEGMENT
??_7CBaseToggle@@6B@ DD FLAT:?GetDataDescMap@CBaseToggle@@UAEPAUdatamap_s@@XZ ; CBaseToggle::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseToggle@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseToggle@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseToggle@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseToggle@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseToggle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseToggle@@QAE@XZ PROC NEAR			; CBaseToggle::CBaseToggle, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseToggle@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseAnimating@@QAE@XZ		; CBaseAnimating::CBaseAnimating
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1864				; 00000748H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1912				; 00000778H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1924				; 00000784H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1936				; 00000790H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseToggle@@6B@ ; CBaseToggle::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseToggle@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseAnimating@@QAE@XZ		; CBaseAnimating::~CBaseAnimating
	ret	0
__ehhandler$??0CBaseToggle@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseToggle@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseToggle@@QAE@XZ ENDP				; CBaseToggle::CBaseToggle
;	COMDAT ?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT
_this$ = -4
?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z PROC NEAR ; CBaseAnimating::HandleAnimEvent, COMDAT

; 909  : 	virtual void HandleAnimEvent( MonsterEvent_t *pEvent ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z ENDP ; CBaseAnimating::HandleAnimEvent
_TEXT	ENDS
;	COMDAT ??1CBaseToggle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseToggle@@QAE@XZ PROC NEAR			; CBaseToggle::~CBaseToggle, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseAnimating@@QAE@XZ		; CBaseAnimating::~CBaseAnimating
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseToggle@@QAE@XZ ENDP				; CBaseToggle::~CBaseToggle
_TEXT	ENDS
;	COMDAT ??0WayPoint_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0WayPoint_t@@QAE@XZ PROC NEAR				; WayPoint_t::WayPoint_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0WayPoint_t@@QAE@XZ ENDP				; WayPoint_t::WayPoint_t
_TEXT	ENDS
PUBLIC	?GetState@CBaseDelay@@UAE?AW4STATE@@XZ		; CBaseDelay::GetState
PUBLIC	??0CBaseDelay@@QAE@XZ				; CBaseDelay::CBaseDelay
PUBLIC	??_7CBaseAnimating@@6B@				; CBaseAnimating::`vftable'
EXTRN	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseDelay::KeyValue
EXTRN	?GetDataDescMap@CBaseAnimating@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseAnimating::GetDataDescMap
;	COMDAT ??_7CBaseAnimating@@6B@
CONST	SEGMENT
??_7CBaseAnimating@@6B@ DD FLAT:?GetDataDescMap@CBaseAnimating@@UAEPAUdatamap_s@@XZ ; CBaseAnimating::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
CONST	ENDS
;	COMDAT ??0CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseAnimating@@QAE@XZ PROC NEAR			; CBaseAnimating::CBaseAnimating, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseAnimating@@6B@ ; CBaseAnimating::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseAnimating@@QAE@XZ ENDP				; CBaseAnimating::CBaseAnimating
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseDelay::GetState, COMDAT

; 881  : 	virtual STATE GetState( void ) { return m_iState; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1788]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ ENDP		; CBaseDelay::GetState
_TEXT	ENDS
PUBLIC	??1CBaseDelay@@QAE@XZ				; CBaseDelay::~CBaseDelay
;	COMDAT ??1CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseAnimating@@QAE@XZ PROC NEAR			; CBaseAnimating::~CBaseAnimating, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseDelay@@QAE@XZ			; CBaseDelay::~CBaseDelay
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseAnimating@@QAE@XZ ENDP				; CBaseAnimating::~CBaseAnimating
_TEXT	ENDS
PUBLIC	??_7CBaseDelay@@6B@				; CBaseDelay::`vftable'
EXTRN	?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseDelay::GetDataDescMap
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT
??_7CBaseDelay@@6B@ DD FLAT:?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ ; CBaseDelay::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseDelay@@6B@ ; CBaseDelay::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::CBaseDelay
_TEXT	ENDS
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::~CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseEntity@@QAE@XZ			; CBaseEntity::~CBaseEntity
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::~CBaseDelay
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
PUBLIC	?CopyConstruct@@YAXPAPADABQAD@Z			; CopyConstruct
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ DB '('
	DB	'elem == Count()) || IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L40659
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L40659
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L40659
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40659:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L40660
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40660
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40660:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAPADABQAD@Z		; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC NEAR		; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L40665
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40665:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L39162

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L39162:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PADH@@QAE@XZ PROC NEAR			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
_TEXT	ENDS
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC NEAR		; CUtlMemory<char *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40670
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40670:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40671
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40671:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC NEAR		; CUtlMemory<char *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40674
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40674:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC NEAR	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40681
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L40681
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40682
$L40681:
	mov	DWORD PTR -8+[ebp], 0
$L40682:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAPAD@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L39195:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L39196

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAD@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L39195
$L39196:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ		; CUtlMemory<char *,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@PADH@@QAEXH@Z		; CUtlMemory<char *,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L39205

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@PADH@@QAEXH@Z	; CUtlMemory<char *,int>::Grow
$L39205:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
_TEXT	ENDS
PUBLIC	??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
EXTRN	_memmove:NEAR
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ DB 'I'
	DB	'sValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 )', 00H ; `string'
CONST	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40689
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L40689
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L40689
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40689:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L39214
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L39214

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L39214:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
_src$ = 12
$T40692 = -4
?CopyConstruct@@YAXPAPADABQAD@Z PROC NEAR		; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T40692[ebp], eax
	cmp	DWORD PTR $T40692[ebp], 0
	je	SHORT $L40693
	mov	ecx, DWORD PTR $T40692[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T40692[ebp]
	mov	DWORD PTR -8+[ebp], ecx
	jmp	SHORT $L40694
$L40693:
	mov	DWORD PTR -8+[ebp], 0
$L40694:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyConstruct@@YAXPAPADABQAD@Z ENDP			; CopyConstruct
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC NEAR	; CUtlMemory<char *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40699
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L40699
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40700
$L40699:
	mov	DWORD PTR -8+[ebp], 0
$L40700:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC NEAR		; CUtlMemory<char *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39228

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L39229

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L39229:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L39228:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR	; CUtlMemory<char *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ PROC NEAR	; CUtlMemory<char *,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ ENDP		; CUtlMemory<char *,int>::NumAllocated
_TEXT	ENDS
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@PADH@@QAEXH@Z PROC NEAR		; CUtlMemory<char *,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L40709
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40709:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L39243

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L40710
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40710:

; 567  : 		return;

	jmp	$L39240
$L39243:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	4
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L39263

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L39255
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L39255

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L39263
$L39255:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L39259

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L40711
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40711:

; 589  : 				return;

	jmp	$L39240
$L39259:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L39263

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L39259
$L39263:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L39266

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L40712
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40712:

; 603  : 	else

	jmp	SHORT $L40713
$L39266:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L40713
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40713:
$L39240:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@PADH@@QAEXH@Z ENDP			; CUtlMemory<char *,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L28985

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L28990
$L28985:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L28987

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L28987:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L28990

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L28987
$L28990:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR ; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAD@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAD@Z ENDP				; Destruct
_TEXT	ENDS
END
