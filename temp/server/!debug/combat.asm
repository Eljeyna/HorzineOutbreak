	TITLE	Z:\XashXTSRC\server\combat.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGEN@AnimateUntilDead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HOLP@CGib?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@BKJG@BounceGibTouch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@ICLP@StickyGibTouch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DHF@WaitTillLand?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@FBGL@models?1stickygib?4mdl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@OBBL@models?1germangibs?4mdl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@NOLD@models?1hgibs?4mdl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@OLK@models?1agibs?4mdl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@CHLM@common?1bodysplat?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@JDJM@violence_hgibs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@DCJD@violence_agibs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LNFJ@common?1null?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GAKJ@SUB_FadeOut?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@BMDK@SUB_StartFadeOut?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HBJ@gib?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MDCK@monster_target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector2D@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector2D@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??XVector@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Make2D@Vector@@QBE?AVVector2D@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPointEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopAnimation@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remember@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasMemory@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CGib@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExplosionMagnitude@CBreakable@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CGib@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CGib@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E38
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E42
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LimitVelocity@CGib@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdjustVelocityBasedOnHealth@CGib@@QAEXHAAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpawnStickyGibs@CGib@@SAXPAUentvars_s@@VVector@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpawnHeadGib@CGib@@SAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpawnRandomGibs@CGib@@SAXPAUentvars_s@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasHumanGibs@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasAlienGibs@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FadeMonster@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GibMonster@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSmallFlinchActivity@CBaseMonster@@QAE?AW4Activity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BecomeDead@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShouldGibMonster@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CallGibMonster@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DamageDecal@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SUB_StartFadeOut@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SUB_FadeOut@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WaitTillLand@CGib@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BounceGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StickyGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CGib@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TakeHealth@CBaseMonster@@UAEHMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeadTakeDamage@CBaseMonster@@QAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DamageForce@CBaseMonster@@QAEMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RadiusDamage@@YAXVVector@@PAUentvars_s@@1MMHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RadiusDamage@CBaseMonster@@QAEXPAUentvars_s@@0MHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RadiusDamage@CBaseMonster@@QAEXVVector@@PAUentvars_s@@1MHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckTraceHullAttack@CBaseMonster@@QAEPAVCBaseEntity@@MHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FVisible@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FVisible@CBaseEntity@@UAEHABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeDamageBloodDecal@CBaseMonster@@QAEXHMPAUgametrace_s@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCGib@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGib@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CGib@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??_C@_04HOLP@CGib?$AA@				; `string'
PUBLIC	?g_DataMapHolder@CGib_DataDescInit@@3PAUdatamap_s@@A ; CGib_DataDescInit::g_DataMapHolder
PUBLIC	?m_DataMap@CGib@@2Udatamap_s@@A			; CGib::m_DataMap
_BSS	SEGMENT
?g_DataMapHolder@CGib_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CGib_DataDescInit::g_DataMapHolder
_BSS	ENDS
_DATA	SEGMENT
?m_DataMap@CGib@@2Udatamap_s@@A DD 00H			; CGib::m_DataMap
	DD	00H
	DD	FLAT:??_C@_04HOLP@CGib?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S40	DD	FLAT:_$E39
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	012H
	ORG $+68
_DATA	ENDS
;	COMDAT ??_C@_04HOLP@CGib?$AA@
CONST	SEGMENT
??_C@_04HOLP@CGib?$AA@ DB 'CGib', 00H			; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CGib@@UAEPAUdatamap_s@@XZ	; CGib::GetDataDescMap
;	COMDAT ?GetDataDescMap@CGib@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CGib@@UAEPAUdatamap_s@@XZ PROC NEAR	; CGib::GetDataDescMap, COMDAT

; 43   : BEGIN_DATADESC( CGib )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CGib@@2Udatamap_s@@A ; CGib::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CGib@@UAEPAUdatamap_s@@XZ ENDP		; CGib::GetDataDescMap
_TEXT	ENDS
PUBLIC	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
PUBLIC	?GetBaseMap@CGib@@SAPAUdatamap_s@@XZ		; CGib::GetBaseMap
;	COMDAT ?GetBaseMap@CGib@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CGib@@SAPAUdatamap_s@@XZ PROC NEAR		; CGib::GetBaseMap, COMDAT

; 43   : BEGIN_DATADESC( CGib )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CGib@@SAPAUdatamap_s@@XZ ENDP		; CGib::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT
_$E39	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E38
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E39	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z	; DataMapInit
;	COMDAT _$E38
_TEXT	SEGMENT
_$E38	PROC NEAR					; COMDAT

; 43   : BEGIN_DATADESC( CGib )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CGib_DataDescInit@@3PAUdatamap_s@@A, eax ; CGib_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E38	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@BKJG@BounceGibTouch?$AA@		; `string'
PUBLIC	??_C@_0P@ICLP@StickyGibTouch?$AA@		; `string'
PUBLIC	??_C@_0N@DHF@WaitTillLand?$AA@			; `string'
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
PUBLIC	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
PUBLIC	?BounceGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z	; CGib::BounceGibTouch
PUBLIC	?StickyGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z	; CGib::StickyGibTouch
PUBLIC	?WaitTillLand@CGib@@QAEXXZ			; CGib::WaitTillLand
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0P@BKJG@BounceGibTouch?$AA@
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
??_C@_0P@BKJG@BounceGibTouch?$AA@ DB 'BounceGibTouch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ICLP@StickyGibTouch?$AA@
CONST	SEGMENT
??_C@_0P@ICLP@StickyGibTouch?$AA@ DB 'StickyGibTouch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DHF@WaitTillLand?$AA@
CONST	SEGMENT
??_C@_0N@DHF@WaitTillLand?$AA@ DB 'WaitTillLand', 00H	; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z PROC NEAR	; DataMapInit, COMDAT

; 43   : BEGIN_DATADESC( CGib )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L38032
	mov	cl, BYTE PTR _?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_04HOLP@CGib?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E42
	call	_atexit
	add	esp, 4
$L38032:
	call	?GetBaseMap@CGib@@SAPAUdatamap_s@@XZ	; CGib::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CGib@@2Udatamap_s@@A+12, eax

; 44   : 	DEFINE_FUNCTION( BounceGibTouch ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L38036
	mov	al, BYTE PTR _?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_0P@BKJG@BounceGibTouch?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+28, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+32, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+36, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+38, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+40, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+44, OFFSET FLAT:?BounceGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z ; CGib::BounceGibTouch

; 45   : 	DEFINE_FUNCTION( StickyGibTouch ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+48, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0P@ICLP@StickyGibTouch?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+52, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+56, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+60, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+62, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+64, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+68, OFFSET FLAT:?StickyGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z ; CGib::StickyGibTouch

; 46   : 	DEFINE_FUNCTION( WaitTillLand ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+72, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0N@DHF@WaitTillLand?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+76, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+80, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+84, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+86, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+88, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+92, OFFSET FLAT:?WaitTillLand@CGib@@QAEXXZ ; CGib::WaitTillLand
$L38036:

; 47   : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L38046
	mov	DWORD PTR ?m_DataMap@CGib@@2Udatamap_s@@A+4, 3
	mov	DWORD PTR ?m_DataMap@CGib@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L38047
$L38046:
	mov	DWORD PTR ?m_DataMap@CGib@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CGib@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4PAUtypedescription_s@@A
$L38047:
	mov	eax, OFFSET FLAT:?m_DataMap@CGib@@2Udatamap_s@@A ; CGib::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z ENDP		; DataMapInit
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
EXTRN	_strlen:NEAR
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_pszBase$ = 8
_this$ = -4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC NEAR	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
PUBLIC	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
PUBLIC	??_C@_04NHIK@?$CFs?3?3?$AA@			; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_strcat:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
; File z:\xashxtsrc\common\datamap.h
CONST	SEGMENT
??_C@_04NHIK@?$CFs?3?3?$AA@ DB '%s::', 00H		; `string'
CONST	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT
_pszIdentifier$ = 8
$T39263 = -12
_this$ = -4
_pBuf$ = -8
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z PROC NEAR ; CDatadescGeneratedNameHolder::GenerateName, COMDAT

; 205  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		char *pBuf = new char[m_nLenBase + strlen(pszIdentifier) + 1];

	mov	eax, DWORD PTR _pszIdentifier$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax+1]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T39263[ebp], eax
	mov	ecx, DWORD PTR $T39263[ebp]
	mov	DWORD PTR _pBuf$[ebp], ecx

; 207  : 		sprintf( pBuf, "%s::", m_pszBase );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_04NHIK@?$CFs?3?3?$AA@	; `string'
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 208  : 		strcat( pBuf, pszIdentifier );

	mov	edx, DWORD PTR _pszIdentifier$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 209  : 		m_Names.AddToTail( pBuf );

	lea	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail

; 210  : 		return pBuf;

	mov	eax, DWORD PTR _pBuf$[ebp]

; 211  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ENDP ; CDatadescGeneratedNameHolder::GenerateName
_TEXT	ENDS
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E42
_TEXT	SEGMENT
_$E42	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGib@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E42	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File z:\xashxtsrc\common\datamap.h
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
$T39268 = -24
__$EHRec$ = -12
_this$ = -16
_i$ = -20
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC NEAR	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L30214
$L30215:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L30214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L30216

; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T39268[ebp], edx
	mov	eax, DWORD PTR $T39268[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 		}

	jmp	SHORT $L30215
$L30216:

; 202  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	ret	0
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	__real@8@4009bb80000000000000
PUBLIC	?LimitVelocity@CGib@@QAEXXZ			; CGib::LimitVelocity
EXTRN	__fltused:NEAR
EXTRN	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsVelocity
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
;	COMDAT __real@8@4009bb80000000000000
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
__real@8@4009bb80000000000000 DQ 04097700000000000r ; 1500
CONST	ENDS
;	COMDAT ?LimitVelocity@CGib@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_vecNewVelocity$ = -16
_length$ = -20
$T39282 = -32
$T39283 = -44
?LimitVelocity@CGib@@QAEXXZ PROC NEAR			; CGib::LimitVelocity, COMDAT

; 51   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 52   : 	Vector vecNewVelocity = GetAbsVelocity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vecNewVelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 53   : 	float length = vecNewVelocity.Length();

	lea	ecx, DWORD PTR _vecNewVelocity$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _length$[ebp]

; 54   : 
; 55   : 	// ceiling at 1500.  The gib velocity equation is not bounded properly.  Rather than tune it
; 56   : 	// in 3 separate places again, I'll just limit it here.
; 57   : 	if( length > 1500.0 )

	fld	DWORD PTR _length$[ebp]
	fcomp	QWORD PTR __real@8@4009bb80000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38055

; 59   : 		vecNewVelocity = vecNewVelocity.Normalize() * 1500;	// This should really be sv_maxvelocity * 0.75 or something

	push	1153138688				; 44bb8000H
	lea	eax, DWORD PTR $T39283[ebp]
	push	eax
	lea	ecx, DWORD PTR $T39282[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecNewVelocity$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecNewVelocity$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecNewVelocity$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecNewVelocity$[ebp+8], edx

; 60   : 		SetAbsVelocity( vecNewVelocity );

	lea	eax, DWORD PTR _vecNewVelocity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L38055:

; 62   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LimitVelocity@CGib@@QAEXXZ ENDP			; CGib::LimitVelocity
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T39291 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39291[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
EXTRN	_sqrt:NEAR
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
PUBLIC	__real@4@00000000000000000000
PUBLIC	__real@4@3fff8000000000000000
;	COMDAT __real@4@00000000000000000000
; File z:\xashxtsrc\game_shared\vector.h
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT __real@4@3fff8000000000000000
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_flLen$ = -8
$T39298 = -20
?Normalize@Vector@@QBE?AV1@XZ PROC NEAR			; Vector::Normalize, COMDAT

; 232  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 234  : 
; 235  : 		if( flLen )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L24894

; 237  : 			flLen = 1.0f / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 238  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39298[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L24892
$L24894:

; 240  : 
; 241  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L24892:

; 242  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
PUBLIC	??XVector@@QAEAAV0@M@Z				; Vector::operator*=
PUBLIC	?AdjustVelocityBasedOnHealth@CGib@@QAEXHAAVVector@@@Z ; CGib::AdjustVelocityBasedOnHealth
;	COMDAT ?AdjustVelocityBasedOnHealth@CGib@@QAEXHAAVVector@@@Z
_TEXT	SEGMENT
_nHealth$ = 8
_vecVelocity$ = 12
_this$ = -4
?AdjustVelocityBasedOnHealth@CGib@@QAEXHAAVVector@@@Z PROC NEAR ; CGib::AdjustVelocityBasedOnHealth, COMDAT

; 68   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 	if( nHealth > -50 )

	cmp	DWORD PTR _nHealth$[ebp], -50		; ffffffceH
	jle	SHORT $L38063

; 71   : 		vecVelocity *= 0.7f;

	push	1060320051				; 3f333333H
	mov	ecx, DWORD PTR _vecVelocity$[ebp]
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=

; 73   : 	else if( nHealth > -200 )

	jmp	SHORT $L38066
$L38063:
	cmp	DWORD PTR _nHealth$[ebp], -200		; ffffff38H
	jle	SHORT $L38065

; 75   : 		vecVelocity *= 2;

	push	1073741824				; 40000000H
	mov	ecx, DWORD PTR _vecVelocity$[ebp]
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=

; 77   : 	else

	jmp	SHORT $L38066
$L38065:

; 79   : 		vecVelocity *= 4;

	push	1082130432				; 40800000H
	mov	ecx, DWORD PTR _vecVelocity$[ebp]
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=
$L38066:

; 81   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AdjustVelocityBasedOnHealth@CGib@@QAEXHAAVVector@@@Z ENDP ; CGib::AdjustVelocityBasedOnHealth
_TEXT	ENDS
;	COMDAT ??XVector@@QAEAAV0@M@Z
_TEXT	SEGMENT
_s$ = 8
_this$ = -4
??XVector@@QAEAAV0@M@Z PROC NEAR			; Vector::operator*=, COMDAT

; 174  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 		x *= s; y *= s; z *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 176  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 177  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??XVector@@QAEAAV0@M@Z ENDP				; Vector::operator*=
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCGib@@PAV1@@Z		; GetClassPtr
PUBLIC	??_C@_0BF@FBGL@models?1stickygib?4mdl?$AA@	; `string'
PUBLIC	??_C@_04BAK@NULL?$AA@				; `string'
PUBLIC	?Spawn@CGib@@QAEXPBD@Z				; CGib::Spawn
PUBLIC	?SpawnStickyGibs@CGib@@SAXPAUentvars_s@@VVector@@H@Z ; CGib::SpawnStickyGibs
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z	; CBaseEntity::Instance
PUBLIC	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
PUBLIC	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet
EXTRN	?g_Language@@3HA:DWORD				; g_Language
EXTRN	__ftol:NEAR
EXTRN	?g_vecAttackDir@@3VVector@@A:BYTE		; g_vecAttackDir
EXTRN	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalOrigin
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAvelocity
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z:NEAR ; UTIL_SetSize
;	COMDAT ??_C@_0BF@FBGL@models?1stickygib?4mdl?$AA@
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
??_C@_0BF@FBGL@models?1stickygib?4mdl?$AA@ DB 'models/stickygib.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
CONST	SEGMENT
??_C@_04BAK@NULL?$AA@ DB 'NULL', 00H			; `string'
CONST	ENDS
;	COMDAT ?SpawnStickyGibs@CGib@@SAXPAUentvars_s@@VVector@@H@Z
_TEXT	SEGMENT
_pevVictim$ = 8
_vecOrigin$ = 12
_cGibs$ = 24
_i$ = -4
_pGib$38077 = -8
_vecNewVelocity$38086 = -20
_vecAngVelocity$38088 = -32
$T39309 = -44
$T39310 = -56
?SpawnStickyGibs@CGib@@SAXPAUentvars_s@@VVector@@H@Z PROC NEAR ; CGib::SpawnStickyGibs, COMDAT

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 85   : 	int i;
; 86   : 
; 87   : 	if ( g_Language == LANGUAGE_GERMAN )

	cmp	DWORD PTR ?g_Language@@3HA, 1		; g_Language
	jne	SHORT $L38073

; 89   : 		// no sticky gibs in germany right now!
; 90   : 		return; 

	jmp	$L38071
$L38073:

; 92   : 
; 93   : 	for ( i = 0 ; i < cGibs ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38074
$L38075:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38074:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _cGibs$[ebp]
	jge	$L38076

; 95   : 		CGib *pGib = GetClassPtr( (CGib *)NULL );

	push	0
	call	?GetClassPtr@@YAPAVCGib@@PAV1@@Z	; GetClassPtr
	add	esp, 4
	mov	DWORD PTR _pGib$38077[ebp], eax

; 96   : 
; 97   : 		pGib->Spawn( "models/stickygib.mdl" );

	push	OFFSET FLAT:??_C@_0BF@FBGL@models?1stickygib?4mdl?$AA@ ; `string'
	mov	ecx, DWORD PTR _pGib$38077[ebp]
	call	?Spawn@CGib@@QAEXPBD@Z			; CGib::Spawn

; 98   : 		pGib->pev->body = RANDOM_LONG(0,2);

	push	2
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	edx, DWORD PTR _pGib$38077[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+276], eax

; 99   : 
; 100  : 		if ( pevVictim )

	cmp	DWORD PTR _pevVictim$[ebp], 0
	je	$L38084

; 102  : 			pGib->SetLocalOrigin( Vector(
; 103  : 				vecOrigin.x + RANDOM_FLOAT( -3, 3 ),
; 104  : 				vecOrigin.y + RANDOM_FLOAT( -3, 3 ),
; 105  : 				vecOrigin.z + RANDOM_FLOAT( -3, 3 )
; 106  : 			));

	push	1077936128				; 40400000H
	push	-1069547520				; c0400000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecOrigin$[ebp+8]
	push	ecx
	fstp	DWORD PTR [esp]
	push	1077936128				; 40400000H
	push	-1069547520				; c0400000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecOrigin$[ebp+4]
	push	ecx
	fstp	DWORD PTR [esp]
	push	1077936128				; 40400000H
	push	-1069547520				; c0400000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecOrigin$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39309[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _pGib$38077[ebp]
	call	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalOrigin

; 107  : 
; 108  : 			// make the gib fly away from the attack vector
; 109  : 			Vector vecNewVelocity = g_vecAttackDir * -1;

	push	-1082130432				; bf800000H
	lea	edx, DWORD PTR $T39310[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?g_vecAttackDir@@3VVector@@A
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _vecNewVelocity$38086[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 110  : 
; 111  : 			// mix in some noise
; 112  : 			vecNewVelocity.x += RANDOM_FLOAT( -0.15f, 0.15f );

	push	1041865114				; 3e19999aH
	push	-1105618534				; be19999aH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecNewVelocity$38086[ebp]
	fstp	DWORD PTR _vecNewVelocity$38086[ebp]

; 113  : 			vecNewVelocity.y += RANDOM_FLOAT( -0.15f, 0.15f );

	push	1041865114				; 3e19999aH
	push	-1105618534				; be19999aH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecNewVelocity$38086[ebp+4]
	fstp	DWORD PTR _vecNewVelocity$38086[ebp+4]

; 114  : 			vecNewVelocity.z += RANDOM_FLOAT( -0.15f, 0.15f );

	push	1041865114				; 3e19999aH
	push	-1105618534				; be19999aH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecNewVelocity$38086[ebp+8]
	fstp	DWORD PTR _vecNewVelocity$38086[ebp+8]

; 115  : 
; 116  : 			vecNewVelocity *= 900;

	push	1147207680				; 44610000H
	lea	ecx, DWORD PTR _vecNewVelocity$38086[ebp]
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=

; 117  : 
; 118  : 			Vector vecAngVelocity( RANDOM_FLOAT( 250, 400 ), RANDOM_FLOAT( 250, 400 ), 0 );

	push	0
	push	1137180672				; 43c80000H
	push	1132068864				; 437a0000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	1137180672				; 43c80000H
	push	1132068864				; 437a0000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _vecAngVelocity$38088[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 119  : 			pGib->SetLocalAvelocity( vecAngVelocity );

	lea	eax, DWORD PTR _vecAngVelocity$38088[ebp]
	push	eax
	mov	ecx, DWORD PTR _pGib$38077[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 120  : 
; 121  :  			pGib->AdjustVelocityBasedOnHealth( pevVictim->health, vecNewVelocity );

	lea	ecx, DWORD PTR _vecNewVelocity$38086[ebp]
	push	ecx
	mov	edx, DWORD PTR _pevVictim$[ebp]
	fld	DWORD PTR [edx+352]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _pGib$38077[ebp]
	call	?AdjustVelocityBasedOnHealth@CGib@@QAEXHAAVVector@@@Z ; CGib::AdjustVelocityBasedOnHealth

; 122  : 			pGib->SetAbsVelocity( vecNewVelocity );

	lea	eax, DWORD PTR _vecNewVelocity$38086[ebp]
	push	eax
	mov	ecx, DWORD PTR _pGib$38077[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 123  : 
; 124  : 			// copy owner's blood color
; 125  : 			pGib->m_bloodColor = (CBaseEntity::Instance(pevVictim))->BloodColor();

	mov	ecx, DWORD PTR _pevVictim$[ebp]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR -60+[ebp], eax
	mov	edx, DWORD PTR -60+[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR -60+[ebp]
	call	DWORD PTR [eax+112]
	mov	ecx, DWORD PTR _pGib$38077[ebp]
	mov	DWORD PTR [ecx+1764], eax

; 126  : 
; 127  : 			pGib->pev->movetype = MOVETYPE_TOSS;

	mov	edx, DWORD PTR _pGib$38077[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 6

; 128  : 			pGib->pev->solid = SOLID_BBOX;

	mov	ecx, DWORD PTR _pGib$38077[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 2

; 129  : 			UTIL_SetSize( pGib->pev, g_vecZero, g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _pGib$38077[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 130  : 			pGib->SetTouch( StickyGibTouch );

	push	OFFSET FLAT:??_C@_0P@ICLP@StickyGibTouch?$AA@ ; `string'
	push	OFFSET FLAT:?StickyGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z ; CGib::StickyGibTouch
	mov	ecx, DWORD PTR _pGib$38077[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 131  : 			pGib->SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _pGib$38077[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
$L38084:

; 133  : 
; 134  : 		pGib->LimitVelocity();

	mov	ecx, DWORD PTR _pGib$38077[ebp]
	call	?LimitVelocity@CGib@@QAEXXZ		; CGib::LimitVelocity

; 135  : 	}

	jmp	$L38075
$L38076:
$L38071:

; 136  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SpawnStickyGibs@CGib@@SAXPAUentvars_s@@VVector@@H@Z ENDP ; CGib::SpawnStickyGibs
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z PROC NEAR ; CBaseEntity::Instance, COMDAT

; 533  : 	static CBaseEntity *Instance( entvars_t *pev ) { return Instance( ENT( pev ) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
PUBLIC	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z	; CBaseEntity::FunctionCheck
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::ThinkSet, COMDAT

; 560  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 		m_pfnThink = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1744], ecx

; 562  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnThink)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1744]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 563  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 564  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP	; CBaseEntity::ThinkSet
_TEXT	ENDS
PUBLIC	??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:NEAR ; UTIL_FunctionToName
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ DB 'F'
	DB	'UNCTION NOT IN TABLE!: %s:%s (%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT
_this$ = -4
_pFunction$ = 8
_name$ = 12
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z PROC NEAR	; CBaseEntity::FunctionCheck, COMDAT

; 554  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 		if (pFunction && !UTIL_FunctionToName( GetDataDescMap(), pFunction ) )

	cmp	DWORD PTR _pFunction$[ebp], 0
	je	SHORT $L35044
	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	test	eax, eax
	jne	SHORT $L35044

; 556  : 			ALERT( at_warning, "FUNCTION NOT IN TABLE!: %s:%s (%08lx)\n", GetClassname(), name, (unsigned long)pFunction );

	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L35044:

; 557  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ENDP		; CBaseEntity::FunctionCheck
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
;	COMDAT ?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z PROC NEAR ; CBaseEntity::TouchSet, COMDAT

; 567  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 568  : 		m_pfnTouch = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1748], ecx

; 569  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnTouch)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1748]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 570  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 571  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ENDP ; CBaseEntity::TouchSet
_TEXT	ENDS
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	??_C@_0BG@OBBL@models?1germangibs?4mdl?$AA@	; `string'
PUBLIC	??_C@_0BB@NOLD@models?1hgibs?4mdl?$AA@		; `string'
PUBLIC	__real@4@4005c800000000000000
PUBLIC	?SpawnHeadGib@CGib@@SAXPAUentvars_s@@@Z		; CGib::SpawnHeadGib
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
EXTRN	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAvelocity
;	COMDAT ??_C@_0BG@OBBL@models?1germangibs?4mdl?$AA@
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
??_C@_0BG@OBBL@models?1germangibs?4mdl?$AA@ DB 'models/germangibs.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NOLD@models?1hgibs?4mdl?$AA@
CONST	SEGMENT
??_C@_0BB@NOLD@models?1hgibs?4mdl?$AA@ DB 'models/hgibs.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4@4005c800000000000000
CONST	SEGMENT
__real@4@4005c800000000000000 DD 042c80000r	; 100
CONST	ENDS
;	COMDAT ?SpawnHeadGib@CGib@@SAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pevVictim$ = 8
_pGib$ = -4
_pVictim$38107 = -8
_vecNewVelocity$38108 = -20
_pentPlayer$38110 = -24
_pPlayer$38112 = -28
_vecNewAngularVelocity$38119 = -40
$T39332 = -52
$T39333 = -64
$T39334 = -76
$T39335 = -88
$T39336 = -100
$T39337 = -112
?SpawnHeadGib@CGib@@SAXPAUentvars_s@@@Z PROC NEAR	; CGib::SpawnHeadGib, COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi

; 140  : 	CGib *pGib = GetClassPtr( (CGib *)NULL );

	push	0
	call	?GetClassPtr@@YAPAVCGib@@PAV1@@Z	; GetClassPtr
	add	esp, 4
	mov	DWORD PTR _pGib$[ebp], eax

; 141  : 
; 142  : 	if ( g_Language == LANGUAGE_GERMAN )

	cmp	DWORD PTR ?g_Language@@3HA, 1		; g_Language
	jne	SHORT $L38102

; 144  : 		pGib->Spawn( "models/germangibs.mdl" );// throw one head

	push	OFFSET FLAT:??_C@_0BG@OBBL@models?1germangibs?4mdl?$AA@ ; `string'
	mov	ecx, DWORD PTR _pGib$[ebp]
	call	?Spawn@CGib@@QAEXPBD@Z			; CGib::Spawn

; 145  : 		pGib->pev->body = 0;

	mov	eax, DWORD PTR _pGib$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+276], 0

; 147  : 	else

	jmp	SHORT $L38104
$L38102:

; 149  : 		pGib->Spawn( "models/hgibs.mdl" );// throw one head

	push	OFFSET FLAT:??_C@_0BB@NOLD@models?1hgibs?4mdl?$AA@ ; `string'
	mov	ecx, DWORD PTR _pGib$[ebp]
	call	?Spawn@CGib@@QAEXPBD@Z			; CGib::Spawn

; 150  : 		pGib->pev->body = 0;

	mov	edx, DWORD PTR _pGib$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+276], 0
$L38104:

; 152  : 
; 153  : 	if ( pevVictim )

	cmp	DWORD PTR _pevVictim$[ebp], 0
	je	$L38106

; 155  : 		CBaseEntity *pVictim = CBaseEntity::Instance( pevVictim );

	mov	ecx, DWORD PTR _pevVictim$[ebp]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pVictim$38107[ebp], eax

; 156  : 		Vector vecNewVelocity = pGib->GetAbsVelocity();

	mov	ecx, DWORD PTR _pGib$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vecNewVelocity$38108[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 157  : 
; 158  : 		pGib->SetLocalOrigin( pVictim->EyePosition() );

	lea	edx, DWORD PTR $T39332[ebp]
	push	edx
	mov	eax, DWORD PTR _pVictim$38107[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pVictim$38107[ebp]
	call	DWORD PTR [edx+308]
	push	eax
	mov	ecx, DWORD PTR _pGib$[ebp]
	call	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalOrigin

; 159  : 		
; 160  : 		edict_t *pentPlayer = FIND_CLIENT_IN_PVS( pGib->edict() );

	mov	ecx, DWORD PTR _pGib$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+68
	add	esp, 4
	mov	DWORD PTR _pentPlayer$38110[ebp], eax

; 161  : 		
; 162  : 		if ( RANDOM_LONG ( 0, 100 ) <= 5 && pentPlayer )

	push	100					; 00000064H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	cmp	eax, 5
	jg	SHORT $L38111
	cmp	DWORD PTR _pentPlayer$38110[ebp], 0
	je	SHORT $L38111

; 164  : 			// 5% chance head will be thrown at player's face.
; 165  : 			CBaseEntity *pPlayer = CBaseEntity::Instance( pentPlayer );

	mov	eax, DWORD PTR _pentPlayer$38110[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pPlayer$38112[ebp], eax

; 166  : 
; 167  : 			vecNewVelocity = (pPlayer->EyePosition() - pGib->GetAbsOrigin()).Normalize() * 300;

	push	1133903872				; 43960000H
	lea	ecx, DWORD PTR $T39336[ebp]
	push	ecx
	lea	edx, DWORD PTR $T39335[ebp]
	push	edx
	mov	ecx, DWORD PTR _pGib$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T39334[ebp]
	push	eax
	lea	ecx, DWORD PTR $T39333[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlayer$38112[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pPlayer$38112[ebp]
	call	DWORD PTR [eax+308]
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecNewVelocity$38108[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecNewVelocity$38108[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecNewVelocity$38108[ebp+8], eax

; 168  : 			vecNewVelocity.z += 100;

	fld	DWORD PTR _vecNewVelocity$38108[ebp+8]
	fadd	DWORD PTR __real@4@4005c800000000000000
	fstp	DWORD PTR _vecNewVelocity$38108[ebp+8]

; 170  : 		else

	jmp	SHORT $L38117
$L38111:

; 172  : 			vecNewVelocity = Vector( RANDOM_FLOAT( -100, 100 ), RANDOM_FLOAT( -100, 100 ), RANDOM_FLOAT( 200, 300 ));

	push	1133903872				; 43960000H
	push	1128792064				; 43480000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	1120403456				; 42c80000H
	push	-1027080192				; c2c80000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	1120403456				; 42c80000H
	push	-1027080192				; c2c80000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39337[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecNewVelocity$38108[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecNewVelocity$38108[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecNewVelocity$38108[ebp+8], eax
$L38117:

; 174  : 
; 175  : 		Vector vecNewAngularVelocity = pGib->GetLocalAvelocity();

	mov	ecx, DWORD PTR _pGib$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	push	eax
	lea	ecx, DWORD PTR _vecNewAngularVelocity$38119[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 176  : 		vecNewAngularVelocity.x = RANDOM_FLOAT( 100, 200 );

	push	1128792064				; 43480000H
	push	1120403456				; 42c80000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fstp	DWORD PTR _vecNewAngularVelocity$38119[ebp]

; 177  : 		vecNewAngularVelocity.y = RANDOM_FLOAT( 100, 300 );

	push	1133903872				; 43960000H
	push	1120403456				; 42c80000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fstp	DWORD PTR _vecNewAngularVelocity$38119[ebp+4]

; 178  : 		pGib->SetLocalAvelocity( vecNewAngularVelocity );

	lea	ecx, DWORD PTR _vecNewAngularVelocity$38119[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pGib$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 179  : 
; 180  : 		// copy owner's blood color
; 181  : 		pGib->m_bloodColor = pVictim->BloodColor();

	mov	edx, DWORD PTR _pVictim$38107[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pVictim$38107[ebp]
	call	DWORD PTR [eax+112]
	mov	ecx, DWORD PTR _pGib$[ebp]
	mov	DWORD PTR [ecx+1764], eax

; 182  : 
; 183  : 		pGib->AdjustVelocityBasedOnHealth( pevVictim->health, vecNewVelocity );

	lea	edx, DWORD PTR _vecNewVelocity$38108[ebp]
	push	edx
	mov	eax, DWORD PTR _pevVictim$[ebp]
	fld	DWORD PTR [eax+352]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _pGib$[ebp]
	call	?AdjustVelocityBasedOnHealth@CGib@@QAEXHAAVVector@@@Z ; CGib::AdjustVelocityBasedOnHealth

; 184  : 		pGib->SetAbsVelocity( vecNewVelocity );

	lea	ecx, DWORD PTR _vecNewVelocity$38108[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pGib$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L38106:

; 186  : 
; 187  : 	pGib->LimitVelocity();

	mov	ecx, DWORD PTR _pGib$[ebp]
	call	?LimitVelocity@CGib@@QAEXXZ		; CGib::LimitVelocity

; 188  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SpawnHeadGib@CGib@@SAXPAUentvars_s@@@Z ENDP		; CGib::SpawnHeadGib
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T39342 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39342[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??_C@_0BB@OLK@models?1agibs?4mdl?$AA@		; `string'
PUBLIC	?SpawnRandomGibs@CGib@@SAXPAUentvars_s@@HH@Z	; CGib::SpawnRandomGibs
EXTRN	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsOrigin
;	COMDAT ??_C@_0BB@OLK@models?1agibs?4mdl?$AA@
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
??_C@_0BB@OLK@models?1agibs?4mdl?$AA@ DB 'models/agibs.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ?SpawnRandomGibs@CGib@@SAXPAUentvars_s@@HH@Z
_TEXT	SEGMENT
_pevVictim$ = 8
_cGibs$ = 12
_human$ = 16
_cSplat$ = -4
_pGib$38129 = -8
_vecOrigin$38140 = -20
_vecNewVelocity$38141 = -32
_vecNewAngularVelocity$38143 = -44
$T39347 = -56
?SpawnRandomGibs@CGib@@SAXPAUentvars_s@@HH@Z PROC NEAR	; CGib::SpawnRandomGibs, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 192  : 	int cSplat;
; 193  : 
; 194  : 	for ( cSplat = 0 ; cSplat < cGibs ; cSplat++ )

	mov	DWORD PTR _cSplat$[ebp], 0
	jmp	SHORT $L38126
$L38127:
	mov	eax, DWORD PTR _cSplat$[ebp]
	add	eax, 1
	mov	DWORD PTR _cSplat$[ebp], eax
$L38126:
	mov	ecx, DWORD PTR _cSplat$[ebp]
	cmp	ecx, DWORD PTR _cGibs$[ebp]
	jge	$L38128

; 196  : 		CGib *pGib = GetClassPtr( (CGib *)NULL );

	push	0
	call	?GetClassPtr@@YAPAVCGib@@PAV1@@Z	; GetClassPtr
	add	esp, 4
	mov	DWORD PTR _pGib$38129[ebp], eax

; 197  : 
; 198  : 		if ( g_Language == LANGUAGE_GERMAN )

	cmp	DWORD PTR ?g_Language@@3HA, 1		; g_Language
	jne	SHORT $L38134

; 200  : 			pGib->Spawn( "models/germangibs.mdl" );

	push	OFFSET FLAT:??_C@_0BG@OBBL@models?1germangibs?4mdl?$AA@ ; `string'
	mov	ecx, DWORD PTR _pGib$38129[ebp]
	call	?Spawn@CGib@@QAEXPBD@Z			; CGib::Spawn

; 201  : 			pGib->pev->body = RANDOM_LONG(0,GERMAN_GIB_COUNT-1);

	push	3
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	edx, DWORD PTR _pGib$38129[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+276], eax

; 203  : 		else

	jmp	SHORT $L38137
$L38134:

; 205  : 			if ( human )

	cmp	DWORD PTR _human$[ebp], 0
	je	SHORT $L38136

; 207  : 				// human pieces
; 208  : 				pGib->Spawn( "models/hgibs.mdl" );

	push	OFFSET FLAT:??_C@_0BB@NOLD@models?1hgibs?4mdl?$AA@ ; `string'
	mov	ecx, DWORD PTR _pGib$38129[ebp]
	call	?Spawn@CGib@@QAEXPBD@Z			; CGib::Spawn

; 209  : 				pGib->pev->body = RANDOM_LONG(1,HUMAN_GIB_COUNT-1);// start at one to avoid throwing random amounts of skulls (0th gib)

	push	5
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	edx, DWORD PTR _pGib$38129[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+276], eax

; 211  : 			else

	jmp	SHORT $L38137
$L38136:

; 213  : 				// aliens
; 214  : 				pGib->Spawn( "models/agibs.mdl" );

	push	OFFSET FLAT:??_C@_0BB@OLK@models?1agibs?4mdl?$AA@ ; `string'
	mov	ecx, DWORD PTR _pGib$38129[ebp]
	call	?Spawn@CGib@@QAEXPBD@Z			; CGib::Spawn

; 215  : 				pGib->pev->body = RANDOM_LONG(0,ALIEN_GIB_COUNT-1);

	push	3
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	edx, DWORD PTR _pGib$38129[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+276], eax
$L38137:

; 218  : 
; 219  : 		if ( pevVictim )

	cmp	DWORD PTR _pevVictim$[ebp], 0
	je	$L38139

; 221  : 			Vector vecOrigin;

	lea	ecx, DWORD PTR _vecOrigin$38140[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 222  : 
; 223  : 			// spawn the gib somewhere in the monster's bounding volume
; 224  : 			vecOrigin.x = pevVictim->absmin.x + pevVictim->size.x * (RANDOM_FLOAT( 0 , 1 ) );

	push	1065353216				; 3f800000H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	mov	edx, DWORD PTR _pevVictim$[ebp]
	fmul	DWORD PTR [edx+244]
	mov	eax, DWORD PTR _pevVictim$[ebp]
	fadd	DWORD PTR [eax+196]
	fstp	DWORD PTR _vecOrigin$38140[ebp]

; 225  : 			vecOrigin.y = pevVictim->absmin.y + pevVictim->size.y * (RANDOM_FLOAT( 0 , 1 ) );

	push	1065353216				; 3f800000H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	mov	ecx, DWORD PTR _pevVictim$[ebp]
	fmul	DWORD PTR [ecx+248]
	mov	edx, DWORD PTR _pevVictim$[ebp]
	fadd	DWORD PTR [edx+200]
	fstp	DWORD PTR _vecOrigin$38140[ebp+4]

; 226  : 			vecOrigin.z = pevVictim->absmin.z + pevVictim->size.z * (RANDOM_FLOAT( 0 , 1 ) ) + 1;	// absmin.z is in the floor because the engine subtracts 1 to enlarge the box

	push	1065353216				; 3f800000H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	mov	eax, DWORD PTR _pevVictim$[ebp]
	fmul	DWORD PTR [eax+252]
	mov	ecx, DWORD PTR _pevVictim$[ebp]
	fadd	DWORD PTR [ecx+204]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _vecOrigin$38140[ebp+8]

; 227  : 			pGib->SetAbsOrigin( vecOrigin );

	lea	edx, DWORD PTR _vecOrigin$38140[ebp]
	push	edx
	mov	ecx, DWORD PTR _pGib$38129[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 228  : 
; 229  : 			// make the gib fly away from the attack vector
; 230  : 			Vector vecNewVelocity = g_vecAttackDir * -1;

	push	-1082130432				; bf800000H
	lea	eax, DWORD PTR $T39347[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?g_vecAttackDir@@3VVector@@A
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _vecNewVelocity$38141[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 231  : 
; 232  : 			// mix in some noise
; 233  : 			vecNewVelocity.x += RANDOM_FLOAT ( -0.25, 0.25 );

	push	1048576000				; 3e800000H
	push	-1098907648				; be800000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecNewVelocity$38141[ebp]
	fstp	DWORD PTR _vecNewVelocity$38141[ebp]

; 234  : 			vecNewVelocity.y += RANDOM_FLOAT ( -0.25, 0.25 );

	push	1048576000				; 3e800000H
	push	-1098907648				; be800000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecNewVelocity$38141[ebp+4]
	fstp	DWORD PTR _vecNewVelocity$38141[ebp+4]

; 235  : 			vecNewVelocity.z += RANDOM_FLOAT ( -0.25, 0.25 );

	push	1048576000				; 3e800000H
	push	-1098907648				; be800000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecNewVelocity$38141[ebp+8]
	fstp	DWORD PTR _vecNewVelocity$38141[ebp+8]

; 236  : 
; 237  : 			vecNewVelocity *= RANDOM_FLOAT ( 300, 400 );

	push	1137180672				; 43c80000H
	push	1133903872				; 43960000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _vecNewVelocity$38141[ebp]
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=

; 238  : 			pGib->SetAbsVelocity( vecNewVelocity );

	lea	ecx, DWORD PTR _vecNewVelocity$38141[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pGib$38129[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 239  : 
; 240  : 			Vector vecNewAngularVelocity = pGib->GetLocalAvelocity();

	mov	ecx, DWORD PTR _pGib$38129[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	push	eax
	lea	ecx, DWORD PTR _vecNewAngularVelocity$38143[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 241  : 			vecNewAngularVelocity.x = RANDOM_FLOAT( 100, 200 );

	push	1128792064				; 43480000H
	push	1120403456				; 42c80000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fstp	DWORD PTR _vecNewAngularVelocity$38143[ebp]

; 242  : 			vecNewAngularVelocity.y = RANDOM_FLOAT( 100, 300 );

	push	1133903872				; 43960000H
	push	1120403456				; 42c80000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fstp	DWORD PTR _vecNewAngularVelocity$38143[ebp+4]

; 243  : 			pGib->SetLocalAvelocity( vecNewAngularVelocity );

	lea	edx, DWORD PTR _vecNewAngularVelocity$38143[ebp]
	push	edx
	mov	ecx, DWORD PTR _pGib$38129[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 244  :  
; 245  : 			// copy owner's blood color
; 246  : 			pGib->m_bloodColor = (CBaseEntity::Instance(pevVictim))->BloodColor();

	mov	eax, DWORD PTR _pevVictim$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR -60+[ebp], eax
	mov	ecx, DWORD PTR -60+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -60+[ebp]
	call	DWORD PTR [edx+112]
	mov	ecx, DWORD PTR _pGib$38129[ebp]
	mov	DWORD PTR [ecx+1764], eax

; 247  : 
; 248  : 			pGib->AdjustVelocityBasedOnHealth( pevVictim->health, vecNewVelocity );			

	lea	edx, DWORD PTR _vecNewVelocity$38141[ebp]
	push	edx
	mov	eax, DWORD PTR _pevVictim$[ebp]
	fld	DWORD PTR [eax+352]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _pGib$38129[ebp]
	call	?AdjustVelocityBasedOnHealth@CGib@@QAEXHAAVVector@@@Z ; CGib::AdjustVelocityBasedOnHealth

; 249  : 
; 250  : 			pGib->pev->solid = SOLID_BBOX;

	mov	ecx, DWORD PTR _pGib$38129[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 2

; 251  : 			UTIL_SetSize( pGib->pev, g_vecZero, g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _pGib$38129[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH
$L38139:

; 253  : 		pGib->LimitVelocity();

	mov	ecx, DWORD PTR _pGib$38129[ebp]
	call	?LimitVelocity@CGib@@QAEXXZ		; CGib::LimitVelocity

; 254  : 	}

	jmp	$L38127
$L38128:

; 255  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SpawnRandomGibs@CGib@@SAXPAUentvars_s@@HH@Z ENDP	; CGib::SpawnRandomGibs
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
PUBLIC	?HasHumanGibs@CBaseMonster@@UAEHXZ		; CBaseMonster::HasHumanGibs
;	COMDAT ?HasHumanGibs@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
_myClass$ = -8
?HasHumanGibs@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::HasHumanGibs, COMDAT

; 259  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 260  : 	int myClass = Classify();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+68]
	mov	DWORD PTR _myClass$[ebp], eax

; 263  : 		 myClass == CLASS_PLAYER_ALLY	||
; 264  : 		 myClass == CLASS_HUMAN_PASSIVE  ||
; 265  : 		 myClass == CLASS_PLAYER )

	cmp	DWORD PTR _myClass$[ebp], 4
	je	SHORT $L38150
	cmp	DWORD PTR _myClass$[ebp], 11		; 0000000bH
	je	SHORT $L38150
	cmp	DWORD PTR _myClass$[ebp], 3
	je	SHORT $L38150
	cmp	DWORD PTR _myClass$[ebp], 2
	jne	SHORT $L38149
$L38150:

; 266  : 
; 267  : 		 return TRUE;

	mov	eax, 1
	jmp	SHORT $L38147
$L38149:

; 268  : 
; 269  : 	return FALSE;

	xor	eax, eax
$L38147:

; 270  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HasHumanGibs@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::HasHumanGibs
_TEXT	ENDS
PUBLIC	?HasAlienGibs@CBaseMonster@@UAEHXZ		; CBaseMonster::HasAlienGibs
;	COMDAT ?HasAlienGibs@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
_myClass$ = -8
?HasAlienGibs@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::HasAlienGibs, COMDAT

; 274  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 275  : 	int myClass = Classify();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+68]
	mov	DWORD PTR _myClass$[ebp], eax

; 278  : 		 myClass == CLASS_ALIEN_MONSTER	||
; 279  : 		 myClass == CLASS_ALIEN_PASSIVE  ||
; 280  : 		 myClass == CLASS_INSECT  ||
; 281  : 		 myClass == CLASS_ALIEN_PREDATOR  ||
; 282  : 		 myClass == CLASS_ALIEN_PREY )

	cmp	DWORD PTR _myClass$[ebp], 5
	je	SHORT $L38157
	cmp	DWORD PTR _myClass$[ebp], 7
	je	SHORT $L38157
	cmp	DWORD PTR _myClass$[ebp], 6
	je	SHORT $L38157
	cmp	DWORD PTR _myClass$[ebp], 10		; 0000000aH
	je	SHORT $L38157
	cmp	DWORD PTR _myClass$[ebp], 9
	je	SHORT $L38157
	cmp	DWORD PTR _myClass$[ebp], 8
	jne	SHORT $L38156
$L38157:

; 283  : 
; 284  : 		 return TRUE;

	mov	eax, 1
	jmp	SHORT $L38154
$L38156:

; 285  : 
; 286  : 	return FALSE;

	xor	eax, eax
$L38154:

; 287  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HasAlienGibs@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::HasAlienGibs
_TEXT	ENDS
PUBLIC	?FadeMonster@CBaseMonster@@UAEXXZ		; CBaseMonster::FadeMonster
PUBLIC	?SUB_StartFadeOut@CBaseEntity@@QAEXXZ		; CBaseEntity::SUB_StartFadeOut
PUBLIC	?StopAnimation@CBaseMonster@@QAEXXZ		; CBaseMonster::StopAnimation
EXTRN	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalVelocity
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
;	COMDAT ?FadeMonster@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?FadeMonster@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::FadeMonster, COMDAT

; 291  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 292  : 	StopAnimation();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopAnimation@CBaseMonster@@QAEXXZ	; CBaseMonster::StopAnimation

; 293  : 	SetLocalVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 294  : 	pev->movetype = MOVETYPE_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 0

; 295  : 	SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 296  : 	pev->animtime = gpGlobals->time;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+308], edx

; 297  : 	pev->effects |= EF_NOINTERP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx

; 298  : 	SUB_StartFadeOut();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_StartFadeOut@CBaseEntity@@QAEXXZ	; CBaseEntity::SUB_StartFadeOut

; 299  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FadeMonster@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::FadeMonster
_TEXT	ENDS
;	COMDAT ?StopAnimation@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopAnimation@CBaseMonster@@QAEXXZ PROC NEAR		; CBaseMonster::StopAnimation, COMDAT

; 179  : 		inline void StopAnimation( void ) { pev->framerate = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+312], 0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopAnimation@CBaseMonster@@QAEXXZ ENDP		; CBaseMonster::StopAnimation
_TEXT	ENDS
PUBLIC	?GibMonster@CBaseMonster@@UAEXXZ		; CBaseMonster::GibMonster
PUBLIC	??_C@_0L@KHDH@SUB_Remove?$AA@			; `string'
PUBLIC	??_C@_0BF@CHLM@common?1bodysplat?4wav?$AA@	; `string'
PUBLIC	??_C@_0P@JDJM@violence_hgibs?$AA@		; `string'
PUBLIC	??_C@_0P@DCJD@violence_agibs?$AA@		; `string'
PUBLIC	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z		; EMIT_SOUND
PUBLIC	??0gametrace_s@@QAE@XZ				; gametrace_s::gametrace_s
EXTRN	?SUB_Remove@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::SUB_Remove
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
??_C@_0L@KHDH@SUB_Remove?$AA@ DB 'SUB_Remove', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CHLM@common?1bodysplat?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@CHLM@common?1bodysplat?4wav?$AA@ DB 'common/bodysplat.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JDJM@violence_hgibs?$AA@
CONST	SEGMENT
??_C@_0P@JDJM@violence_hgibs?$AA@ DB 'violence_hgibs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DCJD@violence_agibs?$AA@
CONST	SEGMENT
??_C@_0P@DCJD@violence_agibs?$AA@ DB 'violence_agibs', 00H ; `string'
CONST	ENDS
;	COMDAT ?GibMonster@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_tr$ = -60
_gibbed$ = -64
?GibMonster@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::GibMonster, COMDAT

; 306  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 307  : 	TraceResult	tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 308  : 	BOOL		gibbed = FALSE;

	mov	DWORD PTR _gibbed$[ebp], 0

; 309  : 
; 310  : 	EMIT_SOUND(ENT(pev), CHAN_WEAPON, "common/bodysplat.wav", 1, ATTN_NORM);		

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BF@CHLM@common?1bodysplat?4wav?$AA@ ; `string'
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 311  : 
; 312  : 	// only humans throw skulls !!!UNDONE - eventually monsters will have their own sets of gibs
; 313  : 	if ( HasHumanGibs() )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+576]
	test	eax, eax
	je	SHORT $L38170

; 315  : 		if ( CVAR_GET_FLOAT("violence_hgibs") != 0 )	// Only the player will ever get here

	push	OFFSET FLAT:??_C@_0P@JDJM@violence_hgibs?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38171

; 317  : 			CGib::SpawnHeadGib( pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?SpawnHeadGib@CGib@@SAXPAUentvars_s@@@Z	; CGib::SpawnHeadGib
	add	esp, 4

; 318  : 			CGib::SpawnRandomGibs( pev, 4, 1 );	// throw some human gibs.

	push	1
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?SpawnRandomGibs@CGib@@SAXPAUentvars_s@@HH@Z ; CGib::SpawnRandomGibs
	add	esp, 12					; 0000000cH
$L38171:

; 320  : 		gibbed = TRUE;

	mov	DWORD PTR _gibbed$[ebp], 1

; 322  : 	else if ( HasAlienGibs() )

	jmp	SHORT $L38174
$L38170:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+580]
	test	eax, eax
	je	SHORT $L38174

; 324  : 		if ( CVAR_GET_FLOAT("violence_agibs") != 0 )	// Should never get here, but someone might call it directly

	push	OFFSET FLAT:??_C@_0P@DCJD@violence_agibs?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38175

; 326  : 			CGib::SpawnRandomGibs( pev, 4, 0 );	// Throw alien gibs

	push	0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?SpawnRandomGibs@CGib@@SAXPAUentvars_s@@HH@Z ; CGib::SpawnRandomGibs
	add	esp, 12					; 0000000cH
$L38175:

; 328  : 		gibbed = TRUE;

	mov	DWORD PTR _gibbed$[ebp], 1
$L38174:

; 330  : 
; 331  : 	if ( !IsPlayer() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L38181

; 333  : 		if ( gibbed )

	cmp	DWORD PTR _gibbed$[ebp], 0
	je	SHORT $L38178

; 335  : 			// don't remove players!
; 336  : 			SetThink ( SUB_Remove );

	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 337  : 			pev->nextthink = gpGlobals->time;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+260], eax

; 339  : 		else

	jmp	SHORT $L38181
$L38178:

; 341  : 			FadeMonster();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+584]
$L38181:

; 344  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GibMonster@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::GibMonster
_TEXT	ENDS
EXTRN	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z:NEAR	; EMIT_SOUND_DYN
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
_volume$ = 20
_attenuation$ = 24
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z PROC NEAR		; EMIT_SOUND, COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 610  : 	EMIT_SOUND_DYN( entity, channel, sample, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 611  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z ENDP		; EMIT_SOUND
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0gametrace_s@@QAE@XZ PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0gametrace_s@@QAE@XZ ENDP				; gametrace_s::gametrace_s
_TEXT	ENDS
PUBLIC	?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ ; CBaseMonster::GetDeathActivity
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	?DotProduct@@YAMABVVector@@0@Z			; DotProduct
PUBLIC	__real@8@3ffd9999999999999800
PUBLIC	__real@8@bffd9999999999999800
PUBLIC	__real@8@3fff8000000000000000
EXTRN	?LookupActivity@CBaseAnimating@@QAEHH@Z:NEAR	; CBaseAnimating::LookupActivity
EXTRN	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsAngles
EXTRN	?UTIL_MakeVectors@@YAXABVVector@@@Z:NEAR	; UTIL_MakeVectors
EXTRN	?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceHull
;	COMDAT __real@8@3ffd9999999999999800
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
__real@8@3ffd9999999999999800 DQ 03fd3333333333333r ; 0.3
CONST	ENDS
;	COMDAT __real@8@bffd9999999999999800
CONST	SEGMENT
__real@8@bffd9999999999999800 DQ 0bfd3333333333333r ; -0.3
CONST	ENDS
;	COMDAT __real@8@3fff8000000000000000
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT ?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
_TEXT	SEGMENT
_this$ = -4
_deathActivity$ = -8
_fTriedDirection$ = -12
_flDot$ = -16
_tr$ = -72
_vecSrc$ = -84
$T39366 = -96
$T39367 = -108
$T39368 = -120
$T39369 = -132
$T39370 = -144
$T39371 = -156
?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ PROC NEAR ; CBaseMonster::GetDeathActivity, COMDAT

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 352  : 	Activity	deathActivity;
; 353  : 	BOOL		fTriedDirection;
; 354  : 	float		flDot;
; 355  : 	TraceResult	tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 356  : 	Vector		vecSrc;

	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 357  : 
; 358  : 	if ( pev->deadflag != DEAD_NO )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	je	SHORT $L38193

; 360  : 		// don't run this while dying.
; 361  : 		return m_IdealActivity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2072]
	jmp	$L38187
$L38193:

; 363  : 
; 364  : 	vecSrc = Center();

	lea	eax, DWORD PTR $T39366[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecSrc$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecSrc$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecSrc$[ebp+8], eax

; 365  : 
; 366  : 	fTriedDirection = FALSE;

	mov	DWORD PTR _fTriedDirection$[ebp], 0

; 367  : 	deathActivity = ACT_DIESIMPLE;// in case we can't find any special deaths to do.

	mov	DWORD PTR _deathActivity$[ebp], 36	; 00000024H

; 368  : 
; 369  : 	UTIL_MakeVectors ( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 370  : 	flDot = DotProduct ( gpGlobals->v_forward, g_vecAttackDir * -1 );

	push	-1082130432				; bf800000H
	lea	ecx, DWORD PTR $T39367[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?g_vecAttackDir@@3VVector@@A
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	edx, 40					; 00000028H
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _flDot$[ebp]

; 373  : 	{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2076]
	mov	DWORD PTR -160+[ebp], ecx
	cmp	DWORD PTR -160+[ebp], 0
	je	SHORT $L38202
	cmp	DWORD PTR -160+[ebp], 1
	je	SHORT $L38200
	cmp	DWORD PTR -160+[ebp], 3
	je	SHORT $L38201
	jmp	SHORT $L38206
$L38200:

; 374  : 		// try to pick a region-specific death.
; 375  : 	case HITGROUP_HEAD:
; 376  : 		deathActivity = ACT_DIE_HEADSHOT;

	mov	DWORD PTR _deathActivity$[ebp], 66	; 00000042H

; 377  : 		break;

	jmp	SHORT $L38197
$L38201:

; 378  : 
; 379  : 	case HITGROUP_STOMACH:
; 380  : 		deathActivity = ACT_DIE_GUTSHOT;

	mov	DWORD PTR _deathActivity$[ebp], 68	; 00000044H

; 381  : 		break;

	jmp	SHORT $L38197
$L38202:

; 382  : 
; 383  : 	case HITGROUP_GENERIC:
; 384  : 		// try to pick a death based on attack direction
; 385  : 		fTriedDirection = TRUE;

	mov	DWORD PTR _fTriedDirection$[ebp], 1

; 386  : 
; 387  : 		if ( flDot > 0.3 )

	fld	DWORD PTR _flDot$[ebp]
	fcomp	QWORD PTR __real@8@3ffd9999999999999800
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38203

; 389  : 			deathActivity = ACT_DIEFORWARD;

	mov	DWORD PTR _deathActivity$[ebp], 38	; 00000026H

; 391  : 		else if ( flDot <= -0.3 )

	jmp	SHORT $L38205
$L38203:
	fld	DWORD PTR _flDot$[ebp]
	fcomp	QWORD PTR __real@8@bffd9999999999999800
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38205

; 393  : 			deathActivity = ACT_DIEBACKWARD;

	mov	DWORD PTR _deathActivity$[ebp], 37	; 00000025H
$L38205:

; 395  : 		break;

	jmp	SHORT $L38197
$L38206:

; 396  : 
; 397  : 	default:
; 398  : 		// try to pick a death based on attack direction
; 399  : 		fTriedDirection = TRUE;

	mov	DWORD PTR _fTriedDirection$[ebp], 1

; 400  : 
; 401  : 		if ( flDot > 0.3 )

	fld	DWORD PTR _flDot$[ebp]
	fcomp	QWORD PTR __real@8@3ffd9999999999999800
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38207

; 403  : 			deathActivity = ACT_DIEFORWARD;

	mov	DWORD PTR _deathActivity$[ebp], 38	; 00000026H

; 405  : 		else if ( flDot <= -0.3 )

	jmp	SHORT $L38209
$L38207:
	fld	DWORD PTR _flDot$[ebp]
	fcomp	QWORD PTR __real@8@bffd9999999999999800
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38209

; 407  : 			deathActivity = ACT_DIEBACKWARD;

	mov	DWORD PTR _deathActivity$[ebp], 37	; 00000025H
$L38209:
$L38197:

; 411  : 
; 412  : 
; 413  : 	// can we perform the prescribed death?
; 414  : 	if ( LookupActivity ( deathActivity ) == ACTIVITY_NOT_AVAILABLE )

	mov	edx, DWORD PTR _deathActivity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	cmp	eax, -1
	jne	SHORT $L38215

; 416  : 		// no! did we fail to perform a directional death? 
; 417  : 		if ( fTriedDirection )

	cmp	DWORD PTR _fTriedDirection$[ebp], 0
	je	SHORT $L38211

; 419  : 			// if yes, we're out of options. Go simple.
; 420  : 			deathActivity = ACT_DIESIMPLE;

	mov	DWORD PTR _deathActivity$[ebp], 36	; 00000024H

; 422  : 		else

	jmp	SHORT $L38215
$L38211:

; 424  : 			// cannot perform the ideal region-specific death, so try a direction.
; 425  : 			if ( flDot > 0.3 )

	fld	DWORD PTR _flDot$[ebp]
	fcomp	QWORD PTR __real@8@3ffd9999999999999800
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38213

; 427  : 				deathActivity = ACT_DIEFORWARD;

	mov	DWORD PTR _deathActivity$[ebp], 38	; 00000026H

; 429  : 			else if ( flDot <= -0.3 )

	jmp	SHORT $L38215
$L38213:
	fld	DWORD PTR _flDot$[ebp]
	fcomp	QWORD PTR __real@8@bffd9999999999999800
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38215

; 431  : 				deathActivity = ACT_DIEBACKWARD;

	mov	DWORD PTR _deathActivity$[ebp], 37	; 00000025H
$L38215:

; 435  : 
; 436  : 	if ( LookupActivity ( deathActivity ) == ACTIVITY_NOT_AVAILABLE )

	mov	eax, DWORD PTR _deathActivity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	cmp	eax, -1
	jne	SHORT $L38216

; 438  : 		// if we're still invalid, simple is our only option.
; 439  : 		deathActivity = ACT_DIESIMPLE;

	mov	DWORD PTR _deathActivity$[ebp], 36	; 00000024H
$L38216:

; 441  : 
; 442  : 	if ( deathActivity == ACT_DIEFORWARD )

	cmp	DWORD PTR _deathActivity$[ebp], 38	; 00000026H
	jne	SHORT $L38220

; 444  : 			// make sure there's room to fall forward
; 445  : 			UTIL_TraceHull ( vecSrc, vecSrc + gpGlobals->v_forward * 64, dont_ignore_monsters, head_hull, edict(), &tr );

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	3
	push	0
	push	1115684864				; 42800000H
	lea	edx, DWORD PTR $T39368[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T39369[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	call	?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceHull
	add	esp, 24					; 00000018H

; 446  : 
; 447  : 			if ( tr.flFraction != 1.0 )

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38220

; 449  : 				deathActivity = ACT_DIESIMPLE;

	mov	DWORD PTR _deathActivity$[ebp], 36	; 00000024H
$L38220:

; 452  : 
; 453  : 	if ( deathActivity == ACT_DIEBACKWARD )

	cmp	DWORD PTR _deathActivity$[ebp], 37	; 00000025H
	jne	SHORT $L38224

; 455  : 			// make sure there's room to fall backward
; 456  : 			UTIL_TraceHull ( vecSrc, vecSrc - gpGlobals->v_forward * 64, dont_ignore_monsters, head_hull, edict(), &tr );

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	3
	push	0
	push	1115684864				; 42800000H
	lea	eax, DWORD PTR $T39370[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T39371[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	edx, DWORD PTR _vecSrc$[ebp]
	push	edx
	call	?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceHull
	add	esp, 24					; 00000018H

; 457  : 
; 458  : 			if ( tr.flFraction != 1.0 )

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38224

; 460  : 				deathActivity = ACT_DIESIMPLE;

	mov	DWORD PTR _deathActivity$[ebp], 36	; 00000024H
$L38224:

; 463  : 
; 464  : 	return deathActivity;

	mov	eax, DWORD PTR _deathActivity$[ebp]
$L38187:

; 465  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ ENDP ; CBaseMonster::GetDeathActivity
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T39380 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39380[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProduct@@YAMABVVector@@0@Z PROC NEAR		; DotProduct, COMDAT

; 289  : inline float DotProduct(const Vector& a, const Vector& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector@@0@Z ENDP			; DotProduct
_TEXT	ENDS
PUBLIC	?GetSmallFlinchActivity@CBaseMonster@@QAE?AW4Activity@@XZ ; CBaseMonster::GetSmallFlinchActivity
;	COMDAT ?GetSmallFlinchActivity@CBaseMonster@@QAE?AW4Activity@@XZ
_TEXT	SEGMENT
_this$ = -4
_flinchActivity$ = -8
_fTriedDirection$ = -12
_flDot$ = -16
$T39385 = -28
?GetSmallFlinchActivity@CBaseMonster@@QAE?AW4Activity@@XZ PROC NEAR ; CBaseMonster::GetSmallFlinchActivity, COMDAT

; 472  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 473  : 	Activity	flinchActivity;
; 474  : 	BOOL		fTriedDirection;
; 475  : 	float		flDot;
; 476  : 
; 477  : 	fTriedDirection = FALSE;

	mov	DWORD PTR _fTriedDirection$[ebp], 0

; 478  : 	UTIL_MakeVectors ( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 479  : 	flDot = DotProduct ( gpGlobals->v_forward, g_vecAttackDir * -1 );

	push	-1082130432				; bf800000H
	lea	eax, DWORD PTR $T39385[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?g_vecAttackDir@@3VVector@@A
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _flDot$[ebp]

; 482  : 	{

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2076]
	mov	DWORD PTR -32+[ebp], eax
	mov	ecx, DWORD PTR -32+[ebp]
	sub	ecx, 1
	mov	DWORD PTR -32+[ebp], ecx
	cmp	DWORD PTR -32+[ebp], 6
	ja	SHORT $L38243
	mov	edx, DWORD PTR -32+[ebp]
	jmp	DWORD PTR $L39386[edx*4]
$L38237:

; 483  : 		// pick a region-specific flinch
; 484  : 	case HITGROUP_HEAD:
; 485  : 		flinchActivity = ACT_FLINCH_HEAD;

	mov	DWORD PTR _flinchActivity$[ebp], 70	; 00000046H

; 486  : 		break;

	jmp	SHORT $L38234
$L38238:

; 487  : 	case HITGROUP_STOMACH:
; 488  : 		flinchActivity = ACT_FLINCH_STOMACH;

	mov	DWORD PTR _flinchActivity$[ebp], 72	; 00000048H

; 489  : 		break;

	jmp	SHORT $L38234
$L38239:

; 490  : 	case HITGROUP_LEFTARM:
; 491  : 		flinchActivity = ACT_FLINCH_LEFTARM;

	mov	DWORD PTR _flinchActivity$[ebp], 73	; 00000049H

; 492  : 		break;

	jmp	SHORT $L38234
$L38240:

; 493  : 	case HITGROUP_RIGHTARM:
; 494  : 		flinchActivity = ACT_FLINCH_RIGHTARM;

	mov	DWORD PTR _flinchActivity$[ebp], 74	; 0000004aH

; 495  : 		break;

	jmp	SHORT $L38234
$L38241:

; 496  : 	case HITGROUP_LEFTLEG:
; 497  : 		flinchActivity = ACT_FLINCH_LEFTLEG;

	mov	DWORD PTR _flinchActivity$[ebp], 75	; 0000004bH

; 498  : 		break;

	jmp	SHORT $L38234
$L38242:

; 499  : 	case HITGROUP_RIGHTLEG:
; 500  : 		flinchActivity = ACT_FLINCH_RIGHTLEG;

	mov	DWORD PTR _flinchActivity$[ebp], 76	; 0000004cH

; 501  : 		break;

	jmp	SHORT $L38234
$L38243:

; 502  : 	case HITGROUP_GENERIC:
; 503  : 	default:
; 504  : 		// just get a generic flinch.
; 505  : 		flinchActivity = ACT_SMALL_FLINCH;

	mov	DWORD PTR _flinchActivity$[ebp], 26	; 0000001aH
$L38234:

; 508  : 
; 509  : 
; 510  : 	// do we have a sequence for the ideal activity?
; 511  : 	if ( LookupActivity ( flinchActivity ) == ACTIVITY_NOT_AVAILABLE )

	mov	eax, DWORD PTR _flinchActivity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	cmp	eax, -1
	jne	SHORT $L38244

; 513  : 		flinchActivity = ACT_SMALL_FLINCH;

	mov	DWORD PTR _flinchActivity$[ebp], 26	; 0000001aH
$L38244:

; 515  : 
; 516  : 	return flinchActivity;

	mov	eax, DWORD PTR _flinchActivity$[ebp]

; 517  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L39386:
	DD	$L38237
	DD	$L38243
	DD	$L38238
	DD	$L38239
	DD	$L38240
	DD	$L38241
	DD	$L38242
?GetSmallFlinchActivity@CBaseMonster@@QAE?AW4Activity@@XZ ENDP ; CBaseMonster::GetSmallFlinchActivity
_TEXT	ENDS
PUBLIC	__real@4@40008000000000000000
PUBLIC	?BecomeDead@CBaseMonster@@UAEXXZ		; CBaseMonster::BecomeDead
;	COMDAT __real@4@40008000000000000000
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
__real@4@40008000000000000000 DD 040000000r	; 2
CONST	ENDS
;	COMDAT ?BecomeDead@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?BecomeDead@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::BecomeDead, COMDAT

; 521  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 	pev->takedamage = DAMAGE_YES;// don't let autoaim aim at corpses.

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+364], 1065353216		; 3f800000H

; 523  : 	
; 524  : 	// give the corpse half of the monster's original maximum health. 
; 525  : 	pev->health = pev->max_health / 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+432]
	fdiv	DWORD PTR __real@4@40008000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+352]

; 526  : 	pev->max_health = 5; // max_health now becomes a counter for how many blood decals the corpse can place.

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+432], 1084227584		; 40a00000H

; 527  : 
; 528  : 	// make the corpse fly away from the attack vector
; 529  : 	pev->movetype = MOVETYPE_TOSS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 6

; 530  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BecomeDead@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::BecomeDead
_TEXT	ENDS
PUBLIC	?ShouldGibMonster@CBaseMonster@@QAEHH@Z		; CBaseMonster::ShouldGibMonster
PUBLIC	__real@4@c003f000000000000000
;	COMDAT __real@4@c003f000000000000000
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
__real@4@c003f000000000000000 DD 0c1f00000r	; -30
CONST	ENDS
;	COMDAT ?ShouldGibMonster@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT
_iGib$ = 8
_this$ = -4
?ShouldGibMonster@CBaseMonster@@QAEHH@Z PROC NEAR	; CBaseMonster::ShouldGibMonster, COMDAT

; 534  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 535  : 	if ( ( iGib == GIB_NORMAL && pev->health < GIB_HEALTH_VALUE ) || ( iGib == GIB_ALWAYS ) )

	cmp	DWORD PTR _iGib$[ebp], 0
	jne	SHORT $L38255
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+352]
	fcomp	DWORD PTR __real@4@c003f000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L38254
$L38255:
	cmp	DWORD PTR _iGib$[ebp], 2
	jne	SHORT $L38253
$L38254:

; 536  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L38252
$L38253:

; 537  : 	
; 538  : 	return FALSE;

	xor	eax, eax
$L38252:

; 539  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ShouldGibMonster@CBaseMonster@@QAEHH@Z ENDP		; CBaseMonster::ShouldGibMonster
_TEXT	ENDS
PUBLIC	?CallGibMonster@CBaseMonster@@QAEXXZ		; CBaseMonster::CallGibMonster
PUBLIC	__real@4@c005c600000000000000
EXTRN	?FCheckAITrigger@CBaseMonster@@QAEHXZ:NEAR	; CBaseMonster::FCheckAITrigger
EXTRN	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_Remove
;	COMDAT __real@4@c005c600000000000000
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
__real@4@c005c600000000000000 DD 0c2c60000r	; -99
CONST	ENDS
;	COMDAT ?CallGibMonster@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_fade$ = -8
?CallGibMonster@CBaseMonster@@QAEXXZ PROC NEAR		; CBaseMonster::CallGibMonster, COMDAT

; 543  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 544  : 	BOOL fade = FALSE;

	mov	DWORD PTR _fade$[ebp], 0

; 545  : 
; 546  : 	if ( HasHumanGibs() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+576]
	test	eax, eax
	je	SHORT $L38261

; 548  : 		if ( CVAR_GET_FLOAT("violence_hgibs") == 0 )

	push	OFFSET FLAT:??_C@_0P@JDJM@violence_hgibs?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38262

; 549  : 			fade = TRUE;

	mov	DWORD PTR _fade$[ebp], 1
$L38262:

; 551  : 	else if ( HasAlienGibs() )

	jmp	SHORT $L38265
$L38261:
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+580]
	test	eax, eax
	je	SHORT $L38265

; 553  : 		if ( CVAR_GET_FLOAT("violence_agibs") == 0 )

	push	OFFSET FLAT:??_C@_0P@DCJD@violence_agibs?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38265

; 554  : 			fade = TRUE;

	mov	DWORD PTR _fade$[ebp], 1
$L38265:

; 556  : 
; 557  : 	pev->takedamage = DAMAGE_NO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+364], 0

; 558  : 	pev->solid = SOLID_NOT;// do something with the body. while monster blows up

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 0

; 559  : 
; 560  : 	if ( fade )

	cmp	DWORD PTR _fade$[ebp], 0
	je	SHORT $L38266

; 562  : 		FadeMonster();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+584]

; 564  : 	else

	jmp	SHORT $L38267
$L38266:

; 566  : 		pev->effects |= EF_NODRAW; // make the model invisible.

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx

; 567  : 		GibMonster();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+572]
$L38267:

; 569  : 
; 570  : 	pev->deadflag = DEAD_DEAD;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+368], 2

; 571  : 	FCheckAITrigger();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FCheckAITrigger@CBaseMonster@@QAEHXZ	; CBaseMonster::FCheckAITrigger

; 572  : 
; 573  : 	// don't let the status bar glitch for players.with <0 health.
; 574  : 	if (pev->health < -99)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+352]
	fcomp	DWORD PTR __real@4@c005c600000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38268

; 576  : 		pev->health = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+352], 0
$L38268:

; 578  : 	
; 579  : 	if ( ShouldFadeOnDeath() && !fade )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+352]
	test	eax, eax
	je	SHORT $L38269
	cmp	DWORD PTR _fade$[ebp], 0
	jne	SHORT $L38269

; 580  : 		UTIL_Remove(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4
$L38269:

; 581  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CallGibMonster@CBaseMonster@@QAEXXZ ENDP		; CBaseMonster::CallGibMonster
_TEXT	ENDS
PUBLIC	?DamageDecal@CBaseMonster@@UAEHH@Z		; CBaseMonster::DamageDecal
;	COMDAT ?DamageDecal@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT
_bitsDamageType$ = 8
_this$ = -4
?DamageDecal@CBaseMonster@@UAEHH@Z PROC NEAR		; CBaseMonster::DamageDecal, COMDAT

; 584  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 585  : 	if( bitsDamageType & ( DMG_BULLET|DMG_CLUB ))

	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	and	eax, 130				; 00000082H
	test	eax, eax
	je	SHORT $L38279

; 587  : 		if( BloodColor() == BLOOD_COLOR_RED )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+112]
	cmp	eax, 247				; 000000f7H
	jne	SHORT $L38276

; 588  : 			return (DECAL_BLOOD1 + RANDOM_LONG( 0, 5 ));

	push	5
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 13					; 0000000dH
	jmp	SHORT $L38273
$L38276:

; 589  : 		else if( BloodColor() == BLOOD_COLOR_YELLOW )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+112]
	cmp	eax, 195				; 000000c3H
	jne	SHORT $L38279

; 590  : 			return (DECAL_YBLOOD1 + RANDOM_LONG( 0, 5 ));

	push	5
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 19					; 00000013H
	jmp	SHORT $L38273
$L38279:

; 592  : 
; 593  : 	// Assume no blood is vehicles or furniture
; 594  : 	return DECAL_GUNSHOT1 + RANDOM_LONG( 0, DECAL_GUNSHOT5 );

	push	4
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
$L38273:

; 595  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DamageDecal@CBaseMonster@@UAEHH@Z ENDP			; CBaseMonster::DamageDecal
_TEXT	ENDS
PUBLIC	?SetConditions@CBaseMonster@@QAEXH@Z		; CBaseMonster::SetConditions
PUBLIC	?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z	; CBaseMonster::Killed
PUBLIC	?Remember@CBaseMonster@@QAEXH@Z			; CBaseMonster::Remember
PUBLIC	?HasMemory@CBaseMonster@@QAEHH@Z		; CBaseMonster::HasMemory
PUBLIC	??_C@_0BA@LNFJ@common?1null?4wav?$AA@		; `string'
;	COMDAT ??_C@_0BA@LNFJ@common?1null?4wav?$AA@
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
??_C@_0BA@LNFJ@common?1null?4wav?$AA@ DB 'common/null.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z
_TEXT	SEGMENT
_iGib$ = 12
_this$ = -4
_cCount$ = -8
_fDone$ = -12
_pOwner$ = -16
?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z PROC NEAR	; CBaseMonster::Killed, COMDAT

; 603  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 604  : 	unsigned int	cCount = 0;

	mov	DWORD PTR _cCount$[ebp], 0

; 605  : 	BOOL			fDone = FALSE;

	mov	DWORD PTR _fDone$[ebp], 0

; 606  : 
; 607  : 	if ( HasMemory( bits_MEMORY_KILLED ) )

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasMemory@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasMemory
	test	eax, eax
	je	SHORT $L38287

; 609  : 		if ( ShouldGibMonster( iGib ) )

	mov	eax, DWORD PTR _iGib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldGibMonster@CBaseMonster@@QAEHH@Z	; CBaseMonster::ShouldGibMonster
	test	eax, eax
	je	SHORT $L38288

; 610  : 			CallGibMonster();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CallGibMonster@CBaseMonster@@QAEXXZ	; CBaseMonster::CallGibMonster
$L38288:

; 611  : 		return;

	jmp	$L38284
$L38287:

; 613  : 
; 614  : 	Remember( bits_MEMORY_KILLED );

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Remember@CBaseMonster@@QAEXH@Z		; CBaseMonster::Remember

; 615  : 
; 616  : 	// clear the deceased's sound channels.(may have been firing or reloading when killed)
; 617  : 	EMIT_SOUND(ENT(pev), CHAN_WEAPON, "common/null.wav", 1, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BA@LNFJ@common?1null?4wav?$AA@ ; `string'
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 618  : 	m_IdealMonsterState = MONSTERSTATE_DEAD;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2084], 8

; 619  : 	// Make sure this condition is fired too (TakeDamage breaks out before this happens on death)
; 620  : 	SetConditions( bits_COND_LIGHT_DAMAGE );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions

; 621  : 	
; 622  : 	// tell owner ( if any ) that we're dead.This is mostly for MonsterMaker functionality.
; 623  : 	CBaseEntity *pOwner = CBaseEntity::Instance(pev->owner);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+408]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pOwner$[ebp], eax

; 624  : 	if ( pOwner )

	cmp	DWORD PTR _pOwner$[ebp], 0
	je	SHORT $L38292

; 626  : 		pOwner->DeathNotice( pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pOwner$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOwner$[ebp]
	call	DWORD PTR [edx+72]
$L38292:

; 628  : 
; 629  : 	if	( ShouldGibMonster( iGib ) )

	mov	eax, DWORD PTR _iGib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldGibMonster@CBaseMonster@@QAEHH@Z	; CBaseMonster::ShouldGibMonster
	test	eax, eax
	je	SHORT $L38293

; 631  : 		CallGibMonster();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CallGibMonster@CBaseMonster@@QAEXXZ	; CBaseMonster::CallGibMonster

; 632  : 		return;

	jmp	SHORT $L38284
$L38293:

; 634  : 	else if ( pev->flags & FL_MONSTER )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $L38295

; 636  : 		SetTouch( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 637  : 		BecomeDead();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+376]
$L38295:

; 639  : 	
; 640  : 	// don't let the status bar glitch for players.with <0 health.
; 641  : 	if (pev->health < -99)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+352]
	fcomp	DWORD PTR __real@4@c005c600000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38298

; 643  : 		pev->health = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+352], 0
$L38298:

; 645  : 	
; 646  : 	//pev->enemy = ENT( pevAttacker );//why? (sjb)
; 647  : 	
; 648  : 	m_IdealMonsterState = MONSTERSTATE_DEAD;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2084], 8
$L38284:

; 649  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z ENDP	; CBaseMonster::Killed
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_iConditions$ = 8
_this$ = -4
?SetConditions@CBaseMonster@@QAEXH@Z PROC NEAR		; CBaseMonster::SetConditions, COMDAT

; 256  : 		inline void	SetConditions( int iConditions ) { m_afConditions |= iConditions; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1956]
	or	ecx, DWORD PTR _iConditions$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1956], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetConditions@CBaseMonster@@QAEXH@Z ENDP		; CBaseMonster::SetConditions
_TEXT	ENDS
;	COMDAT ?Remember@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_iMemory$ = 8
_this$ = -4
?Remember@CBaseMonster@@QAEXH@Z PROC NEAR		; CBaseMonster::Remember, COMDAT

; 341  : 	inline void	Remember( int iMemory ) { m_afMemory |= iMemory; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2280]
	or	ecx, DWORD PTR _iMemory$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2280], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Remember@CBaseMonster@@QAEXH@Z ENDP			; CBaseMonster::Remember
_TEXT	ENDS
;	COMDAT ?HasMemory@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT
_iMemory$ = 8
_this$ = -4
?HasMemory@CBaseMonster@@QAEHH@Z PROC NEAR		; CBaseMonster::HasMemory, COMDAT

; 343  : 	inline BOOL HasMemory( int iMemory ) { if ( m_afMemory & iMemory ) return TRUE; return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2280]
	and	ecx, DWORD PTR _iMemory$[ebp]
	test	ecx, ecx
	je	SHORT $L36145
	mov	eax, 1
	jmp	SHORT $L36144
$L36145:
	xor	eax, eax
$L36144:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasMemory@CBaseMonster@@QAEHH@Z ENDP			; CBaseMonster::HasMemory
_TEXT	ENDS
PUBLIC	??_C@_0M@GAKJ@SUB_FadeOut?$AA@			; `string'
PUBLIC	__real@8@3ffbccccccccccccd000
PUBLIC	?SUB_FadeOut@CBaseEntity@@QAEXXZ		; CBaseEntity::SUB_FadeOut
;	COMDAT ??_C@_0M@GAKJ@SUB_FadeOut?$AA@
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
??_C@_0M@GAKJ@SUB_FadeOut?$AA@ DB 'SUB_FadeOut', 00H	; `string'
CONST	ENDS
;	COMDAT __real@8@3ffbccccccccccccd000
CONST	SEGMENT
__real@8@3ffbccccccccccccd000 DQ 03fb999999999999ar ; 0.1
CONST	ENDS
;	COMDAT ?SUB_StartFadeOut@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SUB_StartFadeOut@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::SUB_StartFadeOut, COMDAT

; 657  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 658  : 	if( pev->rendermode == kRenderNormal )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+328], 0
	jne	SHORT $L38303

; 660  : 		pev->renderamt = 255;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+332], 1132396544		; 437f0000H

; 661  : 		pev->rendermode = kRenderTransTexture;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+328], 2
$L38303:

; 663  : 
; 664  : 	pev->solid = SOLID_NOT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 0

; 665  : 	SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 666  : 
; 667  : 	pev->nextthink = gpGlobals->time + 0.1;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -8+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+260]

; 668  : 	SetThink ( SUB_FadeOut );

	push	OFFSET FLAT:??_C@_0M@GAKJ@SUB_FadeOut?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_FadeOut@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_FadeOut
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 669  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SUB_StartFadeOut@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::SUB_StartFadeOut
_TEXT	ENDS
PUBLIC	__real@4@4001e000000000000000
PUBLIC	__real@8@3ffcccccccccccccd000
;	COMDAT __real@4@4001e000000000000000
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
__real@4@4001e000000000000000 DD 040e00000r	; 7
CONST	ENDS
;	COMDAT __real@8@3ffcccccccccccccd000
CONST	SEGMENT
__real@8@3ffcccccccccccccd000 DQ 03fc999999999999ar ; 0.2
CONST	ENDS
;	COMDAT ?SUB_FadeOut@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SUB_FadeOut@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::SUB_FadeOut, COMDAT

; 672  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 673  : 	if ( pev->renderamt > 7 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+332]
	fcomp	DWORD PTR __real@4@4001e000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38311

; 675  : 		pev->renderamt -= 7;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+332]
	fsub	DWORD PTR __real@4@4001e000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+332]

; 676  : 		pev->nextthink = gpGlobals->time + 0.1;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 678  : 	else 

	jmp	SHORT $L38312
$L38311:

; 680  : 		pev->renderamt = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+332], 0

; 681  : 		pev->nextthink = gpGlobals->time + 0.2;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	QWORD PTR __real@8@3ffcccccccccccccd000
	fst	DWORD PTR -12+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+260]

; 682  : 		SetThink ( SUB_Remove );

	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
$L38312:

; 684  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SUB_FadeOut@CBaseEntity@@QAEXXZ ENDP			; CBaseEntity::SUB_FadeOut
_TEXT	ENDS
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
PUBLIC	??_C@_0BB@BMDK@SUB_StartFadeOut?$AA@		; `string'
EXTRN	?InsertSound@CSoundEnt@@SAXHABVVector@@HM@Z:NEAR ; CSoundEnt::InsertSound
;	COMDAT ??_C@_0BB@BMDK@SUB_StartFadeOut?$AA@
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
??_C@_0BB@BMDK@SUB_StartFadeOut?$AA@ DB 'SUB_StartFadeOut', 00H ; `string'
CONST	ENDS
;	COMDAT ?WaitTillLand@CGib@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?WaitTillLand@CGib@@QAEXXZ PROC NEAR			; CGib::WaitTillLand, COMDAT

; 693  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 694  : 	if( !IsInWorld( ))

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+220]
	test	eax, eax
	jne	SHORT $L38319

; 696  : 		UTIL_Remove( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 697  : 		return;

	jmp	SHORT $L38318
$L38319:

; 699  : 
; 700  : 	if( GetAbsVelocity() == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L38320

; 702  : 		SetThink( SUB_StartFadeOut );

	push	OFFSET FLAT:??_C@_0BB@BMDK@SUB_StartFadeOut?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_StartFadeOut@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_StartFadeOut
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 703  : 		SetNextThink( m_lifeTime );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1776]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 704  : 
; 705  : 		// If you bleed, you stink!
; 706  : 		if( m_bloodColor != DONT_BLEED )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1764], -1
	je	SHORT $L38324

; 708  : 			// ok, start stinkin!
; 709  : 			CSoundEnt::InsertSound ( bits_SOUND_MEAT, GetAbsOrigin(), 384, 25 );

	push	1103626240				; 41c80000H
	push	384					; 00000180H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	push	16					; 00000010H
	call	?InsertSound@CSoundEnt@@SAXHABVVector@@HM@Z ; CSoundEnt::InsertSound
	add	esp, 16					; 00000010H
$L38324:

; 712  : 	else

	jmp	SHORT $L38325
$L38320:

; 714  : 		// wait and check again in another half second.
; 715  : 		SetNextThink( 0.5 );

	push	1056964608				; 3f000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]
$L38325:
$L38318:

; 717  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?WaitTillLand@CGib@@QAEXXZ ENDP				; CGib::WaitTillLand
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39423
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39423
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39423
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39424
$L39423:
	mov	DWORD PTR -8+[ebp], 0
$L39424:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
PUBLIC	__real@4@4007e100000000000000
PUBLIC	__real@8@3ffeccccccccccccd000
EXTRN	?UTIL_BloodDecalTrace@@YAXPAUgametrace_s@@H@Z:NEAR ; UTIL_BloodDecalTrace
EXTRN	?MaterialSoundRandom@CBreakable@@SAXPAUedict_s@@W4Materials@@M@Z:NEAR ; CBreakable::MaterialSoundRandom
EXTRN	_fabs:NEAR
EXTRN	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAngles
EXTRN	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAngles
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
;	COMDAT __real@4@4007e100000000000000
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
__real@4@4007e100000000000000 DD 043e10000r	; 450
CONST	ENDS
;	COMDAT __real@8@3ffeccccccccccccd000
CONST	SEGMENT
__real@8@3ffeccccccccccccd000 DQ 03fe999999999999ar ; 0.8
CONST	ENDS
;	COMDAT ?BounceGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_vecSpot$ = -16
_tr$ = -72
_angles$38334 = -84
_angVel$38335 = -96
_volume$38343 = -100
_zvel$38344 = -104
$T39427 = -116
$T39428 = -128
$T39429 = -140
$T39430 = -152
$T39431 = -164
?BounceGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z PROC NEAR	; CGib::BounceGibTouch, COMDAT

; 723  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 724  : 	Vector vecSpot;

	lea	ecx, DWORD PTR _vecSpot$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 725  : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 726  : 
; 727  : 	if( pev->flags & FL_ONGROUND )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	$L38332

; 729  : 		SetAbsVelocity( GetAbsVelocity() * 0.9f );

	push	1063675494				; 3f666666H
	lea	eax, DWORD PTR $T39427[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 730  : 		Vector angles = GetLocalAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	lea	ecx, DWORD PTR _angles$38334[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 731  : 		angles.x = 0;

	mov	DWORD PTR _angles$38334[ebp], 0

; 732  : 		angles.z = 0;

	mov	DWORD PTR _angles$38334[ebp+8], 0

; 733  : 		SetLocalAngles( angles );

	lea	ecx, DWORD PTR _angles$38334[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 734  : 
; 735  : 		Vector angVel = GetLocalAvelocity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	push	eax
	lea	ecx, DWORD PTR _angVel$38335[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 736  : 		angVel.x = 0;

	mov	DWORD PTR _angVel$38335[ebp], 0

; 737  : 		angVel.z = 0;

	mov	DWORD PTR _angVel$38335[ebp+8], 0

; 738  : 		SetLocalAvelocity( angVel );	// g-cont. half-life rules: stay yaw rotation active

	lea	edx, DWORD PTR _angVel$38335[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 739  : 		pev->friction = 0.5;	// ... and enable Xash feature: friction

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+288], 1056964608		; 3f000000H

; 741  : 	else

	jmp	$L38342
$L38332:

; 743  : 		if( g_Language != LANGUAGE_GERMAN && m_cBloodDecals > 0 && m_bloodColor != DONT_BLEED )

	cmp	DWORD PTR ?g_Language@@3HA, 1		; g_Language
	je	$L38337
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1768], 0
	jle	$L38337
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1764], -1
	je	$L38337

; 745  : 			vecSpot = GetAbsOrigin() + Vector ( 0 , 0 , 8 );//move up a bit, and trace down.

	push	1090519040				; 41000000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T39428[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T39429[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecSpot$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecSpot$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecSpot$[ebp+8], edx

; 746  : 			UTIL_TraceLine( vecSpot, vecSpot + Vector( 0, 0, -24 ),  ignore_monsters, edict(), &tr );

	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	push	-1044381696				; c1c00000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T39430[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T39431[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecSpot$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	edx, DWORD PTR _vecSpot$[ebp]
	push	edx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 747  : 
; 748  : 			UTIL_BloodDecalTrace( &tr, m_bloodColor );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1764]
	push	ecx
	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	call	?UTIL_BloodDecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_BloodDecalTrace
	add	esp, 8

; 749  : 
; 750  : 			m_cBloodDecals--; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1768]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1768], ecx
$L38337:

; 752  : 
; 753  : 		if( m_material != matNone && RANDOM_LONG( 0, 2 ) == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1772], 9
	je	$L38342
	push	2
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	jne	$L38342

; 755  : 			float volume;
; 756  : 			float zvel = fabs( GetAbsVelocity().z );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fst	DWORD PTR _zvel$38344[ebp]

; 757  : 		
; 758  : 			volume = 0.8 * Q_min( 1.0, zvel / 450.0f);

	fdiv	DWORD PTR __real@4@4007e100000000000000
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39432
	mov	DWORD PTR -172+[ebp], 0
	mov	DWORD PTR -172+[ebp+4], 1072693248	; 3ff00000H
	jmp	SHORT $L39433
$L39432:
	fld	DWORD PTR _zvel$38344[ebp]
	fdiv	DWORD PTR __real@4@4007e100000000000000
	fstp	QWORD PTR -172+[ebp]
$L39433:
	fld	QWORD PTR __real@8@3ffeccccccccccccd000
	fmul	QWORD PTR -172+[ebp]
	fstp	DWORD PTR _volume$38343[ebp]

; 759  : 
; 760  : 			CBreakable::MaterialSoundRandom( edict(), (Materials)m_material, volume );

	mov	ecx, DWORD PTR _volume$38343[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1772]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?MaterialSoundRandom@CBreakable@@SAXPAUedict_s@@W4Materials@@M@Z ; CBreakable::MaterialSoundRandom
	add	esp, 12					; 0000000cH
$L38342:

; 763  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?BounceGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z ENDP	; CGib::BounceGibTouch
_TEXT	ENDS
EXTRN	?g_pWorld@@3PAVCBaseEntity@@A:DWORD		; g_pWorld
EXTRN	?SetParent@CBaseEntity@@QAEXPAV1@H@Z:NEAR	; CBaseEntity::SetParent
EXTRN	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z:NEAR	; UTIL_VecToAngles
;	COMDAT ?StickyGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
_tr$ = -60
_vecForward$38357 = -72
$T39440 = -84
$T39441 = -96
$T39442 = -108
$T39443 = -120
?StickyGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z PROC NEAR	; CGib::StickyGibTouch, COMDAT

; 769  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 770  : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 771  : 	
; 772  : 	SetThink( SUB_Remove );

	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 773  : 	SetNextThink( 60 );

	push	1114636288				; 42700000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 774  : 
; 775  : 	if( pOther == g_pWorld || pOther->pev->movetype == MOVETYPE_PUSH || pOther->IsPushable() || pOther->IsRigidBody() )

	mov	eax, DWORD PTR _pOther$[ebp]
	cmp	eax, DWORD PTR ?g_pWorld@@3PAVCBaseEntity@@A ; g_pWorld
	je	SHORT $L38354
	mov	ecx, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 7
	je	SHORT $L38354
	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+236]
	test	eax, eax
	jne	SHORT $L38354
	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+76]
	test	eax, eax
	je	$L38353
$L38354:

; 777  : 		UTIL_TraceLine ( GetAbsOrigin(), GetAbsOrigin() + GetAbsVelocity() * 32, ignore_monsters, edict(), &tr );

	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	push	1107296256				; 42000000H
	lea	ecx, DWORD PTR $T39440[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T39441[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 778  : 		UTIL_BloodDecalTrace( &tr, m_bloodColor );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1764]
	push	ecx
	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	call	?UTIL_BloodDecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_BloodDecalTrace
	add	esp, 8

; 779  : 
; 780  : 		Vector vecForward = tr.vecPlaneNormal * -1;

	push	-1082130432				; bf800000H
	lea	eax, DWORD PTR $T39442[ebp]
	push	eax
	lea	ecx, DWORD PTR _tr$[ebp+36]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _vecForward$38357[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 781  : 		SetLocalAngles( UTIL_VecToAngles( vecForward ));

	lea	ecx, DWORD PTR _vecForward$38357[ebp]
	push	ecx
	lea	edx, DWORD PTR $T39443[ebp]
	push	edx
	call	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z	; UTIL_VecToAngles
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 782  : 		SetLocalVelocity( g_vecZero ); 

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 783  : 		SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 784  : 		pev->movetype = MOVETYPE_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 0

; 785  : 
; 786  : 		if( pOther != g_pWorld )

	mov	edx, DWORD PTR _pOther$[ebp]
	cmp	edx, DWORD PTR ?g_pWorld@@3PAVCBaseEntity@@A ; g_pWorld
	je	SHORT $L38360

; 787  : 			SetParent( pOther );

	push	0
	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@CBaseEntity@@QAEXPAV1@H@Z	; CBaseEntity::SetParent
$L38360:

; 789  : 	else

	jmp	SHORT $L38361
$L38353:

; 791  : 		SetNextThink( 0 );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]
$L38361:

; 794  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StickyGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z ENDP	; CGib::StickyGibTouch
_TEXT	ENDS
PUBLIC	??_C@_03HBJ@gib?$AA@				; `string'
;	COMDAT ??_C@_03HBJ@gib?$AA@
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
??_C@_03HBJ@gib?$AA@ DB 'gib', 00H			; `string'
CONST	ENDS
;	COMDAT ?Spawn@CGib@@QAEXPBD@Z
_TEXT	SEGMENT
_szGibModel$ = 8
_this$ = -4
?Spawn@CGib@@QAEXPBD@Z PROC NEAR			; CGib::Spawn, COMDAT

; 800  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 801  : 	pev->movetype = MOVETYPE_BOUNCE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 10			; 0000000aH

; 802  : 	pev->friction = 0.55; // deading the bounce a bit

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+288], 1057803469		; 3f0ccccdH

; 803  : 	
; 804  : 	// sometimes an entity inherits the edict from a former piece of glass,
; 805  : 	// and will spawn using the same render FX or rendermode! bad!
; 806  : 	pev->renderamt = 255;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+332], 1132396544		; 437f0000H

; 807  : 	pev->rendermode = kRenderNormal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+328], 0

; 808  : 	pev->renderfx = kRenderFxNone;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+348], 0

; 809  : 	pev->solid = SOLID_SLIDEBOX; // hopefully this will fix the VELOCITY TOO LOW crap

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 3

; 810  : 	pev->classname = MAKE_STRING( "gib" );

	push	OFFSET FLAT:??_C@_03HBJ@gib?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 811  : 
; 812  : 	SET_MODEL( edict(), szGibModel );

	mov	eax, DWORD PTR _szGibModel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 813  : 	UTIL_SetSize( pev, g_vecZero, g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 814  : 
; 815  : 	SetNextThink( 4 );

	push	1082130432				; 40800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 816  : 	m_lifeTime = 25;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1776], 1103626240	; 41c80000H

; 817  : 	SetThink( WaitTillLand );

	push	OFFSET FLAT:??_C@_0N@DHF@WaitTillLand?$AA@ ; `string'
	push	OFFSET FLAT:?WaitTillLand@CGib@@QAEXXZ	; CGib::WaitTillLand
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 818  : 	SetTouch( BounceGibTouch );

	push	OFFSET FLAT:??_C@_0P@BKJG@BounceGibTouch?$AA@ ; `string'
	push	OFFSET FLAT:?BounceGibTouch@CGib@@QAEXPAVCBaseEntity@@@Z ; CGib::BounceGibTouch
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 819  : 
; 820  : 	m_material = matNone;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1772], 9

; 821  : 	m_cBloodDecals = 5; // how many blood decals this gib can place (1 per bounce until none remain). 

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1768], 5

; 822  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Spawn@CGib@@QAEXPBD@Z ENDP				; CGib::Spawn
_TEXT	ENDS
PUBLIC	?TakeHealth@CBaseMonster@@UAEHMH@Z		; CBaseMonster::TakeHealth
EXTRN	?TakeHealth@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeHealth
;	COMDAT ?TakeHealth@CBaseMonster@@UAEHMH@Z
_TEXT	SEGMENT
_flHealth$ = 8
_bitsDamageType$ = 12
_this$ = -4
?TakeHealth@CBaseMonster@@UAEHMH@Z PROC NEAR		; CBaseMonster::TakeHealth, COMDAT

; 826  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 827  : 	if (!pev->takedamage)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38376

; 828  : 		return 0;

	xor	eax, eax
	jmp	SHORT $L38375
$L38376:

; 829  : 
; 830  : 	// clear out any damage types we healed.
; 831  : 	// UNDONE: generic health should not heal any
; 832  : 	// UNDONE: time-based damage
; 833  : 
; 834  : 	m_bitsDamageType &= ~(bitsDamageType & ~DMG_TIMEBASED);

	mov	edx, DWORD PTR _bitsDamageType$[ebp]
	and	edx, -16760833				; ff003fffH
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2312]
	and	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2312], ecx

; 835  : 	
; 836  : 	return CBaseEntity::TakeHealth(flHealth, bitsDamageType);

	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flHealth$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TakeHealth@CBaseEntity@@UAEHMH@Z	; CBaseEntity::TakeHealth
$L38375:

; 837  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?TakeHealth@CBaseMonster@@UAEHMH@Z ENDP			; CBaseMonster::TakeHealth
_TEXT	ENDS
PUBLIC	?HasConditions@CBaseMonster@@QAEHH@Z		; CBaseMonster::HasConditions
PUBLIC	?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z ; CBaseMonster::TakeDamage
PUBLIC	?DeadTakeDamage@CBaseMonster@@QAEHPAUentvars_s@@0MH@Z ; CBaseMonster::DeadTakeDamage
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
PUBLIC	__real@4@4003a000000000000000
PUBLIC	?FNullEnt@@YAHPAUentvars_s@@@Z			; FNullEnt
PUBLIC	?DamageForce@CBaseMonster@@QAEMM@Z		; CBaseMonster::DamageForce
EXTRN	?g_pevLastInflictor@@3PAUentvars_s@@A:DWORD	; g_pevLastInflictor
EXTRN	?UTIL_IsFacing@@YAHPAUentvars_s@@ABVVector@@@Z:NEAR ; UTIL_IsFacing
EXTRN	?MakeIdealYaw@CBaseMonster@@QAEXVVector@@@Z:NEAR ; CBaseMonster::MakeIdealYaw
;	COMDAT __real@4@4003a000000000000000
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
__real@4@4003a000000000000000 DD 041a00000r	; 20
CONST	ENDS
;	COMDAT ?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT
_pevInflictor$ = 8
_pevAttacker$ = 12
_flDamage$ = 16
_bitsDamageType$ = 20
_this$ = -4
_flTake$ = -8
_vecDir$ = -20
_pInflictor$38391 = -24
$T39450 = -36
$T39451 = -48
$T39452 = -60
$T39453 = -72
$T39454 = -84
$T39455 = -96
$T39456 = -108
$T39457 = -120
$T39458 = -132
$T39459 = -144
$T39460 = -156
$T39461 = -168
?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z PROC NEAR ; CBaseMonster::TakeDamage, COMDAT

; 856  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 857  : 	float	flTake;
; 858  : 	Vector	vecDir;

	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 859  : 
; 860  : 	if (!pev->takedamage)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38386

; 861  : 		return 0;

	xor	eax, eax
	jmp	$L38383
$L38386:

; 862  : 
; 863  : 	if ( !IsAlive() )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+200]
	test	eax, eax
	jne	SHORT $L38387

; 865  : 		return DeadTakeDamage( pevInflictor, pevAttacker, flDamage, bitsDamageType );

	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flDamage$[ebp]
	push	edx
	mov	eax, DWORD PTR _pevAttacker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeadTakeDamage@CBaseMonster@@QAEHPAUentvars_s@@0MH@Z ; CBaseMonster::DeadTakeDamage
	jmp	$L38383
$L38387:

; 867  : 
; 868  : 	if ( pev->deadflag == DEAD_NO )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+368], 0
	jne	SHORT $L38388

; 870  : 		// no pain sound during death animation.
; 871  : 		PainSound();// "Ouch!"

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+604]
$L38388:

; 873  : 
; 874  : 	//!!!LATER - make armor consideration here!
; 875  : 	flTake = flDamage;

	mov	eax, DWORD PTR _flDamage$[ebp]
	mov	DWORD PTR _flTake$[ebp], eax

; 876  : 
; 877  : 	// set damage type sustained
; 878  : 	m_bitsDamageType |= bitsDamageType;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2312]
	or	edx, DWORD PTR _bitsDamageType$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2312], edx

; 879  : 
; 880  : 	// grab the vector of the incoming attack. ( pretend that the inflictor is a little lower than it really is, so the body will tend to fly upward a bit).
; 881  : 	vecDir = Vector( 0, 0, 0 );

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR $T39450[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecDir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecDir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecDir$[ebp+8], eax

; 882  : 	if (!FNullEnt( pevInflictor ))

	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	push	ecx
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	$L38392

; 884  : 		CBaseEntity *pInflictor = CBaseEntity :: Instance( pevInflictor );

	mov	edx, DWORD PTR _pevInflictor$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pInflictor$38391[ebp], eax

; 885  : 		if (pInflictor)

	cmp	DWORD PTR _pInflictor$38391[ebp], 0
	je	$L38392

; 887  : 			vecDir = ( pInflictor->Center() - Vector ( 0, 0, 10 ) - Center() ).Normalize();

	lea	eax, DWORD PTR $T39456[ebp]
	push	eax
	lea	ecx, DWORD PTR $T39454[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+304]
	push	eax
	lea	ecx, DWORD PTR $T39455[ebp]
	push	ecx
	push	1092616192				; 41200000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T39452[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	edx, DWORD PTR $T39453[ebp]
	push	edx
	lea	eax, DWORD PTR $T39451[ebp]
	push	eax
	mov	ecx, DWORD PTR _pInflictor$38391[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pInflictor$38391[ebp]
	call	DWORD PTR [edx+304]
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecDir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecDir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecDir$[ebp+8], eax

; 888  : 			vecDir = g_vecAttackDir = vecDir.Normalize();

	lea	ecx, DWORD PTR $T39457[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR ?g_vecAttackDir@@3VVector@@A, edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR ?g_vecAttackDir@@3VVector@@A+4, ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR ?g_vecAttackDir@@3VVector@@A+8, edx
	mov	eax, DWORD PTR ?g_vecAttackDir@@3VVector@@A
	mov	DWORD PTR _vecDir$[ebp], eax
	mov	ecx, DWORD PTR ?g_vecAttackDir@@3VVector@@A+4
	mov	DWORD PTR _vecDir$[ebp+4], ecx
	mov	edx, DWORD PTR ?g_vecAttackDir@@3VVector@@A+8
	mov	DWORD PTR _vecDir$[ebp+8], edx
$L38392:

; 891  : 
; 892  : 	// add to the damage total for clients, which will be sent as a single
; 893  : 	// message at the end of the frame
; 894  : 	// todo: remove after combining shotgun blasts?
; 895  : 	if ( IsPlayer() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L38402

; 897  : 		if ( pevInflictor )

	cmp	DWORD PTR _pevInflictor$[ebp], 0
	je	SHORT $L38401

; 898  : 			pev->dmg_inflictor = ENT(pevInflictor);

	mov	eax, DWORD PTR _pevInflictor$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+396], eax
$L38401:

; 899  : 
; 900  : 		pev->dmg_take += flTake;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR _flTake$[ebp]
	fadd	DWORD PTR [ecx+472]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+472]

; 901  : 
; 902  : 		// check for godmode or invincibility
; 903  : 		if ( pev->flags & FL_GODMODE )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $L38402

; 905  : 			return 0;

	xor	eax, eax
	jmp	$L38383
$L38402:

; 908  : 
; 909  : 	// if this is a player, move him around!
; 910  : 	if ( ( !FNullEnt( pevInflictor ) ) && (pev->movetype == MOVETYPE_WALK) && (!pevAttacker || pevAttacker->solid != SOLID_TRIGGER) )

	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	push	ecx
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L38403
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+264], 3
	jne	SHORT $L38403
	cmp	DWORD PTR _pevAttacker$[ebp], 0
	je	SHORT $L38404
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	cmp	DWORD PTR [ecx+268], 1
	je	SHORT $L38403
$L38404:

; 912  : 		SetAbsVelocity( GetAbsVelocity() + vecDir * -DamageForce( flDamage ));

	mov	edx, DWORD PTR _flDamage$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DamageForce@CBaseMonster@@QAEMM@Z	; CBaseMonster::DamageForce
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T39458[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T39459[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L38403:

; 914  : 
; 915  : 	// do the damage
; 916  : 	pev->health -= flTake;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fsub	DWORD PTR _flTake$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+352]

; 917  : 
; 918  : 	
; 919  : 	// HACKHACK Don't kill monsters in a script.  Let them break their scripts first
; 920  : 	if ( m_MonsterState == MONSTERSTATE_SCRIPT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2080], 6
	jne	SHORT $L38407

; 922  : 		SetConditions( bits_COND_LIGHT_DAMAGE );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions

; 923  : 		return 0;

	xor	eax, eax
	jmp	$L38383
$L38407:

; 925  : 
; 926  : 	if ( pev->health <= 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38408

; 928  : 		g_pevLastInflictor = pevInflictor;

	mov	eax, DWORD PTR _pevInflictor$[ebp]
	mov	DWORD PTR ?g_pevLastInflictor@@3PAUentvars_s@@A, eax ; g_pevLastInflictor

; 929  : 
; 930  : 		if ( bitsDamageType & DMG_ALWAYSGIB )

	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	and	ecx, 8192				; 00002000H
	test	ecx, ecx
	je	SHORT $L38409

; 932  : 			Killed( pevAttacker, GIB_ALWAYS );

	push	2
	mov	edx, DWORD PTR _pevAttacker$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+108]

; 934  : 		else if ( bitsDamageType & DMG_NEVERGIB )

	jmp	SHORT $L38412
$L38409:
	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $L38411

; 936  : 			Killed( pevAttacker, GIB_NEVER );

	push	1
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+108]

; 938  : 		else

	jmp	SHORT $L38412
$L38411:

; 940  : 			Killed( pevAttacker, GIB_NORMAL );

	push	0
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+108]
$L38412:

; 942  : 
; 943  : 		g_pevLastInflictor = NULL;

	mov	DWORD PTR ?g_pevLastInflictor@@3PAUentvars_s@@A, 0 ; g_pevLastInflictor

; 944  : 
; 945  : 		return 0;

	xor	eax, eax
	jmp	$L38383
$L38408:

; 947  : 
; 948  : 	// react to the damage (get mad)
; 949  : 	if ( (pev->flags & FL_MONSTER) && !FNullEnt(pevAttacker) )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	$L38431
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	$L38431

; 951  : 		//LRC - new behaviours, for m_iPlayerReact.
; 952  : 		if (pevAttacker->flags & FL_CLIENT)

	mov	edx, DWORD PTR _pevAttacker$[ebp]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 8
	test	eax, eax
	je	SHORT $L38421

; 954  : 			if (m_iPlayerReact == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2392], 2
	jne	SHORT $L38415

; 956  : 				// just get angry.
; 957  : 				Remember( bits_MEMORY_PROVOKED );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Remember@CBaseMonster@@QAEXH@Z		; CBaseMonster::Remember

; 959  : 			else if (m_iPlayerReact == 3)

	jmp	SHORT $L38421
$L38415:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2392], 3
	jne	SHORT $L38421

; 961  : 				// try to decide whether it was deliberate... if I have an enemy, assume it was just crossfire.
; 962  : 				if ( m_hEnemy == NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $L38421

; 964  : 					if ( (m_afMemory & bits_MEMORY_SUSPICIOUS) || UTIL_IsFacing( pevAttacker, pev->origin ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2280]
	and	ecx, 4
	test	ecx, ecx
	jne	SHORT $L38420
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	call	?UTIL_IsFacing@@YAHPAUentvars_s@@ABVVector@@@Z ; UTIL_IsFacing
	add	esp, 8
	test	eax, eax
	je	SHORT $L38419
$L38420:

; 965  : 						Remember( bits_MEMORY_PROVOKED );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Remember@CBaseMonster@@QAEXH@Z		; CBaseMonster::Remember

; 966  : 					else

	jmp	SHORT $L38421
$L38419:

; 967  : 						Remember( bits_MEMORY_SUSPICIOUS );

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Remember@CBaseMonster@@QAEXH@Z		; CBaseMonster::Remember
$L38421:

; 971  : 
; 972  : 		if ( pevAttacker->flags & (FL_MONSTER | FL_CLIENT) )

	mov	edx, DWORD PTR _pevAttacker$[ebp]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 40					; 00000028H
	test	eax, eax
	je	$L38431

; 974  : 			
; 975  : 			// enemy's last known position is somewhere down the vector that the attack came from.
; 976  : 			if (pevInflictor)

	cmp	DWORD PTR _pevInflictor$[ebp], 0
	je	SHORT $L38423

; 978  : 				if (m_hEnemy == NULL || pevInflictor == m_hEnemy->pev || !HasConditions(bits_COND_SEE_ENEMY))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L38425
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $L38425
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	jne	SHORT $L38424
$L38425:

; 980  : 					m_vecEnemyLKP = pevInflictor->origin;

	mov	edx, DWORD PTR _pevInflictor$[ebp]
	add	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2288				; 000008f0H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
$L38424:

; 983  : 			else

	jmp	SHORT $L38426
$L38423:

; 985  : 				m_vecEnemyLKP = GetAbsOrigin() + ( g_vecAttackDir * 64 ); 

	push	1115684864				; 42800000H
	lea	eax, DWORD PTR $T39460[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?g_vecAttackDir@@3VVector@@A
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T39461[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2288				; 000008f0H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L38426:

; 987  : 
; 988  : 			MakeIdealYaw( m_vecEnemyLKP );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	push	ecx
	mov	ecx, edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeIdealYaw@CBaseMonster@@QAEXVVector@@@Z ; CBaseMonster::MakeIdealYaw

; 989  : 
; 990  : 			// add pain to the conditions 
; 991  : 			// !!!HACKHACK - fudged for now. Do we want to have a virtual function to determine what is light and 
; 992  : 			// heavy damage per monster class?
; 993  : 			if ( flDamage > 0 )

	fld	DWORD PTR _flDamage$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38430

; 995  : 				SetConditions(bits_COND_LIGHT_DAMAGE);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
$L38430:

; 997  : 
; 998  : 			if ( flDamage >= 20 )

	fld	DWORD PTR _flDamage$[ebp]
	fcomp	DWORD PTR __real@4@4003a000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L38431

; 1000 : 				SetConditions(bits_COND_HEAVY_DAMAGE);

	push	512					; 00000200H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
$L38431:

; 1004 : 
; 1005 : 	return 1;

	mov	eax, 1
$L38383:

; 1006 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z ENDP	; CBaseMonster::TakeDamage
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?FNullEnt@@YAHPAUentvars_s@@@Z PROC NEAR		; FNullEnt, COMDAT

; 196  : inline BOOL FNullEnt(entvars_t* pev)				{ return pev == NULL || FNullEnt(OFFSET(pev)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pev$[ebp], 0
	je	SHORT $L39467
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39467
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L39468
$L39467:
	mov	DWORD PTR -4+[ebp], 1
$L39468:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAUentvars_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad pev in OFFSET()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?OFFSET@@YAHPAUentvars_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L32439

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32439:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator->, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT
_iConditions$ = 8
_this$ = -4
?HasConditions@CBaseMonster@@QAEHH@Z PROC NEAR		; CBaseMonster::HasConditions, COMDAT

; 258  : 		inline BOOL HasConditions( int iConditions ) { if ( m_afConditions & iConditions ) return TRUE; return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1956]
	and	ecx, DWORD PTR _iConditions$[ebp]
	test	ecx, ecx
	je	SHORT $L36111
	mov	eax, 1
	jmp	SHORT $L36110
$L36111:
	xor	eax, eax
$L36110:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasConditions@CBaseMonster@@QAEHH@Z ENDP		; CBaseMonster::HasConditions
_TEXT	ENDS
;	COMDAT ?DeadTakeDamage@CBaseMonster@@QAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT
_pevInflictor$ = 8
_pevAttacker$ = 12
_flDamage$ = 16
_bitsDamageType$ = 20
_this$ = -4
_vecDir$ = -16
_pInflictor$38442 = -20
$T39485 = -32
$T39486 = -44
$T39487 = -56
$T39488 = -68
$T39489 = -80
$T39490 = -92
$T39491 = -104
$T39492 = -116
?DeadTakeDamage@CBaseMonster@@QAEHPAUentvars_s@@0MH@Z PROC NEAR ; CBaseMonster::DeadTakeDamage, COMDAT

; 1013 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1014 : 	Vector			vecDir;

	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1015 : 
; 1016 : 	// grab the vector of the incoming attack. ( pretend that the inflictor is a little lower than it really is, so the body will tend to fly upward a bit).
; 1017 : 	vecDir = Vector( 0, 0, 0 );

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR $T39485[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecDir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecDir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecDir$[ebp+8], eax

; 1018 : 	if (!FNullEnt( pevInflictor ))

	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	push	ecx
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	$L38443

; 1020 : 		CBaseEntity *pInflictor = CBaseEntity :: Instance( pevInflictor );

	mov	edx, DWORD PTR _pevInflictor$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pInflictor$38442[ebp], eax

; 1021 : 		if (pInflictor)

	cmp	DWORD PTR _pInflictor$38442[ebp], 0
	je	$L38443

; 1023 : 			vecDir = ( pInflictor->Center() - Vector ( 0, 0, 10 ) - Center() ).Normalize();

	lea	eax, DWORD PTR $T39491[ebp]
	push	eax
	lea	ecx, DWORD PTR $T39489[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+304]
	push	eax
	lea	ecx, DWORD PTR $T39490[ebp]
	push	ecx
	push	1092616192				; 41200000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T39487[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	edx, DWORD PTR $T39488[ebp]
	push	edx
	lea	eax, DWORD PTR $T39486[ebp]
	push	eax
	mov	ecx, DWORD PTR _pInflictor$38442[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pInflictor$38442[ebp]
	call	DWORD PTR [edx+304]
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecDir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecDir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecDir$[ebp+8], eax

; 1024 : 			vecDir = g_vecAttackDir = vecDir.Normalize();

	lea	ecx, DWORD PTR $T39492[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR ?g_vecAttackDir@@3VVector@@A, edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR ?g_vecAttackDir@@3VVector@@A+4, ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR ?g_vecAttackDir@@3VVector@@A+8, edx
	mov	eax, DWORD PTR ?g_vecAttackDir@@3VVector@@A
	mov	DWORD PTR _vecDir$[ebp], eax
	mov	ecx, DWORD PTR ?g_vecAttackDir@@3VVector@@A+4
	mov	DWORD PTR _vecDir$[ebp+4], ecx
	mov	edx, DWORD PTR ?g_vecAttackDir@@3VVector@@A+8
	mov	DWORD PTR _vecDir$[ebp+8], edx
$L38443:

; 1027 : 
; 1028 : 	// kill the corpse if enough damage was done to destroy the corpse and the damage is of a type that is allowed to destroy the corpse.
; 1029 : 	if ( bitsDamageType & DMG_GIB_CORPSE )

	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	and	eax, 8389345				; 008002e1H
	test	eax, eax
	je	SHORT $L38451

; 1031 : 		if ( pev->health <= flDamage )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+352]
	fcomp	DWORD PTR _flDamage$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38452

; 1033 : 			pev->health = -50;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+352], -1035468800	; c2480000H

; 1034 : 			Killed( pevAttacker, GIB_ALWAYS );

	push	2
	mov	edx, DWORD PTR _pevAttacker$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+108]

; 1035 : 			return 0;

	xor	eax, eax
	jmp	SHORT $L38438
$L38452:

; 1037 : 		// Accumulate corpse gibbing damage, so you can gib with multiple hits
; 1038 : 		pev->health -= flDamage * 0.1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+352]
	fld	DWORD PTR _flDamage$[ebp]
	fmul	QWORD PTR __real@8@3ffbccccccccccccd000
	fsubp	ST(1), ST(0)
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+352]
$L38451:

; 1040 : 	
; 1041 : 	return 1;

	mov	eax, 1
$L38438:

; 1042 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DeadTakeDamage@CBaseMonster@@QAEHPAUentvars_s@@0MH@Z ENDP ; CBaseMonster::DeadTakeDamage
_TEXT	ENDS
PUBLIC	__real@8@400f9000000000000000
PUBLIC	__real@8@4001a000000000000000
PUBLIC	__real@8@4008fa00000000000000
;	COMDAT __real@8@400f9000000000000000
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
__real@8@400f9000000000000000 DQ 040f2000000000000r ; 73728
CONST	ENDS
;	COMDAT __real@8@4001a000000000000000
CONST	SEGMENT
__real@8@4001a000000000000000 DQ 04014000000000000r ; 5
CONST	ENDS
;	COMDAT __real@8@4008fa00000000000000
CONST	SEGMENT
__real@8@4008fa00000000000000 DQ 0408f400000000000r ; 1000
CONST	ENDS
;	COMDAT ?DamageForce@CBaseMonster@@QAEMM@Z
_TEXT	SEGMENT
_damage$ = 8
_this$ = -4
_force$ = -8
?DamageForce@CBaseMonster@@QAEMM@Z PROC NEAR		; CBaseMonster::DamageForce, COMDAT

; 1046 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1047 : 	float force = damage * ((32 * 32 * 72.0) / (pev->size.x * pev->size.y * pev->size.z)) * 5;

	fld	DWORD PTR _damage$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [ecx+244]
	fmul	DWORD PTR [eax+248]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fmul	DWORD PTR [edx+252]
	fdivr	QWORD PTR __real@8@400f9000000000000000
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR __real@8@4001a000000000000000
	fstp	DWORD PTR _force$[ebp]

; 1048 : 	
; 1049 : 	if ( force > 1000.0) 

	fld	DWORD PTR _force$[ebp]
	fcomp	QWORD PTR __real@8@4008fa00000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38458

; 1051 : 		force = 1000.0;

	mov	DWORD PTR _force$[ebp], 1148846080	; 447a0000H
$L38458:

; 1053 : 
; 1054 : 	return force;

	fld	DWORD PTR _force$[ebp]

; 1055 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DamageForce@CBaseMonster@@QAEMM@Z ENDP			; CBaseMonster::DamageForce
_TEXT	ENDS
PUBLIC	?RadiusDamage@@YAXVVector@@PAUentvars_s@@1MMHH@Z ; RadiusDamage
EXTRN	?UTIL_PointContents@@YAHABVVector@@@Z:NEAR	; UTIL_PointContents
EXTRN	?ClearMultiDamage@@YAXXZ:NEAR			; ClearMultiDamage
EXTRN	?ApplyMultiDamage@@YAXPAUentvars_s@@0@Z:NEAR	; ApplyMultiDamage
EXTRN	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z:NEAR ; UTIL_FindEntityInSphere
;	COMDAT ?RadiusDamage@@YAXVVector@@PAUentvars_s@@1MMHH@Z
_TEXT	SEGMENT
_vecSrc$ = 8
_pevInflictor$ = 20
_pevAttacker$ = 24
_flDamage$ = 28
_flRadius$ = 32
_iClassIgnore$ = 36
_bitsDamageType$ = 40
_pEntity$ = -4
_tr$ = -60
_flAdjustedDamage$ = -64
_falloff$ = -68
_vecSpot$ = -80
_bInWater$ = -84
$T39503 = -96
$T39504 = -108
$T39506 = -124
$T39507 = -136
?RadiusDamage@@YAXVVector@@PAUentvars_s@@1MMHH@Z PROC NEAR ; RadiusDamage, COMDAT

; 1064 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi

; 1065 : 	CBaseEntity *pEntity = NULL;

	mov	DWORD PTR _pEntity$[ebp], 0

; 1066 : 	TraceResult	tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1067 : 	float		flAdjustedDamage, falloff;
; 1068 : 	Vector		vecSpot;

	lea	ecx, DWORD PTR _vecSpot$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1069 : 
; 1070 : 	if ( flRadius )

	fld	DWORD PTR _flRadius$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38473

; 1071 : 		falloff = flDamage / flRadius;

	fld	DWORD PTR _flDamage$[ebp]
	fdiv	DWORD PTR _flRadius$[ebp]
	fstp	DWORD PTR _falloff$[ebp]

; 1072 : 	else

	jmp	SHORT $L38474
$L38473:

; 1073 : 		falloff = 1.0;

	mov	DWORD PTR _falloff$[ebp], 1065353216	; 3f800000H
$L38474:

; 1074 : 
; 1075 : 	int bInWater = (UTIL_PointContents ( vecSrc ) == CONTENTS_WATER);

	lea	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	call	?UTIL_PointContents@@YAHABVVector@@@Z	; UTIL_PointContents
	add	esp, 4
	xor	ecx, ecx
	cmp	eax, -3					; fffffffdH
	sete	cl
	mov	DWORD PTR _bInWater$[ebp], ecx

; 1076 : 
; 1077 : 	vecSrc.z += 1;// in case grenade is lying on the ground

	fld	DWORD PTR _vecSrc$[ebp+8]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _vecSrc$[ebp+8]

; 1078 : 
; 1079 : 	if ( !pevAttacker )

	cmp	DWORD PTR _pevAttacker$[ebp], 0
	jne	SHORT $L38476

; 1080 : 		pevAttacker = pevInflictor;

	mov	edx, DWORD PTR _pevInflictor$[ebp]
	mov	DWORD PTR _pevAttacker$[ebp], edx
$L38476:

; 1081 : 
; 1082 : 	// iterate on all entities in the vicinity.
; 1083 : 	while ((pEntity = UTIL_FindEntityInSphere( pEntity, vecSrc, flRadius )) != NULL)

	mov	eax, DWORD PTR _flRadius$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z ; UTIL_FindEntityInSphere
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pEntity$[ebp], eax
	cmp	DWORD PTR _pEntity$[ebp], 0
	je	$L38479

; 1085 : 		if ( pEntity->pev->takedamage != DAMAGE_NO )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L38494

; 1087 : 			// UNDONE: this should check a damage mask, not an ignore
; 1088 : 			if ( iClassIgnore != CLASS_NONE && pEntity->Classify() == iClassIgnore )

	cmp	DWORD PTR _iClassIgnore$[ebp], 0
	je	SHORT $L38481
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [eax+68]
	cmp	eax, DWORD PTR _iClassIgnore$[ebp]
	jne	SHORT $L38481

; 1090 : 				continue;

	jmp	SHORT $L38476
$L38481:

; 1092 : 
; 1093 : 			// blast's don't tavel into or out of water
; 1094 : 			if (bInWater && pEntity->pev->waterlevel == 0)

	cmp	DWORD PTR _bInWater$[ebp], 0
	je	SHORT $L38482
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+448], 0
	jne	SHORT $L38482

; 1095 : 				continue;

	jmp	SHORT $L38476
$L38482:

; 1096 : 			if (!bInWater && pEntity->pev->waterlevel == 3)

	cmp	DWORD PTR _bInWater$[ebp], 0
	jne	SHORT $L38483
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+448], 3
	jne	SHORT $L38483

; 1097 : 				continue;

	jmp	$L38476
$L38483:

; 1098 : 
; 1099 : 			vecSpot = pEntity->BodyTarget( vecSrc );

	lea	edx, DWORD PTR _vecSrc$[ebp]
	push	edx
	lea	eax, DWORD PTR $T39503[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+316]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecSpot$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecSpot$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecSpot$[ebp+8], eax

; 1100 : 			
; 1101 : 			UTIL_TraceLine ( vecSrc, vecSpot, dont_ignore_monsters, ENT(pevInflictor), &tr );

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pevInflictor$[ebp]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	0
	lea	eax, DWORD PTR _vecSpot$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 1102 : 
; 1103 : 			if ( tr.flFraction == 1.0 || tr.pHit == pEntity->edict() )

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38486
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	cmp	DWORD PTR _tr$[ebp+48], eax
	jne	$L38494
$L38486:

; 1105 : 				// the explosion can 'see' this entity, so hurt them!
; 1106 : 				if (tr.fStartSolid)

	cmp	DWORD PTR _tr$[ebp+4], 0
	je	SHORT $L38487

; 1108 : 					// if we're stuck inside them, fixup the position and distance
; 1109 : 					tr.vecEndPos = vecSrc;

	mov	edx, DWORD PTR _vecSrc$[ebp]
	mov	DWORD PTR _tr$[ebp+20], edx
	mov	eax, DWORD PTR _vecSrc$[ebp+4]
	mov	DWORD PTR _tr$[ebp+24], eax
	mov	ecx, DWORD PTR _vecSrc$[ebp+8]
	mov	DWORD PTR _tr$[ebp+28], ecx

; 1110 : 					tr.flFraction = 0.0;

	mov	DWORD PTR _tr$[ebp+16], 0
$L38487:

; 1112 : 				
; 1113 : 				// decrease damage for an ent that's farther from the bomb.
; 1114 : 				flAdjustedDamage = ( vecSrc - tr.vecEndPos ).Length() * falloff;

	lea	edx, DWORD PTR _tr$[ebp+20]
	push	edx
	lea	eax, DWORD PTR $T39504[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fmul	DWORD PTR _falloff$[ebp]
	fstp	DWORD PTR _flAdjustedDamage$[ebp]

; 1115 : 				flAdjustedDamage = flDamage - flAdjustedDamage;

	fld	DWORD PTR _flDamage$[ebp]
	fsub	DWORD PTR _flAdjustedDamage$[ebp]
	fstp	DWORD PTR _flAdjustedDamage$[ebp]

; 1116 : 			
; 1117 : 				if ( flAdjustedDamage < 0 )

	fld	DWORD PTR _flAdjustedDamage$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38489

; 1119 : 					flAdjustedDamage = 0;

	mov	DWORD PTR _flAdjustedDamage$[ebp], 0
$L38489:

; 1121 : 			
; 1122 : 				// ALERT( at_console, "hit %s\n", STRING( pEntity->pev->classname ) );
; 1123 : 				if (tr.flFraction != 1.0)

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38490

; 1125 : 					ClearMultiDamage( );

	call	?ClearMultiDamage@@YAXXZ		; ClearMultiDamage

; 1126 : 					pEntity->TraceAttack( pevInflictor, flAdjustedDamage, (tr.vecEndPos - vecSrc).Normalize( ), &tr, bitsDamageType );

	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	lea	eax, DWORD PTR $T39507[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T39506[ebp]
	push	edx
	lea	ecx, DWORD PTR _tr$[ebp+20]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR _flAdjustedDamage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [eax+92]

; 1127 : 					ApplyMultiDamage( pevInflictor, pevAttacker );

	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pevInflictor$[ebp]
	push	edx
	call	?ApplyMultiDamage@@YAXPAUentvars_s@@0@Z	; ApplyMultiDamage
	add	esp, 8

; 1129 : 				else

	jmp	SHORT $L38494
$L38490:

; 1131 : 					pEntity->TakeDamage ( pevInflictor, pevAttacker, flAdjustedDamage, bitsDamageType );

	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flAdjustedDamage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pevAttacker$[ebp]
	push	edx
	mov	eax, DWORD PTR _pevInflictor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+96]
$L38494:

; 1135 : 	}

	jmp	$L38476
$L38479:

; 1136 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RadiusDamage@@YAXVVector@@PAUentvars_s@@1MMHH@Z ENDP	; RadiusDamage
_TEXT	ENDS
PUBLIC	?RadiusDamage@CBaseMonster@@QAEXPAUentvars_s@@0MHH@Z ; CBaseMonster::RadiusDamage
PUBLIC	__real@8@4000a000000000000000
;	COMDAT __real@8@4000a000000000000000
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
__real@8@4000a000000000000000 DQ 04004000000000000r ; 2.5
CONST	ENDS
;	COMDAT ?RadiusDamage@CBaseMonster@@QAEXPAUentvars_s@@0MHH@Z
_TEXT	SEGMENT
_pevInflictor$ = 8
_pevAttacker$ = 12
_flDamage$ = 16
_iClassIgnore$ = 20
_bitsDamageType$ = 24
_this$ = -4
?RadiusDamage@CBaseMonster@@QAEXPAUentvars_s@@0MHH@Z PROC NEAR ; CBaseMonster::RadiusDamage, COMDAT

; 1140 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1141 : 	::RadiusDamage( GetAbsOrigin(), pevInflictor, pevAttacker, flDamage, flDamage * 2.5, iClassIgnore, bitsDamageType );

	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iClassIgnore$[ebp]
	push	ecx
	fld	DWORD PTR _flDamage$[ebp]
	fmul	QWORD PTR __real@8@4000a000000000000000
	fst	DWORD PTR -12+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _flDamage$[ebp]
	push	edx
	mov	eax, DWORD PTR _pevAttacker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?RadiusDamage@@YAXVVector@@PAUentvars_s@@1MMHH@Z ; RadiusDamage
	add	esp, 36					; 00000024H

; 1142 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?RadiusDamage@CBaseMonster@@QAEXPAUentvars_s@@0MHH@Z ENDP ; CBaseMonster::RadiusDamage
_TEXT	ENDS
PUBLIC	?RadiusDamage@CBaseMonster@@QAEXVVector@@PAUentvars_s@@1MHH@Z ; CBaseMonster::RadiusDamage
;	COMDAT ?RadiusDamage@CBaseMonster@@QAEXVVector@@PAUentvars_s@@1MHH@Z
_TEXT	SEGMENT
_vecSrc$ = 8
_pevInflictor$ = 20
_pevAttacker$ = 24
_flDamage$ = 28
_iClassIgnore$ = 32
_bitsDamageType$ = 36
_this$ = -4
?RadiusDamage@CBaseMonster@@QAEXVVector@@PAUentvars_s@@1MHH@Z PROC NEAR ; CBaseMonster::RadiusDamage, COMDAT

; 1146 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1147 : 	::RadiusDamage( vecSrc, pevInflictor, pevAttacker, flDamage, flDamage * 2.5, iClassIgnore, bitsDamageType );

	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iClassIgnore$[ebp]
	push	ecx
	fld	DWORD PTR _flDamage$[ebp]
	fmul	QWORD PTR __real@8@4000a000000000000000
	fst	DWORD PTR -12+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _flDamage$[ebp]
	push	edx
	mov	eax, DWORD PTR _pevAttacker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecSrc$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?RadiusDamage@@YAXVVector@@PAUentvars_s@@1MMHH@Z ; RadiusDamage
	add	esp, 36					; 00000024H

; 1148 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?RadiusDamage@CBaseMonster@@QAEXVVector@@PAUentvars_s@@1MHH@Z ENDP ; CBaseMonster::RadiusDamage
_TEXT	ENDS
PUBLIC	?CheckTraceHullAttack@CBaseMonster@@QAEPAVCBaseEntity@@MHH@Z ; CBaseMonster::CheckTraceHullAttack
PUBLIC	__real@8@3ffe8000000000000000
EXTRN	?UTIL_MakeAimVectors@@YAXABVVector@@@Z:NEAR	; UTIL_MakeAimVectors
;	COMDAT __real@8@3ffe8000000000000000
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
__real@8@3ffe8000000000000000 DQ 03fe0000000000000r ; 0.5
CONST	ENDS
;	COMDAT ?CheckTraceHullAttack@CBaseMonster@@QAEPAVCBaseEntity@@MHH@Z
_TEXT	SEGMENT
$T39518 = -100
$T39519 = -112
_flDist$ = 8
_iDamage$ = 12
_iDmgType$ = 16
_this$ = -4
_tr$ = -60
_vecStart$ = -72
_vecEnd$ = -84
_pEntity$38528 = -88
?CheckTraceHullAttack@CBaseMonster@@QAEPAVCBaseEntity@@MHH@Z PROC NEAR ; CBaseMonster::CheckTraceHullAttack, COMDAT

; 1160 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1161 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1162 : 
; 1163 : 	if (IsPlayer())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L38521

; 1164 : 		UTIL_MakeVectors( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 1165 : 	else

	jmp	SHORT $L38522
$L38521:

; 1166 : 		UTIL_MakeAimVectors( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeAimVectors@@YAXABVVector@@@Z	; UTIL_MakeAimVectors
	add	esp, 4
$L38522:

; 1167 : 
; 1168 : 	Vector vecStart = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1169 : 	vecStart.z += pev->size.z * 0.5;

	fld	DWORD PTR _vecStart$[ebp+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+252]
	fmul	QWORD PTR __real@8@3ffe8000000000000000
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _vecStart$[ebp+8]

; 1170 : 	Vector vecEnd = vecStart + (gpGlobals->v_forward * flDist );

	mov	edx, DWORD PTR _flDist$[ebp]
	push	edx
	lea	eax, DWORD PTR $T39518[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T39519[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1171 : 
; 1172 : 	UTIL_TraceHull( vecStart, vecEnd, dont_ignore_monsters, head_hull, edict(), &tr );

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	3
	push	0
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	push	ecx
	call	?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceHull
	add	esp, 24					; 00000018H

; 1173 : 	
; 1174 : 	if ( tr.pHit )

	cmp	DWORD PTR _tr$[ebp+48], 0
	je	SHORT $L38527

; 1176 : 		CBaseEntity *pEntity = CBaseEntity::Instance( tr.pHit );

	mov	edx, DWORD PTR _tr$[ebp+48]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$38528[ebp], eax

; 1177 : 
; 1178 : 		if ( iDamage > 0 )

	cmp	DWORD PTR _iDamage$[ebp], 0
	jle	SHORT $L38529

; 1180 : 			pEntity->TakeDamage( pev, pev, iDamage, iDmgType );

	mov	eax, DWORD PTR _iDmgType$[ebp]
	push	eax
	fild	DWORD PTR _iDamage$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pEntity$38528[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$38528[ebp]
	call	DWORD PTR [eax+96]
$L38529:

; 1182 : 
; 1183 : 		return pEntity;

	mov	eax, DWORD PTR _pEntity$38528[ebp]
	jmp	SHORT $L38519
$L38527:

; 1185 : 
; 1186 : 	return NULL;

	xor	eax, eax
$L38519:

; 1187 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CheckTraceHullAttack@CBaseMonster@@QAEPAVCBaseEntity@@MHH@Z ENDP ; CBaseMonster::CheckTraceHullAttack
_TEXT	ENDS
PUBLIC	?Normalize@Vector2D@@QBE?AV1@XZ			; Vector2D::Normalize
PUBLIC	?DotProduct@@YAMABVVector2D@@0@Z		; DotProduct
PUBLIC	?Make2D@Vector@@QBE?AVVector2D@@XZ		; Vector::Make2D
PUBLIC	?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z ; CBaseMonster::FInViewCone
PUBLIC	??0Vector2D@@QAE@XZ				; Vector2D::Vector2D
;	COMDAT ?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T39524 = -28
$T39525 = -36
$T39526 = -44
$T39527 = -52
_pEntity$ = 8
_this$ = -4
_vec2LOS$ = -12
_flDot$ = -16
?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z PROC NEAR ; CBaseMonster::FInViewCone, COMDAT

; 1196 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1197 : 	Vector2D	vec2LOS;

	lea	ecx, DWORD PTR _vec2LOS$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 1198 : 	float	flDot;
; 1199 : 
; 1200 : 	UTIL_MakeVectors ( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 1201 : 	
; 1202 : 	vec2LOS = ( pEntity->GetAbsOrigin() - GetAbsOrigin() ).Make2D();

	lea	eax, DWORD PTR $T39525[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T39524[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Make2D@Vector@@QBE?AVVector2D@@XZ	; Vector::Make2D
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _vec2LOS$[ebp], edx
	mov	DWORD PTR _vec2LOS$[ebp+4], eax

; 1203 : 	vec2LOS = vec2LOS.Normalize();

	lea	ecx, DWORD PTR $T39526[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vec2LOS$[ebp]
	call	?Normalize@Vector2D@@QBE?AV1@XZ		; Vector2D::Normalize
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _vec2LOS$[ebp], edx
	mov	DWORD PTR _vec2LOS$[ebp+4], eax

; 1204 : 
; 1205 : 	flDot = DotProduct (vec2LOS , gpGlobals->v_forward.Make2D() );

	lea	ecx, DWORD PTR $T39527[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	?Make2D@Vector@@QBE?AVVector2D@@XZ	; Vector::Make2D
	push	eax
	lea	edx, DWORD PTR _vec2LOS$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector2D@@0@Z	; DotProduct
	add	esp, 8
	fstp	DWORD PTR _flDot$[ebp]

; 1206 : 
; 1207 : 	if ( flDot > m_flFieldOfView )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flDot$[ebp]
	fcomp	DWORD PTR [eax+2056]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38540

; 1209 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L38541
$L38540:

; 1213 : 		return FALSE;

	xor	eax, eax
$L38541:

; 1215 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z ENDP	; CBaseMonster::FInViewCone
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector2D@@QAE@XZ PROC NEAR				; Vector2D::Vector2D, COMDAT

; 57   : 	inline Vector2D(void) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector2D@@QAE@XZ ENDP				; Vector2D::Vector2D
_TEXT	ENDS
PUBLIC	?Length@Vector2D@@QBEMXZ			; Vector2D::Length
PUBLIC	??0Vector2D@@QAE@MM@Z				; Vector2D::Vector2D
;	COMDAT ?Normalize@Vector2D@@QBE?AV1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_vec2$ = -12
_flLen$ = -16
$T39532 = -24
$T39533 = -32
?Normalize@Vector2D@@QBE?AV1@XZ PROC NEAR		; Vector2D::Normalize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		Vector2D vec2;

	lea	ecx, DWORD PTR _vec2$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 105  : 
; 106  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector2D@@QBEMXZ		; Vector2D::Length
	fstp	DWORD PTR _flLen$[ebp]

; 107  : 		if ( flLen == 0 )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L24660

; 109  : 			return Vector2D( 0, 0 );

	push	0
	push	0
	lea	ecx, DWORD PTR $T39532[ebp]
	call	??0Vector2D@@QAE@MM@Z			; Vector2D::Vector2D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L24662
$L24660:

; 113  : 			flLen = 1 / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 114  : 			return Vector2D( x * flLen, y * flLen );

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39533[ebp]
	call	??0Vector2D@@QAE@MM@Z			; Vector2D::Vector2D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L24662:

; 116  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector2D@@QBE?AV1@XZ ENDP			; Vector2D::Normalize
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT
_this$ = -4
_X$ = 8
_Y$ = 12
??0Vector2D@@QAE@MM@Z PROC NEAR				; Vector2D::Vector2D, COMDAT

; 58   : 	inline Vector2D(float X, float Y) { x = X; y = Y; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0Vector2D@@QAE@MM@Z ENDP				; Vector2D::Vector2D
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector2D@@QBEMXZ PROC NEAR			; Vector2D::Length, COMDAT

; 101  : 	inline float Length(void) const { return sqrt(x*x + y*y ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector2D@@QBEMXZ ENDP				; Vector2D::Length
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector2D@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProduct@@YAMABVVector2D@@0@Z PROC NEAR		; DotProduct, COMDAT

; 122  : inline float DotProduct(const Vector2D& a, const Vector2D& b) { return( a.x*b.x + a.y*b.y ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector2D@@0@Z ENDP			; DotProduct
_TEXT	ENDS
;	COMDAT ?Make2D@Vector@@QBE?AVVector2D@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_Vec2$ = -12
?Make2D@Vector@@QBE?AVVector2D@@XZ PROC NEAR		; Vector::Make2D, COMDAT

; 275  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 276  : 		Vector2D	Vec2;

	lea	ecx, DWORD PTR _Vec2$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 277  : 		Vec2.x = x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _Vec2$[ebp], ecx

; 278  : 		Vec2.y = y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _Vec2$[ebp+4], eax

; 279  : 		return Vec2;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _Vec2$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _Vec2$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 280  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Make2D@Vector@@QBE?AVVector2D@@XZ ENDP			; Vector::Make2D
_TEXT	ENDS
PUBLIC	?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z	; CBaseMonster::FInViewCone
;	COMDAT ?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
_TEXT	SEGMENT
$T39544 = -28
$T39545 = -36
$T39546 = -44
$T39547 = -52
_pOrigin$ = 8
_this$ = -4
_vec2LOS$ = -12
_flDot$ = -16
?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z PROC NEAR	; CBaseMonster::FInViewCone, COMDAT

; 1223 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1224 : 	Vector2D	vec2LOS;

	lea	ecx, DWORD PTR _vec2LOS$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 1225 : 	float		flDot;
; 1226 : 
; 1227 : 	UTIL_MakeVectors ( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 1228 : 	
; 1229 : 	vec2LOS = ( *pOrigin - GetAbsOrigin() ).Make2D();

	lea	eax, DWORD PTR $T39545[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T39544[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Make2D@Vector@@QBE?AVVector2D@@XZ	; Vector::Make2D
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _vec2LOS$[ebp], edx
	mov	DWORD PTR _vec2LOS$[ebp+4], eax

; 1230 : 	vec2LOS = vec2LOS.Normalize();

	lea	ecx, DWORD PTR $T39546[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vec2LOS$[ebp]
	call	?Normalize@Vector2D@@QBE?AV1@XZ		; Vector2D::Normalize
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _vec2LOS$[ebp], edx
	mov	DWORD PTR _vec2LOS$[ebp+4], eax

; 1231 : 
; 1232 : 	flDot = DotProduct (vec2LOS , gpGlobals->v_forward.Make2D() );

	lea	ecx, DWORD PTR $T39547[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	?Make2D@Vector@@QBE?AVVector2D@@XZ	; Vector::Make2D
	push	eax
	lea	edx, DWORD PTR _vec2LOS$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector2D@@0@Z	; DotProduct
	add	esp, 8
	fstp	DWORD PTR _flDot$[ebp]

; 1233 : 
; 1234 : 	if ( flDot > m_flFieldOfView )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flDot$[ebp]
	fcomp	DWORD PTR [eax+2056]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38552

; 1236 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L38553
$L38552:

; 1240 : 		return FALSE;

	xor	eax, eax
$L38553:

; 1242 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z ENDP	; CBaseMonster::FInViewCone
_TEXT	ENDS
PUBLIC	?FVisible@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::FVisible
PUBLIC	??_C@_0P@MDCK@monster_target?$AA@		; `string'
EXTRN	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z:NEAR	; FClassnameIs
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
;	COMDAT ??_C@_0P@MDCK@monster_target?$AA@
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
??_C@_0P@MDCK@monster_target?$AA@ DB 'monster_target', 00H ; `string'
CONST	ENDS
;	COMDAT ?FVisible@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
$T39550 = -96
$T39551 = -108
_pEntity$ = 8
_this$ = -4
_tr$ = -60
_vecLookerOrigin$ = -72
_vecTargetOrigin$ = -84
?FVisible@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::FVisible, COMDAT

; 1249 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1250 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1251 : 	Vector vecLookerOrigin;

	lea	ecx, DWORD PTR _vecLookerOrigin$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1252 : 	Vector vecTargetOrigin;

	lea	ecx, DWORD PTR _vecTargetOrigin$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1253 : 	
; 1254 : 	if (FBitSet( pEntity->pev->flags, FL_NOTARGET ))

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 128				; 00000080H
	test	edx, edx
	je	SHORT $L38561

; 1255 : 		return FALSE;

	xor	eax, eax
	jmp	$L38570
$L38561:

; 1256 : 
; 1257 : 	// don't look through water
; 1258 : 	if(( pev->waterlevel != 3 && pEntity->pev->waterlevel == 3 ) || ( pev->waterlevel == 3 && pEntity->pev->waterlevel == 0 ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+448], 3
	je	SHORT $L38564
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+448], 3
	je	SHORT $L38563
$L38564:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+448], 3
	jne	SHORT $L38562
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+448], 0
	jne	SHORT $L38562
$L38563:

; 1259 : 		return FALSE;

	xor	eax, eax
	jmp	$L38570
$L38562:

; 1260 : 
; 1261 : 	vecLookerOrigin = EyePosition(); // look through the caller's 'eyes'

	lea	edx, DWORD PTR $T39550[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+308]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecLookerOrigin$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecLookerOrigin$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecLookerOrigin$[ebp+8], eax

; 1262 : 	vecTargetOrigin = pEntity->EyePosition();

	lea	ecx, DWORD PTR $T39551[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [eax+308]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecTargetOrigin$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecTargetOrigin$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecTargetOrigin$[ebp+8], eax

; 1263 : 
; 1264 : 	UTIL_TraceLine(vecLookerOrigin, vecTargetOrigin, ignore_monsters, ignore_glass, ENT(pev)/*pentIgnore*/, &tr);

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	push	1
	lea	ecx, DWORD PTR _vecTargetOrigin$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecLookerOrigin$[ebp]
	push	edx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 24					; 00000018H

; 1265 : 
; 1266 : 	if( FClassnameIs( pEntity, "monster_target" ) && tr.fInOpen )

	push	OFFSET FLAT:??_C@_0P@MDCK@monster_target?$AA@ ; `string'
	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L38567
	cmp	DWORD PTR _tr$[ebp+8], 0
	je	SHORT $L38567

; 1267 : 		return TRUE; // monster_target can't be tracelined as well

	mov	eax, 1
	jmp	SHORT $L38570
$L38567:

; 1268 : 	
; 1269 : 	if( tr.flFraction != 1.0 )//&& tr.pHit != ENT( pEntity->pev ))

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38569

; 1271 : 		return FALSE;// Line of sight is not established

	xor	eax, eax
	jmp	SHORT $L38570
$L38569:

; 1275 : 		return TRUE;// line of sight is valid.

	mov	eax, 1
$L38570:

; 1277 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FVisible@CBaseEntity@@UAEHPAV1@@Z ENDP			; CBaseEntity::FVisible
_TEXT	ENDS
PUBLIC	?FVisible@CBaseEntity@@UAEHABVVector@@@Z	; CBaseEntity::FVisible
;	COMDAT ?FVisible@CBaseEntity@@UAEHABVVector@@@Z
_TEXT	SEGMENT
$T39554 = -84
_vecOrigin$ = 8
_this$ = -4
_tr$ = -60
_vecLookerOrigin$ = -72
?FVisible@CBaseEntity@@UAEHABVVector@@@Z PROC NEAR	; CBaseEntity::FVisible, COMDAT

; 1284 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1285 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1286 : 	Vector		vecLookerOrigin;

	lea	ecx, DWORD PTR _vecLookerOrigin$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1287 : 	
; 1288 : 	vecLookerOrigin = EyePosition();//look through the caller's 'eyes'

	lea	eax, DWORD PTR $T39554[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+308]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecLookerOrigin$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecLookerOrigin$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecLookerOrigin$[ebp+8], eax

; 1289 : 
; 1290 : 	UTIL_TraceLine(vecLookerOrigin, vecOrigin, ignore_monsters, ignore_glass, ENT(pev)/*pentIgnore*/, &tr);

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	push	1
	mov	ecx, DWORD PTR _vecOrigin$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecLookerOrigin$[ebp]
	push	edx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 24					; 00000018H

; 1291 : 	
; 1292 : 	if (tr.flFraction != 1.0)

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38578

; 1294 : 		return FALSE;// Line of sight is not established

	xor	eax, eax
	jmp	SHORT $L38579
$L38578:

; 1298 : 		return TRUE;// line of sight is valid.

	mov	eax, 1
$L38579:

; 1300 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FVisible@CBaseEntity@@UAEHABVVector@@@Z ENDP		; CBaseEntity::FVisible
_TEXT	ENDS
PUBLIC	?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z ; CBaseEntity::TraceAttack
EXTRN	?AddMultiDamage@@YAXPAUentvars_s@@PAVCBaseEntity@@MH@Z:NEAR ; AddMultiDamage
EXTRN	?SpawnBlood@@YAXVVector@@HM@Z:NEAR		; SpawnBlood
;	COMDAT ?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
_TEXT	SEGMENT
$T39557 = -32
$T39558 = -44
_pevAttacker$ = 8
_flDamage$ = 12
_vecDir$ = 16
_ptr$ = 28
_bitsDamageType$ = 32
_this$ = -4
_vecOrigin$ = -16
_blood$38592 = -20
?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z PROC NEAR ; CBaseEntity::TraceAttack, COMDAT

; 1308 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1309 : 	Vector vecOrigin = ptr->vecEndPos - vecDir * 4;

	push	1082130432				; 40800000H
	lea	eax, DWORD PTR $T39557[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T39558[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 20					; 00000014H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecOrigin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1310 : 
; 1311 : 	if ( pev->takedamage )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38593

; 1313 : 		AddMultiDamage( pevAttacker, this, flDamage, bitsDamageType );

	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flDamage$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	call	?AddMultiDamage@@YAXPAUentvars_s@@PAVCBaseEntity@@MH@Z ; AddMultiDamage
	add	esp, 16					; 00000010H

; 1314 : 
; 1315 : 		int blood = BloodColor();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+112]
	mov	DWORD PTR _blood$38592[ebp], eax

; 1316 : 		
; 1317 : 		if ( blood != DONT_BLEED )

	cmp	DWORD PTR _blood$38592[ebp], -1
	je	SHORT $L38593

; 1319 : 			SpawnBlood(vecOrigin, blood, flDamage);// a little surface blood.

	mov	ecx, DWORD PTR _flDamage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _blood$38592[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecOrigin$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?SpawnBlood@@YAXVVector@@HM@Z		; SpawnBlood
	add	esp, 20					; 00000014H

; 1320 : 			TraceBleed( flDamage, vecDir, ptr, bitsDamageType );

	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecDir$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _flDamage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+116]
$L38593:

; 1323 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z ENDP ; CBaseEntity::TraceAttack
_TEXT	ENDS
PUBLIC	?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z ; CBaseMonster::TraceAttack
EXTRN	?gSkillData@@3Uskilldata_t@@A:BYTE		; gSkillData
;	COMDAT ?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
_TEXT	SEGMENT
_pevAttacker$ = 8
_flDamage$ = 12
_vecDir$ = 16
_ptr$ = 28
_bitsDamageType$ = 32
_this$ = -4
?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z PROC NEAR ; CBaseMonster::TraceAttack, COMDAT

; 1355 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1356 : 	if ( pev->takedamage )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L38604

; 1358 : 		m_LastHitGroup = ptr->iHitgroup;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+2076], ecx

; 1361 : 		{

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR -16+[ebp], eax
	mov	ecx, DWORD PTR -16+[ebp]
	sub	ecx, 1
	mov	DWORD PTR -16+[ebp], ecx
	cmp	DWORD PTR -16+[ebp], 6
	ja	SHORT $L38615
	mov	edx, DWORD PTR -16+[ebp]
	jmp	DWORD PTR $L39565[edx*4]
$L38610:

; 1362 : 		case HITGROUP_GENERIC:
; 1363 : 			break;
; 1364 : 		case HITGROUP_HEAD:
; 1365 : 			flDamage *= gSkillData.monHead;

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+320
	fstp	DWORD PTR _flDamage$[ebp]

; 1366 : 			break;

	jmp	SHORT $L38606
$L38611:

; 1367 : 		case HITGROUP_CHEST:
; 1368 : 			flDamage *= gSkillData.monChest;

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+324
	fstp	DWORD PTR _flDamage$[ebp]

; 1369 : 			break;

	jmp	SHORT $L38606
$L38612:

; 1370 : 		case HITGROUP_STOMACH:
; 1371 : 			flDamage *= gSkillData.monStomach;

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+328
	fstp	DWORD PTR _flDamage$[ebp]

; 1372 : 			break;

	jmp	SHORT $L38606
$L38613:

; 1373 : 		case HITGROUP_LEFTARM:
; 1374 : 		case HITGROUP_RIGHTARM:
; 1375 : 			flDamage *= gSkillData.monArm;

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+336
	fstp	DWORD PTR _flDamage$[ebp]

; 1376 : 			break;

	jmp	SHORT $L38606
$L38614:

; 1377 : 		case HITGROUP_LEFTLEG:
; 1378 : 		case HITGROUP_RIGHTLEG:
; 1379 : 			flDamage *= gSkillData.monLeg;

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+332
	fstp	DWORD PTR _flDamage$[ebp]
$L38615:
$L38606:

; 1384 : 
; 1385 : 		SpawnBlood(ptr->vecEndPos, BloodColor(), flDamage);// a little surface blood.

	mov	eax, DWORD PTR _flDamage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+112]
	push	eax
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 20					; 00000014H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?SpawnBlood@@YAXVVector@@HM@Z		; SpawnBlood
	add	esp, 20					; 00000014H

; 1386 : 		TraceBleed( flDamage, vecDir, ptr, bitsDamageType );

	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecDir$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _flDamage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+116]

; 1387 : 		AddMultiDamage( pevAttacker, this, flDamage, bitsDamageType );

	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flDamage$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	call	?AddMultiDamage@@YAXPAUentvars_s@@PAVCBaseEntity@@MH@Z ; AddMultiDamage
	add	esp, 16					; 00000010H
$L38604:

; 1389 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L39565:
	DD	$L38610
	DD	$L38611
	DD	$L38612
	DD	$L38613
	DD	$L38613
	DD	$L38614
	DD	$L38614
?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z ENDP ; CBaseMonster::TraceAttack
_TEXT	ENDS
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	??D@YA?AVVector@@MABV0@@Z			; operator*
PUBLIC	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z		; MESSAGE_BEGIN
PUBLIC	__real@8@40058000000000000000
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
PUBLIC	?FNullEnt@@YAHPBUedict_s@@@Z			; FNullEnt
PUBLIC	?FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z ; CBaseEntity::FireBullets
EXTRN	?UTIL_DecalTrace@@YAXPAUgametrace_s@@H@Z:NEAR	; UTIL_DecalTrace
EXTRN	?UTIL_BubbleTrail@@YAXVVector@@0H@Z:NEAR	; UTIL_BubbleTrail
EXTRN	?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z:NEAR ; TEXTURETYPE_PlaySound
EXTRN	?DecalGunshot@@YAXPAUgametrace_s@@H@Z:NEAR	; DecalGunshot
EXTRN	?gMultiDamage@@3UMULTIDAMAGE@@A:BYTE		; gMultiDamage
_BSS	SEGMENT
	ALIGN	4

_?tracerCount@?1??FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z@4HA DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@8@40058000000000000000
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
__real@8@40058000000000000000 DQ 04050000000000000r ; 64
CONST	ENDS
;	COMDAT ?FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z
_TEXT	SEGMENT
$T39568 = -156
$T39569 = -168
$T39570 = -180
$T39571 = -192
$T39572 = -204
$T39573 = -216
$T39574 = -228
$T39575 = -240
$T39576 = -252
$T39577 = -264
$T39578 = -276
$T39579 = -288
_cShots$ = 8
_vecSrc$ = 12
_vecDirShooting$ = 24
_vecSpread$ = 36
_flDistance$ = 48
_iBulletType$ = 52
_iTracerFreq$ = 56
_iDamage$ = 60
_pevAttacker$ = 64
_this$ = -4
_tracer$ = -8
_tr$ = -64
_vecRight$ = -76
_vecUp$ = -88
_iShot$ = -92
_x$38641 = -96
_y$38642 = -100
_z$38643 = -104
_vecDir$38647 = -116
_vecEnd$38652 = -128
_vecTracerSrc$38656 = -140
_pEntity$38672 = -144
?FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z PROC NEAR ; CBaseEntity::FireBullets, COMDAT

; 1401 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 484				; 000001e4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1402 : 	static int tracerCount;
; 1403 : 	int tracer;
; 1404 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1405 : 	Vector vecRight = gpGlobals->v_right;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	eax, 64					; 00000040H
	push	eax
	lea	ecx, DWORD PTR _vecRight$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1406 : 	Vector vecUp = gpGlobals->v_up;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 52					; 00000034H
	push	ecx
	lea	ecx, DWORD PTR _vecUp$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1407 : 
; 1408 : 	if ( pevAttacker == NULL )

	cmp	DWORD PTR _pevAttacker$[ebp], 0
	jne	SHORT $L38636

; 1409 : 		pevAttacker = pev;  // the default attacker is ourselves

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _pevAttacker$[ebp], eax
$L38636:

; 1410 : 
; 1411 : 	ClearMultiDamage();

	call	?ClearMultiDamage@@YAXXZ		; ClearMultiDamage

; 1412 : 	gMultiDamage.type = DMG_BULLET | DMG_NEVERGIB;

	mov	DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A+8, 4098 ; 00001002H

; 1413 : 
; 1414 : 	for (ULONG iShot = 1; iShot <= cShots; iShot++)

	mov	DWORD PTR _iShot$[ebp], 1
	jmp	SHORT $L38638
$L38639:
	mov	ecx, DWORD PTR _iShot$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iShot$[ebp], ecx
$L38638:
	mov	edx, DWORD PTR _iShot$[ebp]
	cmp	edx, DWORD PTR _cShots$[ebp]
	ja	$L38640
$L38644:

; 1419 : 			x = RANDOM_FLOAT(-0.5,0.5) + RANDOM_FLOAT(-0.5,0.5);

	push	1056964608				; 3f000000H
	push	-1090519040				; bf000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	fstp	DWORD PTR -408+[ebp]
	add	esp, 8
	push	1056964608				; 3f000000H
	push	-1090519040				; bf000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR -408+[ebp]
	fstp	DWORD PTR _x$38641[ebp]

; 1420 : 			y = RANDOM_FLOAT(-0.5,0.5) + RANDOM_FLOAT(-0.5,0.5);

	push	1056964608				; 3f000000H
	push	-1090519040				; bf000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	fstp	DWORD PTR -412+[ebp]
	add	esp, 8
	push	1056964608				; 3f000000H
	push	-1090519040				; bf000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR -412+[ebp]
	fstp	DWORD PTR _y$38642[ebp]

; 1421 : 			z = x*x+y*y;

	fld	DWORD PTR _x$38641[ebp]
	fmul	DWORD PTR _x$38641[ebp]
	fld	DWORD PTR _y$38642[ebp]
	fmul	DWORD PTR _y$38642[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _z$38643[ebp]

; 1422 : 		} while (z > 1);

	fld	DWORD PTR _z$38643[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L38644

; 1423 : 
; 1424 : 		Vector vecDir = vecDirShooting +
; 1425 : 						x * vecSpread.x * vecRight +
; 1426 : 						y * vecSpread.y * vecUp;

	lea	eax, DWORD PTR _vecUp$[ebp]
	push	eax
	fld	DWORD PTR _y$38642[ebp]
	fmul	DWORD PTR _vecSpread$[ebp+4]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39570[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T39571[ebp]
	push	edx
	lea	eax, DWORD PTR _vecRight$[ebp]
	push	eax
	fld	DWORD PTR _x$38641[ebp]
	fmul	DWORD PTR _vecSpread$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39568[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T39569[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecDirShooting$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecDir$38647[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1427 : 		Vector vecEnd;

	lea	ecx, DWORD PTR _vecEnd$38652[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1428 : 
; 1429 : 		vecEnd = vecSrc + vecDir * flDistance;

	mov	eax, DWORD PTR _flDistance$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T39572[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecDir$38647[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T39573[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecEnd$38652[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecEnd$38652[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecEnd$38652[ebp+8], eax

; 1430 : 		UTIL_TraceLine(vecSrc, vecEnd, dont_ignore_monsters, ENT(pev)/*pentIgnore*/, &tr);

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	0
	lea	ecx, DWORD PTR _vecEnd$38652[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecSrc$[ebp]
	push	edx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 1431 : 
; 1432 : 		tracer = 0;

	mov	DWORD PTR _tracer$[ebp], 0

; 1433 : 		if (iTracerFreq != 0 && (tracerCount++ % iTracerFreq) == 0)

	cmp	DWORD PTR _iTracerFreq$[ebp], 0
	je	$L38667
	mov	eax, DWORD PTR _?tracerCount@?1??FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z@4HA
	cdq
	idiv	DWORD PTR _iTracerFreq$[ebp]
	mov	eax, DWORD PTR _?tracerCount@?1??FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z@4HA
	add	eax, 1
	mov	DWORD PTR _?tracerCount@?1??FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z@4HA, eax
	test	edx, edx
	jne	$L38667

; 1435 : 			Vector vecTracerSrc;

	lea	ecx, DWORD PTR _vecTracerSrc$38656[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1436 : 
; 1437 : 			if ( IsPlayer() )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	$L38657

; 1439 : 				vecTracerSrc = vecSrc + Vector ( 0 , 0 , -4 ) + gpGlobals->v_right * 2 + gpGlobals->v_forward * 16;

	push	1098907648				; 41800000H
	lea	eax, DWORD PTR $T39578[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T39579[ebp]
	push	ecx
	push	1073741824				; 40000000H
	lea	edx, DWORD PTR $T39576[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T39577[ebp]
	push	eax
	push	-1065353216				; c0800000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T39574[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T39575[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecTracerSrc$38656[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecTracerSrc$38656[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecTracerSrc$38656[ebp+8], edx

; 1441 : 			else

	jmp	SHORT $L38664
$L38657:

; 1443 : 				vecTracerSrc = vecSrc;

	mov	eax, DWORD PTR _vecSrc$[ebp]
	mov	DWORD PTR _vecTracerSrc$38656[ebp], eax
	mov	ecx, DWORD PTR _vecSrc$[ebp+4]
	mov	DWORD PTR _vecTracerSrc$38656[ebp+4], ecx
	mov	edx, DWORD PTR _vecSrc$[ebp+8]
	mov	DWORD PTR _vecTracerSrc$38656[ebp+8], edx
$L38664:

; 1445 : 			
; 1446 : 			if ( iTracerFreq != 1 )		// guns that always trace also always decal

	cmp	DWORD PTR _iTracerFreq$[ebp], 1
	je	SHORT $L38665

; 1447 : 				tracer = 1;

	mov	DWORD PTR _tracer$[ebp], 1
$L38665:

; 1449 : 			{

	mov	eax, DWORD PTR _iBulletType$[ebp]
	mov	DWORD PTR -416+[ebp], eax

; 1450 : 			case BULLET_MONSTER_MP5:
; 1451 : 			case BULLET_MONSTER_9MM:
; 1452 : 			case BULLET_MONSTER_12MM:
; 1453 : 			default:
; 1454 : 				MESSAGE_BEGIN( MSG_PAS, SVC_TEMPENTITY, vecTracerSrc );

	push	0
	lea	ecx, DWORD PTR _vecTracerSrc$38656[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	push	23					; 00000017H
	push	5
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1455 : 					WRITE_BYTE( TE_TRACER );

	push	6
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1456 : 					WRITE_COORD( vecTracerSrc.x );

	mov	ecx, DWORD PTR _vecTracerSrc$38656[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1457 : 					WRITE_COORD( vecTracerSrc.y );

	mov	edx, DWORD PTR _vecTracerSrc$38656[ebp+4]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1458 : 					WRITE_COORD( vecTracerSrc.z );

	mov	eax, DWORD PTR _vecTracerSrc$38656[ebp+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1459 : 					WRITE_COORD( tr.vecEndPos.x );

	mov	ecx, DWORD PTR _tr$[ebp+20]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1460 : 					WRITE_COORD( tr.vecEndPos.y );

	mov	edx, DWORD PTR _tr$[ebp+24]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1461 : 					WRITE_COORD( tr.vecEndPos.z );

	mov	eax, DWORD PTR _tr$[ebp+28]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1462 : 				MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L38667:

; 1466 : 		// do damage, paint decals
; 1467 : 		if (tr.flFraction != 1.0)

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L38679

; 1469 : 			CBaseEntity *pEntity = CBaseEntity::Instance(tr.pHit);

	mov	ecx, DWORD PTR _tr$[ebp+48]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$38672[ebp], eax

; 1470 : 
; 1471 : 			if ( iDamage )

	cmp	DWORD PTR _iDamage$[ebp], 0
	je	$L38673

; 1473 : 				pEntity->TraceAttack(pevAttacker, iDamage, vecDir, &tr, DMG_BULLET | ((iDamage > 16) ? DMG_ALWAYSGIB : DMG_NEVERGIB) );

	xor	edx, edx
	cmp	DWORD PTR _iDamage$[ebp], 16		; 00000010H
	setle	dl
	dec	edx
	and	edx, 4096				; 00001000H
	add	edx, 4096				; 00001000H
	or	edx, 2
	push	edx
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecDir$38647[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	fild	DWORD PTR _iDamage$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _pevAttacker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$38672[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$38672[ebp]
	call	DWORD PTR [edx+92]

; 1474 : 				
; 1475 : 				TEXTURETYPE_PlaySound(&tr, vecSrc, vecEnd, iBulletType);

	mov	eax, DWORD PTR _iBulletType$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecEnd$38652[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z ; TEXTURETYPE_PlaySound
	fstp	ST(0)
	add	esp, 32					; 00000020H

; 1476 : 				DecalGunshot( &tr, iBulletType );

	mov	edx, DWORD PTR _iBulletType$[ebp]
	push	edx
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	call	?DecalGunshot@@YAXPAUgametrace_s@@H@Z	; DecalGunshot
	add	esp, 8

; 1478 : 			else switch(iBulletType)

	jmp	$L38679
$L38673:

; 1479 : 			{

	mov	ecx, DWORD PTR _iBulletType$[ebp]
	mov	DWORD PTR -420+[ebp], ecx
	cmp	DWORD PTR -420+[ebp], 8
	ja	SHORT $L38682
	mov	edx, DWORD PTR -420+[ebp]
	jmp	DWORD PTR $L39611[edx*4]
$L38682:

; 1480 : 			default:
; 1481 : 			case BULLET_MONSTER_9MM:
; 1482 : 				pEntity->TraceAttack(pevAttacker, gSkillData.monDmg9MM, vecDir, &tr, DMG_BULLET);

	push	2
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecDir$38647[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ?gSkillData@@3Uskilldata_t@@A+284
	push	eax
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$38672[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$38672[ebp]
	call	DWORD PTR [eax+92]

; 1483 : 				if ( !tracer )

	cmp	DWORD PTR _tracer$[ebp], 0
	jne	SHORT $L38684

; 1485 : 					TEXTURETYPE_PlaySound(&tr, vecSrc, vecEnd, iBulletType);

	mov	ecx, DWORD PTR _iBulletType$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecEnd$38652[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z ; TEXTURETYPE_PlaySound
	fstp	ST(0)
	add	esp, 32					; 00000020H

; 1486 : 					DecalGunshot( &tr, iBulletType );

	mov	edx, DWORD PTR _iBulletType$[ebp]
	push	edx
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	call	?DecalGunshot@@YAXPAUgametrace_s@@H@Z	; DecalGunshot
	add	esp, 8
$L38684:

; 1488 : 				break;

	jmp	$L38679
$L38687:

; 1489 : 
; 1490 : 			case BULLET_MONSTER_MP5:
; 1491 : 				pEntity->TraceAttack(pevAttacker, gSkillData.monDmgMP5, vecDir, &tr, DMG_BULLET);

	push	2
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecDir$38647[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ?gSkillData@@3Uskilldata_t@@A+288
	push	eax
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$38672[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$38672[ebp]
	call	DWORD PTR [eax+92]

; 1492 : 				if ( !tracer )

	cmp	DWORD PTR _tracer$[ebp], 0
	jne	SHORT $L38689

; 1494 : 					TEXTURETYPE_PlaySound(&tr, vecSrc, vecEnd, iBulletType);

	mov	ecx, DWORD PTR _iBulletType$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecEnd$38652[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z ; TEXTURETYPE_PlaySound
	fstp	ST(0)
	add	esp, 32					; 00000020H

; 1495 : 					DecalGunshot( &tr, iBulletType );

	mov	edx, DWORD PTR _iBulletType$[ebp]
	push	edx
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	call	?DecalGunshot@@YAXPAUgametrace_s@@H@Z	; DecalGunshot
	add	esp, 8
$L38689:

; 1497 : 				break;

	jmp	$L38679
$L38692:

; 1498 : 
; 1499 : 			case BULLET_MONSTER_12MM:		
; 1500 : 				pEntity->TraceAttack(pevAttacker, gSkillData.monDmg12MM, vecDir, &tr, DMG_BULLET); 

	push	2
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecDir$38647[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ?gSkillData@@3Uskilldata_t@@A+292
	push	eax
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$38672[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$38672[ebp]
	call	DWORD PTR [eax+92]

; 1501 : 				if ( !tracer )

	cmp	DWORD PTR _tracer$[ebp], 0
	jne	SHORT $L38694

; 1503 : 					TEXTURETYPE_PlaySound(&tr, vecSrc, vecEnd, iBulletType);

	mov	ecx, DWORD PTR _iBulletType$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecEnd$38652[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z ; TEXTURETYPE_PlaySound
	fstp	ST(0)
	add	esp, 32					; 00000020H

; 1504 : 					DecalGunshot( &tr, iBulletType );

	mov	edx, DWORD PTR _iBulletType$[ebp]
	push	edx
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	call	?DecalGunshot@@YAXPAUgametrace_s@@H@Z	; DecalGunshot
	add	esp, 8
$L38694:

; 1506 : 				break;

	jmp	$L38679
$L38697:

; 1507 : 
; 1508 : 			case BULLET_PLAYER_357:
; 1509 : 				pEntity->TraceAttack(pevAttacker, gSkillData.plrDmg357, vecDir, &tr, DMG_BULLET);

	push	2
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecDir$38647[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ?gSkillData@@3Uskilldata_t@@A+228
	push	eax
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$38672[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$38672[ebp]
	call	DWORD PTR [eax+92]

; 1510 : 				if ( !tracer )

	cmp	DWORD PTR _tracer$[ebp], 0
	jne	SHORT $L38699

; 1512 : 					TEXTURETYPE_PlaySound(&tr, vecSrc, vecEnd, iBulletType);

	mov	ecx, DWORD PTR _iBulletType$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecEnd$38652[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z ; TEXTURETYPE_PlaySound
	fstp	ST(0)
	add	esp, 32					; 00000020H

; 1513 : 					DecalGunshot( &tr, iBulletType );

	mov	edx, DWORD PTR _iBulletType$[ebp]
	push	edx
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	call	?DecalGunshot@@YAXPAUgametrace_s@@H@Z	; DecalGunshot
	add	esp, 8
$L38699:

; 1515 : 				break;

	jmp	$L38679
$L38702:

; 1516 : 
; 1517 : 			case BULLET_PLAYER_9MM:		
; 1518 : 				pEntity->TraceAttack(pevAttacker, gSkillData.plrDmg9MM, vecDir, &tr, DMG_BULLET); 

	push	2
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecDir$38647[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ?gSkillData@@3Uskilldata_t@@A+224
	push	eax
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$38672[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$38672[ebp]
	call	DWORD PTR [eax+92]

; 1519 : 				if ( !tracer )

	cmp	DWORD PTR _tracer$[ebp], 0
	jne	SHORT $L38704

; 1521 : 					TEXTURETYPE_PlaySound(&tr, vecSrc, vecEnd, iBulletType);

	mov	ecx, DWORD PTR _iBulletType$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecEnd$38652[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z ; TEXTURETYPE_PlaySound
	fstp	ST(0)
	add	esp, 32					; 00000020H

; 1522 : 					DecalGunshot( &tr, iBulletType );

	mov	edx, DWORD PTR _iBulletType$[ebp]
	push	edx
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	call	?DecalGunshot@@YAXPAUgametrace_s@@H@Z	; DecalGunshot
	add	esp, 8
$L38704:

; 1524 : 				break;

	jmp	$L38679
$L38707:

; 1525 : 
; 1526 : 			case BULLET_PLAYER_MP5:		
; 1527 : 				pEntity->TraceAttack(pevAttacker, gSkillData.plrDmgMP5, vecDir, &tr, DMG_BULLET); 

	push	2
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecDir$38647[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ?gSkillData@@3Uskilldata_t@@A+232
	push	eax
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$38672[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$38672[ebp]
	call	DWORD PTR [eax+92]

; 1528 : 				if ( !tracer )

	cmp	DWORD PTR _tracer$[ebp], 0
	jne	SHORT $L38709

; 1530 : 					TEXTURETYPE_PlaySound(&tr, vecSrc, vecEnd, iBulletType);

	mov	ecx, DWORD PTR _iBulletType$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecEnd$38652[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z ; TEXTURETYPE_PlaySound
	fstp	ST(0)
	add	esp, 32					; 00000020H

; 1531 : 					DecalGunshot( &tr, iBulletType );

	mov	edx, DWORD PTR _iBulletType$[ebp]
	push	edx
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	call	?DecalGunshot@@YAXPAUgametrace_s@@H@Z	; DecalGunshot
	add	esp, 8
$L38709:

; 1533 : 				break;

	jmp	$L38679
$L38712:

; 1534 : 
; 1535 : 			case BULLET_PLAYER_BUCKSHOT:	
; 1536 : 				 // make distance based!
; 1537 : 				pEntity->TraceAttack(pevAttacker, gSkillData.plrDmgBuckshot, vecDir, &tr, DMG_BULLET); 

	push	2
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecDir$38647[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ?gSkillData@@3Uskilldata_t@@A+240
	push	eax
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$38672[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$38672[ebp]
	call	DWORD PTR [eax+92]

; 1538 : 				if ( !tracer )

	cmp	DWORD PTR _tracer$[ebp], 0
	jne	SHORT $L38714

; 1540 : 					TEXTURETYPE_PlaySound(&tr, vecSrc, vecEnd, iBulletType);

	mov	ecx, DWORD PTR _iBulletType$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecEnd$38652[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z ; TEXTURETYPE_PlaySound
	fstp	ST(0)
	add	esp, 32					; 00000020H

; 1541 : 					DecalGunshot( &tr, iBulletType );

	mov	edx, DWORD PTR _iBulletType$[ebp]
	push	edx
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	call	?DecalGunshot@@YAXPAUgametrace_s@@H@Z	; DecalGunshot
	add	esp, 8
$L38714:

; 1543 : 				break;

	jmp	$L38679
$L38717:

; 1544 : 			
; 1545 : 			case BULLET_NONE: // FIX 
; 1546 : 				pEntity->TraceAttack(pevAttacker, 50, vecDir, &tr, DMG_CLUB);

	push	128					; 00000080H
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecDir$38647[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	push	1112014848				; 42480000H
	mov	eax, DWORD PTR _pevAttacker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$38672[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$38672[ebp]
	call	DWORD PTR [edx+92]

; 1547 : 				TEXTURETYPE_PlaySound(&tr, vecSrc, vecEnd, iBulletType);

	mov	eax, DWORD PTR _iBulletType$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecEnd$38652[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z ; TEXTURETYPE_PlaySound
	fstp	ST(0)
	add	esp, 32					; 00000020H

; 1548 : 				// only decal glass
; 1549 : 				if ( !FNullEnt(tr.pHit) && VARS(tr.pHit)->rendermode != 0)

	mov	edx, DWORD PTR _tr$[ebp+48]
	push	edx
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L38721
	mov	eax, DWORD PTR _tr$[ebp+48]
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	cmp	DWORD PTR [eax+328], 0
	je	SHORT $L38721

; 1551 : 					UTIL_DecalTrace( &tr, DECAL_GLASSBREAK1 + RANDOM_LONG(0,2) );

	push	2
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 25					; 00000019H
	push	eax
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	?UTIL_DecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_DecalTrace
	add	esp, 8
$L38721:
$L38679:

; 1557 : 		// make bullet trails
; 1558 : 		UTIL_BubbleTrail( vecSrc, tr.vecEndPos, (flDistance * tr.flFraction) / 64.0 );

	fld	DWORD PTR _flDistance$[ebp]
	fmul	DWORD PTR _tr$[ebp+16]
	fdiv	QWORD PTR __real@8@40058000000000000000
	call	__ftol
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _tr$[ebp+20]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?UTIL_BubbleTrail@@YAXVVector@@0H@Z	; UTIL_BubbleTrail
	add	esp, 28					; 0000001cH

; 1559 : 	}

	jmp	$L38639
$L38640:

; 1560 : 	ApplyMultiDamage(pev, pevAttacker);

	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ApplyMultiDamage@@YAXPAUentvars_s@@0@Z	; ApplyMultiDamage
	add	esp, 8

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	60					; 0000003cH
$L39611:
	DD	$L38717
	DD	$L38702
	DD	$L38707
	DD	$L38697
	DD	$L38712
	DD	$L38682
	DD	$L38682
	DD	$L38687
	DD	$L38692
?FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z ENDP ; CBaseEntity::FireBullets
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT
_fl$ = 12
_v$ = 16
___$ReturnUdt$ = 8
$T39616 = -12
??D@YA?AVVector@@MABV0@@Z PROC NEAR			; operator*, COMDAT

; 288  : inline Vector operator* ( float fl, const Vector& v ) { return v * fl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T39616[ebp]
	push	ecx
	mov	ecx, DWORD PTR _v$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??D@YA?AVVector@@MABV0@@Z ENDP				; operator*
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_type$ = 12
_pOrigin$ = 16
_ed$ = 20
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z PROC NEAR	; MESSAGE_BEGIN, COMDAT

; 72   : inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin = NULL, edict_t *ed = NULL ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 73   : 	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ed);

	mov	eax, DWORD PTR _ed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+184
	add	esp, 16					; 00000010H

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z ENDP		; MESSAGE_BEGIN
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC NEAR		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32448

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L32447
$L32448:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$L32447:

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?FNullEnt@@YAHPBUedict_s@@@Z PROC NEAR			; FNullEnt, COMDAT

; 195  : inline BOOL FNullEnt(const edict_t* pent)	{ return pent == NULL || FNullEnt(OFFSET(pent)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L39623
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39623
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L39624
$L39623:
	mov	DWORD PTR -4+[ebp], 1
$L39624:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPBUedict_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	__real@4@4002a000000000000000
PUBLIC	__real@4@4003c800000000000000
PUBLIC	?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z ; CBaseEntity::TraceBleed
;	COMDAT __real@4@4002a000000000000000
; File z:\xashxtsrc\server\combat.cpp
CONST	SEGMENT
__real@4@4002a000000000000000 DD 041200000r	; 10
CONST	ENDS
;	COMDAT __real@4@4003c800000000000000
CONST	SEGMENT
__real@4@4003c800000000000000 DD 041c80000r	; 25
CONST	ENDS
;	COMDAT ?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
_TEXT	SEGMENT
$T39627 = -96
$T39628 = -108
$T39629 = -120
_flDamage$ = 8
_vecDir$ = 12
_ptr$ = 24
_bitsDamageType$ = 28
_this$ = -4
_Bloodtr$ = -60
_vecTraceDir$ = -72
_flNoise$ = -76
_cCount$ = -80
_i$ = -84
?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z PROC NEAR ; CBaseEntity::TraceBleed, COMDAT

; 1564 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1565 : 	if (BloodColor() == DONT_BLEED)

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+112]
	cmp	eax, -1
	jne	SHORT $L38731

; 1566 : 		return;

	jmp	$L38730
$L38731:

; 1567 : 	
; 1568 : 	if (flDamage == 0)

	fld	DWORD PTR _flDamage$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38732

; 1569 : 		return;

	jmp	$L38730
$L38732:

; 1570 : 
; 1571 : 	if (! (bitsDamageType & (DMG_CRUSH | DMG_BULLET | DMG_SLASH | DMG_BLAST | DMG_CLUB | DMG_MORTAR)))

	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	and	eax, 16777415				; 010000c7H
	test	eax, eax
	jne	SHORT $L38733

; 1572 : 		return;

	jmp	$L38730
$L38733:

; 1573 : 	
; 1574 : 	// make blood decal on the wall! 
; 1575 : 	TraceResult Bloodtr;

	lea	ecx, DWORD PTR _Bloodtr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1576 : 	Vector vecTraceDir; 

	lea	ecx, DWORD PTR _vecTraceDir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1577 : 	float flNoise;
; 1578 : 	int cCount;
; 1579 : 	int i;
; 1580 : 
; 1581 : /*
; 1582 : 	if ( !IsAlive() )
; 1583 : 	{
; 1584 : 		// dealing with a dead monster. 
; 1585 : 		if ( pev->max_health <= 0 )
; 1586 : 		{
; 1587 : 			// no blood decal for a monster that has already decalled its limit.
; 1588 : 			return; 
; 1589 : 		}
; 1590 : 		else
; 1591 : 		{
; 1592 : 			pev->max_health--;
; 1593 : 		}
; 1594 : 	}
; 1595 : */
; 1596 : 
; 1597 : 	if (flDamage < 10)

	fld	DWORD PTR _flDamage$[ebp]
	fcomp	DWORD PTR __real@4@4002a000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38739

; 1599 : 		flNoise = 0.1;

	mov	DWORD PTR _flNoise$[ebp], 1036831949	; 3dcccccdH

; 1600 : 		cCount = 1;

	mov	DWORD PTR _cCount$[ebp], 1

; 1602 : 	else if (flDamage < 25)

	jmp	SHORT $L38742
$L38739:
	fld	DWORD PTR _flDamage$[ebp]
	fcomp	DWORD PTR __real@4@4003c800000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38741

; 1604 : 		flNoise = 0.2;

	mov	DWORD PTR _flNoise$[ebp], 1045220557	; 3e4ccccdH

; 1605 : 		cCount = 2;

	mov	DWORD PTR _cCount$[ebp], 2

; 1607 : 	else

	jmp	SHORT $L38742
$L38741:

; 1609 : 		flNoise = 0.3;

	mov	DWORD PTR _flNoise$[ebp], 1050253722	; 3e99999aH

; 1610 : 		cCount = 4;

	mov	DWORD PTR _cCount$[ebp], 4
$L38742:

; 1612 : 
; 1613 : 	for ( i = 0 ; i < cCount ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38743
$L38744:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L38743:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _cCount$[ebp]
	jge	$L38745

; 1615 : 		vecTraceDir = vecDir * -1;// trace in the opposite direction the shot came from (the direction the shot is going)

	push	-1082130432				; bf800000H
	lea	eax, DWORD PTR $T39627[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecTraceDir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecTraceDir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecTraceDir$[ebp+8], eax

; 1616 : 
; 1617 : 		vecTraceDir.x += RANDOM_FLOAT( -flNoise, flNoise );

	mov	ecx, DWORD PTR _flNoise$[ebp]
	push	ecx
	fld	DWORD PTR _flNoise$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecTraceDir$[ebp]
	fstp	DWORD PTR _vecTraceDir$[ebp]

; 1618 : 		vecTraceDir.y += RANDOM_FLOAT( -flNoise, flNoise );

	mov	edx, DWORD PTR _flNoise$[ebp]
	push	edx
	fld	DWORD PTR _flNoise$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecTraceDir$[ebp+4]
	fstp	DWORD PTR _vecTraceDir$[ebp+4]

; 1619 : 		vecTraceDir.z += RANDOM_FLOAT( -flNoise, flNoise );

	mov	eax, DWORD PTR _flNoise$[ebp]
	push	eax
	fld	DWORD PTR _flNoise$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecTraceDir$[ebp+8]
	fstp	DWORD PTR _vecTraceDir$[ebp+8]

; 1620 : 
; 1621 : 		UTIL_TraceLine( ptr->vecEndPos, ptr->vecEndPos + vecTraceDir * -172, ignore_monsters, ENT(pev), &Bloodtr);

	lea	ecx, DWORD PTR _Bloodtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	push	-1020526592				; c32c0000H
	lea	ecx, DWORD PTR $T39628[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecTraceDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T39629[ebp]
	push	edx
	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 20					; 00000014H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 1622 : 
; 1623 : 		if ( Bloodtr.flFraction != 1.0 )

	fld	DWORD PTR _Bloodtr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38749

; 1625 : 			UTIL_BloodDecalTrace( &Bloodtr, BloodColor() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+112]
	push	eax
	lea	eax, DWORD PTR _Bloodtr$[ebp]
	push	eax
	call	?UTIL_BloodDecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_BloodDecalTrace
	add	esp, 8
$L38749:

; 1627 : 	}

	jmp	$L38744
$L38745:
$L38730:

; 1628 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z ENDP ; CBaseEntity::TraceBleed
_TEXT	ENDS
PUBLIC	?MakeDamageBloodDecal@CBaseMonster@@QAEXHMPAUgametrace_s@@ABVVector@@@Z ; CBaseMonster::MakeDamageBloodDecal
;	COMDAT ?MakeDamageBloodDecal@CBaseMonster@@QAEXHMPAUgametrace_s@@ABVVector@@@Z
_TEXT	SEGMENT
$T39636 = -88
$T39637 = -100
_cCount$ = 8
_flNoise$ = 12
_ptr$ = 16
_vecDir$ = 20
_this$ = -4
_Bloodtr$ = -60
_vecTraceDir$ = -72
_i$ = -76
?MakeDamageBloodDecal@CBaseMonster@@QAEXHMPAUgametrace_s@@ABVVector@@@Z PROC NEAR ; CBaseMonster::MakeDamageBloodDecal, COMDAT

; 1633 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1634 : 	// make blood decal on the wall! 
; 1635 : 	TraceResult Bloodtr;

	lea	ecx, DWORD PTR _Bloodtr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1636 : 	Vector vecTraceDir; 

	lea	ecx, DWORD PTR _vecTraceDir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1637 : 	int i;
; 1638 : 
; 1639 : 	if ( !IsAlive() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	jne	SHORT $L38762

; 1641 : 		// dealing with a dead monster. 
; 1642 : 		if ( pev->max_health <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+432]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38761

; 1644 : 			// no blood decal for a monster that has already decalled its limit.
; 1645 : 			return; 

	jmp	$L38756
$L38761:

; 1649 : 			pev->max_health--;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+432]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+432]
$L38762:

; 1652 : 
; 1653 : 	for ( i = 0 ; i < cCount ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38763
$L38764:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38763:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _cCount$[ebp]
	jge	$L38765

; 1655 : 		vecTraceDir = vecDir;

	mov	edx, DWORD PTR _vecDir$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _vecTraceDir$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _vecTraceDir$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _vecTraceDir$[ebp+8], edx

; 1656 : 
; 1657 : 		vecTraceDir.x += RANDOM_FLOAT( -flNoise, flNoise );

	mov	eax, DWORD PTR _flNoise$[ebp]
	push	eax
	fld	DWORD PTR _flNoise$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecTraceDir$[ebp]
	fstp	DWORD PTR _vecTraceDir$[ebp]

; 1658 : 		vecTraceDir.y += RANDOM_FLOAT( -flNoise, flNoise );

	mov	ecx, DWORD PTR _flNoise$[ebp]
	push	ecx
	fld	DWORD PTR _flNoise$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecTraceDir$[ebp+4]
	fstp	DWORD PTR _vecTraceDir$[ebp+4]

; 1659 : 		vecTraceDir.z += RANDOM_FLOAT( -flNoise, flNoise );

	mov	edx, DWORD PTR _flNoise$[ebp]
	push	edx
	fld	DWORD PTR _flNoise$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR _vecTraceDir$[ebp+8]
	fstp	DWORD PTR _vecTraceDir$[ebp+8]

; 1660 : 
; 1661 : 		UTIL_TraceLine( ptr->vecEndPos, ptr->vecEndPos + vecTraceDir * 172, ignore_monsters, ENT(pev), &Bloodtr);

	lea	eax, DWORD PTR _Bloodtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	push	1126957056				; 432c0000H
	lea	eax, DWORD PTR $T39636[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecTraceDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T39637[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 20					; 00000014H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 1662 : 
; 1663 : /*
; 1664 : 		MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );
; 1665 : 			WRITE_BYTE( TE_SHOWLINE);
; 1666 : 			WRITE_COORD( ptr->vecEndPos.x );
; 1667 : 			WRITE_COORD( ptr->vecEndPos.y );
; 1668 : 			WRITE_COORD( ptr->vecEndPos.z );
; 1669 : 			
; 1670 : 			WRITE_COORD( Bloodtr.vecEndPos.x );
; 1671 : 			WRITE_COORD( Bloodtr.vecEndPos.y );
; 1672 : 			WRITE_COORD( Bloodtr.vecEndPos.z );
; 1673 : 		MESSAGE_END();
; 1674 : */
; 1675 : 
; 1676 : 		if ( Bloodtr.flFraction != 1.0 )

	fld	DWORD PTR _Bloodtr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38768

; 1678 : 			UTIL_BloodDecalTrace( &Bloodtr, BloodColor() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+112]
	push	eax
	lea	eax, DWORD PTR _Bloodtr$[ebp]
	push	eax
	call	?UTIL_BloodDecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_BloodDecalTrace
	add	esp, 8
$L38768:

; 1680 : 	}

	jmp	$L38764
$L38765:
$L38756:

; 1681 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?MakeDamageBloodDecal@CBaseMonster@@QAEXHMPAUgametrace_s@@ABVVector@@@Z ENDP ; CBaseMonster::MakeDamageBloodDecal
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_this$ = -16
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
PUBLIC	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
PUBLIC	??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
PUBLIC	??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT
??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ DB '('
	DB	'Base() == NULL) || (&src < Base()) || (&src >= (Base() + Coun'
	DB	't()) )', 00H				; `string'
CONST	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L39662
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L39662
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L39662
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39662:

; 520  : 	return InsertBefore( m_Size, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseEntity@@2Udatamap_s@@A:BYTE	; CBaseEntity::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseEntity@@2Udatamap_s@@A ; CBaseEntity::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	??0CGib@@QAE@XZ					; CGib::CGib
PUBLIC	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z		; CBaseEntity::operator new
PUBLIC	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z		; CBaseEntity::operator delete
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCGib@@PAV1@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCGib@@PAV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCGib@@PAV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCGib@@PAV1@@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCGib@@PAV1@@Z
_TEXT	SEGMENT
_a$ = 8
$T39667 = -20
$T39668 = -24
__$EHRec$ = -12
_pev$ = -16
?GetClassPtr@@YAPAVCGib@@PAV1@@Z PROC NEAR		; GetClassPtr, COMDAT

; 1073 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCGib@@PAV1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1074 : 	entvars_t *pev = (entvars_t *)a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1075 : 
; 1076 : 	// allocate entity if necessary
; 1077 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L38795

; 1078 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L38795:

; 1079 : 
; 1080 : 	// get the private data
; 1081 : 	a = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 1082 : 
; 1083 : 	if (a == NULL) 

	cmp	DWORD PTR _a$[ebp], 0
	jne	SHORT $L38797

; 1085 : 		// allocate private data 
; 1086 : 		a = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1780					; 000006f4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T39668[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T39668[ebp], 0
	je	SHORT $L39669
	mov	ecx, DWORD PTR $T39668[ebp]
	call	??0CGib@@QAE@XZ				; CGib::CGib
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L39670
$L39669:
	mov	DWORD PTR -28+[ebp], 0
$L39670:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T39667[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T39667[ebp]
	mov	DWORD PTR _a$[ebp], ecx

; 1087 : 		a->pev = pev;

	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L38797:

; 1089 : 	return a;

	mov	eax, DWORD PTR _a$[ebp]

; 1090 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCGib@@PAV1@@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T39668[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCGib@@PAV1@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCGib@@PAV1@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCGib@@PAV1@@Z ENDP			; GetClassPtr
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT
_stAllocateBlock$ = 8
_pev$ = 12
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator new, COMDAT

; 489  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 490  : 		return (void *)ALLOC_PRIVATE(ENT(pev), stAllocateBlock);

	mov	eax, DWORD PTR _stAllocateBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+252
	add	esp, 8

; 491  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z ENDP		; CBaseEntity::operator new
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 12
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator delete, COMDAT

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 497  : 		pev->flags |= FL_KILLME;

	mov	eax, DWORD PTR _pev$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+420], ecx

; 498  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z ENDP		; CBaseEntity::operator delete
_TEXT	ENDS
PUBLIC	?EarPosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EarPosition
PUBLIC	?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z	; CBaseEntity::BodyTarget
PUBLIC	?IsPointSized@CBaseEntity@@UBEHXZ		; CBaseEntity::IsPointSized
PUBLIC	?Illumination@CBaseEntity@@UAEHXZ		; CBaseEntity::Illumination
PUBLIC	??0CBaseEntity@@QAE@XZ				; CBaseEntity::CBaseEntity
PUBLIC	?ObjectCaps@CGib@@UAEHXZ			; CGib::ObjectCaps
PUBLIC	??_7CGib@@6B@					; CGib::`vftable'
PUBLIC	?Spawn@CBaseEntity@@UAEXXZ			; CBaseEntity::Spawn
PUBLIC	?Precache@CBaseEntity@@UAEXXZ			; CBaseEntity::Precache
PUBLIC	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
PUBLIC	?Activate@CBaseEntity@@UAEXXZ			; CBaseEntity::Activate
PUBLIC	?OnChangeLevel@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeLevel
PUBLIC	?OnTeleport@CBaseEntity@@UAEXXZ			; CBaseEntity::OnTeleport
PUBLIC	?PortalSleep@CBaseEntity@@UAEXM@Z		; CBaseEntity::PortalSleep
PUBLIC	?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ; CBaseEntity::StartMessage
PUBLIC	?GetPosition@CBaseEntity@@UAEMXZ		; CBaseEntity::GetPosition
PUBLIC	?OnChangeParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeParent
PUBLIC	?OnClearParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnClearParent
PUBLIC	?OnRemove@CBaseEntity@@UAEXXZ			; CBaseEntity::OnRemove
PUBLIC	?Classify@CBaseEntity@@UAEHXZ			; CBaseEntity::Classify
PUBLIC	?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z	; CBaseEntity::DeathNotice
PUBLIC	?IsRigidBody@CBaseEntity@@UAEHXZ		; CBaseEntity::IsRigidBody
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@XZ		; CBaseEntity::GetState
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z	; CBaseEntity::GetState
PUBLIC	?BloodColor@CBaseEntity@@UAEHXZ			; CBaseEntity::BloodColor
PUBLIC	?IsTriggered@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::IsTriggered
PUBLIC	?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ; CBaseEntity::MyMonsterPointer
PUBLIC	?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ; CBaseEntity::MySquadMonsterPointer
PUBLIC	?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ	; CBaseEntity::GetVehicleDriver
PUBLIC	?GetToggleState@CBaseEntity@@UAEHXZ		; CBaseEntity::GetToggleState
PUBLIC	?AddPoints@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPoints
PUBLIC	?AddPointsToTeam@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPointsToTeam
PUBLIC	?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::AddPlayerItem
PUBLIC	?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::RemovePlayerItem
PUBLIC	?GiveAmmo@CBaseEntity@@UAEHHPADH@Z		; CBaseEntity::GiveAmmo
PUBLIC	?GetDelay@CBaseEntity@@UAEMXZ			; CBaseEntity::GetDelay
PUBLIC	?IsMoving@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMoving
PUBLIC	?OverrideReset@CBaseEntity@@UAEXXZ		; CBaseEntity::OverrideReset
PUBLIC	?TransferReset@CBaseEntity@@UAEXXZ		; CBaseEntity::TransferReset
PUBLIC	?SetToggleState@CBaseEntity@@UAEXH@Z		; CBaseEntity::SetToggleState
PUBLIC	?StartSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StartSneaking
PUBLIC	?StopSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StopSneaking
PUBLIC	?OnControls@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::OnControls
PUBLIC	?IsSneaking@CBaseEntity@@UAEHXZ			; CBaseEntity::IsSneaking
PUBLIC	?IsAlive@CBaseEntity@@UAEHXZ			; CBaseEntity::IsAlive
PUBLIC	?IsBSPModel@CBaseEntity@@UAEHXZ			; CBaseEntity::IsBSPModel
PUBLIC	?IsCustomModel@CBaseEntity@@UAEHXZ		; CBaseEntity::IsCustomModel
PUBLIC	?ReflectGauss@CBaseEntity@@UAEHXZ		; CBaseEntity::ReflectGauss
PUBLIC	?HasTarget@CBaseEntity@@UAEHH@Z			; CBaseEntity::HasTarget
PUBLIC	?IsPlayer@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPlayer
PUBLIC	?IsNetClient@CBaseEntity@@UAEHXZ		; CBaseEntity::IsNetClient
PUBLIC	?IsMonster@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMonster
PUBLIC	?IsPushable@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPushable
PUBLIC	?IsProjectile@CBaseEntity@@UAEHXZ		; CBaseEntity::IsProjectile
PUBLIC	?IsFuncScreen@CBaseEntity@@UAEHXZ		; CBaseEntity::IsFuncScreen
PUBLIC	?IsPortal@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPortal
PUBLIC	?IsTank@CBaseEntity@@UAEHXZ			; CBaseEntity::IsTank
PUBLIC	?IsMover@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMover
PUBLIC	?IsBreakable@CBaseEntity@@UAEHXZ		; CBaseEntity::IsBreakable
PUBLIC	?TeamID@CBaseEntity@@UAEPBDXZ			; CBaseEntity::TeamID
PUBLIC	?Think@CBaseEntity@@UAEXXZ			; CBaseEntity::Think
PUBLIC	?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z	; CBaseEntity::Use
PUBLIC	?Touch@CBaseEntity@@UAEXPAV1@@Z			; CBaseEntity::Touch
PUBLIC	?Blocked@CBaseEntity@@UAEXPAV1@@Z		; CBaseEntity::Blocked
PUBLIC	?MoveDone@CBaseEntity@@UAEXXZ			; CBaseEntity::MoveDone
PUBLIC	?Respawn@CBaseEntity@@UAEPAV1@XZ		; CBaseEntity::Respawn
PUBLIC	?UpdateOwner@CBaseEntity@@UAEXXZ		; CBaseEntity::UpdateOwner
PUBLIC	?FBecomeProne@CBaseEntity@@UAEHXZ		; CBaseEntity::FBecomeProne
PUBLIC	?Center@CBaseEntity@@UAE?AVVector@@XZ		; CBaseEntity::Center
PUBLIC	?EyePosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EyePosition
EXTRN	?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z:NEAR	; CBaseEntity::ShouldCollide
EXTRN	?Save@CBaseEntity@@UAEHAAVCSave@@@Z:NEAR	; CBaseEntity::Save
EXTRN	?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z:NEAR	; CBaseEntity::Restore
EXTRN	?SetObjectCollisionBox@CBaseEntity@@UAEXXZ:NEAR	; CBaseEntity::SetObjectCollisionBox
EXTRN	?SetNextThink@CBaseEntity@@UAEXM@Z:NEAR		; CBaseEntity::SetNextThink
EXTRN	?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseEntity::TakeDamage
EXTRN	?TakeArmor@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeArmor
EXTRN	?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z:NEAR	; CBaseEntity::Killed
EXTRN	?DamageDecal@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::DamageDecal
EXTRN	?IsInWorld@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::IsInWorld
EXTRN	?GetNextTarget@CBaseEntity@@UAEPAV1@XZ:NEAR	; CBaseEntity::GetNextTarget
;	COMDAT ??_7CGib@@6B@
CONST	SEGMENT
??_7CGib@@6B@ DD FLAT:?GetDataDescMap@CGib@@UAEPAUdatamap_s@@XZ ; CGib::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CGib@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CGib@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CGib@@QAE@XZ PROC NEAR				; CGib::CGib, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CGib@@6B@ ; CGib::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CGib@@QAE@XZ ENDP					; CGib::CGib
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Spawn, COMDAT

; 325  : 	virtual void	Spawn( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Spawn
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Precache, COMDAT

; 326  : 	virtual void	Precache( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Precache
_TEXT	ENDS
PUBLIC	??_C@_06FOPF@parent?$AA@			; `string'
PUBLIC	??_C@_08IDGH@movewith?$AA@			; `string'
PUBLIC	??_C@_0M@FCIN@parentflags?$AA@			; `string'
PUBLIC	??_C@_05JCDO@style?$AA@				; `string'
PUBLIC	??_C@_0L@MCHI@reflection?$AA@			; `string'
PUBLIC	??_C@_0N@DCCA@vlight_cache?$AA@			; `string'
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
EXTRN	_atoi:NEAR
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
;	COMDAT ??_C@_06FOPF@parent?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_06FOPF@parent?$AA@ DB 'parent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT
??_C@_08IDGH@movewith?$AA@ DB 'movewith', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT
??_C@_0M@FCIN@parentflags?$AA@ DB 'parentflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT
??_C@_05JCDO@style?$AA@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT
??_C@_0L@MCHI@reflection?$AA@ DB 'reflection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT
??_C@_0N@DCCA@vlight_cache?$AA@ DB 'vlight_cache', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pkvd$ = 8
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseEntity::KeyValue, COMDAT

; 328  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 		// get support for spirit field too
; 330  : 		if( FStrEq( pkvd->szKeyName, "parent" ) || FStrEq( pkvd->szKeyName, "movewith" ))

	push	OFFSET FLAT:??_C@_06FOPF@parent?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L34875
	push	OFFSET FLAT:??_C@_08IDGH@movewith?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34874
$L34875:

; 332  : 			m_iParent = ALLOC_STRING(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 333  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 335  : 		else if( FStrEq( pkvd->szKeyName, "parentflags" ))

	jmp	$L34896
$L34874:
	push	OFFSET FLAT:??_C@_0M@FCIN@parentflags?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34879

; 337  : 			m_iParentFlags = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 338  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 340  : 		else if( FStrEq( pkvd->szKeyName, "style" ))

	jmp	$L34896
$L34879:
	push	OFFSET FLAT:??_C@_05JCDO@style?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34882

; 342  : 			m_iStyle = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 343  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 345  : 		else if( FStrEq( pkvd->szKeyName, "reflection" ))

	jmp	$L34896
$L34882:
	push	OFFSET FLAT:??_C@_0L@MCHI@reflection?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34885

; 348  : 			{

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L34891
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L34892
	jmp	SHORT $L34888
$L34891:

; 349  : 			case 1: pev->effects |= EF_NOREFLECT; break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
	jmp	SHORT $L34888
$L34892:

; 350  : 			case 2: pev->effects |= EF_REFLECTONLY; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L34888:

; 352  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 354  : 		else if( FStrEq(pkvd->szKeyName, "vlight_cache"))

	jmp	SHORT $L34896
$L34885:
	push	OFFSET FLAT:??_C@_0N@DCCA@vlight_cache?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34894

; 356  : 			pev->iuser3 = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+588], eax

; 357  : 			pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 359  : 		else pkvd->fHandled = FALSE;

	jmp	SHORT $L34896
$L34894:
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L34896:

; 360  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseEntity::KeyValue
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Activate@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Activate, COMDAT

; 365  : 	virtual void	Activate( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Activate
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeLevel@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeLevel, COMDAT

; 366  : 	virtual void	OnChangeLevel( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeLevel@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnChangeLevel
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnTeleport@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnTeleport, COMDAT

; 367  : 	virtual void	OnTeleport( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnTeleport@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnTeleport
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4
?PortalSleep@CBaseEntity@@UAEXM@Z PROC NEAR		; CBaseEntity::PortalSleep, COMDAT

; 368  : 	virtual void	PortalSleep( float seconds ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PortalSleep@CBaseEntity@@UAEXM@Z ENDP			; CBaseEntity::PortalSleep
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CBaseEntity::StartMessage, COMDAT

; 369  :           virtual void	StartMessage( CBasePlayer *pPlayer ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ENDP	; CBaseEntity::StartMessage
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetPosition@CBaseEntity@@UAEMXZ PROC NEAR		; CBaseEntity::GetPosition, COMDAT

; 370  : 	virtual float	GetPosition( void ) { return 0.0f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPosition@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetPosition
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeParent, COMDAT

; 371  : 	virtual void	OnChangeParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CBaseEntity@@UAEXXZ ENDP		; CBaseEntity::OnChangeParent
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnClearParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnClearParent, COMDAT

; 372  : 	virtual void	OnClearParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnClearParent
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnRemove@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::OnRemove, COMDAT

; 373  : 	virtual void	OnRemove( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnRemove@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnRemove
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::Classify, COMDAT

; 385  : 	virtual int Classify ( void ) { return CLASS_NONE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Classify
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z PROC NEAR ; CBaseEntity::DeathNotice, COMDAT

; 386  : 	virtual void DeathNotice ( entvars_t *pevChild ) { } // monster maker children use this to tell the monster maker that they have died.

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z ENDP	; CBaseEntity::DeathNotice
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsRigidBody@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsRigidBody, COMDAT

; 387  : 	virtual BOOL IsRigidBody( void ) { return (m_iActorType == ACTOR_DYNAMIC); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	mov	eax, ecx
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsRigidBody@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsRigidBody
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseEntity::GetState, COMDAT

; 398  : 	virtual STATE GetState ( void ) { return STATE_OFF; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ ENDP		; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z PROC NEAR	; CBaseEntity::GetState, COMDAT

; 401  : 	virtual STATE GetState ( CBaseEntity* pEnt ) { return GetState(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z ENDP	; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::BloodColor, COMDAT

; 408  : 	virtual int	BloodColor( void ) { return DONT_BLEED; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::BloodColor
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::IsTriggered, COMDAT

; 410  : 	virtual BOOL	IsTriggered( CBaseEntity *pActivator ) {return TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::IsTriggered
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ PROC NEAR ; CBaseEntity::MyMonsterPointer, COMDAT

; 411  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ENDP ; CBaseEntity::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ PROC NEAR ; CBaseEntity::MySquadMonsterPointer, COMDAT

; 412  : 	virtual CSquadMonster *MySquadMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ENDP ; CBaseEntity::MySquadMonsterPointer
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ PROC NEAR	; CBaseEntity::GetVehicleDriver, COMDAT

; 413  : 	virtual CBaseEntity *GetVehicleDriver( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ ENDP		; CBaseEntity::GetVehicleDriver
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::GetToggleState, COMDAT

; 414  : 	virtual int	GetToggleState( void ) { return TS_AT_TOP; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseEntity@@UAEHXZ ENDP		; CBaseEntity::GetToggleState
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPoints@CBaseEntity@@UAEXHH@Z PROC NEAR		; CBaseEntity::AddPoints, COMDAT

; 415  : 	virtual void	AddPoints( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPoints@CBaseEntity@@UAEXHH@Z ENDP			; CBaseEntity::AddPoints
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z PROC NEAR	; CBaseEntity::AddPointsToTeam, COMDAT

; 416  : 	virtual void	AddPointsToTeam( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z ENDP		; CBaseEntity::AddPointsToTeam
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::AddPlayerItem, COMDAT

; 417  : 	virtual BOOL	AddPlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::AddPlayerItem
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::RemovePlayerItem, COMDAT

; 418  : 	virtual BOOL	RemovePlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::RemovePlayerItem
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT
_this$ = -4
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z PROC NEAR		; CBaseEntity::GiveAmmo, COMDAT

; 419  : 	virtual int 	GiveAmmo( int iAmount, char *szName, int iMax ) { return -1; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z ENDP			; CBaseEntity::GiveAmmo
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseEntity@@UAEMXZ PROC NEAR			; CBaseEntity::GetDelay, COMDAT

; 420  : 	virtual float	GetDelay( void ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetDelay
_TEXT	ENDS
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMoving, COMDAT

; 421  : 	virtual int	IsMoving( void ) { return GetAbsVelocity() != g_vecZero; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMoving
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OverrideReset, COMDAT

; 422  : 	virtual void	OverrideReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OverrideReset
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TransferReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::TransferReset, COMDAT

; 423  : 	virtual void	TransferReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransferReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::TransferReset
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?SetToggleState@CBaseEntity@@UAEXH@Z PROC NEAR		; CBaseEntity::SetToggleState, COMDAT

; 426  : 	virtual void	SetToggleState( int state ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetToggleState@CBaseEntity@@UAEXH@Z ENDP		; CBaseEntity::SetToggleState
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StartSneaking, COMDAT

; 427  : 	virtual void	StartSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StartSneaking
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StopSneaking, COMDAT

; 428  : 	virtual void	StopSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StopSneaking
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?OnControls@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::OnControls, COMDAT

; 429  : 	virtual BOOL	OnControls( CBaseEntity *pTest ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnControls@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::OnControls
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSneaking@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsSneaking, COMDAT

; 430  : 	virtual BOOL	IsSneaking( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSneaking@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsSneaking
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsAlive, COMDAT

; 431  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	jne	SHORT $L39765
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39765
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39766
$L39765:
	mov	DWORD PTR -8+[ebp], 0
$L39766:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsAlive
_TEXT	ENDS
EXTRN	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z:NEAR	; UTIL_GetModelType
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBSPModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBSPModel, COMDAT

; 432  : 	virtual BOOL	IsBSPModel( void ) { return UTIL_GetModelType( pev->modelindex ) == mod_brush; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBSPModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBSPModel
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsCustomModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsCustomModel, COMDAT

; 433  : 	virtual BOOL	IsCustomModel( void ) { return pev->solid == SOLID_CUSTOM; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+268], 5
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCustomModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsCustomModel
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ReflectGauss@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ReflectGauss, COMDAT

; 434  : 	virtual BOOL	ReflectGauss( void ) { return (( IsBSPModel() || IsCustomModel()) && !pev->takedamage ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	test	eax, eax
	jne	SHORT $L39773
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+208]
	test	eax, eax
	je	SHORT $L39774
$L39773:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39774
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39775
$L39774:
	mov	DWORD PTR -8+[ebp], 0
$L39775:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReflectGauss@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ReflectGauss
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_targetname$ = 8
?HasTarget@CBaseEntity@@UAEHH@Z PROC NEAR		; CBaseEntity::HasTarget, COMDAT

; 435  : 	virtual BOOL	HasTarget( string_t targetname ) { return FStrEq(STRING(targetname), STRING(pev->targetname) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _targetname$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasTarget@CBaseEntity@@UAEHH@Z ENDP			; CBaseEntity::HasTarget
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPlayer@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPlayer, COMDAT

; 437  : 	virtual BOOL	IsPlayer( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPlayer
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsNetClient@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsNetClient, COMDAT

; 438  : 	virtual BOOL	IsNetClient( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetClient@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsNetClient
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMonster@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsMonster, COMDAT

; 439  : 	virtual BOOL	IsMonster( void ) { return (pev->flags & FL_MONSTER ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+420]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMonster@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMonster
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPushable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsPushable, COMDAT

; 440  : 	virtual BOOL	IsPushable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPushable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPushable
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsProjectile@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsProjectile, COMDAT

; 441  : 	virtual BOOL	IsProjectile( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsProjectile@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsProjectile
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsFuncScreen@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsFuncScreen, COMDAT

; 442  : 	virtual BOOL	IsFuncScreen( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFuncScreen@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsFuncScreen
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPortal@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPortal, COMDAT

; 443  : 	virtual BOOL	IsPortal( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPortal@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPortal
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTank@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsTank, COMDAT

; 444  : 	virtual BOOL	IsTank( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTank@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsTank
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMover@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMover, COMDAT

; 445  : 	virtual BOOL	IsMover( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMover
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBreakable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBreakable, COMDAT

; 446  : 	virtual BOOL	IsBreakable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBreakable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBreakable
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?TeamID@CBaseEntity@@UAEPBDXZ PROC NEAR			; CBaseEntity::TeamID, COMDAT

; 447  : 	virtual const char	*TeamID( void ) { return ""; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TeamID@CBaseEntity@@UAEPBDXZ ENDP			; CBaseEntity::TeamID
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Think@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Think, COMDAT

; 458  : 	virtual void Think( void ) { if (m_pfnThink) (this->*m_pfnThink)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1744], 0
	je	SHORT $L35006
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1744]
$L35006:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Think
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
_pActivator$ = 8
_pCaller$ = 12
_useType$ = 16
_value$ = 20
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z PROC NEAR	; CBaseEntity::Use, COMDAT

; 461  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 		if (m_pfnUse) (this->*m_pfnUse)( pActivator, pCaller, useType, value );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1752], 0
	je	SHORT $L35009
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCaller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1752]
$L35009:

; 463  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z ENDP	; CBaseEntity::Use
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Touch@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Touch, COMDAT

; 466  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 		if( m_pfnTouch )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1748], 0
	je	SHORT $L35012

; 468  : 			(this->*m_pfnTouch)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1748]
$L35012:

; 469  : 
; 470  : 		// forward the blocked event to our parent, if any.
; 471  : 		if( m_hParent != NULL && !m_isChaining )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35013
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1628]
	test	ecx, ecx
	jne	SHORT $L35013

; 472  : 			m_hParent->Touch( pOther );

	mov	edx, DWORD PTR _pOther$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+280]
$L35013:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Touch
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Blocked@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Blocked, COMDAT

; 476  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 		if( m_pfnBlocked )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1756], 0
	je	SHORT $L35016

; 478  : 			(this->*m_pfnBlocked)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1756]
$L35016:

; 479  : 
; 480  : 		// forward the blocked event to our parent, if any.
; 481  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35017

; 482  : 			m_hParent->Blocked( pOther );

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+284]
$L35017:

; 483  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Blocked
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MoveDone@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::MoveDone, COMDAT

; 485  : 	virtual void MoveDone( void ) { if( m_pfnMoveDone )(this->*m_pfnMoveDone)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1760], 0
	je	SHORT $L35020
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1760]
$L35020:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveDone@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::MoveDone
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?Respawn@CBaseEntity@@UAEPAV1@XZ PROC NEAR		; CBaseEntity::Respawn, COMDAT

; 513  : 	virtual CBaseEntity *Respawn( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Respawn@CBaseEntity@@UAEPAV1@XZ ENDP			; CBaseEntity::Respawn
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?UpdateOwner@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::UpdateOwner, COMDAT

; 705  : 	virtual	void UpdateOwner( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateOwner@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::UpdateOwner
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FBecomeProne@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::FBecomeProne, COMDAT

; 709  : 	virtual BOOL FBecomeProne( void ) {return FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FBecomeProne@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::FBecomeProne
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T39818 = -16
$T39819 = -28
?Center@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR		; CBaseEntity::Center, COMDAT

; 714  : 	virtual Vector Center( ) { return (pev->absmax + pev->absmin) * 0.5; }; // center point of entity

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T39819[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	push	edx
	lea	eax, DWORD PTR $T39818[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 208				; 000000d0H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Center@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::Center
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T39822 = -16
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EyePosition, COMDAT

; 715  : 	virtual Vector EyePosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of eyes

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T39822[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EyePosition
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T39825 = -16
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EarPosition, COMDAT

; 716  : 	virtual Vector EarPosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of ears

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T39825[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EarPosition
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T39828 = -16
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseEntity::BodyTarget, COMDAT

; 717  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ); };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T39828[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseEntity::BodyTarget
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPointSized@CBaseEntity@@UBEHXZ PROC NEAR		; CBaseEntity::IsPointSized, COMDAT

; 718  : 	virtual BOOL IsPointSized() const { return (pev->size == g_vecZero) ? true : false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	setne	al
	and	eax, 255				; 000000ffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPointSized@CBaseEntity@@UBEHXZ ENDP			; CBaseEntity::IsPointSized
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Illumination@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::Illumination, COMDAT

; 720  : 	virtual int Illumination( ) { return GETENTITYILLUM( ENT( pev ) ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+60
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Illumination@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Illumination
_TEXT	ENDS
PUBLIC	?ObjectCaps@CBaseEntity@@UAEHXZ			; CBaseEntity::ObjectCaps
;	COMDAT ?ObjectCaps@CGib@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CGib@@UAEHXZ PROC NEAR			; CGib::ObjectCaps, COMDAT

; 156  : 	virtual int ObjectCaps( void ) { return (CBaseEntity :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | FCAP_DONT_SAVE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	eax, -2147483648			; 80000000H
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CGib@@UAEHXZ ENDP				; CGib::ObjectCaps
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ObjectCaps, COMDAT

; 364  : 	virtual int	ObjectCaps( void ) { return FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 2
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ObjectCaps
_TEXT	ENDS
PUBLIC	??_7CBaseEntity@@6B@				; CBaseEntity::`vftable'
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	??0CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::CMeshDesc
EXTRN	??1CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::~CMeshDesc
EXTRN	?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseEntity::GetDataDescMap
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT
??_7CBaseEntity@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CBaseEntity::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseEntity@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseEntity@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseEntity@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseEntity@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseEntity@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??0CMeshDesc@@QAE@XZ			; CMeshDesc::CMeshDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1632				; 00000660H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseEntity@@6B@ ; CBaseEntity::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseEntity@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	ret	0
__ehhandler$??0CBaseEntity@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseEntity@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::CBaseEntity
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
PUBLIC	??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
PUBLIC	?CopyConstruct@@YAXPAPADABQAD@Z			; CopyConstruct
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ DB '('
	DB	'elem == Count()) || IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L39852
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L39852
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L39852
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39852:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L39853
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39853
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39853:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAPADABQAD@Z		; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC NEAR		; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L39858
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39858:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L38837

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L38837:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PADH@@QAE@XZ PROC NEAR			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC NEAR		; CUtlMemory<char *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L39863
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39863:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39864
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39864:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC NEAR		; CUtlMemory<char *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L39867
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39867:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC NEAR	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L39874
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L39874
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39875
$L39874:
	mov	DWORD PTR -8+[ebp], 0
$L39875:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAPAD@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L38870:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L38871

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAD@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L38870
$L38871:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ		; CUtlMemory<char *,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@PADH@@QAEXH@Z		; CUtlMemory<char *,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L38880

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@PADH@@QAEXH@Z	; CUtlMemory<char *,int>::Grow
$L38880:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
_TEXT	ENDS
PUBLIC	??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
EXTRN	_memmove:NEAR
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ DB 'I'
	DB	'sValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 )', 00H ; `string'
CONST	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39882
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L39882
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L39882
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39882:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L38889
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L38889

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L38889:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
_src$ = 12
$T39885 = -4
?CopyConstruct@@YAXPAPADABQAD@Z PROC NEAR		; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T39885[ebp], eax
	cmp	DWORD PTR $T39885[ebp], 0
	je	SHORT $L39886
	mov	ecx, DWORD PTR $T39885[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T39885[ebp]
	mov	DWORD PTR -8+[ebp], ecx
	jmp	SHORT $L39887
$L39886:
	mov	DWORD PTR -8+[ebp], 0
$L39887:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyConstruct@@YAXPAPADABQAD@Z ENDP			; CopyConstruct
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC NEAR	; CUtlMemory<char *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L39892
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L39892
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39893
$L39892:
	mov	DWORD PTR -8+[ebp], 0
$L39893:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC NEAR		; CUtlMemory<char *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L38903

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L38904

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L38904:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L38903:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR	; CUtlMemory<char *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ PROC NEAR	; CUtlMemory<char *,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ ENDP		; CUtlMemory<char *,int>::NumAllocated
_TEXT	ENDS
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@PADH@@QAEXH@Z PROC NEAR		; CUtlMemory<char *,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L39902
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39902:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L38918

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L39903
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39903:

; 567  : 		return;

	jmp	$L38915
$L38918:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	4
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L38938

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L38930
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L38930

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L38938
$L38930:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L38934

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L39904
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39904:

; 589  : 				return;

	jmp	$L38915
$L38934:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L38938

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L38934
$L38938:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L38941

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L39905
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39905:

; 603  : 	else

	jmp	SHORT $L39906
$L38941:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L39906
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39906:
$L38915:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@PADH@@QAEXH@Z ENDP			; CUtlMemory<char *,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L28985

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L28990
$L28985:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L28987

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L28987:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L28990

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L28987
$L28990:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR ; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
EXTRN	_memset:NEAR
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAD@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAD@Z ENDP				; Destruct
_TEXT	ENDS
END
