	TITLE	Z:\XashXTSRC\server\plats.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@FFMP@CBasePlatTrain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MFAH@m_iMoveSnd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07HPHJ@movesnd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LAAP@m_iStopSnd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07KHB@stopsnd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08INAP@m_volume?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FLOP@volume?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09EEEM@m_flFloor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03JNMJ@lip?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OMDE@wait?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06OKPG@height?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PNBN@width?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GHGA@rotation?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LNFJ@common?1null?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@HCHF@plats?1bigmove1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@JCBK@plats?1bigmove2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GPDA@plats?1elevmove1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@IPFP@plats?1elevmove2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@CPHK@plats?1elevmove3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@PED@plats?1freightmove1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@OPCM@plats?1freightmove2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@EMBJ@plats?1heavymove1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@DHCG@plats?1rackmove1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@BJAI@plats?1railmove1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@FCFK@plats?1squeekmove1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@BBJL@plats?1talkmove1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@PBPE@plats?1talkmove2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@PIKI@plats?1bigstop1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@BIMH@plats?1bigstop2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@IFJO@plats?1freightstop1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@CGKL@plats?1heavystop2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@LNPL@plats?1rackstop1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@JDNF@plats?1railstop1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@NIIH@plats?1squeekstop1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@JLEG@plats?1talkstop1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HHKD@func_plat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@FILI@func_platform?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HOM@CFuncPlat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07JPAN@PlatUse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09FKJM@FloorCalc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08LEJO@CallGoUp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EDMM@CallGoDown?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OBGH@CallHitTop?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@FDMJ@CallHitBottom?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@CLLJ@CallHitFloor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@NJDE@z?3?2xashxtsrc?2server?2plats?4cpp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@PHDA@m_toggle_state?5?$DN?$DN?5TS_AT_TOP?5?$HM?$HM?5m@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GoDown@CFuncPlat@@UAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@BPNN@m_toggle_state?5?$DN?$DN?5TS_GOING_DOWN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??HitBottom@CFuncPlat@@UAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EC@PCLE@m_toggle_state?5?$DN?$DN?5TS_AT_BOTTOM?5?$HM@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GoUp@CFuncPlat@@UAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@OMAF@m_toggle_state?5?$DN?$DN?5TS_GOING_UP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??HitTop@CFuncPlat@@UAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EB@BHHJ@m_toggle_state?5?$DN?$DN?5TS_GOING_UP?5?$HM?$HM@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??HitFloor@CFuncPlat@@UAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@HNBH@func_platrot?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GBFP@CFuncPlatRot?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MAPN@m_end?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07GINM@m_start?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@IOJK@scripted_trainsequence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@FDFA@CTrainSequence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GABM@m_iszEntity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FMLJ@m_iszDestination?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@FKJF@m_iszTerminate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@CAEJ@m_iDirection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@LAEL@m_pDestination?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CPLD@m_pTrain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08LGNC@EndThink?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OLKI@func_train?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GCNI@CFuncTrain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HEEN@m_hCurrentTarget?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@MLG@m_pSequence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OADG@m_activated?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@JMDO@SoundSetup?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04EGHG@Wait?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04CIMM@Next?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OJNB@Train?5?$CFs?5speed?5to?5?$CF4?42f?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@NAM@?$CFs?5with?5name?5?$CFs?5has?5no?5target?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@KEIM@?$CGCFuncTrain?5?3?3?5SoundSetup?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@NFMG@trainsequence?5?$CC?$CFs?$CC?5found?5train?5?$CC@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@HAH@found?5destination?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@GIIE@missing?5destination?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EI@PICH@Found?5no?5path?5to?5reach?5destinati@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@EJNJ@scripted_trainsequence?5?$CFs?5can?8t?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@HMAL@Missing?5train?5?$CC?$CFs?$CC?5for?5scripted_@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@CFIL@scripted_trainsequence?3?5StopSequ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LBCA@scripted_trainsequence?3?5ArrivalN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@PNOC@CFuncTrackTrain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07DNJA@m_ppath?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07GHJN@m_pDoor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@KADK@m_pSpeedControl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08ECOL@m_length?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06MALF@wheels?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08DMBG@m_height?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@IMGF@m_startSpeed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DAPE@startspeed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@NOJL@m_controlMins?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@FDHI@m_controlMaxs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HCCP@m_controlOrigin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08KGNE@m_sounds?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06HADE@sounds?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@FMBA@m_soundStart?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OAIB@soundstart?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@ILOK@m_soundStop?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BKIF@soundstop?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@FDMP@m_eVelocityType?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09KAOB@acceltype?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@HANG@m_eOrientationType?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OAHA@orientation?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MFGO@m_flVolume?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08JBFJ@m_flBank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04MAHH@bank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@MLLD@m_flDesiredSpeed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@OJMG@m_flAccelSpeed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLCA@m_flReachedDist?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@FKGC@m_oldSpeed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@ILNC@m_maxSpeed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KFLM@m_dir?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOJF@Find?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BJFE@NearestPath?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07LJIB@DeadEnd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@KOLE@func_tracktrain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@NHEJ@TRAIN?$CI?$CFs?$CJ?0?5speed?5to?5?$CF?42f?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@OGMH@TRAIN?$CI?$CFs?$CJ?3?5Blocked?5by?5?$CFs?5?$CIdmg?3?$CF?4@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@CPIO@TRAIN?$CI?5?$CFs?5?$CJ?0?5speed?5to?5?$CF?42f?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@FAOJ@TrackTrain?5?$CFs?5arrived?5at?5?$CFs?0?5spe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DH@LFPB@?$CBpPrev?5?$HM?$HM?5?$CIpPrev?9?$DOm_hParent?4Get?$CI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??UpdateTrainOrientation@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@LMCO@TRAIN?$CI?$CFs?$CJ?3?5Speed?5is?50?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@FNFN@TRAIN?$CI?$CFs?$CJ?3?5Lost?5path?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@MBML@?$CBpNext?5?$HM?$HM?5?$CI?5pNext?9?$DOm_hParent?4Get@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Next@CFuncTrackTrain@@QAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@LGCC@TRAIN?$CI?$CFs?$CJ?3?5Dead?5end?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06BLHP@at?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NGLK@path_track?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@CPIB@func_track_train?5must?5be?5on?5a?5pa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@EIGK@Can?8t?5find?5a?5nearby?5track?5?$CB?$CB?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@BCAL@TRAIN?3?5?$CFs?0?5Nearest?5track?5is?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@FABF@?$CGCFuncTrackTrain?3?3Next?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@PKMI@FuncTrackTrain?5?8?$CFs?8?5has?5no?5targe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@BGEM@?$CGCFuncTrackTrain?3?3Find?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@KFKM@plats?1ttrain1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@EFMD@plats?1ttrain2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@OFOG@plats?1ttrain3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@IFBM@plats?1ttrain4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@MFFG@plats?1ttrain6?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@GFHD@plats?1ttrain7?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@DAGB@plats?1ttrain_start1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@LCPH@plats?1ttrain_brake1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@PKJK@func_traincontrols?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@NFLN@CFuncTrainControls?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@MHDA@TrackTrainControls?3?5No?5train?5?$CFs?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@EDIN@func_trackchange?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@MCNO@CFuncTrackChange?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EEBK@m_trackTop?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@DAKG@m_trackBottom?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07JLCO@m_train?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MEPM@m_trackTopName?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08DIO@toptrack?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@NHGG@m_trackBottomName?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@DPJA@bottomtrack?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OFHE@m_trainName?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HLPG@train?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06HCNB@m_code?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@BCOO@m_targetState?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05NIPN@m_use?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IPB@m_flRadius?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04JFMM@GoUp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06OMMA@GoDown?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@CGCH@buttons?1button11?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06JGHA@radius?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@MHNP@Can?8t?5find?5train?5for?5track?5chang@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@CHAO@Can?8t?5find?5bottom?5track?5for?5trac@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@JAGN@Can?8t?5find?5top?5track?5for?5track?5c@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MJH@Found?5train?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@NFLJ@func_trackautochange?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MJPL@func_guntarget?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@CLNG@CGunTarget?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BJEF@m_on?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05IMKO@Start?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@Vector@@QAEXMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ZVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??XVector@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapVal@@YAMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSplineRemapVal@@YAMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTarget@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMessageA@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModel@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDebugName@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMoveDoneTime@CBaseEntity@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMoveDoneTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseToggle@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseToggle@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stop@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScheduleChange@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanPlaySentence@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetYawSpeed@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CoverRadius@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckAmmo@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HearingSensitivity@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrescheduleThink@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AlertSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IdleSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PainSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopFollowing@CBaseMonster@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOrientationType@CPathTrack@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDirForward@CFuncTrackTrain@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTrack@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSpeed@CFuncTrackTrain@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CFuncTrackTrain@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncTrackTrain@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBasePlatTrain@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTogglePlat@CBasePlatTrain@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CBasePlatTrain@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CBasePlatTrain@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E23
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E27
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBasePlatTrain@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBasePlatTrain@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncPlat@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CallGoUp@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CallGoDown@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CallHitTop@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CallHitBottom@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CallHitFloor@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcFloor@CFuncPlat@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?step@CFuncPlat@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E29
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E30
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E32
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E33
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CFuncPlat@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CFuncPlat@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E35
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPlatTrigger@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlatSpawnInsideTrigger@@YAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Setup@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpawnInsideTrigger@CPlatTrigger@@QAEXPAVCFuncPlat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CPlatTrigger@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlatUse@CFuncPlat@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GoDown@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HitBottom@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GoUp@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HitTop@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HitFloor@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GoToFloor@CFuncPlat@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FloorCalc@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E41
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E42
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CFuncPlatRot@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CFuncPlatRot@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E44
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E45
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetupRotation@CFuncPlatRot@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncPlatRot@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GoDown@CFuncPlatRot@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HitBottom@CFuncPlatRot@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GoUp@CFuncPlatRot@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HitTop@CFuncPlatRot@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotMove@CFuncPlatRot@@QAEXAAVVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CTrainSequence@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CTrainSequence@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E50
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E51
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CTrainSequence@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CTrainSequence@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E53
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E54
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E57
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CTrainSequence@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndThink@CTrainSequence@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CFuncTrain@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcPosition@CFuncTrain@@QAE?AVVector@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E59
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E60
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CFuncTrain@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CFuncTrain@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E62
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E63
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E66
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CFuncTrain@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stop@CFuncTrain@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CFuncTrain@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Wait@CFuncTrain@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Next@CFuncTrain@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CFuncTrain@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSequence@CFuncTrain@@QAEXPAVCTrainSequence@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSequence@CFuncTrain@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncTrain@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CFuncTrain@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SoundSetup@CFuncTrain@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CFuncTrain@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CTrainSequence@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSequence@CTrainSequence@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ArrivalNotify@CTrainSequence@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CFuncTrackTrain@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CFuncTrackTrain@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E67
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E68
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E71
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E72
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E73
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncTrackTrain@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CFuncTrackTrain@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDirForward@CFuncTrackTrain@@QAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSpeed@CFuncTrackTrain@@QAEXMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSpeedExternal@CFuncTrackTrain@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stop@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CFuncTrackTrain@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CFuncTrackTrain@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fix@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSound@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateSound@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ArriveAtNode@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateTrainVelocity@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateTrainOrientation@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOrientationAtPathTracks@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOrientationBlend@CFuncTrackTrain@@QAEXHPAVCPathTrack@@0ABVVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUpdateOrientation@CFuncTrackTrain@@QAEXABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeleportToPathTrack@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Next@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeadEnd@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetControls@CFuncTrackTrain@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControls@CFuncTrackTrain@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Find@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NearestPath@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CFuncTrackTrain@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CFuncTrackTrain@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncTrackTrain@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CFuncTrackTrain@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOnRemove@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncTrainControls@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E76
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E77
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CFuncTrainControls@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CFuncTrainControls@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E79
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E80
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E83
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Find@CFuncTrainControls@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncTrainControls@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CFuncTrackChange@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTogglePlat@CFuncTrackChange@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DisableUse@CFuncTrackChange@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableUse@CFuncTrackChange@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UseEnabled@CFuncTrackChange@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E85
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E86
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CFuncTrackChange@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CFuncTrackChange@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E88
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E89
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E92
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CFuncTrackChange@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Find@CFuncTrackChange@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EvaluateTrain@CFuncTrackChange@@QAE?AW4TRAIN_CODE@@PAVCPathTrack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateTrain@CFuncTrackChange@@QAEXAAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GoDown@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GoUp@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateAutoTargets@CFuncTrackChange@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CFuncTrackChange@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HitBottom@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HitTop@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E93
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E94
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateAutoTargets@CFuncTrackAuto@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CFuncTrackAuto@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CGunTarget@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CGunTarget@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CGunTarget@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CGunTarget@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E97
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E98
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CGunTarget@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CGunTarget@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E100
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E101
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E104
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CGunTarget@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CGunTarget@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Start@CGunTarget@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Next@CGunTarget@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Wait@CGunTarget@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stop@CGunTarget@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TakeDamage@CGunTarget@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CGunTarget@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncPlat@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncPlat@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncPlat@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncPlat@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncPlatRot@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncPlatRot@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncPlatRot@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncPlatRot@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCTrainSequence@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCTrainSequence@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCTrainSequence@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCTrainSequence@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTrain@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncTrain@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTrain@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTrain@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTrackTrain@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncTrackTrain@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTrackTrain@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTrackTrain@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTrainControls@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncTrainControls@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTrainControls@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTrainControls@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTrackChange@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncTrackChange@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTrackChange@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTrackChange@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTrackAuto@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncTrackAuto@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTrackAuto@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTrackAuto@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCGunTarget@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCGunTarget@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCGunTarget@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCGunTarget@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBasePlatTrain@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCFuncPlat@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCFuncPlatRot@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPlatTrigger@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncPlat@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncPlatRot@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTrainSequence@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncTrain@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncTrainControls@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncTrackChange@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncTrackAuto@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGunTarget@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBasePlatTrain@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBasePlatTrain@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFuncPlat@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFuncPlatRot@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFuncTrackChange@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseMonster@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseMonster@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseToggle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseToggle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WayPoint_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_9@$BBFM@AE
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_9@$BBGA@AE
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFuncTrainControls@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseAnimating@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBasePlatTrain@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncTrackAuto@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CPlatTrigger@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncPlat@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCGunTarget@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCTrainSequence@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CTrainSequence@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncTrainControls@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CGunTarget@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncPlatRot@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncTrackChange@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseMonster@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncTrain@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseToggle@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncTrackAuto@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncTrackTrain@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncPlat@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncTrackChange@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncPlatRot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncTrackTrain@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncTrain@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??_C@_09HOM@CFuncPlat?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CFuncTrackTrain_DataDescInit@@3PAUdatamap_s@@A ; CFuncTrackTrain_DataDescInit::g_DataMapHolder
PUBLIC	?g_DataMapHolder@CFuncPlat_DataDescInit@@3PAUdatamap_s@@A ; CFuncPlat_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_07DNJA@m_ppath?$AA@			; `string'
PUBLIC	??_C@_07GHJN@m_pDoor?$AA@			; `string'
PUBLIC	??_C@_0BA@KADK@m_pSpeedControl?$AA@		; `string'
PUBLIC	??_C@_08ECOL@m_length?$AA@			; `string'
PUBLIC	??_C@_06MALF@wheels?$AA@			; `string'
PUBLIC	??_C@_08DMBG@m_height?$AA@			; `string'
PUBLIC	??_C@_0N@IMGF@m_startSpeed?$AA@			; `string'
PUBLIC	??_C@_0L@DAPE@startspeed?$AA@			; `string'
PUBLIC	??_C@_0O@NOJL@m_controlMins?$AA@		; `string'
PUBLIC	??_C@_0O@FDHI@m_controlMaxs?$AA@		; `string'
PUBLIC	??_C@_0BA@HCCP@m_controlOrigin?$AA@		; `string'
PUBLIC	??_C@_08KGNE@m_sounds?$AA@			; `string'
PUBLIC	??_C@_06HADE@sounds?$AA@			; `string'
PUBLIC	??_C@_0N@FMBA@m_soundStart?$AA@			; `string'
PUBLIC	??_C@_0L@OAIB@soundstart?$AA@			; `string'
PUBLIC	??_C@_0M@ILOK@m_soundStop?$AA@			; `string'
PUBLIC	??_C@_09BKIF@soundstop?$AA@			; `string'
PUBLIC	??_C@_0BA@FDMP@m_eVelocityType?$AA@		; `string'
PUBLIC	??_C@_09KAOB@acceltype?$AA@			; `string'
PUBLIC	??_C@_0BD@HANG@m_eOrientationType?$AA@		; `string'
PUBLIC	??_C@_0M@OAHA@orientation?$AA@			; `string'
PUBLIC	??_C@_0L@MFGO@m_flVolume?$AA@			; `string'
PUBLIC	??_C@_08JBFJ@m_flBank?$AA@			; `string'
PUBLIC	??_C@_04MAHH@bank?$AA@				; `string'
PUBLIC	??_C@_0BB@MLLD@m_flDesiredSpeed?$AA@		; `string'
PUBLIC	??_C@_0P@OJMG@m_flAccelSpeed?$AA@		; `string'
PUBLIC	??_C@_0BA@PLCA@m_flReachedDist?$AA@		; `string'
PUBLIC	??_C@_0L@FKGC@m_oldSpeed?$AA@			; `string'
PUBLIC	??_C@_0L@ILNC@m_maxSpeed?$AA@			; `string'
PUBLIC	??_C@_05KFLM@m_dir?$AA@				; `string'
PUBLIC	?m_DataMap@CGunTarget@@2Udatamap_s@@A		; CGunTarget::m_DataMap
PUBLIC	?m_DataMap@CFuncPlatRot@@2Udatamap_s@@A		; CFuncPlatRot::m_DataMap
PUBLIC	??_C@_0L@CLNG@CGunTarget?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CGunTarget_DataDescInit@@3PAUdatamap_s@@A ; CGunTarget_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0N@GBFP@CFuncPlatRot?$AA@			; `string'
PUBLIC	??_C@_04BJEF@m_on?$AA@				; `string'
PUBLIC	?g_DataMapHolder@CFuncPlatRot_DataDescInit@@3PAUdatamap_s@@A ; CFuncPlatRot_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_05MAPN@m_end?$AA@				; `string'
PUBLIC	??_C@_07GINM@m_start?$AA@			; `string'
PUBLIC	?m_DataMap@CTrainSequence@@2Udatamap_s@@A	; CTrainSequence::m_DataMap
PUBLIC	??_C@_0P@FDFA@CTrainSequence?$AA@		; `string'
PUBLIC	?m_DataMap@CFuncTrackTrain@@2Udatamap_s@@A	; CFuncTrackTrain::m_DataMap
PUBLIC	?g_DataMapHolder@CTrainSequence_DataDescInit@@3PAUdatamap_s@@A ; CTrainSequence_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0M@GABM@m_iszEntity?$AA@			; `string'
PUBLIC	??_C@_0BB@FMLJ@m_iszDestination?$AA@		; `string'
PUBLIC	??_C@_0P@FKJF@m_iszTerminate?$AA@		; `string'
PUBLIC	??_C@_0N@CAEJ@m_iDirection?$AA@			; `string'
PUBLIC	??_C@_0P@LAEL@m_pDestination?$AA@		; `string'
PUBLIC	??_C@_08CPLD@m_pTrain?$AA@			; `string'
PUBLIC	?m_DataMap@CFuncTrain@@2Udatamap_s@@A		; CFuncTrain::m_DataMap
PUBLIC	?m_DataMap@CFuncTrainControls@@2Udatamap_s@@A	; CFuncTrainControls::m_DataMap
PUBLIC	??_C@_0BD@NFLN@CFuncTrainControls?$AA@		; `string'
PUBLIC	??_C@_0L@GCNI@CFuncTrain?$AA@			; `string'
PUBLIC	?m_DataMap@CBasePlatTrain@@2Udatamap_s@@A	; CBasePlatTrain::m_DataMap
PUBLIC	?g_DataMapHolder@CFuncTrainControls_DataDescInit@@3PAUdatamap_s@@A ; CFuncTrainControls_DataDescInit::g_DataMapHolder
PUBLIC	?g_DataMapHolder@CFuncTrain_DataDescInit@@3PAUdatamap_s@@A ; CFuncTrain_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0P@FFMP@CBasePlatTrain?$AA@		; `string'
PUBLIC	??_C@_0BB@HEEN@m_hCurrentTarget?$AA@		; `string'
PUBLIC	??_C@_0M@MLG@m_pSequence?$AA@			; `string'
PUBLIC	??_C@_0M@OADG@m_activated?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CBasePlatTrain_DataDescInit@@3PAUdatamap_s@@A ; CBasePlatTrain_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0L@MFAH@m_iMoveSnd?$AA@			; `string'
PUBLIC	??_C@_07HPHJ@movesnd?$AA@			; `string'
PUBLIC	??_C@_0L@LAAP@m_iStopSnd?$AA@			; `string'
PUBLIC	??_C@_07KHB@stopsnd?$AA@			; `string'
PUBLIC	??_C@_08INAP@m_volume?$AA@			; `string'
PUBLIC	??_C@_06FLOP@volume?$AA@			; `string'
PUBLIC	??_C@_09EEEM@m_flFloor?$AA@			; `string'
PUBLIC	??_C@_06OKPG@height?$AA@			; `string'
PUBLIC	?m_DataMap@CFuncTrackChange@@2Udatamap_s@@A	; CFuncTrackChange::m_DataMap
PUBLIC	??_C@_0BB@MCNO@CFuncTrackChange?$AA@		; `string'
PUBLIC	?g_DataMapHolder@CFuncTrackChange_DataDescInit@@3PAUdatamap_s@@A ; CFuncTrackChange_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0L@EEBK@m_trackTop?$AA@			; `string'
PUBLIC	?m_DataMap@CFuncPlat@@2Udatamap_s@@A		; CFuncPlat::m_DataMap
PUBLIC	??_C@_0O@DAKG@m_trackBottom?$AA@		; `string'
PUBLIC	??_C@_07JLCO@m_train?$AA@			; `string'
PUBLIC	??_C@_0P@MEPM@m_trackTopName?$AA@		; `string'
PUBLIC	??_C@_08DIO@toptrack?$AA@			; `string'
PUBLIC	??_C@_0BC@NHGG@m_trackBottomName?$AA@		; `string'
PUBLIC	??_C@_0M@DPJA@bottomtrack?$AA@			; `string'
PUBLIC	??_C@_0M@OFHE@m_trainName?$AA@			; `string'
PUBLIC	??_C@_05HLPG@train?$AA@				; `string'
PUBLIC	??_C@_06HCNB@m_code?$AA@			; `string'
PUBLIC	??_C@_0O@BCOO@m_targetState?$AA@		; `string'
PUBLIC	??_C@_05NIPN@m_use?$AA@				; `string'
PUBLIC	??_C@_0L@IPB@m_flRadius?$AA@			; `string'
PUBLIC	??_C@_0BA@PNOC@CFuncTrackTrain?$AA@		; `string'
_BSS	SEGMENT
?g_DataMapHolder@CFuncTrackTrain_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CFuncTrackTrain_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CFuncPlat_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CFuncPlat_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CGunTarget_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CGunTarget_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CFuncPlatRot_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CFuncPlatRot_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CTrainSequence_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CTrainSequence_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CFuncTrainControls_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CFuncTrainControls_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CFuncTrain_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CFuncTrain_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CBasePlatTrain_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CBasePlatTrain_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CFuncTrackChange_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CFuncTrackChange_DataDescInit::g_DataMapHolder
_BSS	ENDS
_DATA	SEGMENT
?m_DataMap@CBasePlatTrain@@2Udatamap_s@@A DD 00H	; CBasePlatTrain::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0P@FFMP@CBasePlatTrain?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S25	DD	FLAT:_$E24
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0L@MFAH@m_iMoveSnd?$AA@
	DD	07a4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07HPHJ@movesnd?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0L@LAAP@m_iStopSnd?$AA@
	DD	07a8H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07KHB@stopsnd?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_08INAP@m_volume?$AA@
	DD	07acH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06FLOP@volume?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_09EEEM@m_flFloor?$AA@
	DD	07b0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S31	DD	FLAT:_$E30
_$S34	DD	FLAT:_$E33
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CFuncPlat@@2Udatamap_s@@A DD 00H		; CFuncPlat::m_DataMap
	DD	00H
	DD	FLAT:??_C@_09HOM@CFuncPlat?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S37	DD	FLAT:_$E36
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	012H
	ORG $+164
_DATA	ENDS
CRT$XCU	SEGMENT
_$S43	DD	FLAT:_$E42
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CFuncPlatRot@@2Udatamap_s@@A DD 00H		; CFuncPlatRot::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0N@GBFP@CFuncPlatRot?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S46	DD	FLAT:_$E45
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_05MAPN@m_end?$AA@
	DD	07b4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_07GINM@m_start?$AA@
	DD	07c0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S52	DD	FLAT:_$E51
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CTrainSequence@@2Udatamap_s@@A DD 00H	; CTrainSequence::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0P@FDFA@CTrainSequence?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S55	DD	FLAT:_$E54
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0M@GABM@m_iszEntity?$AA@
	DD	06e4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@GABM@m_iszEntity?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0BB@FMLJ@m_iszDestination?$AA@
	DD	06e8H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0BB@FMLJ@m_iszDestination?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0P@FKJF@m_iszTerminate?$AA@
	DD	06ecH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0P@FKJF@m_iszTerminate?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0N@CAEJ@m_iDirection?$AA@
	DD	06f0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0N@CAEJ@m_iDirection?$AA@
	DD	00H
	DD	03H
	DD	FLAT:??_C@_0P@LAEL@m_pDestination?$AA@
	DD	06f8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_08CPLD@m_pTrain?$AA@
	DD	06f4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+20
_DATA	ENDS
CRT$XCU	SEGMENT
_$S61	DD	FLAT:_$E60
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CFuncTrain@@2Udatamap_s@@A DD 00H		; CFuncTrain::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0L@GCNI@CFuncTrain?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S64	DD	FLAT:_$E63
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_0BB@HEEN@m_hCurrentTarget?$AA@
	DD	07b8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_0M@MLG@m_pSequence?$AA@
	DD	07b4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_0M@OADG@m_activated?$AA@
	DD	07c0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+68
?m_DataMap@CFuncTrackTrain@@2Udatamap_s@@A DD 00H	; CFuncTrackTrain::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0BA@PNOC@CFuncTrackTrain?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S69	DD	FLAT:_$E68
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_07DNJA@m_ppath?$AA@
	DD	0704H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_07GHJN@m_pDoor?$AA@
	DD	0700H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_0BA@KADK@m_pSpeedControl?$AA@
	DD	0708H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_08ECOL@m_length?$AA@
	DD	070cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06MALF@wheels?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_08DMBG@m_height?$AA@
	DD	0710H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06OKPG@height?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0N@IMGF@m_startSpeed?$AA@
	DD	0718H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@DAPE@startspeed?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0O@NOJL@m_controlMins?$AA@
	DD	071cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0O@FDHI@m_controlMaxs?$AA@
	DD	0728H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	08H
	DD	FLAT:??_C@_0BA@HCCP@m_controlOrigin?$AA@
	DD	0734H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:??_C@_08KGNE@m_sounds?$AA@
	DD	0744H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06HADE@sounds?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0N@FMBA@m_soundStart?$AA@
	DD	0748H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@OAIB@soundstart?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0M@ILOK@m_soundStop?$AA@
	DD	074cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_09BKIF@soundstop?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BA@FDMP@m_eVelocityType?$AA@
	DD	0764H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_09KAOB@acceltype?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BD@HANG@m_eOrientationType?$AA@
	DD	0760H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@OAHA@orientation?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@MFGO@m_flVolume?$AA@
	DD	0750H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_08JBFJ@m_flBank?$AA@
	DD	0754H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_04MAHH@bank?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BB@MLLD@m_flDesiredSpeed?$AA@
	DD	0768H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0P@OJMG@m_flAccelSpeed?$AA@
	DD	076cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BA@PLCA@m_flReachedDist?$AA@
	DD	0770H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@FKGC@m_oldSpeed?$AA@
	DD	0758H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@ILNC@m_maxSpeed?$AA@
	DD	0714H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_05KFLM@m_dir?$AA@
	DD	075cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+92
_DATA	ENDS
CRT$XCU	SEGMENT
_$S74	DD	FLAT:_$E73
_$S78	DD	FLAT:_$E77
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CFuncTrainControls@@2Udatamap_s@@A DD 00H	; CFuncTrainControls::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0BD@NFLN@CFuncTrainControls?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S81	DD	FLAT:_$E80
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	012H
	ORG $+20
_DATA	ENDS
CRT$XCU	SEGMENT
_$S87	DD	FLAT:_$E86
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CFuncTrackChange@@2Udatamap_s@@A DD 00H	; CFuncTrackChange::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0BB@MCNO@CFuncTrackChange?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S90	DD	FLAT:_$E89
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_0L@EEBK@m_trackTop?$AA@
	DD	07ccH
	DW	01H
	DW	03H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_0O@DAKG@m_trackBottom?$AA@
	DD	07d0H
	DW	01H
	DW	03H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_07JLCO@m_train?$AA@
	DD	07d4H
	DW	01H
	DW	03H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0P@MEPM@m_trackTopName?$AA@
	DD	07d8H
	DW	01H
	DW	07H
	DD	FLAT:??_C@_08DIO@toptrack?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0BC@NHGG@m_trackBottomName?$AA@
	DD	07dcH
	DW	01H
	DW	07H
	DD	FLAT:??_C@_0M@DPJA@bottomtrack?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0M@OFHE@m_trainName?$AA@
	DD	07e0H
	DW	01H
	DW	07H
	DD	FLAT:??_C@_05HLPG@train?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_06HCNB@m_code?$AA@
	DD	07e4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0O@BCOO@m_targetState?$AA@
	DD	07ecH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_05NIPN@m_use?$AA@
	DD	07f0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@IPB@m_flRadius?$AA@
	DD	07e8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+68
_DATA	ENDS
CRT$XCU	SEGMENT
_$S95	DD	FLAT:_$E94
_$S99	DD	FLAT:_$E98
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CGunTarget@@2Udatamap_s@@A DD 00H		; CGunTarget::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0L@CLNG@CGunTarget?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S102	DD	FLAT:_$E101
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_04BJEF@m_on?$AA@
	DD	095cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+68
_DATA	ENDS
;	COMDAT ??_C@_0P@FFMP@CBasePlatTrain?$AA@
CONST	SEGMENT
??_C@_0P@FFMP@CBasePlatTrain?$AA@ DB 'CBasePlatTrain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MFAH@m_iMoveSnd?$AA@
CONST	SEGMENT
??_C@_0L@MFAH@m_iMoveSnd?$AA@ DB 'm_iMoveSnd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HPHJ@movesnd?$AA@
CONST	SEGMENT
??_C@_07HPHJ@movesnd?$AA@ DB 'movesnd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LAAP@m_iStopSnd?$AA@
CONST	SEGMENT
??_C@_0L@LAAP@m_iStopSnd?$AA@ DB 'm_iStopSnd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KHB@stopsnd?$AA@
CONST	SEGMENT
??_C@_07KHB@stopsnd?$AA@ DB 'stopsnd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08INAP@m_volume?$AA@
CONST	SEGMENT
??_C@_08INAP@m_volume?$AA@ DB 'm_volume', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FLOP@volume?$AA@
CONST	SEGMENT
??_C@_06FLOP@volume?$AA@ DB 'volume', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EEEM@m_flFloor?$AA@
CONST	SEGMENT
??_C@_09EEEM@m_flFloor?$AA@ DB 'm_flFloor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OKPG@height?$AA@
CONST	SEGMENT
??_C@_06OKPG@height?$AA@ DB 'height', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HOM@CFuncPlat?$AA@
CONST	SEGMENT
??_C@_09HOM@CFuncPlat?$AA@ DB 'CFuncPlat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GBFP@CFuncPlatRot?$AA@
CONST	SEGMENT
??_C@_0N@GBFP@CFuncPlatRot?$AA@ DB 'CFuncPlatRot', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAPN@m_end?$AA@
CONST	SEGMENT
??_C@_05MAPN@m_end?$AA@ DB 'm_end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07GINM@m_start?$AA@
CONST	SEGMENT
??_C@_07GINM@m_start?$AA@ DB 'm_start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FDFA@CTrainSequence?$AA@
CONST	SEGMENT
??_C@_0P@FDFA@CTrainSequence?$AA@ DB 'CTrainSequence', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GABM@m_iszEntity?$AA@
CONST	SEGMENT
??_C@_0M@GABM@m_iszEntity?$AA@ DB 'm_iszEntity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FMLJ@m_iszDestination?$AA@
CONST	SEGMENT
??_C@_0BB@FMLJ@m_iszDestination?$AA@ DB 'm_iszDestination', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FKJF@m_iszTerminate?$AA@
CONST	SEGMENT
??_C@_0P@FKJF@m_iszTerminate?$AA@ DB 'm_iszTerminate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CAEJ@m_iDirection?$AA@
CONST	SEGMENT
??_C@_0N@CAEJ@m_iDirection?$AA@ DB 'm_iDirection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LAEL@m_pDestination?$AA@
CONST	SEGMENT
??_C@_0P@LAEL@m_pDestination?$AA@ DB 'm_pDestination', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CPLD@m_pTrain?$AA@
CONST	SEGMENT
??_C@_08CPLD@m_pTrain?$AA@ DB 'm_pTrain', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GCNI@CFuncTrain?$AA@
CONST	SEGMENT
??_C@_0L@GCNI@CFuncTrain?$AA@ DB 'CFuncTrain', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HEEN@m_hCurrentTarget?$AA@
CONST	SEGMENT
??_C@_0BB@HEEN@m_hCurrentTarget?$AA@ DB 'm_hCurrentTarget', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MLG@m_pSequence?$AA@
CONST	SEGMENT
??_C@_0M@MLG@m_pSequence?$AA@ DB 'm_pSequence', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OADG@m_activated?$AA@
CONST	SEGMENT
??_C@_0M@OADG@m_activated?$AA@ DB 'm_activated', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PNOC@CFuncTrackTrain?$AA@
CONST	SEGMENT
??_C@_0BA@PNOC@CFuncTrackTrain?$AA@ DB 'CFuncTrackTrain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DNJA@m_ppath?$AA@
CONST	SEGMENT
??_C@_07DNJA@m_ppath?$AA@ DB 'm_ppath', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GHJN@m_pDoor?$AA@
CONST	SEGMENT
??_C@_07GHJN@m_pDoor?$AA@ DB 'm_pDoor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KADK@m_pSpeedControl?$AA@
CONST	SEGMENT
??_C@_0BA@KADK@m_pSpeedControl?$AA@ DB 'm_pSpeedControl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08ECOL@m_length?$AA@
CONST	SEGMENT
??_C@_08ECOL@m_length?$AA@ DB 'm_length', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MALF@wheels?$AA@
CONST	SEGMENT
??_C@_06MALF@wheels?$AA@ DB 'wheels', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DMBG@m_height?$AA@
CONST	SEGMENT
??_C@_08DMBG@m_height?$AA@ DB 'm_height', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IMGF@m_startSpeed?$AA@
CONST	SEGMENT
??_C@_0N@IMGF@m_startSpeed?$AA@ DB 'm_startSpeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DAPE@startspeed?$AA@
CONST	SEGMENT
??_C@_0L@DAPE@startspeed?$AA@ DB 'startspeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NOJL@m_controlMins?$AA@
CONST	SEGMENT
??_C@_0O@NOJL@m_controlMins?$AA@ DB 'm_controlMins', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FDHI@m_controlMaxs?$AA@
CONST	SEGMENT
??_C@_0O@FDHI@m_controlMaxs?$AA@ DB 'm_controlMaxs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HCCP@m_controlOrigin?$AA@
CONST	SEGMENT
??_C@_0BA@HCCP@m_controlOrigin?$AA@ DB 'm_controlOrigin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KGNE@m_sounds?$AA@
CONST	SEGMENT
??_C@_08KGNE@m_sounds?$AA@ DB 'm_sounds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HADE@sounds?$AA@
CONST	SEGMENT
??_C@_06HADE@sounds?$AA@ DB 'sounds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FMBA@m_soundStart?$AA@
CONST	SEGMENT
??_C@_0N@FMBA@m_soundStart?$AA@ DB 'm_soundStart', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OAIB@soundstart?$AA@
CONST	SEGMENT
??_C@_0L@OAIB@soundstart?$AA@ DB 'soundstart', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILOK@m_soundStop?$AA@
CONST	SEGMENT
??_C@_0M@ILOK@m_soundStop?$AA@ DB 'm_soundStop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BKIF@soundstop?$AA@
CONST	SEGMENT
??_C@_09BKIF@soundstop?$AA@ DB 'soundstop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FDMP@m_eVelocityType?$AA@
CONST	SEGMENT
??_C@_0BA@FDMP@m_eVelocityType?$AA@ DB 'm_eVelocityType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KAOB@acceltype?$AA@
CONST	SEGMENT
??_C@_09KAOB@acceltype?$AA@ DB 'acceltype', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HANG@m_eOrientationType?$AA@
CONST	SEGMENT
??_C@_0BD@HANG@m_eOrientationType?$AA@ DB 'm_eOrientationType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OAHA@orientation?$AA@
CONST	SEGMENT
??_C@_0M@OAHA@orientation?$AA@ DB 'orientation', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MFGO@m_flVolume?$AA@
CONST	SEGMENT
??_C@_0L@MFGO@m_flVolume?$AA@ DB 'm_flVolume', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JBFJ@m_flBank?$AA@
CONST	SEGMENT
??_C@_08JBFJ@m_flBank?$AA@ DB 'm_flBank', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MAHH@bank?$AA@
CONST	SEGMENT
??_C@_04MAHH@bank?$AA@ DB 'bank', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MLLD@m_flDesiredSpeed?$AA@
CONST	SEGMENT
??_C@_0BB@MLLD@m_flDesiredSpeed?$AA@ DB 'm_flDesiredSpeed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OJMG@m_flAccelSpeed?$AA@
CONST	SEGMENT
??_C@_0P@OJMG@m_flAccelSpeed?$AA@ DB 'm_flAccelSpeed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLCA@m_flReachedDist?$AA@
CONST	SEGMENT
??_C@_0BA@PLCA@m_flReachedDist?$AA@ DB 'm_flReachedDist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FKGC@m_oldSpeed?$AA@
CONST	SEGMENT
??_C@_0L@FKGC@m_oldSpeed?$AA@ DB 'm_oldSpeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ILNC@m_maxSpeed?$AA@
CONST	SEGMENT
??_C@_0L@ILNC@m_maxSpeed?$AA@ DB 'm_maxSpeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFLM@m_dir?$AA@
CONST	SEGMENT
??_C@_05KFLM@m_dir?$AA@ DB 'm_dir', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NFLN@CFuncTrainControls?$AA@
CONST	SEGMENT
??_C@_0BD@NFLN@CFuncTrainControls?$AA@ DB 'CFuncTrainControls', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MCNO@CFuncTrackChange?$AA@
CONST	SEGMENT
??_C@_0BB@MCNO@CFuncTrackChange?$AA@ DB 'CFuncTrackChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EEBK@m_trackTop?$AA@
CONST	SEGMENT
??_C@_0L@EEBK@m_trackTop?$AA@ DB 'm_trackTop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DAKG@m_trackBottom?$AA@
CONST	SEGMENT
??_C@_0O@DAKG@m_trackBottom?$AA@ DB 'm_trackBottom', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JLCO@m_train?$AA@
CONST	SEGMENT
??_C@_07JLCO@m_train?$AA@ DB 'm_train', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MEPM@m_trackTopName?$AA@
CONST	SEGMENT
??_C@_0P@MEPM@m_trackTopName?$AA@ DB 'm_trackTopName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DIO@toptrack?$AA@
CONST	SEGMENT
??_C@_08DIO@toptrack?$AA@ DB 'toptrack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NHGG@m_trackBottomName?$AA@
CONST	SEGMENT
??_C@_0BC@NHGG@m_trackBottomName?$AA@ DB 'm_trackBottomName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DPJA@bottomtrack?$AA@
CONST	SEGMENT
??_C@_0M@DPJA@bottomtrack?$AA@ DB 'bottomtrack', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OFHE@m_trainName?$AA@
CONST	SEGMENT
??_C@_0M@OFHE@m_trainName?$AA@ DB 'm_trainName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HLPG@train?$AA@
CONST	SEGMENT
??_C@_05HLPG@train?$AA@ DB 'train', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06HCNB@m_code?$AA@
CONST	SEGMENT
??_C@_06HCNB@m_code?$AA@ DB 'm_code', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BCOO@m_targetState?$AA@
CONST	SEGMENT
??_C@_0O@BCOO@m_targetState?$AA@ DB 'm_targetState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05NIPN@m_use?$AA@
CONST	SEGMENT
??_C@_05NIPN@m_use?$AA@ DB 'm_use', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IPB@m_flRadius?$AA@
CONST	SEGMENT
??_C@_0L@IPB@m_flRadius?$AA@ DB 'm_flRadius', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CLNG@CGunTarget?$AA@
CONST	SEGMENT
??_C@_0L@CLNG@CGunTarget?$AA@ DB 'CGunTarget', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BJEF@m_on?$AA@
CONST	SEGMENT
??_C@_04BJEF@m_on?$AA@ DB 'm_on', 00H			; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CBasePlatTrain@@UAEPAUdatamap_s@@XZ ; CBasePlatTrain::GetDataDescMap
;	COMDAT ?GetDataDescMap@CBasePlatTrain@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CBasePlatTrain@@UAEPAUdatamap_s@@XZ PROC NEAR ; CBasePlatTrain::GetDataDescMap, COMDAT

; 50   : BEGIN_DATADESC( CBasePlatTrain )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CBasePlatTrain@@2Udatamap_s@@A ; CBasePlatTrain::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CBasePlatTrain@@UAEPAUdatamap_s@@XZ ENDP ; CBasePlatTrain::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CBasePlatTrain@@SAPAUdatamap_s@@XZ	; CBasePlatTrain::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CBasePlatTrain@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CBasePlatTrain@@SAPAUdatamap_s@@XZ PROC NEAR ; CBasePlatTrain::GetBaseMap, COMDAT

; 50   : BEGIN_DATADESC( CBasePlatTrain )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CBasePlatTrain@@SAPAUdatamap_s@@XZ ENDP	; CBasePlatTrain::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E24
_TEXT	SEGMENT
_$E24	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E23
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E24	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z ; DataMapInit
;	COMDAT _$E23
_TEXT	SEGMENT
_$E23	PROC NEAR					; COMDAT

; 50   : BEGIN_DATADESC( CBasePlatTrain )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CBasePlatTrain_DataDescInit@@3PAUdatamap_s@@A, eax ; CBasePlatTrain_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E23	ENDP
_TEXT	ENDS
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S26@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z PROC NEAR ; DataMapInit, COMDAT

; 50   : BEGIN_DATADESC( CBasePlatTrain )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S26@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L36639
	mov	cl, BYTE PTR _?$S26@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S26@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0P@FFMP@CBasePlatTrain?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E27
	call	_atexit
	add	esp, 4
$L36639:
	call	?GetBaseMap@CBasePlatTrain@@SAPAUdatamap_s@@XZ ; CBasePlatTrain::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CBasePlatTrain@@2Udatamap_s@@A+12, eax

; 51   : 	DEFINE_KEYFIELD( m_iMoveSnd, FIELD_STRING, "movesnd" ),
; 52   : 	DEFINE_KEYFIELD( m_iStopSnd, FIELD_STRING, "stopsnd" ),
; 53   : 	DEFINE_KEYFIELD( m_volume, FIELD_FLOAT, "volume" ),
; 54   : 	DEFINE_FIELD( m_flFloor, FIELD_FLOAT ),
; 55   : END_DATADESC()

	mov	edx, 1
	test	edx, edx
	je	SHORT $L36658
	mov	DWORD PTR ?m_DataMap@CBasePlatTrain@@2Udatamap_s@@A+4, 4
	mov	DWORD PTR ?m_DataMap@CBasePlatTrain@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L36659
$L36658:
	mov	DWORD PTR ?m_DataMap@CBasePlatTrain@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CBasePlatTrain@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z@4PAUtypedescription_s@@A
$L36659:
	mov	eax, OFFSET FLAT:?m_DataMap@CBasePlatTrain@@2Udatamap_s@@A ; CBasePlatTrain::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z ENDP ; DataMapInit
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
EXTRN	_strlen:NEAR
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_pszBase$ = 8
_this$ = -4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC NEAR	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E27
_TEXT	SEGMENT
_$E27	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlatTrain@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E27	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File z:\xashxtsrc\common\datamap.h
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
_i$ = -20
$T40625 = -24
__$EHRec$ = -12
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC NEAR	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L30214
$L30215:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L30214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L30216

; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T40625[ebp], edx
	mov	eax, DWORD PTR $T40625[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 		}

	jmp	SHORT $L30215
$L30216:

; 202  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	ret	0
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
PUBLIC	?KeyValue@CBasePlatTrain@@UAEXPAUKeyValueData_s@@@Z ; CBasePlatTrain::KeyValue
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
PUBLIC	??_C@_03JNMJ@lip?$AA@				; `string'
PUBLIC	??_C@_04OMDE@wait?$AA@				; `string'
PUBLIC	??_C@_05PNBN@width?$AA@				; `string'
PUBLIC	??_C@_08GHGA@rotation?$AA@			; `string'
EXTRN	?Q_atof@@YAMPBD@Z:NEAR				; Q_atof
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseToggle::KeyValue
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_03JNMJ@lip?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_03JNMJ@lip?$AA@ DB 'lip', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OMDE@wait?$AA@
CONST	SEGMENT
??_C@_04OMDE@wait?$AA@ DB 'wait', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PNBN@width?$AA@
CONST	SEGMENT
??_C@_05PNBN@width?$AA@ DB 'width', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHGA@rotation?$AA@
CONST	SEGMENT
??_C@_08GHGA@rotation?$AA@ DB 'rotation', 00H		; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBasePlatTrain@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CBasePlatTrain@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBasePlatTrain::KeyValue, COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	if( FStrEq( pkvd->szKeyName, "lip" ))

	push	OFFSET FLAT:??_C@_03JNMJ@lip?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L36665

; 61   : 		m_flLip = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1828]

; 62   : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 64   : 	else if( FStrEq( pkvd->szKeyName, "wait" ))

	jmp	$L36685
$L36665:
	push	OFFSET FLAT:??_C@_04OMDE@wait?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L36668

; 66   : 		m_flWait = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1764]

; 67   : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 69   : 	else if( FStrEq( pkvd->szKeyName, "height" ))

	jmp	$L36685
$L36668:
	push	OFFSET FLAT:??_C@_06OKPG@height?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L36671

; 71   : 		m_flHeight = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1904]

; 72   : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 74   : 	else if( FStrEq( pkvd->szKeyName, "width" ))

	jmp	$L36685
$L36671:
	push	OFFSET FLAT:??_C@_05PNBN@width?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L36674

; 76   : 		m_flWidth = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1908]

; 77   : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 79   : 	else if( FStrEq( pkvd->szKeyName, "rotation" ))

	jmp	$L36685
$L36674:
	push	OFFSET FLAT:??_C@_08GHGA@rotation?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L36677

; 81   : 		m_vecFinalAngle.x = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1924]

; 82   : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 84   : 	else if( FStrEq( pkvd->szKeyName, "movesnd" ))

	jmp	$L36685
$L36677:
	push	OFFSET FLAT:??_C@_07HPHJ@movesnd?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L36680

; 86   : 		m_iMoveSnd = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1956], eax

; 87   : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 89   : 	else if( FStrEq( pkvd->szKeyName, "stopsnd" ))

	jmp	$L36685
$L36680:
	push	OFFSET FLAT:??_C@_07KHB@stopsnd?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L36682

; 91   : 		m_iStopSnd = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1960], eax

; 92   : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 94   : 	else if( FStrEq( pkvd->szKeyName, "volume" ))

	jmp	SHORT $L36685
$L36682:
	push	OFFSET FLAT:??_C@_06FLOP@volume?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L36684

; 96   : 		m_volume = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1964]

; 97   : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 99   : 	else

	jmp	SHORT $L36685
$L36684:

; 100  : 		BaseClass::KeyValue( pkvd );

	mov	eax, DWORD PTR _pkvd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z ; CBaseToggle::KeyValue
$L36685:

; 101  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBasePlatTrain@@UAEXPAUKeyValueData_s@@@Z ENDP ; CBasePlatTrain::KeyValue
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
PUBLIC	?Precache@CBasePlatTrain@@UAEXXZ		; CBasePlatTrain::Precache
PUBLIC	??_C@_0BA@LNFJ@common?1null?4wav?$AA@		; `string'
PUBLIC	??_C@_0BD@HCHF@plats?1bigmove1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@JCBK@plats?1bigmove2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@GPDA@plats?1elevmove1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@IPFP@plats?1elevmove2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@CPHK@plats?1elevmove3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BH@PED@plats?1freightmove1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BH@OPCM@plats?1freightmove2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@EMBJ@plats?1heavymove1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@DHCG@plats?1rackmove1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@BJAI@plats?1railmove1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BG@FCFK@plats?1squeekmove1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@BBJL@plats?1talkmove1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@PBPE@plats?1talkmove2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@PIKI@plats?1bigstop1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@BIMH@plats?1bigstop2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BH@IFJO@plats?1freightstop1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@CGKL@plats?1heavystop2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@LNPL@plats?1rackstop1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@JDNF@plats?1railstop1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BG@NIIH@plats?1squeekstop1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@JLEG@plats?1talkstop1?4wav?$AA@	; `string'
EXTRN	?UTIL_PrecacheSound@@YAHPBD@Z:NEAR		; UTIL_PrecacheSound
EXTRN	?UTIL_PrecacheSound@@YAHH@Z:NEAR		; UTIL_PrecacheSound
EXTRN	?UTIL_LoadSoundPreset@@YAHH@Z:NEAR		; UTIL_LoadSoundPreset
;	COMDAT ??_C@_0BA@LNFJ@common?1null?4wav?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BA@LNFJ@common?1null?4wav?$AA@ DB 'common/null.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HCHF@plats?1bigmove1?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@HCHF@plats?1bigmove1?4wav?$AA@ DB 'plats/bigmove1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JCBK@plats?1bigmove2?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@JCBK@plats?1bigmove2?4wav?$AA@ DB 'plats/bigmove2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GPDA@plats?1elevmove1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@GPDA@plats?1elevmove1?4wav?$AA@ DB 'plats/elevmove1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IPFP@plats?1elevmove2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@IPFP@plats?1elevmove2?4wav?$AA@ DB 'plats/elevmove2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CPHK@plats?1elevmove3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@CPHK@plats?1elevmove3?4wav?$AA@ DB 'plats/elevmove3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PED@plats?1freightmove1?4wav?$AA@
CONST	SEGMENT
??_C@_0BH@PED@plats?1freightmove1?4wav?$AA@ DB 'plats/freightmove1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OPCM@plats?1freightmove2?4wav?$AA@
CONST	SEGMENT
??_C@_0BH@OPCM@plats?1freightmove2?4wav?$AA@ DB 'plats/freightmove2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EMBJ@plats?1heavymove1?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@EMBJ@plats?1heavymove1?4wav?$AA@ DB 'plats/heavymove1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DHCG@plats?1rackmove1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@DHCG@plats?1rackmove1?4wav?$AA@ DB 'plats/rackmove1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BJAI@plats?1railmove1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@BJAI@plats?1railmove1?4wav?$AA@ DB 'plats/railmove1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FCFK@plats?1squeekmove1?4wav?$AA@
CONST	SEGMENT
??_C@_0BG@FCFK@plats?1squeekmove1?4wav?$AA@ DB 'plats/squeekmove1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BBJL@plats?1talkmove1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@BBJL@plats?1talkmove1?4wav?$AA@ DB 'plats/talkmove1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PBPE@plats?1talkmove2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@PBPE@plats?1talkmove2?4wav?$AA@ DB 'plats/talkmove2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PIKI@plats?1bigstop1?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@PIKI@plats?1bigstop1?4wav?$AA@ DB 'plats/bigstop1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BIMH@plats?1bigstop2?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@BIMH@plats?1bigstop2?4wav?$AA@ DB 'plats/bigstop2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IFJO@plats?1freightstop1?4wav?$AA@
CONST	SEGMENT
??_C@_0BH@IFJO@plats?1freightstop1?4wav?$AA@ DB 'plats/freightstop1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CGKL@plats?1heavystop2?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@CGKL@plats?1heavystop2?4wav?$AA@ DB 'plats/heavystop2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LNPL@plats?1rackstop1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@LNPL@plats?1rackstop1?4wav?$AA@ DB 'plats/rackstop1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JDNF@plats?1railstop1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@JDNF@plats?1railstop1?4wav?$AA@ DB 'plats/railstop1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NIIH@plats?1squeekstop1?4wav?$AA@
CONST	SEGMENT
??_C@_0BG@NIIH@plats?1squeekstop1?4wav?$AA@ DB 'plats/squeekstop1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JLEG@plats?1talkstop1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@JLEG@plats?1talkstop1?4wav?$AA@ DB 'plats/talkstop1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?Precache@CBasePlatTrain@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_m_sound$ = -8
?Precache@CBasePlatTrain@@UAEXXZ PROC NEAR		; CBasePlatTrain::Precache, COMDAT

; 104  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 	int m_sound = UTIL_LoadSoundPreset( m_iMoveSnd );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1956]
	push	ecx
	call	?UTIL_LoadSoundPreset@@YAHH@Z		; UTIL_LoadSoundPreset
	add	esp, 4
	mov	DWORD PTR _m_sound$[ebp], eax

; 109  : 	{

	mov	edx, DWORD PTR _m_sound$[ebp]
	mov	DWORD PTR -12+[ebp], edx
	cmp	DWORD PTR -12+[ebp], 13			; 0000000dH
	ja	$L36723
	mov	eax, DWORD PTR -12+[ebp]
	jmp	DWORD PTR $L40644[eax*4]
$L36695:

; 110  : 	case 0:
; 111  : 		pev->noise = UTIL_PrecacheSound( "common/null.wav" );

	push	OFFSET FLAT:??_C@_0BA@LNFJ@common?1null?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 112  : 		break;

	jmp	$L36692
$L36697:

; 113  : 	case 1:
; 114  : 		pev->noise = UTIL_PrecacheSound( "plats/bigmove1.wav" );

	push	OFFSET FLAT:??_C@_0BD@HCHF@plats?1bigmove1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 115  : 		break;

	jmp	$L36692
$L36699:

; 116  : 	case 2:
; 117  : 		pev->noise = UTIL_PrecacheSound( "plats/bigmove2.wav" );

	push	OFFSET FLAT:??_C@_0BD@JCBK@plats?1bigmove2?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 118  : 		break;

	jmp	$L36692
$L36701:

; 119  : 	case 3:
; 120  : 		pev->noise = UTIL_PrecacheSound( "plats/elevmove1.wav" );

	push	OFFSET FLAT:??_C@_0BE@GPDA@plats?1elevmove1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 121  : 		break;

	jmp	$L36692
$L36703:

; 122  : 	case 4:
; 123  : 		pev->noise = UTIL_PrecacheSound( "plats/elevmove2.wav" );

	push	OFFSET FLAT:??_C@_0BE@IPFP@plats?1elevmove2?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 124  : 		break;

	jmp	$L36692
$L36705:

; 125  : 	case 5:
; 126  : 		pev->noise = UTIL_PrecacheSound( "plats/elevmove3.wav" );

	push	OFFSET FLAT:??_C@_0BE@CPHK@plats?1elevmove3?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 127  : 		break;

	jmp	$L36692
$L36707:

; 128  : 	case 6:
; 129  : 		pev->noise = UTIL_PrecacheSound( "plats/freightmove1.wav" );

	push	OFFSET FLAT:??_C@_0BH@PED@plats?1freightmove1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 130  : 		break;

	jmp	$L36692
$L36709:

; 131  : 	case 7:
; 132  : 		pev->noise = UTIL_PrecacheSound( "plats/freightmove2.wav" );

	push	OFFSET FLAT:??_C@_0BH@OPCM@plats?1freightmove2?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 133  : 		break;

	jmp	$L36692
$L36711:

; 134  : 	case 8:
; 135  : 		pev->noise = UTIL_PrecacheSound( "plats/heavymove1.wav" );

	push	OFFSET FLAT:??_C@_0BF@EMBJ@plats?1heavymove1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 136  : 		break;

	jmp	$L36692
$L36713:

; 137  : 	case 9:
; 138  : 		pev->noise = UTIL_PrecacheSound( "plats/rackmove1.wav" );

	push	OFFSET FLAT:??_C@_0BE@DHCG@plats?1rackmove1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 139  : 		break;

	jmp	$L36692
$L36715:

; 140  : 	case 10:
; 141  : 		pev->noise = UTIL_PrecacheSound( "plats/railmove1.wav" );

	push	OFFSET FLAT:??_C@_0BE@BJAI@plats?1railmove1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 142  : 		break;

	jmp	SHORT $L36692
$L36717:

; 143  : 	case 11:
; 144  : 		pev->noise = UTIL_PrecacheSound( "plats/squeekmove1.wav" );

	push	OFFSET FLAT:??_C@_0BG@FCFK@plats?1squeekmove1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 145  : 		break;

	jmp	SHORT $L36692
$L36719:

; 146  : 	case 12:
; 147  : 		pev->noise = UTIL_PrecacheSound( "plats/talkmove1.wav" );

	push	OFFSET FLAT:??_C@_0BE@BBJL@plats?1talkmove1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 148  : 		break;

	jmp	SHORT $L36692
$L36721:

; 149  : 	case 13:
; 150  : 		pev->noise = UTIL_PrecacheSound( "plats/talkmove2.wav" );

	push	OFFSET FLAT:??_C@_0BE@PBPE@plats?1talkmove2?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 151  : 		break;

	jmp	SHORT $L36692
$L36723:

; 152  : 	default:
; 153  : 		pev->noise = UTIL_PrecacheSound( m_sound );

	mov	eax, DWORD PTR _m_sound$[ebp]
	push	eax
	call	?UTIL_PrecacheSound@@YAHH@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax
$L36692:

; 156  : 
; 157  : 	m_sound = UTIL_LoadSoundPreset( m_iStopSnd );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1960]
	push	ecx
	call	?UTIL_LoadSoundPreset@@YAHH@Z		; UTIL_LoadSoundPreset
	add	esp, 4
	mov	DWORD PTR _m_sound$[ebp], eax

; 161  : 	{

	mov	edx, DWORD PTR _m_sound$[ebp]
	mov	DWORD PTR -16+[ebp], edx
	cmp	DWORD PTR -16+[ebp], 8
	ja	$L36745
	mov	eax, DWORD PTR -16+[ebp]
	jmp	DWORD PTR $L40645[eax*4]
$L36728:

; 162  : 	case 0:
; 163  : 		pev->noise1 = UTIL_PrecacheSound( "common/null.wav" );

	push	OFFSET FLAT:??_C@_0BA@LNFJ@common?1null?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 164  : 		break;

	jmp	$L36725
$L36729:

; 165  : 	case 1:
; 166  : 		pev->noise1 = UTIL_PrecacheSound( "plats/bigstop1.wav" );

	push	OFFSET FLAT:??_C@_0BD@PIKI@plats?1bigstop1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 167  : 		break;

	jmp	$L36725
$L36731:

; 168  : 	case 2:
; 169  : 		pev->noise1 = UTIL_PrecacheSound( "plats/bigstop2.wav" );

	push	OFFSET FLAT:??_C@_0BD@BIMH@plats?1bigstop2?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 170  : 		break;

	jmp	$L36725
$L36733:

; 171  : 	case 3:
; 172  : 		pev->noise1 = UTIL_PrecacheSound( "plats/freightstop1.wav" );

	push	OFFSET FLAT:??_C@_0BH@IFJO@plats?1freightstop1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 173  : 		break;

	jmp	$L36725
$L36735:

; 174  : 	case 4:
; 175  : 		pev->noise1 = UTIL_PrecacheSound( "plats/heavystop2.wav" );

	push	OFFSET FLAT:??_C@_0BF@CGKL@plats?1heavystop2?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 176  : 		break;

	jmp	$L36725
$L36737:

; 177  : 	case 5:
; 178  : 		pev->noise1 = UTIL_PrecacheSound( "plats/rackstop1.wav" );

	push	OFFSET FLAT:??_C@_0BE@LNPL@plats?1rackstop1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 179  : 		break;

	jmp	SHORT $L36725
$L36739:

; 180  : 	case 6:
; 181  : 		pev->noise1 = UTIL_PrecacheSound( "plats/railstop1.wav" );

	push	OFFSET FLAT:??_C@_0BE@JDNF@plats?1railstop1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 182  : 		break;

	jmp	SHORT $L36725
$L36741:

; 183  : 	case 7:
; 184  : 		pev->noise1 = UTIL_PrecacheSound( "plats/squeekstop1.wav" );

	push	OFFSET FLAT:??_C@_0BG@NIIH@plats?1squeekstop1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 185  : 		break;

	jmp	SHORT $L36725
$L36743:

; 186  : 	case 8:
; 187  : 		pev->noise1 = UTIL_PrecacheSound( "plats/talkstop1.wav" );

	push	OFFSET FLAT:??_C@_0BE@JLEG@plats?1talkstop1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 188  : 		break;

	jmp	SHORT $L36725
$L36745:

; 189  : 	default:
; 190  : 		pev->noise1 = UTIL_PrecacheSound( m_sound );

	mov	eax, DWORD PTR _m_sound$[ebp]
	push	eax
	call	?UTIL_PrecacheSound@@YAHH@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax
$L36725:

; 193  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L40644:
	DD	$L36695
	DD	$L36697
	DD	$L36699
	DD	$L36701
	DD	$L36703
	DD	$L36705
	DD	$L36707
	DD	$L36709
	DD	$L36711
	DD	$L36713
	DD	$L36715
	DD	$L36717
	DD	$L36719
	DD	$L36721
$L40645:
	DD	$L36728
	DD	$L36729
	DD	$L36731
	DD	$L36733
	DD	$L36735
	DD	$L36737
	DD	$L36739
	DD	$L36741
	DD	$L36743
?Precache@CBasePlatTrain@@UAEXXZ ENDP			; CBasePlatTrain::Precache
_TEXT	ENDS
;	COMDAT _$E30
_TEXT	SEGMENT
_$E30	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E29
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E30	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncPlat@@@@QAE@PBD@Z	; CEntityFactory<CFuncPlat>::CEntityFactory<CFuncPlat>
PUBLIC	??_C@_09HHKD@func_plat?$AA@			; `string'
_BSS	SEGMENT
	ALIGN	4

_func_plat DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09HHKD@func_plat?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_09HHKD@func_plat?$AA@ DB 'func_plat', 00H		; `string'
CONST	ENDS
;	COMDAT _$E29
_TEXT	SEGMENT
_$E29	PROC NEAR					; COMDAT

; 233  : LINK_ENTITY_TO_CLASS( func_plat, CFuncPlat );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_09HHKD@func_plat?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_func_plat
	call	??0?$CEntityFactory@VCFuncPlat@@@@QAE@PBD@Z ; CEntityFactory<CFuncPlat>::CEntityFactory<CFuncPlat>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E29	ENDP
_TEXT	ENDS
;	COMDAT _$E33
_TEXT	SEGMENT
_$E33	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E32
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E33	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@FILI@func_platform?$AA@		; `string'
_BSS	SEGMENT
_func_platform DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@FILI@func_platform?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0O@FILI@func_platform?$AA@ DB 'func_platform', 00H ; `string'
CONST	ENDS
;	COMDAT _$E32
_TEXT	SEGMENT
_$E32	PROC NEAR					; COMDAT

; 234  : LINK_ENTITY_TO_CLASS( func_platform, CFuncPlat );	// a elevator

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0O@FILI@func_platform?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_platform
	call	??0?$CEntityFactory@VCFuncPlat@@@@QAE@PBD@Z ; CEntityFactory<CFuncPlat>::CEntityFactory<CFuncPlat>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E32	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CFuncPlat@@UAEPAUdatamap_s@@XZ	; CFuncPlat::GetDataDescMap
;	COMDAT ?GetDataDescMap@CFuncPlat@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CFuncPlat@@UAEPAUdatamap_s@@XZ PROC NEAR ; CFuncPlat::GetDataDescMap, COMDAT

; 236  : BEGIN_DATADESC( CFuncPlat )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncPlat@@2Udatamap_s@@A ; CFuncPlat::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CFuncPlat@@UAEPAUdatamap_s@@XZ ENDP	; CFuncPlat::GetDataDescMap
_TEXT	ENDS
PUBLIC	?DataMapAccess@@YAXPAVCBasePlatTrain@@PAPAUdatamap_s@@@Z ; DataMapAccess
PUBLIC	?GetBaseMap@CFuncPlat@@SAPAUdatamap_s@@XZ	; CFuncPlat::GetBaseMap
;	COMDAT ?GetBaseMap@CFuncPlat@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CFuncPlat@@SAPAUdatamap_s@@XZ PROC NEAR	; CFuncPlat::GetBaseMap, COMDAT

; 236  : BEGIN_DATADESC( CFuncPlat )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBasePlatTrain@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CFuncPlat@@SAPAUdatamap_s@@XZ ENDP		; CFuncPlat::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT
_$E36	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E35
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E36	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z	; DataMapInit
;	COMDAT _$E35
_TEXT	SEGMENT
_$E35	PROC NEAR					; COMDAT

; 236  : BEGIN_DATADESC( CFuncPlat )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CFuncPlat_DataDescInit@@3PAUdatamap_s@@A, eax ; CFuncPlat_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E35	ENDP
_TEXT	ENDS
PUBLIC	??_C@_07JPAN@PlatUse?$AA@			; `string'
PUBLIC	??_C@_09FKJM@FloorCalc?$AA@			; `string'
PUBLIC	??_C@_08LEJO@CallGoUp?$AA@			; `string'
PUBLIC	??_C@_0L@EDMM@CallGoDown?$AA@			; `string'
PUBLIC	??_C@_0L@OBGH@CallHitTop?$AA@			; `string'
PUBLIC	??_C@_0O@FDMJ@CallHitBottom?$AA@		; `string'
PUBLIC	??_C@_0N@CLLJ@CallHitFloor?$AA@			; `string'
PUBLIC	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
PUBLIC	?PlatUse@CFuncPlat@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncPlat::PlatUse
PUBLIC	?FloorCalc@CFuncPlat@@QAEXXZ			; CFuncPlat::FloorCalc
PUBLIC	?CallGoUp@CFuncPlat@@QAEXXZ			; CFuncPlat::CallGoUp
PUBLIC	?CallGoDown@CFuncPlat@@QAEXXZ			; CFuncPlat::CallGoDown
PUBLIC	?CallHitTop@CFuncPlat@@QAEXXZ			; CFuncPlat::CallHitTop
PUBLIC	?CallHitBottom@CFuncPlat@@QAEXXZ		; CFuncPlat::CallHitBottom
PUBLIC	?CallHitFloor@CFuncPlat@@QAEXXZ			; CFuncPlat::CallHitFloor
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_07JPAN@PlatUse?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_07JPAN@PlatUse?$AA@ DB 'PlatUse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FKJM@FloorCalc?$AA@
CONST	SEGMENT
??_C@_09FKJM@FloorCalc?$AA@ DB 'FloorCalc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LEJO@CallGoUp?$AA@
CONST	SEGMENT
??_C@_08LEJO@CallGoUp?$AA@ DB 'CallGoUp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EDMM@CallGoDown?$AA@
CONST	SEGMENT
??_C@_0L@EDMM@CallGoDown?$AA@ DB 'CallGoDown', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OBGH@CallHitTop?$AA@
CONST	SEGMENT
??_C@_0L@OBGH@CallHitTop?$AA@ DB 'CallHitTop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FDMJ@CallHitBottom?$AA@
CONST	SEGMENT
??_C@_0O@FDMJ@CallHitBottom?$AA@ DB 'CallHitBottom', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CLLJ@CallHitFloor?$AA@
CONST	SEGMENT
??_C@_0N@CLLJ@CallHitFloor?$AA@ DB 'CallHitFloor', 00H	; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z PROC NEAR ; DataMapInit, COMDAT

; 236  : BEGIN_DATADESC( CFuncPlat )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L36910
	mov	cl, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_09HOM@CFuncPlat?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E39
	call	_atexit
	add	esp, 4
$L36910:
	call	?GetBaseMap@CFuncPlat@@SAPAUdatamap_s@@XZ ; CFuncPlat::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CFuncPlat@@2Udatamap_s@@A+12, eax

; 237  : 	DEFINE_FUNCTION( PlatUse ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L36914
	mov	al, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_07JPAN@PlatUse?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+28, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+32, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+36, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+38, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+40, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+44, OFFSET FLAT:?PlatUse@CFuncPlat@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncPlat::PlatUse

; 238  : 	DEFINE_FUNCTION( FloorCalc ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+48, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_09FKJM@FloorCalc?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+52, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+56, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+60, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+62, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+64, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+68, OFFSET FLAT:?FloorCalc@CFuncPlat@@QAEXXZ ; CFuncPlat::FloorCalc

; 239  : 	DEFINE_FUNCTION( CallGoUp ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+72, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_08LEJO@CallGoUp?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+76, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+80, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+84, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+86, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+88, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+92, OFFSET FLAT:?CallGoUp@CFuncPlat@@QAEXXZ ; CFuncPlat::CallGoUp

; 240  : 	DEFINE_FUNCTION( CallGoDown ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+96, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0L@EDMM@CallGoDown?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+100, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+104, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+108, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+110, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+112, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+116, OFFSET FLAT:?CallGoDown@CFuncPlat@@QAEXXZ ; CFuncPlat::CallGoDown

; 241  : 	DEFINE_FUNCTION( CallHitTop ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+120, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0L@OBGH@CallHitTop?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+124, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+128, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+132, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+134, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+136, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+140, OFFSET FLAT:?CallHitTop@CFuncPlat@@QAEXXZ ; CFuncPlat::CallHitTop

; 242  : 	DEFINE_FUNCTION( CallHitBottom ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+144, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0O@FDMJ@CallHitBottom?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+148, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+152, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+156, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+158, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+160, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+164, OFFSET FLAT:?CallHitBottom@CFuncPlat@@QAEXXZ ; CFuncPlat::CallHitBottom

; 243  : 	DEFINE_FUNCTION( CallHitFloor ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+168, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0N@CLLJ@CallHitFloor?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+172, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+176, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+180, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+182, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+184, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+188, OFFSET FLAT:?CallHitFloor@CFuncPlat@@QAEXXZ ; CFuncPlat::CallHitFloor
$L36914:

; 244  : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L36936
	mov	DWORD PTR ?m_DataMap@CFuncPlat@@2Udatamap_s@@A+4, 7
	mov	DWORD PTR ?m_DataMap@CFuncPlat@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L36937
$L36936:
	mov	DWORD PTR ?m_DataMap@CFuncPlat@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncPlat@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4PAUtypedescription_s@@A
$L36937:
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncPlat@@2Udatamap_s@@A ; CFuncPlat::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z ENDP	; DataMapInit
_TEXT	ENDS
PUBLIC	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
PUBLIC	??_C@_04NHIK@?$CFs?3?3?$AA@			; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_strcat:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
; File z:\xashxtsrc\common\datamap.h
CONST	SEGMENT
??_C@_04NHIK@?$CFs?3?3?$AA@ DB '%s::', 00H		; `string'
CONST	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT
_pszIdentifier$ = 8
_this$ = -4
_pBuf$ = -8
$T40666 = -12
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z PROC NEAR ; CDatadescGeneratedNameHolder::GenerateName, COMDAT

; 205  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		char *pBuf = new char[m_nLenBase + strlen(pszIdentifier) + 1];

	mov	eax, DWORD PTR _pszIdentifier$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax+1]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T40666[ebp], eax
	mov	ecx, DWORD PTR $T40666[ebp]
	mov	DWORD PTR _pBuf$[ebp], ecx

; 207  : 		sprintf( pBuf, "%s::", m_pszBase );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_04NHIK@?$CFs?3?3?$AA@	; `string'
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 208  : 		strcat( pBuf, pszIdentifier );

	mov	edx, DWORD PTR _pszIdentifier$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 209  : 		m_Names.AddToTail( pBuf );

	lea	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail

; 210  : 		return pBuf;

	mov	eax, DWORD PTR _pBuf$[ebp]

; 211  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ENDP ; CDatadescGeneratedNameHolder::GenerateName
_TEXT	ENDS
;	COMDAT ?CallGoUp@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CallGoUp@CFuncPlat@@QAEXXZ PROC NEAR			; CFuncPlat::CallGoUp, COMDAT

; 213  : 	void CallGoUp( void ) { GoUp(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+348]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CallGoUp@CFuncPlat@@QAEXXZ ENDP			; CFuncPlat::CallGoUp
_TEXT	ENDS
;	COMDAT ?CallGoDown@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CallGoDown@CFuncPlat@@QAEXXZ PROC NEAR			; CFuncPlat::CallGoDown, COMDAT

; 214  : 	void CallGoDown( void ) { GoDown(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+352]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CallGoDown@CFuncPlat@@QAEXXZ ENDP			; CFuncPlat::CallGoDown
_TEXT	ENDS
;	COMDAT ?CallHitTop@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CallHitTop@CFuncPlat@@QAEXXZ PROC NEAR			; CFuncPlat::CallHitTop, COMDAT

; 215  : 	void CallHitTop( void  ) { HitTop(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+356]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CallHitTop@CFuncPlat@@QAEXXZ ENDP			; CFuncPlat::CallHitTop
_TEXT	ENDS
;	COMDAT ?CallHitBottom@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CallHitBottom@CFuncPlat@@QAEXXZ PROC NEAR		; CFuncPlat::CallHitBottom, COMDAT

; 216  : 	void CallHitBottom( void ) { HitBottom(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+360]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CallHitBottom@CFuncPlat@@QAEXXZ ENDP			; CFuncPlat::CallHitBottom
_TEXT	ENDS
;	COMDAT ?CallHitFloor@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CallHitFloor@CFuncPlat@@QAEXXZ PROC NEAR		; CFuncPlat::CallHitFloor, COMDAT

; 217  : 	void CallHitFloor( void ) { HitFloor(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+364]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CallHitFloor@CFuncPlat@@QAEXXZ ENDP			; CFuncPlat::CallHitFloor
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT
_$E39	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlat@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E39	ENDP
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	__real@4@00000000000000000000
PUBLIC	__real@4@40028000000000000000
PUBLIC	?Setup@CFuncPlat@@QAEXXZ			; CFuncPlat::Setup
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
EXTRN	?WorldPhysic@@3PAVIPhysicLayer@@A:DWORD		; WorldPhysic
EXTRN	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalOrigin
EXTRN	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAngles
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z:NEAR ; UTIL_SetSize
EXTRN	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z:NEAR ; CBaseEntity::RelinkEntity
;	COMDAT __real@4@00000000000000000000
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT __real@4@40028000000000000000
CONST	SEGMENT
__real@4@40028000000000000000 DD 041000000r	; 8
CONST	ENDS
;	COMDAT ?Setup@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
$T40681 = -16
$T40682 = -28
$T40683 = -40
?Setup@CFuncPlat@@QAEXXZ PROC NEAR			; CFuncPlat::Setup, COMDAT

; 279  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 	if( m_flTLength == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1836]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L36981

; 281  : 		m_flTLength = 80;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1836], 1117782016	; 42a00000H
$L36981:

; 282  : 	if( m_flTWidth == 0 )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1832]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L36982

; 283  : 		m_flTWidth = 10;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1832], 1092616192	; 41200000H
$L36982:

; 284  : 
; 285  : 	if( pev->movedir == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 68					; 00000044H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L36983

; 286  : 		pev->movedir = Vector( 1.0f, 0.0f, 0.0f );

	push	0
	push	0
	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR $T40681[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L36983:

; 287  : 
; 288  : 	SetLocalAngles( g_vecZero );	

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 289  : 
; 290  : 	pev->solid = SOLID_BSP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 4

; 291  : 	pev->movetype = MOVETYPE_PUSH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 7

; 292  : 
; 293  : 	RelinkEntity( TRUE ); // set size and link into world

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 294  : 	UTIL_SetSize( pev, pev->mins, pev->maxs);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 232				; 000000e8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 220				; 000000dcH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 295  : 	SET_MODEL( edict(), STRING( pev->model ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+184]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 296  : 
; 297  : 	m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 298  : 
; 299  : 	// vecPosition1 is the top position, vecPosition2 is the bottom
; 300  : 	m_vecPosition1 = GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1840				; 00000730H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 301  : 	m_vecPosition2 = GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 302  : 
; 303  : 	if( m_flWidth != 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1908]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L36985

; 305  : 		m_vecPosition2 = m_vecPosition1 + (pev->movedir * m_flWidth);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1908]
	push	eax
	lea	ecx, DWORD PTR $T40682[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40683[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 306  : 
; 307  : 		if( m_flHeight != 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1904]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L36988

; 308  : 			m_vecPosition2.z = m_vecPosition2.z - m_flHeight;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1860]
	fsub	DWORD PTR [eax+1904]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1860]

; 309  : 		else

	jmp	SHORT $L36989
$L36988:

; 310  : 			m_vecPosition2.z = m_vecPosition1.z; // just kill Z-component

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1848]
	mov	DWORD PTR [edx+1860], ecx
$L36989:

; 312  : 	else

	jmp	SHORT $L36992
$L36985:

; 314  : 		if( m_flHeight != 0 )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1904]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L36991

; 315  : 			m_vecPosition2.z = m_vecPosition2.z - m_flHeight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1860]
	fsub	DWORD PTR [ecx+1904]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1860]

; 316  : 		else

	jmp	SHORT $L36992
$L36991:

; 317  : 			m_vecPosition2.z = m_vecPosition2.z - pev->size.z + 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1860]
	fsub	DWORD PTR [ecx+252]
	fadd	DWORD PTR __real@4@40028000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1860]
$L36992:

; 319  : 
; 320  : 	if( !pev->speed )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L36993

; 321  : 		pev->speed = 150;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+504], 1125515264		; 43160000H
$L36993:

; 322  : 
; 323  : 	if( !m_volume )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1964]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L36994

; 324  : 		m_volume = 0.85f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1964], 1062836634	; 3f59999aH
$L36994:

; 325  : 
; 326  : 	if( !pev->dmg )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+480]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L36995

; 327  : 		pev->dmg = 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+480], 1065353216		; 3f800000H
$L36995:

; 328  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Setup@CFuncPlat@@QAEXXZ ENDP				; CFuncPlat::Setup
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40692
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40692
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40692
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40693
$L40692:
	mov	DWORD PTR -8+[ebp], 0
$L40693:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40696 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40696[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40701 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40701[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z		; FClassnameIs
PUBLIC	?Precache@CFuncPlat@@UAEXXZ			; CFuncPlat::Precache
;	COMDAT ?Precache@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CFuncPlat@@UAEXXZ PROC NEAR			; CFuncPlat::Precache, COMDAT

; 331  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 332  : 	CBasePlatTrain::Precache();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Precache@CBasePlatTrain@@UAEXXZ	; CBasePlatTrain::Precache

; 333  : 
; 334  : 	if( !IsTogglePlat( ) && !FClassnameIs( pev, "func_platform" ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+344]
	test	eax, eax
	jne	SHORT $L36999
	push	OFFSET FLAT:??_C@_0O@FILI@func_platform?$AA@ ; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	jne	SHORT $L36999

; 335  : 		PlatSpawnInsideTrigger( pev ); // the "start moving" trigger

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?PlatSpawnInsideTrigger@@YAXPAUentvars_s@@@Z ; PlatSpawnInsideTrigger
	add	esp, 4
$L36999:

; 336  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CFuncPlat@@UAEXXZ ENDP			; CFuncPlat::Precache
_TEXT	ENDS
PUBLIC	?FNullEnt@@YAHPAUentvars_s@@@Z			; FNullEnt
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT
_pev$ = 8
_szClassname$ = 12
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z PROC NEAR		; FClassnameIs, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 295  : 	if( FNullEnt( pev )) return FALSE;

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L32565
	xor	eax, eax
	jmp	SHORT $L32564
$L32565:

; 296  : 	return FStrEq( STRING( pev->classname ), szClassname );

	mov	ecx, DWORD PTR _szClassname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pev$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
$L32564:

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z ENDP		; FClassnameIs
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?FNullEnt@@YAHPAUentvars_s@@@Z PROC NEAR		; FNullEnt, COMDAT

; 196  : inline BOOL FNullEnt(entvars_t* pev)				{ return pev == NULL || FNullEnt(OFFSET(pev)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pev$[ebp], 0
	je	SHORT $L40712
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40712
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L40713
$L40712:
	mov	DWORD PTR -4+[ebp], 1
$L40713:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAUentvars_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad pev in OFFSET()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?OFFSET@@YAHPAUentvars_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L32439

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32439:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
PUBLIC	?SpawnInsideTrigger@CPlatTrigger@@QAEXPAVCFuncPlat@@@Z ; CPlatTrigger::SpawnInsideTrigger
PUBLIC	?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z	; GetClassPtr
PUBLIC	?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z		; GetClassPtr
;	COMDAT ?PlatSpawnInsideTrigger@@YAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pevPlatform$ = 8
?PlatSpawnInsideTrigger@@YAXPAUentvars_s@@@Z PROC NEAR	; PlatSpawnInsideTrigger, COMDAT

; 258  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 259  : 	GetClassPtr(( CPlatTrigger *)NULL)->SpawnInsideTrigger( GetClassPtr(( CFuncPlat *)pevPlatform ));

	mov	eax, DWORD PTR _pevPlatform$[ebp]
	push	eax
	call	?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z	; GetClassPtr
	add	esp, 4
	push	eax
	push	0
	call	?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z ; GetClassPtr
	add	esp, 4
	mov	ecx, eax
	call	?SpawnInsideTrigger@CPlatTrigger@@QAEXPAVCFuncPlat@@@Z ; CPlatTrigger::SpawnInsideTrigger

; 260  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PlatSpawnInsideTrigger@@YAXPAUentvars_s@@@Z ENDP	; PlatSpawnInsideTrigger
_TEXT	ENDS
PUBLIC	?FStringNull@@YAHH@Z				; FStringNull
PUBLIC	?Spawn@CFuncPlat@@UAEXXZ			; CFuncPlat::Spawn
PUBLIC	?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ; CBaseEntity::UseSet
EXTRN	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z:NEAR ; UTIL_SetOrigin
;	COMDAT ?Spawn@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CFuncPlat@@UAEXXZ PROC NEAR			; CFuncPlat::Spawn, COMDAT

; 339  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 340  : 	Setup();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Setup@CFuncPlat@@QAEXXZ		; CFuncPlat::Setup

; 341  : 
; 342  : 	Precache();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 343  : 
; 344  : 	// If this platform is the target of some button, it starts at the TOP position,
; 345  : 	// and is brought down by that button.  Otherwise, it starts at BOTTOM.
; 346  : 	if( !FStringNull( pev->targetname ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L37004

; 348  : 		UTIL_SetOrigin( this, m_vecPosition1 );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1840				; 00000730H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 349  : 		m_toggle_state = TS_AT_TOP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1816], 0

; 350  : 		SetUse( PlatUse );

	push	OFFSET FLAT:??_C@_07JPAN@PlatUse?$AA@	; `string'
	push	OFFSET FLAT:?PlatUse@CFuncPlat@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncPlat::PlatUse
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ; CBaseEntity::UseSet

; 352  : 	else

	jmp	SHORT $L37010
$L37004:

; 354  : 		UTIL_SetOrigin( this, m_vecPosition2 );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1852				; 0000073cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 355  : 		m_toggle_state = TS_AT_BOTTOM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1816], 1
$L37010:

; 357  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncPlat@@UAEXXZ ENDP				; CFuncPlat::Spawn
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT
_iString$ = 8
?FStringNull@@YAHH@Z PROC NEAR				; FStringNull, COMDAT

; 201  : inline BOOL FStringNull(int iString)			{ return iString == iStringNull; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _iString$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStringNull@@YAHH@Z ENDP				; FStringNull
_TEXT	ENDS
PUBLIC	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z	; CBaseEntity::FunctionCheck
;	COMDAT ?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z PROC NEAR ; CBaseEntity::UseSet, COMDAT

; 574  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 575  : 		m_pfnUse = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1752], ecx

; 576  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnUse)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1752]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 577  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 578  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ENDP ; CBaseEntity::UseSet
_TEXT	ENDS
PUBLIC	??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:NEAR ; UTIL_FunctionToName
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ DB 'F'
	DB	'UNCTION NOT IN TABLE!: %s:%s (%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT
_this$ = -4
_pFunction$ = 8
_name$ = 12
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z PROC NEAR	; CBaseEntity::FunctionCheck, COMDAT

; 554  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 		if (pFunction && !UTIL_FunctionToName( GetDataDescMap(), pFunction ) )

	cmp	DWORD PTR _pFunction$[ebp], 0
	je	SHORT $L35044
	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	test	eax, eax
	jne	SHORT $L35044

; 556  : 			ALERT( at_warning, "FUNCTION NOT IN TABLE!: %s:%s (%08lx)\n", GetClassname(), name, (unsigned long)pFunction );

	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L35044:

; 557  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ENDP		; CBaseEntity::FunctionCheck
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
PUBLIC	__real@4@4004c800000000000000
PUBLIC	__real@4@40008000000000000000
PUBLIC	__real@4@3fff8000000000000000
EXTRN	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalOrigin
;	COMDAT __real@4@4004c800000000000000
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
__real@4@4004c800000000000000 DD 042480000r	; 50
CONST	ENDS
;	COMDAT __real@4@40008000000000000000
CONST	SEGMENT
__real@4@40008000000000000000 DD 040000000r	; 2
CONST	ENDS
;	COMDAT __real@4@3fff8000000000000000
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT ?SpawnInsideTrigger@CPlatTrigger@@QAEXPAVCFuncPlat@@@Z
_TEXT	SEGMENT
_pPlatform$ = 8
_this$ = -4
_vecTMin$ = -16
_vecTMax$ = -28
$T40734 = -40
$T40735 = -52
$T40736 = -64
$T40737 = -76
?SpawnInsideTrigger@CPlatTrigger@@QAEXPAVCFuncPlat@@@Z PROC NEAR ; CPlatTrigger::SpawnInsideTrigger, COMDAT

; 363  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 	m_pPlatform = pPlatform;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pPlatform$[ebp]
	mov	DWORD PTR [eax+1764], ecx

; 365  : 
; 366  : 	// Create trigger entity, "point" it at the owning platform, give it a touch method
; 367  : 	pev->solid = SOLID_TRIGGER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 1

; 368  : 	pev->movetype = MOVETYPE_NONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+264], 0

; 369  : 	SetLocalOrigin( pPlatform->GetLocalOrigin() );

	mov	ecx, DWORD PTR _pPlatform$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalOrigin

; 370  : 
; 371  : 	// Establish the trigger field's size
; 372  : 	Vector vecTMin = m_pPlatform->pev->mins + Vector ( 25 , 25 , 0 );

	push	0
	push	1103626240				; 41c80000H
	push	1103626240				; 41c80000H
	lea	ecx, DWORD PTR $T40734[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T40735[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1764]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 220				; 000000dcH
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecTMin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 373  : 	Vector vecTMax = m_pPlatform->pev->maxs + Vector ( 25 , 25 , 8 );

	push	1090519040				; 41000000H
	push	1103626240				; 41c80000H
	push	1103626240				; 41c80000H
	lea	ecx, DWORD PTR $T40736[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T40737[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1764]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 232				; 000000e8H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecTMax$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 374  : 	vecTMin.z = vecTMax.z - ( m_pPlatform->m_vecPosition1.z - m_pPlatform->m_vecPosition2.z + 8 );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1764]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1764]
	fld	DWORD PTR [ecx+1848]
	fsub	DWORD PTR [eax+1860]
	fadd	DWORD PTR __real@4@40028000000000000000
	fsubr	DWORD PTR _vecTMax$[ebp+8]
	fstp	DWORD PTR _vecTMin$[ebp+8]

; 375  : 
; 376  : 	if( m_pPlatform->pev->size.x <= 50 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1764]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+244]
	fcomp	DWORD PTR __real@4@4004c800000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L37021

; 378  : 		vecTMin.x = ( m_pPlatform->pev->mins.x + m_pPlatform->pev->maxs.x ) / 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1764]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1764]
	mov	ecx, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+220]
	fadd	DWORD PTR [ecx+232]
	fdiv	DWORD PTR __real@4@40008000000000000000
	fst	DWORD PTR _vecTMin$[ebp]

; 379  : 		vecTMax.x = vecTMin.x + 1;

	fadd	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _vecTMax$[ebp]
$L37021:

; 381  : 
; 382  : 	if( m_pPlatform->pev->size.y <= 50 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1764]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+248]
	fcomp	DWORD PTR __real@4@4004c800000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L37022

; 384  : 		vecTMin.y = ( m_pPlatform->pev->mins.y + m_pPlatform->pev->maxs.y ) / 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1764]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1764]
	mov	edx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+224]
	fadd	DWORD PTR [edx+236]
	fdiv	DWORD PTR __real@4@40008000000000000000
	fst	DWORD PTR _vecTMin$[ebp+4]

; 385  : 		vecTMax.y = vecTMin.y + 1;

	fadd	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _vecTMax$[ebp+4]
$L37022:

; 387  : 
; 388  : 	UTIL_SetSize ( pev, vecTMin, vecTMax );

	lea	eax, DWORD PTR _vecTMax$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecTMin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 389  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SpawnInsideTrigger@CPlatTrigger@@QAEXPAVCFuncPlat@@@Z ENDP ; CPlatTrigger::SpawnInsideTrigger
_TEXT	ENDS
PUBLIC	?Touch@CPlatTrigger@@UAEXPAVCBaseEntity@@@Z	; CPlatTrigger::Touch
PUBLIC	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z		; CBaseEntity::SetMoveDoneTime
;	COMDAT ?Touch@CPlatTrigger@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
?Touch@CPlatTrigger@@UAEXPAVCBaseEntity@@@Z PROC NEAR	; CPlatTrigger::Touch, COMDAT

; 395  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 396  : 	// Ignore touches by non-players
; 397  : 	if( !pOther->IsPlayer( ))

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L37027

; 398  : 		return;

	jmp	SHORT $L37026
$L37027:

; 399  : 
; 400  : 	// Ignore touches by corpses
; 401  : 	if( !pOther->IsAlive( ))

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	jne	SHORT $L37028

; 402  : 		return;

	jmp	SHORT $L37026
$L37028:

; 403  : 	
; 404  : 	// Make linked platform go up/down.
; 405  : 	if( m_pPlatform->m_toggle_state == TS_AT_BOTTOM )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1764]
	cmp	DWORD PTR [ecx+1816], 1
	jne	SHORT $L37029

; 406  : 		m_pPlatform->GoUp();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1764]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1764]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+348]

; 407  : 	else if( m_pPlatform->m_toggle_state == TS_AT_TOP )

	jmp	SHORT $L37031
$L37029:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1764]
	cmp	DWORD PTR [edx+1816], 0
	jne	SHORT $L37031

; 408  : 		m_pPlatform->SetMoveDoneTime( 1 ); // delay going down

	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1764]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime
$L37031:
$L37026:

; 409  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CPlatTrigger@@UAEXPAVCBaseEntity@@@Z ENDP	; CPlatTrigger::Touch
_TEXT	ENDS
PUBLIC	?GetLocalTime@CBaseEntity@@QBEMXZ		; CBaseEntity::GetLocalTime
;	COMDAT ?SetMoveDoneTime@CBaseEntity@@QAEXM@Z
_TEXT	SEGMENT
_flDelay$ = 8
_this$ = -4
?SetMoveDoneTime@CBaseEntity@@QAEXM@Z PROC NEAR		; CBaseEntity::SetMoveDoneTime, COMDAT

; 798  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 799  : 	if( flDelay >= 0 )

	fld	DWORD PTR _flDelay$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L35183

; 800  : 		m_flMoveDoneTime = GetLocalTime() + flDelay;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetLocalTime
	fadd	DWORD PTR _flDelay$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+44]

; 801  : 	else m_flMoveDoneTime = -1;

	jmp	SHORT $L35184
$L35183:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], -1082130432		; bf800000H
$L35184:

; 802  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMoveDoneTime@CBaseEntity@@QAEXM@Z ENDP		; CBaseEntity::SetMoveDoneTime
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetLocalTime@CBaseEntity@@QBEMXZ PROC NEAR		; CBaseEntity::GetLocalTime, COMDAT

; 788  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 789  : 	return pev->ltime; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+256]

; 790  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLocalTime@CBaseEntity@@QBEMXZ ENDP			; CBaseEntity::GetLocalTime
_TEXT	ENDS
PUBLIC	??_C@_04BAK@NULL?$AA@				; `string'
PUBLIC	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z		; EHANDLE::operator=
PUBLIC	?GoToFloor@CFuncPlat@@QAEXM@Z			; CFuncPlat::GoToFloor
EXTRN	?IsLockedByMaster@CBaseDelay@@QAEHXZ:NEAR	; CBaseDelay::IsLockedByMaster
EXTRN	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@H@Z:NEAR ; CBaseEntity::ShouldToggle
;	COMDAT ??_C@_04BAK@NULL?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_04BAK@NULL?$AA@ DB 'NULL', 00H			; `string'
CONST	ENDS
;	COMDAT ?PlatUse@CFuncPlat@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_value$ = 20
_this$ = -4
_on$37042 = -8
?PlatUse@CFuncPlat@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CFuncPlat::PlatUse, COMDAT

; 416  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 417  : 	m_hActivator = pActivator;

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 418  : 
; 419  : 	if( IsLockedByMaster( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHXZ	; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L37039

; 420  : 		return;

	jmp	$L37038
$L37039:

; 421  : 
; 422  : 	if( useType == USE_SET && FClassnameIs( pev, "func_platform" ))

	cmp	DWORD PTR _useType$[ebp], 2
	jne	SHORT $L37040
	push	OFFSET FLAT:??_C@_0O@FILI@func_platform?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L37040

; 424  : 		GoToFloor( value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GoToFloor@CFuncPlat@@QAEXM@Z		; CFuncPlat::GoToFloor

; 425  : 		return;

	jmp	$L37038
$L37040:

; 427  : 
; 428  : 	if( IsTogglePlat( ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+344]
	test	eax, eax
	je	SHORT $L37041

; 430  : 		// Top is off, bottom is on
; 431  : 		BOOL on = (m_toggle_state == TS_AT_BOTTOM) ? TRUE : FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+1816], 1
	sete	cl
	mov	DWORD PTR _on$37042[ebp], ecx

; 432  : 
; 433  : 		if( !ShouldToggle( useType, on ))

	mov	edx, DWORD PTR _on$37042[ebp]
	push	edx
	mov	eax, DWORD PTR _useType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@H@Z ; CBaseEntity::ShouldToggle
	test	eax, eax
	jne	SHORT $L37043

; 434  : 			return;

	jmp	SHORT $L37038
$L37043:

; 435  : 
; 436  : 		if( m_toggle_state == TS_AT_TOP )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 0
	jne	SHORT $L37044

; 437  : 			GoDown();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+352]

; 438  : 		else if( m_toggle_state == TS_AT_BOTTOM )

	jmp	SHORT $L37046
$L37044:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 1
	jne	SHORT $L37046

; 439  : 			GoUp();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+348]
$L37046:

; 441  : 	else

	jmp	SHORT $L37054
$L37041:

; 443  : 		SetUse( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ; CBaseEntity::UseSet

; 444  : 
; 445  : 		if( m_toggle_state == TS_AT_TOP )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 0
	jne	SHORT $L37054

; 446  : 			GoDown();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+352]
$L37054:
$L37038:

; 448  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?PlatUse@CFuncPlat@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CFuncPlat::PlatUse
_TEXT	ENDS
EXTRN	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z:NEAR	; ENT
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z PROC NEAR	; EHANDLE::operator=, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 	if (pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L34280

; 72   : 		m_pent = ENT( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 73   : 		if (m_pent)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L34281

; 74   : 			m_serialnumber = m_pent->serialnumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$L34281:

; 76   : 	else

	jmp	SHORT $L34282
$L34280:

; 78   : 		m_pent = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 79   : 		m_serialnumber = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$L34282:

; 81   : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z ENDP		; EHANDLE::operator=
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GoDown@CFuncPlat@@UAEXXZ@4FA	; `CFuncPlat::GoDown'::`2'::__LINE__Var
PUBLIC	??_C@_0BO@NJDE@z?3?2xashxtsrc?2server?2plats?4cpp?$AA@ ; `string'
PUBLIC	??_C@_0DN@PHDA@m_toggle_state?5?$DN?$DN?5TS_AT_TOP?5?$HM?$HM?5m@ ; `string'
PUBLIC	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z		; EMIT_SOUND
PUBLIC	?GoDown@CFuncPlat@@UAEXXZ			; CFuncPlat::GoDown
PUBLIC	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet
EXTRN	?DBG_AssertFunction@@YAXHPBD0H0@Z:NEAR		; DBG_AssertFunction
EXTRN	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z:NEAR ; CBaseToggle::LinearMove
;	COMDAT ?__LINE__Var@?1??GoDown@CFuncPlat@@UAEXXZ@4FA
; File z:\xashxtsrc\server\plats.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GoDown@CFuncPlat@@UAEXXZ@4FA DW 01c6H	; `CFuncPlat::GoDown'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BO@NJDE@z?3?2xashxtsrc?2server?2plats?4cpp?$AA@
CONST	SEGMENT
??_C@_0BO@NJDE@z?3?2xashxtsrc?2server?2plats?4cpp?$AA@ DB 'z:\xashxtsrc\s'
	DB	'erver\plats.cpp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@PHDA@m_toggle_state?5?$DN?$DN?5TS_AT_TOP?5?$HM?$HM?5m@
CONST	SEGMENT
??_C@_0DN@PHDA@m_toggle_state?5?$DN?$DN?5TS_AT_TOP?5?$HM?$HM?5m@ DB 'm_to'
	DB	'ggle_state == TS_AT_TOP || m_toggle_state == TS_GOING_UP', 00H ; `string'
CONST	ENDS
;	COMDAT ?GoDown@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?GoDown@CFuncPlat@@UAEXXZ PROC NEAR			; CFuncPlat::GoDown, COMDAT

; 454  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 455  : 	if( pev->noise )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+488], 0
	je	SHORT $L37059

; 456  : 		EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ), m_volume, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1964]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+488]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37059:

; 457  : 
; 458  : 	ASSERT( m_toggle_state == TS_AT_TOP || m_toggle_state == TS_GOING_UP );

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 0
	je	SHORT $L40756
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1816], 2
	je	SHORT $L40756
	mov	DWORD PTR -8+[ebp], 0
	jmp	SHORT $L40757
$L40756:
	mov	DWORD PTR -8+[ebp], 1
$L40757:
	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??GoDown@CFuncPlat@@UAEXXZ@4FA ; `CFuncPlat::GoDown'::`2'::__LINE__Var
	add	eax, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BO@NJDE@z?3?2xashxtsrc?2server?2plats?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0DN@PHDA@m_toggle_state?5?$DN?$DN?5TS_AT_TOP?5?$HM?$HM?5m@ ; `string'
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 459  : 
; 460  : 	m_toggle_state = TS_GOING_DOWN;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1816], 3

; 461  : 	SetMoveDone( CallHitBottom );

	push	OFFSET FLAT:??_C@_0O@FDMJ@CallHitBottom?$AA@ ; `string'
	push	OFFSET FLAT:?CallHitBottom@CFuncPlat@@QAEXXZ ; CFuncPlat::CallHitBottom
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 462  : 	LinearMove( m_vecPosition2, pev->speed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+504]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1852				; 0000073cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::LinearMove

; 463  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GoDown@CFuncPlat@@UAEXXZ ENDP				; CFuncPlat::GoDown
_TEXT	ENDS
EXTRN	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z:NEAR	; EMIT_SOUND_DYN
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
_volume$ = 20
_attenuation$ = 24
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z PROC NEAR		; EMIT_SOUND, COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 610  : 	EMIT_SOUND_DYN( entity, channel, sample, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 611  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z ENDP		; EMIT_SOUND
_TEXT	ENDS
;	COMDAT ?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::MoveDoneSet, COMDAT

; 588  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 589  : 		m_pfnMoveDone = func;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1760], ecx

; 590  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnMoveDone)), name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1760]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 591  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 592  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP ; CBaseEntity::MoveDoneSet
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??HitBottom@CFuncPlat@@UAEXXZ@4FA ; `CFuncPlat::HitBottom'::`2'::__LINE__Var
PUBLIC	??_C@_0CA@BPNN@m_toggle_state?5?$DN?$DN?5TS_GOING_DOWN?$AA@ ; `string'
PUBLIC	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z		; STOP_SOUND
PUBLIC	?HitBottom@CFuncPlat@@UAEXXZ			; CFuncPlat::HitBottom
;	COMDAT ?__LINE__Var@?1??HitBottom@CFuncPlat@@UAEXXZ@4FA
; File z:\xashxtsrc\server\plats.cpp
_DATA	SEGMENT
?__LINE__Var@?1??HitBottom@CFuncPlat@@UAEXXZ@4FA DW 01d6H ; `CFuncPlat::HitBottom'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CA@BPNN@m_toggle_state?5?$DN?$DN?5TS_GOING_DOWN?$AA@
CONST	SEGMENT
??_C@_0CA@BPNN@m_toggle_state?5?$DN?$DN?5TS_GOING_DOWN?$AA@ DB 'm_toggle_'
	DB	'state == TS_GOING_DOWN', 00H		; `string'
CONST	ENDS
;	COMDAT ?HitBottom@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?HitBottom@CFuncPlat@@UAEXXZ PROC NEAR			; CFuncPlat::HitBottom, COMDAT

; 470  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 471  : 	if( pev->noise )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+488], 0
	je	SHORT $L37070

; 472  : 		STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+488]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH
$L37070:

; 473  : 
; 474  : 	if( pev->noise1 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+492], 0
	je	SHORT $L37071

; 475  : 		EMIT_SOUND( edict(), CHAN_WEAPON, STRING( pev->noise1 ), m_volume, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1964]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+492]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37071:

; 476  : 
; 477  : 	ASSERT( m_toggle_state == TS_GOING_DOWN );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??HitBottom@CFuncPlat@@UAEXXZ@4FA ; `CFuncPlat::HitBottom'::`2'::__LINE__Var
	add	eax, 7
	push	eax
	push	OFFSET FLAT:??_C@_0BO@NJDE@z?3?2xashxtsrc?2server?2plats?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CA@BPNN@m_toggle_state?5?$DN?$DN?5TS_GOING_DOWN?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1816], 3
	sete	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 478  : 	m_toggle_state = TS_AT_BOTTOM;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1816], 1

; 479  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HitBottom@CFuncPlat@@UAEXXZ ENDP			; CFuncPlat::HitBottom
_TEXT	ENDS
;	COMDAT ?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z PROC NEAR		; STOP_SOUND, COMDAT

; 614  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 615  : 	EMIT_SOUND_DYN( entity, channel, sample, 0, 0, SND_STOP, PITCH_NORM );

	push	100					; 00000064H
	push	32					; 00000020H
	push	0
	push	0
	mov	eax, DWORD PTR _sample$[ebp]
	push	eax
	mov	ecx, DWORD PTR _channel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entity$[ebp]
	push	edx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 616  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z ENDP			; STOP_SOUND
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GoUp@CFuncPlat@@UAEXXZ@4FA	; `CFuncPlat::GoUp'::`2'::__LINE__Var
PUBLIC	??_C@_0EC@PCLE@m_toggle_state?5?$DN?$DN?5TS_AT_BOTTOM?5?$HM@ ; `string'
PUBLIC	?GoUp@CFuncPlat@@UAEXXZ				; CFuncPlat::GoUp
;	COMDAT ?__LINE__Var@?1??GoUp@CFuncPlat@@UAEXXZ@4FA
; File z:\xashxtsrc\server\plats.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GoUp@CFuncPlat@@UAEXXZ@4FA DW 01e5H	; `CFuncPlat::GoUp'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EC@PCLE@m_toggle_state?5?$DN?$DN?5TS_AT_BOTTOM?5?$HM@
CONST	SEGMENT
??_C@_0EC@PCLE@m_toggle_state?5?$DN?$DN?5TS_AT_BOTTOM?5?$HM@ DB 'm_toggle'
	DB	'_state == TS_AT_BOTTOM || m_toggle_state == TS_GOING_DOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ?GoUp@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?GoUp@CFuncPlat@@UAEXXZ PROC NEAR			; CFuncPlat::GoUp, COMDAT

; 485  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 486  : 	if( pev->noise )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+488], 0
	je	SHORT $L37079

; 487  : 		EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ), m_volume, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1964]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+488]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37079:

; 488  : 	
; 489  : 	ASSERT( m_toggle_state == TS_AT_BOTTOM || m_toggle_state == TS_GOING_DOWN );

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 1
	je	SHORT $L40768
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1816], 3
	je	SHORT $L40768
	mov	DWORD PTR -8+[ebp], 0
	jmp	SHORT $L40769
$L40768:
	mov	DWORD PTR -8+[ebp], 1
$L40769:
	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??GoUp@CFuncPlat@@UAEXXZ@4FA ; `CFuncPlat::GoUp'::`2'::__LINE__Var
	add	eax, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BO@NJDE@z?3?2xashxtsrc?2server?2plats?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0EC@PCLE@m_toggle_state?5?$DN?$DN?5TS_AT_BOTTOM?5?$HM@ ; `string'
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 490  : 	m_toggle_state = TS_GOING_UP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1816], 2

; 491  : 	SetMoveDone( CallHitTop );

	push	OFFSET FLAT:??_C@_0L@OBGH@CallHitTop?$AA@ ; `string'
	push	OFFSET FLAT:?CallHitTop@CFuncPlat@@QAEXXZ ; CFuncPlat::CallHitTop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 492  : 	LinearMove( m_vecPosition1, pev->speed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+504]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1840				; 00000730H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::LinearMove

; 493  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GoUp@CFuncPlat@@UAEXXZ ENDP				; CFuncPlat::GoUp
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??HitTop@CFuncPlat@@UAEXXZ@4FA	; `CFuncPlat::HitTop'::`2'::__LINE__Var
PUBLIC	??_C@_0BO@OMAF@m_toggle_state?5?$DN?$DN?5TS_GOING_UP?$AA@ ; `string'
PUBLIC	?HitTop@CFuncPlat@@UAEXXZ			; CFuncPlat::HitTop
;	COMDAT ?__LINE__Var@?1??HitTop@CFuncPlat@@UAEXXZ@4FA
; File z:\xashxtsrc\server\plats.cpp
_DATA	SEGMENT
?__LINE__Var@?1??HitTop@CFuncPlat@@UAEXXZ@4FA DW 01f4H	; `CFuncPlat::HitTop'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BO@OMAF@m_toggle_state?5?$DN?$DN?5TS_GOING_UP?$AA@
CONST	SEGMENT
??_C@_0BO@OMAF@m_toggle_state?5?$DN?$DN?5TS_GOING_UP?$AA@ DB 'm_toggle_st'
	DB	'ate == TS_GOING_UP', 00H			; `string'
CONST	ENDS
;	COMDAT ?HitTop@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?HitTop@CFuncPlat@@UAEXXZ PROC NEAR			; CFuncPlat::HitTop, COMDAT

; 500  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 501  : 	if( pev->noise )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+488], 0
	je	SHORT $L37089

; 502  : 		STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+488]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH
$L37089:

; 503  : 
; 504  : 	if( pev->noise1 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+492], 0
	je	SHORT $L37090

; 505  : 		EMIT_SOUND( edict(), CHAN_WEAPON, STRING( pev->noise1 ), m_volume, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1964]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+492]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37090:

; 506  : 	
; 507  : 	ASSERT( m_toggle_state == TS_GOING_UP );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??HitTop@CFuncPlat@@UAEXXZ@4FA ; `CFuncPlat::HitTop'::`2'::__LINE__Var
	add	eax, 7
	push	eax
	push	OFFSET FLAT:??_C@_0BO@NJDE@z?3?2xashxtsrc?2server?2plats?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BO@OMAF@m_toggle_state?5?$DN?$DN?5TS_GOING_UP?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1816], 2
	sete	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 508  : 	m_toggle_state = TS_AT_TOP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1816], 0

; 509  : 
; 510  : 	if( !IsTogglePlat( ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+344]
	test	eax, eax
	jne	SHORT $L37094

; 512  : 		// After a delay, the platform will automatically start going down again.
; 513  : 		SetMoveDone( CallGoDown );

	push	OFFSET FLAT:??_C@_0L@EDMM@CallGoDown?$AA@ ; `string'
	push	OFFSET FLAT:?CallGoDown@CFuncPlat@@QAEXXZ ; CFuncPlat::CallGoDown
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 514  : 		SetMoveDoneTime( 3 );

	push	1077936128				; 40400000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime
$L37094:

; 516  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HitTop@CFuncPlat@@UAEXXZ ENDP				; CFuncPlat::HitTop
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??HitFloor@CFuncPlat@@UAEXXZ@4FA	; `CFuncPlat::HitFloor'::`2'::__LINE__Var
PUBLIC	??_C@_0EB@BHHJ@m_toggle_state?5?$DN?$DN?5TS_GOING_UP?5?$HM?$HM@ ; `string'
PUBLIC	??BEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator CBaseEntity *
PUBLIC	?HitFloor@CFuncPlat@@UAEXXZ			; CFuncPlat::HitFloor
PUBLIC	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
EXTRN	?DontThink@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::DontThink
EXTRN	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z:NEAR ; UTIL_FireTargets
;	COMDAT ?__LINE__Var@?1??HitFloor@CFuncPlat@@UAEXXZ@4FA
; File z:\xashxtsrc\server\plats.cpp
_DATA	SEGMENT
?__LINE__Var@?1??HitFloor@CFuncPlat@@UAEXXZ@4FA DW 020aH ; `CFuncPlat::HitFloor'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EB@BHHJ@m_toggle_state?5?$DN?$DN?5TS_GOING_UP?5?$HM?$HM@
CONST	SEGMENT
??_C@_0EB@BHHJ@m_toggle_state?5?$DN?$DN?5TS_GOING_UP?5?$HM?$HM@ DB 'm_tog'
	DB	'gle_state == TS_GOING_UP || m_toggle_state == TS_GOING_DOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ?HitFloor@CFuncPlat@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?HitFloor@CFuncPlat@@UAEXXZ PROC NEAR			; CFuncPlat::HitFloor, COMDAT

; 522  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 523  : 	if( pev->noise )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+488], 0
	je	SHORT $L37101

; 524  : 		STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+488]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH
$L37101:

; 525  : 
; 526  : 	if( pev->noise1 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+492], 0
	je	SHORT $L37102

; 527  : 		EMIT_SOUND( edict(), CHAN_WEAPON, STRING( pev->noise1 ), m_volume, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1964]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+492]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37102:

; 528  : 	
; 529  : 	ASSERT( m_toggle_state == TS_GOING_UP || m_toggle_state == TS_GOING_DOWN );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1816], 2
	je	SHORT $L40774
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 3
	je	SHORT $L40774
	mov	DWORD PTR -8+[ebp], 0
	jmp	SHORT $L40775
$L40774:
	mov	DWORD PTR -8+[ebp], 1
$L40775:
	push	0
	movsx	edx, WORD PTR ?__LINE__Var@?1??HitFloor@CFuncPlat@@UAEXXZ@4FA ; `CFuncPlat::HitFloor'::`2'::__LINE__Var
	add	edx, 7
	push	edx
	push	OFFSET FLAT:??_C@_0BO@NJDE@z?3?2xashxtsrc?2server?2plats?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0EB@BHHJ@m_toggle_state?5?$DN?$DN?5TS_GOING_UP?5?$HM?$HM@ ; `string'
	mov	eax, DWORD PTR -8+[ebp]
	push	eax
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 530  : 
; 531  : 	if( m_toggle_state == TS_GOING_UP )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 2
	jne	SHORT $L37106

; 532  : 		m_toggle_state = TS_AT_TOP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1816], 0

; 533  : 	else

	jmp	SHORT $L37107
$L37106:

; 534  : 		m_toggle_state = TS_AT_BOTTOM;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1816], 1
$L37107:

; 535  : 
; 536  : 	UTIL_FireTargets( pev->target, m_hActivator, this, USE_TOGGLE, m_flFloor );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1968]
	push	edx
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+456]
	push	eax
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 537  : 	UTIL_FireTargets( pev->netname, m_hActivator, this, USE_SET, m_flFloor );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1968]
	push	edx
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+464]
	push	eax
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 538  : 
; 539  : 	SetUse( PlatUse );

	push	OFFSET FLAT:??_C@_07JPAN@PlatUse?$AA@	; `string'
	push	OFFSET FLAT:?PlatUse@CFuncPlat@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncPlat::PlatUse
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ; CBaseEntity::UseSet

; 540  : 	SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 541  : 	DontThink(); // stop the floor counter

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DontThink@CBaseEntity@@QAEXXZ		; CBaseEntity::DontThink

; 542  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HitFloor@CFuncPlat@@UAEXXZ ENDP			; CFuncPlat::HitFloor
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator CBaseEntity *, COMDAT

; 64   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator CBaseEntity *
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::ThinkSet, COMDAT

; 560  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 		m_pfnThink = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1744], ecx

; 562  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnThink)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1744]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 563  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 564  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP	; CBaseEntity::ThinkSet
_TEXT	ENDS
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	?CalcFloor@CFuncPlat@@QAEMXZ			; CFuncPlat::CalcFloor
PUBLIC	?step@CFuncPlat@@QAEMXZ				; CFuncPlat::step
EXTRN	_fabs:NEAR
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
;	COMDAT __real@8@3fff8000000000000000
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT ?GoToFloor@CFuncPlat@@QAEXM@Z
_TEXT	SEGMENT
_floor$ = 8
_this$ = -4
_curfloor$ = -8
?GoToFloor@CFuncPlat@@QAEXM@Z PROC NEAR			; CFuncPlat::GoToFloor, COMDAT

; 545  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 	float curfloor = CalcFloor();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcFloor@CFuncPlat@@QAEMXZ		; CFuncPlat::CalcFloor
	fstp	DWORD PTR _curfloor$[ebp]

; 547  :           m_flFloor = floor;	// store target floor

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _floor$[ebp]
	mov	DWORD PTR [eax+1968], ecx

; 548  :  
; 549  : 	if( curfloor <= 0.0f ) return;

	fld	DWORD PTR _curfloor$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L37120
	jmp	$L37118
$L37120:

; 550  : 	if( curfloor == floor )

	fld	DWORD PTR _curfloor$[ebp]
	fcomp	DWORD PTR _floor$[ebp]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37121

; 552  : 		UTIL_FireTargets( pev->target, m_hActivator, this, USE_TOGGLE, m_flFloor );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1968]
	push	eax
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+456]
	push	ecx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 553  : 		return; // already there?

	jmp	$L37118
$L37121:

; 555  : 
; 556  :           m_vecFloor = m_vecPosition1;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1840				; 00000730H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1936				; 00000790H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 557  :           m_vecFloor.z = GetAbsOrigin().z + (floor * step( )) - (curfloor * step( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?step@CFuncPlat@@QAEMXZ			; CFuncPlat::step
	fmul	DWORD PTR _floor$[ebp]
	fadd	DWORD PTR [esi+8]
	fstp	DWORD PTR -12+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?step@CFuncPlat@@QAEMXZ			; CFuncPlat::step
	fmul	DWORD PTR _curfloor$[ebp]
	fsubr	DWORD PTR -12+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1944]

; 558  : 	
; 559  : 	if( pev->noise )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+488], 0
	je	SHORT $L37122

; 560  : 		EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ), m_volume, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1964]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+488]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37122:

; 561  :         
; 562  : 	if( floor > curfloor )

	fld	DWORD PTR _floor$[ebp]
	fcomp	DWORD PTR _curfloor$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37124

; 563  : 		m_toggle_state = TS_GOING_UP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1816], 2

; 564  : 	else m_toggle_state = TS_GOING_DOWN;

	jmp	SHORT $L37125
$L37124:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1816], 3
$L37125:

; 565  : 
; 566  : 	if( fabs( floor - curfloor ) > 1.0f )

	fld	DWORD PTR _floor$[ebp]
	fsub	DWORD PTR _curfloor$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37126

; 568  : 		// run a floor informator for env_counter
; 569  : 		SetThink( FloorCalc );

	push	OFFSET FLAT:??_C@_09FKJM@FloorCalc?$AA@	; `string'
	push	OFFSET FLAT:?FloorCalc@CFuncPlat@@QAEXXZ ; CFuncPlat::FloorCalc
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 570  : 		SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]
$L37126:

; 572  : 
; 573  : 	SetUse( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ; CBaseEntity::UseSet

; 574  : 	SetMoveDone( CallHitFloor );

	push	OFFSET FLAT:??_C@_0N@CLLJ@CallHitFloor?$AA@ ; `string'
	push	OFFSET FLAT:?CallHitFloor@CFuncPlat@@QAEXXZ ; CFuncPlat::CallHitFloor
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 575  : 	LinearMove( m_vecFloor, pev->speed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+504]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1936				; 00000790H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::LinearMove
$L37118:

; 576  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GoToFloor@CFuncPlat@@QAEXM@Z ENDP			; CFuncPlat::GoToFloor
_TEXT	ENDS
PUBLIC	__real@4@3ffe8000000000000000
EXTRN	__ftol:NEAR
;	COMDAT __real@4@3ffe8000000000000000
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
__real@4@3ffe8000000000000000 DD 03f000000r	; 0.5
CONST	ENDS
;	COMDAT ?CalcFloor@CFuncPlat@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4
?CalcFloor@CFuncPlat@@QAEMXZ PROC NEAR			; CFuncPlat::CalcFloor, COMDAT

; 228  : 	float CalcFloor( void ) { return Q_rint( (( GetLocalOrigin().z - m_vecPosition1.z ) / step( )) + 1 ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+1848]
	fstp	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?step@CFuncPlat@@QAEMXZ			; CFuncPlat::step
	fdivr	DWORD PTR -8+[ebp]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40790
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [edx+1848]
	fstp	DWORD PTR -12+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?step@CFuncPlat@@QAEMXZ			; CFuncPlat::step
	fdivr	DWORD PTR -12+[ebp]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR __real@4@3ffe8000000000000000
	call	__ftol
	mov	DWORD PTR -16+[ebp], eax
	jmp	SHORT $L40791
$L40790:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+1848]
	fstp	DWORD PTR -20+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?step@CFuncPlat@@QAEMXZ			; CFuncPlat::step
	fdivr	DWORD PTR -20+[ebp]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fadd	DWORD PTR __real@4@3ffe8000000000000000
	call	__ftol
	mov	DWORD PTR -16+[ebp], eax
$L40791:
	fild	DWORD PTR -16+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CalcFloor@CFuncPlat@@QAEMXZ ENDP			; CFuncPlat::CalcFloor
_TEXT	ENDS
;	COMDAT ?step@CFuncPlat@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4
?step@CFuncPlat@@QAEMXZ PROC NEAR			; CFuncPlat::step, COMDAT

; 229  : 	float step( void ) { return ( pev->size.z + m_flHeight - 2 ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+252]
	fadd	DWORD PTR [edx+1904]
	fsub	DWORD PTR __real@4@40008000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?step@CFuncPlat@@QAEMXZ ENDP				; CFuncPlat::step
_TEXT	ENDS
;	COMDAT ?FloorCalc@CFuncPlat@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?FloorCalc@CFuncPlat@@QAEXXZ PROC NEAR			; CFuncPlat::FloorCalc, COMDAT

; 579  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 580  : 	UTIL_FireTargets( pev->netname, m_hActivator, this, USE_SET, CalcFloor( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcFloor@CFuncPlat@@QAEMXZ		; CFuncPlat::CalcFloor
	push	ecx
	fstp	DWORD PTR [esp]
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+464]
	push	eax
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 581  : 	SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 582  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FloorCalc@CFuncPlat@@QAEXXZ ENDP			; CFuncPlat::FloorCalc
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z@4FA ; `CFuncPlat::Blocked'::`2'::__LINE__Var
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
PUBLIC	?Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z	; CFuncPlat::Blocked
;	COMDAT ?__LINE__Var@?1??Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z@4FA
; File z:\xashxtsrc\server\plats.cpp
_DATA	SEGMENT
?__LINE__Var@?1??Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z@4FA DW 0249H ; `CFuncPlat::Blocked'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
?Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z PROC NEAR	; CFuncPlat::Blocked, COMDAT

; 585  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 586  : //	ALERT( at_aiconsole, "%s Blocked by %s\n", GetClassname(), pOther->GetClassname() );
; 587  : 
; 588  : 	// Hurt the blocker a little
; 589  : 	if( m_hActivator )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37144

; 590  : 		pOther->TakeDamage( pev, m_hActivator->pev, pev->dmg, DMG_CRUSH );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+480]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+96]

; 591  : 	else

	jmp	SHORT $L37145
$L37144:

; 592  : 		pOther->TakeDamage( pev, pev, pev->dmg, DMG_CRUSH );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+480]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+96]
$L37145:

; 593  : 
; 594  : 	if( FClassnameIs( pev, "func_platform" ))

	push	OFFSET FLAT:??_C@_0O@FILI@func_platform?$AA@ ; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L37146

; 595  : 		return;

	jmp	$L37143
$L37146:

; 596  : 
; 597  : 	if( pev->noise )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+488], 0
	je	SHORT $L37147

; 598  : 		STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+488]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH
$L37147:

; 599  : 	
; 600  : 	// Send the platform back where it came from
; 601  : 	ASSERT( m_toggle_state == TS_GOING_UP || m_toggle_state == TS_GOING_DOWN );

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 2
	je	SHORT $L40801
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1816], 3
	je	SHORT $L40801
	mov	DWORD PTR -8+[ebp], 0
	jmp	SHORT $L40802
$L40801:
	mov	DWORD PTR -8+[ebp], 1
$L40802:
	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z@4FA ; `CFuncPlat::Blocked'::`2'::__LINE__Var
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET FLAT:??_C@_0BO@NJDE@z?3?2xashxtsrc?2server?2plats?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0EB@BHHJ@m_toggle_state?5?$DN?$DN?5TS_GOING_UP?5?$HM?$HM@ ; `string'
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 602  : 
; 603  : 	if( m_toggle_state == TS_GOING_UP )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1816], 2
	jne	SHORT $L37149

; 604  : 		GoDown();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+352]

; 605  : 	else if( m_toggle_state == TS_GOING_DOWN )

	jmp	SHORT $L37151
$L37149:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1816], 3
	jne	SHORT $L37151

; 606  : 		GoUp ();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+348]
$L37151:
$L37143:

; 607  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z ENDP		; CFuncPlat::Blocked
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator->, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
;	COMDAT _$E42
_TEXT	SEGMENT
_$E42	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E41
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E42	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncPlatRot@@@@QAE@PBD@Z	; CEntityFactory<CFuncPlatRot>::CEntityFactory<CFuncPlatRot>
PUBLIC	??_C@_0N@HNBH@func_platrot?$AA@			; `string'
_BSS	SEGMENT
	ALIGN	4

_func_platrot DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0N@HNBH@func_platrot?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0N@HNBH@func_platrot?$AA@ DB 'func_platrot', 00H	; `string'
CONST	ENDS
;	COMDAT _$E41
_TEXT	SEGMENT
_$E41	PROC NEAR					; COMDAT

; 628  : LINK_ENTITY_TO_CLASS( func_platrot, CFuncPlatRot );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0N@HNBH@func_platrot?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_platrot
	call	??0?$CEntityFactory@VCFuncPlatRot@@@@QAE@PBD@Z ; CEntityFactory<CFuncPlatRot>::CEntityFactory<CFuncPlatRot>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E41	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CFuncPlatRot@@UAEPAUdatamap_s@@XZ ; CFuncPlatRot::GetDataDescMap
;	COMDAT ?GetDataDescMap@CFuncPlatRot@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CFuncPlatRot@@UAEPAUdatamap_s@@XZ PROC NEAR ; CFuncPlatRot::GetDataDescMap, COMDAT

; 630  : BEGIN_DATADESC( CFuncPlatRot )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncPlatRot@@2Udatamap_s@@A ; CFuncPlatRot::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CFuncPlatRot@@UAEPAUdatamap_s@@XZ ENDP	; CFuncPlatRot::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CFuncPlatRot@@SAPAUdatamap_s@@XZ	; CFuncPlatRot::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCFuncPlat@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CFuncPlatRot@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CFuncPlatRot@@SAPAUdatamap_s@@XZ PROC NEAR	; CFuncPlatRot::GetBaseMap, COMDAT

; 630  : BEGIN_DATADESC( CFuncPlatRot )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCFuncPlat@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CFuncPlatRot@@SAPAUdatamap_s@@XZ ENDP	; CFuncPlatRot::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E45
_TEXT	SEGMENT
_$E45	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E44
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E45	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z ; DataMapInit
;	COMDAT _$E44
_TEXT	SEGMENT
_$E44	PROC NEAR					; COMDAT

; 630  : BEGIN_DATADESC( CFuncPlatRot )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CFuncPlatRot_DataDescInit@@3PAUdatamap_s@@A, eax ; CFuncPlatRot_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E44	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S47@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z PROC NEAR ; DataMapInit, COMDAT

; 630  : BEGIN_DATADESC( CFuncPlatRot )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S47@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L37261
	mov	cl, BYTE PTR _?$S47@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S47@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0N@GBFP@CFuncPlatRot?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E48
	call	_atexit
	add	esp, 4
$L37261:
	call	?GetBaseMap@CFuncPlatRot@@SAPAUdatamap_s@@XZ ; CFuncPlatRot::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CFuncPlatRot@@2Udatamap_s@@A+12, eax

; 631  : 	DEFINE_FIELD( m_end, FIELD_VECTOR ),
; 632  : 	DEFINE_FIELD( m_start, FIELD_VECTOR ),
; 633  : END_DATADESC()

	mov	edx, 1
	test	edx, edx
	je	SHORT $L37271
	mov	DWORD PTR ?m_DataMap@CFuncPlatRot@@2Udatamap_s@@A+4, 2
	mov	DWORD PTR ?m_DataMap@CFuncPlatRot@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L37272
$L37271:
	mov	DWORD PTR ?m_DataMap@CFuncPlatRot@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncPlatRot@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z@4PAUtypedescription_s@@A
$L37272:
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncPlatRot@@2Udatamap_s@@A ; CFuncPlatRot::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z ENDP	; DataMapInit
_TEXT	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT
_$E48	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncPlatRot@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E48	ENDP
_TEXT	ENDS
PUBLIC	?SetupRotation@CFuncPlatRot@@QAEXXZ		; CFuncPlatRot::SetupRotation
EXTRN	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAngles
EXTRN	?AxisDir@CBaseToggle@@SAXPAUentvars_s@@@Z:NEAR	; CBaseToggle::AxisDir
;	COMDAT ?SetupRotation@CFuncPlatRot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
$T40825 = -16
$T40826 = -28
?SetupRotation@CFuncPlatRot@@QAEXXZ PROC NEAR		; CFuncPlatRot::SetupRotation, COMDAT

; 636  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 637  : 	if( m_vecFinalAngle.x != 0 ) // this plat rotates too!

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1924]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L37278

; 639  : 		CBaseToggle :: AxisDir( pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?AxisDir@CBaseToggle@@SAXPAUentvars_s@@@Z ; CBaseToggle::AxisDir
	add	esp, 4

; 640  : 		m_start = GetLocalAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1984				; 000007c0H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 641  : 		m_end = GetLocalAngles() + pev->movedir * m_vecFinalAngle.x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1924]
	push	edx
	lea	eax, DWORD PTR $T40825[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T40826[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1972				; 000007b4H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 643  : 	else

	jmp	SHORT $L37281
$L37278:

; 645  : 		m_start = g_vecZero;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1984				; 000007c0H
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [ecx+8], edx

; 646  : 		m_end = g_vecZero;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1972				; 000007b4H
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [eax+8], ecx
$L37281:

; 648  : 
; 649  : 	if( !FStringNull( pev->targetname )) // Start at top

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+460]
	push	ecx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L37282

; 651  : 		SetLocalAngles( m_end );

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1972				; 000007b4H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles
$L37282:

; 653  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetupRotation@CFuncPlatRot@@QAEXXZ ENDP		; CFuncPlatRot::SetupRotation
_TEXT	ENDS
PUBLIC	?Spawn@CFuncPlatRot@@UAEXXZ			; CFuncPlatRot::Spawn
;	COMDAT ?Spawn@CFuncPlatRot@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CFuncPlatRot@@UAEXXZ PROC NEAR			; CFuncPlatRot::Spawn, COMDAT

; 656  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 657  : 	BaseClass :: Spawn();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Spawn@CFuncPlat@@UAEXXZ		; CFuncPlat::Spawn

; 658  : 	SetupRotation();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupRotation@CFuncPlatRot@@QAEXXZ	; CFuncPlatRot::SetupRotation

; 659  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncPlatRot@@UAEXXZ ENDP			; CFuncPlatRot::Spawn
_TEXT	ENDS
PUBLIC	?GoDown@CFuncPlatRot@@UAEXXZ			; CFuncPlatRot::GoDown
PUBLIC	?RotMove@CFuncPlatRot@@QAEXAAVVector@@M@Z	; CFuncPlatRot::RotMove
PUBLIC	?GetMoveDoneTime@CBaseEntity@@QBEMXZ		; CBaseEntity::GetMoveDoneTime
;	COMDAT ?GoDown@CFuncPlatRot@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?GoDown@CFuncPlatRot@@UAEXXZ PROC NEAR			; CFuncPlatRot::GoDown, COMDAT

; 662  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 663  : 	BaseClass :: GoDown();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GoDown@CFuncPlat@@UAEXXZ		; CFuncPlat::GoDown

; 664  : 	RotMove( m_start, GetMoveDoneTime() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMoveDoneTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetMoveDoneTime
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1984				; 000007c0H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotMove@CFuncPlatRot@@QAEXAAVVector@@M@Z ; CFuncPlatRot::RotMove

; 665  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GoDown@CFuncPlatRot@@UAEXXZ ENDP			; CFuncPlatRot::GoDown
_TEXT	ENDS
;	COMDAT ?GetMoveDoneTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetMoveDoneTime@CBaseEntity@@QBEMXZ PROC NEAR		; CBaseEntity::GetMoveDoneTime, COMDAT

; 805  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 806  : 	return (m_flMoveDoneTime >= 0) ? m_flMoveDoneTime - GetLocalTime() : -1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40833
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetLocalTime
	mov	ecx, DWORD PTR _this$[ebp]
	fsubr	DWORD PTR [ecx+44]
	fstp	DWORD PTR -8+[ebp]
	jmp	SHORT $L40834
$L40833:
	mov	DWORD PTR -8+[ebp], -1082130432		; bf800000H
$L40834:
	fld	DWORD PTR -8+[ebp]

; 807  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMoveDoneTime@CBaseEntity@@QBEMXZ ENDP		; CBaseEntity::GetMoveDoneTime
_TEXT	ENDS
PUBLIC	?HitBottom@CFuncPlatRot@@UAEXXZ			; CFuncPlatRot::HitBottom
EXTRN	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAvelocity
;	COMDAT ?HitBottom@CFuncPlatRot@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?HitBottom@CFuncPlatRot@@UAEXXZ PROC NEAR		; CFuncPlatRot::HitBottom, COMDAT

; 671  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 672  : 	BaseClass :: HitBottom();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?HitBottom@CFuncPlat@@UAEXXZ		; CFuncPlat::HitBottom

; 673  : 	SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 674  : 	SetLocalAngles( m_start );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1984				; 000007c0H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 675  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HitBottom@CFuncPlatRot@@UAEXXZ ENDP			; CFuncPlatRot::HitBottom
_TEXT	ENDS
PUBLIC	?GoUp@CFuncPlatRot@@UAEXXZ			; CFuncPlatRot::GoUp
;	COMDAT ?GoUp@CFuncPlatRot@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?GoUp@CFuncPlatRot@@UAEXXZ PROC NEAR			; CFuncPlatRot::GoUp, COMDAT

; 681  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 682  : 	BaseClass :: GoUp();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GoUp@CFuncPlat@@UAEXXZ			; CFuncPlat::GoUp

; 683  : 	RotMove( m_end, GetMoveDoneTime() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMoveDoneTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetMoveDoneTime
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1972				; 000007b4H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotMove@CFuncPlatRot@@QAEXAAVVector@@M@Z ; CFuncPlatRot::RotMove

; 684  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GoUp@CFuncPlatRot@@UAEXXZ ENDP				; CFuncPlatRot::GoUp
_TEXT	ENDS
PUBLIC	?HitTop@CFuncPlatRot@@UAEXXZ			; CFuncPlatRot::HitTop
;	COMDAT ?HitTop@CFuncPlatRot@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?HitTop@CFuncPlatRot@@UAEXXZ PROC NEAR			; CFuncPlatRot::HitTop, COMDAT

; 690  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 691  : 	BaseClass :: HitTop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?HitTop@CFuncPlat@@UAEXXZ		; CFuncPlat::HitTop

; 692  : 	SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 693  : 	SetLocalAngles( m_end );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1972				; 000007b4H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 694  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HitTop@CFuncPlatRot@@UAEXXZ ENDP			; CFuncPlatRot::HitTop
_TEXT	ENDS
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	__real@4@3ffbcccccd0000000000
;	COMDAT __real@4@3ffbcccccd0000000000
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
__real@4@3ffbcccccd0000000000 DD 03dcccccdr	; 0.1
CONST	ENDS
;	COMDAT ?RotMove@CFuncPlatRot@@QAEXAAVVector@@M@Z
_TEXT	SEGMENT
_destAngle$ = 8
_time$ = 12
_this$ = -4
_vecDestDelta$ = -16
$T40843 = -28
$T40844 = -40
?RotMove@CFuncPlatRot@@QAEXAAVVector@@M@Z PROC NEAR	; CFuncPlatRot::RotMove, COMDAT

; 697  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 698  : 	// set destdelta to the vector needed to move
; 699  : 	Vector vecDestDelta = destAngle - GetLocalAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	lea	eax, DWORD PTR $T40843[ebp]
	push	eax
	mov	ecx, DWORD PTR _destAngle$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecDestDelta$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 700  : 
; 701  : 	// Travel time is so short, we're practically there already;  so make it so.
; 702  : 	if( time >= 0.1f )

	fld	DWORD PTR _time$[ebp]
	fcomp	DWORD PTR __real@4@3ffbcccccd0000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L37310

; 704  : 		SetLocalAvelocity( vecDestDelta * ( 1.0 / time ));

	fld	DWORD PTR _time$[ebp]
	fdivr	QWORD PTR __real@8@3fff8000000000000000
	fst	DWORD PTR -44+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40844[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecDestDelta$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 706  : 	else

	jmp	SHORT $L37312
$L37310:

; 708  : 		SetLocalAvelocity( vecDestDelta );

	lea	edx, DWORD PTR _vecDestDelta$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 709  : 		SetMoveDoneTime( 1 );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime
$L37312:

; 711  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?RotMove@CFuncPlatRot@@QAEXAAVVector@@M@Z ENDP		; CFuncPlatRot::RotMove
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40849 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40849[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
;	COMDAT _$E51
_TEXT	SEGMENT
_$E51	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E50
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E51	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCTrainSequence@@@@QAE@PBD@Z ; CEntityFactory<CTrainSequence>::CEntityFactory<CTrainSequence>
PUBLIC	??_C@_0BH@IOJK@scripted_trainsequence?$AA@	; `string'
_BSS	SEGMENT
	ALIGN	4

_scripted_trainsequence DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BH@IOJK@scripted_trainsequence?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BH@IOJK@scripted_trainsequence?$AA@ DB 'scripted_trainsequence', 00H ; `string'
CONST	ENDS
;	COMDAT _$E50
_TEXT	SEGMENT
_$E50	PROC NEAR					; COMDAT

; 750  : LINK_ENTITY_TO_CLASS( scripted_trainsequence, CTrainSequence );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BH@IOJK@scripted_trainsequence?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_scripted_trainsequence
	call	??0?$CEntityFactory@VCTrainSequence@@@@QAE@PBD@Z ; CEntityFactory<CTrainSequence>::CEntityFactory<CTrainSequence>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E50	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CTrainSequence@@UAEPAUdatamap_s@@XZ ; CTrainSequence::GetDataDescMap
;	COMDAT ?GetDataDescMap@CTrainSequence@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CTrainSequence@@UAEPAUdatamap_s@@XZ PROC NEAR ; CTrainSequence::GetDataDescMap, COMDAT

; 752  : BEGIN_DATADESC( CTrainSequence )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CTrainSequence@@2Udatamap_s@@A ; CTrainSequence::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CTrainSequence@@UAEPAUdatamap_s@@XZ ENDP ; CTrainSequence::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CTrainSequence@@SAPAUdatamap_s@@XZ	; CTrainSequence::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CTrainSequence@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CTrainSequence@@SAPAUdatamap_s@@XZ PROC NEAR ; CTrainSequence::GetBaseMap, COMDAT

; 752  : BEGIN_DATADESC( CTrainSequence )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CTrainSequence@@SAPAUdatamap_s@@XZ ENDP	; CTrainSequence::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E54
_TEXT	SEGMENT
_$E54	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E53
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E54	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z ; DataMapInit
;	COMDAT _$E53
_TEXT	SEGMENT
_$E53	PROC NEAR					; COMDAT

; 752  : BEGIN_DATADESC( CTrainSequence )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CTrainSequence_DataDescInit@@3PAUdatamap_s@@A, eax ; CTrainSequence_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E53	ENDP
_TEXT	ENDS
PUBLIC	?EndThink@CTrainSequence@@QAEXXZ		; CTrainSequence::EndThink
PUBLIC	??_C@_08LGNC@EndThink?$AA@			; `string'
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S56@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_08LGNC@EndThink?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_08LGNC@EndThink?$AA@ DB 'EndThink', 00H		; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z PROC NEAR ; DataMapInit, COMDAT

; 752  : BEGIN_DATADESC( CTrainSequence )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S56@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L37440
	mov	cl, BYTE PTR _?$S56@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S56@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0P@FDFA@CTrainSequence?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E57
	call	_atexit
	add	esp, 4
$L37440:
	call	?GetBaseMap@CTrainSequence@@SAPAUdatamap_s@@XZ ; CTrainSequence::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CTrainSequence@@2Udatamap_s@@A+12, eax

; 753  : 	DEFINE_KEYFIELD( m_iszEntity, FIELD_STRING, "m_iszEntity" ),
; 754  : 	DEFINE_KEYFIELD( m_iszDestination, FIELD_STRING, "m_iszDestination" ),
; 755  : 	DEFINE_KEYFIELD( m_iszTerminate, FIELD_STRING, "m_iszTerminate" ),
; 756  : 	DEFINE_KEYFIELD( m_iDirection, FIELD_INTEGER, "m_iDirection" ),
; 757  : 	DEFINE_FIELD( m_pDestination, FIELD_CLASSPTR ),
; 758  : 	DEFINE_FIELD( m_pTrain, FIELD_CLASSPTR ),
; 759  : 	DEFINE_FUNCTION( EndThink ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S56@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	SHORT $L37462
	mov	al, BYTE PTR _?$S56@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S56@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_08LGNC@EndThink?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4PAUtypedescription_s@@A+172, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4PAUtypedescription_s@@A+176, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4PAUtypedescription_s@@A+180, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4PAUtypedescription_s@@A+182, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4PAUtypedescription_s@@A+184, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4PAUtypedescription_s@@A+188, OFFSET FLAT:?EndThink@CTrainSequence@@QAEXXZ ; CTrainSequence::EndThink
$L37462:

; 760  : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L37466
	mov	DWORD PTR ?m_DataMap@CTrainSequence@@2Udatamap_s@@A+4, 7
	mov	DWORD PTR ?m_DataMap@CTrainSequence@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L37467
$L37466:
	mov	DWORD PTR ?m_DataMap@CTrainSequence@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CTrainSequence@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4PAUtypedescription_s@@A
$L37467:
	mov	eax, OFFSET FLAT:?m_DataMap@CTrainSequence@@2Udatamap_s@@A ; CTrainSequence::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z ENDP ; DataMapInit
_TEXT	ENDS
;	COMDAT _$E57
_TEXT	SEGMENT
_$E57	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTrainSequence@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E57	ENDP
_TEXT	ENDS
PUBLIC	?KeyValue@CTrainSequence@@UAEXPAUKeyValueData_s@@@Z ; CTrainSequence::KeyValue
PUBLIC	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
;	COMDAT ?KeyValue@CTrainSequence@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CTrainSequence@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CTrainSequence::KeyValue, COMDAT

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 764  : 	if( FStrEq( pkvd->szKeyName, "m_iDirection" ))

	push	OFFSET FLAT:??_C@_0N@CAEJ@m_iDirection?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37473

; 766  : 		m_iDirection = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1776], eax

; 767  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 769  : 	else if( FStrEq( pkvd->szKeyName, "m_iszEntity" ))

	jmp	$L37480
$L37473:
	push	OFFSET FLAT:??_C@_0M@GABM@m_iszEntity?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37475

; 771  : 		m_iszEntity = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1764], eax

; 772  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 774  : 	else if( FStrEq( pkvd->szKeyName, "m_iszDestination" ))

	jmp	$L37480
$L37475:
	push	OFFSET FLAT:??_C@_0BB@FMLJ@m_iszDestination?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37477

; 776  : 		m_iszDestination = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1768], eax

; 777  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 779  : 	else if( FStrEq( pkvd->szKeyName, "m_iszTerminate" ))

	jmp	SHORT $L37480
$L37477:
	push	OFFSET FLAT:??_C@_0P@FKJF@m_iszTerminate?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37479

; 781  : 		m_iszTerminate = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1772], eax

; 782  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 784  : 	else

	jmp	SHORT $L37480
$L37479:

; 785  : 		BaseClass::KeyValue( pkvd );

	mov	eax, DWORD PTR _pkvd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
$L37480:

; 786  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CTrainSequence@@UAEXPAUKeyValueData_s@@@Z ENDP ; CTrainSequence::KeyValue
_TEXT	ENDS
PUBLIC	??_C@_06FOPF@parent?$AA@			; `string'
PUBLIC	??_C@_08IDGH@movewith?$AA@			; `string'
PUBLIC	??_C@_0M@FCIN@parentflags?$AA@			; `string'
PUBLIC	??_C@_05JCDO@style?$AA@				; `string'
PUBLIC	??_C@_0L@MCHI@reflection?$AA@			; `string'
PUBLIC	??_C@_0N@DCCA@vlight_cache?$AA@			; `string'
EXTRN	_atoi:NEAR
;	COMDAT ??_C@_06FOPF@parent?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_06FOPF@parent?$AA@ DB 'parent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT
??_C@_08IDGH@movewith?$AA@ DB 'movewith', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT
??_C@_0M@FCIN@parentflags?$AA@ DB 'parentflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT
??_C@_05JCDO@style?$AA@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT
??_C@_0L@MCHI@reflection?$AA@ DB 'reflection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT
??_C@_0N@DCCA@vlight_cache?$AA@ DB 'vlight_cache', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pkvd$ = 8
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseEntity::KeyValue, COMDAT

; 328  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 		// get support for spirit field too
; 330  : 		if( FStrEq( pkvd->szKeyName, "parent" ) || FStrEq( pkvd->szKeyName, "movewith" ))

	push	OFFSET FLAT:??_C@_06FOPF@parent?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L34875
	push	OFFSET FLAT:??_C@_08IDGH@movewith?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34874
$L34875:

; 332  : 			m_iParent = ALLOC_STRING(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 333  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 335  : 		else if( FStrEq( pkvd->szKeyName, "parentflags" ))

	jmp	$L34896
$L34874:
	push	OFFSET FLAT:??_C@_0M@FCIN@parentflags?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34879

; 337  : 			m_iParentFlags = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 338  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 340  : 		else if( FStrEq( pkvd->szKeyName, "style" ))

	jmp	$L34896
$L34879:
	push	OFFSET FLAT:??_C@_05JCDO@style?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34882

; 342  : 			m_iStyle = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 343  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 345  : 		else if( FStrEq( pkvd->szKeyName, "reflection" ))

	jmp	$L34896
$L34882:
	push	OFFSET FLAT:??_C@_0L@MCHI@reflection?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34885

; 348  : 			{

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L34891
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L34892
	jmp	SHORT $L34888
$L34891:

; 349  : 			case 1: pev->effects |= EF_NOREFLECT; break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
	jmp	SHORT $L34888
$L34892:

; 350  : 			case 2: pev->effects |= EF_REFLECTONLY; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L34888:

; 352  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 354  : 		else if( FStrEq(pkvd->szKeyName, "vlight_cache"))

	jmp	SHORT $L34896
$L34885:
	push	OFFSET FLAT:??_C@_0N@DCCA@vlight_cache?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34894

; 356  : 			pev->iuser3 = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+588], eax

; 357  : 			pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 359  : 		else pkvd->fHandled = FALSE;

	jmp	SHORT $L34896
$L34894:
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L34896:

; 360  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseEntity::KeyValue
_TEXT	ENDS
PUBLIC	?StopSequence@CTrainSequence@@QAEXXZ		; CTrainSequence::StopSequence
EXTRN	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z:NEAR ; UTIL_FireTargets
;	COMDAT ?EndThink@CTrainSequence@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?EndThink@CTrainSequence@@QAEXXZ PROC NEAR		; CTrainSequence::EndThink, COMDAT

; 789  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 790  : 	// the sequence has expired. Release control.
; 791  : 	StopSequence();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopSequence@CTrainSequence@@QAEXXZ	; CTrainSequence::StopSequence

; 792  : 	UTIL_FireTargets( STRING( pev->target ), this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+456]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 793  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EndThink@CTrainSequence@@QAEXXZ ENDP			; CTrainSequence::EndThink
_TEXT	ENDS
;	COMDAT _$E60
_TEXT	SEGMENT
_$E60	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E59
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E60	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncTrain@@@@QAE@PBD@Z	; CEntityFactory<CFuncTrain>::CEntityFactory<CFuncTrain>
PUBLIC	??_C@_0L@OLKI@func_train?$AA@			; `string'
_BSS	SEGMENT
	ALIGN	4

_func_train DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0L@OLKI@func_train?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0L@OLKI@func_train?$AA@ DB 'func_train', 00H	; `string'
CONST	ENDS
;	COMDAT _$E59
_TEXT	SEGMENT
_$E59	PROC NEAR					; COMDAT

; 842  : LINK_ENTITY_TO_CLASS( func_train, CFuncTrain );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0L@OLKI@func_train?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_train
	call	??0?$CEntityFactory@VCFuncTrain@@@@QAE@PBD@Z ; CEntityFactory<CFuncTrain>::CEntityFactory<CFuncTrain>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E59	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CFuncTrain@@UAEPAUdatamap_s@@XZ	; CFuncTrain::GetDataDescMap
;	COMDAT ?GetDataDescMap@CFuncTrain@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CFuncTrain@@UAEPAUdatamap_s@@XZ PROC NEAR ; CFuncTrain::GetDataDescMap, COMDAT

; 844  : BEGIN_DATADESC( CFuncTrain )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTrain@@2Udatamap_s@@A ; CFuncTrain::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CFuncTrain@@UAEPAUdatamap_s@@XZ ENDP	; CFuncTrain::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CFuncTrain@@SAPAUdatamap_s@@XZ	; CFuncTrain::GetBaseMap
;	COMDAT ?GetBaseMap@CFuncTrain@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CFuncTrain@@SAPAUdatamap_s@@XZ PROC NEAR	; CFuncTrain::GetBaseMap, COMDAT

; 844  : BEGIN_DATADESC( CFuncTrain )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBasePlatTrain@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CFuncTrain@@SAPAUdatamap_s@@XZ ENDP		; CFuncTrain::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E63
_TEXT	SEGMENT
_$E63	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E62
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E63	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z	; DataMapInit
;	COMDAT _$E62
_TEXT	SEGMENT
_$E62	PROC NEAR					; COMDAT

; 844  : BEGIN_DATADESC( CFuncTrain )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CFuncTrain_DataDescInit@@3PAUdatamap_s@@A, eax ; CFuncTrain_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E62	ENDP
_TEXT	ENDS
PUBLIC	?Wait@CFuncTrain@@QAEXXZ			; CFuncTrain::Wait
PUBLIC	?Next@CFuncTrain@@QAEXXZ			; CFuncTrain::Next
PUBLIC	?SoundSetup@CFuncTrain@@QAEXXZ			; CFuncTrain::SoundSetup
PUBLIC	??_C@_0L@JMDO@SoundSetup?$AA@			; `string'
PUBLIC	??_C@_04EGHG@Wait?$AA@				; `string'
PUBLIC	??_C@_04CIMM@Next?$AA@				; `string'
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0L@JMDO@SoundSetup?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0L@JMDO@SoundSetup?$AA@ DB 'SoundSetup', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EGHG@Wait?$AA@
CONST	SEGMENT
??_C@_04EGHG@Wait?$AA@ DB 'Wait', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CIMM@Next?$AA@
CONST	SEGMENT
??_C@_04CIMM@Next?$AA@ DB 'Next', 00H			; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z PROC NEAR ; DataMapInit, COMDAT

; 844  : BEGIN_DATADESC( CFuncTrain )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L37623
	mov	cl, BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0L@GCNI@CFuncTrain?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E66
	call	_atexit
	add	esp, 4
$L37623:
	call	?GetBaseMap@CFuncTrain@@SAPAUdatamap_s@@XZ ; CFuncTrain::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CFuncTrain@@2Udatamap_s@@A+12, eax

; 845  : 	DEFINE_FIELD( m_hCurrentTarget, FIELD_EHANDLE ),
; 846  : 	DEFINE_FIELD( m_pSequence, FIELD_CLASSPTR ),
; 847  : 	DEFINE_FIELD( m_activated, FIELD_BOOLEAN ),
; 848  : 	DEFINE_FUNCTION( SoundSetup ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L37636
	mov	al, BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_0L@JMDO@SoundSetup?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+100, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+104, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+108, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+110, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+112, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+116, OFFSET FLAT:?SoundSetup@CFuncTrain@@QAEXXZ ; CFuncTrain::SoundSetup

; 849  : 	DEFINE_FUNCTION( Wait ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+120, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_04EGHG@Wait?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+124, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+128, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+132, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+134, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+136, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+140, OFFSET FLAT:?Wait@CFuncTrain@@QAEXXZ ; CFuncTrain::Wait

; 850  : 	DEFINE_FUNCTION( Next ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+144, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_04CIMM@Next?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+148, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+152, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+156, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+158, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+160, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+164, OFFSET FLAT:?Next@CFuncTrain@@QAEXXZ ; CFuncTrain::Next
$L37636:

; 851  : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L37646
	mov	DWORD PTR ?m_DataMap@CFuncTrain@@2Udatamap_s@@A+4, 6
	mov	DWORD PTR ?m_DataMap@CFuncTrain@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L37647
$L37646:
	mov	DWORD PTR ?m_DataMap@CFuncTrain@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncTrain@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4PAUtypedescription_s@@A
$L37647:
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTrain@@2Udatamap_s@@A ; CFuncTrain::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z ENDP	; DataMapInit
_TEXT	ENDS
;	COMDAT _$E66
_TEXT	SEGMENT
_$E66	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrain@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E66	ENDP
_TEXT	ENDS
PUBLIC	?Blocked@CFuncTrain@@UAEXPAVCBaseEntity@@@Z	; CFuncTrain::Blocked
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
;	COMDAT ?Blocked@CFuncTrain@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
?Blocked@CFuncTrain@@UAEXPAVCBaseEntity@@@Z PROC NEAR	; CFuncTrain::Blocked, COMDAT

; 854  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 855  : 	if( gpGlobals->time < m_flActivateFinished )

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx+1820]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37653

; 856  : 		return;

	jmp	$L37652
$L37653:

; 857  : 
; 858  : 	m_flActivateFinished = gpGlobals->time + 0.5f;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	DWORD PTR __real@4@3ffe8000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1820]

; 859  : 
; 860  : 	if( pev->dmg )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+480]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L37656

; 862  : 		if( m_hActivator )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37655

; 863  : 			pOther->TakeDamage( pev, m_hActivator->pev, pev->dmg, DMG_CRUSH );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+480]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+96]

; 864  : 		else

	jmp	SHORT $L37656
$L37655:

; 865  : 			pOther->TakeDamage( pev, pev, pev->dmg, DMG_CRUSH );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+480]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+96]
$L37656:
$L37652:

; 867  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CFuncTrain@@UAEXPAVCBaseEntity@@@Z ENDP	; CFuncTrain::Blocked
_TEXT	ENDS
PUBLIC	?Stop@CFuncTrain@@QAEXXZ			; CFuncTrain::Stop
EXTRN	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalVelocity
;	COMDAT ?Stop@CFuncTrain@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Stop@CFuncTrain@@QAEXXZ PROC NEAR			; CFuncTrain::Stop, COMDAT

; 870  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 871  : 	// clear the sound channel.
; 872  : 	if( pev->noise )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+488], 0
	je	SHORT $L37661

; 873  : 		STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+488]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH
$L37661:

; 874  : 
; 875  : 	SetLocalVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 876  : 	SetMoveDoneTime( -1 );

	push	-1082130432				; bf800000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 877  : 	m_iState = STATE_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 0

; 878  : 	SetMoveDone( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 879  : 	DontThink();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DontThink@CBaseEntity@@QAEXXZ		; CBaseEntity::DontThink

; 880  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@CFuncTrain@@QAEXXZ ENDP				; CFuncTrain::Stop
_TEXT	ENDS
PUBLIC	?Use@CFuncTrain@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncTrain::Use
EXTRN	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z:NEAR ; CBaseEntity::ShouldToggle
;	COMDAT ?Use@CFuncTrain@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_this$ = -4
?Use@CFuncTrain@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CFuncTrain::Use, COMDAT

; 883  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 	m_hActivator = pActivator;

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 885  : 
; 886  : 	if( IsLockedByMaster( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHXZ	; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L37671

; 887  : 		return;

	jmp	$L37670
$L37671:

; 888  : 
; 889  : 	if( !ShouldToggle( useType ))

	mov	ecx, DWORD PTR _useType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z ; CBaseEntity::ShouldToggle
	test	eax, eax
	jne	SHORT $L37672

; 890  : 		return;

	jmp	$L37670
$L37672:

; 891  : 
; 892  : 	if( pev->spawnflags & SF_TRAIN_WAIT_RETRIGGER )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L37673

; 894  : 		// Move toward my target
; 895  : 		pev->spawnflags &= ~SF_TRAIN_WAIT_RETRIGGER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+416], ecx

; 896  : 		Next();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Next@CFuncTrain@@QAEXXZ		; CFuncTrain::Next

; 898  : 	else

	jmp	$L37676
$L37673:

; 900  : 		pev->spawnflags |= SF_TRAIN_WAIT_RETRIGGER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	or	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+416], eax

; 901  : 
; 902  : 		// pop back to last target if it's available
; 903  : 		if( pev->enemy )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+400], 0
	je	SHORT $L37675

; 904  : 			pev->target = pev->enemy->v.targetname;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+400]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+588]
	mov	DWORD PTR [eax+456], ecx
$L37675:

; 905  : 
; 906  : 		Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@CFuncTrain@@QAEXXZ		; CFuncTrain::Stop

; 907  : 
; 908  : 		if( pev->noise1 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+492], 0
	je	SHORT $L37676

; 909  : 			EMIT_SOUND( edict(), CHAN_VOICE, STRING( pev->noise1 ), m_volume, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1964]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+492]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37676:
$L37670:

; 911  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CFuncTrain@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CFuncTrain::Use
_TEXT	ENDS
PUBLIC	?ArrivalNotify@CTrainSequence@@QAEXXZ		; CTrainSequence::ArrivalNotify
;	COMDAT ?Wait@CFuncTrain@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Wait@CFuncTrain@@QAEXXZ PROC NEAR			; CFuncTrain::Wait, COMDAT

; 914  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 915  : 	if ( m_pSequence )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1972], 0
	je	SHORT $L37682

; 916  : 		m_pSequence->ArrivalNotify();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1972]
	call	?ArrivalNotify@CTrainSequence@@QAEXXZ	; CTrainSequence::ArrivalNotify
$L37682:

; 917  : 
; 918  : 	// Fire the pass target if there is one
; 919  : 	if ( m_hCurrentTarget->pev->message )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1976				; 000007b8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	edx, DWORD PTR [eax+4]
	cmp	DWORD PTR [edx+468], 0
	je	$L37684

; 921  : 		UTIL_FireTargets( STRING( m_hCurrentTarget->pev->message ), this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1976				; 000007b8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+468]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 922  : 		UTIL_FireTargets( STRING( pev->netname ), this, this, USE_TOGGLE );

	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 923  : 
; 924  : 		if( FBitSet( m_hCurrentTarget->pev->spawnflags, SF_CORNER_FIREONCE ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1976				; 000007b8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 4
	test	ecx, ecx
	je	SHORT $L37684

; 925  : 			m_hCurrentTarget->pev->message = NULL_STRING;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1976				; 000007b8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+468], 0
$L37684:

; 927  : 		
; 928  : 	// need pointer to LAST target.
; 929  : 	if( FBitSet( m_hCurrentTarget->pev->spawnflags, SF_TRAIN_WAIT_RETRIGGER ) || ( pev->spawnflags & SF_TRAIN_WAIT_RETRIGGER ) )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1976				; 000007b8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L37686
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L37685
$L37686:

; 931  : 		pev->spawnflags |= SF_TRAIN_WAIT_RETRIGGER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	or	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+416], ecx

; 932  : 
; 933  : 		Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@CFuncTrain@@QAEXXZ		; CFuncTrain::Stop

; 934  : 
; 935  : 		if( pev->noise1 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+492], 0
	je	SHORT $L37687

; 936  : 			EMIT_SOUND( edict(), CHAN_VOICE, STRING( pev->noise1 ), m_volume, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1964]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+492]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37687:

; 937  : 		return;

	jmp	$L37681
$L37685:

; 939  :     
; 940  : 	// ALERT ( at_console, "%f\n", m_flWait );
; 941  : 
; 942  : 	if( m_flWait != 0 )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1764]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L37689

; 944  : 		// -1 wait will wait forever!		
; 945  : 		SetMoveDoneTime( m_flWait );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1764]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 946  : 
; 947  : 		if( pev->noise )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+488], 0
	je	SHORT $L37690

; 948  : 			STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+488]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH
$L37690:

; 949  : 
; 950  : 		if( pev->noise1 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+492], 0
	je	SHORT $L37691

; 951  : 			EMIT_SOUND( edict(), CHAN_VOICE, STRING( pev->noise1 ), m_volume, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1964]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+492]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37691:

; 952  : 
; 953  : 		SetMoveDone( Next );

	push	OFFSET FLAT:??_C@_04CIMM@Next?$AA@	; `string'
	push	OFFSET FLAT:?Next@CFuncTrain@@QAEXXZ	; CFuncTrain::Next
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 954  : 		m_iState = STATE_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 0

; 956  : 	else

	jmp	SHORT $L37695
$L37689:

; 958  : 		// do it RIGHT now!
; 959  : 		Next();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Next@CFuncTrain@@QAEXXZ		; CFuncTrain::Next
$L37695:
$L37681:

; 961  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Wait@CFuncTrain@@QAEXXZ ENDP				; CFuncTrain::Wait
_TEXT	ENDS
PUBLIC	?GetTargetname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetTargetname
PUBLIC	?GetTarget@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetTarget
PUBLIC	?CalcPosition@CFuncTrain@@QAE?AVVector@@PAVCBaseEntity@@@Z ; CFuncTrain::CalcPosition
PUBLIC	??_C@_0BJ@OJNB@Train?5?$CFs?5speed?5to?5?$CF4?42f?6?$AA@ ; `string'
;	COMDAT ??_C@_0BJ@OJNB@Train?5?$CFs?5speed?5to?5?$CF4?42f?6?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BJ@OJNB@Train?5?$CFs?5speed?5to?5?$CF4?42f?6?$AA@ DB 'Train %s spe'
	DB	'ed to %4.2f', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?Next@CFuncTrain@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pTarg$ = -8
_pSearch$37705 = -12
$T40898 = -24
$T40899 = -36
?Next@CFuncTrain@@QAEXXZ PROC NEAR			; CFuncTrain::Next, COMDAT

; 967  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 968  : 	// now find our next target
; 969  : 	CBaseEntity *pTarg = GetNextTarget();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+268]
	mov	DWORD PTR _pTarg$[ebp], eax

; 970  : 
; 971  : 	if( !pTarg )

	cmp	DWORD PTR _pTarg$[ebp], 0
	jne	SHORT $L37701

; 973  : 		Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@CFuncTrain@@QAEXXZ		; CFuncTrain::Stop

; 974  : 
; 975  : 		// play stop sound
; 976  : 		if( pev->noise1 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+492], 0
	je	SHORT $L37702

; 977  : 			EMIT_SOUND( edict(), CHAN_VOICE, STRING( pev->noise1 ), m_volume, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1964]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+492]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37702:

; 978  : 
; 979  : 		return;

	jmp	$L37699
$L37701:

; 981  : 
; 982  : 	// Save last target in case we need to find it again
; 983  : 	pev->message = pev->target;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+456]
	mov	DWORD PTR [ecx+468], edx

; 984  : 
; 985  : 	if( FBitSet( pev->spawnflags, SF_TRAIN_REVERSE ) && m_pSequence != NULL )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, -2147483648			; 80000000H
	test	edx, edx
	je	SHORT $L37704
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1972], 0
	je	SHORT $L37704

; 987  : 		CBaseEntity *pSearch = m_pSequence->m_pDestination;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1972]
	mov	eax, DWORD PTR [edx+1784]
	mov	DWORD PTR _pSearch$37705[ebp], eax
$L37707:

; 988  : 
; 989  : 		while( pSearch )

	cmp	DWORD PTR _pSearch$37705[ebp], 0
	je	SHORT $L37708

; 991  : 			if( FStrEq( pSearch->GetTarget(), GetTarget()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTarget@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTarget
	push	eax
	mov	ecx, DWORD PTR _pSearch$37705[ebp]
	call	?GetTarget@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTarget
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37709

; 993  : 				// pSearch leads to the current corner, so it's the next thing we're moving to.
; 994  : 				pev->target = pSearch->pev->targetname;

	mov	ecx, DWORD PTR _pSearch$37705[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+460]
	mov	DWORD PTR [ecx+456], edx

; 995  : 				break;

	jmp	SHORT $L37708
$L37709:

; 997  : 
; 998  : 			pSearch = pSearch->GetNextTarget();

	mov	eax, DWORD PTR _pSearch$37705[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pSearch$37705[ebp]
	call	DWORD PTR [edx+268]
	mov	DWORD PTR _pSearch$37705[ebp], eax

; 999  : 		}

	jmp	SHORT $L37707
$L37708:

; 1001 : 	else

	jmp	SHORT $L37710
$L37704:

; 1003 : 		pev->target = pTarg->pev->target;

	mov	eax, DWORD PTR _pTarg$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+456]
	mov	DWORD PTR [eax+456], ecx
$L37710:

; 1005 : 
; 1006 : 	m_flWait = pTarg->GetDelay();

	mov	edx, DWORD PTR _pTarg$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pTarg$[ebp]
	call	DWORD PTR [eax+160]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1764]

; 1007 : 
; 1008 : 	if( m_hCurrentTarget != NULL && m_hCurrentTarget->pev->speed != 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1976				; 000007b8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37711
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1976				; 000007b8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	edx, DWORD PTR [eax+4]
	fld	DWORD PTR [edx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L37711

; 1010 : 		// don't copy speed from target if it is 0 (uninitialized)
; 1011 : 		pev->speed = m_hCurrentTarget->pev->speed;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1976				; 000007b8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+504]
	mov	DWORD PTR [edx+504], eax

; 1012 : 		ALERT( at_aiconsole, "Train %s speed to %4.2f\n", GetTargetname(), pev->speed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	push	OFFSET FLAT:??_C@_0BJ@OJNB@Train?5?$CFs?5speed?5to?5?$CF4?42f?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L37711:

; 1014 : 
; 1015 : 	m_hCurrentTarget = pTarg;	// keep track of this since path corners change our target for us.

	mov	eax, DWORD PTR _pTarg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1976				; 000007b8H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1016 : 	pev->enemy = pTarg->edict();	// hack

	mov	ecx, DWORD PTR _pTarg$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+400], eax

; 1017 : 
; 1018 : 	if( FBitSet( m_hCurrentTarget->pev->spawnflags, SF_CORNER_TELEPORT ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1976				; 000007b8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L37713

; 1020 : 		// Path corner has indicated a teleport to the next corner.
; 1021 : 		SetBits( pev->effects, EF_NOINTERP );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+280]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+280], ecx

; 1022 : 		UTIL_SetOrigin( this, CalcPosition( pTarg ));

	mov	ecx, DWORD PTR _pTarg$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40898[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcPosition@CFuncTrain@@QAE?AVVector@@PAVCBaseEntity@@@Z ; CFuncTrain::CalcPosition
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 1023 : 		Wait(); // Get on with doing the next path corner.

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Wait@CFuncTrain@@QAEXXZ		; CFuncTrain::Wait

; 1025 : 	else

	jmp	$L37715
$L37713:

; 1027 : 		// Normal linear move.
; 1028 : 		
; 1029 : 		// CHANGED this from CHAN_VOICE to CHAN_STATIC around OEM beta time because trains should
; 1030 : 		// use CHAN_STATIC for their movement sounds to prevent sound field problems.
; 1031 : 		// this is not a hack or temporary fix, this is how things should be. (sjb).
; 1032 : 		if( pev->noise )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+488], 0
	je	SHORT $L37716

; 1033 : 			STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+488]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH
$L37716:

; 1034 : 
; 1035 : 		if( pev->noise )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+488], 0
	je	SHORT $L37717

; 1036 : 			EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ), m_volume, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1964]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+488]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37717:

; 1037 : 
; 1038 : 		ClearBits( pev->effects, EF_NOINTERP );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	and	al, -33					; ffffffdfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax

; 1039 : 		m_iState = STATE_ON;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 1

; 1040 : 
; 1041 : 		SetMoveDone( Wait );

	push	OFFSET FLAT:??_C@_04EGHG@Wait?$AA@	; `string'
	push	OFFSET FLAT:?Wait@CFuncTrain@@QAEXXZ	; CFuncTrain::Wait
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 1042 : 		LinearMove( CalcPosition( pTarg ), pev->speed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	push	eax
	mov	ecx, DWORD PTR _pTarg$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40899[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcPosition@CFuncTrain@@QAE?AVVector@@PAVCBaseEntity@@@Z ; CFuncTrain::CalcPosition
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::LinearMove
$L37715:
$L37699:

; 1044 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Next@CFuncTrain@@QAEXXZ ENDP				; CFuncTrain::Next
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetTargetname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetTargetname, COMDAT

; 284  : 	const char*	GetTargetname() { return STRING( pev->targetname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTargetname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetTargetname
_TEXT	ENDS
;	COMDAT ?GetTarget@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetTarget@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetTarget, COMDAT

; 285  : 	const char*	GetTarget() { return STRING( pev->target ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+456]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTarget@CBaseEntity@@QAEPBDXZ ENDP			; CBaseEntity::GetTarget
_TEXT	ENDS
PUBLIC	??ZVector@@QAEAAV0@ABV0@@Z			; Vector::operator-=
;	COMDAT ?CalcPosition@CFuncTrain@@QAE?AVVector@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pTarg$ = 12
___$ReturnUdt$ = 8
_this$ = -4
_nextPos$ = -16
$T40906 = -28
$T40907 = -40
?CalcPosition@CFuncTrain@@QAE?AVVector@@PAVCBaseEntity@@@Z PROC NEAR ; CFuncTrain::CalcPosition, COMDAT

; 820  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 821  : 		Vector nextPos = pTarg->GetLocalOrigin();

	mov	ecx, DWORD PTR _pTarg$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	ecx, DWORD PTR _nextPos$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 822  : 		if( !FBitSet( pev->spawnflags, SF_TRAIN_SETORIGIN ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 2
	test	edx, edx
	jne	SHORT $L37557

; 823  : 			nextPos -= (pev->mins + pev->maxs) * 0.5f;

	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T40907[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 232				; 000000e8H
	push	edx
	lea	eax, DWORD PTR $T40906[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 220				; 000000dcH
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _nextPos$[ebp]
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=
$L37557:

; 824  : 		return nextPos;

	lea	edx, DWORD PTR _nextPos$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 825  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CalcPosition@CFuncTrain@@QAE?AVVector@@PAVCBaseEntity@@@Z ENDP ; CFuncTrain::CalcPosition
_TEXT	ENDS
;	COMDAT ??ZVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??ZVector@@QAEAAV0@ABV0@@Z PROC NEAR			; Vector::operator-=, COMDAT

; 164  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		x-=v.x; y-=v.y; z -= v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 166  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 167  : 	}		

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??ZVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator-=
_TEXT	ENDS
PUBLIC	?Activate@CFuncTrain@@UAEXXZ			; CFuncTrain::Activate
EXTRN	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z:NEAR ; UTIL_FindEntityByTargetname
EXTRN	?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z:NEAR	; CBaseEntity::Teleport
;	COMDAT ?Activate@CFuncTrain@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pTarg$37727 = -8
_nextPos$37729 = -20
$T40912 = -32
?Activate@CFuncTrain@@UAEXXZ PROC NEAR			; CFuncTrain::Activate, COMDAT

; 1047 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1048 : 	// Not yet active, so teleport to first target
; 1049 : 	if( !m_activated )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1984], 0
	jne	$L37734

; 1051 : 		m_activated = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1984], 1

; 1052 : 		CBaseEntity *pTarg = UTIL_FindEntityByTargetname( NULL, STRING( pev->target ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+456]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pTarg$37727[ebp], eax

; 1053 : 
; 1054 : 		if( pTarg )

	cmp	DWORD PTR _pTarg$37727[ebp], 0
	je	SHORT $L37728

; 1056 : 			pev->target = pTarg->pev->target;

	mov	edx, DWORD PTR _pTarg$37727[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+456]
	mov	DWORD PTR [edx+456], eax

; 1057 : 			pev->message = pTarg->pev->targetname;

	mov	ecx, DWORD PTR _pTarg$37727[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+460]
	mov	DWORD PTR [ecx+468], edx

; 1058 : 			m_hCurrentTarget = pTarg; // keep track of this since path corners change our target for us.

	mov	eax, DWORD PTR _pTarg$37727[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1976				; 000007b8H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1059 : 			Vector nextPos = CalcPosition( pTarg );

	mov	ecx, DWORD PTR _pTarg$37727[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40912[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcPosition@CFuncTrain@@QAE?AVVector@@PAVCBaseEntity@@@Z ; CFuncTrain::CalcPosition
	push	eax
	lea	ecx, DWORD PTR _nextPos$37729[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1060 :     
; 1061 : 			Teleport( &nextPos, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _nextPos$37729[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z ; CBaseEntity::Teleport
$L37728:

; 1063 : 
; 1064 : 		if( FStringNull( pev->targetname ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+460]
	push	eax
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	je	SHORT $L37731

; 1066 : 			// not triggered, so start immediately
; 1067 : 			SetMoveDoneTime( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 1068 : 			SetMoveDone( Next );

	push	OFFSET FLAT:??_C@_04CIMM@Next?$AA@	; `string'
	push	OFFSET FLAT:?Next@CFuncTrain@@QAEXXZ	; CFuncTrain::Next
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 1070 : 		else

	jmp	SHORT $L37734
$L37731:

; 1072 : 			pev->spawnflags |= SF_TRAIN_WAIT_RETRIGGER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	or	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+416], eax
$L37734:

; 1075 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CFuncTrain@@UAEXXZ ENDP			; CFuncTrain::Activate
_TEXT	ENDS
PUBLIC	?StartSequence@CFuncTrain@@QAEXPAVCTrainSequence@@@Z ; CFuncTrain::StartSequence
;	COMDAT ?StartSequence@CFuncTrain@@QAEXPAVCTrainSequence@@@Z
_TEXT	SEGMENT
_pSequence$ = 8
_this$ = -4
?StartSequence@CFuncTrain@@QAEXPAVCTrainSequence@@@Z PROC NEAR ; CFuncTrain::StartSequence, COMDAT

; 1078 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1079 : 	m_pSequence = pSequence;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pSequence$[ebp]
	mov	DWORD PTR [eax+1972], ecx

; 1080 : 	ClearBits( pev->spawnflags, SF_TRAIN_WAIT_RETRIGGER );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+416], ecx

; 1081 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartSequence@CFuncTrain@@QAEXPAVCTrainSequence@@@Z ENDP ; CFuncTrain::StartSequence
_TEXT	ENDS
PUBLIC	?StopSequence@CFuncTrain@@QAEXXZ		; CFuncTrain::StopSequence
;	COMDAT ?StopSequence@CFuncTrain@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSequence@CFuncTrain@@QAEXXZ PROC NEAR		; CFuncTrain::StopSequence, COMDAT

; 1084 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1085 : 	m_pSequence = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1972], 0

; 1086 : 	pev->spawnflags &= ~SF_TRAIN_REVERSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 2147483647				; 7fffffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+416], eax

; 1087 : 	Use( this, this, USE_OFF, 0.0f );

	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+276]

; 1088 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSequence@CFuncTrain@@QAEXXZ ENDP			; CFuncTrain::StopSequence
_TEXT	ENDS
PUBLIC	?GetModel@CBaseEntity@@QAEPBDXZ			; CBaseEntity::GetModel
PUBLIC	?Spawn@CFuncTrain@@UAEXXZ			; CFuncTrain::Spawn
PUBLIC	??_C@_0BP@NAM@?$CFs?5with?5name?5?$CFs?5has?5no?5target?6?$AA@ ; `string'
PUBLIC	__real@4@bfff8000000000000000
;	COMDAT ??_C@_0BP@NAM@?$CFs?5with?5name?5?$CFs?5has?5no?5target?6?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BP@NAM@?$CFs?5with?5name?5?$CFs?5has?5no?5target?6?$AA@ DB '%s wit'
	DB	'h name %s has no target', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@4@bfff8000000000000000
CONST	SEGMENT
__real@4@bfff8000000000000000 DD 0bf800000r	; -1
CONST	ENDS
;	COMDAT ?Spawn@CFuncTrain@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CFuncTrain@@UAEXXZ PROC NEAR			; CFuncTrain::Spawn, COMDAT

; 1102 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 	Precache();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 1104 : 
; 1105 : 	if( !pev->speed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37746

; 1106 : 		pev->speed = 100;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+504], 1120403456		; 42c80000H
$L37746:

; 1107 : 	
; 1108 : 	if( FStringNull( pev->target ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+456]
	push	eax
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	je	SHORT $L37747

; 1109 : 		ALERT( at_error, "%s with name %s has no target\n", GetClassname(), GetTargetname());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0BP@NAM@?$CFs?5with?5name?5?$CFs?5has?5no?5target?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H
$L37747:

; 1110 : 	
; 1111 : 	if( pev->dmg == 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+480]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37749

; 1112 : 		pev->dmg = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+480], 1073741824		; 40000000H

; 1113 : 	else if( pev->dmg == -1 )

	jmp	SHORT $L37751
$L37749:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+480]
	fcomp	DWORD PTR __real@4@bfff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37751

; 1114 : 		pev->dmg = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+480], 0
$L37751:

; 1115 : 	
; 1116 : 	pev->movetype = MOVETYPE_PUSH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 7

; 1117 : 	
; 1118 : 	if( FBitSet( pev->spawnflags, SF_TRACKTRAIN_PASSABLE ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 8
	test	ecx, ecx
	je	SHORT $L37752

; 1119 : 		pev->solid = SOLID_NOT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 0

; 1120 : 	else pev->solid = SOLID_BSP;

	jmp	SHORT $L37753
$L37752:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 4
$L37753:

; 1121 : 
; 1122 : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 1123 : 	UTIL_SetSize( pev, pev->mins, pev->maxs );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 232				; 000000e8H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 220				; 000000dcH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 1124 : 	RelinkEntity( TRUE );

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 1125 : 
; 1126 : 	m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 1127 : 	m_iState = STATE_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 0

; 1128 : 	m_activated = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1984], 0

; 1129 : 
; 1130 : 	if( !m_volume )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1964]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37754

; 1131 : 		m_volume = 0.85f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1964], 1062836634	; 3f59999aH
$L37754:

; 1132 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncTrain@@UAEXXZ ENDP				; CFuncTrain::Spawn
_TEXT	ENDS
;	COMDAT ?GetModel@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetModel@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetModel, COMDAT

; 288  : 	const char*	GetModel() { return STRING( pev->model ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+184]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetModel@CBaseEntity@@QAEPBDXZ ENDP			; CBaseEntity::GetModel
_TEXT	ENDS
PUBLIC	?Precache@CFuncTrain@@UAEXXZ			; CFuncTrain::Precache
PUBLIC	??_C@_0BK@KEIM@?$CGCFuncTrain?5?3?3?5SoundSetup?$AA@ ; `string'
;	COMDAT ??_C@_0BK@KEIM@?$CGCFuncTrain?5?3?3?5SoundSetup?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BK@KEIM@?$CGCFuncTrain?5?3?3?5SoundSetup?$AA@ DB '&CFuncTrain :: S'
	DB	'oundSetup', 00H				; `string'
CONST	ENDS
;	COMDAT ?Precache@CFuncTrain@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CFuncTrain@@UAEXXZ PROC NEAR			; CFuncTrain::Precache, COMDAT

; 1135 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1136 : 	CBasePlatTrain::Precache();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Precache@CBasePlatTrain@@UAEXXZ	; CBasePlatTrain::Precache

; 1137 : 
; 1138 : 	SetThink( &CFuncTrain :: SoundSetup );

	push	OFFSET FLAT:??_C@_0BK@KEIM@?$CGCFuncTrain?5?3?3?5SoundSetup?$AA@ ; `string'
	push	OFFSET FLAT:?SoundSetup@CFuncTrain@@QAEXXZ ; CFuncTrain::SoundSetup
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1139 : 	SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 1140 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CFuncTrain@@UAEXXZ ENDP			; CFuncTrain::Precache
_TEXT	ENDS
;	COMDAT ?SoundSetup@CFuncTrain@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SoundSetup@CFuncTrain@@QAEXXZ PROC NEAR		; CFuncTrain::SoundSetup, COMDAT

; 1143 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1144 : 	if( pev->noise && m_iState == STATE_ON )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+488], 0
	je	SHORT $L37766
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1788], 1
	jne	SHORT $L37766

; 1145 : 		EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ), m_volume, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1964]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+488]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37766:

; 1146 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SoundSetup@CFuncTrain@@QAEXXZ ENDP			; CFuncTrain::SoundSetup
_TEXT	ENDS
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
PUBLIC	?OverrideReset@CFuncTrain@@UAEXXZ		; CFuncTrain::OverrideReset
EXTRN	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalVelocity
;	COMDAT ?OverrideReset@CFuncTrain@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pTarg$ = -8
?OverrideReset@CFuncTrain@@UAEXXZ PROC NEAR		; CFuncTrain::OverrideReset, COMDAT

; 1149 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1150 : 	CBaseEntity *pTarg;
; 1151 : 
; 1152 : 	// are we moving?
; 1153 : 	if( GetLocalVelocity() != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	$L37775

; 1155 : 		pev->target = pev->message;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+468]
	mov	DWORD PTR [eax+456], ecx

; 1156 : 		// now find our next target
; 1157 : 		pTarg = GetNextTarget();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+268]
	mov	DWORD PTR _pTarg$[ebp], eax

; 1158 : 
; 1159 : 		if( !pTarg )

	cmp	DWORD PTR _pTarg$[ebp], 0
	jne	SHORT $L37774

; 1161 : 			Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@CFuncTrain@@QAEXXZ		; CFuncTrain::Stop

; 1163 : 		else	

	jmp	SHORT $L37775
$L37774:

; 1165 : 			// UNDONE: this code is wrong
; 1166 : 
; 1167 : 			// restore target on a next level
; 1168 : 			m_hCurrentTarget = pTarg;

	mov	ecx, DWORD PTR _pTarg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1976				; 000007b8H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1169 : 			pev->enemy = pTarg->edict();

	mov	ecx, DWORD PTR _pTarg$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+400], eax

; 1170 : 
; 1171 : 			// restore sound on a next level
; 1172 : 			SetThink( &CFuncTrain :: SoundSetup );

	push	OFFSET FLAT:??_C@_0BK@KEIM@?$CGCFuncTrain?5?3?3?5SoundSetup?$AA@ ; `string'
	push	OFFSET FLAT:?SoundSetup@CFuncTrain@@QAEXXZ ; CFuncTrain::SoundSetup
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1173 : 			SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]
$L37775:

; 1176 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CFuncTrain@@UAEXXZ ENDP			; CFuncTrain::OverrideReset
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	?Use@CTrainSequence@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CTrainSequence::Use
PUBLIC	?GetMessageA@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetMessageA
PUBLIC	??_C@_0CE@NFMG@trainsequence?5?$CC?$CFs?$CC?5found?5train?5?$CC@ ; `string'
PUBLIC	??_C@_0BG@HAH@found?5destination?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0BF@GIIE@missing?5destination?6?$AA@	; `string'
PUBLIC	??_C@_0EI@PICH@Found?5no?5path?5to?5reach?5destinati@ ; `string'
PUBLIC	??_C@_0DO@EJNJ@scripted_trainsequence?5?$CFs?5can?8t?5@ ; `string'
PUBLIC	??_C@_0DD@HMAL@Missing?5train?5?$CC?$CFs?$CC?5for?5scripted_@ ; `string'
EXTRN	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD0@Z:NEAR ; UTIL_FindEntityByTargetname
;	COMDAT ??_C@_0CE@NFMG@trainsequence?5?$CC?$CFs?$CC?5found?5train?5?$CC@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0CE@NFMG@trainsequence?5?$CC?$CFs?$CC?5found?5train?5?$CC@ DB 'trai'
	DB	'nsequence "%s" found train "%s"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HAH@found?5destination?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BG@HAH@found?5destination?5?$CFs?6?$AA@ DB 'found destination %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GIIE@missing?5destination?6?$AA@
CONST	SEGMENT
??_C@_0BF@GIIE@missing?5destination?6?$AA@ DB 'missing destination', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@PICH@Found?5no?5path?5to?5reach?5destinati@
CONST	SEGMENT
??_C@_0EI@PICH@Found?5no?5path?5to?5reach?5destinati@ DB 'Found no path t'
	DB	'o reach destination! (train has t %s, m %s; dest is %s)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@EJNJ@scripted_trainsequence?5?$CFs?5can?8t?5@
CONST	SEGMENT
??_C@_0DO@EJNJ@scripted_trainsequence?5?$CFs?5can?8t?5@ DB 'scripted_trai'
	DB	'nsequence %s can''t affect %s "%s": not a train!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@HMAL@Missing?5train?5?$CC?$CFs?$CC?5for?5scripted_@
CONST	SEGMENT
??_C@_0DD@HMAL@Missing?5train?5?$CC?$CFs?$CC?5for?5scripted_@ DB 'Missing'
	DB	' train "%s" for scripted_trainsequence %s!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?Use@CTrainSequence@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_this$ = -4
_pEnt$37787 = -8
_pTrain$37796 = -12
_iDir$37801 = -16
_vecFTemp$37808 = -28
_vecBTemp$37809 = -40
_pTrainDest$37810 = -44
_fForward$37811 = -48
_fBackward$37821 = -52
_pCurForward$37822 = -56
_pCurBackward$37823 = -60
_loopbreaker$37824 = -64
_pSearch$37846 = -68
_pTrainTarg$37851 = -72
$T40933 = -84
$T40934 = -96
$T40935 = -108
$T40936 = -120
$T40937 = -132
$T40938 = -144
$T40939 = -156
?Use@CTrainSequence@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CTrainSequence::Use, COMDAT

; 1179 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1180 : 	if( !ShouldToggle( useType ))

	mov	eax, DWORD PTR _useType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z ; CBaseEntity::ShouldToggle
	test	eax, eax
	jne	SHORT $L37785

; 1181 : 		return;

	jmp	$L37784
$L37785:

; 1182 : 
; 1183 : 	if( GetState() == STATE_OFF )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	test	eax, eax
	jne	$L37786

; 1185 : 		// start the sequence, take control of the train
; 1186 : 
; 1187 : 		CBaseEntity *pEnt = UTIL_FindEntityByTargetname( NULL, STRING( m_iszEntity ), pActivator );

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1764]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD0@Z ; UTIL_FindEntityByTargetname
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pEnt$37787[ebp], eax

; 1188 : 
; 1189 : 		if( pEnt )

	cmp	DWORD PTR _pEnt$37787[ebp], 0
	je	$L37788

; 1191 : 			m_pDestination = UTIL_FindEntityByTargetname( NULL, STRING( m_iszDestination ), pActivator );

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1768]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD0@Z ; UTIL_FindEntityByTargetname
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1784], eax

; 1192 : 
; 1193 : 			if( FBitSet( pev->spawnflags, SF_TRAINSEQ_DEBUG ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 8
	test	ecx, ecx
	je	SHORT $L37793

; 1195 : 				ALERT( at_console, "trainsequence \"%s\" found train \"%s\"", GetTargetname(), pEnt->GetTargetname());

	mov	ecx, DWORD PTR _pEnt$37787[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	push	OFFSET FLAT:??_C@_0CE@NFMG@trainsequence?5?$CC?$CFs?$CC?5found?5train?5?$CC@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 1196 : 
; 1197 : 				if( m_pDestination )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1784], 0
	je	SHORT $L37791

; 1198 : 					ALERT( at_console, "found destination %s\n", m_pDestination->GetTargetname());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1784]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	push	OFFSET FLAT:??_C@_0BG@HAH@found?5destination?5?$CFs?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1199 : 				else

	jmp	SHORT $L37793
$L37791:

; 1200 : 					ALERT( at_console, "missing destination\n" );

	push	OFFSET FLAT:??_C@_0BF@GIIE@missing?5destination?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L37793:

; 1202 : 
; 1203 : 			if( FStrEq( pEnt->GetClassname(), "func_train" ))

	push	OFFSET FLAT:??_C@_0L@OLKI@func_train?$AA@ ; `string'
	mov	ecx, DWORD PTR _pEnt$37787[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	$L37795

; 1205 : 				CFuncTrain *pTrain = (CFuncTrain*)pEnt;

	mov	ecx, DWORD PTR _pEnt$37787[ebp]
	mov	DWORD PTR _pTrain$37796[ebp], ecx

; 1206 : 
; 1207 : 				// check whether it's being controlled by another sequence
; 1208 : 				if( pTrain->m_pSequence )

	mov	edx, DWORD PTR _pTrain$37796[ebp]
	cmp	DWORD PTR [edx+1972], 0
	je	SHORT $L37798

; 1209 : 					return;

	jmp	$L37784
$L37798:

; 1210 : 
; 1211 : 				// ok, we can now take control of it.
; 1212 : 				pTrain->StartSequence( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	call	?StartSequence@CFuncTrain@@QAEXPAVCTrainSequence@@@Z ; CFuncTrain::StartSequence

; 1213 : 				m_pTrain = pTrain;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTrain$37796[ebp]
	mov	DWORD PTR [ecx+1780], edx

; 1214 : 
; 1215 : 				if( FBitSet( pev->spawnflags, SF_TRAINSEQ_DIRECT ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 4
	test	edx, edx
	je	SHORT $L37799

; 1217 : 					pTrain->pev->target = m_pDestination->pev->targetname;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1784]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pTrain$37796[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+460]
	mov	DWORD PTR [ecx+456], edx

; 1218 : 					pTrain->Next();

	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	call	?Next@CFuncTrain@@QAEXXZ		; CFuncTrain::Next

; 1220 : 				else

	jmp	$L37858
$L37799:

; 1222 : 					int iDir = DIRECTION_NONE;

	mov	DWORD PTR _iDir$37801[ebp], 0

; 1225 : 					{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1776]
	mov	DWORD PTR -160+[ebp], ecx
	mov	edx, DWORD PTR -160+[ebp]
	sub	edx, 1
	mov	DWORD PTR -160+[ebp], edx
	cmp	DWORD PTR -160+[ebp], 3
	ja	$L37803
	mov	eax, DWORD PTR -160+[ebp]
	jmp	DWORD PTR $L40940[eax*4]
$L37806:

; 1226 : 					case DIRECTION_DESTINATION:
; 1227 : 						if( m_pDestination )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1784], 0
	je	$L37807

; 1229 : 							Vector vecFTemp, vecBTemp;

	lea	ecx, DWORD PTR _vecFTemp$37808[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _vecBTemp$37809[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1230 : 							CBaseEntity *pTrainDest = UTIL_FindEntityByTargetname( NULL, pTrain->GetMessage( ));

	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	call	?GetMessageA@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetMessageA
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pTrainDest$37810[ebp], eax

; 1231 : 							float fForward;
; 1232 : 
; 1233 : 							if( !pTrainDest )

	cmp	DWORD PTR _pTrainDest$37810[ebp], 0
	jne	SHORT $L37812

; 1235 : 								// this shouldn't happen.
; 1236 : 								ALERT(at_error, "Found no path to reach destination! (train has t %s, m %s; dest is %s)\n",
; 1237 : 								pTrain->GetTarget(), pTrain->GetMessage(), m_pDestination->GetTargetname( ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1784]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	call	?GetMessageA@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetMessageA
	push	eax
	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	call	?GetTarget@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTarget
	push	eax
	push	OFFSET FLAT:??_C@_0EI@PICH@Found?5no?5path?5to?5reach?5destinati@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H

; 1238 : 								return;

	jmp	$L37784
$L37812:

; 1240 : 
; 1241 : 							if( FBitSet( pTrain->pev->spawnflags, SF_TRAIN_SETORIGIN ))

	mov	eax, DWORD PTR _pTrain$37796[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 2
	test	edx, edx
	je	SHORT $L37814

; 1242 : 								fForward = (pTrainDest->GetLocalOrigin() - pTrain->GetLocalOrigin()).Length();

	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	eax, DWORD PTR $T40933[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTrainDest$37810[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _fForward$37811[ebp]

; 1243 : 							else fForward = (pTrainDest->GetLocalOrigin() - (pTrain->GetLocalOrigin() + (pTrain->pev->maxs + pTrain->pev->mins) * 0.5f )).Length();

	jmp	SHORT $L37816
$L37814:
	push	1056964608				; 3f000000H
	lea	ecx, DWORD PTR $T40935[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTrain$37796[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 220				; 000000dcH
	push	eax
	lea	ecx, DWORD PTR $T40934[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTrain$37796[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 232				; 000000e8H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40936[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR $T40937[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTrainDest$37810[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _fForward$37811[ebp]
$L37816:

; 1244 : 							float fBackward = -fForward; // the further back from the TrainDest entity we are, the shorter the backward distance.

	fld	DWORD PTR _fForward$37811[ebp]
	fchs
	fstp	DWORD PTR _fBackward$37821[ebp]

; 1245 : 
; 1246 : 							CBaseEntity *pCurForward = pTrainDest;

	mov	edx, DWORD PTR _pTrainDest$37810[ebp]
	mov	DWORD PTR _pCurForward$37822[ebp], edx

; 1247 : 							CBaseEntity *pCurBackward = m_pDestination;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1784]
	mov	DWORD PTR _pCurBackward$37823[ebp], ecx

; 1248 : 							vecFTemp = pCurForward->GetLocalOrigin();

	mov	ecx, DWORD PTR _pCurForward$37822[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecFTemp$37808[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecFTemp$37808[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecFTemp$37808[ebp+8], edx

; 1249 : 							vecBTemp = pCurBackward->GetLocalOrigin();

	mov	ecx, DWORD PTR _pCurBackward$37823[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecBTemp$37809[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecBTemp$37809[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecBTemp$37809[ebp+8], eax

; 1250 : 							int loopbreaker = 10;

	mov	DWORD PTR _loopbreaker$37824[ebp], 10	; 0000000aH
$L37826:

; 1251 : 
; 1252 : 							while( iDir == DIRECTION_NONE )

	cmp	DWORD PTR _iDir$37801[ebp], 0
	jne	$L37827

; 1254 : 								if (pCurForward)

	cmp	DWORD PTR _pCurForward$37822[ebp], 0
	je	SHORT $L37833

; 1256 : 									fForward += (pCurForward->GetLocalOrigin() - vecFTemp).Length();

	lea	ecx, DWORD PTR _vecFTemp$37808[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40938[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCurForward$37822[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fadd	DWORD PTR _fForward$37811[ebp]
	fstp	DWORD PTR _fForward$37811[ebp]

; 1257 : 									vecFTemp = pCurForward->GetLocalOrigin();

	mov	ecx, DWORD PTR _pCurForward$37822[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecFTemp$37808[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecFTemp$37808[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecFTemp$37808[ebp+8], eax

; 1258 : 
; 1259 : 									// if we've finished tracing the forward line
; 1260 : 									if( pCurForward == m_pDestination )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pCurForward$37822[ebp]
	cmp	edx, DWORD PTR [ecx+1784]
	jne	SHORT $L37830

; 1262 : 										// if the backward line is longest
; 1263 : 										if( fBackward >= fForward || pCurBackward == NULL )

	fld	DWORD PTR _fBackward$37821[ebp]
	fcomp	DWORD PTR _fForward$37811[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37832
	cmp	DWORD PTR _pCurBackward$37823[ebp], 0
	jne	SHORT $L37831
$L37832:

; 1264 : 											iDir = DIRECTION_FORWARDS;

	mov	DWORD PTR _iDir$37801[ebp], 1
$L37831:

; 1266 : 									else

	jmp	SHORT $L37833
$L37830:

; 1268 : 										pCurForward = pCurForward->GetNextTarget();

	mov	eax, DWORD PTR _pCurForward$37822[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pCurForward$37822[ebp]
	call	DWORD PTR [edx+268]
	mov	DWORD PTR _pCurForward$37822[ebp], eax
$L37833:

; 1271 : 
; 1272 : 								if( pCurBackward )

	cmp	DWORD PTR _pCurBackward$37823[ebp], 0
	je	SHORT $L37839

; 1274 : 									fBackward += (pCurBackward->GetLocalOrigin() - vecBTemp).Length();

	lea	eax, DWORD PTR _vecBTemp$37809[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40939[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCurBackward$37823[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fadd	DWORD PTR _fBackward$37821[ebp]
	fstp	DWORD PTR _fBackward$37821[ebp]

; 1275 : 									vecBTemp = pCurBackward->GetLocalOrigin();

	mov	ecx, DWORD PTR _pCurBackward$37823[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecBTemp$37809[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecBTemp$37809[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecBTemp$37809[ebp+8], edx

; 1276 : 
; 1277 : 									// if we've finished tracng the backward line
; 1278 : 									if( pCurBackward == pTrainDest )

	mov	eax, DWORD PTR _pCurBackward$37823[ebp]
	cmp	eax, DWORD PTR _pTrainDest$37810[ebp]
	jne	SHORT $L37836

; 1280 : 										// if the forward line is shorter
; 1281 : 										if( fBackward < fForward || pCurForward == NULL )

	fld	DWORD PTR _fBackward$37821[ebp]
	fcomp	DWORD PTR _fForward$37811[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L37838
	cmp	DWORD PTR _pCurForward$37822[ebp], 0
	jne	SHORT $L37837
$L37838:

; 1282 : 											iDir = DIRECTION_BACKWARDS;

	mov	DWORD PTR _iDir$37801[ebp], 2
$L37837:

; 1284 : 									else

	jmp	SHORT $L37839
$L37836:

; 1286 : 										pCurBackward = pCurBackward->GetNextTarget();

	mov	ecx, DWORD PTR _pCurBackward$37823[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pCurBackward$37823[ebp]
	call	DWORD PTR [edx+268]
	mov	DWORD PTR _pCurBackward$37823[ebp], eax
$L37839:

; 1289 : 
; 1290 : 								if( --loopbreaker <= 0 )

	mov	eax, DWORD PTR _loopbreaker$37824[ebp]
	sub	eax, 1
	mov	DWORD PTR _loopbreaker$37824[ebp], eax
	cmp	DWORD PTR _loopbreaker$37824[ebp], 0
	jg	SHORT $L37840

; 1291 : 									iDir = DIRECTION_STOP;

	mov	DWORD PTR _iDir$37801[ebp], 3
$L37840:

; 1292 : 							}

	jmp	$L37826
$L37827:

; 1294 : 						else

	jmp	SHORT $L37841
$L37807:

; 1296 : 							iDir = DIRECTION_STOP;

	mov	DWORD PTR _iDir$37801[ebp], 3
$L37841:

; 1298 : 						break;

	jmp	SHORT $L37803
$L37842:

; 1299 : 					case DIRECTION_FORWARDS:
; 1300 : 						iDir = DIRECTION_FORWARDS;

	mov	DWORD PTR _iDir$37801[ebp], 1

; 1301 : 						break;

	jmp	SHORT $L37803
$L37843:

; 1302 : 					case DIRECTION_BACKWARDS:
; 1303 : 						iDir = DIRECTION_BACKWARDS;

	mov	DWORD PTR _iDir$37801[ebp], 2

; 1304 : 						break;

	jmp	SHORT $L37803
$L37844:

; 1305 : 					case DIRECTION_STOP:
; 1306 : 						iDir = DIRECTION_STOP;

	mov	DWORD PTR _iDir$37801[ebp], 3
$L37803:

; 1309 : 					
; 1310 : 					if( iDir == DIRECTION_BACKWARDS && !FBitSet( pTrain->pev->spawnflags, SF_TRAIN_REVERSE ))

	cmp	DWORD PTR _iDir$37801[ebp], 2
	jne	$L37845
	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	jne	$L37845

; 1312 : 						// change direction
; 1313 : 						SetBits( pTrain->pev->spawnflags, SF_TRAIN_REVERSE );

	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	or	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+416], eax

; 1314 : 
; 1315 : 						CBaseEntity *pSearch = m_pDestination;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1784]
	mov	DWORD PTR _pSearch$37846[ebp], ecx
$L37848:

; 1316 : 
; 1317 : 						while( pSearch )

	cmp	DWORD PTR _pSearch$37846[ebp], 0
	je	$L37849

; 1319 : 							if( FStrEq( pSearch->GetTarget(), pTrain->GetMessage()))

	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	call	?GetMessageA@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetMessageA
	push	eax
	mov	ecx, DWORD PTR _pSearch$37846[ebp]
	call	?GetTarget@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTarget
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37850

; 1321 : 								CBaseEntity *pTrainTarg = pSearch->GetNextTarget();

	mov	edx, DWORD PTR _pSearch$37846[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pSearch$37846[ebp]
	call	DWORD PTR [eax+268]
	mov	DWORD PTR _pTrainTarg$37851[ebp], eax

; 1322 : 								if( pTrainTarg )

	cmp	DWORD PTR _pTrainTarg$37851[ebp], 0
	je	SHORT $L37852

; 1323 : 									pTrain->pev->enemy = pTrainTarg->edict();

	mov	ecx, DWORD PTR _pTrainTarg$37851[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+400], eax

; 1324 : 								else pTrain->pev->enemy = NULL;

	jmp	SHORT $L37853
$L37852:
	mov	eax, DWORD PTR _pTrain$37796[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+400], 0
$L37853:

; 1325 : 
; 1326 : 								pTrain->pev->target = pSearch->pev->targetname;

	mov	edx, DWORD PTR _pSearch$37846[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+460]
	mov	DWORD PTR [edx+456], eax

; 1327 : 								break;

	jmp	SHORT $L37849
$L37850:

; 1329 : 
; 1330 : 							pSearch = pSearch->GetNextTarget();

	mov	ecx, DWORD PTR _pSearch$37846[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pSearch$37846[ebp]
	call	DWORD PTR [edx+268]
	mov	DWORD PTR _pSearch$37846[ebp], eax

; 1331 : 						}

	jmp	$L37848
$L37849:

; 1332 : 
; 1333 : 						if( !pSearch )

	cmp	DWORD PTR _pSearch$37846[ebp], 0
	jne	SHORT $L37854

; 1335 : 							// this shouldn't happen.
; 1336 : 							ALERT(at_error, "Found no path to reach destination! (train has t %s, m %s; dest is %s)\n",
; 1337 : 							pTrain->GetTarget(), pTrain->GetMessage(), m_pDestination->GetTargetname( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1784]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	call	?GetMessageA@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetMessageA
	push	eax
	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	call	?GetTarget@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTarget
	push	eax
	push	OFFSET FLAT:??_C@_0EI@PICH@Found?5no?5path?5to?5reach?5destinati@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H

; 1338 : 							return;

	jmp	$L37784
$L37854:

; 1340 : 
; 1341 : 						// we haven't reached the corner, so don't use its settings
; 1342 : 						pTrain->m_hCurrentTarget = NULL;

	push	0
	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	add	ecx, 1976				; 000007b8H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1343 : 						pTrain->Next();

	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	call	?Next@CFuncTrain@@QAEXXZ		; CFuncTrain::Next

; 1345 : 					else if( iDir == DIRECTION_FORWARDS )

	jmp	SHORT $L37858
$L37845:
	cmp	DWORD PTR _iDir$37801[ebp], 1
	jne	SHORT $L37856

; 1347 : 						pTrain->pev->target = pTrain->pev->message;

	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pTrain$37796[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+468]
	mov	DWORD PTR [ecx+456], edx

; 1348 : 						pTrain->Next();

	mov	ecx, DWORD PTR _pTrain$37796[ebp]
	call	?Next@CFuncTrain@@QAEXXZ		; CFuncTrain::Next

; 1350 : 					else if( iDir == DIRECTION_STOP )

	jmp	SHORT $L37858
$L37856:
	cmp	DWORD PTR _iDir$37801[ebp], 3
	jne	SHORT $L37858

; 1352 : 						SetThink( EndThink );

	push	OFFSET FLAT:??_C@_08LGNC@EndThink?$AA@	; `string'
	push	OFFSET FLAT:?EndThink@CTrainSequence@@QAEXXZ ; CTrainSequence::EndThink
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1353 : 						SetNextThink( 0.1f );

	push	1036831949				; 3dcccccdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 1354 : 						return;

	jmp	SHORT $L37784
$L37858:

; 1358 : 			else

	jmp	SHORT $L37861
$L37795:

; 1360 : 				ALERT( at_error, "scripted_trainsequence %s can't affect %s \"%s\": not a train!\n", GetTargetname(), pEnt->GetClassname(), pEnt->GetTargetname( ));

	mov	ecx, DWORD PTR _pEnt$37787[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	mov	ecx, DWORD PTR _pEnt$37787[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	push	OFFSET FLAT:??_C@_0DO@EJNJ@scripted_trainsequence?5?$CFs?5can?8t?5@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H

; 1361 : 				return;

	jmp	SHORT $L37784
$L37861:

; 1364 : 		else // no entity with that name

	jmp	SHORT $L37863
$L37788:

; 1366 : 			ALERT(at_error, "Missing train \"%s\" for scripted_trainsequence %s!\n", STRING( m_iszEntity ), GetTargetname( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1764]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0DD@HMAL@Missing?5train?5?$CC?$CFs?$CC?5for?5scripted_@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 1367 : 			return;

	jmp	SHORT $L37784
$L37863:

; 1370 : 	else // prematurely end the sequence

	jmp	SHORT $L37865
$L37786:

; 1372 : 		// disable the other end conditions
; 1373 : 		DontThink();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DontThink@CBaseEntity@@QAEXXZ		; CBaseEntity::DontThink

; 1374 : 
; 1375 : 		// release control of the train
; 1376 : 		StopSequence();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopSequence@CTrainSequence@@QAEXXZ	; CTrainSequence::StopSequence
$L37865:
$L37784:

; 1378 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L40940:
	DD	$L37842
	DD	$L37843
	DD	$L37844
	DD	$L37806
?Use@CTrainSequence@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CTrainSequence::Use
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
EXTRN	_sqrt:NEAR
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
;	COMDAT ?GetMessageA@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetMessageA@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetMessageA, COMDAT

; 286  : 	const char*	GetMessage() { return STRING( pev->message ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMessageA@CBaseEntity@@QAEPBDXZ ENDP			; CBaseEntity::GetMessageA
_TEXT	ENDS
PUBLIC	??_C@_0DI@CFIL@scripted_trainsequence?3?5StopSequ@ ; `string'
EXTRN	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_Remove
;	COMDAT ??_C@_0DI@CFIL@scripted_trainsequence?3?5StopSequ@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0DI@CFIL@scripted_trainsequence?3?5StopSequ@ DB 'scripted_trainsequ'
	DB	'ence: StopSequence without a train!?', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?StopSequence@CTrainSequence@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSequence@CTrainSequence@@QAEXXZ PROC NEAR		; CTrainSequence::StopSequence, COMDAT

; 1381 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1382 : 	if( m_pTrain )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1780], 0
	je	SHORT $L37870

; 1384 : 		m_pTrain->StopSequence();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1780]
	call	?StopSequence@CFuncTrain@@QAEXXZ	; CFuncTrain::StopSequence

; 1385 : 		m_pTrain = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1780], 0

; 1386 : 
; 1387 : 		if( FBitSet( pev->spawnflags, SF_TRAINSEQ_REMOVE ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 2
	test	edx, edx
	je	SHORT $L37871

; 1388 : 			UTIL_Remove( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4
$L37871:

; 1390 : 	else

	jmp	SHORT $L37872
$L37870:

; 1392 : 		ALERT( at_error, "scripted_trainsequence: StopSequence without a train!?\n" );

	push	OFFSET FLAT:??_C@_0DI@CFIL@scripted_trainsequence?3?5StopSequ@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1393 : 		return; // this shouldn't happen.

	jmp	SHORT $L37869
$L37872:

; 1395 : 
; 1396 : 	UTIL_FireTargets( STRING( m_iszTerminate ), this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1772]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L37869:

; 1397 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSequence@CTrainSequence@@QAEXXZ ENDP		; CTrainSequence::StopSequence
_TEXT	ENDS
PUBLIC	??_C@_0DJ@LBCA@scripted_trainsequence?3?5ArrivalN@ ; `string'
;	COMDAT ??_C@_0DJ@LBCA@scripted_trainsequence?3?5ArrivalN@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0DJ@LBCA@scripted_trainsequence?3?5ArrivalN@ DB 'scripted_trainsequ'
	DB	'ence: ArrivalNotify without a train!?', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?ArrivalNotify@CTrainSequence@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ArrivalNotify@CTrainSequence@@QAEXXZ PROC NEAR		; CTrainSequence::ArrivalNotify, COMDAT

; 1400 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1401 : 	// check whether the current path is our destination,
; 1402 : 	// and end the sequence if it is.
; 1403 : 
; 1404 : 	if( m_pTrain )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1780], 0
	je	SHORT $L37878

; 1406 : 		if( m_pTrain->m_hCurrentTarget == m_pDestination )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1780]
	add	ecx, 1976				; 000007b8H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	edx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [edx+1784]
	jne	SHORT $L37879

; 1408 : 			// we've reached the destination. Stop now.
; 1409 : 			EndThink();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EndThink@CTrainSequence@@QAEXXZ	; CTrainSequence::EndThink
$L37879:

; 1412 : 	else

	jmp	SHORT $L37880
$L37878:

; 1414 : 		ALERT( at_error, "scripted_trainsequence: ArrivalNotify without a train!?\n" );

	push	OFFSET FLAT:??_C@_0DJ@LBCA@scripted_trainsequence?3?5ArrivalN@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L37880:

; 1417 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ArrivalNotify@CTrainSequence@@QAEXXZ ENDP		; CTrainSequence::ArrivalNotify
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CFuncTrackTrain@@UAEPAUdatamap_s@@XZ ; CFuncTrackTrain::GetDataDescMap
;	COMDAT ?GetDataDescMap@CFuncTrackTrain@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CFuncTrackTrain@@UAEPAUdatamap_s@@XZ PROC NEAR ; CFuncTrackTrain::GetDataDescMap, COMDAT

; 1425 : BEGIN_DATADESC( CFuncTrackTrain )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTrackTrain@@2Udatamap_s@@A ; CFuncTrackTrain::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CFuncTrackTrain@@UAEPAUdatamap_s@@XZ ENDP ; CFuncTrackTrain::GetDataDescMap
_TEXT	ENDS
PUBLIC	?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ; DataMapAccess
PUBLIC	?GetBaseMap@CFuncTrackTrain@@SAPAUdatamap_s@@XZ	; CFuncTrackTrain::GetBaseMap
;	COMDAT ?GetBaseMap@CFuncTrackTrain@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CFuncTrackTrain@@SAPAUdatamap_s@@XZ PROC NEAR ; CFuncTrackTrain::GetBaseMap, COMDAT

; 1425 : BEGIN_DATADESC( CFuncTrackTrain )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CFuncTrackTrain@@SAPAUdatamap_s@@XZ ENDP	; CFuncTrackTrain::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E68
_TEXT	SEGMENT
_$E68	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E67
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E68	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z ; DataMapInit
;	COMDAT _$E67
_TEXT	SEGMENT
_$E67	PROC NEAR					; COMDAT

; 1425 : BEGIN_DATADESC( CFuncTrackTrain )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CFuncTrackTrain_DataDescInit@@3PAUdatamap_s@@A, eax ; CFuncTrackTrain_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E67	ENDP
_TEXT	ENDS
PUBLIC	??_C@_04GOJF@Find?$AA@				; `string'
PUBLIC	??_C@_0M@BJFE@NearestPath?$AA@			; `string'
PUBLIC	??_C@_07LJIB@DeadEnd?$AA@			; `string'
PUBLIC	?Next@CFuncTrackTrain@@QAEXXZ			; CFuncTrackTrain::Next
PUBLIC	?Find@CFuncTrackTrain@@QAEXXZ			; CFuncTrackTrain::Find
PUBLIC	?NearestPath@CFuncTrackTrain@@QAEXXZ		; CFuncTrackTrain::NearestPath
PUBLIC	?DeadEnd@CFuncTrackTrain@@QAEXXZ		; CFuncTrackTrain::DeadEnd
_BSS	SEGMENT
	ALIGN	4

_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S70@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04GOJF@Find?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_04GOJF@Find?$AA@ DB 'Find', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BJFE@NearestPath?$AA@
CONST	SEGMENT
??_C@_0M@BJFE@NearestPath?$AA@ DB 'NearestPath', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LJIB@DeadEnd?$AA@
CONST	SEGMENT
??_C@_07LJIB@DeadEnd?$AA@ DB 'DeadEnd', 00H		; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z PROC NEAR ; DataMapInit, COMDAT

; 1425 : BEGIN_DATADESC( CFuncTrackTrain )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S70@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L37921
	mov	cl, BYTE PTR _?$S70@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S70@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0BA@PNOC@CFuncTrackTrain?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E71
	call	_atexit
	add	esp, 4
$L37921:
	call	?GetBaseMap@CFuncTrackTrain@@SAPAUdatamap_s@@XZ ; CFuncTrackTrain::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CFuncTrackTrain@@2Udatamap_s@@A+12, eax

; 1426 : 	DEFINE_FIELD( m_ppath, FIELD_CLASSPTR ),
; 1427 : 	DEFINE_FIELD( m_pDoor, FIELD_CLASSPTR ),
; 1428 : 	DEFINE_FIELD( m_pSpeedControl, FIELD_CLASSPTR ),
; 1429 : 	DEFINE_KEYFIELD( m_length, FIELD_FLOAT, "wheels" ),
; 1430 : 	DEFINE_KEYFIELD( m_height, FIELD_FLOAT, "height" ),
; 1431 : 	DEFINE_KEYFIELD( m_startSpeed, FIELD_FLOAT, "startspeed" ),
; 1432 : 	DEFINE_FIELD( m_controlMins, FIELD_VECTOR ),
; 1433 : 	DEFINE_FIELD( m_controlMaxs, FIELD_VECTOR ),
; 1434 : 	DEFINE_FIELD( m_controlOrigin, FIELD_POSITION_VECTOR ),
; 1435 : 	DEFINE_KEYFIELD( m_sounds, FIELD_STRING, "sounds" ),
; 1436 : 	DEFINE_KEYFIELD( m_soundStart, FIELD_STRING, "soundstart" ),
; 1437 : 	DEFINE_KEYFIELD( m_soundStop, FIELD_STRING, "soundstop" ),
; 1438 : 	DEFINE_KEYFIELD( m_eVelocityType, FIELD_INTEGER, "acceltype" ),
; 1439 : 	DEFINE_KEYFIELD( m_eOrientationType, FIELD_INTEGER, "orientation" ),
; 1440 : 	DEFINE_FIELD( m_flVolume, FIELD_FLOAT ),
; 1441 : 	DEFINE_KEYFIELD( m_flBank, FIELD_FLOAT, "bank" ),
; 1442 : 	DEFINE_FIELD( m_flDesiredSpeed, FIELD_FLOAT ),
; 1443 : 	DEFINE_FIELD( m_flAccelSpeed, FIELD_FLOAT ),
; 1444 : 	DEFINE_FIELD( m_flReachedDist, FIELD_FLOAT ),
; 1445 : 	DEFINE_FIELD( m_oldSpeed, FIELD_FLOAT ),
; 1446 : 	DEFINE_FIELD( m_maxSpeed, FIELD_FLOAT ),
; 1447 : 	DEFINE_FIELD( m_dir, FIELD_FLOAT ),
; 1448 : 	DEFINE_FUNCTION( Next ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S70@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L37999
	mov	al, BYTE PTR _?$S70@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S70@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_04CIMM@Next?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+556, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+560, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+564, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+566, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+568, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+572, OFFSET FLAT:?Next@CFuncTrackTrain@@QAEXXZ ; CFuncTrackTrain::Next

; 1449 : 	DEFINE_FUNCTION( Find ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+576, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_04GOJF@Find?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+580, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+584, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+588, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+590, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+592, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+596, OFFSET FLAT:?Find@CFuncTrackTrain@@QAEXXZ ; CFuncTrackTrain::Find

; 1450 : 	DEFINE_FUNCTION( NearestPath ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+600, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0M@BJFE@NearestPath?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+604, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+608, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+612, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+614, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+616, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+620, OFFSET FLAT:?NearestPath@CFuncTrackTrain@@QAEXXZ ; CFuncTrackTrain::NearestPath

; 1451 : 	DEFINE_FUNCTION( DeadEnd ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+624, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_07LJIB@DeadEnd?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+628, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+632, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+636, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+638, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+640, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+644, OFFSET FLAT:?DeadEnd@CFuncTrackTrain@@QAEXXZ ; CFuncTrackTrain::DeadEnd
$L37999:

; 1452 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L38011
	mov	DWORD PTR ?m_DataMap@CFuncTrackTrain@@2Udatamap_s@@A+4, 26 ; 0000001aH
	mov	DWORD PTR ?m_DataMap@CFuncTrackTrain@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L38012
$L38011:
	mov	DWORD PTR ?m_DataMap@CFuncTrackTrain@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncTrackTrain@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4PAUtypedescription_s@@A
$L38012:
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTrackTrain@@2Udatamap_s@@A ; CFuncTrackTrain::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z ENDP ; DataMapInit
_TEXT	ENDS
;	COMDAT _$E71
_TEXT	SEGMENT
_$E71	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackTrain@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E71	ENDP
_TEXT	ENDS
;	COMDAT _$E73
_TEXT	SEGMENT
_$E73	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E72
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E73	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncTrackTrain@@@@QAE@PBD@Z ; CEntityFactory<CFuncTrackTrain>::CEntityFactory<CFuncTrackTrain>
PUBLIC	??_C@_0BA@KOLE@func_tracktrain?$AA@		; `string'
_BSS	SEGMENT
	ALIGN	4

_func_tracktrain DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BA@KOLE@func_tracktrain?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BA@KOLE@func_tracktrain?$AA@ DB 'func_tracktrain', 00H ; `string'
CONST	ENDS
;	COMDAT _$E72
_TEXT	SEGMENT
_$E72	PROC NEAR					; COMDAT

; 1454 : LINK_ENTITY_TO_CLASS( func_tracktrain, CFuncTrackTrain );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BA@KOLE@func_tracktrain?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_tracktrain
	call	??0?$CEntityFactory@VCFuncTrackTrain@@@@QAE@PBD@Z ; CEntityFactory<CFuncTrackTrain>::CEntityFactory<CFuncTrackTrain>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E72	ENDP
_TEXT	ENDS
PUBLIC	?EarPosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EarPosition
PUBLIC	?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z	; CBaseEntity::BodyTarget
PUBLIC	?IsPointSized@CBaseEntity@@UBEHXZ		; CBaseEntity::IsPointSized
PUBLIC	?Illumination@CBaseEntity@@UAEHXZ		; CBaseEntity::Illumination
PUBLIC	?Init@Vector@@QAEXMMM@Z				; Vector::Init
PUBLIC	??0CBaseDelay@@QAE@XZ				; CBaseDelay::CBaseDelay
PUBLIC	??1CBaseDelay@@QAE@XZ				; CBaseDelay::~CBaseDelay
PUBLIC	??0CFuncTrackTrain@@QAE@XZ			; CFuncTrackTrain::CFuncTrackTrain
PUBLIC	?Spawn@CFuncTrackTrain@@UAEXXZ			; CFuncTrackTrain::Spawn
PUBLIC	?Precache@CFuncTrackTrain@@UAEXXZ		; CFuncTrackTrain::Precache
PUBLIC	?Blocked@CFuncTrackTrain@@UAEXPAVCBaseEntity@@@Z ; CFuncTrackTrain::Blocked
PUBLIC	?Use@CFuncTrackTrain@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncTrackTrain::Use
PUBLIC	?KeyValue@CFuncTrackTrain@@UAEXPAUKeyValueData_s@@@Z ; CFuncTrackTrain::KeyValue
PUBLIC	?OnControls@CFuncTrackTrain@@UAEHPAVCBaseEntity@@@Z ; CFuncTrackTrain::OnControls
PUBLIC	?GetState@CFuncTrackTrain@@UAE?AW4STATE@@XZ	; CFuncTrackTrain::GetState
PUBLIC	?ObjectCaps@CFuncTrackTrain@@UAEHXZ		; CFuncTrackTrain::ObjectCaps
PUBLIC	?OverrideReset@CFuncTrackTrain@@UAEXXZ		; CFuncTrackTrain::OverrideReset
PUBLIC	??_7CFuncTrackTrain@@6B@			; CFuncTrackTrain::`vftable'
PUBLIC	?Activate@CBaseEntity@@UAEXXZ			; CBaseEntity::Activate
PUBLIC	?OnChangeLevel@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeLevel
PUBLIC	?OnTeleport@CBaseEntity@@UAEXXZ			; CBaseEntity::OnTeleport
PUBLIC	?PortalSleep@CBaseEntity@@UAEXM@Z		; CBaseEntity::PortalSleep
PUBLIC	?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ; CBaseEntity::StartMessage
PUBLIC	?GetPosition@CBaseEntity@@UAEMXZ		; CBaseEntity::GetPosition
PUBLIC	?OnChangeParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeParent
PUBLIC	?OnClearParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnClearParent
PUBLIC	?OnRemove@CBaseEntity@@UAEXXZ			; CBaseEntity::OnRemove
PUBLIC	?Classify@CBaseEntity@@UAEHXZ			; CBaseEntity::Classify
PUBLIC	?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z	; CBaseEntity::DeathNotice
PUBLIC	?IsRigidBody@CBaseEntity@@UAEHXZ		; CBaseEntity::IsRigidBody
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z	; CBaseEntity::GetState
PUBLIC	?BloodColor@CBaseEntity@@UAEHXZ			; CBaseEntity::BloodColor
PUBLIC	?IsTriggered@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::IsTriggered
PUBLIC	?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ; CBaseEntity::MyMonsterPointer
PUBLIC	?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ; CBaseEntity::MySquadMonsterPointer
PUBLIC	?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ	; CBaseEntity::GetVehicleDriver
PUBLIC	?GetToggleState@CBaseEntity@@UAEHXZ		; CBaseEntity::GetToggleState
PUBLIC	?AddPoints@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPoints
PUBLIC	?AddPointsToTeam@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPointsToTeam
PUBLIC	?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::AddPlayerItem
PUBLIC	?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::RemovePlayerItem
PUBLIC	?GiveAmmo@CBaseEntity@@UAEHHPADH@Z		; CBaseEntity::GiveAmmo
PUBLIC	?GetDelay@CBaseEntity@@UAEMXZ			; CBaseEntity::GetDelay
PUBLIC	?IsMoving@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMoving
PUBLIC	?TransferReset@CBaseEntity@@UAEXXZ		; CBaseEntity::TransferReset
PUBLIC	?SetToggleState@CBaseEntity@@UAEXH@Z		; CBaseEntity::SetToggleState
PUBLIC	?StartSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StartSneaking
PUBLIC	?StopSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StopSneaking
PUBLIC	?IsSneaking@CBaseEntity@@UAEHXZ			; CBaseEntity::IsSneaking
PUBLIC	?IsAlive@CBaseEntity@@UAEHXZ			; CBaseEntity::IsAlive
PUBLIC	?IsBSPModel@CBaseEntity@@UAEHXZ			; CBaseEntity::IsBSPModel
PUBLIC	?IsCustomModel@CBaseEntity@@UAEHXZ		; CBaseEntity::IsCustomModel
PUBLIC	?ReflectGauss@CBaseEntity@@UAEHXZ		; CBaseEntity::ReflectGauss
PUBLIC	?HasTarget@CBaseEntity@@UAEHH@Z			; CBaseEntity::HasTarget
PUBLIC	?IsPlayer@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPlayer
PUBLIC	?IsNetClient@CBaseEntity@@UAEHXZ		; CBaseEntity::IsNetClient
PUBLIC	?IsMonster@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMonster
PUBLIC	?IsPushable@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPushable
PUBLIC	?IsProjectile@CBaseEntity@@UAEHXZ		; CBaseEntity::IsProjectile
PUBLIC	?IsFuncScreen@CBaseEntity@@UAEHXZ		; CBaseEntity::IsFuncScreen
PUBLIC	?IsPortal@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPortal
PUBLIC	?IsTank@CBaseEntity@@UAEHXZ			; CBaseEntity::IsTank
PUBLIC	?IsMover@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMover
PUBLIC	?IsBreakable@CBaseEntity@@UAEHXZ		; CBaseEntity::IsBreakable
PUBLIC	?TeamID@CBaseEntity@@UAEPBDXZ			; CBaseEntity::TeamID
PUBLIC	?Think@CBaseEntity@@UAEXXZ			; CBaseEntity::Think
PUBLIC	?Touch@CBaseEntity@@UAEXPAV1@@Z			; CBaseEntity::Touch
PUBLIC	?MoveDone@CBaseEntity@@UAEXXZ			; CBaseEntity::MoveDone
PUBLIC	?Respawn@CBaseEntity@@UAEPAV1@XZ		; CBaseEntity::Respawn
PUBLIC	?UpdateOwner@CBaseEntity@@UAEXXZ		; CBaseEntity::UpdateOwner
PUBLIC	?FBecomeProne@CBaseEntity@@UAEHXZ		; CBaseEntity::FBecomeProne
PUBLIC	?Center@CBaseEntity@@UAE?AVVector@@XZ		; CBaseEntity::Center
PUBLIC	?EyePosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EyePosition
EXTRN	?FVisible@CBaseEntity@@UAEHPAV1@@Z:NEAR		; CBaseEntity::FVisible
EXTRN	?FVisible@CBaseEntity@@UAEHABVVector@@@Z:NEAR	; CBaseEntity::FVisible
EXTRN	?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z:NEAR	; CBaseEntity::ShouldCollide
EXTRN	?Save@CBaseEntity@@UAEHAAVCSave@@@Z:NEAR	; CBaseEntity::Save
EXTRN	?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z:NEAR	; CBaseEntity::Restore
EXTRN	?SetObjectCollisionBox@CBaseEntity@@UAEXXZ:NEAR	; CBaseEntity::SetObjectCollisionBox
EXTRN	?SetNextThink@CBaseEntity@@UAEXM@Z:NEAR		; CBaseEntity::SetNextThink
EXTRN	?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceAttack
EXTRN	?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseEntity::TakeDamage
EXTRN	?TakeHealth@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeHealth
EXTRN	?TakeArmor@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeArmor
EXTRN	?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z:NEAR	; CBaseEntity::Killed
EXTRN	?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceBleed
EXTRN	?DamageDecal@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::DamageDecal
EXTRN	?IsInWorld@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::IsInWorld
EXTRN	?GetNextTarget@CBaseEntity@@UAEPAV1@XZ:NEAR	; CBaseEntity::GetNextTarget
;	COMDAT ??_7CFuncTrackTrain@@6B@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_7CFuncTrackTrain@@6B@ DD FLAT:?GetDataDescMap@CFuncTrackTrain@@UAEPAUdatamap_s@@XZ ; CFuncTrackTrain::`vftable'
	DD	FLAT:?Spawn@CFuncTrackTrain@@UAEXXZ
	DD	FLAT:?Precache@CFuncTrackTrain@@UAEXXZ
	DD	FLAT:?KeyValue@CFuncTrackTrain@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncTrackTrain@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CFuncTrackTrain@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CFuncTrackTrain@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CFuncTrackTrain@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CFuncTrackTrain@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CFuncTrackTrain@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CFuncTrackTrain@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CFuncTrackTrain@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CFuncTrackTrain@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CFuncTrackTrain@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CFuncTrackTrain@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0CFuncTrackTrain@@QAE@XZ PROC NEAR			; CFuncTrackTrain::CFuncTrackTrain, COMDAT

; 1460 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CFuncTrackTrain@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1820				; 0000071cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1832				; 00000728H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1844				; 00000734H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncTrackTrain@@6B@ ; CFuncTrackTrain::`vftable'

; 1461 : #ifdef _DEBUG
; 1462 : 	m_controlMins.Init();

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1820				; 0000071cH
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init

; 1463 : 	m_controlMaxs.Init();

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1832				; 00000728H
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init

; 1464 : #endif
; 1465 : 	// These defaults match old func_tracktrains. Changing these defaults would
; 1466 : 	// require a vmf_tweak of older content to keep it from breaking.
; 1467 : 	m_eOrientationType = TrainOrientation_AtPathTracks;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1888], 1

; 1468 : 	m_eVelocityType = TrainVelocity_EaseInEaseOut;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1892], 2

; 1469 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CFuncTrackTrain@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseDelay@@QAE@XZ			; CBaseDelay::~CBaseDelay
	ret	0
__ehhandler$??0CFuncTrackTrain@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CFuncTrackTrain@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CFuncTrackTrain@@QAE@XZ ENDP				; CFuncTrackTrain::CFuncTrackTrain
;	COMDAT ?Init@Vector@@QAEXMMM@Z
_TEXT	SEGMENT
_ix$ = 8
_iy$ = 12
_iz$ = 16
_this$ = -4
?Init@Vector@@QAEXMMM@Z PROC NEAR			; Vector::Init, COMDAT

; 143  : 	void Init(float ix=0.0f, float iy=0.0f, float iz=0.0f){ x = ix; y = iy; z = iz; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ix$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iy$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iz$[ebp]
	mov	DWORD PTR [ecx+8], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Init@Vector@@QAEXMMM@Z ENDP				; Vector::Init
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Activate@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Activate, COMDAT

; 365  : 	virtual void	Activate( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Activate
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeLevel@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeLevel, COMDAT

; 366  : 	virtual void	OnChangeLevel( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeLevel@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnChangeLevel
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnTeleport@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnTeleport, COMDAT

; 367  : 	virtual void	OnTeleport( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnTeleport@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnTeleport
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4
?PortalSleep@CBaseEntity@@UAEXM@Z PROC NEAR		; CBaseEntity::PortalSleep, COMDAT

; 368  : 	virtual void	PortalSleep( float seconds ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PortalSleep@CBaseEntity@@UAEXM@Z ENDP			; CBaseEntity::PortalSleep
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CBaseEntity::StartMessage, COMDAT

; 369  :           virtual void	StartMessage( CBasePlayer *pPlayer ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ENDP	; CBaseEntity::StartMessage
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetPosition@CBaseEntity@@UAEMXZ PROC NEAR		; CBaseEntity::GetPosition, COMDAT

; 370  : 	virtual float	GetPosition( void ) { return 0.0f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPosition@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetPosition
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeParent, COMDAT

; 371  : 	virtual void	OnChangeParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CBaseEntity@@UAEXXZ ENDP		; CBaseEntity::OnChangeParent
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnClearParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnClearParent, COMDAT

; 372  : 	virtual void	OnClearParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnClearParent
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnRemove@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::OnRemove, COMDAT

; 373  : 	virtual void	OnRemove( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnRemove@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnRemove
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::Classify, COMDAT

; 385  : 	virtual int Classify ( void ) { return CLASS_NONE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Classify
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z PROC NEAR ; CBaseEntity::DeathNotice, COMDAT

; 386  : 	virtual void DeathNotice ( entvars_t *pevChild ) { } // monster maker children use this to tell the monster maker that they have died.

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z ENDP	; CBaseEntity::DeathNotice
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsRigidBody@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsRigidBody, COMDAT

; 387  : 	virtual BOOL IsRigidBody( void ) { return (m_iActorType == ACTOR_DYNAMIC); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	mov	eax, ecx
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsRigidBody@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsRigidBody
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z PROC NEAR	; CBaseEntity::GetState, COMDAT

; 401  : 	virtual STATE GetState ( CBaseEntity* pEnt ) { return GetState(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z ENDP	; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::BloodColor, COMDAT

; 408  : 	virtual int	BloodColor( void ) { return DONT_BLEED; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::BloodColor
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::IsTriggered, COMDAT

; 410  : 	virtual BOOL	IsTriggered( CBaseEntity *pActivator ) {return TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::IsTriggered
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ PROC NEAR ; CBaseEntity::MyMonsterPointer, COMDAT

; 411  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ENDP ; CBaseEntity::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ PROC NEAR ; CBaseEntity::MySquadMonsterPointer, COMDAT

; 412  : 	virtual CSquadMonster *MySquadMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ENDP ; CBaseEntity::MySquadMonsterPointer
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ PROC NEAR	; CBaseEntity::GetVehicleDriver, COMDAT

; 413  : 	virtual CBaseEntity *GetVehicleDriver( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ ENDP		; CBaseEntity::GetVehicleDriver
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::GetToggleState, COMDAT

; 414  : 	virtual int	GetToggleState( void ) { return TS_AT_TOP; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseEntity@@UAEHXZ ENDP		; CBaseEntity::GetToggleState
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPoints@CBaseEntity@@UAEXHH@Z PROC NEAR		; CBaseEntity::AddPoints, COMDAT

; 415  : 	virtual void	AddPoints( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPoints@CBaseEntity@@UAEXHH@Z ENDP			; CBaseEntity::AddPoints
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z PROC NEAR	; CBaseEntity::AddPointsToTeam, COMDAT

; 416  : 	virtual void	AddPointsToTeam( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z ENDP		; CBaseEntity::AddPointsToTeam
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::AddPlayerItem, COMDAT

; 417  : 	virtual BOOL	AddPlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::AddPlayerItem
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::RemovePlayerItem, COMDAT

; 418  : 	virtual BOOL	RemovePlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::RemovePlayerItem
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT
_this$ = -4
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z PROC NEAR		; CBaseEntity::GiveAmmo, COMDAT

; 419  : 	virtual int 	GiveAmmo( int iAmount, char *szName, int iMax ) { return -1; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z ENDP			; CBaseEntity::GiveAmmo
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseEntity@@UAEMXZ PROC NEAR			; CBaseEntity::GetDelay, COMDAT

; 420  : 	virtual float	GetDelay( void ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetDelay
_TEXT	ENDS
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMoving, COMDAT

; 421  : 	virtual int	IsMoving( void ) { return GetAbsVelocity() != g_vecZero; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMoving
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TransferReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::TransferReset, COMDAT

; 423  : 	virtual void	TransferReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransferReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::TransferReset
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?SetToggleState@CBaseEntity@@UAEXH@Z PROC NEAR		; CBaseEntity::SetToggleState, COMDAT

; 426  : 	virtual void	SetToggleState( int state ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetToggleState@CBaseEntity@@UAEXH@Z ENDP		; CBaseEntity::SetToggleState
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StartSneaking, COMDAT

; 427  : 	virtual void	StartSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StartSneaking
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StopSneaking, COMDAT

; 428  : 	virtual void	StopSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StopSneaking
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSneaking@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsSneaking, COMDAT

; 430  : 	virtual BOOL	IsSneaking( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSneaking@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsSneaking
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsAlive, COMDAT

; 431  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	jne	SHORT $L41042
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41042
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41043
$L41042:
	mov	DWORD PTR -8+[ebp], 0
$L41043:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsAlive
_TEXT	ENDS
EXTRN	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z:NEAR	; UTIL_GetModelType
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBSPModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBSPModel, COMDAT

; 432  : 	virtual BOOL	IsBSPModel( void ) { return UTIL_GetModelType( pev->modelindex ) == mod_brush; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBSPModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBSPModel
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsCustomModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsCustomModel, COMDAT

; 433  : 	virtual BOOL	IsCustomModel( void ) { return pev->solid == SOLID_CUSTOM; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+268], 5
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCustomModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsCustomModel
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ReflectGauss@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ReflectGauss, COMDAT

; 434  : 	virtual BOOL	ReflectGauss( void ) { return (( IsBSPModel() || IsCustomModel()) && !pev->takedamage ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	test	eax, eax
	jne	SHORT $L41050
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+208]
	test	eax, eax
	je	SHORT $L41051
$L41050:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41051
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41052
$L41051:
	mov	DWORD PTR -8+[ebp], 0
$L41052:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReflectGauss@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ReflectGauss
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_targetname$ = 8
?HasTarget@CBaseEntity@@UAEHH@Z PROC NEAR		; CBaseEntity::HasTarget, COMDAT

; 435  : 	virtual BOOL	HasTarget( string_t targetname ) { return FStrEq(STRING(targetname), STRING(pev->targetname) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _targetname$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasTarget@CBaseEntity@@UAEHH@Z ENDP			; CBaseEntity::HasTarget
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPlayer@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPlayer, COMDAT

; 437  : 	virtual BOOL	IsPlayer( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPlayer
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsNetClient@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsNetClient, COMDAT

; 438  : 	virtual BOOL	IsNetClient( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetClient@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsNetClient
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMonster@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsMonster, COMDAT

; 439  : 	virtual BOOL	IsMonster( void ) { return (pev->flags & FL_MONSTER ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+420]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMonster@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMonster
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPushable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsPushable, COMDAT

; 440  : 	virtual BOOL	IsPushable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPushable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPushable
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsProjectile@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsProjectile, COMDAT

; 441  : 	virtual BOOL	IsProjectile( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsProjectile@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsProjectile
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsFuncScreen@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsFuncScreen, COMDAT

; 442  : 	virtual BOOL	IsFuncScreen( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFuncScreen@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsFuncScreen
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPortal@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPortal, COMDAT

; 443  : 	virtual BOOL	IsPortal( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPortal@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPortal
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTank@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsTank, COMDAT

; 444  : 	virtual BOOL	IsTank( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTank@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsTank
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMover@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMover, COMDAT

; 445  : 	virtual BOOL	IsMover( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMover
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBreakable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBreakable, COMDAT

; 446  : 	virtual BOOL	IsBreakable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBreakable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBreakable
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?TeamID@CBaseEntity@@UAEPBDXZ PROC NEAR			; CBaseEntity::TeamID, COMDAT

; 447  : 	virtual const char	*TeamID( void ) { return ""; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TeamID@CBaseEntity@@UAEPBDXZ ENDP			; CBaseEntity::TeamID
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Think@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Think, COMDAT

; 458  : 	virtual void Think( void ) { if (m_pfnThink) (this->*m_pfnThink)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1744], 0
	je	SHORT $L35006
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1744]
$L35006:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Think
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Touch@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Touch, COMDAT

; 466  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 		if( m_pfnTouch )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1748], 0
	je	SHORT $L35012

; 468  : 			(this->*m_pfnTouch)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1748]
$L35012:

; 469  : 
; 470  : 		// forward the blocked event to our parent, if any.
; 471  : 		if( m_hParent != NULL && !m_isChaining )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35013
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1628]
	test	ecx, ecx
	jne	SHORT $L35013

; 472  : 			m_hParent->Touch( pOther );

	mov	edx, DWORD PTR _pOther$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+280]
$L35013:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Touch
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MoveDone@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::MoveDone, COMDAT

; 485  : 	virtual void MoveDone( void ) { if( m_pfnMoveDone )(this->*m_pfnMoveDone)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1760], 0
	je	SHORT $L35020
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1760]
$L35020:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveDone@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::MoveDone
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?Respawn@CBaseEntity@@UAEPAV1@XZ PROC NEAR		; CBaseEntity::Respawn, COMDAT

; 513  : 	virtual CBaseEntity *Respawn( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Respawn@CBaseEntity@@UAEPAV1@XZ ENDP			; CBaseEntity::Respawn
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?UpdateOwner@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::UpdateOwner, COMDAT

; 705  : 	virtual	void UpdateOwner( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateOwner@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::UpdateOwner
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FBecomeProne@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::FBecomeProne, COMDAT

; 709  : 	virtual BOOL FBecomeProne( void ) {return FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FBecomeProne@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::FBecomeProne
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
$T41091 = -16
$T41092 = -28
___$ReturnUdt$ = 8
_this$ = -4
?Center@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR		; CBaseEntity::Center, COMDAT

; 714  : 	virtual Vector Center( ) { return (pev->absmax + pev->absmin) * 0.5; }; // center point of entity

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T41092[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	push	edx
	lea	eax, DWORD PTR $T41091[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 208				; 000000d0H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Center@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::Center
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
$T41095 = -16
___$ReturnUdt$ = 8
_this$ = -4
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EyePosition, COMDAT

; 715  : 	virtual Vector EyePosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of eyes

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T41095[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EyePosition
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
$T41098 = -16
___$ReturnUdt$ = 8
_this$ = -4
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EarPosition, COMDAT

; 716  : 	virtual Vector EarPosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of ears

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T41098[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EarPosition
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
$T41101 = -16
___$ReturnUdt$ = 8
_this$ = -4
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseEntity::BodyTarget, COMDAT

; 717  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ); };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T41101[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseEntity::BodyTarget
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPointSized@CBaseEntity@@UBEHXZ PROC NEAR		; CBaseEntity::IsPointSized, COMDAT

; 718  : 	virtual BOOL IsPointSized() const { return (pev->size == g_vecZero) ? true : false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	setne	al
	and	eax, 255				; 000000ffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPointSized@CBaseEntity@@UBEHXZ ENDP			; CBaseEntity::IsPointSized
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Illumination@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::Illumination, COMDAT

; 720  : 	virtual int Illumination( ) { return GETENTITYILLUM( ENT( pev ) ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+60
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Illumination@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Illumination
_TEXT	ENDS
;	COMDAT ?GetState@CFuncTrackTrain@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CFuncTrackTrain@@UAE?AW4STATE@@XZ PROC NEAR	; CFuncTrackTrain::GetState, COMDAT

; 158  : 	virtual STATE	GetState( void ) { return (pev->speed != 0) ? STATE_ON : STATE_OFF; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41108
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41109
$L41108:
	mov	DWORD PTR -8+[ebp], 0
$L41109:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CFuncTrackTrain@@UAE?AW4STATE@@XZ ENDP	; CFuncTrackTrain::GetState
_TEXT	ENDS
PUBLIC	?ObjectCaps@CBaseEntity@@UAEHXZ			; CBaseEntity::ObjectCaps
;	COMDAT ?ObjectCaps@CFuncTrackTrain@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CFuncTrackTrain@@UAEHXZ PROC NEAR		; CFuncTrackTrain::ObjectCaps, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		return (CBaseDelay :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | FCAP_DIRECTIONAL_USE | FCAP_HOLD_ANGLES;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	al, 64					; 00000040H
	or	ah, 4

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CFuncTrackTrain@@UAEHXZ ENDP		; CFuncTrackTrain::ObjectCaps
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ObjectCaps, COMDAT

; 364  : 	virtual int	ObjectCaps( void ) { return FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 2
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ObjectCaps
_TEXT	ENDS
PUBLIC	??0CBaseEntity@@QAE@XZ				; CBaseEntity::CBaseEntity
PUBLIC	?GetState@CBaseDelay@@UAE?AW4STATE@@XZ		; CBaseDelay::GetState
PUBLIC	??_7CBaseDelay@@6B@				; CBaseDelay::`vftable'
PUBLIC	?Spawn@CBaseEntity@@UAEXXZ			; CBaseEntity::Spawn
PUBLIC	?Precache@CBaseEntity@@UAEXXZ			; CBaseEntity::Precache
PUBLIC	?OverrideReset@CBaseEntity@@UAEXXZ		; CBaseEntity::OverrideReset
PUBLIC	?OnControls@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::OnControls
PUBLIC	?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z	; CBaseEntity::Use
PUBLIC	?Blocked@CBaseEntity@@UAEXPAV1@@Z		; CBaseEntity::Blocked
EXTRN	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseDelay::KeyValue
EXTRN	?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseDelay::GetDataDescMap
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT
??_7CBaseDelay@@6B@ DD FLAT:?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ ; CBaseDelay::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseDelay@@6B@ ; CBaseDelay::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::CBaseDelay
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Spawn, COMDAT

; 325  : 	virtual void	Spawn( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Spawn
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Precache, COMDAT

; 326  : 	virtual void	Precache( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Precache
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OverrideReset, COMDAT

; 422  : 	virtual void	OverrideReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OverrideReset
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?OnControls@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::OnControls, COMDAT

; 429  : 	virtual BOOL	OnControls( CBaseEntity *pTest ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnControls@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::OnControls
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
_pActivator$ = 8
_pCaller$ = 12
_useType$ = 16
_value$ = 20
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z PROC NEAR	; CBaseEntity::Use, COMDAT

; 461  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 		if (m_pfnUse) (this->*m_pfnUse)( pActivator, pCaller, useType, value );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1752], 0
	je	SHORT $L35009
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCaller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1752]
$L35009:

; 463  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z ENDP	; CBaseEntity::Use
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Blocked@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Blocked, COMDAT

; 476  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 		if( m_pfnBlocked )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1756], 0
	je	SHORT $L35016

; 478  : 			(this->*m_pfnBlocked)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1756]
$L35016:

; 479  : 
; 480  : 		// forward the blocked event to our parent, if any.
; 481  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35017

; 482  : 			m_hParent->Blocked( pOther );

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+284]
$L35017:

; 483  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Blocked
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseDelay::GetState, COMDAT

; 881  : 	virtual STATE GetState( void ) { return m_iState; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1788]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ ENDP		; CBaseDelay::GetState
_TEXT	ENDS
PUBLIC	??1CBaseEntity@@QAE@XZ				; CBaseEntity::~CBaseEntity
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::~CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseEntity@@QAE@XZ			; CBaseEntity::~CBaseEntity
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::~CBaseDelay
_TEXT	ENDS
PUBLIC	??_7CBaseEntity@@6B@				; CBaseEntity::`vftable'
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@XZ		; CBaseEntity::GetState
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	??0CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::CMeshDesc
EXTRN	??1CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::~CMeshDesc
EXTRN	?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseEntity::GetDataDescMap
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT
??_7CBaseEntity@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CBaseEntity::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseEntity@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseEntity@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseEntity@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseEntity@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseEntity@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??0CMeshDesc@@QAE@XZ			; CMeshDesc::CMeshDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1632				; 00000660H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseEntity@@6B@ ; CBaseEntity::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseEntity@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	ret	0
__ehhandler$??0CBaseEntity@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseEntity@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::CBaseEntity
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseEntity::GetState, COMDAT

; 398  : 	virtual STATE GetState ( void ) { return STATE_OFF; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ ENDP		; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::~CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::~CBaseEntity
_TEXT	ENDS
;	COMDAT ?KeyValue@CFuncTrackTrain@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CFuncTrackTrain@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CFuncTrackTrain::KeyValue, COMDAT

; 1472 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1473 : 	if( FStrEq( pkvd->szKeyName, "wheels" ))

	push	OFFSET FLAT:??_C@_06MALF@wheels?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38054

; 1475 : 		m_length = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1804]

; 1476 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1478 : 	else if( FStrEq( pkvd->szKeyName, "height" ))

	jmp	$L38074
$L38054:
	push	OFFSET FLAT:??_C@_06OKPG@height?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38056

; 1480 : 		m_height = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1808]

; 1481 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1483 : 	else if( FStrEq( pkvd->szKeyName, "startspeed" ))

	jmp	$L38074
$L38056:
	push	OFFSET FLAT:??_C@_0L@DAPE@startspeed?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38058

; 1485 : 		m_startSpeed = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1816]

; 1486 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1488 : 	else if( FStrEq( pkvd->szKeyName, "sounds" ))

	jmp	$L38074
$L38058:
	push	OFFSET FLAT:??_C@_06HADE@sounds?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38060

; 1490 : 		m_sounds = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1860], eax

; 1491 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1493 : 	else if( FStrEq( pkvd->szKeyName, "soundstop" ))

	jmp	$L38074
$L38060:
	push	OFFSET FLAT:??_C@_09BKIF@soundstop?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38062

; 1495 : 		m_soundStop = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1868], eax

; 1496 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1498 : 	else if( FStrEq( pkvd->szKeyName, "soundstart" ))

	jmp	$L38074
$L38062:
	push	OFFSET FLAT:??_C@_0L@OAIB@soundstart?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38064

; 1500 : 		m_soundStart = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1864], eax

; 1501 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1503 : 	else if( FStrEq( pkvd->szKeyName, "volume" ))

	jmp	$L38074
$L38064:
	push	OFFSET FLAT:??_C@_06FLOP@volume?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38066

; 1505 : 		m_flVolume = (float)( Q_atoi( pkvd->szValue ));

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	fild	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1872]

; 1506 : 		m_flVolume *= 0.1f;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1872]
	fmul	DWORD PTR __real@4@3ffbcccccd0000000000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1872]

; 1507 : 		pkvd->fHandled = TRUE;

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 1509 : 	else if( FStrEq( pkvd->szKeyName, "acceltype" ))

	jmp	$L38074
$L38066:
	push	OFFSET FLAT:??_C@_09KAOB@acceltype?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38069

; 1511 : 		m_eVelocityType = Q_atoi( pkvd->szValue );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1892], eax

; 1512 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1514 : 	else if( FStrEq( pkvd->szKeyName, "orientation" ))

	jmp	$L38074
$L38069:
	push	OFFSET FLAT:??_C@_0M@OAHA@orientation?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38071

; 1516 : 		m_eOrientationType = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1888], eax

; 1517 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1519 : 	else if( FStrEq( pkvd->szKeyName, "bank" ))

	jmp	SHORT $L38074
$L38071:
	push	OFFSET FLAT:??_C@_04MAHH@bank?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38073

; 1521 : 		m_flBank = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1876]

; 1522 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1524 : 	else

	jmp	SHORT $L38074
$L38073:

; 1525 : 		BaseClass::KeyValue( pkvd );

	mov	eax, DWORD PTR _pkvd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z ; CBaseDelay::KeyValue
$L38074:

; 1526 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CFuncTrackTrain@@UAEXPAUKeyValueData_s@@@Z ENDP ; CFuncTrackTrain::KeyValue
_TEXT	ENDS
PUBLIC	?SetDirForward@CFuncTrackTrain@@QAEX_N@Z	; CFuncTrackTrain::SetDirForward
EXTRN	?GetNext@CPathTrack@@QAEPAV1@XZ:NEAR		; CPathTrack::GetNext
EXTRN	?GetPrevious@CPathTrack@@QAEPAV1@XZ:NEAR	; CPathTrack::GetPrevious
;	COMDAT ?SetDirForward@CFuncTrackTrain@@QAEX_N@Z
_TEXT	SEGMENT
_bForward$ = 8
_this$ = -4
?SetDirForward@CFuncTrackTrain@@QAEX_N@Z PROC NEAR	; CFuncTrackTrain::SetDirForward, COMDAT

; 1529 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1530 : 	if( bForward && ( m_dir != 1 ))

	mov	eax, DWORD PTR _bForward$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L38079
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1884]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38079

; 1532 : 		// Reverse direction.
; 1533 : 		if ( m_ppath && m_ppath->GetPrevious() )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1796], 0
	je	SHORT $L38080
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1796]
	call	?GetPrevious@CPathTrack@@QAEPAV1@XZ	; CPathTrack::GetPrevious
	test	eax, eax
	je	SHORT $L38080

; 1535 : 			m_ppath = m_ppath->GetPrevious();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1796]
	call	?GetPrevious@CPathTrack@@QAEPAV1@XZ	; CPathTrack::GetPrevious
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1796], eax
$L38080:

; 1537 : 
; 1538 : 		m_dir = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1884], 1065353216	; 3f800000H

; 1540 : 	else if( !bForward && ( m_dir != -1 ))

	jmp	SHORT $L38082
$L38079:
	mov	ecx, DWORD PTR _bForward$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L38082
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1884]
	fcomp	DWORD PTR __real@4@bfff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38082

; 1542 : 		// Reverse direction.
; 1543 : 		if ( m_ppath && m_ppath->GetNext() )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1796], 0
	je	SHORT $L38083
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1796]
	call	?GetNext@CPathTrack@@QAEPAV1@XZ		; CPathTrack::GetNext
	test	eax, eax
	je	SHORT $L38083

; 1545 : 			m_ppath = m_ppath->GetNext();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1796]
	call	?GetNext@CPathTrack@@QAEPAV1@XZ		; CPathTrack::GetNext
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1796], eax
$L38083:

; 1547 : 
; 1548 : 		m_dir = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1884], -1082130432	; bf800000H
$L38082:

; 1550 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDirForward@CFuncTrackTrain@@QAEX_N@Z ENDP		; CFuncTrackTrain::SetDirForward
_TEXT	ENDS
PUBLIC	??_C@_0BK@NHEJ@TRAIN?$CI?$CFs?$CJ?0?5speed?5to?5?$CF?42f?6?$AA@ ; `string'
PUBLIC	?Stop@CFuncTrackTrain@@QAEXXZ			; CFuncTrackTrain::Stop
PUBLIC	?IsDirForward@CFuncTrackTrain@@QAE_NXZ		; CFuncTrackTrain::IsDirForward
PUBLIC	?SetSpeed@CFuncTrackTrain@@QAEXMM@Z		; CFuncTrackTrain::SetSpeed
PUBLIC	?GetDebugName@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetDebugName
;	COMDAT ??_C@_0BK@NHEJ@TRAIN?$CI?$CFs?$CJ?0?5speed?5to?5?$CF?42f?6?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BK@NHEJ@TRAIN?$CI?$CFs?$CJ?0?5speed?5to?5?$CF?42f?6?$AA@ DB 'TRAIN'
	DB	'(%s), speed to %.2f', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?SetSpeed@CFuncTrackTrain@@QAEXMM@Z
_TEXT	SEGMENT
_flSpeed$ = 8
_flAccel$ = 12
_this$ = -4
_flOldSpeed$ = -8
?SetSpeed@CFuncTrackTrain@@QAEXMM@Z PROC NEAR		; CFuncTrackTrain::SetSpeed, COMDAT

; 1556 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1557 : 	float flOldSpeed = pev->speed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+504]
	mov	DWORD PTR _flOldSpeed$[ebp], edx

; 1558 : 	m_flAccelSpeed = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1900], 0

; 1559 : 
; 1560 : 	if( flAccel != 0.0f )

	fld	DWORD PTR _flAccel$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L38090

; 1562 : 		m_flDesiredSpeed = fabs( flSpeed ) * m_dir;

	fld	DWORD PTR _flSpeed$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+1884]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1896]

; 1563 : 
; 1564 : 		if( pev->speed == 0 ) // little push to get us going

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38091

; 1565 : 			pev->speed = IsDirForward() ? 0.1f : -0.1f;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDirForward@CFuncTrackTrain@@QAE_NXZ	; CFuncTrackTrain::IsDirForward
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41154
	mov	DWORD PTR -12+[ebp], 1036831949		; 3dcccccdH
	jmp	SHORT $L41155
$L41154:
	mov	DWORD PTR -12+[ebp], -1110651699	; bdcccccdH
$L41155:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR -12+[ebp]
	mov	DWORD PTR [eax+504], ecx
$L38091:

; 1566 : 		m_flAccelSpeed = flAccel;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _flAccel$[ebp]
	mov	DWORD PTR [edx+1900], eax

; 1567 : 
; 1568 : 		Next();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Next@CFuncTrackTrain@@QAEXXZ		; CFuncTrackTrain::Next

; 1569 : 		return;		

	jmp	$L38088
$L38090:

; 1571 : 
; 1572 : 	pev->speed = m_flDesiredSpeed = fabs( flSpeed ) * m_dir;

	fld	DWORD PTR _flSpeed$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+1884]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1896]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1896]
	mov	DWORD PTR [ecx+504], eax

; 1573 : 	m_oldSpeed = flOldSpeed;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _flOldSpeed$[ebp]
	mov	DWORD PTR [ecx+1880], edx

; 1574 : 
; 1575 : 	if( pev->speed != flOldSpeed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR _flOldSpeed$[ebp]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38094

; 1577 : 		// Changing speed.
; 1578 : 		if( pev->speed != 0 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38093

; 1580 : 			// Starting to move.
; 1581 : 			Next();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Next@CFuncTrackTrain@@QAEXXZ		; CFuncTrackTrain::Next

; 1583 : 		else

	jmp	SHORT $L38094
$L38093:

; 1585 : 			// Stopping.
; 1586 : 			Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@CFuncTrackTrain@@QAEXXZ		; CFuncTrackTrain::Stop
$L38094:

; 1589 : 
; 1590 : 	ALERT( at_aiconsole, "TRAIN(%s), speed to %.2f\n", GetDebugName(), pev->speed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDebugName@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetDebugName
	push	eax
	push	OFFSET FLAT:??_C@_0BK@NHEJ@TRAIN?$CI?$CFs?$CJ?0?5speed?5to?5?$CF?42f?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L38088:

; 1591 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetSpeed@CFuncTrackTrain@@QAEXMM@Z ENDP		; CFuncTrackTrain::SetSpeed
_TEXT	ENDS
PUBLIC	??_C@_04GOCP@null?$AA@				; `string'
;	COMDAT ??_C@_04GOCP@null?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_04GOCP@null?$AA@ DB 'null', 00H			; `string'
CONST	ENDS
;	COMDAT ?GetDebugName@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetDebugName@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetDebugName, COMDAT

; 293  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 294  : 		if( this == NULL || pev == NULL )

	cmp	DWORD PTR _this$[ebp], 0
	je	SHORT $L34863
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L34862
$L34863:

; 295  : 			return "null";

	mov	eax, OFFSET FLAT:??_C@_04GOCP@null?$AA@	; `string'
	jmp	SHORT $L34861
$L34862:

; 296  : 
; 297  : 		if( pev->targetname != NULL_STRING ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+460], 0
	je	SHORT $L34865

; 298  : 			return GetTargetname();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	jmp	SHORT $L34861
$L34865:

; 299  : 		return GetClassname();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
$L34861:

; 300  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDebugName@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetDebugName
_TEXT	ENDS
;	COMDAT ?IsDirForward@CFuncTrackTrain@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsDirForward@CFuncTrackTrain@@QAE_NXZ PROC NEAR	; CFuncTrackTrain::IsDirForward, COMDAT

; 132  : 	bool IsDirForward() { return ( m_dir == 1 ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1884]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41160
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41161
$L41160:
	mov	DWORD PTR -8+[ebp], 0
$L41161:
	mov	al, BYTE PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDirForward@CFuncTrackTrain@@QAE_NXZ ENDP		; CFuncTrackTrain::IsDirForward
_TEXT	ENDS
PUBLIC	__real@8@00000000000000000000
PUBLIC	?SetSpeedExternal@CFuncTrackTrain@@QAEXM@Z	; CFuncTrackTrain::SetSpeedExternal
;	COMDAT __real@8@00000000000000000000
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
__real@8@00000000000000000000 DQ 00000000000000000r ; 0
CONST	ENDS
;	COMDAT ?SetSpeedExternal@CFuncTrackTrain@@QAEXM@Z
_TEXT	SEGMENT
_flSpeed$ = 8
_this$ = -4
_flOldSpeed$ = -8
?SetSpeedExternal@CFuncTrackTrain@@QAEXM@Z PROC NEAR	; CFuncTrackTrain::SetSpeedExternal, COMDAT

; 1594 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1595 : 	float flOldSpeed = pev->speed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+504]
	mov	DWORD PTR _flOldSpeed$[ebp], edx

; 1596 : 
; 1597 : 	if( flSpeed > 0.0f )

	fld	DWORD PTR _flSpeed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38101

; 1598 : 		SetDirForward( true );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDirForward@CFuncTrackTrain@@QAEX_N@Z ; CFuncTrackTrain::SetDirForward

; 1599 : 	else if( flSpeed < 0.0 )

	jmp	SHORT $L38103
$L38101:
	fld	DWORD PTR _flSpeed$[ebp]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38103

; 1600 : 		SetDirForward( false );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDirForward@CFuncTrackTrain@@QAEX_N@Z ; CFuncTrackTrain::SetDirForward
$L38103:

; 1601 : 
; 1602 : 	pev->speed = m_flDesiredSpeed = fabs( flSpeed ) * m_dir;

	fld	DWORD PTR _flSpeed$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+1884]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1896]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1896]
	mov	DWORD PTR [eax+504], edx

; 1603 : 	m_oldSpeed = flOldSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flOldSpeed$[ebp]
	mov	DWORD PTR [eax+1880], ecx

; 1604 : 
; 1605 : 	if( pev->speed != flOldSpeed )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	fcomp	DWORD PTR _flOldSpeed$[ebp]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38106

; 1607 : 		// Changing speed.
; 1608 : 		if( pev->speed != 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38105

; 1610 : 			// Starting to move.
; 1611 : 			Next();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Next@CFuncTrackTrain@@QAEXXZ		; CFuncTrackTrain::Next

; 1613 : 		else

	jmp	SHORT $L38106
$L38105:

; 1615 : 			// Stopping.
; 1616 : 			Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@CFuncTrackTrain@@QAEXXZ		; CFuncTrackTrain::Stop
$L38106:

; 1619 : 
; 1620 : 	ALERT( at_aiconsole, "TRAIN(%s), speed to %.2f\n", GetDebugName(), pev->speed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDebugName@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetDebugName
	push	eax
	push	OFFSET FLAT:??_C@_0BK@NHEJ@TRAIN?$CI?$CFs?$CJ?0?5speed?5to?5?$CF?42f?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H

; 1621 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSpeedExternal@CFuncTrackTrain@@QAEXM@Z ENDP		; CFuncTrackTrain::SetSpeedExternal
_TEXT	ENDS
PUBLIC	?StopSound@CFuncTrackTrain@@QAEXXZ		; CFuncTrackTrain::StopSound
;	COMDAT ?Stop@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Stop@CFuncTrackTrain@@QAEXXZ PROC NEAR			; CFuncTrackTrain::Stop, COMDAT

; 1627 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1628 : 	SetLocalVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 1629 : 	SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 1630 : 	m_oldSpeed = pev->speed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+504]
	mov	DWORD PTR [edx+1880], eax

; 1631 : 	SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1632 : 	pev->speed = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+504], 0

; 1633 : 	StopSound();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopSound@CFuncTrackTrain@@QAEXXZ	; CFuncTrackTrain::StopSound

; 1634 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@CFuncTrackTrain@@QAEXXZ ENDP			; CFuncTrackTrain::Stop
_TEXT	ENDS
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	??_C@_0CF@OGMH@TRAIN?$CI?$CFs?$CJ?3?5Blocked?5by?5?$CFs?5?$CIdmg?3?$CF?4@ ; `string'
PUBLIC	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ	; CBaseEntity::GetGroundEntity
EXTRN	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsVelocity
;	COMDAT ??_C@_0CF@OGMH@TRAIN?$CI?$CFs?$CJ?3?5Blocked?5by?5?$CFs?5?$CIdmg?3?$CF?4@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0CF@OGMH@TRAIN?$CI?$CFs?$CJ?3?5Blocked?5by?5?$CFs?5?$CIdmg?3?$CF?4@ DB 'T'
	DB	'RAIN(%s): Blocked by %s (dmg:%.2f)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?Blocked@CFuncTrackTrain@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T41170 = -44
$T41171 = -56
$T41172 = -68
_pOther$ = 8
_this$ = -4
_deltaSpeed$38118 = -8
_vecNewVelocity$38120 = -20
_vecNewVelocity$38123 = -32
?Blocked@CFuncTrackTrain@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CFuncTrackTrain::Blocked, COMDAT

; 1637 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1638 : 	// Blocker is on-ground on the train
; 1639 : 	if ( FBitSet( pOther->pev->flags, FL_ONGROUND ) && pOther->GetGroundEntity() == this )

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	SHORT $L38117
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ; CBaseEntity::GetGroundEntity
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $L38117

; 1641 : 		float deltaSpeed = fabs( pev->speed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _deltaSpeed$38118[ebp]

; 1642 : 
; 1643 : 		if( deltaSpeed > 50 )

	fld	DWORD PTR _deltaSpeed$38118[ebp]
	fcomp	DWORD PTR __real@4@4004c800000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38119

; 1644 : 			deltaSpeed = 50;

	mov	DWORD PTR _deltaSpeed$38118[ebp], 1112014848 ; 42480000H
$L38119:

; 1645 : 
; 1646 : 		Vector vecNewVelocity = pOther->GetAbsVelocity();

	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vecNewVelocity$38120[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1647 : 
; 1648 : 		if( !vecNewVelocity.z )

	fld	DWORD PTR _vecNewVelocity$38120[ebp+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38121

; 1650 : 			vecNewVelocity.z += deltaSpeed;

	fld	DWORD PTR _vecNewVelocity$38120[ebp+8]
	fadd	DWORD PTR _deltaSpeed$38118[ebp]
	fstp	DWORD PTR _vecNewVelocity$38120[ebp+8]

; 1651 : 			pOther->SetAbsVelocity( vecNewVelocity );

	lea	edx, DWORD PTR _vecNewVelocity$38120[ebp]
	push	edx
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L38121:

; 1653 : 		return;

	jmp	$L38116
$L38117:

; 1657 : 		Vector vecNewVelocity = (pOther->GetAbsOrigin() - GetAbsOrigin()).Normalize() * pev->dmg;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+480]
	push	edx
	lea	eax, DWORD PTR $T41172[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41171[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T41170[ebp]
	push	edx
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _vecNewVelocity$38123[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1658 : 		pOther->SetAbsVelocity( vecNewVelocity );

	lea	eax, DWORD PTR _vecNewVelocity$38123[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1660 : 
; 1661 : 	if( FBitSet( pev->spawnflags, SF_TRACKTRAIN_UNBLOCKABLE ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $L38128

; 1663 : 		// unblockable shouldn't damage the player in this case
; 1664 : 		if ( pOther->IsPlayer() )

	mov	ecx, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L38128

; 1665 : 			return;

	jmp	SHORT $L38116
$L38128:

; 1667 : 
; 1668 : 	ALERT( at_aiconsole, "TRAIN(%s): Blocked by %s (dmg:%.2f)\n", GetDebugName(), pOther->GetClassname(), pev->dmg );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+480]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDebugName@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetDebugName
	push	eax
	push	OFFSET FLAT:??_C@_0CF@OGMH@TRAIN?$CI?$CFs?$CJ?3?5Blocked?5by?5?$CFs?5?$CIdmg?3?$CF?4@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 24					; 00000018H

; 1669 : 	if( pev->dmg <= 0 ) return;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+480]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38130
	jmp	SHORT $L38116
$L38130:

; 1670 : 
; 1671 : 	// we can't hurt this thing, so we're not concerned with it
; 1672 : 	pOther->TakeDamage( pev, pev, pev->dmg, DMG_CRUSH );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+480]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pOther$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [eax+96]
$L38116:

; 1673 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CFuncTrackTrain@@UAEXPAVCBaseEntity@@@Z ENDP	; CFuncTrackTrain::Blocked
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
$T41175 = -20
___$ReturnUdt$ = 8
_this$ = -4
_flLen$ = -8
?Normalize@Vector@@QBE?AV1@XZ PROC NEAR			; Vector::Normalize, COMDAT

; 232  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 234  : 
; 235  : 		if( flLen )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L24894

; 237  : 			flLen = 1.0f / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 238  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41175[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L24892
$L24894:

; 240  : 
; 241  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L24892:

; 242  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
;	COMDAT ?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ PROC NEAR	; CBaseEntity::GetGroundEntity, COMDAT

; 599  : 	CBaseEntity *GetGroundEntity( void ) { return Instance( pev->groundentity ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+412]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ENDP		; CBaseEntity::GetGroundEntity
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
PUBLIC	__real@4@40018000000000000000
PUBLIC	__real@8@3ffd8000000000000000
PUBLIC	??_C@_0BM@CPIO@TRAIN?$CI?5?$CFs?5?$CJ?0?5speed?5to?5?$CF?42f?6?$AA@ ; `string'
;	COMDAT ??_C@_0BM@CPIO@TRAIN?$CI?5?$CFs?5?$CJ?0?5speed?5to?5?$CF?42f?6?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BM@CPIO@TRAIN?$CI?5?$CFs?5?$CJ?0?5speed?5to?5?$CF?42f?6?$AA@ DB 'T'
	DB	'RAIN( %s ), speed to %.2f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@4@40018000000000000000
CONST	SEGMENT
__real@4@40018000000000000000 DD 040800000r	; 4
CONST	ENDS
;	COMDAT __real@8@3ffd8000000000000000
CONST	SEGMENT
__real@8@3ffd8000000000000000 DQ 03fd0000000000000r ; 0.25
CONST	ENDS
;	COMDAT ?Use@CFuncTrackTrain@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_pCaller$ = 12
_useType$ = 16
_value$ = 20
_this$ = -4
_delta$38151 = -8
_accel$38152 = -12
?Use@CFuncTrackTrain@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CFuncTrackTrain::Use, COMDAT

; 1677 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1678 : 	m_hActivator = pActivator;

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1679 : 
; 1680 : 	if( IsLockedByMaster( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHXZ	; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L38138

; 1681 : 		return;

	jmp	$L38137
$L38138:

; 1682 : 
; 1683 : 	if( useType == USE_RESET )

	cmp	DWORD PTR _useType$[ebp], 4
	jne	SHORT $L38139

; 1685 : 		if( FBitSet( pev->spawnflags, SF_TRACKTRAIN_FORWARDONLY ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 4
	test	eax, eax
	je	SHORT $L38140

; 1686 : 			return;	// can't moving backward

	jmp	$L38137
$L38140:

; 1687 : 
; 1688 : 		if( !FBitSet( pev->spawnflags, SF_TRACKTRAIN_NOCONTROL ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 2
	test	eax, eax
	jne	SHORT $L38141

; 1689 : 			return; // only for non-controllable trains

	jmp	$L38137
$L38141:

; 1690 : 
; 1691 : 		// will change only for non-moving train
; 1692 : 		if( pev->speed == 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38142

; 1693 : 			SetDirForward( !IsDirForward() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDirForward@CFuncTrackTrain@@QAE_NXZ	; CFuncTrackTrain::IsDirForward
	and	eax, 255				; 000000ffH
	neg	eax
	sbb	eax, eax
	inc	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDirForward@CFuncTrackTrain@@QAEX_N@Z ; CFuncTrackTrain::SetDirForward
$L38142:

; 1695 : 	else if( useType != USE_SET )

	jmp	$L38149
$L38139:
	cmp	DWORD PTR _useType$[ebp], 2
	je	$L38144

; 1697 : 		if( !ShouldToggle( useType, ( pev->speed != 0 )))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41184
	mov	DWORD PTR -16+[ebp], 1
	jmp	SHORT $L41185
$L41184:
	mov	DWORD PTR -16+[ebp], 0
$L41185:
	mov	edx, DWORD PTR -16+[ebp]
	push	edx
	mov	eax, DWORD PTR _useType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@H@Z ; CBaseEntity::ShouldToggle
	test	eax, eax
	jne	SHORT $L38145

; 1698 : 			return;

	jmp	$L38137
$L38145:

; 1699 : 
; 1700 : 		if( pev->speed == 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38146

; 1702 : 			if( m_pDoor && m_pDoor->IsDoorControl( ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1792], 0
	je	SHORT $L38147
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1792]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1792]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+344]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L38147

; 1704 : 				m_pDoor->Use( pActivator, pCaller, USE_SET, 2.0f );

	push	1073741824				; 40000000H
	push	2
	mov	eax, DWORD PTR _pCaller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1792]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1792]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+276]

; 1705 : 				return; // wait for door closing first

	jmp	$L38137
$L38147:

; 1707 : 
; 1708 : 			SetSpeed( m_maxSpeed );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1812]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSpeed@CFuncTrackTrain@@QAEXMM@Z	; CFuncTrackTrain::SetSpeed

; 1710 : 		else

	jmp	SHORT $L38148
$L38146:

; 1712 : 			SetSpeed( 0 );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSpeed@CFuncTrackTrain@@QAEXMM@Z	; CFuncTrackTrain::SetSpeed
$L38148:

; 1715 : 	else

	jmp	$L38149
$L38144:

; 1717 : 		// g-cont. Don't controls, if tracktrain on trackchange
; 1718 : 	          if( m_ppath == NULL ) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $L38150

; 1719 : 			return;

	jmp	$L38137
$L38150:

; 1720 : 
; 1721 : 		float delta = value;

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _delta$38151[ebp], ecx

; 1722 : 		float accel = 0.0f;

	mov	DWORD PTR _accel$38152[ebp], 0

; 1723 : 
; 1724 : 		if( pCaller && pCaller->IsPlayer( ))

	cmp	DWORD PTR _pCaller$[ebp], 0
	je	SHORT $L38153
	mov	edx, DWORD PTR _pCaller$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pCaller$[ebp]
	call	DWORD PTR [eax+224]
	test	eax, eax
	je	SHORT $L38153

; 1726 : 			delta = ((int)(m_flDesiredSpeed * 4) / (int)m_maxSpeed) * 0.25 + 0.25 * delta;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1896]
	fmul	DWORD PTR __real@4@40018000000000000000
	call	__ftol
	mov	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1812]
	call	__ftol
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	mov	DWORD PTR -20+[ebp], eax
	fild	DWORD PTR -20+[ebp]
	fmul	QWORD PTR __real@8@3ffd8000000000000000
	fld	DWORD PTR _delta$38151[ebp]
	fmul	QWORD PTR __real@8@3ffd8000000000000000
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _delta$38151[ebp]

; 1727 : 			accel = 100.0f;

	mov	DWORD PTR _accel$38152[ebp], 1120403456	; 42c80000H

; 1729 : 		else delta *= m_dir; // momentary button can't sending negative values

	jmp	SHORT $L38156
$L38153:
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _delta$38151[ebp]
	fmul	DWORD PTR [edx+1884]
	fstp	DWORD PTR _delta$38151[ebp]
$L38156:

; 1730 : 
; 1731 : 		if( FBitSet( pev->spawnflags, SF_TRACKTRAIN_FORWARDONLY ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 4
	test	edx, edx
	je	SHORT $L38157

; 1732 : 			delta = bound( 0.0f, delta, 1.0f );

	fld	DWORD PTR _delta$38151[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L41188
	fld	DWORD PTR _delta$38151[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41186
	mov	eax, DWORD PTR _delta$38151[ebp]
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L41187
$L41186:
	mov	DWORD PTR -24+[ebp], 1065353216		; 3f800000H
$L41187:
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR -28+[ebp], ecx
	jmp	SHORT $L41189
$L41188:
	mov	DWORD PTR -28+[ebp], 0
$L41189:
	mov	edx, DWORD PTR -28+[ebp]
	mov	DWORD PTR _delta$38151[ebp], edx

; 1733 : 		else delta = bound( -1.0f, delta, 1.0f ); // g-cont. limit the backspeed

	jmp	SHORT $L38158
$L38157:
	fld	DWORD PTR _delta$38151[ebp]
	fcomp	DWORD PTR __real@4@bfff8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L41192
	fld	DWORD PTR _delta$38151[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41190
	mov	eax, DWORD PTR _delta$38151[ebp]
	mov	DWORD PTR -32+[ebp], eax
	jmp	SHORT $L41191
$L41190:
	mov	DWORD PTR -32+[ebp], 1065353216		; 3f800000H
$L41191:
	mov	ecx, DWORD PTR -32+[ebp]
	mov	DWORD PTR -36+[ebp], ecx
	jmp	SHORT $L41193
$L41192:
	mov	DWORD PTR -36+[ebp], -1082130432	; bf800000H
$L41193:
	mov	edx, DWORD PTR -36+[ebp]
	mov	DWORD PTR _delta$38151[ebp], edx
$L38158:

; 1734 : 
; 1735 : 		// don't reverse if decelerate
; 1736 : 		if( pev->speed != 0 && IsDirForward() && delta < 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38159
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDirForward@CFuncTrackTrain@@QAE_NXZ	; CFuncTrackTrain::IsDirForward
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L38159
	fld	DWORD PTR _delta$38151[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38159

; 1737 : 			return;

	jmp	$L38137
$L38159:

; 1738 : 		if( pev->speed != 0 && !IsDirForward() && delta > 0 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38160
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDirForward@CFuncTrackTrain@@QAE_NXZ	; CFuncTrackTrain::IsDirForward
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L38160
	fld	DWORD PTR _delta$38151[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38160

; 1739 : 			return;

	jmp	$L38137
$L38160:

; 1740 : 
; 1741 : 		if( delta > 0.0f )

	fld	DWORD PTR _delta$38151[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38161

; 1742 : 			SetDirForward( true );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDirForward@CFuncTrackTrain@@QAEX_N@Z ; CFuncTrackTrain::SetDirForward

; 1743 : 		else if( delta < 0.0 )

	jmp	SHORT $L38163
$L38161:
	fld	DWORD PTR _delta$38151[ebp]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38163

; 1744 : 			SetDirForward( false );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDirForward@CFuncTrackTrain@@QAEX_N@Z ; CFuncTrackTrain::SetDirForward
$L38163:

; 1745 : 		delta = fabs( delta );

	fld	DWORD PTR _delta$38151[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _delta$38151[ebp]

; 1746 : 		SetSpeed( m_maxSpeed * delta, accel );

	mov	ecx, DWORD PTR _accel$38152[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _delta$38151[ebp]
	fmul	DWORD PTR [edx+1812]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSpeed@CFuncTrackTrain@@QAEXMM@Z	; CFuncTrackTrain::SetSpeed

; 1747 : 
; 1748 : 		ALERT( at_aiconsole, "TRAIN( %s ), speed to %.2f\n", GetTargetname(), pev->speed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	push	OFFSET FLAT:??_C@_0BM@CPIO@TRAIN?$CI?5?$CFs?5?$CJ?0?5speed?5to?5?$CF?42f?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L38149:
$L38137:

; 1750 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CFuncTrackTrain@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CFuncTrackTrain::Use
_TEXT	ENDS
;	COMDAT ?StopSound@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSound@CFuncTrackTrain@@QAEXXZ PROC NEAR		; CFuncTrackTrain::StopSound, COMDAT

; 1775 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1776 : 	// if sound playing, stop it
; 1777 : 	if( m_soundPlaying && pev->noise )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1856], 0
	je	SHORT $L38184
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+488], 0
	je	SHORT $L38184

; 1779 : 		STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+488]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH

; 1780 : 		EMIT_SOUND_DYN( edict(), CHAN_ITEM, STRING( pev->noise2 ), m_flVolume, ATTN_NORM, 0, 100 );

	push	100					; 00000064H
	push	0
	push	1061997773				; 3f4ccccdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1872]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+496]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH
$L38184:

; 1782 : 
; 1783 : 	m_soundPlaying = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1856], 0

; 1784 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSound@CFuncTrackTrain@@QAEXXZ ENDP			; CFuncTrackTrain::StopSound
_TEXT	ENDS
PUBLIC	__real@8@4008fa00000000000000
PUBLIC	?RemapVal@@YAMMMMMM@Z				; RemapVal
PUBLIC	?UpdateSound@CFuncTrackTrain@@QAEXXZ		; CFuncTrackTrain::UpdateSound
;	COMDAT __real@8@4008fa00000000000000
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
__real@8@4008fa00000000000000 DQ 0408f400000000000r ; 1000
CONST	ENDS
;	COMDAT ?UpdateSound@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_flSpeedRatio$ = -8
_flpitch$ = -12
?UpdateSound@CFuncTrackTrain@@QAEXXZ PROC NEAR		; CFuncTrackTrain::UpdateSound, COMDAT

; 1790 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1791 : 	if( !pev->noise )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+488], 0
	jne	SHORT $L38190

; 1792 : 		return;

	jmp	$L38189
$L38190:

; 1793 : 
; 1794 : 	float flSpeedRatio = 0;

	mov	DWORD PTR _flSpeedRatio$[ebp], 0

; 1795 : 
; 1796 : 	if ( FBitSet( pev->spawnflags, SF_TRACKTRAIN_SPEEDBASED_PITCH ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 64					; 00000040H
	test	ecx, ecx
	je	$L38192

; 1798 : 		flSpeedRatio = bound( 0.0f, fabs( pev->speed ) / m_maxSpeed, 1.0f );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx+1812]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L41204
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx+1812]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41202
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx+1812]
	fstp	QWORD PTR -20+[ebp]
	jmp	SHORT $L41203
$L41202:
	mov	DWORD PTR -20+[ebp], 0
	mov	DWORD PTR -20+[ebp+4], 1072693248	; 3ff00000H
$L41203:
	mov	edx, DWORD PTR -20+[ebp]
	mov	DWORD PTR -28+[ebp], edx
	mov	eax, DWORD PTR -20+[ebp+4]
	mov	DWORD PTR -28+[ebp+4], eax
	jmp	SHORT $L41205
$L41204:
	mov	DWORD PTR -28+[ebp], 0
	mov	DWORD PTR -28+[ebp+4], 0
$L41205:
	fld	QWORD PTR -28+[ebp]
	fstp	DWORD PTR _flSpeedRatio$[ebp]

; 1800 : 	else

	jmp	$L38193
$L38192:

; 1802 : 		flSpeedRatio = bound( 0.0f, fabs( pev->speed ) / TRAIN_MAXSPEED, 1.0f );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L41208
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41206
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	fstp	QWORD PTR -36+[ebp]
	jmp	SHORT $L41207
$L41206:
	mov	DWORD PTR -36+[ebp], 0
	mov	DWORD PTR -36+[ebp+4], 1072693248	; 3ff00000H
$L41207:
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR -44+[ebp], ecx
	mov	edx, DWORD PTR -36+[ebp+4]
	mov	DWORD PTR -44+[ebp+4], edx
	jmp	SHORT $L41209
$L41208:
	mov	DWORD PTR -44+[ebp], 0
	mov	DWORD PTR -44+[ebp+4], 0
$L41209:
	fld	QWORD PTR -44+[ebp]
	fstp	DWORD PTR _flSpeedRatio$[ebp]
$L38193:

; 1804 : 
; 1805 : 	float flpitch = RemapVal( flSpeedRatio, 0.0f, 1.0f, TRAIN_MINPITCH, TRAIN_MAXPITCH );

	push	1128792064				; 43480000H
	push	1114636288				; 42700000H
	push	1065353216				; 3f800000H
	push	0
	mov	eax, DWORD PTR _flSpeedRatio$[ebp]
	push	eax
	call	?RemapVal@@YAMMMMMM@Z			; RemapVal
	add	esp, 20					; 00000014H
	fstp	DWORD PTR _flpitch$[ebp]

; 1806 : 
; 1807 : 	if( !m_soundPlaying )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1856], 0
	jne	$L38195

; 1809 : 		// play startup sound for train
; 1810 : 		EMIT_SOUND_DYN( edict(), CHAN_ITEM, STRING( pev->noise1 ), m_flVolume, ATTN_NORM, 0, 100 );

	push	100					; 00000064H
	push	0
	push	1061997773				; 3f4ccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1872]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+492]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 1811 : 		EMIT_SOUND_DYN( edict(), CHAN_STATIC, STRING( pev->noise ), m_flVolume, ATTN_NORM, 0, (int)flpitch );

	fld	DWORD PTR _flpitch$[ebp]
	call	__ftol
	push	eax
	push	0
	push	1061997773				; 3f4ccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1872]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+488]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 1812 : 		m_soundPlaying = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], 1

; 1814 : 	else

	jmp	SHORT $L38199
$L38195:

; 1816 : 		// update pitch
; 1817 : 		EMIT_SOUND_DYN( edict(), CHAN_STATIC, STRING(pev->noise), m_flVolume, ATTN_NORM, SND_CHANGE_PITCH, (int)flpitch );

	fld	DWORD PTR _flpitch$[ebp]
	call	__ftol
	push	eax
	push	128					; 00000080H
	push	1061997773				; 3f4ccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1872]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+488]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH
$L38199:
$L38189:

; 1819 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateSound@CFuncTrackTrain@@QAEXXZ ENDP		; CFuncTrackTrain::UpdateSound
_TEXT	ENDS
;	COMDAT ?RemapVal@@YAMMMMMM@Z
_TEXT	SEGMENT
_val$ = 8
_A$ = 12
_B$ = 16
_C$ = 20
_D$ = 24
?RemapVal@@YAMMMMMM@Z PROC NEAR				; RemapVal, COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 92   : 	if( A == B ) return val >= B ? D : C;

	fld	DWORD PTR _A$[ebp]
	fcomp	DWORD PTR _B$[ebp]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L26106
	fld	DWORD PTR _val$[ebp]
	fcomp	DWORD PTR _B$[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L41214
	mov	eax, DWORD PTR _D$[ebp]
	mov	DWORD PTR -4+[ebp], eax
	jmp	SHORT $L41215
$L41214:
	mov	ecx, DWORD PTR _C$[ebp]
	mov	DWORD PTR -4+[ebp], ecx
$L41215:
	fld	DWORD PTR -4+[ebp]
	jmp	SHORT $L26105
$L26106:

; 93   : 	return C + (D - C) * (val - A) / (B - A);

	fld	DWORD PTR _D$[ebp]
	fsub	DWORD PTR _C$[ebp]
	fld	DWORD PTR _val$[ebp]
	fsub	DWORD PTR _A$[ebp]
	fmulp	ST(1), ST(0)
	fld	DWORD PTR _B$[ebp]
	fsub	DWORD PTR _A$[ebp]
	fdivp	ST(1), ST(0)
	fadd	DWORD PTR _C$[ebp]
$L26105:

; 94   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemapVal@@YAMMMMMM@Z ENDP				; RemapVal
_TEXT	ENDS
PUBLIC	??_C@_0CN@FAOJ@TrackTrain?5?$CFs?5arrived?5at?5?$CFs?0?5spe@ ; `string'
PUBLIC	?ArriveAtNode@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z ; CFuncTrackTrain::ArriveAtNode
;	COMDAT ??_C@_0CN@FAOJ@TrackTrain?5?$CFs?5arrived?5at?5?$CFs?0?5spe@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0CN@FAOJ@TrackTrain?5?$CFs?5arrived?5at?5?$CFs?0?5spe@ DB 'TrackTra'
	DB	'in %s arrived at %s, speed to %4.2f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?ArriveAtNode@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z
_TEXT	SEGMENT
_pNode$ = 8
_this$ = -4
?ArriveAtNode@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z PROC NEAR ; CFuncTrackTrain::ArriveAtNode, COMDAT

; 1822 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1823 : 	// Fire the pass target if there is one
; 1824 : 	if ( pNode->pev->message && !FBitSet( pev->spawnflags, SF_TRACKTRAIN_NO_FIRE_ON_PASS ))

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+468], 0
	je	SHORT $L38207
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 16					; 00000010H
	test	ecx, ecx
	jne	SHORT $L38207

; 1826 : 		UTIL_FireTargets( pNode->pev->message, this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+468]
	push	eax
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 1827 : 		if ( FBitSet( pNode->pev->spawnflags, SF_PATH_FIREONCE ) )

	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 2
	test	eax, eax
	je	SHORT $L38207

; 1828 : 			pNode->pev->message = NULL_STRING;

	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+468], 0
$L38207:

; 1830 : 
; 1831 : 	if ( pNode->m_iszFireFow && IsDirForward( ))

	mov	eax, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [eax+1788], 0
	je	SHORT $L38208
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDirForward@CFuncTrackTrain@@QAE_NXZ	; CFuncTrackTrain::IsDirForward
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L38208

; 1833 : 		UTIL_FireTargets( pNode->m_iszFireFow, this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR [eax+1788]
	push	ecx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L38208:

; 1835 : 
; 1836 : 	if ( pNode->m_iszFireRev && !IsDirForward())

	mov	edx, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [edx+1792], 0
	je	SHORT $L38209
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDirForward@CFuncTrackTrain@@QAE_NXZ	; CFuncTrackTrain::IsDirForward
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L38209

; 1838 : 		UTIL_FireTargets( pNode->m_iszFireRev, this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+1792]
	push	eax
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L38209:

; 1840 : 
; 1841 : 	//
; 1842 : 	// Disable train controls if this path track says to do so.
; 1843 : 	//
; 1844 : 	if( FBitSet( pNode->pev->spawnflags, SF_PATH_DISABLE_TRAIN ))

	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 8
	test	eax, eax
	je	SHORT $L38210

; 1845 : 		SetBits( pev->spawnflags, SF_TRACKTRAIN_NOCONTROL );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	or	al, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+416], eax
$L38210:

; 1846 : 			
; 1847 : 	// Don't override the train speed if it's under user control.
; 1848 : 	if ( FBitSet( pev->spawnflags, SF_TRACKTRAIN_NOCONTROL ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 2
	test	edx, edx
	je	SHORT $L38212

; 1850 : 		if ( pNode->pev->speed != 0 )

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38212

; 1852 : 			// don't copy speed from target if it is 0 (uninitialized)
; 1853 : 			SetSpeed( pNode->pev->speed );

	push	0
	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+504]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSpeed@CFuncTrackTrain@@QAEXMM@Z	; CFuncTrackTrain::SetSpeed

; 1854 : 			ALERT( at_aiconsole, "TrackTrain %s arrived at %s, speed to %4.2f\n", GetDebugName(), pNode->GetDebugName(), pNode->pev->speed );

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _pNode$[ebp]
	call	?GetDebugName@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetDebugName
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDebugName@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetDebugName
	push	eax
	push	OFFSET FLAT:??_C@_0CN@FAOJ@TrackTrain?5?$CFs?5arrived?5at?5?$CFs?0?5spe@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 24					; 00000018H
$L38212:

; 1857 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ArriveAtNode@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z ENDP ; CFuncTrackTrain::ArriveAtNode
_TEXT	ENDS
PUBLIC	??XVector@@QAEAAV0@M@Z				; Vector::operator*=
PUBLIC	?UpdateTrainVelocity@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z ; CFuncTrackTrain::UpdateTrainVelocity
PUBLIC	?SimpleSplineRemapVal@@YAMMMMMM@Z		; SimpleSplineRemapVal
EXTRN	?UTIL_Approach@@YAMMMM@Z:NEAR			; UTIL_Approach
;	COMDAT ?UpdateTrainVelocity@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z
_TEXT	SEGMENT
$T41220 = -76
$T41221 = -88
$T41222 = -100
$T41223 = -112
$T41224 = -124
$T41225 = -136
_pPrev$ = 8
_pNext$ = 12
_nextPos$ = 16
_flInterval$ = 20
_this$ = -4
_velDesired$ = -16
_flPrevSpeed$38231 = -20
_flNextSpeed$38232 = -24
_flPrevSpeed$38236 = -28
_flNextSpeed$38238 = -32
_vecSegment$38241 = -44
_flSegmentLen$38243 = -48
_vecCurOffset$38245 = -60
_p$38247 = -64
?UpdateTrainVelocity@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z PROC NEAR ; CFuncTrackTrain::UpdateTrainVelocity, COMDAT

; 1864 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1865 : 	Vector velDesired;

	lea	ecx, DWORD PTR _velDesired$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1868 : 	{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1892]
	mov	DWORD PTR -140+[ebp], ecx
	cmp	DWORD PTR -140+[ebp], 0
	je	SHORT $L38226
	cmp	DWORD PTR -140+[ebp], 0
	jle	$L38223
	cmp	DWORD PTR -140+[ebp], 2
	jle	$L38229
	jmp	$L38223
$L38226:

; 1869 : 	case TrainVelocity_Instantaneous:
; 1870 : 		velDesired = nextPos - GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	edx, DWORD PTR $T41220[ebp]
	push	edx
	mov	ecx, DWORD PTR _nextPos$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _velDesired$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _velDesired$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _velDesired$[ebp+8], eax

; 1871 : 		velDesired = velDesired.Normalize();

	lea	ecx, DWORD PTR $T41221[ebp]
	push	ecx
	lea	ecx, DWORD PTR _velDesired$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _velDesired$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _velDesired$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _velDesired$[ebp+8], edx

; 1872 : 		velDesired *= fabs( pev->speed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fst	DWORD PTR -144+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _velDesired$[ebp]
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=

; 1873 : 		SetLocalVelocity( velDesired );

	lea	edx, DWORD PTR _velDesired$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 1874 : 		break;

	jmp	$L38223
$L38229:

; 1875 : 	case TrainVelocity_LinearBlend:
; 1876 : 	case TrainVelocity_EaseInEaseOut:
; 1877 : 		if( m_flAccelSpeed != 0.0f )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1900]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38230

; 1879 : 			float flPrevSpeed = pev->speed;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	mov	DWORD PTR _flPrevSpeed$38231[ebp], eax

; 1880 : 			float flNextSpeed = m_flDesiredSpeed;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1896]
	mov	DWORD PTR _flNextSpeed$38232[ebp], edx

; 1881 : 
; 1882 : 			if( flPrevSpeed != flNextSpeed )

	fld	DWORD PTR _flPrevSpeed$38231[ebp]
	fcomp	DWORD PTR _flNextSpeed$38232[ebp]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38233

; 1884 : 				pev->speed = UTIL_Approach( m_flDesiredSpeed, pev->speed, m_flAccelSpeed * flInterval );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flInterval$[ebp]
	fmul	DWORD PTR [eax+1900]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1896]
	push	edx
	call	?UTIL_Approach@@YAMMMM@Z		; UTIL_Approach
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+504]
$L38233:

; 1887 : 		else if( pPrev && pNext )

	jmp	$L38249
$L38230:
	cmp	DWORD PTR _pPrev$[ebp], 0
	je	$L38249
	cmp	DWORD PTR _pNext$[ebp], 0
	je	$L38249

; 1889 : 			// Get the speed to blend from.
; 1890 : 			float flPrevSpeed = pev->speed;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+504]
	mov	DWORD PTR _flPrevSpeed$38236[ebp], ecx

; 1891 : 			if( pPrev->pev->speed != 0 && FBitSet( pev->spawnflags, SF_TRACKTRAIN_NOCONTROL ))

	mov	edx, DWORD PTR _pPrev$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38237
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 2
	test	eax, eax
	je	SHORT $L38237

; 1893 : 				flPrevSpeed = pPrev->pev->speed;

	mov	ecx, DWORD PTR _pPrev$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	mov	DWORD PTR _flPrevSpeed$38236[ebp], eax
$L38237:

; 1895 : 
; 1896 : 			// Get the speed to blend to.
; 1897 : 			float flNextSpeed = flPrevSpeed;

	mov	ecx, DWORD PTR _flPrevSpeed$38236[ebp]
	mov	DWORD PTR _flNextSpeed$38238[ebp], ecx

; 1898 : 			if( pNext->pev->speed != 0 && FBitSet( pev->spawnflags, SF_TRACKTRAIN_NOCONTROL ))

	mov	edx, DWORD PTR _pNext$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38239
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 2
	test	eax, eax
	je	SHORT $L38239

; 1900 : 				flNextSpeed = pNext->pev->speed;

	mov	ecx, DWORD PTR _pNext$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	mov	DWORD PTR _flNextSpeed$38238[ebp], eax
$L38239:

; 1902 : 
; 1903 : 			flNextSpeed = fabs( flNextSpeed );

	fld	DWORD PTR _flNextSpeed$38238[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _flNextSpeed$38238[ebp]

; 1904 : 			flPrevSpeed = fabs( flPrevSpeed );

	fld	DWORD PTR _flPrevSpeed$38236[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _flPrevSpeed$38236[ebp]

; 1905 : 
; 1906 : 			// If they're different, do the blend.
; 1907 : 			if( flPrevSpeed != flNextSpeed )

	fld	DWORD PTR _flPrevSpeed$38236[ebp]
	fcomp	DWORD PTR _flNextSpeed$38238[ebp]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L38240

; 1909 : 				Vector vecSegment = pNext->GetLocalOrigin() - pPrev->GetLocalOrigin();

	mov	ecx, DWORD PTR _pPrev$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	ecx, DWORD PTR $T41222[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pNext$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecSegment$38241[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1910 : 				float flSegmentLen = vecSegment.Length();

	lea	ecx, DWORD PTR _vecSegment$38241[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flSegmentLen$38243[ebp]

; 1911 : 
; 1912 : 				if( flSegmentLen )

	fld	DWORD PTR _flSegmentLen$38243[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L38244

; 1914 : 					Vector vecCurOffset = GetLocalOrigin() - pPrev->GetLocalOrigin();

	mov	ecx, DWORD PTR _pPrev$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	edx, DWORD PTR $T41223[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecCurOffset$38245[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1915 : 					float p = vecCurOffset.Length() / flSegmentLen;

	lea	ecx, DWORD PTR _vecCurOffset$38245[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fdiv	DWORD PTR _flSegmentLen$38243[ebp]
	fstp	DWORD PTR _p$38247[ebp]

; 1916 : 					if( m_eVelocityType == TrainVelocity_EaseInEaseOut )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1892], 2
	jne	SHORT $L38248

; 1918 : 						p = SimpleSplineRemapVal( p, 0.0f, 1.0f, 0.0f, 1.0f );

	push	1065353216				; 3f800000H
	push	0
	push	1065353216				; 3f800000H
	push	0
	mov	ecx, DWORD PTR _p$38247[ebp]
	push	ecx
	call	?SimpleSplineRemapVal@@YAMMMMMM@Z	; SimpleSplineRemapVal
	add	esp, 20					; 00000014H
	fstp	DWORD PTR _p$38247[ebp]
$L38248:

; 1920 : 
; 1921 : 					pev->speed = m_dir * ( flPrevSpeed * ( 1.0 - p ) + flNextSpeed * p );

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1884]
	fld	DWORD PTR _flPrevSpeed$38236[ebp]
	fld	DWORD PTR _p$38247[ebp]
	fsubr	QWORD PTR __real@8@3fff8000000000000000
	fmulp	ST(1), ST(0)
	fld	DWORD PTR _flNextSpeed$38238[ebp]
	fmul	DWORD PTR _p$38247[ebp]
	faddp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fst	DWORD PTR -148+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+504]
$L38244:

; 1924 : 			else

	jmp	SHORT $L38249
$L38240:

; 1926 : 				pev->speed = m_dir * flPrevSpeed;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flPrevSpeed$38236[ebp]
	fmul	DWORD PTR [edx+1884]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+504]
$L38249:

; 1929 : //Msg( "pev->speed %g\n", pev->speed );
; 1930 : 		velDesired = nextPos - GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	edx, DWORD PTR $T41224[ebp]
	push	edx
	mov	ecx, DWORD PTR _nextPos$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _velDesired$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _velDesired$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _velDesired$[ebp+8], eax

; 1931 : 		velDesired = velDesired.Normalize();

	lea	ecx, DWORD PTR $T41225[ebp]
	push	ecx
	lea	ecx, DWORD PTR _velDesired$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _velDesired$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _velDesired$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _velDesired$[ebp+8], edx

; 1932 : 		velDesired *= fabs( pev->speed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fst	DWORD PTR -152+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _velDesired$[ebp]
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=

; 1933 : 		SetLocalVelocity( velDesired );

	lea	edx, DWORD PTR _velDesired$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity
$L38223:

; 1936 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?UpdateTrainVelocity@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z ENDP ; CFuncTrackTrain::UpdateTrainVelocity
_TEXT	ENDS
;	COMDAT ??XVector@@QAEAAV0@M@Z
_TEXT	SEGMENT
_s$ = 8
_this$ = -4
??XVector@@QAEAAV0@M@Z PROC NEAR			; Vector::operator*=, COMDAT

; 174  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 		x *= s; y *= s; z *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 176  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 177  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??XVector@@QAEAAV0@M@Z ENDP				; Vector::operator*=
_TEXT	ENDS
PUBLIC	?SimpleSpline@@YAMM@Z				; SimpleSpline
;	COMDAT ?SimpleSplineRemapVal@@YAMMMMMM@Z
_TEXT	SEGMENT
_val$ = 8
_A$ = 12
_B$ = 16
_C$ = 20
_D$ = 24
_cVal$ = -4
?SimpleSplineRemapVal@@YAMMMMMM@Z PROC NEAR		; SimpleSplineRemapVal, COMDAT

; 237  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 238  : 	if ( A == B )

	fld	DWORD PTR _A$[ebp]
	fcomp	DWORD PTR _B$[ebp]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L26380

; 239  : 		return val >= B ? D : C;

	fld	DWORD PTR _val$[ebp]
	fcomp	DWORD PTR _B$[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L41230
	mov	eax, DWORD PTR _D$[ebp]
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L41231
$L41230:
	mov	ecx, DWORD PTR _C$[ebp]
	mov	DWORD PTR -8+[ebp], ecx
$L41231:
	fld	DWORD PTR -8+[ebp]
	jmp	SHORT $L26379
$L26380:

; 240  : 	float cVal = (val - A) / (B - A);

	fld	DWORD PTR _val$[ebp]
	fsub	DWORD PTR _A$[ebp]
	fld	DWORD PTR _B$[ebp]
	fsub	DWORD PTR _A$[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _cVal$[ebp]

; 241  : 	return C + (D - C) * SimpleSpline( cVal );

	fld	DWORD PTR _D$[ebp]
	fsub	DWORD PTR _C$[ebp]
	fstp	DWORD PTR -12+[ebp]
	mov	edx, DWORD PTR _cVal$[ebp]
	push	edx
	call	?SimpleSpline@@YAMM@Z			; SimpleSpline
	add	esp, 4
	fmul	DWORD PTR -12+[ebp]
	fadd	DWORD PTR _C$[ebp]
$L26379:

; 242  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SimpleSplineRemapVal@@YAMMMMMM@Z ENDP			; SimpleSplineRemapVal
_TEXT	ENDS
PUBLIC	__real@4@4000c000000000000000
;	COMDAT __real@4@4000c000000000000000
; File z:\xashxtsrc\game_shared\mathlib.h
CONST	SEGMENT
__real@4@4000c000000000000000 DD 040400000r	; 3
CONST	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT
_value$ = 8
_valueSquared$ = -4
?SimpleSpline@@YAMM@Z PROC NEAR				; SimpleSpline, COMDAT

; 229  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 230  : 	float valueSquared = value * value;

	fld	DWORD PTR _value$[ebp]
	fmul	DWORD PTR _value$[ebp]
	fstp	DWORD PTR _valueSquared$[ebp]

; 231  : 
; 232  : 	// Nice little ease-in, ease-out spline-like curve
; 233  : 	return (3 * valueSquared - 2 * valueSquared * value);

	fld	DWORD PTR __real@4@4000c000000000000000
	fmul	DWORD PTR _valueSquared$[ebp]
	fld	DWORD PTR __real@4@40008000000000000000
	fmul	DWORD PTR _valueSquared$[ebp]
	fmul	DWORD PTR _value$[ebp]
	fsubp	ST(1), ST(0)

; 234  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SimpleSpline@@YAMM@Z ENDP				; SimpleSpline
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??UpdateTrainOrientation@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z@4FA ; `CFuncTrackTrain::UpdateTrainOrientation'::`2'::__LINE__Var
PUBLIC	??_C@_0DH@LFPB@?$CBpPrev?5?$HM?$HM?5?$CIpPrev?9?$DOm_hParent?4Get?$CI@ ; `string'
PUBLIC	?UpdateTrainOrientation@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z ; CFuncTrackTrain::UpdateTrainOrientation
PUBLIC	?UpdateOrientationAtPathTracks@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z ; CFuncTrackTrain::UpdateOrientationAtPathTracks
PUBLIC	?UpdateOrientationBlend@CFuncTrackTrain@@QAEXHPAVCPathTrack@@0ABVVector@@M@Z ; CFuncTrackTrain::UpdateOrientationBlend
EXTRN	__assert:NEAR
;	COMDAT ?__LINE__Var@?1??UpdateTrainOrientation@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z@4FA
; File z:\xashxtsrc\server\plats.cpp
_DATA	SEGMENT
?__LINE__Var@?1??UpdateTrainOrientation@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z@4FA DW 0797H ; `CFuncTrackTrain::UpdateTrainOrientation'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DH@LFPB@?$CBpPrev?5?$HM?$HM?5?$CIpPrev?9?$DOm_hParent?4Get?$CI@
CONST	SEGMENT
??_C@_0DH@LFPB@?$CBpPrev?5?$HM?$HM?5?$CIpPrev?9?$DOm_hParent?4Get?$CI@ DB '!'
	DB	'pPrev || (pPrev->m_hParent.Get() == m_hParent.Get() )', 00H ; `string'
CONST	ENDS
;	COMDAT ?UpdateTrainOrientation@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z
_TEXT	SEGMENT
_pPrev$ = 8
_pNext$ = 12
_nextPos$ = 16
_flInterval$ = 20
_this$ = -4
?UpdateTrainOrientation@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z PROC NEAR ; CFuncTrackTrain::UpdateTrainOrientation, COMDAT

; 1943 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1944 : 	// Trains *can* work in local space, but only if all elements of the track share
; 1945 : 	// the same move parent as the train.
; 1946 : 	assert( !pPrev || (pPrev->m_hParent.Get() == m_hParent.Get() ) );

	cmp	DWORD PTR _pPrev$[ebp], 0
	je	SHORT $L41238
	mov	ecx, DWORD PTR _pPrev$[ebp]
	add	ecx, 148				; 00000094H
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	cmp	esi, eax
	je	SHORT $L41238
	movsx	eax, WORD PTR ?__LINE__Var@?1??UpdateTrainOrientation@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z@4FA ; `CFuncTrackTrain::UpdateTrainOrientation'::`2'::__LINE__Var
	add	eax, 3
	push	eax
	push	OFFSET FLAT:??_C@_0BO@NJDE@z?3?2xashxtsrc?2server?2plats?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0DH@LFPB@?$CBpPrev?5?$HM?$HM?5?$CIpPrev?9?$DOm_hParent?4Get?$CI@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41238:

; 1949 : 	{

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1888]
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L38267
	cmp	DWORD PTR -8+[ebp], 1
	jle	SHORT $L38263
	cmp	DWORD PTR -8+[ebp], 3
	jle	SHORT $L38268
	jmp	SHORT $L38263
$L38267:

; 1950 : 	case TrainOrientation_Fixed:
; 1951 : 		// Fixed orientation. Do nothing.
; 1952 : 		break;
; 1953 : 	case TrainOrientation_AtPathTracks:
; 1954 : 		UpdateOrientationAtPathTracks( pPrev, pNext, nextPos, flInterval );

	mov	ecx, DWORD PTR _flInterval$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nextPos$[ebp]
	push	edx
	mov	eax, DWORD PTR _pNext$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPrev$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateOrientationAtPathTracks@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z ; CFuncTrackTrain::UpdateOrientationAtPathTracks

; 1955 : 		break;

	jmp	SHORT $L38263
$L38268:

; 1956 : 	case TrainOrientation_EaseInEaseOut:
; 1957 : 	case TrainOrientation_LinearBlend:
; 1958 : 		UpdateOrientationBlend( m_eOrientationType, pPrev, pNext, nextPos, flInterval );

	mov	edx, DWORD PTR _flInterval$[ebp]
	push	edx
	mov	eax, DWORD PTR _nextPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPrev$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1888]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateOrientationBlend@CFuncTrackTrain@@QAEXHPAVCPathTrack@@0ABVVector@@M@Z ; CFuncTrackTrain::UpdateOrientationBlend
$L38263:

; 1961 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?UpdateTrainOrientation@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z ENDP ; CFuncTrackTrain::UpdateTrainOrientation
_TEXT	ENDS
PUBLIC	__real@4@4006b400000000000000
PUBLIC	?GetOrientationType@CPathTrack@@QAEHXZ		; CPathTrack::GetOrientationType
PUBLIC	?DoUpdateOrientation@CFuncTrackTrain@@QAEXABVVector@@0M@Z ; CFuncTrackTrain::DoUpdateOrientation
EXTRN	?GetOrientation@CPathTrack@@QAE?AVVector@@_N@Z:NEAR ; CPathTrack::GetOrientation
EXTRN	?LookAhead@CPathTrack@@QAEPAV1@AAVVector@@MHPAPAV1@@Z:NEAR ; CPathTrack::LookAhead
EXTRN	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z:NEAR	; UTIL_VecToAngles
;	COMDAT __real@4@4006b400000000000000
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
__real@4@4006b400000000000000 DD 043340000r	; 180
CONST	ENDS
;	COMDAT ?UpdateOrientationAtPathTracks@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z
_TEXT	SEGMENT
$T41245 = -68
$T41246 = -80
$T41247 = -92
_pPrev$ = 8
_flInterval$ = 20
_this$ = -4
_nextFront$ = -16
_pNextNode$ = -20
_vecFaceDir$ = -32
_angles$ = -44
_curAngles$ = -56
?UpdateOrientationAtPathTracks@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z PROC NEAR ; CFuncTrackTrain::UpdateOrientationAtPathTracks, COMDAT

; 1970 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1971 : 	if( !m_ppath )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $L38276

; 1972 : 		return;

	jmp	$L38275
$L38276:

; 1973 : 
; 1974 : 	Vector nextFront = GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	ecx, DWORD PTR _nextFront$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1975 : 	CPathTrack *pNextNode = NULL;

	mov	DWORD PTR _pNextNode$[ebp], 0

; 1976 : 
; 1977 : 	nextFront.z -= m_height;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _nextFront$[ebp+8]
	fsub	DWORD PTR [ecx+1808]
	fstp	DWORD PTR _nextFront$[ebp+8]

; 1978 : 	if ( m_length > 0 )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1804]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38279

; 1980 : 		m_ppath->LookAhead( nextFront, IsDirForward() ? m_length : -m_length, 0, &pNextNode );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDirForward@CFuncTrackTrain@@QAE_NXZ	; CFuncTrackTrain::IsDirForward
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41241
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1804]
	mov	DWORD PTR -96+[ebp], ecx
	jmp	SHORT $L41242
$L41241:
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1804]
	fchs
	fstp	DWORD PTR -96+[ebp]
$L41242:
	lea	eax, DWORD PTR _pNextNode$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR -96+[ebp]
	push	ecx
	lea	edx, DWORD PTR _nextFront$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1796]
	call	?LookAhead@CPathTrack@@QAEPAV1@AAVVector@@MHPAPAV1@@Z ; CPathTrack::LookAhead

; 1982 : 	else

	jmp	SHORT $L38280
$L38279:

; 1984 : 		m_ppath->LookAhead( nextFront, IsDirForward() ? 100.0f : -100.0f, 0, &pNextNode );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDirForward@CFuncTrackTrain@@QAE_NXZ	; CFuncTrackTrain::IsDirForward
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41243
	mov	DWORD PTR -100+[ebp], 1120403456	; 42c80000H
	jmp	SHORT $L41244
$L41243:
	mov	DWORD PTR -100+[ebp], -1027080192	; c2c80000H
$L41244:
	lea	ecx, DWORD PTR _pNextNode$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR -100+[ebp]
	push	edx
	lea	eax, DWORD PTR _nextFront$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1796]
	call	?LookAhead@CPathTrack@@QAEPAV1@AAVVector@@MHPAPAV1@@Z ; CPathTrack::LookAhead
$L38280:

; 1986 : 	nextFront.z += m_height;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _nextFront$[ebp+8]
	fadd	DWORD PTR [edx+1808]
	fstp	DWORD PTR _nextFront$[ebp+8]

; 1987 : 
; 1988 : 	Vector vecFaceDir = nextFront - GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	eax, DWORD PTR $T41245[ebp]
	push	eax
	lea	ecx, DWORD PTR _nextFront$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecFaceDir$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1989 : 	if ( !IsDirForward() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDirForward@CFuncTrackTrain@@QAE_NXZ	; CFuncTrackTrain::IsDirForward
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L38283

; 1991 : 		vecFaceDir *= -1;

	push	-1082130432				; bf800000H
	lea	ecx, DWORD PTR _vecFaceDir$[ebp]
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=
$L38283:

; 1993 : 
; 1994 : 	Vector angles = UTIL_VecToAngles( vecFaceDir );

	lea	ecx, DWORD PTR _vecFaceDir$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41246[ebp]
	push	edx
	call	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z	; UTIL_VecToAngles
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1995 : 	angles.x = -angles.x;

	fld	DWORD PTR _angles$[ebp]
	fchs
	fstp	DWORD PTR _angles$[ebp]

; 1996 : 	// The train actually points west
; 1997 : 	angles.y += 180;

	fld	DWORD PTR _angles$[ebp+4]
	fadd	DWORD PTR __real@4@4006b400000000000000
	fstp	DWORD PTR _angles$[ebp+4]

; 1998 : 
; 1999 : 	// Wrapped with this bool so we don't affect old trains
; 2000 : 	if( FBitSet( pev->spawnflags, SF_TRACKTRAIN_NOCONTROL ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 2
	test	edx, edx
	je	SHORT $L38287

; 2002 : 		if( pNextNode && pNextNode->GetOrientationType() == TrackOrientation_FacePathAngles )

	cmp	DWORD PTR _pNextNode$[ebp], 0
	je	SHORT $L38287
	mov	ecx, DWORD PTR _pNextNode$[ebp]
	call	?GetOrientationType@CPathTrack@@QAEHXZ	; CPathTrack::GetOrientationType
	cmp	eax, 2
	jne	SHORT $L38287

; 2004 : 			angles = pNextNode->GetOrientation( IsDirForward() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDirForward@CFuncTrackTrain@@QAE_NXZ	; CFuncTrackTrain::IsDirForward
	push	eax
	lea	eax, DWORD PTR $T41247[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNextNode$[ebp]
	call	?GetOrientation@CPathTrack@@QAE?AVVector@@_N@Z ; CPathTrack::GetOrientation
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _angles$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _angles$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _angles$[ebp+8], eax
$L38287:

; 2007 : 
; 2008 : 	Vector curAngles = GetLocalAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	lea	ecx, DWORD PTR _curAngles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2009 : 
; 2010 : 	if ( !pPrev || (vecFaceDir.x == 0 && vecFaceDir.y == 0) )

	cmp	DWORD PTR _pPrev$[ebp], 0
	je	SHORT $L38291
	fld	DWORD PTR _vecFaceDir$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38290
	fld	DWORD PTR _vecFaceDir$[ebp+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38290
$L38291:

; 2011 : 		angles = curAngles;

	mov	ecx, DWORD PTR _curAngles$[ebp]
	mov	DWORD PTR _angles$[ebp], ecx
	mov	edx, DWORD PTR _curAngles$[ebp+4]
	mov	DWORD PTR _angles$[ebp+4], edx
	mov	eax, DWORD PTR _curAngles$[ebp+8]
	mov	DWORD PTR _angles$[ebp+8], eax
$L38290:

; 2012 : 
; 2013 : 	DoUpdateOrientation( curAngles, angles, flInterval );

	mov	ecx, DWORD PTR _flInterval$[ebp]
	push	ecx
	lea	edx, DWORD PTR _angles$[ebp]
	push	edx
	lea	eax, DWORD PTR _curAngles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoUpdateOrientation@CFuncTrackTrain@@QAEXABVVector@@0M@Z ; CFuncTrackTrain::DoUpdateOrientation
$L38275:

; 2014 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?UpdateOrientationAtPathTracks@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z ENDP ; CFuncTrackTrain::UpdateOrientationAtPathTracks
_TEXT	ENDS
;	COMDAT ?GetOrientationType@CPathTrack@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetOrientationType@CPathTrack@@QAEHXZ PROC NEAR	; CPathTrack::GetOrientationType, COMDAT

; 80   : 	int		GetOrientationType( void ) { return m_eOrientationType; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1784]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOrientationType@CPathTrack@@QAEHXZ ENDP		; CPathTrack::GetOrientationType
_TEXT	ENDS
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	??0Vector4D@@QAE@XZ				; Vector4D::Vector4D
EXTRN	?AngleQuaternion@@YAXABVVector@@AAVVector4D@@@Z:NEAR ; AngleQuaternion
EXTRN	?QuaternionAngle@@YAXABVVector4D@@AAVVector@@@Z:NEAR ; QuaternionAngle
EXTRN	?QuaternionSlerp@@YAXABVVector4D@@0MAAV1@@Z:NEAR ; QuaternionSlerp
EXTRN	?QuaternionAngleDiff@@YAMABVVector4D@@0@Z:NEAR	; QuaternionAngleDiff
;	COMDAT ?UpdateOrientationBlend@CFuncTrackTrain@@QAEXHPAVCPathTrack@@0ABVVector@@M@Z
_TEXT	SEGMENT
$T41254 = -124
$T41255 = -136
$T41256 = -148
_eOrientationType$ = 8
_pPrev$ = 12
_pNext$ = 16
_flInterval$ = 24
_this$ = -4
_angPrev$ = -16
_angNext$ = -28
_p$ = -32
_vecSegment$38309 = -44
_flSegmentLen$38311 = -48
_qtPrev$ = -64
_qtNext$ = -80
_angNew$ = -92
_flAngleDiff$ = -96
_qtNew$38319 = -112
?UpdateOrientationBlend@CFuncTrackTrain@@QAEXHPAVCPathTrack@@0ABVVector@@M@Z PROC NEAR ; CFuncTrackTrain::UpdateOrientationBlend, COMDAT

; 2023 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2024 : 	// Get the angles to blend from.
; 2025 : 	Vector angPrev = pPrev->GetOrientation( IsDirForward() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDirForward@CFuncTrackTrain@@QAE_NXZ	; CFuncTrackTrain::IsDirForward
	push	eax
	lea	eax, DWORD PTR $T41254[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPrev$[ebp]
	call	?GetOrientation@CPathTrack@@QAE?AVVector@@_N@Z ; CPathTrack::GetOrientation
	push	eax
	lea	ecx, DWORD PTR _angPrev$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2026 : 
; 2027 : 	// Get the angles to blend to. 
; 2028 : 	Vector angNext;

	lea	ecx, DWORD PTR _angNext$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2029 : 	if ( pNext )

	cmp	DWORD PTR _pNext$[ebp], 0
	je	SHORT $L38303

; 2031 : 		angNext = pNext->GetOrientation( IsDirForward() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDirForward@CFuncTrackTrain@@QAE_NXZ	; CFuncTrackTrain::IsDirForward
	push	eax
	lea	ecx, DWORD PTR $T41255[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pNext$[ebp]
	call	?GetOrientation@CPathTrack@@QAE?AVVector@@_N@Z ; CPathTrack::GetOrientation
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _angNext$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _angNext$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _angNext$[ebp+8], edx

; 2033 : 	else

	jmp	SHORT $L38305
$L38303:

; 2035 : 		// At a dead end, just use the last path track's angles.
; 2036 : 		angNext = angPrev;

	mov	eax, DWORD PTR _angPrev$[ebp]
	mov	DWORD PTR _angNext$[ebp], eax
	mov	ecx, DWORD PTR _angPrev$[ebp+4]
	mov	DWORD PTR _angNext$[ebp+4], ecx
	mov	edx, DWORD PTR _angPrev$[ebp+8]
	mov	DWORD PTR _angNext$[ebp+8], edx
$L38305:

; 2038 : 
; 2039 : 	if ( FBitSet( pev->spawnflags, SF_TRACKTRAIN_NOPITCH ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1
	test	edx, edx
	je	SHORT $L38306

; 2041 : 		angNext[PITCH] = angPrev[PITCH];

	lea	ecx, DWORD PTR _angPrev$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	lea	ecx, DWORD PTR _angNext$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
$L38306:

; 2043 : 
; 2044 : 	// Calculate our parametric distance along the path segment from 0 to 1.
; 2045 : 	float p = 0;

	mov	DWORD PTR _p$[ebp], 0

; 2046 : 	if( pPrev && ( angPrev != angNext ) )

	cmp	DWORD PTR _pPrev$[ebp], 0
	je	SHORT $L38312
	lea	edx, DWORD PTR _angNext$[ebp]
	push	edx
	lea	ecx, DWORD PTR _angPrev$[ebp]
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L38312

; 2048 : 		Vector vecSegment = pNext->GetLocalOrigin() - pPrev->GetLocalOrigin();

	mov	ecx, DWORD PTR _pPrev$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	eax, DWORD PTR $T41256[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNext$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecSegment$38309[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2049 : 		float flSegmentLen = vecSegment.Length();

	lea	ecx, DWORD PTR _vecSegment$38309[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flSegmentLen$38311[ebp]

; 2050 : 		if( flSegmentLen ) p = m_flReachedDist / flSegmentLen;

	fld	DWORD PTR _flSegmentLen$38311[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38312
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1904]
	fdiv	DWORD PTR _flSegmentLen$38311[ebp]
	fstp	DWORD PTR _p$[ebp]
$L38312:

; 2052 : 
; 2053 : 	if ( eOrientationType == TrainOrientation_EaseInEaseOut )

	cmp	DWORD PTR _eOrientationType$[ebp], 3
	jne	SHORT $L38313

; 2055 : 		p = SimpleSplineRemapVal( p, 0.0f, 1.0f, 0.0f, 1.0f );

	push	1065353216				; 3f800000H
	push	0
	push	1065353216				; 3f800000H
	push	0
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?SimpleSplineRemapVal@@YAMMMMMM@Z	; SimpleSplineRemapVal
	add	esp, 20					; 00000014H
	fstp	DWORD PTR _p$[ebp]
$L38313:

; 2057 : 
; 2058 : //	Msg( "UpdateOrientationFacePathAngles: %s->%s, p=%f\n", pPrev->GetDebugName(), pNext->GetDebugName(), p );
; 2059 : 
; 2060 : 	Vector4D qtPrev;

	lea	ecx, DWORD PTR _qtPrev$[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 2061 : 	Vector4D qtNext;

	lea	ecx, DWORD PTR _qtNext$[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 2062 : 	
; 2063 : 	AngleQuaternion( angPrev, qtPrev );

	lea	eax, DWORD PTR _qtPrev$[ebp]
	push	eax
	lea	ecx, DWORD PTR _angPrev$[ebp]
	push	ecx
	call	?AngleQuaternion@@YAXABVVector@@AAVVector4D@@@Z ; AngleQuaternion
	add	esp, 8

; 2064 : 	AngleQuaternion( angNext, qtNext );

	lea	edx, DWORD PTR _qtNext$[ebp]
	push	edx
	lea	eax, DWORD PTR _angNext$[ebp]
	push	eax
	call	?AngleQuaternion@@YAXABVVector@@AAVVector4D@@@Z ; AngleQuaternion
	add	esp, 8

; 2065 : 
; 2066 : 	Vector angNew = angNext;

	lea	ecx, DWORD PTR _angNext$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _angNew$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2067 : 	float flAngleDiff = QuaternionAngleDiff( qtPrev, qtNext );

	lea	edx, DWORD PTR _qtNext$[ebp]
	push	edx
	lea	eax, DWORD PTR _qtPrev$[ebp]
	push	eax
	call	?QuaternionAngleDiff@@YAMABVVector4D@@0@Z ; QuaternionAngleDiff
	add	esp, 8
	fstp	DWORD PTR _flAngleDiff$[ebp]

; 2068 : 	if( flAngleDiff )

	fld	DWORD PTR _flAngleDiff$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38318

; 2070 : 		Vector4D qtNew;

	lea	ecx, DWORD PTR _qtNew$38319[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 2071 : 		QuaternionSlerp( qtPrev, qtNext, p, qtNew );

	lea	ecx, DWORD PTR _qtNew$38319[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	lea	eax, DWORD PTR _qtNext$[ebp]
	push	eax
	lea	ecx, DWORD PTR _qtPrev$[ebp]
	push	ecx
	call	?QuaternionSlerp@@YAXABVVector4D@@0MAAV1@@Z ; QuaternionSlerp
	add	esp, 16					; 00000010H

; 2072 : 		QuaternionAngle( qtNew, angNew );

	lea	edx, DWORD PTR _angNew$[ebp]
	push	edx
	lea	eax, DWORD PTR _qtNew$38319[ebp]
	push	eax
	call	?QuaternionAngle@@YAXABVVector4D@@AAVVector@@@Z ; QuaternionAngle
	add	esp, 8
$L38318:

; 2074 : 
; 2075 : 	if ( FBitSet( pev->spawnflags, SF_TRACKTRAIN_NOPITCH ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 1
	test	eax, eax
	je	SHORT $L38320

; 2077 : 		angNew[PITCH] = angPrev[PITCH];

	lea	ecx, DWORD PTR _angPrev$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	lea	ecx, DWORD PTR _angNew$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
$L38320:

; 2079 : 
; 2080 : 	angNew.x = -angNew.x;

	fld	DWORD PTR _angNew$[ebp]
	fchs
	fstp	DWORD PTR _angNew$[ebp]

; 2081 : 	DoUpdateOrientation( GetLocalAngles(), angNew, flInterval );

	mov	edx, DWORD PTR _flInterval$[ebp]
	push	edx
	lea	eax, DWORD PTR _angNew$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoUpdateOrientation@CFuncTrackTrain@@QAEXABVVector@@0M@Z ; CFuncTrackTrain::DoUpdateOrientation

; 2082 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?UpdateOrientationBlend@CFuncTrackTrain@@QAEXHPAVCPathTrack@@0ABVVector@@M@Z ENDP ; CFuncTrackTrain::UpdateOrientationBlend
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector4D@@QAE@XZ PROC NEAR				; Vector4D::Vector4D, COMDAT

; 311  : 	inline Vector4D( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector4D@@QAE@XZ ENDP				; Vector4D::Vector4D
_TEXT	ENDS
PUBLIC	__real@8@3ffbccccccccccccd000
PUBLIC	__real@4@c001a000000000000000
PUBLIC	__real@4@4001a000000000000000
EXTRN	?UTIL_ApproachAngle@@YAMMMM@Z:NEAR		; UTIL_ApproachAngle
EXTRN	?UTIL_AngleDistance@@YAMMM@Z:NEAR		; UTIL_AngleDistance
EXTRN	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAvelocity
;	COMDAT __real@8@3ffbccccccccccccd000
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
__real@8@3ffbccccccccccccd000 DQ 03fb999999999999ar ; 0.1
CONST	ENDS
;	COMDAT __real@4@c001a000000000000000
CONST	SEGMENT
__real@4@c001a000000000000000 DD 0c0a00000r	; -5
CONST	ENDS
;	COMDAT __real@4@4001a000000000000000
CONST	SEGMENT
__real@4@4001a000000000000000 DD 040a00000r	; 5
CONST	ENDS
;	COMDAT ?DoUpdateOrientation@CFuncTrackTrain@@QAEXABVVector@@0M@Z
_TEXT	SEGMENT
_curAngles$ = 8
_angles$ = 12
_flInterval$ = 16
_this$ = -4
_vy$ = -8
_vx$ = -12
_vecAngVel$ = -24
?DoUpdateOrientation@CFuncTrackTrain@@QAEXABVVector@@0M@Z PROC NEAR ; CFuncTrackTrain::DoUpdateOrientation, COMDAT

; 2089 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2090 : 	float vy, vx;
; 2091 : 	if ( !FBitSet( pev->spawnflags, SF_TRACKTRAIN_NOPITCH ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1
	test	edx, edx
	jne	SHORT $L38329

; 2093 : 		vx = UTIL_AngleDistance( Fix( angles.x ), Fix( curAngles.x ));

	mov	eax, DWORD PTR _curAngles$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Fix@@YAMM@Z				; Fix
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?Fix@@YAMM@Z				; Fix
	fstp	DWORD PTR [esp]
	call	?UTIL_AngleDistance@@YAMMM@Z		; UTIL_AngleDistance
	add	esp, 8
	fstp	DWORD PTR _vx$[ebp]

; 2095 : 	else

	jmp	SHORT $L38330
$L38329:

; 2097 : 		vx = 0;

	mov	DWORD PTR _vx$[ebp], 0
$L38330:

; 2099 : 
; 2100 : 	vy = UTIL_AngleDistance( Fix( angles.y ), Fix( curAngles.y ));

	mov	ecx, DWORD PTR _curAngles$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?Fix@@YAMM@Z				; Fix
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?Fix@@YAMM@Z				; Fix
	fstp	DWORD PTR [esp]
	call	?UTIL_AngleDistance@@YAMMM@Z		; UTIL_AngleDistance
	add	esp, 8
	fstp	DWORD PTR _vy$[ebp]

; 2101 : 	
; 2102 : 	// HACKHACK: Clamp really small angular deltas to avoid rotating movement on things
; 2103 : 	// that are close enough
; 2104 : 	if ( fabs(vx) < 0.1 )

	fld	DWORD PTR _vx$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3ffbccccccccccccd000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38331

; 2106 : 		vx = 0;

	mov	DWORD PTR _vx$[ebp], 0
$L38331:

; 2108 : 	if ( fabs(vy) < 0.1 )

	fld	DWORD PTR _vy$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3ffbccccccccccccd000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38332

; 2110 : 		vy = 0;

	mov	DWORD PTR _vy$[ebp], 0
$L38332:

; 2112 : 
; 2113 : 	if ( flInterval == 0 )

	fld	DWORD PTR _flInterval$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38333

; 2115 : 		// Avoid dividing by zero
; 2116 : 		flInterval = 0.1;

	mov	DWORD PTR _flInterval$[ebp], 1036831949	; 3dcccccdH
$L38333:

; 2118 : 
; 2119 : 	Vector vecAngVel( vx / flInterval, vy / flInterval, GetLocalAvelocity().z );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	edx, DWORD PTR [eax+8]
	push	edx
	fld	DWORD PTR _vy$[ebp]
	fdiv	DWORD PTR _flInterval$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _vx$[ebp]
	fdiv	DWORD PTR _flInterval$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _vecAngVel$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 2120 : 
; 2121 : 	if ( m_flBank != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1876]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L38339

; 2123 : 		if ( vecAngVel.y < -5 )

	fld	DWORD PTR _vecAngVel$[ebp+4]
	fcomp	DWORD PTR __real@4@c001a000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38336

; 2125 : 			vecAngVel.z = UTIL_AngleDistance( UTIL_ApproachAngle( -m_flBank, curAngles.z, m_flBank * 2 ), curAngles.z );

	mov	ecx, DWORD PTR _curAngles$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1876]
	fadd	ST(0), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _curAngles$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1876]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	call	?UTIL_ApproachAngle@@YAMMMM@Z		; UTIL_ApproachAngle
	add	esp, 8
	fstp	DWORD PTR [esp]
	call	?UTIL_AngleDistance@@YAMMM@Z		; UTIL_AngleDistance
	add	esp, 8
	fstp	DWORD PTR _vecAngVel$[ebp+8]

; 2127 : 		else if ( vecAngVel.y > 5 )

	jmp	$L38339
$L38336:
	fld	DWORD PTR _vecAngVel$[ebp+4]
	fcomp	DWORD PTR __real@4@4001a000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38338

; 2129 : 			vecAngVel.z = UTIL_AngleDistance( UTIL_ApproachAngle( m_flBank, curAngles.z, m_flBank * 2 ), curAngles.z );

	mov	ecx, DWORD PTR _curAngles$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1876]
	fadd	ST(0), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _curAngles$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1876]
	push	ecx
	call	?UTIL_ApproachAngle@@YAMMMM@Z		; UTIL_ApproachAngle
	add	esp, 8
	fstp	DWORD PTR [esp]
	call	?UTIL_AngleDistance@@YAMMM@Z		; UTIL_AngleDistance
	add	esp, 8
	fstp	DWORD PTR _vecAngVel$[ebp+8]

; 2131 : 		else

	jmp	SHORT $L38339
$L38338:

; 2133 : 			vecAngVel.z = UTIL_AngleDistance( UTIL_ApproachAngle( 0, curAngles.z, m_flBank * 4 ), curAngles.z ) * 4;

	mov	edx, DWORD PTR _curAngles$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1876]
	fmul	DWORD PTR __real@4@40018000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _curAngles$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	0
	call	?UTIL_ApproachAngle@@YAMMMM@Z		; UTIL_ApproachAngle
	add	esp, 8
	fstp	DWORD PTR [esp]
	call	?UTIL_AngleDistance@@YAMMM@Z		; UTIL_AngleDistance
	add	esp, 8
	fmul	DWORD PTR __real@4@40018000000000000000
	fstp	DWORD PTR _vecAngVel$[ebp+8]
$L38339:

; 2136 : 
; 2137 : 	SetLocalAvelocity( vecAngVel );

	lea	ecx, DWORD PTR _vecAngVel$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 2138 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DoUpdateOrientation@CFuncTrackTrain@@QAEXABVVector@@0M@Z ENDP ; CFuncTrackTrain::DoUpdateOrientation
_TEXT	ENDS
PUBLIC	__real@4@4007b400000000000000
;	COMDAT __real@4@4007b400000000000000
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
__real@4@4007b400000000000000 DD 043b40000r	; 360
CONST	ENDS
;	COMDAT ?Fix@@YAMM@Z
_TEXT	SEGMENT
_angle$ = 8
?Fix@@YAMM@Z PROC NEAR					; Fix, COMDAT

; 1753 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L38169:

; 1754 : 	while ( angle < 0 )

	fld	DWORD PTR _angle$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38170

; 1755 : 		angle += 360;

	fld	DWORD PTR _angle$[ebp]
	fadd	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _angle$[ebp]
	jmp	SHORT $L38169
$L38170:

; 1756 : 	while ( angle > 360 )

	fld	DWORD PTR _angle$[ebp]
	fcomp	DWORD PTR __real@4@4007b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38173

; 1757 : 		angle -= 360;

	fld	DWORD PTR _angle$[ebp]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _angle$[ebp]
	jmp	SHORT $L38170
$L38173:

; 1758 : 
; 1759 : 	return angle;

	fld	DWORD PTR _angle$[ebp]

; 1760 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Fix@@YAMM@Z ENDP					; Fix
_TEXT	ENDS
PUBLIC	?TeleportToPathTrack@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z ; CFuncTrackTrain::TeleportToPathTrack
;	COMDAT ?TeleportToPathTrack@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z
_TEXT	SEGMENT
$T41277 = -64
_pTeleport$ = 8
_this$ = -4
_angCur$ = -16
_nextPos$ = -28
_look$ = -40
_nextAngles$ = -52
?TeleportToPathTrack@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z PROC NEAR ; CFuncTrackTrain::TeleportToPathTrack, COMDAT

; 2141 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2142 : 	Vector angCur = GetLocalAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	lea	ecx, DWORD PTR _angCur$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2143 : 
; 2144 : 	Vector nextPos = pTeleport->GetLocalOrigin();

	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	ecx, DWORD PTR _nextPos$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2145 : 	Vector look = nextPos;

	lea	eax, DWORD PTR _nextPos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _look$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2146 : 	pTeleport->LookAhead( look, m_length, 0 );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1804]
	push	edx
	lea	eax, DWORD PTR _look$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?LookAhead@CPathTrack@@QAEPAV1@AAVVector@@MHPAPAV1@@Z ; CPathTrack::LookAhead

; 2147 : 
; 2148 : 	Vector nextAngles;

	lea	ecx, DWORD PTR _nextAngles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2149 : 	if( look == nextPos )

	lea	ecx, DWORD PTR _nextPos$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _look$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L38348

; 2151 : 		nextAngles = GetLocalAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _nextAngles$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nextAngles$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _nextAngles$[ebp+8], edx

; 2153 : 	else

	jmp	SHORT $L38351
$L38348:

; 2155 : 		nextAngles = pTeleport->GetOrientation(( pev->speed > 0 ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41275
	mov	DWORD PTR -68+[ebp], 1
	jmp	SHORT $L41276
$L41275:
	mov	DWORD PTR -68+[ebp], 0
$L41276:
	mov	dl, BYTE PTR -68+[ebp]
	push	edx
	lea	eax, DWORD PTR $T41277[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?GetOrientation@CPathTrack@@QAE?AVVector@@_N@Z ; CPathTrack::GetOrientation
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nextAngles$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _nextAngles$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _nextAngles$[ebp+8], eax

; 2156 : 		if( FBitSet( pev->spawnflags, SF_TRACKTRAIN_NOPITCH ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 1
	test	eax, eax
	je	SHORT $L38351

; 2158 : 			nextAngles[PITCH] = angCur[PITCH];

	lea	ecx, DWORD PTR _angCur$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	lea	ecx, DWORD PTR _nextAngles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
$L38351:

; 2161 : 
; 2162 : 	Teleport( &pTeleport->GetLocalOrigin(), &nextAngles, NULL );

	push	0
	lea	edx, DWORD PTR _nextAngles$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z ; CBaseEntity::Teleport

; 2163 : 	SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 2164 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?TeleportToPathTrack@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z ENDP ; CFuncTrackTrain::TeleportToPathTrack
_TEXT	ENDS
PUBLIC	??_C@_0BH@LMCO@TRAIN?$CI?$CFs?$CJ?3?5Speed?5is?50?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@FNFN@TRAIN?$CI?$CFs?$CJ?3?5Lost?5path?6?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??Next@CFuncTrackTrain@@QAEXXZ@4FA ; `CFuncTrackTrain::Next'::`2'::__LINE__Var
PUBLIC	??_C@_0DI@MBML@?$CBpNext?5?$HM?$HM?5?$CI?5pNext?9?$DOm_hParent?4Get@ ; `string'
;	COMDAT ?__LINE__Var@?1??Next@CFuncTrackTrain@@QAEXXZ@4FA
; File z:\xashxtsrc\server\plats.cpp
_DATA	SEGMENT
?__LINE__Var@?1??Next@CFuncTrackTrain@@QAEXXZ@4FA DW 0877H ; `CFuncTrackTrain::Next'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BH@LMCO@TRAIN?$CI?$CFs?$CJ?3?5Speed?5is?50?6?$AA@
CONST	SEGMENT
??_C@_0BH@LMCO@TRAIN?$CI?$CFs?$CJ?3?5Speed?5is?50?6?$AA@ DB 'TRAIN(%s): S'
	DB	'peed is 0', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FNFN@TRAIN?$CI?$CFs?$CJ?3?5Lost?5path?6?$AA@
CONST	SEGMENT
??_C@_0BG@FNFN@TRAIN?$CI?$CFs?$CJ?3?5Lost?5path?6?$AA@ DB 'TRAIN(%s): Los'
	DB	't path', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MBML@?$CBpNext?5?$HM?$HM?5?$CI?5pNext?9?$DOm_hParent?4Get@
CONST	SEGMENT
??_C@_0DI@MBML@?$CBpNext?5?$HM?$HM?5?$CI?5pNext?9?$DOm_hParent?4Get@ DB '!'
	DB	'pNext || ( pNext->m_hParent.Get() == m_hParent.Get() )', 00H ; `string'
CONST	ENDS
;	COMDAT ?Next@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT
$T41286 = -56
$T41287 = -68
_this$ = -4
_nextPos$ = -16
_flSpeed$ = -20
_pNextNext$ = -24
_pNext$ = -28
_pFire$38372 = -32
_pTeleport$38375 = -36
_distance$38383 = -40
_flTime$38385 = -44
?Next@CFuncTrackTrain@@QAEXXZ PROC NEAR			; CFuncTrackTrain::Next, COMDAT

; 2167 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2168 : 	if ( !pev->speed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38356

; 2170 : 		ALERT( at_aiconsole, "TRAIN(%s): Speed is 0\n", STRING(pev->targetname) );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+460]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BH@LMCO@TRAIN?$CI?$CFs?$CJ?3?5Speed?5is?50?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2171 : 		Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@CFuncTrackTrain@@QAEXXZ		; CFuncTrackTrain::Stop

; 2172 : 		return;

	jmp	$L38355
$L38356:

; 2174 : 
; 2175 : 	if ( !m_ppath )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1796], 0
	jne	SHORT $L38358

; 2177 : 		ALERT( at_aiconsole, "TRAIN(%s): Lost path\n", STRING(pev->targetname) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BG@FNFN@TRAIN?$CI?$CFs?$CJ?3?5Lost?5path?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2178 : 		Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@CFuncTrackTrain@@QAEXXZ		; CFuncTrackTrain::Stop

; 2179 : 		return;

	jmp	$L38355
$L38358:

; 2181 : 
; 2182 : 	UpdateSound();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSound@CFuncTrackTrain@@QAEXXZ	; CFuncTrackTrain::UpdateSound

; 2183 : 
; 2184 : 	Vector nextPos = GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	ecx, DWORD PTR _nextPos$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2185 : 	float flSpeed = pev->speed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+504]
	mov	DWORD PTR _flSpeed$[ebp], edx

; 2186 : 
; 2187 : 	nextPos.z -= m_height;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _nextPos$[ebp+8]
	fsub	DWORD PTR [eax+1808]
	fstp	DWORD PTR _nextPos$[ebp+8]

; 2188 : 	CPathTrack *pNextNext = NULL;

	mov	DWORD PTR _pNextNext$[ebp], 0

; 2189 : 	CPathTrack *pNext = m_ppath->LookAhead( nextPos, flSpeed * 0.1, 1, &pNextNext );

	lea	ecx, DWORD PTR _pNextNext$[ebp]
	push	ecx
	push	1
	fld	DWORD PTR _flSpeed$[ebp]
	fmul	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -72+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR _nextPos$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1796]
	call	?LookAhead@CPathTrack@@QAEPAV1@AAVVector@@MHPAPAV1@@Z ; CPathTrack::LookAhead
	mov	DWORD PTR _pNext$[ebp], eax

; 2190 : 	nextPos.z += m_height;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _nextPos$[ebp+8]
	fadd	DWORD PTR [ecx+1808]
	fstp	DWORD PTR _nextPos$[ebp+8]

; 2191 : 
; 2192 : 	// If we're moving towards a dead end, but our desired speed goes in the opposite direction
; 2193 : 	// this fixes us from stalling
; 2194 : 	if( FBitSet( pev->spawnflags, SF_TRACKTRAIN_NOCONTROL ) && (( flSpeed < 0 ) != ( m_flDesiredSpeed < 0 )))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L38365
	fld	DWORD PTR _flSpeed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41280
	mov	DWORD PTR -76+[ebp], 1
	jmp	SHORT $L41281
$L41280:
	mov	DWORD PTR -76+[ebp], 0
$L41281:
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1896]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41282
	mov	DWORD PTR -80+[ebp], 1
	jmp	SHORT $L41283
$L41282:
	mov	DWORD PTR -80+[ebp], 0
$L41283:
	mov	eax, DWORD PTR -76+[ebp]
	cmp	eax, DWORD PTR -80+[ebp]
	je	SHORT $L38365

; 2196 : 		if( !pNext ) pNext = m_ppath;

	cmp	DWORD PTR _pNext$[ebp], 0
	jne	SHORT $L38365
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1796]
	mov	DWORD PTR _pNext$[ebp], edx
$L38365:

; 2198 : 
; 2199 : 	// Trains *can* work in local space, but only if all elements of the track share
; 2200 : 	// the same move parent as the train.
; 2201 : 	ASSERT( !pNext || ( pNext->m_hParent.Get() == m_hParent.Get() ));

	cmp	DWORD PTR _pNext$[ebp], 0
	je	SHORT $L41284
	mov	ecx, DWORD PTR _pNext$[ebp]
	add	ecx, 148				; 00000094H
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	cmp	esi, eax
	je	SHORT $L41284
	mov	DWORD PTR -84+[ebp], 0
	jmp	SHORT $L41285
$L41284:
	mov	DWORD PTR -84+[ebp], 1
$L41285:
	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??Next@CFuncTrackTrain@@QAEXXZ@4FA ; `CFuncTrackTrain::Next'::`2'::__LINE__Var
	add	eax, 34					; 00000022H
	push	eax
	push	OFFSET FLAT:??_C@_0BO@NJDE@z?3?2xashxtsrc?2server?2plats?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0DI@MBML@?$CBpNext?5?$HM?$HM?5?$CI?5pNext?9?$DOm_hParent?4Get@ ; `string'
	mov	ecx, DWORD PTR -84+[ebp]
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 2202 : 
; 2203 : 	if( pNext )

	cmp	DWORD PTR _pNext$[ebp], 0
	je	$L38368

; 2205 : 		// can't compute correct distance in 3D because angle interpolation change the origin
; 2206 : 		if( pNext == m_ppath )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pNext$[ebp]
	cmp	eax, DWORD PTR [edx+1796]
	jne	SHORT $L38369

; 2207 : 			m_flReachedDist += fabs( pev->speed ) * gpGlobals->frametime;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1904]
	fstp	QWORD PTR -92+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fmul	DWORD PTR [ecx+4]
	fadd	QWORD PTR -92+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1904]

; 2208 : 		else m_flReachedDist = 0.0f;

	jmp	SHORT $L38370
$L38369:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1904], 0
$L38370:

; 2209 : 
; 2210 : 		UpdateTrainVelocity( pNext, pNextNext, nextPos, gpGlobals->frametime );

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR _nextPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNextNext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pNext$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateTrainVelocity@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z ; CFuncTrackTrain::UpdateTrainVelocity

; 2211 : 		UpdateTrainOrientation( pNext, pNextNext, nextPos, 0.1 );

	push	1036831949				; 3dcccccdH
	lea	eax, DWORD PTR _nextPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNextNext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pNext$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateTrainOrientation@CFuncTrackTrain@@QAEXPAVCPathTrack@@0ABVVector@@M@Z ; CFuncTrackTrain::UpdateTrainOrientation

; 2212 : 
; 2213 : 		if( pNext != m_ppath )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pNext$[ebp]
	cmp	ecx, DWORD PTR [eax+1796]
	je	SHORT $L38376

; 2215 : 			CPathTrack *pFire;
; 2216 : 
; 2217 : 			if( IsDirForward( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDirForward@CFuncTrackTrain@@QAE_NXZ	; CFuncTrackTrain::IsDirForward
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L38373

; 2218 : 				pFire = pNext;

	mov	edx, DWORD PTR _pNext$[ebp]
	mov	DWORD PTR _pFire$38372[ebp], edx

; 2219 : 			else pFire = m_ppath;

	jmp	SHORT $L38374
$L38373:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1796]
	mov	DWORD PTR _pFire$38372[ebp], ecx
$L38374:

; 2220 : 
; 2221 : 			//
; 2222 : 			// We have reached a new path track. Fire its OnPass output.
; 2223 : 			//
; 2224 : 			m_ppath = pNext;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pNext$[ebp]
	mov	DWORD PTR [edx+1796], eax

; 2225 : 			ArriveAtNode( pFire );

	mov	ecx, DWORD PTR _pFire$38372[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArriveAtNode@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z ; CFuncTrackTrain::ArriveAtNode

; 2226 : 
; 2227 : 			//
; 2228 : 			// See if we should teleport to the next path track.
; 2229 : 			//
; 2230 : 			CPathTrack *pTeleport = pNext->GetNext();

	mov	ecx, DWORD PTR _pNext$[ebp]
	call	?GetNext@CPathTrack@@QAEPAV1@XZ		; CPathTrack::GetNext
	mov	DWORD PTR _pTeleport$38375[ebp], eax

; 2231 : 			if(( pTeleport != NULL ) && FBitSet( pTeleport->pev->spawnflags, SF_PATH_TELEPORT ))

	cmp	DWORD PTR _pTeleport$38375[ebp], 0
	je	SHORT $L38376
	mov	edx, DWORD PTR _pTeleport$38375[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 16					; 00000010H
	test	ecx, ecx
	je	SHORT $L38376

; 2233 : 				TeleportToPathTrack( pTeleport );

	mov	edx, DWORD PTR _pTeleport$38375[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TeleportToPathTrack@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z ; CFuncTrackTrain::TeleportToPathTrack
$L38376:

; 2236 : 
; 2237 : 		SetMoveDoneTime( 0.5f );

	push	1056964608				; 3f000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 2238 : 		SetNextThink( 0.0f );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 2239 : 		SetMoveDone( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 2240 : 		SetThink( Next );

	push	OFFSET FLAT:??_C@_04CIMM@Next?$AA@	; `string'
	push	OFFSET FLAT:?Next@CFuncTrackTrain@@QAEXXZ ; CFuncTrackTrain::Next
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 2242 : 	else

	jmp	$L38389
$L38368:

; 2244 : 		//
; 2245 : 		// We've reached the end of the path, stop.
; 2246 : 		//
; 2247 : 		StopSound();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopSound@CFuncTrackTrain@@QAEXXZ	; CFuncTrackTrain::StopSound

; 2248 : 		SetLocalVelocity( nextPos - GetLocalOrigin( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	eax, DWORD PTR $T41286[ebp]
	push	eax
	lea	ecx, DWORD PTR _nextPos$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 2249 : 		float distance = GetLocalVelocity().Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalVelocity
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _distance$38383[ebp]

; 2250 : 		SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 2251 : 		m_oldSpeed = pev->speed;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+504]
	mov	DWORD PTR [eax+1880], ecx

; 2252 : 		m_flDesiredSpeed = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1896], 0

; 2253 : 		pev->speed = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+504], 0

; 2254 : 
; 2255 : 		// Move to the dead end
; 2256 : 		
; 2257 : 		// Are we there yet?
; 2258 : 		if ( distance > 0 )

	fld	DWORD PTR _distance$38383[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38384

; 2260 : 			// no, how long to get there?
; 2261 : 			float flTime = distance / fabs( m_oldSpeed );

	fld	DWORD PTR _distance$38383[ebp]
	fstp	QWORD PTR -100+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1880]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fdivr	QWORD PTR -100+[ebp]
	fstp	DWORD PTR _flTime$38385[ebp]

; 2262 : 			SetLocalVelocity( GetLocalVelocity() * (m_oldSpeed / distance) );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1880]
	fdiv	DWORD PTR _distance$38383[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41287[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 2263 : 			SetMoveDoneTime( flTime );

	mov	edx, DWORD PTR _flTime$38385[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 2264 : 			SetMoveDone( DeadEnd );

	push	OFFSET FLAT:??_C@_07LJIB@DeadEnd?$AA@	; `string'
	push	OFFSET FLAT:?DeadEnd@CFuncTrackTrain@@QAEXXZ ; CFuncTrackTrain::DeadEnd
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 2265 : 			DontThink();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DontThink@CBaseEntity@@QAEXXZ		; CBaseEntity::DontThink

; 2267 : 		else

	jmp	SHORT $L38389
$L38384:

; 2269 : 			DeadEnd();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeadEnd@CFuncTrackTrain@@QAEXXZ	; CFuncTrackTrain::DeadEnd
$L38389:
$L38355:

; 2272 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Next@CFuncTrackTrain@@QAEXXZ ENDP			; CFuncTrackTrain::Next
_TEXT	ENDS
PUBLIC	??_C@_0BF@LGCC@TRAIN?$CI?$CFs?$CJ?3?5Dead?5end?5?$AA@ ; `string'
PUBLIC	??_C@_06BLHP@at?5?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_01BJG@?6?$AA@				; `string'
PUBLIC	?GetNetname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetNetname
EXTRN	?ValidPath@CPathTrack@@QAEPAV1@PAV1@H@Z:NEAR	; CPathTrack::ValidPath
;	COMDAT ??_C@_0BF@LGCC@TRAIN?$CI?$CFs?$CJ?3?5Dead?5end?5?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BF@LGCC@TRAIN?$CI?$CFs?$CJ?3?5Dead?5end?5?$AA@ DB 'TRAIN(%s): Dead'
	DB	' end ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06BLHP@at?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_06BLHP@at?5?$CFs?6?$AA@ DB 'at %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT
??_C@_01BJG@?6?$AA@ DB 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?DeadEnd@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pTrack$ = -8
_pNext$ = -12
?DeadEnd@CFuncTrackTrain@@QAEXXZ PROC NEAR		; CFuncTrackTrain::DeadEnd, COMDAT

; 2275 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 	// Fire the dead-end target if there is one
; 2277 : 	CPathTrack *pTrack, *pNext;
; 2278 : 
; 2279 : 	pTrack = m_ppath;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1796]
	mov	DWORD PTR _pTrack$[ebp], ecx

; 2280 : 
; 2281 : 	ALERT( at_aiconsole, "TRAIN(%s): Dead end ", GetDebugName() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDebugName@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetDebugName
	push	eax
	push	OFFSET FLAT:??_C@_0BF@LGCC@TRAIN?$CI?$CFs?$CJ?3?5Dead?5end?5?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2282 : 	// Find the dead end path node
; 2283 : 	// HACKHACK -- This is bugly, but the train can actually stop moving at a different node depending on it's speed
; 2284 : 	// so we have to traverse the list to it's end.
; 2285 : 	if ( pTrack )

	cmp	DWORD PTR _pTrack$[ebp], 0
	je	SHORT $L38406

; 2287 : 		if ( m_oldSpeed < 0 )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1880]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38398
$L38399:

; 2291 : 				pNext = pTrack->ValidPath( pTrack->GetPrevious(), TRUE );

	push	1
	mov	ecx, DWORD PTR _pTrack$[ebp]
	call	?GetPrevious@CPathTrack@@QAEPAV1@XZ	; CPathTrack::GetPrevious
	push	eax
	mov	ecx, DWORD PTR _pTrack$[ebp]
	call	?ValidPath@CPathTrack@@QAEPAV1@PAV1@H@Z	; CPathTrack::ValidPath
	mov	DWORD PTR _pNext$[ebp], eax

; 2292 : 				if ( pNext )

	cmp	DWORD PTR _pNext$[ebp], 0
	je	SHORT $L38402

; 2293 : 					pTrack = pNext;

	mov	eax, DWORD PTR _pNext$[ebp]
	mov	DWORD PTR _pTrack$[ebp], eax
$L38402:

; 2294 : 			} while ( pNext );

	cmp	DWORD PTR _pNext$[ebp], 0
	jne	SHORT $L38399

; 2296 : 		else

	jmp	SHORT $L38406
$L38398:

; 2300 : 				pNext = pTrack->ValidPath( pTrack->GetNext(), TRUE );

	push	1
	mov	ecx, DWORD PTR _pTrack$[ebp]
	call	?GetNext@CPathTrack@@QAEPAV1@XZ		; CPathTrack::GetNext
	push	eax
	mov	ecx, DWORD PTR _pTrack$[ebp]
	call	?ValidPath@CPathTrack@@QAEPAV1@PAV1@H@Z	; CPathTrack::ValidPath
	mov	DWORD PTR _pNext$[ebp], eax

; 2301 : 				if ( pNext )

	cmp	DWORD PTR _pNext$[ebp], 0
	je	SHORT $L38407

; 2302 : 					pTrack = pNext;

	mov	ecx, DWORD PTR _pNext$[ebp]
	mov	DWORD PTR _pTrack$[ebp], ecx
$L38407:

; 2303 : 			} while ( pNext );

	cmp	DWORD PTR _pNext$[ebp], 0
	jne	SHORT $L38398
$L38406:

; 2306 : 
; 2307 : 	m_oldSpeed = pev->speed;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+504]
	mov	DWORD PTR [ecx+1880], edx

; 2308 : 	m_flDesiredSpeed = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1896], 0

; 2309 : 	pev->speed = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+504], 0

; 2310 : 	SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 2311 : 	SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 2312 : 
; 2313 : 	if ( pTrack )

	cmp	DWORD PTR _pTrack$[ebp], 0
	je	SHORT $L38408

; 2315 : 		ALERT( at_aiconsole, "at %s\n", pTrack->GetDebugName() );

	mov	ecx, DWORD PTR _pTrack$[ebp]
	call	?GetDebugName@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetDebugName
	push	eax
	push	OFFSET FLAT:??_C@_06BLHP@at?5?$CFs?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2316 : 		if ( pTrack->pev->netname )

	mov	eax, DWORD PTR _pTrack$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+464], 0
	je	SHORT $L38410

; 2317 : 			UTIL_FireTargets( pTrack->GetNetname(), this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTrack$[ebp]
	call	?GetNetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetNetname
	push	eax
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L38410:

; 2319 : 	else

	jmp	SHORT $L38411
$L38408:

; 2320 : 		ALERT( at_aiconsole, "\n" );

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L38411:

; 2321 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DeadEnd@CFuncTrackTrain@@QAEXXZ ENDP			; CFuncTrackTrain::DeadEnd
_TEXT	ENDS
;	COMDAT ?GetNetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetNetname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetNetname, COMDAT

; 287  : 	const char*	GetNetname() { return STRING( pev->netname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNetname@CBaseEntity@@QAEPBDXZ ENDP			; CBaseEntity::GetNetname
_TEXT	ENDS
PUBLIC	?SetControls@CFuncTrackTrain@@QAEXPAVCBaseEntity@@@Z ; CFuncTrackTrain::SetControls
;	COMDAT ?SetControls@CFuncTrackTrain@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T41294 = -28
$T41295 = -40
$T41296 = -52
_pControls$ = 8
_this$ = -4
_offset$ = -16
?SetControls@CFuncTrackTrain@@QAEXPAVCBaseEntity@@@Z PROC NEAR ; CFuncTrackTrain::SetControls, COMDAT

; 2324 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2325 : 	Vector offset = pControls->GetLocalOrigin() - m_controlOrigin;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1844				; 00000734H
	push	eax
	lea	ecx, DWORD PTR $T41294[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pControls$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _offset$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2326 : 
; 2327 : 	m_controlMins = pControls->pev->mins + offset;

	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	lea	eax, DWORD PTR $T41295[ebp]
	push	eax
	mov	ecx, DWORD PTR _pControls$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 220				; 000000dcH
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1820				; 0000071cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 2328 : 	m_controlMaxs = pControls->pev->maxs + offset;

	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41296[ebp]
	push	edx
	mov	eax, DWORD PTR _pControls$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 232				; 000000e8H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1832				; 00000728H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 2329 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetControls@CFuncTrackTrain@@QAEXPAVCBaseEntity@@@Z ENDP ; CFuncTrackTrain::SetControls
_TEXT	ENDS
PUBLIC	??0matrix3x3@@QAE@ABVVector@@@Z			; matrix3x3::matrix3x3
PUBLIC	??0matrix3x3@@QAE@ABV0@@Z			; matrix3x3::matrix3x3
EXTRN	?VectorIRotate@matrix3x3@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix3x3::VectorIRotate
;	COMDAT ?OnControls@CFuncTrackTrain@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T41299 = -76
$T41300 = -112
$T41301 = -124
_pTest$ = 8
_this$ = -4
_offset$ = -16
_tmp$ = -52
_local$ = -64
?OnControls@CFuncTrackTrain@@UAEHPAVCBaseEntity@@@Z PROC NEAR ; CFuncTrackTrain::OnControls, COMDAT

; 2332 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2333 : 	Vector offset = pTest->GetAbsOrigin() - GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	eax, DWORD PTR $T41299[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTest$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _offset$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2334 : 
; 2335 : 	if( FBitSet( pev->spawnflags, SF_TRACKTRAIN_NOCONTROL ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 2
	test	eax, eax
	je	SHORT $L38427

; 2336 : 		return FALSE;

	xor	eax, eax
	jmp	$L38424
$L38427:

; 2337 : 
; 2338 : 	// Transform offset into local coordinates
; 2339 : 	matrix3x3 tmp = matrix3x3( GetLocalAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	lea	ecx, DWORD PTR $T41300[ebp]
	call	??0matrix3x3@@QAE@ABVVector@@@Z		; matrix3x3::matrix3x3
	push	eax
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??0matrix3x3@@QAE@ABV0@@Z		; matrix3x3::matrix3x3

; 2340 : 	// rotate into local space
; 2341 : 	Vector local = tmp.VectorIRotate( offset );

	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41301[ebp]
	push	edx
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	?VectorIRotate@matrix3x3@@QBE?AVVector@@ABV2@@Z ; matrix3x3::VectorIRotate
	push	eax
	lea	ecx, DWORD PTR _local$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2344 : 		 local.x <= m_controlMaxs.x && local.y <= m_controlMaxs.y && local.z <= m_controlMaxs.z )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _local$[ebp]
	fcomp	DWORD PTR [eax+1820]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L38432
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _local$[ebp+4]
	fcomp	DWORD PTR [ecx+1824]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L38432
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _local$[ebp+8]
	fcomp	DWORD PTR [edx+1828]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L38432
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _local$[ebp]
	fcomp	DWORD PTR [eax+1832]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38432
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _local$[ebp+4]
	fcomp	DWORD PTR [ecx+1836]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38432
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _local$[ebp+8]
	fcomp	DWORD PTR [edx+1840]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38432

; 2345 : 		 return TRUE;

	mov	eax, 1
	jmp	SHORT $L38424
$L38432:

; 2346 : 
; 2347 : 	return FALSE;

	xor	eax, eax
$L38424:

; 2348 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnControls@CFuncTrackTrain@@UAEHPAVCBaseEntity@@@Z ENDP ; CFuncTrackTrain::OnControls
_TEXT	ENDS
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	__real@8@3ff98efa351294e9c800
PUBLIC	?SinCos@@YAXMPAM0@Z				; SinCos
;	COMDAT __real@8@3ff98efa351294e9c800
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@8@3ff98efa351294e9c800 DQ 03f91df46a2529d39r ; 0.0174533
CONST	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABVVector@@@Z
_TEXT	SEGMENT
_angles$ = 8
_this$ = -4
_angle$ = -8
_sr$ = -12
_sp$ = -16
_sy$ = -20
_cr$ = -24
_cp$ = -28
_cy$ = -32
??0matrix3x3@@QAE@ABVVector@@@Z PROC NEAR		; matrix3x3::matrix3x3, COMDAT

; 50   : 	_forceinline matrix3x3( const Vector &angles )

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	3
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 51   : 	{
; 52   : 		float	angle, sr, sp, sy, cr, cp, cy;
; 53   : 
; 54   : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25290

; 56   : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 57   : 			SinCos( angle, &sy, &cy );

	lea	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 58   : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 59   : 			SinCos( angle, &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 60   : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 61   : 			SinCos( angle, &sr, &cr );

	lea	ecx, DWORD PTR _cr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sr$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 62   : 
; 63   : 			mat[0][0] = (cp*cy);

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax], ecx

; 64   : 			mat[1][0] = (sr*sp*cy+cr*-sy);

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _cr$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax], edx

; 65   : 			mat[2][0] = (cr*sp*cy+-sr*-sy);

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR [eax], ecx

; 66   : 			mat[0][1] = (cp*sy);

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+4], edx

; 67   : 			mat[1][1] = (sr*sp*sy+cr*cy);

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 68   : 			mat[2][1] = (cr*sp*sy+-sr*cy);

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax+4], edx

; 69   : 			mat[0][2] = (-sp);

	fld	DWORD PTR _sp$[ebp]
	fchs
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 70   : 			mat[1][2] = (sr*cp);

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fstp	DWORD PTR -64+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+8], edx

; 71   : 			mat[2][2] = (cr*cp);

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fstp	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 73   : 		else if( angles[PITCH] )

	jmp	$L25295
$L25290:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25292

; 75   : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 76   : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 77   : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 78   : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 79   : 
; 80   : 			mat[0][0] = (cp*cy);

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fstp	DWORD PTR -72+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -72+[ebp]
	mov	DWORD PTR [eax], edx

; 81   : 			mat[1][0] = (-sy);

	fld	DWORD PTR _sy$[ebp]
	fchs
	fstp	DWORD PTR -76+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -76+[ebp]
	mov	DWORD PTR [eax], ecx

; 82   : 			mat[2][0] = (sp*cy);

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fstp	DWORD PTR -80+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -80+[ebp]
	mov	DWORD PTR [eax], edx

; 83   : 			mat[0][1] = (cp*sy);

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fstp	DWORD PTR -84+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -84+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 84   : 			mat[1][1] = (cy);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _cy$[ebp]
	mov	DWORD PTR [eax+4], edx

; 85   : 			mat[2][1] = (sp*sy);

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fstp	DWORD PTR -88+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -88+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 86   : 			mat[0][2] = (-sp);

	fld	DWORD PTR _sp$[ebp]
	fchs
	fstp	DWORD PTR -92+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -92+[ebp]
	mov	DWORD PTR [eax+8], edx

; 87   : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 88   : 			mat[2][2] = (cp);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _cp$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 90   : 		else if( angles[YAW] )

	jmp	$L25295
$L25292:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25294

; 92   : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 93   : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 94   : 
; 95   : 			mat[0][0] = (cy);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _cy$[ebp]
	mov	DWORD PTR [eax], edx

; 96   : 			mat[1][0] = (-sy);

	fld	DWORD PTR _sy$[ebp]
	fchs
	fstp	DWORD PTR -96+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -96+[ebp]
	mov	DWORD PTR [eax], ecx

; 97   : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 98   : 			mat[0][1] = (sy);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _sy$[ebp]
	mov	DWORD PTR [eax+4], edx

; 99   : 			mat[1][1] = (cy);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _cy$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 100  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 101  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 102  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 103  : 			mat[2][2] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 1065353216		; 3f800000H

; 105  : 		else

	jmp	$L25295
$L25294:

; 107  : 			mat[0][0] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 108  : 			mat[1][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 109  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 110  : 			mat[0][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 111  : 			mat[1][1] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 1065353216		; 3f800000H

; 112  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 113  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 114  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 115  : 			mat[2][2] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 1065353216		; 3f800000H
$L25295:

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix3x3@@QAE@ABVVector@@@Z ENDP			; matrix3x3::matrix3x3
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT
_angle$ = 8
_sine$ = 12
_cosine$ = 16
?SinCos@@YAXMPAM0@Z PROC NEAR				; SinCos, COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 37   : 	__asm
; 38   : 	{
; 39   : 		push	ecx

	push	ecx

; 40   : 		fld	dword ptr angle

	fld	DWORD PTR _angle$[ebp]

; 41   : 		fsincos

	fsincos

; 42   : 		mov	ecx, dword ptr[cosine]

	mov	ecx, DWORD PTR _cosine$[ebp]

; 43   : 		fstp      dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 44   : 		mov 	ecx, dword ptr[sine]

	mov	ecx, DWORD PTR _sine$[ebp]

; 45   : 		fstp	dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 46   : 		pop	ecx

	pop	ecx

; 47   : 	}
; 48   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SinCos@@YAXMPAM0@Z ENDP				; SinCos
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QBEPBMXZ PROC NEAR				; Vector::operator float const *, COMDAT

; 229  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
_$S1$ = -8
_$S2$ = -12
_$S3$ = -16
??0matrix3x3@@QAE@ABV0@@Z PROC NEAR			; matrix3x3::matrix3x3, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S1$[ebp], 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _$S2$[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR _$S3$[ebp], ecx
$L25393:
	mov	edx, DWORD PTR _$S3$[ebp]
	push	edx
	mov	ecx, DWORD PTR _$S2$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR _$S2$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _$S2$[ebp], eax
	mov	ecx, DWORD PTR _$S3$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _$S3$[ebp], ecx
	mov	edx, DWORD PTR _$S1$[ebp]
	sub	edx, 1
	mov	DWORD PTR _$S1$[ebp], edx
	cmp	DWORD PTR _$S1$[ebp], 0
	ja	SHORT $L25393
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix3x3@@QAE@ABV0@@Z ENDP				; matrix3x3::matrix3x3
_TEXT	ENDS
PUBLIC	??_C@_0L@NGLK@path_track?$AA@			; `string'
PUBLIC	??_C@_0DC@CPIB@func_track_train?5must?5be?5on?5a?5pa@ ; `string'
EXTRN	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z:NEAR	; FClassnameIs
;	COMDAT ??_C@_0L@NGLK@path_track?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0L@NGLK@path_track?$AA@ DB 'path_track', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@CPIB@func_track_train?5must?5be?5on?5a?5pa@
CONST	SEGMENT
??_C@_0DC@CPIB@func_track_train?5must?5be?5on?5a?5pa@ DB 'func_track_trai'
	DB	'n must be on a path of path_track', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?Find@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT
$T41314 = -52
$T41315 = -64
_this$ = -4
_nextPos$ = -16
_look$ = -28
_nextAngles$ = -40
?Find@CFuncTrackTrain@@QAEXXZ PROC NEAR			; CFuncTrackTrain::Find, COMDAT

; 2351 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2352 : 	m_ppath = (CPathTrack *)UTIL_FindEntityByTargetname( NULL, GetTarget() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTarget@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTarget
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1796], eax

; 2353 : 	if ( !m_ppath )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1796], 0
	jne	SHORT $L38438

; 2354 : 		return;

	jmp	$L38436
$L38438:

; 2355 : 
; 2356 : 	if ( !FClassnameIs( m_ppath, "path_track" ) )

	push	OFFSET FLAT:??_C@_0L@NGLK@path_track?$AA@ ; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1796]
	push	ecx
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	jne	SHORT $L38439

; 2358 : 		ALERT( at_error, "func_track_train must be on a path of path_track\n" );

	push	OFFSET FLAT:??_C@_0DC@CPIB@func_track_train?5must?5be?5on?5a?5pa@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2359 : 		m_ppath = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1796], 0

; 2360 : 		return;

	jmp	$L38436
$L38439:

; 2362 : 
; 2363 : 	Vector nextPos = m_ppath->GetLocalOrigin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1796]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	ecx, DWORD PTR _nextPos$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2364 : 	Vector look = nextPos;

	lea	ecx, DWORD PTR _nextPos$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _look$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2365 : 	m_ppath->LookAhead( look, m_length, 0 );

	push	0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1804]
	push	eax
	lea	ecx, DWORD PTR _look$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1796]
	call	?LookAhead@CPathTrack@@QAEPAV1@AAVVector@@MHPAPAV1@@Z ; CPathTrack::LookAhead

; 2366 : 	nextPos.z += m_height;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _nextPos$[ebp+8]
	fadd	DWORD PTR [eax+1808]
	fstp	DWORD PTR _nextPos$[ebp+8]

; 2367 : 	look.z += m_height;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _look$[ebp+8]
	fadd	DWORD PTR [ecx+1808]
	fstp	DWORD PTR _look$[ebp+8]

; 2368 : 
; 2369 : 	Vector nextAngles = UTIL_VecToAngles( look - nextPos );

	lea	edx, DWORD PTR _nextPos$[ebp]
	push	edx
	lea	eax, DWORD PTR $T41314[ebp]
	push	eax
	lea	ecx, DWORD PTR _look$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR $T41315[ebp]
	push	ecx
	call	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z	; UTIL_VecToAngles
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _nextAngles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2370 : 	nextAngles.x = -nextAngles.x;

	fld	DWORD PTR _nextAngles$[ebp]
	fchs
	fstp	DWORD PTR _nextAngles$[ebp]

; 2371 : 	// The train actually points west
; 2372 : 	nextAngles.y += 180;

	fld	DWORD PTR _nextAngles$[ebp+4]
	fadd	DWORD PTR __real@4@4006b400000000000000
	fstp	DWORD PTR _nextAngles$[ebp+4]

; 2373 : 
; 2374 : 	if ( pev->spawnflags & SF_TRACKTRAIN_NOPITCH )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L38447

; 2375 : 		nextAngles.x = 0;

	mov	DWORD PTR _nextAngles$[ebp], 0
$L38447:

; 2376 : 
; 2377 : 	Teleport( &nextPos, &nextAngles, NULL );

	push	0
	lea	edx, DWORD PTR _nextAngles$[ebp]
	push	edx
	lea	eax, DWORD PTR _nextPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z ; CBaseEntity::Teleport

; 2378 : 	SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 2379 : 
; 2380 : 	ArriveAtNode( m_ppath );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1796]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArriveAtNode@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z ; CFuncTrackTrain::ArriveAtNode

; 2381 : 	pev->speed = m_startSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	mov	DWORD PTR [ecx+504], eax

; 2382 : 
; 2383 : 	SetNextThink( 0.1f );

	push	1036831949				; 3dcccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 2384 : 	SetThink( Next );

	push	OFFSET FLAT:??_C@_04CIMM@Next?$AA@	; `string'
	push	OFFSET FLAT:?Next@CFuncTrackTrain@@QAEXXZ ; CFuncTrackTrain::Next
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
$L38436:

; 2385 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Find@CFuncTrackTrain@@QAEXXZ ENDP			; CFuncTrackTrain::Find
_TEXT	ENDS
PUBLIC	??_C@_0BP@EIGK@Can?8t?5find?5a?5nearby?5track?5?$CB?$CB?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@BCAL@TRAIN?3?5?$CFs?0?5Nearest?5track?5is?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@FABF@?$CGCFuncTrackTrain?3?3Next?$AA@	; `string'
EXTRN	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z:NEAR ; UTIL_FindEntityInSphere
;	COMDAT ??_C@_0BP@EIGK@Can?8t?5find?5a?5nearby?5track?5?$CB?$CB?$CB?6?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BP@EIGK@Can?8t?5find?5a?5nearby?5track?5?$CB?$CB?$CB?6?$AA@ DB 'Ca'
	DB	'n''t find a nearby track !!!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BCAL@TRAIN?3?5?$CFs?0?5Nearest?5track?5is?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0CA@BCAL@TRAIN?3?5?$CFs?0?5Nearest?5track?5is?5?$CFs?6?$AA@ DB 'TRA'
	DB	'IN: %s, Nearest track is %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FABF@?$CGCFuncTrackTrain?3?3Next?$AA@
CONST	SEGMENT
??_C@_0BH@FABF@?$CGCFuncTrackTrain?3?3Next?$AA@ DB '&CFuncTrackTrain::Nex'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ?NearestPath@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT
$T41318 = -32
$T41319 = -44
$T41320 = -56
_this$ = -4
_pTrack$ = -8
_pNearest$ = -12
_dist$ = -16
_closest$ = -20
?NearestPath@CFuncTrackTrain@@QAEXXZ PROC NEAR		; CFuncTrackTrain::NearestPath, COMDAT

; 2388 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2389 : 	CBaseEntity *pTrack = NULL;

	mov	DWORD PTR _pTrack$[ebp], 0

; 2390 : 	CBaseEntity *pNearest = NULL;

	mov	DWORD PTR _pNearest$[ebp], 0

; 2391 : 	float dist, closest;
; 2392 : 
; 2393 : 	closest = 1024;

	mov	DWORD PTR _closest$[ebp], 1149239296	; 44800000H
$L38459:

; 2394 : 
; 2395 : 	while ((pTrack = UTIL_FindEntityInSphere( pTrack, GetAbsOrigin(), 1024 )) != NULL)

	push	1149239296				; 44800000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	eax, DWORD PTR _pTrack$[ebp]
	push	eax
	call	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z ; UTIL_FindEntityInSphere
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTrack$[ebp], eax
	cmp	DWORD PTR _pTrack$[ebp], 0
	je	SHORT $L38460

; 2397 : 		// filter out non-tracks
; 2398 : 		if ( !(pTrack->pev->flags & (FL_CLIENT|FL_MONSTER)) && FClassnameIs( pTrack, "path_track" ) )

	mov	ecx, DWORD PTR _pTrack$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 40					; 00000028H
	test	eax, eax
	jne	SHORT $L38463
	push	OFFSET FLAT:??_C@_0L@NGLK@path_track?$AA@ ; `string'
	mov	ecx, DWORD PTR _pTrack$[ebp]
	push	ecx
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L38463

; 2400 : 			dist = (GetLocalOrigin() - pTrack->GetLocalOrigin()).Length();

	mov	ecx, DWORD PTR _pTrack$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	edx, DWORD PTR $T41318[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _dist$[ebp]

; 2401 : 			if ( dist < closest )

	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR _closest$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38463

; 2403 : 				closest = dist;

	mov	eax, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _closest$[ebp], eax

; 2404 : 				pNearest = pTrack;

	mov	ecx, DWORD PTR _pTrack$[ebp]
	mov	DWORD PTR _pNearest$[ebp], ecx
$L38463:

; 2407 : 	}

	jmp	$L38459
$L38460:

; 2408 : 
; 2409 : 	if ( !pNearest )

	cmp	DWORD PTR _pNearest$[ebp], 0
	jne	SHORT $L38464

; 2411 : 		ALERT( at_console, "Can't find a nearby track !!!\n" );

	push	OFFSET FLAT:??_C@_0BP@EIGK@Can?8t?5find?5a?5nearby?5track?5?$CB?$CB?$CB?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2412 : 		SetThink(NULL);

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 2413 : 		return;

	jmp	$L38453
$L38464:

; 2415 : 
; 2416 : 	ALERT( at_aiconsole, "TRAIN: %s, Nearest track is %s\n", GetDebugName(), pNearest->GetDebugName() );

	mov	ecx, DWORD PTR _pNearest$[ebp]
	call	?GetDebugName@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetDebugName
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDebugName@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetDebugName
	push	eax
	push	OFFSET FLAT:??_C@_0CA@BCAL@TRAIN?3?5?$CFs?0?5Nearest?5track?5is?5?$CFs?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 2417 : 	// If I'm closer to the next path_track on this path, then it's my real path
; 2418 : 	pTrack = ((CPathTrack *)pNearest)->GetNext();

	mov	ecx, DWORD PTR _pNearest$[ebp]
	call	?GetNext@CPathTrack@@QAEPAV1@XZ		; CPathTrack::GetNext
	mov	DWORD PTR _pTrack$[ebp], eax

; 2419 : 	if ( pTrack )

	cmp	DWORD PTR _pTrack$[ebp], 0
	je	SHORT $L38473

; 2421 : 		if ( (GetLocalOrigin() - pTrack->GetLocalOrigin()).Length() < (GetLocalOrigin() - pNearest->GetLocalOrigin()).Length() )

	mov	ecx, DWORD PTR _pTrack$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	edx, DWORD PTR $T41319[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _pNearest$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	eax, DWORD PTR $T41320[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fcomp	DWORD PTR -60+[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38473

; 2422 : 			pNearest = pTrack;

	mov	ecx, DWORD PTR _pTrack$[ebp]
	mov	DWORD PTR _pNearest$[ebp], ecx
$L38473:

; 2424 : 
; 2425 : 	m_ppath = (CPathTrack *)pNearest;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pNearest$[ebp]
	mov	DWORD PTR [edx+1796], eax

; 2426 : 
; 2427 : 	if ( pev->speed != 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38475

; 2429 : 		SetMoveDoneTime( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 2430 : 		SetMoveDone( &CFuncTrackTrain::Next );

	push	OFFSET FLAT:??_C@_0BH@FABF@?$CGCFuncTrackTrain?3?3Next?$AA@ ; `string'
	push	OFFSET FLAT:?Next@CFuncTrackTrain@@QAEXXZ ; CFuncTrackTrain::Next
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet
$L38475:
$L38453:

; 2432 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NearestPath@CFuncTrackTrain@@QAEXXZ ENDP		; CFuncTrackTrain::NearestPath
_TEXT	ENDS
;	COMDAT ?OverrideReset@CFuncTrackTrain@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CFuncTrackTrain@@UAEXXZ PROC NEAR	; CFuncTrackTrain::OverrideReset, COMDAT

; 2436 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2437 : 	// NOTE: all entities are spawned so we don't need
; 2438 : 	// to make delay before searching nearest path
; 2439 : 	if( !m_ppath )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $L38483

; 2441 : 		NearestPath();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NearestPath@CFuncTrackTrain@@QAEXXZ	; CFuncTrackTrain::NearestPath

; 2442 : 		SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
$L38483:

; 2444 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CFuncTrackTrain@@UAEXXZ ENDP		; CFuncTrackTrain::OverrideReset
_TEXT	ENDS
PUBLIC	?Instance@CFuncTrackTrain@@SAPAV1@PAUedict_s@@@Z ; CFuncTrackTrain::Instance
;	COMDAT ?Instance@CFuncTrackTrain@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
_pEntity$ = -4
?Instance@CFuncTrackTrain@@SAPAV1@PAUedict_s@@@Z PROC NEAR ; CFuncTrackTrain::Instance, COMDAT

; 2447 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2448 : 	CBaseEntity *pEntity = CBaseEntity::Instance( pent );

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 2449 : 	if( FClassnameIs( pEntity, "func_tracktrain" ))

	push	OFFSET FLAT:??_C@_0BA@KOLE@func_tracktrain?$AA@ ; `string'
	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L38490

; 2450 : 		return (CFuncTrackTrain *)pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]
	jmp	SHORT $L38488
$L38490:

; 2451 : 	return NULL;

	xor	eax, eax
$L38488:

; 2452 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CFuncTrackTrain@@SAPAV1@PAUedict_s@@@Z ENDP	; CFuncTrackTrain::Instance
_TEXT	ENDS
PUBLIC	__real@4@40059000000000000000
PUBLIC	??_C@_0CE@PKMI@FuncTrackTrain?5?8?$CFs?8?5has?5no?5targe@ ; `string'
PUBLIC	??_C@_0BH@BGEM@?$CGCFuncTrackTrain?3?3Find?$AA@	; `string'
;	COMDAT ??_C@_0CE@PKMI@FuncTrackTrain?5?8?$CFs?8?5has?5no?5targe@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0CE@PKMI@FuncTrackTrain?5?8?$CFs?8?5has?5no?5targe@ DB 'FuncTrackTr'
	DB	'ain ''%s'' has no target.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BGEM@?$CGCFuncTrackTrain?3?3Find?$AA@
CONST	SEGMENT
??_C@_0BH@BGEM@?$CGCFuncTrackTrain?3?3Find?$AA@ DB '&CFuncTrackTrain::Fin'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT __real@4@40059000000000000000
CONST	SEGMENT
__real@4@40059000000000000000 DD 042900000r	; 72
CONST	ENDS
;	COMDAT ?Spawn@CFuncTrackTrain@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CFuncTrackTrain@@UAEXXZ PROC NEAR		; CFuncTrackTrain::Spawn, COMDAT

; 2466 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2467 : 	if( m_maxSpeed == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1812]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38498

; 2469 : 		if( pev->speed == 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38497

; 2470 : 			m_maxSpeed = 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1812], 1120403456	; 42c80000H

; 2471 : 		else m_maxSpeed = pev->speed;

	jmp	SHORT $L38498
$L38497:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+504]
	mov	DWORD PTR [eax+1812], ecx
$L38498:

; 2473 : 
; 2474 : 	SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 2475 : 	SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 2476 : 	pev->speed = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+504], 0

; 2477 : 	m_dir = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1884], 1065353216	; 3f800000H

; 2478 : 
; 2479 : 	if ( FStringNull(pev->target) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+456]
	push	ecx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	je	SHORT $L38499

; 2480 : 		ALERT( at_console, "FuncTrackTrain '%s' has no target.\n", GetDebugName());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDebugName@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetDebugName
	push	eax
	push	OFFSET FLAT:??_C@_0CE@PKMI@FuncTrackTrain?5?8?$CFs?8?5has?5no?5targe@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L38499:

; 2481 : 
; 2482 : 	if( FBitSet( pev->spawnflags, SF_TRACKTRAIN_UNBLOCKABLE ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 32					; 00000020H
	test	ecx, ecx
	je	SHORT $L38501

; 2483 : 		SetBits( pev->flags, FL_UNBLOCKABLE );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 268435456				; 10000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx
$L38501:

; 2484 : 
; 2485 : 	if( FBitSet( pev->spawnflags, SF_TRACKTRAIN_PASSABLE ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 8
	test	eax, eax
	je	SHORT $L38502

; 2486 : 		pev->solid = SOLID_NOT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 0

; 2487 : 	else pev->solid = SOLID_BSP;

	jmp	SHORT $L38503
$L38502:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 4
$L38503:

; 2488 : 	pev->movetype = MOVETYPE_PUSH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 7

; 2489 : 	
; 2490 : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 2491 : 
; 2492 : 	UTIL_SetSize( pev, pev->mins, pev->maxs );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 232				; 000000e8H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 220				; 000000dcH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 2493 : 	RelinkEntity( TRUE );

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 2494 : 
; 2495 : 	// NOTE: cull the tracktrain by PHS because it's may out of PVS
; 2496 : 	// and hanging the moving sound
; 2497 : 	SetBits( pev->effects, EF_REQUEST_PHS );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax

; 2498 : 
; 2499 : 	m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 2500 : 
; 2501 : 	// Cache off placed origin for train controls
; 2502 : 	m_controlOrigin = GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1844				; 00000734H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 2503 : 
; 2504 : 	m_controlMins = pev->mins;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 220				; 000000dcH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1820				; 0000071cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 2505 : 	m_controlMaxs = pev->maxs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 232				; 000000e8H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1832				; 00000728H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 2506 : 	m_controlMaxs.z += 72;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1840]
	fadd	DWORD PTR __real@4@40059000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1840]

; 2507 : // start trains on the next frame, to make sure their targets have had
; 2508 : // a chance to spawn/activate
; 2509 : 	SetThink( &CFuncTrackTrain::Find );

	push	OFFSET FLAT:??_C@_0BH@BGEM@?$CGCFuncTrackTrain?3?3Find?$AA@ ; `string'
	push	OFFSET FLAT:?Find@CFuncTrackTrain@@QAEXXZ ; CFuncTrackTrain::Find
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 2510 : 	SetNextThink( 0.0f );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 2511 : 	Precache();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 2512 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncTrackTrain@@UAEXXZ ENDP			; CFuncTrackTrain::Spawn
_TEXT	ENDS
PUBLIC	??_C@_0BC@KFKM@plats?1ttrain1?4wav?$AA@		; `string'
PUBLIC	??_C@_0BC@EFMD@plats?1ttrain2?4wav?$AA@		; `string'
PUBLIC	??_C@_0BC@OFOG@plats?1ttrain3?4wav?$AA@		; `string'
PUBLIC	??_C@_0BC@IFBM@plats?1ttrain4?4wav?$AA@		; `string'
PUBLIC	??_C@_0BC@MFFG@plats?1ttrain6?4wav?$AA@		; `string'
PUBLIC	??_C@_0BC@GFHD@plats?1ttrain7?4wav?$AA@		; `string'
PUBLIC	??_C@_0BI@DAGB@plats?1ttrain_start1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BI@LCPH@plats?1ttrain_brake1?4wav?$AA@	; `string'
;	COMDAT ??_C@_0BC@KFKM@plats?1ttrain1?4wav?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BC@KFKM@plats?1ttrain1?4wav?$AA@ DB 'plats/ttrain1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EFMD@plats?1ttrain2?4wav?$AA@
CONST	SEGMENT
??_C@_0BC@EFMD@plats?1ttrain2?4wav?$AA@ DB 'plats/ttrain2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OFOG@plats?1ttrain3?4wav?$AA@
CONST	SEGMENT
??_C@_0BC@OFOG@plats?1ttrain3?4wav?$AA@ DB 'plats/ttrain3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IFBM@plats?1ttrain4?4wav?$AA@
CONST	SEGMENT
??_C@_0BC@IFBM@plats?1ttrain4?4wav?$AA@ DB 'plats/ttrain4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MFFG@plats?1ttrain6?4wav?$AA@
CONST	SEGMENT
??_C@_0BC@MFFG@plats?1ttrain6?4wav?$AA@ DB 'plats/ttrain6.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GFHD@plats?1ttrain7?4wav?$AA@
CONST	SEGMENT
??_C@_0BC@GFHD@plats?1ttrain7?4wav?$AA@ DB 'plats/ttrain7.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DAGB@plats?1ttrain_start1?4wav?$AA@
CONST	SEGMENT
??_C@_0BI@DAGB@plats?1ttrain_start1?4wav?$AA@ DB 'plats/ttrain_start1.wav'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LCPH@plats?1ttrain_brake1?4wav?$AA@
CONST	SEGMENT
??_C@_0BI@LCPH@plats?1ttrain_brake1?4wav?$AA@ DB 'plats/ttrain_brake1.wav'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?Precache@CFuncTrackTrain@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_m_sound$ = -8
?Precache@CFuncTrackTrain@@UAEXXZ PROC NEAR		; CFuncTrackTrain::Precache, COMDAT

; 2515 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2516 : 	if( !m_flVolume )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1872]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38511

; 2517 : 		m_flVolume = 1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1872], 1065353216	; 3f800000H
$L38511:

; 2518 : 
; 2519 : 	int m_sound = UTIL_LoadSoundPreset( m_sounds );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1860]
	push	eax
	call	?UTIL_LoadSoundPreset@@YAHH@Z		; UTIL_LoadSoundPreset
	add	esp, 4
	mov	DWORD PTR _m_sound$[ebp], eax

; 2522 : 	{

	mov	ecx, DWORD PTR _m_sound$[ebp]
	mov	DWORD PTR -12+[ebp], ecx
	cmp	DWORD PTR -12+[ebp], 6
	ja	$L38530
	mov	edx, DWORD PTR -12+[ebp]
	jmp	DWORD PTR $L41331[edx*4]
$L38517:

; 2523 : 	case 0: pev->noise = 0; break; // no sound

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+488], 0
	jmp	$L38514
$L38518:

; 2524 : 	case 1: pev->noise = UTIL_PrecacheSound( "plats/ttrain1.wav" ); break;

	push	OFFSET FLAT:??_C@_0BC@KFKM@plats?1ttrain1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+488], eax
	jmp	$L38514
$L38520:

; 2525 : 	case 2: pev->noise = UTIL_PrecacheSound( "plats/ttrain2.wav" ); break;

	push	OFFSET FLAT:??_C@_0BC@EFMD@plats?1ttrain2?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+488], eax
	jmp	$L38514
$L38522:

; 2526 : 	case 3: pev->noise = UTIL_PrecacheSound( "plats/ttrain3.wav" ); break;

	push	OFFSET FLAT:??_C@_0BC@OFOG@plats?1ttrain3?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+488], eax
	jmp	SHORT $L38514
$L38524:

; 2527 : 	case 4: pev->noise = UTIL_PrecacheSound( "plats/ttrain4.wav" ); break;

	push	OFFSET FLAT:??_C@_0BC@IFBM@plats?1ttrain4?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+488], eax
	jmp	SHORT $L38514
$L38526:

; 2528 : 	case 5: pev->noise = UTIL_PrecacheSound( "plats/ttrain6.wav" ); break;

	push	OFFSET FLAT:??_C@_0BC@MFFG@plats?1ttrain6?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+488], eax
	jmp	SHORT $L38514
$L38528:

; 2529 : 	case 6: pev->noise = UTIL_PrecacheSound( "plats/ttrain7.wav" ); break;

	push	OFFSET FLAT:??_C@_0BC@GFHD@plats?1ttrain7?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+488], eax
	jmp	SHORT $L38514
$L38530:

; 2530 : 	default: pev->noise = UTIL_PrecacheSound( m_sound ); break;

	mov	edx, DWORD PTR _m_sound$[ebp]
	push	edx
	call	?UTIL_PrecacheSound@@YAHH@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax
$L38514:

; 2532 : 
; 2533 : 	if( m_soundStart != NULL_STRING )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1864], 0
	je	SHORT $L38531

; 2534 : 		pev->noise1 = UTIL_PrecacheSound( m_soundStart );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1864]
	push	edx
	call	?UTIL_PrecacheSound@@YAHH@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 2535 : 	else pev->noise1 = UTIL_PrecacheSound( "plats/ttrain_start1.wav" );

	jmp	SHORT $L38532
$L38531:
	push	OFFSET FLAT:??_C@_0BI@DAGB@plats?1ttrain_start1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax
$L38532:

; 2536 : 
; 2537 : 	if( m_soundStop != NULL_STRING )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1868], 0
	je	SHORT $L38534

; 2538 : 		pev->noise2 = UTIL_PrecacheSound( m_soundStop );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1868]
	push	edx
	call	?UTIL_PrecacheSound@@YAHH@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 2539 : 	else pev->noise2 = UTIL_PrecacheSound( "plats/ttrain_brake1.wav" );

	jmp	SHORT $L38535
$L38534:
	push	OFFSET FLAT:??_C@_0BI@LCPH@plats?1ttrain_brake1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax
$L38535:

; 2540 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L41331:
	DD	$L38517
	DD	$L38518
	DD	$L38520
	DD	$L38522
	DD	$L38524
	DD	$L38526
	DD	$L38528
?Precache@CFuncTrackTrain@@UAEXXZ ENDP			; CFuncTrackTrain::Precache
_TEXT	ENDS
PUBLIC	?UpdateOnRemove@CFuncTrackTrain@@QAEXXZ		; CFuncTrackTrain::UpdateOnRemove
EXTRN	?UpdateOnRemove@CBaseEntity@@QAEXXZ:NEAR	; CBaseEntity::UpdateOnRemove
;	COMDAT ?UpdateOnRemove@CFuncTrackTrain@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?UpdateOnRemove@CFuncTrackTrain@@QAEXXZ PROC NEAR	; CFuncTrackTrain::UpdateOnRemove, COMDAT

; 2543 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2544 : 	StopSound();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopSound@CFuncTrackTrain@@QAEXXZ	; CFuncTrackTrain::StopSound

; 2545 : 	BaseClass::UpdateOnRemove();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateOnRemove@CBaseEntity@@QAEXXZ	; CBaseEntity::UpdateOnRemove

; 2546 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateOnRemove@CFuncTrackTrain@@QAEXXZ ENDP		; CFuncTrackTrain::UpdateOnRemove
_TEXT	ENDS
;	COMDAT _$E77
_TEXT	SEGMENT
_$E77	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E76
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E77	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncTrainControls@@@@QAE@PBD@Z ; CEntityFactory<CFuncTrainControls>::CEntityFactory<CFuncTrainControls>
PUBLIC	??_C@_0BD@PKJK@func_traincontrols?$AA@		; `string'
_BSS	SEGMENT
_func_traincontrols DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BD@PKJK@func_traincontrols?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BD@PKJK@func_traincontrols?$AA@ DB 'func_traincontrols', 00H ; `string'
CONST	ENDS
;	COMDAT _$E76
_TEXT	SEGMENT
_$E76	PROC NEAR					; COMDAT

; 2560 : LINK_ENTITY_TO_CLASS( func_traincontrols, CFuncTrainControls );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BD@PKJK@func_traincontrols?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_traincontrols
	call	??0?$CEntityFactory@VCFuncTrainControls@@@@QAE@PBD@Z ; CEntityFactory<CFuncTrainControls>::CEntityFactory<CFuncTrainControls>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E76	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CFuncTrainControls@@UAEPAUdatamap_s@@XZ ; CFuncTrainControls::GetDataDescMap
;	COMDAT ?GetDataDescMap@CFuncTrainControls@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CFuncTrainControls@@UAEPAUdatamap_s@@XZ PROC NEAR ; CFuncTrainControls::GetDataDescMap, COMDAT

; 2562 : BEGIN_DATADESC( CFuncTrainControls )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTrainControls@@2Udatamap_s@@A ; CFuncTrainControls::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CFuncTrainControls@@UAEPAUdatamap_s@@XZ ENDP ; CFuncTrainControls::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CFuncTrainControls@@SAPAUdatamap_s@@XZ ; CFuncTrainControls::GetBaseMap
;	COMDAT ?GetBaseMap@CFuncTrainControls@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CFuncTrainControls@@SAPAUdatamap_s@@XZ PROC NEAR ; CFuncTrainControls::GetBaseMap, COMDAT

; 2562 : BEGIN_DATADESC( CFuncTrainControls )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CFuncTrainControls@@SAPAUdatamap_s@@XZ ENDP	; CFuncTrainControls::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E80
_TEXT	SEGMENT
_$E80	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E79
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E80	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z ; DataMapInit
;	COMDAT _$E79
_TEXT	SEGMENT
_$E79	PROC NEAR					; COMDAT

; 2562 : BEGIN_DATADESC( CFuncTrainControls )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CFuncTrainControls_DataDescInit@@3PAUdatamap_s@@A, eax ; CFuncTrainControls_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E79	ENDP
_TEXT	ENDS
PUBLIC	?Find@CFuncTrainControls@@QAEXXZ		; CFuncTrainControls::Find
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S82@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z PROC NEAR ; DataMapInit, COMDAT

; 2562 : BEGIN_DATADESC( CFuncTrainControls )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S82@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L38640
	mov	cl, BYTE PTR _?$S82@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S82@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0BD@NFLN@CFuncTrainControls?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E83
	call	_atexit
	add	esp, 4
$L38640:
	call	?GetBaseMap@CFuncTrainControls@@SAPAUdatamap_s@@XZ ; CFuncTrainControls::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CFuncTrainControls@@2Udatamap_s@@A+12, eax

; 2563 : 	DEFINE_FUNCTION( Find ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S82@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	SHORT $L38644
	mov	al, BYTE PTR _?$S82@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S82@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_04GOJF@Find?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4PAUtypedescription_s@@A+28, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4PAUtypedescription_s@@A+32, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4PAUtypedescription_s@@A+36, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4PAUtypedescription_s@@A+38, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4PAUtypedescription_s@@A+40, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4PAUtypedescription_s@@A+44, OFFSET FLAT:?Find@CFuncTrainControls@@QAEXXZ ; CFuncTrainControls::Find
$L38644:

; 2564 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L38647
	mov	DWORD PTR ?m_DataMap@CFuncTrainControls@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncTrainControls@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L38648
$L38647:
	mov	DWORD PTR ?m_DataMap@CFuncTrainControls@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncTrainControls@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4PAUtypedescription_s@@A
$L38648:
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTrainControls@@2Udatamap_s@@A ; CFuncTrainControls::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z ENDP ; DataMapInit
_TEXT	ENDS
;	COMDAT _$E83
_TEXT	SEGMENT
_$E83	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrainControls@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E83	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@MHDA@TrackTrainControls?3?5No?5train?5?$CFs?6@ ; `string'
;	COMDAT ??_C@_0CB@MHDA@TrackTrainControls?3?5No?5train?5?$CFs?6@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0CB@MHDA@TrackTrainControls?3?5No?5train?5?$CFs?6@ DB 'TrackTrainCo'
	DB	'ntrols: No train %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?Find@CFuncTrainControls@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pTarget$ = -8
_ptrain$ = -12
?Find@CFuncTrainControls@@QAEXXZ PROC NEAR		; CFuncTrainControls::Find, COMDAT

; 2567 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2568 : 	CBaseEntity *pTarget = NULL;

	mov	DWORD PTR _pTarget$[ebp], 0
$L38655:

; 2572 : 		pTarget = UTIL_FindEntityByTargetname( pTarget, GetTarget( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTarget@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTarget
	push	eax
	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pTarget$[ebp], eax

; 2573 : 	} while ( pTarget && !FClassnameIs( pTarget, "func_tracktrain" ));

	cmp	DWORD PTR _pTarget$[ebp], 0
	je	SHORT $L38658
	push	OFFSET FLAT:??_C@_0BA@KOLE@func_tracktrain?$AA@ ; `string'
	mov	ecx, DWORD PTR _pTarget$[ebp]
	push	ecx
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L38655
$L38658:

; 2574 : 
; 2575 : 	if( !pTarget )

	cmp	DWORD PTR _pTarget$[ebp], 0
	jne	SHORT $L38659

; 2577 : 		ALERT( at_error, "TrackTrainControls: No train %s\n", GetTarget( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTarget@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTarget
	push	eax
	push	OFFSET FLAT:??_C@_0CB@MHDA@TrackTrainControls?3?5No?5train?5?$CFs?6@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2578 : 		UTIL_Remove( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 2579 : 		return;

	jmp	SHORT $L38653
$L38659:

; 2581 : 
; 2582 : 	// UNDONE: attach traincontrols with parent system if origin-brush is present?
; 2583 : 	CFuncTrackTrain *ptrain = (CFuncTrackTrain *)pTarget;

	mov	eax, DWORD PTR _pTarget$[ebp]
	mov	DWORD PTR _ptrain$[ebp], eax

; 2584 : 	ptrain->SetControls( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ptrain$[ebp]
	call	?SetControls@CFuncTrackTrain@@QAEXPAVCBaseEntity@@@Z ; CFuncTrackTrain::SetControls

; 2585 : 	UTIL_Remove( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4
$L38653:

; 2586 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Find@CFuncTrainControls@@QAEXXZ ENDP			; CFuncTrainControls::Find
_TEXT	ENDS
PUBLIC	?Spawn@CFuncTrainControls@@UAEXXZ		; CFuncTrainControls::Spawn
;	COMDAT ?Spawn@CFuncTrainControls@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CFuncTrainControls@@UAEXXZ PROC NEAR		; CFuncTrainControls::Spawn, COMDAT

; 2589 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2590 : 	pev->solid = SOLID_NOT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 0

; 2591 : 	pev->movetype = MOVETYPE_NONE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 0

; 2592 : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 2593 : 
; 2594 : 	UTIL_SetSize( pev, pev->mins, pev->maxs );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 232				; 000000e8H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 220				; 000000dcH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 2595 : 	RelinkEntity( TRUE );

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 2596 : 	
; 2597 : 	SetThink( Find );

	push	OFFSET FLAT:??_C@_04GOJF@Find?$AA@	; `string'
	push	OFFSET FLAT:?Find@CFuncTrainControls@@QAEXXZ ; CFuncTrainControls::Find
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 2598 : 	SetNextThink( 0.0f );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 2599 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncTrainControls@@UAEXXZ ENDP			; CFuncTrainControls::Spawn
_TEXT	ENDS
;	COMDAT _$E86
_TEXT	SEGMENT
_$E86	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E85
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E86	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncTrackChange@@@@QAE@PBD@Z ; CEntityFactory<CFuncTrackChange>::CEntityFactory<CFuncTrackChange>
PUBLIC	??_C@_0BB@EDIN@func_trackchange?$AA@		; `string'
_BSS	SEGMENT
	ALIGN	4

_func_trackchange DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BB@EDIN@func_trackchange?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BB@EDIN@func_trackchange?$AA@ DB 'func_trackchange', 00H ; `string'
CONST	ENDS
;	COMDAT _$E85
_TEXT	SEGMENT
_$E85	PROC NEAR					; COMDAT

; 2667 : LINK_ENTITY_TO_CLASS( func_trackchange, CFuncTrackChange );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BB@EDIN@func_trackchange?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_trackchange
	call	??0?$CEntityFactory@VCFuncTrackChange@@@@QAE@PBD@Z ; CEntityFactory<CFuncTrackChange>::CEntityFactory<CFuncTrackChange>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E85	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CFuncTrackChange@@UAEPAUdatamap_s@@XZ ; CFuncTrackChange::GetDataDescMap
;	COMDAT ?GetDataDescMap@CFuncTrackChange@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CFuncTrackChange@@UAEPAUdatamap_s@@XZ PROC NEAR ; CFuncTrackChange::GetDataDescMap, COMDAT

; 2669 : BEGIN_DATADESC( CFuncTrackChange )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTrackChange@@2Udatamap_s@@A ; CFuncTrackChange::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CFuncTrackChange@@UAEPAUdatamap_s@@XZ ENDP ; CFuncTrackChange::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CFuncTrackChange@@SAPAUdatamap_s@@XZ ; CFuncTrackChange::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCFuncPlatRot@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CFuncTrackChange@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CFuncTrackChange@@SAPAUdatamap_s@@XZ PROC NEAR ; CFuncTrackChange::GetBaseMap, COMDAT

; 2669 : BEGIN_DATADESC( CFuncTrackChange )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCFuncPlatRot@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CFuncTrackChange@@SAPAUdatamap_s@@XZ ENDP	; CFuncTrackChange::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E89
_TEXT	SEGMENT
_$E89	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E88
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E89	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z ; DataMapInit
;	COMDAT _$E88
_TEXT	SEGMENT
_$E88	PROC NEAR					; COMDAT

; 2669 : BEGIN_DATADESC( CFuncTrackChange )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CFuncTrackChange_DataDescInit@@3PAUdatamap_s@@A, eax ; CFuncTrackChange_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E88	ENDP
_TEXT	ENDS
PUBLIC	?Find@CFuncTrackChange@@QAEXXZ			; CFuncTrackChange::Find
PUBLIC	??_C@_04JFMM@GoUp?$AA@				; `string'
PUBLIC	??_9@$BBFM@AE					; `vcall'
PUBLIC	??_C@_06OMMA@GoDown?$AA@			; `string'
PUBLIC	??_9@$BBGA@AE					; `vcall'
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S91@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04JFMM@GoUp?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_04JFMM@GoUp?$AA@ DB 'GoUp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OMMA@GoDown?$AA@
CONST	SEGMENT
??_C@_06OMMA@GoDown?$AA@ DB 'GoDown', 00H		; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z PROC NEAR ; DataMapInit, COMDAT

; 2669 : BEGIN_DATADESC( CFuncTrackChange )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S91@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L38831
	mov	cl, BYTE PTR _?$S91@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S91@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0BB@MCNO@CFuncTrackChange?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E92
	call	_atexit
	add	esp, 4
$L38831:
	call	?GetBaseMap@CFuncTrackChange@@SAPAUdatamap_s@@XZ ; CFuncTrackChange::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CFuncTrackChange@@2Udatamap_s@@A+12, eax

; 2670 : 	DEFINE_GLOBAL_FIELD( m_trackTop, FIELD_CLASSPTR ),
; 2671 : 	DEFINE_GLOBAL_FIELD( m_trackBottom, FIELD_CLASSPTR ),
; 2672 : 	DEFINE_GLOBAL_FIELD( m_train, FIELD_CLASSPTR ),
; 2673 : 	DEFINE_GLOBAL_KEYFIELD( m_trackTopName, FIELD_STRING, "toptrack" ),
; 2674 : 	DEFINE_GLOBAL_KEYFIELD( m_trackBottomName, FIELD_STRING, "bottomtrack" ),
; 2675 : 	DEFINE_GLOBAL_KEYFIELD( m_trainName, FIELD_STRING, "train" ),
; 2676 : 	DEFINE_FIELD( m_code, FIELD_INTEGER ),
; 2677 : 	DEFINE_FIELD( m_targetState, FIELD_INTEGER ),
; 2678 : 	DEFINE_FIELD( m_use, FIELD_BOOLEAN ),
; 2679 : 	DEFINE_FIELD( m_flRadius, FIELD_FLOAT ),
; 2680 : 	DEFINE_FUNCTION( GoUp ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S91@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L38868
	mov	al, BYTE PTR _?$S91@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S91@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_04JFMM@GoUp?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+268, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+272, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+276, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+278, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+280, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+284, OFFSET FLAT:??_9@$BBFM@AE ; `vcall'

; 2681 : 	DEFINE_FUNCTION( GoDown ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+288, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_06OMMA@GoDown?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+292, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+296, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+300, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+302, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+304, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+308, OFFSET FLAT:??_9@$BBGA@AE ; `vcall'

; 2682 : 	DEFINE_FUNCTION( Find ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+312, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_04GOJF@Find?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+316, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+320, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+324, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+326, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+328, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+332, OFFSET FLAT:?Find@CFuncTrackChange@@QAEXXZ ; CFuncTrackChange::Find
$L38868:

; 2683 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L38879
	mov	DWORD PTR ?m_DataMap@CFuncTrackChange@@2Udatamap_s@@A+4, 13 ; 0000000dH
	mov	DWORD PTR ?m_DataMap@CFuncTrackChange@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L38880
$L38879:
	mov	DWORD PTR ?m_DataMap@CFuncTrackChange@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncTrackChange@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4PAUtypedescription_s@@A
$L38880:
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTrackChange@@2Udatamap_s@@A ; CFuncTrackChange::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z ENDP ; DataMapInit
_TEXT	ENDS
;	COMDAT _$E92
_TEXT	SEGMENT
_$E92	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTrackChange@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E92	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CFuncTrackChange@@UAEXXZ			; CFuncTrackChange::Spawn
PUBLIC	?EnableUse@CFuncTrackChange@@QAEXXZ		; CFuncTrackChange::EnableUse
;	COMDAT ?Spawn@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CFuncTrackChange@@UAEXXZ PROC NEAR		; CFuncTrackChange::Spawn, COMDAT

; 2686 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2687 : 	Setup();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Setup@CFuncPlat@@QAEXXZ		; CFuncPlat::Setup

; 2688 : 
; 2689 : 	if( FBitSet( pev->spawnflags, SF_TRACK_DONT_MOVE ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 16					; 00000010H
	test	edx, edx
	je	SHORT $L38886

; 2690 : 		m_vecPosition2 = m_vecPosition1;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1840				; 00000730H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L38886:

; 2691 : 
; 2692 : 	SetupRotation();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupRotation@CFuncPlatRot@@QAEXXZ	; CFuncPlatRot::SetupRotation

; 2693 : 
; 2694 : 	if( FBitSet( pev->spawnflags, SF_TRACK_STARTBOTTOM ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 8
	test	eax, eax
	je	SHORT $L38887

; 2696 : 		UTIL_SetOrigin( this, m_vecPosition2 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 2697 : 		m_toggle_state = TS_AT_BOTTOM;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1816], 1

; 2698 : 		SetLocalAngles( m_start );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1984				; 000007c0H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 2699 : 		m_targetState = TS_AT_TOP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2028], 0

; 2701 : 	else

	jmp	SHORT $L38888
$L38887:

; 2703 : 		UTIL_SetOrigin( this, m_vecPosition1 );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1840				; 00000730H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 2704 : 		m_toggle_state = TS_AT_TOP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1816], 0

; 2705 : 		SetLocalAngles( m_end );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1972				; 000007b4H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 2706 : 		m_targetState = TS_AT_BOTTOM;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2028], 1
$L38888:

; 2708 : 
; 2709 : 	EnableUse();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnableUse@CFuncTrackChange@@QAEXXZ	; CFuncTrackChange::EnableUse

; 2710 : 	SetNextThink( 2.0f ); // let's train spawn

	push	1073741824				; 40000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]

; 2711 : 	SetThink( Find );

	push	OFFSET FLAT:??_C@_04GOJF@Find?$AA@	; `string'
	push	OFFSET FLAT:?Find@CFuncTrackChange@@QAEXXZ ; CFuncTrackChange::Find
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 2712 : 	Precache();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 2713 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncTrackChange@@UAEXXZ ENDP			; CFuncTrackChange::Spawn
_TEXT	ENDS
;	COMDAT ?EnableUse@CFuncTrackChange@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?EnableUse@CFuncTrackChange@@QAEXXZ PROC NEAR		; CFuncTrackChange::EnableUse, COMDAT

; 2646 : 	void		EnableUse( void ) { m_use = 1; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2032], 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EnableUse@CFuncTrackChange@@QAEXXZ ENDP		; CFuncTrackChange::EnableUse
_TEXT	ENDS
PUBLIC	?Precache@CFuncTrackChange@@UAEXXZ		; CFuncTrackChange::Precache
PUBLIC	??_C@_0BF@CGCH@buttons?1button11?4wav?$AA@	; `string'
;	COMDAT ??_C@_0BF@CGCH@buttons?1button11?4wav?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BF@CGCH@buttons?1button11?4wav?$AA@ DB 'buttons/button11.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?Precache@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CFuncTrackChange@@UAEXXZ PROC NEAR		; CFuncTrackChange::Precache, COMDAT

; 2716 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2717 : 	// Can't trigger sound
; 2718 : 	PRECACHE_SOUND( "buttons/button11.wav" );

	push	OFFSET FLAT:??_C@_0BF@CGCH@buttons?1button11?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 2719 : 	
; 2720 : 	BaseClass::Precache();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Precache@CFuncPlat@@UAEXXZ		; CFuncPlat::Precache

; 2721 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CFuncTrackChange@@UAEXXZ ENDP			; CFuncTrackChange::Precache
_TEXT	ENDS
PUBLIC	?KeyValue@CFuncTrackChange@@UAEXPAUKeyValueData_s@@@Z ; CFuncTrackChange::KeyValue
PUBLIC	??_C@_06JGHA@radius?$AA@			; `string'
;	COMDAT ??_C@_06JGHA@radius?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_06JGHA@radius?$AA@ DB 'radius', 00H		; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CFuncTrackChange@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CFuncTrackChange@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CFuncTrackChange::KeyValue, COMDAT

; 2724 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2725 : 	if( FStrEq( pkvd->szKeyName, "train" ))

	push	OFFSET FLAT:??_C@_05HLPG@train?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38900

; 2727 : 		m_trainName = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2016], eax

; 2728 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 2730 : 	else if( FStrEq( pkvd->szKeyName, "toptrack" ))

	jmp	$L38908
$L38900:
	push	OFFSET FLAT:??_C@_08DIO@toptrack?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38902

; 2732 : 		m_trackTopName = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2008], eax

; 2733 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 2735 : 	else if( FStrEq( pkvd->szKeyName, "bottomtrack" ))

	jmp	$L38908
$L38902:
	push	OFFSET FLAT:??_C@_0M@DPJA@bottomtrack?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38904

; 2737 : 		m_trackBottomName = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2012], eax

; 2738 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 2740 : 	else if( FStrEq( pkvd->szKeyName, "radius" ))

	jmp	SHORT $L38908
$L38904:
	push	OFFSET FLAT:??_C@_06JGHA@radius?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38906

; 2742 : 		m_flRadius = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2024]

; 2743 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 2745 : 	else

	jmp	SHORT $L38908
$L38906:

; 2747 : 		BaseClass::KeyValue( pkvd ); // Pass up to base class

	mov	eax, DWORD PTR _pkvd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBasePlatTrain@@UAEXPAUKeyValueData_s@@@Z ; CBasePlatTrain::KeyValue
$L38908:

; 2749 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CFuncTrackChange@@UAEXPAUKeyValueData_s@@@Z ENDP ; CFuncTrackChange::KeyValue
_TEXT	ENDS
PUBLIC	?OverrideReset@CFuncTrackChange@@UAEXXZ		; CFuncTrackChange::OverrideReset
;	COMDAT ?OverrideReset@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CFuncTrackChange@@UAEXXZ PROC NEAR	; CFuncTrackChange::OverrideReset, COMDAT

; 2752 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2753 : 	SetMoveDoneTime( 1.0 );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 2754 : 	SetMoveDone( Find );

	push	OFFSET FLAT:??_C@_04GOJF@Find?$AA@	; `string'
	push	OFFSET FLAT:?Find@CFuncTrackChange@@QAEXXZ ; CFuncTrackChange::Find
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 2755 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CFuncTrackChange@@UAEXXZ ENDP		; CFuncTrackChange::OverrideReset
_TEXT	ENDS
PUBLIC	??_C@_0CH@MHNP@Can?8t?5find?5train?5for?5track?5chang@ ; `string'
PUBLIC	??_C@_0CO@CHAO@Can?8t?5find?5bottom?5track?5for?5trac@ ; `string'
PUBLIC	??_C@_0CL@JAGN@Can?8t?5find?5top?5track?5for?5track?5c@ ; `string'
EXTRN	?Nearest@CPathTrack@@QAEPAV1@ABVVector@@@Z:NEAR	; CPathTrack::Nearest
;	COMDAT ??_C@_0CH@MHNP@Can?8t?5find?5train?5for?5track?5chang@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0CH@MHNP@Can?8t?5find?5train?5for?5track?5chang@ DB 'Can''t find tr'
	DB	'ain for track change! %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@CHAO@Can?8t?5find?5bottom?5track?5for?5trac@
CONST	SEGMENT
??_C@_0CO@CHAO@Can?8t?5find?5bottom?5track?5for?5trac@ DB 'Can''t find bo'
	DB	'ttom track for track change! %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JAGN@Can?8t?5find?5top?5track?5for?5track?5c@
CONST	SEGMENT
??_C@_0CL@JAGN@Can?8t?5find?5top?5track?5for?5track?5c@ DB 'Can''t find t'
	DB	'op track for track change! %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?Find@CFuncTrackChange@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pTarget$ = -8
_center$38926 = -20
$T41382 = -32
$T41383 = -44
?Find@CFuncTrackChange@@QAEXXZ PROC NEAR		; CFuncTrackChange::Find, COMDAT

; 2758 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2759 : 	// Find track entities
; 2760 : 	CBaseEntity *pTarget;
; 2761 : 
; 2762 : 	pTarget = UTIL_FindEntityByTargetname( NULL, STRING( m_trackTopName ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2008]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pTarget$[ebp], eax

; 2763 : 
; 2764 : 	if( pTarget && FClassnameIs( pTarget, "path_track" ))

	cmp	DWORD PTR _pTarget$[ebp], 0
	je	$L38920
	push	OFFSET FLAT:??_C@_0L@NGLK@path_track?$AA@ ; `string'
	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	$L38920

; 2766 : 		m_trackTop = (CPathTrack *)pTarget;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	DWORD PTR [eax+1996], ecx

; 2767 : 		pTarget = UTIL_FindEntityByTargetname( NULL, STRING( m_trackBottomName ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2012]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pTarget$[ebp], eax

; 2768 : 
; 2769 : 		if( pTarget && FClassnameIs( pTarget, "path_track" ))

	cmp	DWORD PTR _pTarget$[ebp], 0
	je	$L38922
	push	OFFSET FLAT:??_C@_0L@NGLK@path_track?$AA@ ; `string'
	mov	ecx, DWORD PTR _pTarget$[ebp]
	push	ecx
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	$L38922

; 2771 : 			m_trackBottom = (CPathTrack *)pTarget;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTarget$[ebp]
	mov	DWORD PTR [edx+2000], eax

; 2772 : 			pTarget = UTIL_FindEntityByTargetname( NULL, STRING( m_trainName ));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2016]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pTarget$[ebp], eax

; 2773 : 
; 2774 : 			if( pTarget && FClassnameIs( pTarget, "func_tracktrain" ))

	cmp	DWORD PTR _pTarget$[ebp], 0
	je	$L38924
	push	OFFSET FLAT:??_C@_0BA@KOLE@func_tracktrain?$AA@ ; `string'
	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	$L38924

; 2776 : 				m_train = (CFuncTrackTrain *)pTarget;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTarget$[ebp]
	mov	DWORD PTR [ecx+2004], edx

; 2777 : 				Vector center = (pev->absmin + pev->absmax) * 0.5f;

	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T41383[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 208				; 000000d0H
	push	edx
	lea	eax, DWORD PTR $T41382[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 196				; 000000c4H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _center$38926[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2778 : 				m_trackBottom = m_trackBottom->Nearest( center );

	lea	edx, DWORD PTR _center$38926[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2000]
	call	?Nearest@CPathTrack@@QAEPAV1@ABVVector@@@Z ; CPathTrack::Nearest
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2000], eax

; 2779 : 				m_trackTop = m_trackTop->Nearest( center );

	lea	edx, DWORD PTR _center$38926[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1996]
	call	?Nearest@CPathTrack@@QAEPAV1@ABVVector@@@Z ; CPathTrack::Nearest
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1996], eax

; 2780 : 				UpdateAutoTargets( m_toggle_state );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+368]

; 2781 : 				SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 2782 : 				return;

	jmp	SHORT $L38918
$L38924:

; 2786 : 				ALERT( at_error, "Can't find train for track change! %s\n", STRING( m_trainName ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2016]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CH@MHNP@Can?8t?5find?5train?5for?5track?5chang@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2789 : 		else

	jmp	SHORT $L38933
$L38922:

; 2791 : 			ALERT( at_error, "Can't find bottom track for track change! %s\n", STRING(m_trackBottomName) );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2012]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CO@CHAO@Can?8t?5find?5bottom?5track?5for?5trac@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L38933:

; 2794 : 	else

	jmp	SHORT $L38935
$L38920:

; 2796 : 		ALERT( at_error, "Can't find top track for track change! %s\n", STRING(m_trackTopName) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2008]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CL@JAGN@Can?8t?5find?5top?5track?5for?5track?5c@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L38935:
$L38918:

; 2798 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Find@CFuncTrackChange@@QAEXXZ ENDP			; CFuncTrackChange::Find
_TEXT	ENDS
PUBLIC	?Length2D@Vector@@QBEMXZ			; Vector::Length2D
PUBLIC	__real@4@40069600000000000000
PUBLIC	?GetSpeed@CFuncTrackTrain@@QAEMXZ		; CFuncTrackTrain::GetSpeed
PUBLIC	?EvaluateTrain@CFuncTrackChange@@QAE?AW4TRAIN_CODE@@PAVCPathTrack@@@Z ; CFuncTrackChange::EvaluateTrain
;	COMDAT __real@4@40069600000000000000
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
__real@4@40069600000000000000 DD 043160000r	; 150
CONST	ENDS
;	COMDAT ?EvaluateTrain@CFuncTrackChange@@QAE?AW4TRAIN_CODE@@PAVCPathTrack@@@Z
_TEXT	SEGMENT
_pcurrent$ = 8
_this$ = -4
_dist$38947 = -16
_length$38949 = -20
$T41386 = -32
?EvaluateTrain@CFuncTrackChange@@QAE?AW4TRAIN_CODE@@PAVCPathTrack@@@Z PROC NEAR ; CFuncTrackChange::EvaluateTrain, COMDAT

; 2801 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2802 : 	// Go ahead and work, we don't have anything to switch, so just be an elevator
; 2803 : 	if( !pcurrent || !m_train )

	cmp	DWORD PTR _pcurrent$[ebp], 0
	je	SHORT $L38942
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2004], 0
	jne	SHORT $L38941
$L38942:

; 2804 : 		return TRAIN_SAFE;

	xor	eax, eax
	jmp	$L38940
$L38941:

; 2807 : 		 ( pcurrent->m_pnext && m_train->m_ppath == pcurrent->m_pnext ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2004]
	mov	eax, DWORD PTR [edx+1796]
	cmp	eax, DWORD PTR _pcurrent$[ebp]
	je	SHORT $L38944
	mov	ecx, DWORD PTR _pcurrent$[ebp]
	cmp	DWORD PTR [ecx+1776], 0
	je	SHORT $L38945
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2004]
	mov	ecx, DWORD PTR _pcurrent$[ebp]
	mov	edx, DWORD PTR [eax+1796]
	cmp	edx, DWORD PTR [ecx+1776]
	je	SHORT $L38944
$L38945:
	mov	eax, DWORD PTR _pcurrent$[ebp]
	cmp	DWORD PTR [eax+1772], 0
	je	$L38943
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2004]
	mov	eax, DWORD PTR _pcurrent$[ebp]
	mov	ecx, DWORD PTR [edx+1796]
	cmp	ecx, DWORD PTR [eax+1772]
	jne	$L38943
$L38944:

; 2809 : 		if( m_train->GetSpeed() != 0 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2004]
	call	?GetSpeed@CFuncTrackTrain@@QAEMXZ	; CFuncTrackTrain::GetSpeed
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38946

; 2810 : 			return TRAIN_BLOCKING;

	mov	eax, 1
	jmp	$L38940
$L38946:

; 2811 : 
; 2812 : 		Vector dist = GetLocalOrigin() - m_train->GetLocalOrigin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2004]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	ecx, DWORD PTR $T41386[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _dist$38947[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2813 : 		float length = dist.Length2D();

	lea	ecx, DWORD PTR _dist$38947[ebp]
	call	?Length2D@Vector@@QBEMXZ		; Vector::Length2D
	fstp	DWORD PTR _length$38949[ebp]

; 2814 : 
; 2815 : 		if( length < m_train->m_length ) // empirically determined close distance

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2004]
	fld	DWORD PTR _length$38949[ebp]
	fcomp	DWORD PTR [eax+1804]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38950

; 2816 : 			return TRAIN_FOLLOWING;

	mov	eax, 2
	jmp	SHORT $L38940
$L38950:

; 2817 : 		else if( length > ( 150 + m_train->m_length ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2004]
	fld	DWORD PTR __real@4@40069600000000000000
	fadd	DWORD PTR [edx+1804]
	fcomp	DWORD PTR _length$38949[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38952

; 2818 : 			return TRAIN_SAFE;

	xor	eax, eax
	jmp	SHORT $L38940
$L38952:

; 2819 : 
; 2820 : 		return TRAIN_BLOCKING;

	mov	eax, 1
	jmp	SHORT $L38940
$L38943:

; 2822 : 	return TRAIN_SAFE;

	xor	eax, eax
$L38940:

; 2823 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EvaluateTrain@CFuncTrackChange@@QAE?AW4TRAIN_CODE@@PAVCPathTrack@@@Z ENDP ; CFuncTrackChange::EvaluateTrain
_TEXT	ENDS
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length2D@Vector@@QBEMXZ PROC NEAR			; Vector::Length2D, COMDAT

; 282  : 	inline float Length2D(void) const { return sqrt(x*x + y*y); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length2D@Vector@@QBEMXZ ENDP				; Vector::Length2D
_TEXT	ENDS
;	COMDAT ?GetSpeed@CFuncTrackTrain@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetSpeed@CFuncTrackTrain@@QAEMXZ PROC NEAR		; CFuncTrackTrain::GetSpeed, COMDAT

; 152  : 	float GetSpeed( void ) { return m_flDesiredSpeed; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1896]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpeed@CFuncTrackTrain@@QAEMXZ ENDP			; CFuncTrackTrain::GetSpeed
_TEXT	ENDS
PUBLIC	?DotProduct@@YAMABVVector@@0@Z			; DotProduct
PUBLIC	?UpdateTrain@CFuncTrackChange@@QAEXAAVVector@@@Z ; CFuncTrackChange::UpdateTrain
EXTRN	?UTIL_MakeInvVectors@@YAXABVVector@@PAUglobalvars_t@@@Z:NEAR ; UTIL_MakeInvVectors
;	COMDAT ?UpdateTrain@CFuncTrackChange@@QAEXAAVVector@@@Z
_TEXT	SEGMENT
_dest$ = 8
_this$ = -4
_time$ = -8
_offset$ = -20
_local$ = -32
_delta$ = -44
$T41395 = -56
$T41396 = -68
$T41397 = -80
$T41398 = -92
$T41399 = -104
?UpdateTrain@CFuncTrackChange@@QAEXAAVVector@@@Z PROC NEAR ; CFuncTrackChange::UpdateTrain, COMDAT

; 2826 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2827 : 	float time = GetMoveDoneTime();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMoveDoneTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetMoveDoneTime
	fstp	DWORD PTR _time$[ebp]

; 2828 : 
; 2829 : 	m_train->SetAbsVelocity( GetAbsVelocity() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2004]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 2830 : 	m_train->SetLocalAvelocity( GetLocalAvelocity() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+2004]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 2831 : 	m_train->SetMoveDoneTime( time );

	mov	edx, DWORD PTR _time$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2004]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 2832 : 
; 2833 : 	// attempt at getting the train to rotate properly around the origin of the trackchange
; 2834 : 	if( time <= 0 )

	fld	DWORD PTR _time$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38958

; 2835 : 		return;

	jmp	$L38956
$L38958:

; 2836 : 
; 2837 : 	Vector offset = m_train->GetLocalOrigin() - GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	ecx, DWORD PTR $T41395[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2004]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _offset$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2838 : 	Vector local, delta = dest - GetLocalAngles();

	lea	ecx, DWORD PTR _local$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	lea	eax, DWORD PTR $T41396[ebp]
	push	eax
	mov	ecx, DWORD PTR _dest$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _delta$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2839 : 
; 2840 : 	// Transform offset into local coordinates
; 2841 : 	UTIL_MakeInvVectors( delta, gpGlobals );

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	push	ecx
	lea	edx, DWORD PTR _delta$[ebp]
	push	edx
	call	?UTIL_MakeInvVectors@@YAXABVVector@@PAUglobalvars_t@@@Z ; UTIL_MakeInvVectors
	add	esp, 8

; 2842 : 	local.x = DotProduct( offset, gpGlobals->v_forward );

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	eax, 40					; 00000028H
	push	eax
	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _local$[ebp]

; 2843 : 	local.y = DotProduct( offset, gpGlobals->v_right );

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	edx, 64					; 00000040H
	push	edx
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _local$[ebp+4]

; 2844 : 	local.z = DotProduct( offset, gpGlobals->v_up );

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 52					; 00000034H
	push	ecx
	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _local$[ebp+8]

; 2845 : 
; 2846 : 	local = local - offset;

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41397[ebp]
	push	ecx
	lea	ecx, DWORD PTR _local$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _local$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _local$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _local$[ebp+8], edx

; 2847 : 	m_train->SetAbsVelocity( GetAbsVelocity() + ( local * (1.0f / time )) );

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _time$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T41398[ebp]
	push	eax
	lea	ecx, DWORD PTR _local$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T41399[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2004]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L38956:

; 2848 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateTrain@CFuncTrackChange@@QAEXAAVVector@@@Z ENDP	; CFuncTrackChange::UpdateTrain
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProduct@@YAMABVVector@@0@Z PROC NEAR		; DotProduct, COMDAT

; 289  : inline float DotProduct(const Vector& a, const Vector& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector@@0@Z ENDP			; DotProduct
_TEXT	ENDS
PUBLIC	?GoDown@CFuncTrackChange@@UAEXXZ		; CFuncTrackChange::GoDown
EXTRN	?AngularMove@CBaseToggle@@QAEXABVVector@@M@Z:NEAR ; CBaseToggle::AngularMove
;	COMDAT ?GoDown@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?GoDown@CFuncTrackChange@@UAEXXZ PROC NEAR		; CFuncTrackChange::GoDown, COMDAT

; 2851 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2852 : 	if( m_code == TRAIN_BLOCKING )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2020], 1
	jne	SHORT $L38971

; 2853 : 		return;

	jmp	$L38970
$L38971:

; 2854 : 
; 2855 : 	// HitBottom may get called during CFuncPlat::GoDown(), so set up for that
; 2856 : 	// before you call GoDown()
; 2857 : 
; 2858 : 	UpdateAutoTargets( TS_GOING_DOWN );

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+368]

; 2859 : 
; 2860 : 	// If ROTMOVE, move & rotate
; 2861 : 	if( FBitSet( pev->spawnflags, SF_TRACK_DONT_MOVE ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 16					; 00000010H
	test	edx, edx
	je	SHORT $L38972

; 2863 : 		SetMoveDone( CallHitBottom );

	push	OFFSET FLAT:??_C@_0O@FDMJ@CallHitBottom?$AA@ ; `string'
	push	OFFSET FLAT:?CallHitBottom@CFuncPlat@@QAEXXZ ; CFuncPlat::CallHitBottom
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 2864 : 		m_toggle_state = TS_GOING_DOWN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1816], 3

; 2865 : 		AngularMove( m_start, pev->speed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1984				; 000007c0H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AngularMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::AngularMove

; 2867 : 	else

	jmp	SHORT $L38975
$L38972:

; 2869 : 		CFuncPlat :: GoDown();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GoDown@CFuncPlat@@UAEXXZ		; CFuncPlat::GoDown

; 2870 : 		SetMoveDone( CallHitBottom );

	push	OFFSET FLAT:??_C@_0O@FDMJ@CallHitBottom?$AA@ ; `string'
	push	OFFSET FLAT:?CallHitBottom@CFuncPlat@@QAEXXZ ; CFuncPlat::CallHitBottom
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 2871 : 		RotMove( m_start, GetMoveDoneTime() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMoveDoneTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetMoveDoneTime
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1984				; 000007c0H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotMove@CFuncPlatRot@@QAEXAAVVector@@M@Z ; CFuncPlatRot::RotMove
$L38975:

; 2873 : 
; 2874 : 	// Otherwise, rotate first, move second
; 2875 : 
; 2876 : 	// If the train is moving with the platform, update it
; 2877 : 	if( m_code == TRAIN_FOLLOWING )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2020], 2
	jne	SHORT $L38978

; 2879 : 		UpdateTrain( m_start );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1984				; 000007c0H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateTrain@CFuncTrackChange@@QAEXAAVVector@@@Z ; CFuncTrackChange::UpdateTrain

; 2880 : 		m_train->m_ppath = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2004]
	mov	DWORD PTR [eax+1796], 0
$L38978:
$L38970:

; 2882 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GoDown@CFuncTrackChange@@UAEXXZ ENDP			; CFuncTrackChange::GoDown
_TEXT	ENDS
PUBLIC	?GoUp@CFuncTrackChange@@UAEXXZ			; CFuncTrackChange::GoUp
;	COMDAT ?GoUp@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?GoUp@CFuncTrackChange@@UAEXXZ PROC NEAR		; CFuncTrackChange::GoUp, COMDAT

; 2888 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2889 : 	if( m_code == TRAIN_BLOCKING )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2020], 1
	jne	SHORT $L38983

; 2890 : 		return;

	jmp	$L38982
$L38983:

; 2891 : 
; 2892 : 	// HitTop may get called during CFuncPlat::GoUp(), so set up for that
; 2893 : 	// before you call GoUp();
; 2894 : 
; 2895 : 	UpdateAutoTargets( TS_GOING_UP );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+368]

; 2896 : 
; 2897 : 	if( FBitSet( pev->spawnflags, SF_TRACK_DONT_MOVE ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 16					; 00000010H
	test	edx, edx
	je	SHORT $L38984

; 2899 : 		m_toggle_state = TS_GOING_UP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1816], 2

; 2900 : 		SetMoveDone( CallHitTop );

	push	OFFSET FLAT:??_C@_0L@OBGH@CallHitTop?$AA@ ; `string'
	push	OFFSET FLAT:?CallHitTop@CFuncPlat@@QAEXXZ ; CFuncPlat::CallHitTop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 2901 : 		AngularMove( m_end, pev->speed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1972				; 000007b4H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AngularMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::AngularMove

; 2903 : 	else

	jmp	SHORT $L38987
$L38984:

; 2905 : 		// If ROTMOVE, move & rotate
; 2906 : 		CFuncPlat :: GoUp();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GoUp@CFuncPlat@@UAEXXZ			; CFuncPlat::GoUp

; 2907 : 		SetMoveDone( CallHitTop );

	push	OFFSET FLAT:??_C@_0L@OBGH@CallHitTop?$AA@ ; `string'
	push	OFFSET FLAT:?CallHitTop@CFuncPlat@@QAEXXZ ; CFuncPlat::CallHitTop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 2908 : 		RotMove( m_end, GetMoveDoneTime( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMoveDoneTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetMoveDoneTime
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1972				; 000007b4H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotMove@CFuncPlatRot@@QAEXAAVVector@@M@Z ; CFuncPlatRot::RotMove
$L38987:

; 2910 : 	
; 2911 : 	// Otherwise, move first, rotate second
; 2912 : 
; 2913 : 	// If the train is moving with the platform, update it
; 2914 : 	if( m_code == TRAIN_FOLLOWING )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2020], 2
	jne	SHORT $L38990

; 2916 : 		UpdateTrain( m_end );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1972				; 000007b4H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateTrain@CFuncTrackChange@@QAEXAAVVector@@@Z ; CFuncTrackChange::UpdateTrain

; 2917 : 		m_train->m_ppath = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2004]
	mov	DWORD PTR [eax+1796], 0
$L38990:
$L38982:

; 2919 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GoUp@CFuncTrackChange@@UAEXXZ ENDP			; CFuncTrackChange::GoUp
_TEXT	ENDS
PUBLIC	?UpdateAutoTargets@CFuncTrackChange@@UAEXH@Z	; CFuncTrackChange::UpdateAutoTargets
EXTRN	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z:NEAR ; CBaseDelay::SUB_UseTargets
;	COMDAT ?UpdateAutoTargets@CFuncTrackChange@@UAEXH@Z
_TEXT	SEGMENT
_toggleState$ = 8
_this$ = -4
?UpdateAutoTargets@CFuncTrackChange@@UAEXH@Z PROC NEAR	; CFuncTrackChange::UpdateAutoTargets, COMDAT

; 2923 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2924 : 	// g-cont. update targets same as func_door
; 2925 : 	if( toggleState == TS_AT_BOTTOM )

	cmp	DWORD PTR _toggleState$[ebp], 1
	jne	$L38995

; 2927 : 		if( !FBitSet( pev->spawnflags, SF_TRACK_STARTBOTTOM ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 8
	test	edx, edx
	jne	SHORT $L38996

; 2928 : 			UTIL_FireTargets( pev->netname, m_hActivator, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+464]
	push	eax
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 2929 : 		else

	jmp	SHORT $L38997
$L38996:

; 2930 : 			UTIL_FireTargets( pev->message, m_hActivator, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+468]
	push	ecx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L38997:

; 2931 : 		SUB_UseTargets( m_hActivator, USE_TOGGLE, 0 );

	push	0
	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets

; 2933 : 	else if( toggleState == TS_AT_TOP )

	jmp	$L38999
$L38995:
	cmp	DWORD PTR _toggleState$[ebp], 0
	jne	$L38999

; 2935 : 		if( FBitSet( pev->spawnflags, SF_TRACK_STARTBOTTOM ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 8
	test	ecx, ecx
	je	SHORT $L39000

; 2936 : 			UTIL_FireTargets( pev->netname, m_hActivator, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 2937 : 		else

	jmp	SHORT $L39001
$L39000:

; 2938 : 			UTIL_FireTargets( pev->message, m_hActivator, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+468]
	push	eax
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L39001:

; 2939 : 		SUB_UseTargets( m_hActivator, USE_TOGGLE, 0 );

	push	0
	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets
$L38999:

; 2941 : 
; 2942 : 	if( !m_trackTop || !m_trackBottom )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1996], 0
	je	SHORT $L39003
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2000], 0
	jne	SHORT $L39002
$L39003:

; 2943 : 		return;

	jmp	$L38994
$L39002:

; 2944 : 
; 2945 : 	if( toggleState == TS_AT_TOP )

	cmp	DWORD PTR _toggleState$[ebp], 0
	jne	SHORT $L39004

; 2946 : 		ClearBits( m_trackTop->pev->spawnflags, SF_PATH_DISABLED );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1996]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	al, -2					; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1996]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+416], eax

; 2947 : 	else

	jmp	SHORT $L39005
$L39004:

; 2948 : 		SetBits( m_trackTop->pev->spawnflags, SF_PATH_DISABLED );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1996]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	or	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1996]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+416], edx
$L39005:

; 2949 : 
; 2950 : 	if( toggleState == TS_AT_BOTTOM )

	cmp	DWORD PTR _toggleState$[ebp], 1
	jne	SHORT $L39006

; 2951 : 		ClearBits( m_trackBottom->pev->spawnflags, SF_PATH_DISABLED );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2000]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2000]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+416], ecx

; 2952 : 	else

	jmp	SHORT $L39007
$L39006:

; 2953 : 		SetBits( m_trackBottom->pev->spawnflags, SF_PATH_DISABLED );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2000]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	or	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2000]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+416], eax
$L39007:
$L38994:

; 2954 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateAutoTargets@CFuncTrackChange@@UAEXH@Z ENDP	; CFuncTrackChange::UpdateAutoTargets
_TEXT	ENDS
PUBLIC	??_C@_0BA@MJH@Found?5train?5?$CFs?6?$AA@	; `string'
PUBLIC	?Use@CFuncTrackChange@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncTrackChange::Use
PUBLIC	?DisableUse@CFuncTrackChange@@QAEXXZ		; CFuncTrackChange::DisableUse
;	COMDAT ??_C@_0BA@MJH@Found?5train?5?$CFs?6?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BA@MJH@Found?5train?5?$CFs?6?$AA@ DB 'Found train %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?Use@CFuncTrackChange@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_useType$ = 16
_this$ = -4
_radius$39025 = -8
_pFind$39027 = -12
?Use@CFuncTrackChange@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CFuncTrackChange::Use, COMDAT

; 2957 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2958 : 	if( FBitSet( pev->spawnflags, SF_TRACK_ONOFF_MODE ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 32					; 00000020H
	test	edx, edx
	je	SHORT $L39022

; 2960 : 		if( useType == USE_ON )

	cmp	DWORD PTR _useType$[ebp], 1
	jne	SHORT $L39016

; 2962 : 			if( m_toggle_state != TS_AT_BOTTOM )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1816], 1
	je	SHORT $L39017

; 2963 : 				return;	// ignore

	jmp	$L39014
$L39017:

; 2965 : 		else if( useType == USE_OFF )

	jmp	SHORT $L39022
$L39016:
	cmp	DWORD PTR _useType$[ebp], 0
	jne	SHORT $L39019

; 2967 : 			if( m_toggle_state != TS_AT_TOP )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 0
	je	SHORT $L39020

; 2968 : 				return;

	jmp	$L39014
$L39020:

; 2970 : 		else if( useType == USE_SET || useType == USE_RESET )

	jmp	SHORT $L39022
$L39019:
	cmp	DWORD PTR _useType$[ebp], 2
	je	SHORT $L39023
	cmp	DWORD PTR _useType$[ebp], 4
	jne	SHORT $L39022
$L39023:

; 2971 : 			return; // completely ignore

	jmp	$L39014
$L39022:

; 2973 : 
; 2974 : 
; 2975 : 	// g-cont. if trainname not specified trackchange always search tracktrain in the model radius 
; 2976 : 	if( FStringNull( m_trainName ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2016]
	push	eax
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	je	$L39030

; 2978 : 		// train not specified - search train in radius of trackchange or custom specfied radius
; 2979 : 		float radius = m_flRadius;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2024]
	mov	DWORD PTR _radius$39025[ebp], edx

; 2980 : 		if( !radius ) radius = ( Q_max( pev->size.x, Q_max( pev->size.y, pev->size.z ))) / 2.0f;

	fld	DWORD PTR _radius$39025[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	$L39026
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+248]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+252]
	fcompp
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41410
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+248]
	fstp	DWORD PTR -16+[ebp]
	jmp	SHORT $L41411
$L41410:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+252]
	fstp	DWORD PTR -16+[ebp]
$L41411:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+244]
	fcomp	DWORD PTR -16+[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41414
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+244]
	fstp	DWORD PTR -20+[ebp]
	jmp	SHORT $L41415
$L41414:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+248]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+252]
	fcompp
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41412
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+248]
	fstp	DWORD PTR -24+[ebp]
	jmp	SHORT $L41413
$L41412:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+252]
	fstp	DWORD PTR -24+[ebp]
$L41413:
	mov	edx, DWORD PTR -24+[ebp]
	mov	DWORD PTR -20+[ebp], edx
$L41415:
	fld	DWORD PTR -20+[ebp]
	fdiv	DWORD PTR __real@4@40008000000000000000
	fstp	DWORD PTR _radius$39025[ebp]
$L39026:

; 2981 : 		CBaseEntity *pFind = NULL;

	mov	DWORD PTR _pFind$39027[ebp], 0
$L39029:

; 2982 : 
; 2983 : 		while(( pFind = UTIL_FindEntityInSphere( pFind, GetAbsOrigin(), radius )) != NULL )

	mov	eax, DWORD PTR _radius$39025[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _pFind$39027[ebp]
	push	ecx
	call	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z ; UTIL_FindEntityInSphere
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFind$39027[ebp], eax
	cmp	DWORD PTR _pFind$39027[ebp], 0
	je	SHORT $L39030

; 2985 : 			if( FClassnameIs( pFind->pev, "func_tracktrain" ))

	push	OFFSET FLAT:??_C@_0BA@KOLE@func_tracktrain?$AA@ ; `string'
	mov	edx, DWORD PTR _pFind$39027[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L39031

; 2987 : 				m_train = (CFuncTrackTrain *)pFind;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pFind$39027[ebp]
	mov	DWORD PTR [ecx+2004], edx

; 2988 : 				ALERT( at_aiconsole, "Found train %s\n", STRING( pFind->pev->targetname ));

	mov	eax, DWORD PTR _pFind$39027[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BA@MJH@Found?5train?5?$CFs?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2989 : 				break;

	jmp	SHORT $L39030
$L39031:

; 2991 : 		}

	jmp	SHORT $L39029
$L39030:

; 2996 : 
; 2997 : 	if( m_train && m_train->m_pDoor && m_train->m_pDoor->IsDoorControl( ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2004], 0
	je	SHORT $L39034
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2004]
	cmp	DWORD PTR [edx+1792], 0
	je	SHORT $L39034
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2004]
	mov	ecx, DWORD PTR [ecx+1792]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2004]
	mov	edx, DWORD PTR [eax+1792]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+344]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L39034

; 2999 : 		m_train->m_pDoor->Use( this, this, USE_SET, 3.0f );

	push	1077936128				; 40400000H
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2004]
	mov	ecx, DWORD PTR [ecx+1792]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2004]
	mov	edx, DWORD PTR [eax+1792]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+276]

; 3000 : 		return;

	jmp	$L39014
$L39034:

; 3002 : 
; 3003 : 	if( m_toggle_state != TS_AT_TOP && m_toggle_state != TS_AT_BOTTOM )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 0
	je	SHORT $L39035
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1816], 1
	je	SHORT $L39035

; 3004 : 		return;

	jmp	$L39014
$L39035:

; 3005 : 
; 3006 : 	// If train is in "safe" area, but not on the elevator, play alarm sound
; 3007 : 	if( m_toggle_state == TS_AT_TOP )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1816], 0
	jne	SHORT $L39036

; 3008 : 		m_code = EvaluateTrain( m_trackTop );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1996]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EvaluateTrain@CFuncTrackChange@@QAE?AW4TRAIN_CODE@@PAVCPathTrack@@@Z ; CFuncTrackChange::EvaluateTrain
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2020], eax

; 3009 : 	else if( m_toggle_state == TS_AT_BOTTOM )

	jmp	SHORT $L39039
$L39036:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1816], 1
	jne	SHORT $L39038

; 3010 : 		m_code = EvaluateTrain( m_trackBottom );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2000]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EvaluateTrain@CFuncTrackChange@@QAE?AW4TRAIN_CODE@@PAVCPathTrack@@@Z ; CFuncTrackChange::EvaluateTrain
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2020], eax

; 3011 : 	else

	jmp	SHORT $L39039
$L39038:

; 3012 : 		m_code = TRAIN_BLOCKING;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2020], 1
$L39039:

; 3013 : 
; 3014 : 	if( m_code == TRAIN_BLOCKING )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2020], 1
	jne	SHORT $L39040

; 3016 : 		// Play alarm and return
; 3017 : 		EMIT_SOUND( edict(), CHAN_VOICE, "buttons/button11.wav", 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BF@CGCH@buttons?1button11?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 3018 : 		return;

	jmp	SHORT $L39014
$L39040:

; 3020 : 
; 3021 : 	// Otherwise, it's safe to move
; 3022 : 	// If at top, go down
; 3023 : 	// at bottom, go up
; 3024 : 
; 3025 : 	DisableUse();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisableUse@CFuncTrackChange@@QAEXXZ	; CFuncTrackChange::DisableUse

; 3026 : 	if( m_toggle_state == TS_AT_TOP )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1816], 0
	jne	SHORT $L39042

; 3027 : 		GoDown();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+352]

; 3028 : 	else

	jmp	SHORT $L39043
$L39042:

; 3029 : 		GoUp();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+348]
$L39043:
$L39014:

; 3030 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CFuncTrackChange@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CFuncTrackChange::Use
_TEXT	ENDS
;	COMDAT ?DisableUse@CFuncTrackChange@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DisableUse@CFuncTrackChange@@QAEXXZ PROC NEAR		; CFuncTrackChange::DisableUse, COMDAT

; 2645 : 	void		DisableUse( void ) { m_use = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2032], 0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DisableUse@CFuncTrackChange@@QAEXXZ ENDP		; CFuncTrackChange::DisableUse
_TEXT	ENDS
PUBLIC	?SetTrack@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z ; CFuncTrackTrain::SetTrack
PUBLIC	?HitBottom@CFuncTrackChange@@UAEXXZ		; CFuncTrackChange::HitBottom
;	COMDAT ?HitBottom@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?HitBottom@CFuncTrackChange@@UAEXXZ PROC NEAR		; CFuncTrackChange::HitBottom, COMDAT

; 3037 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3038 : 	BaseClass :: HitBottom();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?HitBottom@CFuncPlatRot@@UAEXXZ		; CFuncPlatRot::HitBottom

; 3039 : 
; 3040 : 	if( m_code == TRAIN_FOLLOWING )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2020], 2
	jne	SHORT $L39048

; 3042 : 		m_train->SetTrack( m_trackBottom );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2000]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2004]
	call	?SetTrack@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z ; CFuncTrackTrain::SetTrack
$L39048:

; 3044 : 
; 3045 : 	SetMoveDone( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 3046 : 	SetMoveDoneTime( -1 );

	push	-1082130432				; bf800000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 3047 : 
; 3048 : 	UpdateAutoTargets( m_toggle_state );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+368]

; 3049 : 
; 3050 : 	EnableUse();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnableUse@CFuncTrackChange@@QAEXXZ	; CFuncTrackChange::EnableUse

; 3051 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HitBottom@CFuncTrackChange@@UAEXXZ ENDP		; CFuncTrackChange::HitBottom
_TEXT	ENDS
;	COMDAT ?SetTrack@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z
_TEXT	SEGMENT
_track$ = 8
_this$ = -4
?SetTrack@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z PROC NEAR ; CFuncTrackTrain::SetTrack, COMDAT

; 138  : 	void SetTrack( CPathTrack *track ) { m_ppath = track->Nearest( GetLocalOrigin( )); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	mov	ecx, DWORD PTR _track$[ebp]
	call	?Nearest@CPathTrack@@QAEPAV1@ABVVector@@@Z ; CPathTrack::Nearest
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1796], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTrack@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z ENDP	; CFuncTrackTrain::SetTrack
_TEXT	ENDS
PUBLIC	?HitTop@CFuncTrackChange@@UAEXXZ		; CFuncTrackChange::HitTop
;	COMDAT ?HitTop@CFuncTrackChange@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?HitTop@CFuncTrackChange@@UAEXXZ PROC NEAR		; CFuncTrackChange::HitTop, COMDAT

; 3057 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3058 : 	BaseClass :: HitTop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?HitTop@CFuncPlatRot@@UAEXXZ		; CFuncPlatRot::HitTop

; 3059 : 
; 3060 : 	if( m_code == TRAIN_FOLLOWING )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2020], 2
	jne	SHORT $L39055

; 3062 : 		m_train->SetTrack( m_trackTop );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1996]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2004]
	call	?SetTrack@CFuncTrackTrain@@QAEXPAVCPathTrack@@@Z ; CFuncTrackTrain::SetTrack
$L39055:

; 3064 : 	
; 3065 : 	// Don't let the plat go back down
; 3066 : 	SetMoveDone( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 3067 : 	SetMoveDoneTime( -1 );

	push	-1082130432				; bf800000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 3068 : 	UpdateAutoTargets( m_toggle_state );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+368]

; 3069 : 	EnableUse();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnableUse@CFuncTrackChange@@QAEXXZ	; CFuncTrackChange::EnableUse

; 3070 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HitTop@CFuncTrackChange@@UAEXXZ ENDP			; CFuncTrackChange::HitTop
_TEXT	ENDS
;	COMDAT _$E94
_TEXT	SEGMENT
_$E94	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E93
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E94	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncTrackAuto@@@@QAE@PBD@Z ; CEntityFactory<CFuncTrackAuto>::CEntityFactory<CFuncTrackAuto>
PUBLIC	??_C@_0BF@NFLJ@func_trackautochange?$AA@	; `string'
_BSS	SEGMENT
	ALIGN	4

_func_trackautochange DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BF@NFLJ@func_trackautochange?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0BF@NFLJ@func_trackautochange?$AA@ DB 'func_trackautochange', 00H ; `string'
CONST	ENDS
;	COMDAT _$E93
_TEXT	SEGMENT
_$E93	PROC NEAR					; COMDAT

; 3080 : LINK_ENTITY_TO_CLASS( func_trackautochange, CFuncTrackAuto );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BF@NFLJ@func_trackautochange?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_trackautochange
	call	??0?$CEntityFactory@VCFuncTrackAuto@@@@QAE@PBD@Z ; CEntityFactory<CFuncTrackAuto>::CEntityFactory<CFuncTrackAuto>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E93	ENDP
_TEXT	ENDS
PUBLIC	?UpdateAutoTargets@CFuncTrackAuto@@UAEXH@Z	; CFuncTrackAuto::UpdateAutoTargets
;	COMDAT ?UpdateAutoTargets@CFuncTrackAuto@@UAEXH@Z
_TEXT	SEGMENT
_toggleState$ = 8
_this$ = -4
_pTarget$ = -8
_pNextTarget$ = -12
?UpdateAutoTargets@CFuncTrackAuto@@UAEXH@Z PROC NEAR	; CFuncTrackAuto::UpdateAutoTargets, COMDAT

; 3084 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3085 : 	// g-cont. update targets same as func_door
; 3086 : 	if( toggleState == TS_AT_BOTTOM )

	cmp	DWORD PTR _toggleState$[ebp], 1
	jne	$L39110

; 3088 : 		if( !FBitSet( pev->spawnflags, SF_TRACK_STARTBOTTOM ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 8
	test	edx, edx
	jne	SHORT $L39111

; 3089 : 			UTIL_FireTargets( pev->netname, m_hActivator, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+464]
	push	eax
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 3090 : 		else

	jmp	SHORT $L39112
$L39111:

; 3091 : 			UTIL_FireTargets( pev->message, m_hActivator, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+468]
	push	ecx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L39112:

; 3092 : 		SUB_UseTargets( m_hActivator, USE_TOGGLE, 0 );

	push	0
	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets

; 3094 : 	else if( toggleState == TS_AT_TOP )

	jmp	$L39114
$L39110:
	cmp	DWORD PTR _toggleState$[ebp], 0
	jne	$L39114

; 3096 : 		if( FBitSet( pev->spawnflags, SF_TRACK_STARTBOTTOM ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 8
	test	ecx, ecx
	je	SHORT $L39115

; 3097 : 			UTIL_FireTargets( pev->netname, m_hActivator, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 3098 : 		else

	jmp	SHORT $L39116
$L39115:

; 3099 : 			UTIL_FireTargets( pev->message, m_hActivator, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+468]
	push	eax
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L39116:

; 3100 : 		SUB_UseTargets( m_hActivator, USE_TOGGLE, 0 );

	push	0
	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets
$L39114:

; 3102 : 
; 3103 : 	if( !m_trackTop || !m_trackBottom )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1996], 0
	je	SHORT $L39118
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2000], 0
	jne	SHORT $L39117
$L39118:

; 3104 : 		return;

	jmp	$L39109
$L39117:

; 3107 : 
; 3108 : 	if( m_targetState == TS_AT_TOP )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2028], 0
	jne	SHORT $L39121

; 3110 : 		pTarget = m_trackTop->GetNext();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1996]
	call	?GetNext@CPathTrack@@QAEPAV1@XZ		; CPathTrack::GetNext
	mov	DWORD PTR _pTarget$[ebp], eax

; 3111 : 		pNextTarget = m_trackBottom->GetNext();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2000]
	call	?GetNext@CPathTrack@@QAEPAV1@XZ		; CPathTrack::GetNext
	mov	DWORD PTR _pNextTarget$[ebp], eax

; 3113 : 	else

	jmp	SHORT $L39122
$L39121:

; 3115 : 		pTarget = m_trackBottom->GetNext();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2000]
	call	?GetNext@CPathTrack@@QAEPAV1@XZ		; CPathTrack::GetNext
	mov	DWORD PTR _pTarget$[ebp], eax

; 3116 : 		pNextTarget = m_trackTop->GetNext();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1996]
	call	?GetNext@CPathTrack@@QAEPAV1@XZ		; CPathTrack::GetNext
	mov	DWORD PTR _pNextTarget$[ebp], eax
$L39122:

; 3118 : 
; 3119 : 	if( pTarget )

	cmp	DWORD PTR _pTarget$[ebp], 0
	je	SHORT $L39124

; 3121 : 		ClearBits( pTarget->pev->spawnflags, SF_PATH_DISABLED );

	mov	edx, DWORD PTR _pTarget$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _pTarget$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+416], ecx

; 3122 : 
; 3123 : 		if( m_code == TRAIN_FOLLOWING && m_train && !m_train->GetSpeed() )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2020], 2
	jne	SHORT $L39124
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2004], 0
	je	SHORT $L39124
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2004]
	call	?GetSpeed@CFuncTrackTrain@@QAEMXZ	; CFuncTrackTrain::GetSpeed
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39124

; 3124 : 			m_train->Use( this, this, USE_ON, 0 );

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2004]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2004]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+276]
$L39124:

; 3126 : 
; 3127 : 	if( pNextTarget )

	cmp	DWORD PTR _pNextTarget$[ebp], 0
	je	SHORT $L39125

; 3128 : 		SetBits( pNextTarget->pev->spawnflags, SF_PATH_DISABLED );

	mov	eax, DWORD PTR _pNextTarget$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	or	edx, 1
	mov	eax, DWORD PTR _pNextTarget$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+416], edx
$L39125:
$L39109:

; 3129 : 
; 3130 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateAutoTargets@CFuncTrackAuto@@UAEXH@Z ENDP		; CFuncTrackAuto::UpdateAutoTargets
_TEXT	ENDS
PUBLIC	?Use@CFuncTrackAuto@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncTrackAuto::Use
PUBLIC	?UseEnabled@CFuncTrackChange@@QAEHXZ		; CFuncTrackChange::UseEnabled
;	COMDAT ?Use@CFuncTrackAuto@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_this$ = -4
_pTarget$ = -8
?Use@CFuncTrackAuto@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CFuncTrackAuto::Use, COMDAT

; 3133 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3134 : 	CPathTrack *pTarget;
; 3135 : 
; 3136 : 	if( !UseEnabled( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseEnabled@CFuncTrackChange@@QAEHXZ	; CFuncTrackChange::UseEnabled
	test	eax, eax
	jne	SHORT $L39134

; 3137 : 		return;

	jmp	$L39132
$L39134:

; 3138 : 
; 3139 : 	if( m_toggle_state == TS_AT_TOP )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1816], 0
	jne	SHORT $L39135

; 3140 : 		pTarget = m_trackTop;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1996]
	mov	DWORD PTR _pTarget$[ebp], edx

; 3141 : 	else if( m_toggle_state == TS_AT_BOTTOM )

	jmp	SHORT $L39138
$L39135:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1816], 1
	jne	SHORT $L39137

; 3142 : 		pTarget = m_trackBottom;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2000]
	mov	DWORD PTR _pTarget$[ebp], edx

; 3143 : 	else

	jmp	SHORT $L39138
$L39137:

; 3144 : 		pTarget = NULL;

	mov	DWORD PTR _pTarget$[ebp], 0
$L39138:

; 3145 : 
; 3146 : 	m_hActivator = pActivator;

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 3147 : 
; 3148 : 	if( FStringNull( m_trainName ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2016]
	push	edx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	je	SHORT $L39139

; 3149 : 		m_train = NULL; // clearing for each call

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2004], 0
$L39139:

; 3150 : 
; 3151 : 	if( FClassnameIs( pActivator, "func_tracktrain" ))

	push	OFFSET FLAT:??_C@_0BA@KOLE@func_tracktrain?$AA@ ; `string'
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	$L39140

; 3153 : 		// g-cont. func_trackautochange doesn't search train in specified radius. It will be waiting train as activator
; 3154 : 		if( !m_train ) m_train = (CFuncTrackTrain *)pActivator;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2004], 0
	jne	SHORT $L39141
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pActivator$[ebp]
	mov	DWORD PTR [eax+2004], ecx
$L39141:

; 3155 : 
; 3156 : 		m_code = EvaluateTrain( pTarget );

	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EvaluateTrain@CFuncTrackChange@@QAE?AW4TRAIN_CODE@@PAVCPathTrack@@@Z ; CFuncTrackChange::EvaluateTrain
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2020], eax

; 3157 : 
; 3158 : 		// safe to fire?
; 3159 : 		if( m_code == TRAIN_FOLLOWING && m_toggle_state != m_targetState )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2020], 2
	jne	SHORT $L39145
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1816]
	cmp	edx, DWORD PTR [ecx+2028]
	je	SHORT $L39145

; 3161 : 			DisableUse();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisableUse@CFuncTrackChange@@QAEXXZ	; CFuncTrackChange::DisableUse

; 3162 : 			if( m_toggle_state == TS_AT_TOP )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1816], 0
	jne	SHORT $L39144

; 3163 : 				GoDown();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+352]

; 3164 : 			else

	jmp	SHORT $L39145
$L39144:

; 3165 : 				GoUp();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+348]
$L39145:

; 3168 : 	else if( m_train != NULL )

	jmp	$L39147
$L39140:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2004], 0
	je	$L39147

; 3170 : 		if( pTarget )

	cmp	DWORD PTR _pTarget$[ebp], 0
	je	SHORT $L39148

; 3171 : 			pTarget = pTarget->GetNext();

	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	?GetNext@CPathTrack@@QAEPAV1@XZ		; CPathTrack::GetNext
	mov	DWORD PTR _pTarget$[ebp], eax
$L39148:

; 3172 : 
; 3173 : 		if( pTarget && m_train->m_ppath != pTarget && ShouldToggle( useType, m_targetState ))

	cmp	DWORD PTR _pTarget$[ebp], 0
	je	SHORT $L39151
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2004]
	mov	eax, DWORD PTR [edx+1796]
	cmp	eax, DWORD PTR _pTarget$[ebp]
	je	SHORT $L39151
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2028]
	push	edx
	mov	eax, DWORD PTR _useType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@H@Z ; CBaseEntity::ShouldToggle
	test	eax, eax
	je	SHORT $L39151

; 3175 : 			if( m_targetState == TS_AT_TOP )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2028], 0
	jne	SHORT $L39150

; 3176 : 				m_targetState = TS_AT_BOTTOM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2028], 1

; 3177 : 			else

	jmp	SHORT $L39151
$L39150:

; 3178 : 				m_targetState = TS_AT_TOP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2028], 0
$L39151:

; 3180 : 
; 3181 : 		UpdateAutoTargets( m_targetState );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2028]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+368]
$L39147:
$L39132:

; 3183 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CFuncTrackAuto@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CFuncTrackAuto::Use
_TEXT	ENDS
;	COMDAT ?UseEnabled@CFuncTrackChange@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?UseEnabled@CFuncTrackChange@@QAEHXZ PROC NEAR		; CFuncTrackChange::UseEnabled, COMDAT

; 2647 : 	int		UseEnabled( void ) { return m_use; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+2032]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UseEnabled@CFuncTrackChange@@QAEHXZ ENDP		; CFuncTrackChange::UseEnabled
_TEXT	ENDS
;	COMDAT _$E98
_TEXT	SEGMENT
_$E98	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E97
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E98	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCGunTarget@@@@QAE@PBD@Z	; CEntityFactory<CGunTarget>::CEntityFactory<CGunTarget>
PUBLIC	??_C@_0P@MJPL@func_guntarget?$AA@		; `string'
_BSS	SEGMENT
_func_guntarget DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0P@MJPL@func_guntarget?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_0P@MJPL@func_guntarget?$AA@ DB 'func_guntarget', 00H ; `string'
CONST	ENDS
;	COMDAT _$E97
_TEXT	SEGMENT
_$E97	PROC NEAR					; COMDAT

; 3219 : LINK_ENTITY_TO_CLASS( func_guntarget, CGunTarget );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0P@MJPL@func_guntarget?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_guntarget
	call	??0?$CEntityFactory@VCGunTarget@@@@QAE@PBD@Z ; CEntityFactory<CGunTarget>::CEntityFactory<CGunTarget>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E97	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CGunTarget@@UAEPAUdatamap_s@@XZ	; CGunTarget::GetDataDescMap
;	COMDAT ?GetDataDescMap@CGunTarget@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CGunTarget@@UAEPAUdatamap_s@@XZ PROC NEAR ; CGunTarget::GetDataDescMap, COMDAT

; 3221 : BEGIN_DATADESC( CGunTarget )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CGunTarget@@2Udatamap_s@@A ; CGunTarget::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CGunTarget@@UAEPAUdatamap_s@@XZ ENDP	; CGunTarget::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CGunTarget@@SAPAUdatamap_s@@XZ	; CGunTarget::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CGunTarget@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CGunTarget@@SAPAUdatamap_s@@XZ PROC NEAR	; CGunTarget::GetBaseMap, COMDAT

; 3221 : BEGIN_DATADESC( CGunTarget )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CGunTarget@@SAPAUdatamap_s@@XZ ENDP		; CGunTarget::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E101
_TEXT	SEGMENT
_$E101	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E100
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E101	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z	; DataMapInit
;	COMDAT _$E100
_TEXT	SEGMENT
_$E100	PROC NEAR					; COMDAT

; 3221 : BEGIN_DATADESC( CGunTarget )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CGunTarget_DataDescInit@@3PAUdatamap_s@@A, eax ; CGunTarget_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E100	ENDP
_TEXT	ENDS
PUBLIC	?Next@CGunTarget@@QAEXXZ			; CGunTarget::Next
PUBLIC	?Start@CGunTarget@@QAEXXZ			; CGunTarget::Start
PUBLIC	?Wait@CGunTarget@@QAEXXZ			; CGunTarget::Wait
PUBLIC	??_C@_05IMKO@Start?$AA@				; `string'
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S103@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_05IMKO@Start?$AA@
; File z:\xashxtsrc\server\plats.cpp
CONST	SEGMENT
??_C@_05IMKO@Start?$AA@ DB 'Start', 00H			; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z PROC NEAR ; DataMapInit, COMDAT

; 3221 : BEGIN_DATADESC( CGunTarget )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S103@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L39285
	mov	cl, BYTE PTR _?$S103@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S103@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0L@CLNG@CGunTarget?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E104
	call	_atexit
	add	esp, 4
$L39285:
	call	?GetBaseMap@CGunTarget@@SAPAUdatamap_s@@XZ ; CGunTarget::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CGunTarget@@2Udatamap_s@@A+12, eax

; 3222 : 	DEFINE_FIELD( m_on, FIELD_BOOLEAN ),
; 3223 : 	DEFINE_FUNCTION( Next ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S103@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L39292
	mov	al, BYTE PTR _?$S103@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S103@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_04CIMM@Next?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+52, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+56, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+60, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+62, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+64, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+68, OFFSET FLAT:?Next@CGunTarget@@QAEXXZ ; CGunTarget::Next

; 3224 : 	DEFINE_FUNCTION( Wait ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+72, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_04EGHG@Wait?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+76, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+80, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+84, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+86, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+88, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+92, OFFSET FLAT:?Wait@CGunTarget@@QAEXXZ ; CGunTarget::Wait

; 3225 : 	DEFINE_FUNCTION( Start ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+96, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_05IMKO@Start?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+100, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+104, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+108, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+110, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+112, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+116, OFFSET FLAT:?Start@CGunTarget@@QAEXXZ ; CGunTarget::Start
$L39292:

; 3226 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L39300
	mov	DWORD PTR ?m_DataMap@CGunTarget@@2Udatamap_s@@A+4, 4
	mov	DWORD PTR ?m_DataMap@CGunTarget@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L39301
$L39300:
	mov	DWORD PTR ?m_DataMap@CGunTarget@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CGunTarget@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4PAUtypedescription_s@@A
$L39301:
	mov	eax, OFFSET FLAT:?m_DataMap@CGunTarget@@2Udatamap_s@@A ; CGunTarget::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z ENDP	; DataMapInit
_TEXT	ENDS
;	COMDAT _$E104
_TEXT	SEGMENT
_$E104	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCGunTarget@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E104	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CGunTarget@@UAEXXZ			; CGunTarget::Spawn
;	COMDAT ?Spawn@CGunTarget@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CGunTarget@@UAEXXZ PROC NEAR			; CGunTarget::Spawn, COMDAT

; 3229 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3230 : 	pev->solid = SOLID_BSP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 4

; 3231 : 	pev->movetype = MOVETYPE_PUSH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 7

; 3232 : 
; 3233 : 	m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 3234 : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 3235 : 	RelinkEntity( TRUE );

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 3236 : 
; 3237 : 	if ( pev->speed == 0 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39307

; 3238 : 		pev->speed = 100;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+504], 1120403456		; 42c80000H
$L39307:

; 3239 : 
; 3240 : 	// Don't take damage until "on"
; 3241 : 	pev->takedamage = DAMAGE_NO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+364], 0

; 3242 : 	pev->flags |= FL_MONSTER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx

; 3243 : 
; 3244 : 	m_on = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2396], 0

; 3245 : 	pev->max_health = pev->health;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+352]
	mov	DWORD PTR [edx+432], eax

; 3246 : 
; 3247 : 	if( pev->spawnflags & FGUNTARGET_START_ON )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 1
	test	eax, eax
	je	SHORT $L39308

; 3249 : 		SetMoveDone( Start );

	push	OFFSET FLAT:??_C@_05IMKO@Start?$AA@	; `string'
	push	OFFSET FLAT:?Start@CGunTarget@@QAEXXZ	; CGunTarget::Start
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 3250 : 		SetMoveDoneTime( 0.3 );

	push	1050253722				; 3e99999aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime
$L39308:

; 3252 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CGunTarget@@UAEXXZ ENDP				; CGunTarget::Spawn
_TEXT	ENDS
PUBLIC	?Activate@CGunTarget@@UAEXXZ			; CGunTarget::Activate
;	COMDAT ?Activate@CGunTarget@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pTarg$ = -8
$T41454 = -20
$T41455 = -32
$T41456 = -44
?Activate@CGunTarget@@UAEXXZ PROC NEAR			; CGunTarget::Activate, COMDAT

; 3255 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3256 : 	CBaseEntity *pTarg;
; 3257 : 
; 3258 : 	// now find our next target
; 3259 : 	pTarg = GetNextTarget();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+268]
	mov	DWORD PTR _pTarg$[ebp], eax

; 3260 : 
; 3261 : 	if( pTarg )

	cmp	DWORD PTR _pTarg$[ebp], 0
	je	SHORT $L39316

; 3263 : 		m_hTargetEnt = pTarg;

	mov	eax, DWORD PTR _pTarg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 3264 : 		UTIL_SetOrigin( this, pTarg->GetLocalOrigin() - (pev->mins + pev->maxs) * 0.5 );

	push	1056964608				; 3f000000H
	lea	ecx, DWORD PTR $T41455[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 232				; 000000e8H
	push	eax
	lea	ecx, DWORD PTR $T41454[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 220				; 000000dcH
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T41456[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarg$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8
$L39316:

; 3266 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CGunTarget@@UAEXXZ ENDP			; CGunTarget::Activate
_TEXT	ENDS
;	COMDAT ?Start@CGunTarget@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Start@CGunTarget@@QAEXXZ PROC NEAR			; CGunTarget::Start, COMDAT

; 3269 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3270 : 	Use( this, this, USE_ON, 0 );

	push	0
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+276]

; 3271 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Start@CGunTarget@@QAEXXZ ENDP				; CGunTarget::Start
_TEXT	ENDS
;	COMDAT ?Next@CGunTarget@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pTarget$ = -8
$T41461 = -20
$T41462 = -32
$T41463 = -44
?Next@CGunTarget@@QAEXXZ PROC NEAR			; CGunTarget::Next, COMDAT

; 3274 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3275 : 	SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 3276 : 
; 3277 : 	m_hTargetEnt = GetNextTarget();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+268]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 3278 : 	CBaseEntity *pTarget = m_hTargetEnt;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pTarget$[ebp], eax

; 3279 : 	
; 3280 : 	if( !pTarget )

	cmp	DWORD PTR _pTarget$[ebp], 0
	jne	SHORT $L39331

; 3282 : 		Stop();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+416]

; 3283 : 		return;

	jmp	SHORT $L39327
$L39331:

; 3285 : 
; 3286 : 	SetMoveDone( Wait );

	push	OFFSET FLAT:??_C@_04EGHG@Wait?$AA@	; `string'
	push	OFFSET FLAT:?Wait@CGunTarget@@QAEXXZ	; CGunTarget::Wait
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 3287 : 	LinearMove( pTarget->GetLocalOrigin() - (pev->mins + pev->maxs) * 0.5, pev->speed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+504]
	push	edx
	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T41462[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 232				; 000000e8H
	push	edx
	lea	eax, DWORD PTR $T41461[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 220				; 000000dcH
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T41463[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::LinearMove
$L39327:

; 3288 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Next@CGunTarget@@QAEXXZ ENDP				; CGunTarget::Next
_TEXT	ENDS
;	COMDAT ?Wait@CGunTarget@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pTarget$ = -8
?Wait@CGunTarget@@QAEXXZ PROC NEAR			; CGunTarget::Wait, COMDAT

; 3292 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3293 : 	CBaseEntity *pTarget = m_hTargetEnt;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pTarget$[ebp], eax

; 3294 : 	
; 3295 : 	if ( !pTarget )

	cmp	DWORD PTR _pTarget$[ebp], 0
	jne	SHORT $L39342

; 3297 : 		Stop();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+416]

; 3298 : 		return;

	jmp	$L39340
$L39342:

; 3300 : 
; 3301 : 	// Fire the pass target if there is one
; 3302 : 	if ( pTarget->pev->message )

	mov	eax, DWORD PTR _pTarget$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+468], 0
	je	SHORT $L39344

; 3304 : 		UTIL_FireTargets( STRING(pTarget->pev->message), this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+468]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 3305 : 		if ( FBitSet( pTarget->pev->spawnflags, SF_CORNER_FIREONCE ) )

	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 4
	test	eax, eax
	je	SHORT $L39344

; 3306 : 			pTarget->pev->message = 0;

	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+468], 0
$L39344:

; 3308 : 		
; 3309 : 	m_flWait = pTarget->GetDelay();

	mov	eax, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [edx+160]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1764]

; 3310 : 
; 3311 : 	pev->target = pTarget->pev->target;

	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+456]
	mov	DWORD PTR [ecx+456], edx

; 3312 : 	SetMoveDone( Next );

	push	OFFSET FLAT:??_C@_04CIMM@Next?$AA@	; `string'
	push	OFFSET FLAT:?Next@CGunTarget@@QAEXXZ	; CGunTarget::Next
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 3313 : 
; 3314 : 	if( m_flWait != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1764]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39347

; 3316 : 		// -1 wait will wait forever!		
; 3317 : 		SetMoveDoneTime( m_flWait );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1764]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 3319 : 	else

	jmp	SHORT $L39348
$L39347:

; 3321 : 		Next();// do it RIGHT now!

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Next@CGunTarget@@QAEXXZ		; CGunTarget::Next
$L39348:
$L39340:

; 3323 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Wait@CGunTarget@@QAEXXZ ENDP				; CGunTarget::Wait
_TEXT	ENDS
PUBLIC	?Stop@CGunTarget@@UAEXXZ			; CGunTarget::Stop
;	COMDAT ?Stop@CGunTarget@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Stop@CGunTarget@@UAEXXZ PROC NEAR			; CGunTarget::Stop, COMDAT

; 3326 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3327 : 	SetLocalVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 3328 : 	SetMoveDoneTime( -1 );

	push	-1082130432				; bf800000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 3329 : 	pev->takedamage = DAMAGE_NO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+364], 0

; 3330 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@CGunTarget@@UAEXXZ ENDP				; CGunTarget::Stop
_TEXT	ENDS
PUBLIC	?TakeDamage@CGunTarget@@UAEHPAUentvars_s@@0MH@Z	; CGunTarget::TakeDamage
;	COMDAT ?TakeDamage@CGunTarget@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT
_flDamage$ = 16
_this$ = -4
?TakeDamage@CGunTarget@@UAEHPAUentvars_s@@0MH@Z PROC NEAR ; CGunTarget::TakeDamage, COMDAT

; 3333 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3334 : 	if ( pev->health > 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L39362

; 3336 : 		pev->health -= flDamage;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fsub	DWORD PTR _flDamage$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+352]

; 3337 : 		if ( pev->health <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39362

; 3339 : 			pev->health = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+352], 0

; 3340 : 			Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+416]

; 3341 : 			if ( pev->message )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+468], 0
	je	SHORT $L39362

; 3342 : 				UTIL_FireTargets( STRING(pev->message), this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+468]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L39362:

; 3345 : 	return 0;

	xor	eax, eax

; 3346 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TakeDamage@CGunTarget@@UAEHPAUentvars_s@@0MH@Z ENDP	; CGunTarget::TakeDamage
_TEXT	ENDS
PUBLIC	?Use@CGunTarget@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CGunTarget::Use
;	COMDAT ?Use@CGunTarget@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_useType$ = 16
_this$ = -4
?Use@CGunTarget@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CGunTarget::Use, COMDAT

; 3349 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3350 : 	if ( !ShouldToggle( useType, m_on ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2396]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@H@Z ; CBaseEntity::ShouldToggle
	test	eax, eax
	jne	SHORT $L39370

; 3351 : 		return;

	jmp	SHORT $L39369
$L39370:

; 3352 : 
; 3353 : 	if ( m_on )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2396], 0
	je	SHORT $L39371

; 3355 : 		Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+416]

; 3357 : 	else

	jmp	SHORT $L39372
$L39371:

; 3359 : 		pev->takedamage = DAMAGE_AIM;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+364], 1073741824		; 40000000H

; 3360 : 		m_hTargetEnt = GetNextTarget();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+268]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 3361 : 		if ( m_hTargetEnt == NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $L39373

; 3362 : 			return;

	jmp	SHORT $L39369
$L39373:

; 3363 : 		pev->health = pev->max_health;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+432]
	mov	DWORD PTR [ecx+352], edx

; 3364 : 		Next();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Next@CGunTarget@@QAEXXZ		; CGunTarget::Next
$L39372:
$L39369:

; 3366 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CGunTarget@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CGunTarget::Use
_TEXT	ENDS
PUBLIC	??0IEntityFactory@@QAE@XZ			; IEntityFactory::IEntityFactory
PUBLIC	?Create@?$CEntityFactory@VCFuncPlat@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncPlat>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncPlat@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncPlat>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncPlat@@@@UAEIXZ ; CEntityFactory<CFuncPlat>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncPlat@@@@6B@		; CEntityFactory<CFuncPlat>::`vftable'
EXTRN	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ:NEAR ; EntityFactoryDictionary
;	COMDAT ??_7?$CEntityFactory@VCFuncPlat@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncPlat@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncPlat@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncPlat>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncPlat@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncPlat@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncPlat@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCFuncPlat@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CFuncPlat>::CEntityFactory<CFuncPlat>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncPlat@@@@6B@ ; CEntityFactory<CFuncPlat>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncPlat@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncPlat>::CEntityFactory<CFuncPlat>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncPlat@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCFuncPlat@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncPlat>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncPlat@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncPlat>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncPlat@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCFuncPlat@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncPlat>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncPlat@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncPlat>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncPlat@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncPlat@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncPlat>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1972				; 000007b4H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncPlat@@@@UAEIXZ ENDP ; CEntityFactory<CFuncPlat>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncPlatRot@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncPlatRot>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncPlatRot@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncPlatRot>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncPlatRot@@@@UAEIXZ ; CEntityFactory<CFuncPlatRot>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncPlatRot@@@@6B@	; CEntityFactory<CFuncPlatRot>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncPlatRot@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncPlatRot@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncPlatRot@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncPlatRot>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncPlatRot@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncPlatRot@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncPlatRot@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncPlatRot@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncPlatRot>::CEntityFactory<CFuncPlatRot>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncPlatRot@@@@6B@ ; CEntityFactory<CFuncPlatRot>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncPlatRot@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncPlatRot>::CEntityFactory<CFuncPlatRot>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncPlatRot@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncPlatRot@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncPlatRot>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncPlatRot@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncPlatRot>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncPlatRot@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncPlatRot@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncPlatRot>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncPlatRot@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncPlatRot>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncPlatRot@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncPlatRot@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncPlatRot>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1996				; 000007ccH

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncPlatRot@@@@UAEIXZ ENDP ; CEntityFactory<CFuncPlatRot>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCTrainSequence@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CTrainSequence>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCTrainSequence@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CTrainSequence>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCTrainSequence@@@@UAEIXZ ; CEntityFactory<CTrainSequence>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCTrainSequence@@@@6B@	; CEntityFactory<CTrainSequence>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCTrainSequence@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCTrainSequence@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCTrainSequence@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CTrainSequence>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCTrainSequence@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCTrainSequence@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCTrainSequence@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCTrainSequence@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CTrainSequence>::CEntityFactory<CTrainSequence>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCTrainSequence@@@@6B@ ; CEntityFactory<CTrainSequence>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCTrainSequence@@@@QAE@PBD@Z ENDP	; CEntityFactory<CTrainSequence>::CEntityFactory<CTrainSequence>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCTrainSequence@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCTrainSequence@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CTrainSequence>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCTrainSequence@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CTrainSequence>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCTrainSequence@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCTrainSequence@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CTrainSequence>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCTrainSequence@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CTrainSequence>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCTrainSequence@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCTrainSequence@@@@UAEIXZ PROC NEAR ; CEntityFactory<CTrainSequence>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1788				; 000006fcH

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCTrainSequence@@@@UAEIXZ ENDP ; CEntityFactory<CTrainSequence>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncTrain@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTrain>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncTrain@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncTrain>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncTrain@@@@UAEIXZ ; CEntityFactory<CFuncTrain>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncTrain@@@@6B@		; CEntityFactory<CFuncTrain>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncTrain@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncTrain@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncTrain@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTrain>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncTrain@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncTrain@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTrain@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCFuncTrain@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CFuncTrain>::CEntityFactory<CFuncTrain>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncTrain@@@@6B@ ; CEntityFactory<CFuncTrain>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncTrain@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncTrain>::CEntityFactory<CFuncTrain>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncTrain@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCFuncTrain@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncTrain>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncTrain@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncTrain>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTrain@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCFuncTrain@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncTrain>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncTrain@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncTrain>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTrain@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncTrain@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncTrain>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1988				; 000007c4H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncTrain@@@@UAEIXZ ENDP ; CEntityFactory<CFuncTrain>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncTrackTrain@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTrackTrain>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncTrackTrain@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncTrackTrain>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncTrackTrain@@@@UAEIXZ ; CEntityFactory<CFuncTrackTrain>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncTrackTrain@@@@6B@	; CEntityFactory<CFuncTrackTrain>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncTrackTrain@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncTrackTrain@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncTrackTrain@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTrackTrain>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncTrackTrain@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncTrackTrain@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTrackTrain@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncTrackTrain@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncTrackTrain>::CEntityFactory<CFuncTrackTrain>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncTrackTrain@@@@6B@ ; CEntityFactory<CFuncTrackTrain>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncTrackTrain@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncTrackTrain>::CEntityFactory<CFuncTrackTrain>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncTrackTrain@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncTrackTrain@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncTrackTrain>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncTrackTrain@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncTrackTrain>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTrackTrain@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncTrackTrain@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncTrackTrain>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncTrackTrain@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncTrackTrain>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTrackTrain@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncTrackTrain@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncTrackTrain>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1908				; 00000774H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncTrackTrain@@@@UAEIXZ ENDP ; CEntityFactory<CFuncTrackTrain>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncTrainControls@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTrainControls>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncTrainControls@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncTrainControls>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncTrainControls@@@@UAEIXZ ; CEntityFactory<CFuncTrainControls>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncTrainControls@@@@6B@	; CEntityFactory<CFuncTrainControls>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncTrainControls@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncTrainControls@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncTrainControls@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTrainControls>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncTrainControls@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncTrainControls@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTrainControls@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCFuncTrainControls@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncTrainControls>::CEntityFactory<CFuncTrainControls>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncTrainControls@@@@6B@ ; CEntityFactory<CFuncTrainControls>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncTrainControls@@@@QAE@PBD@Z ENDP ; CEntityFactory<CFuncTrainControls>::CEntityFactory<CFuncTrainControls>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z ; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncTrainControls@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCFuncTrainControls@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncTrainControls>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncTrainControls@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncTrainControls>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTrainControls@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCFuncTrainControls@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncTrainControls>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncTrainControls@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncTrainControls>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTrainControls@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncTrainControls@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncTrainControls>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1764				; 000006e4H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncTrainControls@@@@UAEIXZ ENDP ; CEntityFactory<CFuncTrainControls>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncTrackChange@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTrackChange>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncTrackChange@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncTrackChange>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncTrackChange@@@@UAEIXZ ; CEntityFactory<CFuncTrackChange>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncTrackChange@@@@6B@	; CEntityFactory<CFuncTrackChange>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncTrackChange@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncTrackChange@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncTrackChange@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTrackChange>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncTrackChange@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncTrackChange@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTrackChange@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCFuncTrackChange@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncTrackChange>::CEntityFactory<CFuncTrackChange>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncTrackChange@@@@6B@ ; CEntityFactory<CFuncTrackChange>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncTrackChange@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncTrackChange>::CEntityFactory<CFuncTrackChange>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncTrackChange@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCFuncTrackChange@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncTrackChange>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncTrackChange@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncTrackChange>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTrackChange@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCFuncTrackChange@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncTrackChange>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncTrackChange@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncTrackChange>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTrackChange@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncTrackChange@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncTrackChange>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 2036				; 000007f4H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncTrackChange@@@@UAEIXZ ENDP ; CEntityFactory<CFuncTrackChange>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncTrackAuto@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTrackAuto>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncTrackAuto@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncTrackAuto>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncTrackAuto@@@@UAEIXZ ; CEntityFactory<CFuncTrackAuto>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncTrackAuto@@@@6B@	; CEntityFactory<CFuncTrackAuto>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncTrackAuto@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncTrackAuto@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncTrackAuto@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTrackAuto>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncTrackAuto@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncTrackAuto@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTrackAuto@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncTrackAuto@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncTrackAuto>::CEntityFactory<CFuncTrackAuto>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncTrackAuto@@@@6B@ ; CEntityFactory<CFuncTrackAuto>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncTrackAuto@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncTrackAuto>::CEntityFactory<CFuncTrackAuto>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncTrackAuto@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncTrackAuto@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncTrackAuto>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncTrackAuto@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncTrackAuto>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTrackAuto@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncTrackAuto@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncTrackAuto>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncTrackAuto@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncTrackAuto>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTrackAuto@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncTrackAuto@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncTrackAuto>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 2036				; 000007f4H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncTrackAuto@@@@UAEIXZ ENDP ; CEntityFactory<CFuncTrackAuto>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCGunTarget@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CGunTarget>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCGunTarget@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CGunTarget>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCGunTarget@@@@UAEIXZ ; CEntityFactory<CGunTarget>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCGunTarget@@@@6B@		; CEntityFactory<CGunTarget>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCGunTarget@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCGunTarget@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCGunTarget@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CGunTarget>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCGunTarget@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCGunTarget@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCGunTarget@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCGunTarget@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CGunTarget>::CEntityFactory<CGunTarget>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCGunTarget@@@@6B@ ; CEntityFactory<CGunTarget>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCGunTarget@@@@QAE@PBD@Z ENDP	; CEntityFactory<CGunTarget>::CEntityFactory<CGunTarget>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCGunTarget@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCGunTarget@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CGunTarget>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCGunTarget@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CGunTarget>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCGunTarget@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCGunTarget@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CGunTarget>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCGunTarget@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CGunTarget>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCGunTarget@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCGunTarget@@@@UAEIXZ PROC NEAR ; CEntityFactory<CGunTarget>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 2400				; 00000960H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCGunTarget@@@@UAEIXZ ENDP ; CEntityFactory<CGunTarget>::GetEntitySize
_TEXT	ENDS
PUBLIC	??_7IEntityFactory@@6B@				; IEntityFactory::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT
??_7IEntityFactory@@6B@ DD FLAT:__purecall		; IEntityFactory::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IEntityFactory@@QAE@XZ PROC NEAR			; IEntityFactory::IEntityFactory, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IEntityFactory@@6B@ ; IEntityFactory::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0IEntityFactory@@QAE@XZ ENDP				; IEntityFactory::IEntityFactory
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_this$ = -16
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
PUBLIC	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
PUBLIC	??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
PUBLIC	??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT
??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ DB '('
	DB	'Base() == NULL) || (&src < Base()) || (&src >= (Base() + Coun'
	DB	't()) )', 00H				; `string'
CONST	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L41570
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L41570
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L41570
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41570:

; 520  : 	return InsertBefore( m_Size, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseToggle@@2Udatamap_s@@A:BYTE	; CBaseToggle::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseToggle@@2Udatamap_s@@A ; CBaseToggle::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBasePlatTrain@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBasePlatTrain@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBasePlatTrain@@2Udatamap_s@@A ; CBasePlatTrain::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBasePlatTrain@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	??0CPlatTrigger@@QAE@XZ				; CPlatTrigger::CPlatTrigger
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
PUBLIC	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z		; CBaseEntity::operator new
PUBLIC	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z		; CBaseEntity::operator delete
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z
_TEXT	SEGMENT
_a$ = 8
$T41577 = -20
$T41578 = -24
__$EHRec$ = -12
_pev$ = -16
?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z PROC NEAR	; GetClassPtr, COMDAT

; 1073 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1074 : 	entvars_t *pev = (entvars_t *)a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1075 : 
; 1076 : 	// allocate entity if necessary
; 1077 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39547

; 1078 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39547:

; 1079 : 
; 1080 : 	// get the private data
; 1081 : 	a = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 1082 : 
; 1083 : 	if (a == NULL) 

	cmp	DWORD PTR _a$[ebp], 0
	jne	SHORT $L39549

; 1085 : 		// allocate private data 
; 1086 : 		a = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1768					; 000006e8H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41578[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41578[ebp], 0
	je	SHORT $L41579
	mov	ecx, DWORD PTR $T41578[ebp]
	call	??0CPlatTrigger@@QAE@XZ			; CPlatTrigger::CPlatTrigger
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41580
$L41579:
	mov	DWORD PTR -28+[ebp], 0
$L41580:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41577[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41577[ebp]
	mov	DWORD PTR _a$[ebp], ecx

; 1087 : 		a->pev = pev;

	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39549:

; 1089 : 	return a;

	mov	eax, DWORD PTR _a$[ebp]

; 1090 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41578[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCPlatTrigger@@PAV1@@Z ENDP		; GetClassPtr
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC NEAR		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32448

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L32447
$L32448:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$L32447:

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT
_stAllocateBlock$ = 8
_pev$ = 12
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator new, COMDAT

; 489  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 490  : 		return (void *)ALLOC_PRIVATE(ENT(pev), stAllocateBlock);

	mov	eax, DWORD PTR _stAllocateBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+252
	add	esp, 8

; 491  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z ENDP		; CBaseEntity::operator new
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 12
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator delete, COMDAT

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 497  : 		pev->flags |= FL_KILLME;

	mov	eax, DWORD PTR _pev$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+420], ecx

; 498  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z ENDP		; CBaseEntity::operator delete
_TEXT	ENDS
PUBLIC	??0CFuncPlat@@QAE@XZ				; CFuncPlat::CFuncPlat
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z
_TEXT	SEGMENT
_a$ = 8
$T41596 = -20
$T41597 = -24
__$EHRec$ = -12
_pev$ = -16
?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z PROC NEAR		; GetClassPtr, COMDAT

; 1073 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1074 : 	entvars_t *pev = (entvars_t *)a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1075 : 
; 1076 : 	// allocate entity if necessary
; 1077 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39558

; 1078 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39558:

; 1079 : 
; 1080 : 	// get the private data
; 1081 : 	a = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 1082 : 
; 1083 : 	if (a == NULL) 

	cmp	DWORD PTR _a$[ebp], 0
	jne	SHORT $L39560

; 1085 : 		// allocate private data 
; 1086 : 		a = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1972					; 000007b4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41597[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41597[ebp], 0
	je	SHORT $L41598
	mov	ecx, DWORD PTR $T41597[ebp]
	call	??0CFuncPlat@@QAE@XZ			; CFuncPlat::CFuncPlat
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41599
$L41598:
	mov	DWORD PTR -28+[ebp], 0
$L41599:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41596[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41596[ebp]
	mov	DWORD PTR _a$[ebp], ecx

; 1087 : 		a->pev = pev;

	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39560:

; 1089 : 	return a;

	mov	eax, DWORD PTR _a$[ebp]

; 1090 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41597[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncPlat@@PAV1@@Z ENDP		; GetClassPtr
;	COMDAT ?DataMapAccess@@YAXPAVCFuncPlat@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCFuncPlat@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CFuncPlat@@2Udatamap_s@@A ; CFuncPlat::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCFuncPlat@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseEntity@@2Udatamap_s@@A:BYTE	; CBaseEntity::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseEntity@@2Udatamap_s@@A ; CBaseEntity::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseDelay@@2Udatamap_s@@A:BYTE	; CBaseDelay::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseDelay@@2Udatamap_s@@A ; CBaseDelay::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCFuncPlatRot@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCFuncPlatRot@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CFuncPlatRot@@2Udatamap_s@@A ; CFuncPlatRot::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCFuncPlatRot@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseMonster@@2Udatamap_s@@A:BYTE	; CBaseMonster::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseMonster@@2Udatamap_s@@A ; CBaseMonster::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	?SetClassname@CBaseEntity@@QAEXPBD@Z		; CBaseEntity::SetClassname
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
$T41619 = -20
$T41620 = -24
_pev$ = -16
__$EHRec$ = -12
?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39574

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39574:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39576

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1972					; 000007b4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41620[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41620[ebp], 0
	je	SHORT $L41621
	mov	ecx, DWORD PTR $T41620[ebp]
	call	??0CFuncPlat@@QAE@XZ			; CFuncPlat::CFuncPlat
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41622
$L41621:
	mov	DWORD PTR -28+[ebp], 0
$L41622:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41619[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41619[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39576:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41620[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncPlat@@PAV1@PBD@Z ENDP		; GetClassPtr
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4
_pszClassName$ = 8
?SetClassname@CBaseEntity@@QAEXPBD@Z PROC NEAR		; CBaseEntity::SetClassname, COMDAT

; 302  : 	void		SetClassname( const char *pszClassName ) { pev->classname = MAKE_STRING( pszClassName ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClassname@CBaseEntity@@QAEXPBD@Z ENDP		; CBaseEntity::SetClassname
_TEXT	ENDS
PUBLIC	??0CFuncPlatRot@@QAE@XZ				; CFuncPlatRot::CFuncPlatRot
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41634 = -20
$T41635 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39585

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39585:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39587

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1996					; 000007ccH
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41635[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41635[ebp], 0
	je	SHORT $L41636
	mov	ecx, DWORD PTR $T41635[ebp]
	call	??0CFuncPlatRot@@QAE@XZ			; CFuncPlatRot::CFuncPlatRot
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41637
$L41636:
	mov	DWORD PTR -28+[ebp], 0
$L41637:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41634[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41634[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39587:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41635[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncPlatRot@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CTrainSequence@@QAE@XZ			; CTrainSequence::CTrainSequence
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41647 = -20
$T41648 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39596

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39596:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39598

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1788					; 000006fcH
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41648[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41648[ebp], 0
	je	SHORT $L41649
	mov	ecx, DWORD PTR $T41648[ebp]
	call	??0CTrainSequence@@QAE@XZ		; CTrainSequence::CTrainSequence
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41650
$L41649:
	mov	DWORD PTR -28+[ebp], 0
$L41650:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41647[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41647[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39598:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41648[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCTrainSequence@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CFuncTrain@@QAE@XZ				; CFuncTrain::CFuncTrain
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41660 = -20
$T41661 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39607

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39607:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39609

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1988					; 000007c4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41661[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41661[ebp], 0
	je	SHORT $L41662
	mov	ecx, DWORD PTR $T41661[ebp]
	call	??0CFuncTrain@@QAE@XZ			; CFuncTrain::CFuncTrain
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41663
$L41662:
	mov	DWORD PTR -28+[ebp], 0
$L41663:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41660[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41660[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39609:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41661[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncTrain@@PAV1@PBD@Z ENDP		; GetClassPtr
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41673 = -20
$T41674 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z PROC NEAR ; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39618

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39618:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39620

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1908					; 00000774H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41674[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41674[ebp], 0
	je	SHORT $L41675
	mov	ecx, DWORD PTR $T41674[ebp]
	call	??0CFuncTrackTrain@@QAE@XZ		; CFuncTrackTrain::CFuncTrackTrain
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41676
$L41675:
	mov	DWORD PTR -28+[ebp], 0
$L41676:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41673[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41673[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39620:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41674[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncTrackTrain@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CFuncTrainControls@@QAE@XZ			; CFuncTrainControls::CFuncTrainControls
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41686 = -20
$T41687 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z PROC NEAR ; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39629

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39629:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39631

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1764					; 000006e4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41687[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41687[ebp], 0
	je	SHORT $L41688
	mov	ecx, DWORD PTR $T41687[ebp]
	call	??0CFuncTrainControls@@QAE@XZ		; CFuncTrainControls::CFuncTrainControls
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41689
$L41688:
	mov	DWORD PTR -28+[ebp], 0
$L41689:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41686[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41686[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39631:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41687[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncTrainControls@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CFuncTrackChange@@QAE@XZ			; CFuncTrackChange::CFuncTrackChange
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41699 = -20
$T41700 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z PROC NEAR ; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39640

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39640:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39642

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2036					; 000007f4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41700[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41700[ebp], 0
	je	SHORT $L41701
	mov	ecx, DWORD PTR $T41700[ebp]
	call	??0CFuncTrackChange@@QAE@XZ		; CFuncTrackChange::CFuncTrackChange
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41702
$L41701:
	mov	DWORD PTR -28+[ebp], 0
$L41702:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41699[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41699[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39642:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41700[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncTrackChange@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CFuncTrackAuto@@QAE@XZ			; CFuncTrackAuto::CFuncTrackAuto
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41712 = -20
$T41713 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39651

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39651:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39653

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2036					; 000007f4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41713[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41713[ebp], 0
	je	SHORT $L41714
	mov	ecx, DWORD PTR $T41713[ebp]
	call	??0CFuncTrackAuto@@QAE@XZ		; CFuncTrackAuto::CFuncTrackAuto
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41715
$L41714:
	mov	DWORD PTR -28+[ebp], 0
$L41715:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41712[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41712[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39653:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41713[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncTrackAuto@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CGunTarget@@QAE@XZ				; CGunTarget::CGunTarget
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41725 = -20
$T41726 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39662

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39662:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39664

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2400					; 00000960H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41726[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41726[ebp], 0
	je	SHORT $L41727
	mov	ecx, DWORD PTR $T41726[ebp]
	call	??0CGunTarget@@QAE@XZ			; CGunTarget::CGunTarget
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41728
$L41727:
	mov	DWORD PTR -28+[ebp], 0
$L41728:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41725[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41725[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39664:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41726[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCGunTarget@@PAV1@PBD@Z ENDP		; GetClassPtr
PUBLIC	?ObjectCaps@CPlatTrigger@@UAEHXZ		; CPlatTrigger::ObjectCaps
PUBLIC	??_7CPlatTrigger@@6B@				; CPlatTrigger::`vftable'
;	COMDAT ??_7CPlatTrigger@@6B@
CONST	SEGMENT
??_7CPlatTrigger@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CPlatTrigger::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CPlatTrigger@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CPlatTrigger@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CPlatTrigger@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CPlatTrigger@@QAE@XZ PROC NEAR			; CPlatTrigger::CPlatTrigger, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CPlatTrigger@@6B@ ; CPlatTrigger::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CPlatTrigger@@QAE@XZ ENDP				; CPlatTrigger::CPlatTrigger
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPlatTrigger@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CPlatTrigger@@UAEHXZ PROC NEAR		; CPlatTrigger::ObjectCaps, COMDAT

; 251  : 	virtual int ObjectCaps( void ) { return (BaseClass :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | FCAP_DONT_SAVE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	eax, -2147483648			; 80000000H
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CPlatTrigger@@UAEHXZ ENDP			; CPlatTrigger::ObjectCaps
_TEXT	ENDS
PUBLIC	?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z ; CBaseAnimating::HandleAnimEvent
PUBLIC	?GetToggleState@CBaseToggle@@UAEHXZ		; CBaseToggle::GetToggleState
PUBLIC	?GetDelay@CBaseToggle@@UAEMXZ			; CBaseToggle::GetDelay
PUBLIC	?IsTogglePlat@CBasePlatTrain@@UAEHXZ		; CBasePlatTrain::IsTogglePlat
PUBLIC	??0CBasePlatTrain@@QAE@XZ			; CBasePlatTrain::CBasePlatTrain
PUBLIC	?ObjectCaps@CFuncPlat@@UAEHXZ			; CFuncPlat::ObjectCaps
PUBLIC	??_7CFuncPlat@@6B@				; CFuncPlat::`vftable'
EXTRN	?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z:NEAR	; CBaseToggle::Restore
EXTRN	?GetState@CBaseToggle@@UAE?AW4STATE@@XZ:NEAR	; CBaseToggle::GetState
EXTRN	?MoveDone@CBaseToggle@@UAEXXZ:NEAR		; CBaseToggle::MoveDone
;	COMDAT ??_7CFuncPlat@@6B@
CONST	SEGMENT
??_7CFuncPlat@@6B@ DD FLAT:?GetDataDescMap@CFuncPlat@@UAEPAUdatamap_s@@XZ ; CFuncPlat::`vftable'
	DD	FLAT:?Spawn@CFuncPlat@@UAEXXZ
	DD	FLAT:?Precache@CFuncPlat@@UAEXXZ
	DD	FLAT:?KeyValue@CBasePlatTrain@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncPlat@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?IsTogglePlat@CBasePlatTrain@@UAEHXZ
	DD	FLAT:?GoUp@CFuncPlat@@UAEXXZ
	DD	FLAT:?GoDown@CFuncPlat@@UAEXXZ
	DD	FLAT:?HitTop@CFuncPlat@@UAEXXZ
	DD	FLAT:?HitBottom@CFuncPlat@@UAEXXZ
	DD	FLAT:?HitFloor@CFuncPlat@@UAEXXZ
CONST	ENDS
;	COMDAT ??0CFuncPlat@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncPlat@@QAE@XZ PROC NEAR				; CFuncPlat::CFuncPlat, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBasePlatTrain@@QAE@XZ		; CBasePlatTrain::CBasePlatTrain
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncPlat@@6B@ ; CFuncPlat::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncPlat@@QAE@XZ ENDP				; CFuncPlat::CFuncPlat
_TEXT	ENDS
;	COMDAT ?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT
_this$ = -4
?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z PROC NEAR ; CBaseAnimating::HandleAnimEvent, COMDAT

; 909  : 	virtual void HandleAnimEvent( MonsterEvent_t *pEvent ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z ENDP ; CBaseAnimating::HandleAnimEvent
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseToggle@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseToggle@@UAEHXZ PROC NEAR		; CBaseToggle::GetToggleState, COMDAT

; 978  : 	virtual int GetToggleState( void ) { return m_toggle_state; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1816]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseToggle@@UAEHXZ ENDP		; CBaseToggle::GetToggleState
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseToggle@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseToggle@@UAEMXZ PROC NEAR			; CBaseToggle::GetDelay, COMDAT

; 979  : 	virtual float GetDelay( void ) { return m_flWait; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1764]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseToggle@@UAEMXZ ENDP			; CBaseToggle::GetDelay
_TEXT	ENDS
;	COMDAT ?IsTogglePlat@CBasePlatTrain@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTogglePlat@CBasePlatTrain@@UAEHXZ PROC NEAR		; CBasePlatTrain::IsTogglePlat, COMDAT

; 40   : 	virtual BOOL IsTogglePlat( void ) { return (pev->spawnflags & SF_PLAT_TOGGLE) ? TRUE : FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+416]
	and	eax, 1
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTogglePlat@CBasePlatTrain@@UAEHXZ ENDP		; CBasePlatTrain::IsTogglePlat
_TEXT	ENDS
PUBLIC	?ObjectCaps@CBasePlatTrain@@UAEHXZ		; CBasePlatTrain::ObjectCaps
;	COMDAT ?ObjectCaps@CFuncPlat@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CFuncPlat@@UAEHXZ PROC NEAR			; CFuncPlat::ObjectCaps, COMDAT

; 208  : 	virtual int ObjectCaps( void ) { return (CBasePlatTrain :: ObjectCaps()) | FCAP_SET_MOVEDIR; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBasePlatTrain@@UAEHXZ	; CBasePlatTrain::ObjectCaps
	or	al, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CFuncPlat@@UAEHXZ ENDP			; CFuncPlat::ObjectCaps
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBasePlatTrain@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBasePlatTrain@@UAEHXZ PROC NEAR		; CBasePlatTrain::ObjectCaps, COMDAT

; 35   : 	virtual int ObjectCaps( void ) { return BaseClass :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBasePlatTrain@@UAEHXZ ENDP			; CBasePlatTrain::ObjectCaps
_TEXT	ENDS
PUBLIC	??_7CFuncPlatRot@@6B@				; CFuncPlatRot::`vftable'
PUBLIC	??1CFuncPlat@@QAE@XZ				; CFuncPlat::~CFuncPlat
;	COMDAT ??_7CFuncPlatRot@@6B@
CONST	SEGMENT
??_7CFuncPlatRot@@6B@ DD FLAT:?GetDataDescMap@CFuncPlatRot@@UAEPAUdatamap_s@@XZ ; CFuncPlatRot::`vftable'
	DD	FLAT:?Spawn@CFuncPlatRot@@UAEXXZ
	DD	FLAT:?Precache@CFuncPlat@@UAEXXZ
	DD	FLAT:?KeyValue@CBasePlatTrain@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncPlat@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?IsTogglePlat@CBasePlatTrain@@UAEHXZ
	DD	FLAT:?GoUp@CFuncPlatRot@@UAEXXZ
	DD	FLAT:?GoDown@CFuncPlatRot@@UAEXXZ
	DD	FLAT:?HitTop@CFuncPlatRot@@UAEXXZ
	DD	FLAT:?HitBottom@CFuncPlatRot@@UAEXXZ
	DD	FLAT:?HitFloor@CFuncPlat@@UAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CFuncPlatRot@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CFuncPlatRot@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CFuncPlatRot@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CFuncPlatRot@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CFuncPlatRot@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CFuncPlatRot@@QAE@XZ PROC NEAR			; CFuncPlatRot::CFuncPlatRot, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CFuncPlatRot@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CFuncPlat@@QAE@XZ			; CFuncPlat::CFuncPlat
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1972				; 000007b4H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1984				; 000007c0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncPlatRot@@6B@ ; CFuncPlatRot::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CFuncPlatRot@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CFuncPlat@@QAE@XZ			; CFuncPlat::~CFuncPlat
	ret	0
__ehhandler$??0CFuncPlatRot@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CFuncPlatRot@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CFuncPlatRot@@QAE@XZ ENDP				; CFuncPlatRot::CFuncPlatRot
PUBLIC	?ObjectCaps@CTrainSequence@@UAEHXZ		; CTrainSequence::ObjectCaps
PUBLIC	?GetState@CTrainSequence@@UAE?AW4STATE@@XZ	; CTrainSequence::GetState
PUBLIC	??_7CTrainSequence@@6B@				; CTrainSequence::`vftable'
;	COMDAT ??_7CTrainSequence@@6B@
CONST	SEGMENT
??_7CTrainSequence@@6B@ DD FLAT:?GetDataDescMap@CTrainSequence@@UAEPAUdatamap_s@@XZ ; CTrainSequence::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CTrainSequence@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CTrainSequence@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CTrainSequence@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CTrainSequence@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CTrainSequence@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CTrainSequence@@QAE@XZ PROC NEAR			; CTrainSequence::CTrainSequence, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CTrainSequence@@6B@ ; CTrainSequence::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CTrainSequence@@QAE@XZ ENDP				; CTrainSequence::CTrainSequence
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CTrainSequence@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CTrainSequence@@UAEHXZ PROC NEAR		; CTrainSequence::ObjectCaps, COMDAT

; 732  : 	virtual int ObjectCaps( void ) { return CBaseEntity :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CTrainSequence@@UAEHXZ ENDP			; CTrainSequence::ObjectCaps
_TEXT	ENDS
;	COMDAT ?GetState@CTrainSequence@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CTrainSequence@@UAE?AW4STATE@@XZ PROC NEAR	; CTrainSequence::GetState, COMDAT

; 733  : 	STATE GetState( void ) { return (m_pTrain) ? STATE_ON : STATE_OFF; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+1780], 0
	setne	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CTrainSequence@@UAE?AW4STATE@@XZ ENDP		; CTrainSequence::GetState
_TEXT	ENDS
PUBLIC	?GetState@CFuncTrain@@UAE?AW4STATE@@XZ		; CFuncTrain::GetState
PUBLIC	??_7CFuncTrain@@6B@				; CFuncTrain::`vftable'
;	COMDAT ??_7CFuncTrain@@6B@
CONST	SEGMENT
??_7CFuncTrain@@6B@ DD FLAT:?GetDataDescMap@CFuncTrain@@UAEPAUdatamap_s@@XZ ; CFuncTrain::`vftable'
	DD	FLAT:?Spawn@CFuncTrain@@UAEXXZ
	DD	FLAT:?Precache@CFuncTrain@@UAEXXZ
	DD	FLAT:?KeyValue@CBasePlatTrain@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBasePlatTrain@@UAEHXZ
	DD	FLAT:?Activate@CFuncTrain@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CFuncTrain@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CFuncTrain@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CFuncTrain@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CFuncTrain@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?IsTogglePlat@CBasePlatTrain@@UAEHXZ
CONST	ENDS
;	COMDAT ??0CFuncTrain@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncTrain@@QAE@XZ PROC NEAR				; CFuncTrain::CFuncTrain, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBasePlatTrain@@QAE@XZ		; CBasePlatTrain::CBasePlatTrain
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncTrain@@6B@ ; CFuncTrain::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncTrain@@QAE@XZ ENDP				; CFuncTrain::CFuncTrain
_TEXT	ENDS
;	COMDAT ?GetState@CFuncTrain@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CFuncTrain@@UAE?AW4STATE@@XZ PROC NEAR	; CFuncTrain::GetState, COMDAT

; 817  : 	STATE GetState( void ) { return m_iState; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1788]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CFuncTrain@@UAE?AW4STATE@@XZ ENDP		; CFuncTrain::GetState
_TEXT	ENDS
PUBLIC	?ObjectCaps@CFuncTrainControls@@UAEHXZ		; CFuncTrainControls::ObjectCaps
PUBLIC	??_7CFuncTrainControls@@6B@			; CFuncTrainControls::`vftable'
;	COMDAT ??_7CFuncTrainControls@@6B@
CONST	SEGMENT
??_7CFuncTrainControls@@6B@ DD FLAT:?GetDataDescMap@CFuncTrainControls@@UAEPAUdatamap_s@@XZ ; CFuncTrainControls::`vftable'
	DD	FLAT:?Spawn@CFuncTrainControls@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncTrainControls@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CFuncTrainControls@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncTrainControls@@QAE@XZ PROC NEAR			; CFuncTrainControls::CFuncTrainControls, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncTrainControls@@6B@ ; CFuncTrainControls::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncTrainControls@@QAE@XZ ENDP			; CFuncTrainControls::CFuncTrainControls
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncTrainControls@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CFuncTrainControls@@UAEHXZ PROC NEAR	; CFuncTrainControls::ObjectCaps, COMDAT

; 2553 : 	virtual int ObjectCaps( void ) { return (BaseClass :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | FCAP_IGNORE_PARENT; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	ah, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CFuncTrainControls@@UAEHXZ ENDP		; CFuncTrainControls::ObjectCaps
_TEXT	ENDS
PUBLIC	?Touch@CFuncTrackChange@@UAEXPAVCBaseEntity@@@Z	; CFuncTrackChange::Touch
PUBLIC	?IsTogglePlat@CFuncTrackChange@@UAEHXZ		; CFuncTrackChange::IsTogglePlat
PUBLIC	??_7CFuncTrackChange@@6B@			; CFuncTrackChange::`vftable'
;	COMDAT ??_7CFuncTrackChange@@6B@
CONST	SEGMENT
??_7CFuncTrackChange@@6B@ DD FLAT:?GetDataDescMap@CFuncTrackChange@@UAEPAUdatamap_s@@XZ ; CFuncTrackChange::`vftable'
	DD	FLAT:?Spawn@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?Precache@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?KeyValue@CFuncTrackChange@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncPlat@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CFuncTrackChange@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CFuncTrackChange@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?IsTogglePlat@CFuncTrackChange@@UAEHXZ
	DD	FLAT:?GoUp@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?GoDown@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?HitTop@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?HitBottom@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?HitFloor@CFuncPlat@@UAEXXZ
	DD	FLAT:?UpdateAutoTargets@CFuncTrackChange@@UAEXH@Z
CONST	ENDS
;	COMDAT ??0CFuncTrackChange@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncTrackChange@@QAE@XZ PROC NEAR			; CFuncTrackChange::CFuncTrackChange, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CFuncPlatRot@@QAE@XZ			; CFuncPlatRot::CFuncPlatRot
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncTrackChange@@6B@ ; CFuncTrackChange::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncTrackChange@@QAE@XZ ENDP			; CFuncTrackChange::CFuncTrackChange
_TEXT	ENDS
;	COMDAT ?Touch@CFuncTrackChange@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
?Touch@CFuncTrackChange@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CFuncTrackChange::Touch, COMDAT

; 2641 : 	void		Touch( CBaseEntity *pOther ) {};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CFuncTrackChange@@UAEXPAVCBaseEntity@@@Z ENDP	; CFuncTrackChange::Touch
_TEXT	ENDS
;	COMDAT ?IsTogglePlat@CFuncTrackChange@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTogglePlat@CFuncTrackChange@@UAEHXZ PROC NEAR	; CFuncTrackChange::IsTogglePlat, COMDAT

; 2643 : 	virtual BOOL	IsTogglePlat( void ) { return TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTogglePlat@CFuncTrackChange@@UAEHXZ ENDP		; CFuncTrackChange::IsTogglePlat
_TEXT	ENDS
PUBLIC	??_7CFuncTrackAuto@@6B@				; CFuncTrackAuto::`vftable'
;	COMDAT ??_7CFuncTrackAuto@@6B@
CONST	SEGMENT
??_7CFuncTrackAuto@@6B@ DD FLAT:?GetDataDescMap@CFuncTrackChange@@UAEPAUdatamap_s@@XZ ; CFuncTrackAuto::`vftable'
	DD	FLAT:?Spawn@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?Precache@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?KeyValue@CFuncTrackChange@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncPlat@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CFuncTrackAuto@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CFuncTrackChange@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?Blocked@CFuncPlat@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?IsTogglePlat@CFuncTrackChange@@UAEHXZ
	DD	FLAT:?GoUp@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?GoDown@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?HitTop@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?HitBottom@CFuncTrackChange@@UAEXXZ
	DD	FLAT:?HitFloor@CFuncPlat@@UAEXXZ
	DD	FLAT:?UpdateAutoTargets@CFuncTrackAuto@@UAEXH@Z
CONST	ENDS
;	COMDAT ??0CFuncTrackAuto@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncTrackAuto@@QAE@XZ PROC NEAR			; CFuncTrackAuto::CFuncTrackAuto, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CFuncTrackChange@@QAE@XZ		; CFuncTrackChange::CFuncTrackChange
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncTrackAuto@@6B@ ; CFuncTrackAuto::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncTrackAuto@@QAE@XZ ENDP				; CFuncTrackAuto::CFuncTrackAuto
_TEXT	ENDS
PUBLIC	?SetYawSpeed@CBaseMonster@@UAEXXZ		; CBaseMonster::SetYawSpeed
PUBLIC	?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z	; CBaseMonster::FValidateCover
PUBLIC	?CoverRadius@CBaseMonster@@UAEMXZ		; CBaseMonster::CoverRadius
PUBLIC	?CheckAmmo@CBaseMonster@@UAEXXZ			; CBaseMonster::CheckAmmo
PUBLIC	?HearingSensitivity@CBaseMonster@@UAEMXZ	; CBaseMonster::HearingSensitivity
PUBLIC	?PrescheduleThink@CBaseMonster@@UAEXXZ		; CBaseMonster::PrescheduleThink
PUBLIC	?IsMoving@CBaseMonster@@UAEHXZ			; CBaseMonster::IsMoving
PUBLIC	?DeathSound@CBaseMonster@@UAEXXZ		; CBaseMonster::DeathSound
PUBLIC	?AlertSound@CBaseMonster@@UAEXXZ		; CBaseMonster::AlertSound
PUBLIC	?IdleSound@CBaseMonster@@UAEXXZ			; CBaseMonster::IdleSound
PUBLIC	?PainSound@CBaseMonster@@UAEXXZ			; CBaseMonster::PainSound
PUBLIC	?StopFollowing@CBaseMonster@@UAEXH@Z		; CBaseMonster::StopFollowing
PUBLIC	??0CBaseMonster@@QAE@XZ				; CBaseMonster::CBaseMonster
PUBLIC	?BloodColor@CGunTarget@@UAEHXZ			; CGunTarget::BloodColor
PUBLIC	?Classify@CGunTarget@@UAEHXZ			; CGunTarget::Classify
PUBLIC	?BodyTarget@CGunTarget@@UAE?AVVector@@ABV2@@Z	; CGunTarget::BodyTarget
PUBLIC	?ObjectCaps@CGunTarget@@UAEHXZ			; CGunTarget::ObjectCaps
PUBLIC	??_7CGunTarget@@6B@				; CGunTarget::`vftable'
PUBLIC	?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ	; CBaseMonster::MyMonsterPointer
PUBLIC	?IsAlive@CBaseMonster@@UAEHXZ			; CBaseMonster::IsAlive
PUBLIC	?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ ; CBaseMonster::GetStoppedActivity
PUBLIC	?ScheduleChange@CBaseMonster@@UAEXXZ		; CBaseMonster::ScheduleChange
PUBLIC	?CanPlaySentence@CBaseMonster@@UAEHH@Z		; CBaseMonster::CanPlaySentence
EXTRN	?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z:NEAR ; CBaseMonster::BuildNearestRoute
EXTRN	?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z:NEAR ; CBaseMonster::FindCover
EXTRN	?FCanCheckAttacks@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::FCanCheckAttacks
EXTRN	?IgnoreConditions@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::IgnoreConditions
EXTRN	?FValidateHintType@CBaseMonster@@UAEHF@Z:NEAR	; CBaseMonster::FValidateHintType
EXTRN	?FCanActiveIdle@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::FCanActiveIdle
EXTRN	?ISoundMask@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::ISoundMask
EXTRN	?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ:NEAR	; CBaseMonster::PBestSound
EXTRN	?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ:NEAR	; CBaseMonster::PBestScent
EXTRN	?FBecomeProne@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::FBecomeProne
EXTRN	?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z:NEAR ; CBaseMonster::BarnacleVictimBitten
EXTRN	?BarnacleVictimReleased@CBaseMonster@@UAEXXZ:NEAR ; CBaseMonster::BarnacleVictimReleased
EXTRN	?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseMonster::TraceAttack
EXTRN	?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ:NEAR ; CBaseMonster::GetDeathActivity
EXTRN	?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z:NEAR ; CBaseMonster::Killed
EXTRN	?GibMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::GibMonster
EXTRN	?DamageDecal@CBaseMonster@@UAEHH@Z:NEAR		; CBaseMonster::DamageDecal
EXTRN	?HasHumanGibs@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::HasHumanGibs
EXTRN	?HasAlienGibs@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::HasAlienGibs
EXTRN	?FadeMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::FadeMonster
EXTRN	?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ:NEAR ; CBaseMonster::GetGunPosition
EXTRN	?TakeHealth@CBaseMonster@@UAEHMH@Z:NEAR		; CBaseMonster::TakeHealth
EXTRN	?StepSound@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::StepSound
EXTRN	?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseMonster::KeyValue
EXTRN	?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z:NEAR	; CBaseMonster::Restore
EXTRN	?Look@CBaseMonster@@UAEXH@Z:NEAR		; CBaseMonster::Look
EXTRN	?RunAI@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::RunAI
EXTRN	?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::ShouldFadeOnDeath
EXTRN	?ChangeYaw@CBaseMonster@@UAEMH@Z:NEAR		; CBaseMonster::ChangeYaw
EXTRN	?MonsterThink@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::MonsterThink
EXTRN	?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::IRelationship
EXTRN	?MonsterInit@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::MonsterInit
EXTRN	?MonsterInitDead@CBaseMonster@@UAEXXZ:NEAR	; CBaseMonster::MonsterInitDead
EXTRN	?BecomeDead@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::BecomeDead
EXTRN	?StartMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::StartMonster
EXTRN	?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ:NEAR ; CBaseMonster::BestVisibleEnemy
EXTRN	?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::FInViewCone
EXTRN	?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z:NEAR ; CBaseMonster::FInViewCone
EXTRN	?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z:NEAR ; CBaseMonster::HandleAnimEvent
EXTRN	?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z:NEAR ; CBaseMonster::CheckLocalMove
EXTRN	?Move@CBaseMonster@@UAEXM@Z:NEAR		; CBaseMonster::Move
EXTRN	?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z:NEAR ; CBaseMonster::MoveExecute
EXTRN	?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z:NEAR	; CBaseMonster::ShouldAdvanceRoute
EXTRN	?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckRangeAttack1
EXTRN	?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckRangeAttack2
EXTRN	?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckMeleeAttack1
EXTRN	?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckMeleeAttack2
EXTRN	?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z:NEAR ; CBaseMonster::ScheduleFromName
EXTRN	?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z:NEAR	; CBaseMonster::StartTask
EXTRN	?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z:NEAR	; CBaseMonster::RunTask
EXTRN	?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z:NEAR ; CBaseMonster::GetScheduleOfType
EXTRN	?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ:NEAR ; CBaseMonster::GetSchedule
EXTRN	?CanPlaySequence@CBaseMonster@@UAEHHH@Z:NEAR	; CBaseMonster::CanPlaySequence
EXTRN	?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z:NEAR	; CBaseMonster::PlaySentence
EXTRN	?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::PlayScriptedSentence
EXTRN	?SentenceStop@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::SentenceStop
EXTRN	?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ:NEAR ; CBaseMonster::GetIdealState
EXTRN	?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z:NEAR ; CBaseMonster::SetActivity
EXTRN	?ReportAIState@CBaseMonster@@UAEXXZ:NEAR	; CBaseMonster::ReportAIState
EXTRN	?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::CheckEnemy
EXTRN	?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z:NEAR ; CBaseMonster::FTriangulate
;	COMDAT ??_7CGunTarget@@6B@
CONST	SEGMENT
??_7CGunTarget@@6B@ DD FLAT:?GetDataDescMap@CGunTarget@@UAEPAUdatamap_s@@XZ ; CGunTarget::`vftable'
	DD	FLAT:?Spawn@CGunTarget@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CGunTarget@@UAEHXZ
	DD	FLAT:?Activate@CGunTarget@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CGunTarget@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CGunTarget@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseMonster@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CGunTarget@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseMonster@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CGunTarget@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseMonster@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CGunTarget@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CGunTarget@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CBaseMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CBaseMonster@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CBaseMonster@@UAEHXZ
	DD	FLAT:?CheckAmmo@CBaseMonster@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CBaseMonster@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?PainSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
CONST	ENDS
;	COMDAT ??0CGunTarget@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CGunTarget@@QAE@XZ PROC NEAR				; CGunTarget::CGunTarget, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseMonster@@QAE@XZ			; CBaseMonster::CBaseMonster
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CGunTarget@@6B@ ; CGunTarget::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CGunTarget@@QAE@XZ ENDP				; CGunTarget::CGunTarget
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ PROC NEAR	; CBaseMonster::MyMonsterPointer, COMDAT

; 134  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return this; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ ENDP		; CBaseMonster::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseMonster@@UAEHXZ PROC NEAR			; CBaseMonster::IsAlive, COMDAT

; 139  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag != DEAD_DEAD); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+368], 2
	setne	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::IsAlive
_TEXT	ENDS
;	COMDAT ?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ PROC NEAR ; CBaseMonster::GetStoppedActivity, COMDAT

; 175  : 		virtual Activity GetStoppedActivity( void ) { return ACT_IDLE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ ENDP ; CBaseMonster::GetStoppedActivity
_TEXT	ENDS
;	COMDAT ?ScheduleChange@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ScheduleChange@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::ScheduleChange, COMDAT

; 203  : 		virtual void ScheduleChange( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ScheduleChange@CBaseMonster@@UAEXXZ ENDP		; CBaseMonster::ScheduleChange
_TEXT	ENDS
;	COMDAT ?CanPlaySentence@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
?CanPlaySentence@CBaseMonster@@UAEHH@Z PROC NEAR	; CBaseMonster::CanPlaySentence, COMDAT

; 206  : 		virtual int CanPlaySentence( BOOL fDisregardState ) { return IsAlive(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CanPlaySentence@CBaseMonster@@UAEHH@Z ENDP		; CBaseMonster::CanPlaySentence
_TEXT	ENDS
;	COMDAT ?SetYawSpeed@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SetYawSpeed@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::SetYawSpeed, COMDAT

; 241  : 		virtual void SetYawSpeed ( void ) { return; };// allows different yaw_speeds for each activity

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetYawSpeed@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::SetYawSpeed
_TEXT	ENDS
;	COMDAT ?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4
?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z PROC NEAR ; CBaseMonster::FValidateCover, COMDAT

; 249  : 		virtual BOOL FValidateCover ( const Vector &vecCoverLocation ) { return TRUE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z ENDP	; CBaseMonster::FValidateCover
_TEXT	ENDS
PUBLIC	__real@4@4008c400000000000000
;	COMDAT __real@4@4008c400000000000000
; File z:\xashxtsrc\server\monsters\basemonster.h
CONST	SEGMENT
__real@4@4008c400000000000000 DD 044440000r	; 784
CONST	ENDS
;	COMDAT ?CoverRadius@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?CoverRadius@CBaseMonster@@UAEMXZ PROC NEAR		; CBaseMonster::CoverRadius, COMDAT

; 250  : 		virtual float CoverRadius( void ) { return 784; } // Default cover radius

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@4008c400000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CoverRadius@CBaseMonster@@UAEMXZ ENDP			; CBaseMonster::CoverRadius
_TEXT	ENDS
;	COMDAT ?CheckAmmo@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CheckAmmo@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::CheckAmmo, COMDAT

; 253  : 		virtual void CheckAmmo( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckAmmo@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::CheckAmmo
_TEXT	ENDS
;	COMDAT ?HearingSensitivity@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?HearingSensitivity@CBaseMonster@@UAEMXZ PROC NEAR	; CBaseMonster::HearingSensitivity, COMDAT

; 278  : 		virtual float HearingSensitivity( void ) { return 1.0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@3fff8000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HearingSensitivity@CBaseMonster@@UAEMXZ ENDP		; CBaseMonster::HearingSensitivity
_TEXT	ENDS
;	COMDAT ?PrescheduleThink@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PrescheduleThink@CBaseMonster@@UAEXXZ PROC NEAR	; CBaseMonster::PrescheduleThink, COMDAT

; 298  : 		virtual void PrescheduleThink( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrescheduleThink@CBaseMonster@@UAEXXZ ENDP		; CBaseMonster::PrescheduleThink
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::IsMoving, COMDAT

; 328  : 	virtual int		IsMoving( void ) { return m_movementGoal != MOVEGOAL_NONE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+2228], 0
	setne	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::IsMoving
_TEXT	ENDS
;	COMDAT ?DeathSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DeathSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::DeathSound, COMDAT

; 333  : 	virtual void DeathSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DeathSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::DeathSound
_TEXT	ENDS
;	COMDAT ?AlertSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?AlertSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::AlertSound, COMDAT

; 334  : 	virtual void AlertSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AlertSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::AlertSound
_TEXT	ENDS
;	COMDAT ?IdleSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?IdleSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::IdleSound, COMDAT

; 335  : 	virtual void IdleSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IdleSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::IdleSound
_TEXT	ENDS
;	COMDAT ?PainSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PainSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::PainSound, COMDAT

; 336  : 	virtual void PainSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PainSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::PainSound
_TEXT	ENDS
;	COMDAT ?StopFollowing@CBaseMonster@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?StopFollowing@CBaseMonster@@UAEXH@Z PROC NEAR		; CBaseMonster::StopFollowing, COMDAT

; 339  : 	virtual void StopFollowing( BOOL clearSchedule ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StopFollowing@CBaseMonster@@UAEXH@Z ENDP		; CBaseMonster::StopFollowing
_TEXT	ENDS
;	COMDAT ?BloodColor@CGunTarget@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CGunTarget@@UAEHXZ PROC NEAR		; CGunTarget::BloodColor, COMDAT

; 3206 : 	int BloodColor( void ) { return DONT_BLEED; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CGunTarget@@UAEHXZ ENDP			; CGunTarget::BloodColor
_TEXT	ENDS
;	COMDAT ?Classify@CGunTarget@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CGunTarget@@UAEHXZ PROC NEAR			; CGunTarget::Classify, COMDAT

; 3207 : 	int Classify( void ) { return CLASS_MACHINE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CGunTarget@@UAEHXZ ENDP			; CGunTarget::Classify
_TEXT	ENDS
;	COMDAT ?BodyTarget@CGunTarget@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
?BodyTarget@CGunTarget@@UAE?AVVector@@ABV2@@Z PROC NEAR	; CGunTarget::BodyTarget, COMDAT

; 3210 : 	Vector BodyTarget( const Vector &posSrc ) { return GetAbsOrigin(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CGunTarget@@UAE?AVVector@@ABV2@@Z ENDP	; CGunTarget::BodyTarget
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CGunTarget@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CGunTarget@@UAEHXZ PROC NEAR		; CGunTarget::ObjectCaps, COMDAT

; 3211 : 	virtual int ObjectCaps( void ) { return BaseClass :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CGunTarget@@UAEHXZ ENDP			; CGunTarget::ObjectCaps
_TEXT	ENDS
PUBLIC	??0CBaseToggle@@QAE@XZ				; CBaseToggle::CBaseToggle
PUBLIC	??_7CBasePlatTrain@@6B@				; CBasePlatTrain::`vftable'
;	COMDAT ??_7CBasePlatTrain@@6B@
CONST	SEGMENT
??_7CBasePlatTrain@@6B@ DD FLAT:?GetDataDescMap@CBasePlatTrain@@UAEPAUdatamap_s@@XZ ; CBasePlatTrain::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBasePlatTrain@@UAEXXZ
	DD	FLAT:?KeyValue@CBasePlatTrain@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBasePlatTrain@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?IsTogglePlat@CBasePlatTrain@@UAEHXZ
CONST	ENDS
;	COMDAT ??0CBasePlatTrain@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBasePlatTrain@@QAE@XZ PROC NEAR			; CBasePlatTrain::CBasePlatTrain, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseToggle@@QAE@XZ			; CBaseToggle::CBaseToggle
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBasePlatTrain@@6B@ ; CBasePlatTrain::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBasePlatTrain@@QAE@XZ ENDP				; CBasePlatTrain::CBasePlatTrain
_TEXT	ENDS
PUBLIC	??1CBasePlatTrain@@QAE@XZ			; CBasePlatTrain::~CBasePlatTrain
;	COMDAT ??1CFuncPlat@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CFuncPlat@@QAE@XZ PROC NEAR				; CFuncPlat::~CFuncPlat, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBasePlatTrain@@QAE@XZ		; CBasePlatTrain::~CBasePlatTrain
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CFuncPlat@@QAE@XZ ENDP				; CFuncPlat::~CFuncPlat
_TEXT	ENDS
PUBLIC	??1CBaseToggle@@QAE@XZ				; CBaseToggle::~CBaseToggle
;	COMDAT ??1CBasePlatTrain@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBasePlatTrain@@QAE@XZ PROC NEAR			; CBasePlatTrain::~CBasePlatTrain, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseToggle@@QAE@XZ			; CBaseToggle::~CBaseToggle
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBasePlatTrain@@QAE@XZ ENDP				; CBasePlatTrain::~CBasePlatTrain
_TEXT	ENDS
PUBLIC	??0WayPoint_t@@QAE@XZ				; WayPoint_t::WayPoint_t
PUBLIC	?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z	; CBaseMonster::BodyTarget
PUBLIC	??_7CBaseMonster@@6B@				; CBaseMonster::`vftable'
PUBLIC	?Classify@CBaseMonster@@UAEHXZ			; CBaseMonster::Classify
PUBLIC	?BloodColor@CBaseMonster@@UAEHXZ		; CBaseMonster::BloodColor
PUBLIC	?Stop@CBaseMonster@@UAEXXZ			; CBaseMonster::Stop
EXTRN	?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseMonster::TakeDamage
EXTRN	?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseMonster::GetDataDescMap
;	COMDAT ??_7CBaseMonster@@6B@
CONST	SEGMENT
??_7CBaseMonster@@6B@ DD FLAT:?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ ; CBaseMonster::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseMonster@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseMonster@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseMonster@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseMonster@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseMonster@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CBaseMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CBaseMonster@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CBaseMonster@@UAEHXZ
	DD	FLAT:?CheckAmmo@CBaseMonster@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CBaseMonster@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?PainSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseMonster@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseMonster@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseMonster@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseMonster@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseMonster@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseMonster@@QAE@XZ PROC NEAR			; CBaseMonster::CBaseMonster, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseMonster@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseToggle@@QAE@XZ			; CBaseToggle::CBaseToggle
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2008				; 000007d8H
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0WayPoint_t@@QAE@XZ	; WayPoint_t::WayPoint_t
	push	8
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2100				; 00000834H
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2240				; 000008c0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2264				; 000008d8H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2364				; 0000093cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET FLAT:??_7CBaseMonster@@6B@ ; CBaseMonster::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseMonster@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseToggle@@QAE@XZ			; CBaseToggle::~CBaseToggle
	ret	0
__ehhandler$??0CBaseMonster@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseMonster@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseMonster@@QAE@XZ ENDP				; CBaseMonster::CBaseMonster
;	COMDAT ?Classify@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::Classify, COMDAT

; 130  : 	virtual int	Classify( void ) { return m_iClass ? m_iClass : CLASS_NONE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2388], 0
	je	SHORT $L41859
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2388]
	mov	DWORD PTR -8+[ebp], edx
	jmp	SHORT $L41860
$L41859:
	mov	DWORD PTR -8+[ebp], 0
$L41860:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::Classify
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::BloodColor, COMDAT

; 132  : 	virtual int	 BloodColor( void ) { return m_bloodColor; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+2328]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::BloodColor
_TEXT	ENDS
;	COMDAT ?Stop@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Stop@CBaseMonster@@UAEXXZ PROC NEAR			; CBaseMonster::Stop, COMDAT

; 176  : 		virtual void Stop( void ) { m_IdealActivity = GetStoppedActivity(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2072], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@CBaseMonster@@UAEXXZ ENDP				; CBaseMonster::Stop
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T41867 = -16
$T41868 = -28
$T41869 = -40
$T41870 = -52
$T41871 = -64
?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseMonster::BodyTarget, COMDAT

; 318  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ) * 0.75 + EyePosition() * 0.25; };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1048576000				; 3e800000H
	lea	eax, DWORD PTR $T41870[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41869[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+308]
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T41871[ebp]
	push	ecx
	push	1061158912				; 3f400000H
	lea	edx, DWORD PTR $T41868[ebp]
	push	edx
	lea	eax, DWORD PTR $T41867[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseMonster::BodyTarget
_TEXT	ENDS
PUBLIC	??0CBaseAnimating@@QAE@XZ			; CBaseAnimating::CBaseAnimating
PUBLIC	??1CBaseAnimating@@QAE@XZ			; CBaseAnimating::~CBaseAnimating
PUBLIC	??_7CBaseToggle@@6B@				; CBaseToggle::`vftable'
EXTRN	?GetDataDescMap@CBaseToggle@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseToggle::GetDataDescMap
;	COMDAT ??_7CBaseToggle@@6B@
CONST	SEGMENT
??_7CBaseToggle@@6B@ DD FLAT:?GetDataDescMap@CBaseToggle@@UAEPAUdatamap_s@@XZ ; CBaseToggle::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseToggle@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseToggle@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseToggle@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseToggle@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseToggle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseToggle@@QAE@XZ PROC NEAR			; CBaseToggle::CBaseToggle, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseToggle@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseAnimating@@QAE@XZ		; CBaseAnimating::CBaseAnimating
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1864				; 00000748H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1912				; 00000778H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1924				; 00000784H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1936				; 00000790H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseToggle@@6B@ ; CBaseToggle::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseToggle@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseAnimating@@QAE@XZ		; CBaseAnimating::~CBaseAnimating
	ret	0
__ehhandler$??0CBaseToggle@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseToggle@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseToggle@@QAE@XZ ENDP				; CBaseToggle::CBaseToggle
;	COMDAT ??1CBaseToggle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseToggle@@QAE@XZ PROC NEAR			; CBaseToggle::~CBaseToggle, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseAnimating@@QAE@XZ		; CBaseAnimating::~CBaseAnimating
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseToggle@@QAE@XZ ENDP				; CBaseToggle::~CBaseToggle
_TEXT	ENDS
;	COMDAT ??0WayPoint_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0WayPoint_t@@QAE@XZ PROC NEAR				; WayPoint_t::WayPoint_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0WayPoint_t@@QAE@XZ ENDP				; WayPoint_t::WayPoint_t
_TEXT	ENDS
PUBLIC	??_7CBaseAnimating@@6B@				; CBaseAnimating::`vftable'
EXTRN	?GetDataDescMap@CBaseAnimating@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseAnimating::GetDataDescMap
;	COMDAT ??_7CBaseAnimating@@6B@
CONST	SEGMENT
??_7CBaseAnimating@@6B@ DD FLAT:?GetDataDescMap@CBaseAnimating@@UAEPAUdatamap_s@@XZ ; CBaseAnimating::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
CONST	ENDS
;	COMDAT ??0CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseAnimating@@QAE@XZ PROC NEAR			; CBaseAnimating::CBaseAnimating, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseAnimating@@6B@ ; CBaseAnimating::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseAnimating@@QAE@XZ ENDP				; CBaseAnimating::CBaseAnimating
_TEXT	ENDS
;	COMDAT ??1CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseAnimating@@QAE@XZ PROC NEAR			; CBaseAnimating::~CBaseAnimating, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseDelay@@QAE@XZ			; CBaseDelay::~CBaseDelay
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseAnimating@@QAE@XZ ENDP				; CBaseAnimating::~CBaseAnimating
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
PUBLIC	??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
PUBLIC	?CopyConstruct@@YAXPAPADABQAD@Z			; CopyConstruct
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ DB '('
	DB	'elem == Count()) || IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L41898
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L41898
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L41898
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41898:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L41899
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41899
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41899:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAPADABQAD@Z		; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC NEAR		; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L41904
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41904:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L39742

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L39742:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PADH@@QAE@XZ PROC NEAR			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC NEAR		; CUtlMemory<char *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41909
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41909:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41910
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41910:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC NEAR		; CUtlMemory<char *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41913
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41913:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC NEAR	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41920
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L41920
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41921
$L41920:
	mov	DWORD PTR -8+[ebp], 0
$L41921:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAPAD@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L39775:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L39776

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAD@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L39775
$L39776:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ		; CUtlMemory<char *,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@PADH@@QAEXH@Z		; CUtlMemory<char *,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L39785

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@PADH@@QAEXH@Z	; CUtlMemory<char *,int>::Grow
$L39785:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
_TEXT	ENDS
PUBLIC	??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
EXTRN	_memmove:NEAR
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ DB 'I'
	DB	'sValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 )', 00H ; `string'
CONST	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41928
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L41928
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L41928
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41928:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L39794
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L39794

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L39794:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
_src$ = 12
$T41931 = -4
?CopyConstruct@@YAXPAPADABQAD@Z PROC NEAR		; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T41931[ebp], eax
	cmp	DWORD PTR $T41931[ebp], 0
	je	SHORT $L41932
	mov	ecx, DWORD PTR $T41931[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T41931[ebp]
	mov	DWORD PTR -8+[ebp], ecx
	jmp	SHORT $L41933
$L41932:
	mov	DWORD PTR -8+[ebp], 0
$L41933:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyConstruct@@YAXPAPADABQAD@Z ENDP			; CopyConstruct
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC NEAR	; CUtlMemory<char *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41938
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L41938
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41939
$L41938:
	mov	DWORD PTR -8+[ebp], 0
$L41939:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC NEAR		; CUtlMemory<char *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39808

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L39809

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L39809:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L39808:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR	; CUtlMemory<char *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ PROC NEAR	; CUtlMemory<char *,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ ENDP		; CUtlMemory<char *,int>::NumAllocated
_TEXT	ENDS
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@PADH@@QAEXH@Z PROC NEAR		; CUtlMemory<char *,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L41948
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41948:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L39823

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L41949
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41949:

; 567  : 		return;

	jmp	$L39820
$L39823:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	4
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L39843

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L39835
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L39835

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L39843
$L39835:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L39839

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L41950
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41950:

; 589  : 				return;

	jmp	$L39820
$L39839:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L39843

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L39839
$L39843:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L39846

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L41951
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41951:

; 603  : 	else

	jmp	SHORT $L41952
$L39846:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L41952
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41952:
$L39820:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@PADH@@QAEXH@Z ENDP			; CUtlMemory<char *,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L28985

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L28990
$L28985:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L28987

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L28987:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L28990

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L28987
$L28990:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR ; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
EXTRN	_memset:NEAR
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAD@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAD@Z ENDP				; Destruct
_TEXT	ENDS
;	COMDAT ??_9@$BBFM@AE
_TEXT	SEGMENT
??_9@$BBFM@AE PROC NEAR					; `vcall', COMDAT
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+348]
??_9@$BBFM@AE ENDP					; `vcall'
_TEXT	ENDS
;	COMDAT ??_9@$BBGA@AE
_TEXT	SEGMENT
??_9@$BBGA@AE PROC NEAR					; `vcall', COMDAT
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+352]
??_9@$BBGA@AE ENDP					; `vcall'
_TEXT	ENDS
END
