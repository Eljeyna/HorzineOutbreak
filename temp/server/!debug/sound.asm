	TITLE	Z:\XashXTSRC\server\sound.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGEN@AnimateUntilDead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09OKKL@Half?9Life?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@IFMB@ambient_generic?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@NFEK@CAmbientGeneric?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLK@m_flAttenuation?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BMHH@m_fActive?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LMNA@m_fLooping?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MGLH@m_dpv?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NOJP@RampThink?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09CHGA@ToggleUse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@BCGO@StartDynamicSound?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@HCGM@EMPTY?5AMBIENT?5AT?3?5?$CFf?0?5?$CFf?0?5?$CFf?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HEJM@sprites?1null?4spr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FAOG@preset?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LHHB@pitch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KOLG@pitchstart?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06HKPC@spinup?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EIAJ@spindown?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FJGI@volstart?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06DKEJ@fadein?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07FOED@fadeout?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07IMGJ@lfotype?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07LIPA@lforate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@HCFK@lfomodpitch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09KJLL@lfomodvol?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07HOJA@cspinup?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DMEH@env_sound?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HBNP@CEnvSound?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IPB@m_flRadius?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06JGHA@radius?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@MOCP@m_flRoomtype?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08JLPP@roomtype?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@JHMK@trigger_sound?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PIHH@?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@GEEN@No?5such?5sentence?5group?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@HEJL@sound?1sentences?4txt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@DGLM@Too?5many?5sentences?5in?5sentences?4@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@NHFB@Sentence?5?$CFs?5longer?5than?5?$CFd?5lette@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@LDAL@Too?5many?5sentence?5groups?5in?5sent@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@HOCG@Unable?5to?5find?5?$CFs?5in?5sentences?4t@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@CIEP@suitvolume?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@BFKO@sound?1materials?4txt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@DAFA@player?1pl_step1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@NADP@player?1pl_step2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@LBED@player?1pl_metal1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@FBCM@player?1pl_metal2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@IGBB@player?1pl_dirt1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGHO@player?1pl_dirt2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGFL@player?1pl_dirt3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@KCPJ@player?1pl_duct1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BEOK@player?1pl_grate1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@DEFK@player?1pl_grate4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@BHLL@player?1pl_tile1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@FHPB@player?1pl_tile3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@PHNE@player?1pl_tile2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@DHAL@player?1pl_tile4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@DKOO@player?1pl_slosh1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@HKKE@player?1pl_slosh3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@NKIB@player?1pl_slosh2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BKFO@player?1pl_slosh4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@MAKG@debris?1wood1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@CAMJ@debris?1wood2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@IAOM@debris?1wood3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@JOHE@debris?1glass1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@HOBL@debris?1glass2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@NODO@debris?1glass3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@JLBM@weapons?1bullet_hit1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@HLHD@weapons?1bullet_hit2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@KFIJ@func_breakable?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNEE@buttons?1spark5?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@INCL@buttons?1spark6?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07EJE@speaker?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FPG@CSpeaker?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IGAG@m_preset?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@ILNE@SpeakerThink?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@LKBA@SPEAKER?5with?5no?5Level?1Sentence?$CB?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FGKA@C1A0_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EAAK@C1A1_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HLPF@C1A2_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05GNFP@C1A3_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MAK@C1A4_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05CPPM@C2A1_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05BEAD@C2A2_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05CKJ@C2A3_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05GDPM@C2A4_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HFFG@C2A5_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KKO@C3A1_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DBFB@C3A2_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@CCLF@Level?5Design?5Error?$CB?6SPEAKER?5has?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MEEO@ambient_music?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@NPLG@m_iszIntroTrack?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@LDKH@m_iszMainTrack?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08KCA@fadetime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@DEKJ@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BLOK@music?5?$CC?$CFs?$CC?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06BJGF@music?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyToArray@Vector@@QBEXPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMessageA@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPointEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseToggle@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseToggle@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stop@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScheduleChange@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanPlaySentence@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetYawSpeed@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CoverRadius@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckAmmo@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HearingSensitivity@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrescheduleThink@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AlertSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IdleSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PainSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopFollowing@CBaseMonster@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBasePlayer@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShouldFadeOnDeath@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CAmbientGeneric@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E38
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CAmbientGeneric@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CAmbientGeneric@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E41
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E42
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E45
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CAmbientGeneric@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CAmbientGeneric@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartDynamicSound@CAmbientGeneric@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RampThink@CAmbientGeneric@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitModulationParms@CAmbientGeneric@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ToggleUse@CAmbientGeneric@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CAmbientGeneric@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CEnvSound@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CEnvSound@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E50
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E51
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E54
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CEnvSound@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FEnvSoundInRange@@YAHPAVCBaseEntity@@0PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CEnvSound@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CEnvSound@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CTriggerSound@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E56
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CTriggerSound@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CTriggerSound@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CTriggerSound@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?USENTENCEG_InitLRU@@YAXPAEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?USENTENCEG_PickSequential@@YAHHPADHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?USENTENCEG_Pick@@YAHHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SENTENCEG_GetIndex@@YAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SENTENCEG_PlayRndI@@YAHPAUedict_s@@HMMHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SENTENCEG_PlaySequentialSz@@YAHPAUedict_s@@PBDMMHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SENTENCEG_Stop@@YAXPAUedict_s@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SENTENCEG_Init@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SENTENCEG_Lookup@@YAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND_SUIT@@YAXPAUedict_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_GROUPID_SUIT@@YAXPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_GROUPNAME_SUIT@@YAXPAUedict_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayLockSounds@@YAXPAUentvars_s@@PAUlocksounds@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?memfgets@@YAPADPAEHAAHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TEXTURETYPE_Init@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TEXTURETYPE_Find@@YADPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CSpeaker@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E59
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E60
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CSpeaker@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CSpeaker@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E62
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E63
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E66
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CSpeaker@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CSpeaker@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpeakerThink@CSpeaker@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ToggleUse@CSpeaker@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CSpeaker@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CAmbientMusic@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E67
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E68
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CAmbientMusic@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CAmbientMusic@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMessage@CAmbientMusic@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayStream@CAmbientMusic@@QAEXPAVCBasePlayer@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CAmbientMusic@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CAmbientMusic@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCAmbientGeneric@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCAmbientGeneric@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCAmbientGeneric@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCAmbientGeneric@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCEnvSound@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCEnvSound@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCEnvSound@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCEnvSound@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCTriggerSound@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCTriggerSound@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCTriggerSound@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCTriggerSound@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCSpeaker@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCSpeaker@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCSpeaker@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCSpeaker@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCAmbientMusic@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCAmbientMusic@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCAmbientMusic@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCAmbientMusic@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCPointEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CEnvSound@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBasePlayer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAmbientGeneric@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTriggerSound@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSpeaker@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAmbientMusic@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPointEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPointEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseMonster@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseMonster@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseToggle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseToggle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WayPoint_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CEntityFactory@VCTriggerSound@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CTriggerSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBasePlayer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCAmbientGeneric@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCAmbientMusic@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseAnimating@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCSpeaker@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CAmbientMusic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CEnvSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSpeaker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseMonster@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseToggle@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCEnvSound@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CAmbientGeneric@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CPointEntity@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??_C@_0BA@NFEK@CAmbientGeneric?$AA@		; `string'
PUBLIC	?g_DataMapHolder@CAmbientGeneric_DataDescInit@@3PAUdatamap_s@@A ; CAmbientGeneric_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_08FPG@CSpeaker?$AA@			; `string'
PUBLIC	??_C@_0BA@PLK@m_flAttenuation?$AA@		; `string'
PUBLIC	??_C@_09BMHH@m_fActive?$AA@			; `string'
PUBLIC	??_C@_0L@LMNA@m_fLooping?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CSpeaker_DataDescInit@@3PAUdatamap_s@@A ; CSpeaker_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_05MGLH@m_dpv?$AA@				; `string'
PUBLIC	??_C@_08IGAG@m_preset?$AA@			; `string'
PUBLIC	??_C@_06FAOG@preset?$AA@			; `string'
PUBLIC	?gszallsentencenames@@3PAY0CA@DA		; gszallsentencenames
PUBLIC	?gcallsentences@@3HA				; gcallsentences
PUBLIC	?m_DataMap@CEnvSound@@2Udatamap_s@@A		; CEnvSound::m_DataMap
PUBLIC	??_C@_09HBNP@CEnvSound?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CEnvSound_DataDescInit@@3PAUdatamap_s@@A ; CEnvSound_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0L@IPB@m_flRadius?$AA@			; `string'
PUBLIC	??_C@_06JGHA@radius?$AA@			; `string'
PUBLIC	??_C@_0N@MOCP@m_flRoomtype?$AA@			; `string'
PUBLIC	??_C@_08JLPP@roomtype?$AA@			; `string'
PUBLIC	?rgsentenceg@@3PAUsentenceg@@A			; rgsentenceg
PUBLIC	?fSentencesInit@@3HA				; fSentencesInit
PUBLIC	?fTextureTypeInit@@3HA				; fTextureTypeInit
PUBLIC	?gcTextures@@3HA				; gcTextures
PUBLIC	?grgszTextureName@@3PAY0N@DA			; grgszTextureName
PUBLIC	?grgchTextureType@@3PADA			; grgchTextureType
PUBLIC	?rgdpvpreset@@3PAUdynpitchvol@@A		; rgdpvpreset
PUBLIC	?m_DataMap@CAmbientGeneric@@2Udatamap_s@@A	; CAmbientGeneric::m_DataMap
PUBLIC	?m_DataMap@CSpeaker@@2Udatamap_s@@A		; CSpeaker::m_DataMap
_BSS	SEGMENT
?g_DataMapHolder@CAmbientGeneric_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CAmbientGeneric_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CSpeaker_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CSpeaker_DataDescInit::g_DataMapHolder
?gszallsentencenames@@3PAY0CA@DA DB 020000H DUP (?)	; gszallsentencenames
?gcallsentences@@3HA DD 01H DUP (?)			; gcallsentences
?g_DataMapHolder@CEnvSound_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CEnvSound_DataDescInit::g_DataMapHolder
?rgsentenceg@@3PAUsentenceg@@A DB 064000H DUP (?)	; rgsentenceg
?fSentencesInit@@3HA DD 01H DUP (?)			; fSentencesInit
?fTextureTypeInit@@3HA DD 01H DUP (?)			; fTextureTypeInit
?gcTextures@@3HA DD 01H DUP (?)				; gcTextures
?grgszTextureName@@3PAY0N@DA DB 01a00H DUP (?)		; grgszTextureName
?grgchTextureType@@3PADA DB 0200H DUP (?)		; grgchTextureType
_BSS	ENDS
_DATA	SEGMENT
?rgdpvpreset@@3PAUdynpitchvol@@A DD 01H			; rgdpvpreset
	DD	0ffH
	DD	04bH
	DD	05fH
	DD	05fH
	DD	0aH
	DD	01H
	DD	032H
	DD	05fH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	02H
	DD	0ffH
	DD	055H
	DD	046H
	DD	058H
	DD	0aH
	DD	01H
	DD	014H
	DD	058H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	03H
	DD	0ffH
	DD	064H
	DD	032H
	DD	04bH
	DD	0aH
	DD	01H
	DD	0aH
	DD	04bH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	04H
	DD	064H
	DD	064H
	DD	00H
	DD	00H
	DD	0aH
	DD	01H
	DD	05aH
	DD	05aH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	05H
	DD	064H
	DD	064H
	DD	00H
	DD	00H
	DD	0aH
	DD	01H
	DD	050H
	DD	050H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	06H
	DD	064H
	DD	064H
	DD	00H
	DD	00H
	DD	0aH
	DD	01H
	DD	032H
	DD	046H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	07H
	DD	064H
	DD	064H
	DD	00H
	DD	00H
	DD	05H
	DD	01H
	DD	028H
	DD	032H
	DD	01H
	DD	032H
	DD	00H
	DD	0aH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	08H
	DD	064H
	DD	064H
	DD	00H
	DD	00H
	DD	05H
	DD	01H
	DD	028H
	DD	032H
	DD	01H
	DD	096H
	DD	00H
	DD	0aH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	09H
	DD	064H
	DD	064H
	DD	00H
	DD	00H
	DD	05H
	DD	01H
	DD	028H
	DD	032H
	DD	01H
	DD	02eeH
	DD	00H
	DD	0aH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	0aH
	DD	080H
	DD	064H
	DD	032H
	DD	04bH
	DD	0aH
	DD	01H
	DD	01eH
	DD	028H
	DD	02H
	DD	08H
	DD	014H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	0bH
	DD	080H
	DD	064H
	DD	032H
	DD	04bH
	DD	0aH
	DD	01H
	DD	01eH
	DD	028H
	DD	02H
	DD	019H
	DD	014H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	0cH
	DD	080H
	DD	064H
	DD	032H
	DD	04bH
	DD	0aH
	DD	01H
	DD	01eH
	DD	028H
	DD	02H
	DD	046H
	DD	014H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	0dH
	DD	032H
	DD	032H
	DD	00H
	DD	00H
	DD	0aH
	DD	01H
	DD	014H
	DD	032H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	0eH
	DD	046H
	DD	046H
	DD	00H
	DD	00H
	DD	0aH
	DD	01H
	DD	014H
	DD	032H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	0fH
	DD	05aH
	DD	05aH
	DD	00H
	DD	00H
	DD	0aH
	DD	01H
	DD	014H
	DD	032H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	010H
	DD	078H
	DD	078H
	DD	00H
	DD	00H
	DD	0aH
	DD	01H
	DD	014H
	DD	032H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	011H
	DD	0b4H
	DD	0b4H
	DD	00H
	DD	00H
	DD	0aH
	DD	01H
	DD	014H
	DD	032H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	012H
	DD	0ffH
	DD	0ffH
	DD	00H
	DD	00H
	DD	0aH
	DD	01H
	DD	014H
	DD	032H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	013H
	DD	0c8H
	DD	04bH
	DD	05aH
	DD	05aH
	DD	0aH
	DD	01H
	DD	032H
	DD	05aH
	DD	02H
	DD	064H
	DD	014H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	014H
	DD	0ffH
	DD	04bH
	DD	061H
	DD	05aH
	DD	0aH
	DD	01H
	DD	032H
	DD	05aH
	DD	01H
	DD	028H
	DD	032H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	015H
	DD	064H
	DD	064H
	DD	00H
	DD	00H
	DD	0aH
	DD	01H
	DD	01eH
	DD	032H
	DD	03H
	DD	0fH
	DD	014H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	016H
	DD	0a0H
	DD	0a0H
	DD	00H
	DD	00H
	DD	0aH
	DD	01H
	DD	032H
	DD	032H
	DD	03H
	DD	01f4H
	DD	019H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	017H
	DD	0ffH
	DD	04bH
	DD	058H
	DD	00H
	DD	0aH
	DD	01H
	DD	028H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	018H
	DD	0c8H
	DD	014H
	DD	05fH
	DD	046H
	DD	0aH
	DD	01H
	DD	046H
	DD	046H
	DD	03H
	DD	014H
	DD	032H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	019H
	DD	0b4H
	DD	064H
	DD	032H
	DD	03cH
	DD	0aH
	DD	01H
	DD	028H
	DD	03cH
	DD	02H
	DD	05aH
	DD	064H
	DD	064H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	01aH
	DD	03cH
	DD	03cH
	DD	00H
	DD	00H
	DD	0aH
	DD	01H
	DD	028H
	DD	046H
	DD	03H
	DD	050H
	DD	014H
	DD	032H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DD	01bH
	DD	080H
	DD	05aH
	DD	0aH
	DD	0aH
	DD	0aH
	DD	01H
	DD	014H
	DD	028H
	DD	01H
	DD	05H
	DD	0aH
	DD	014H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_DATA	ENDS
CRT$XCU	SEGMENT
_$S40	DD	FLAT:_$E39
CRT$XCU	ENDS
_DATA	SEGMENT
	ORG $+4
?m_DataMap@CAmbientGeneric@@2Udatamap_s@@A DD 00H	; CAmbientGeneric::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0BA@NFEK@CAmbientGeneric?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S43	DD	FLAT:_$E42
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BA@PLK@m_flAttenuation?$AA@
	DD	06e4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_09BMHH@m_fActive?$AA@
	DD	074cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_0L@LMNA@m_fLooping?$AA@
	DD	0750H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0eH
	DD	FLAT:??_C@_05MGLH@m_dpv?$AA@
	DD	06e8H
	DW	064H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+68
_DATA	ENDS
CRT$XCU	SEGMENT
_$S49	DD	FLAT:_$E48
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CEnvSound@@2Udatamap_s@@A DD 00H		; CEnvSound::m_DataMap
	DD	00H
	DD	FLAT:??_C@_09HBNP@CEnvSound?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S52	DD	FLAT:_$E51
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@IPB@m_flRadius?$AA@
	DD	06e4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06JGHA@radius?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0N@MOCP@m_flRoomtype?$AA@
	DD	06e8H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08JLPP@roomtype?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S57	DD	FLAT:_$E56
_$S61	DD	FLAT:_$E60
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CSpeaker@@2Udatamap_s@@A DD 00H		; CSpeaker::m_DataMap
	DD	00H
	DD	FLAT:??_C@_08FPG@CSpeaker?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S64	DD	FLAT:_$E63
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08IGAG@m_preset?$AA@
	DD	06e4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06FAOG@preset?$AA@
	DD	00H
	DD	012H
	ORG $+44
_DATA	ENDS
CRT$XCU	SEGMENT
_$S69	DD	FLAT:_$E68
CRT$XCU	ENDS
;	COMDAT ??_C@_0BA@NFEK@CAmbientGeneric?$AA@
CONST	SEGMENT
??_C@_0BA@NFEK@CAmbientGeneric?$AA@ DB 'CAmbientGeneric', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLK@m_flAttenuation?$AA@
CONST	SEGMENT
??_C@_0BA@PLK@m_flAttenuation?$AA@ DB 'm_flAttenuation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BMHH@m_fActive?$AA@
CONST	SEGMENT
??_C@_09BMHH@m_fActive?$AA@ DB 'm_fActive', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LMNA@m_fLooping?$AA@
CONST	SEGMENT
??_C@_0L@LMNA@m_fLooping?$AA@ DB 'm_fLooping', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGLH@m_dpv?$AA@
CONST	SEGMENT
??_C@_05MGLH@m_dpv?$AA@ DB 'm_dpv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FAOG@preset?$AA@
CONST	SEGMENT
??_C@_06FAOG@preset?$AA@ DB 'preset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HBNP@CEnvSound?$AA@
CONST	SEGMENT
??_C@_09HBNP@CEnvSound?$AA@ DB 'CEnvSound', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IPB@m_flRadius?$AA@
CONST	SEGMENT
??_C@_0L@IPB@m_flRadius?$AA@ DB 'm_flRadius', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JGHA@radius?$AA@
CONST	SEGMENT
??_C@_06JGHA@radius?$AA@ DB 'radius', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOCP@m_flRoomtype?$AA@
CONST	SEGMENT
??_C@_0N@MOCP@m_flRoomtype?$AA@ DB 'm_flRoomtype', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JLPP@roomtype?$AA@
CONST	SEGMENT
??_C@_08JLPP@roomtype?$AA@ DB 'roomtype', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FPG@CSpeaker?$AA@
CONST	SEGMENT
??_C@_08FPG@CSpeaker?$AA@ DB 'CSpeaker', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IGAG@m_preset?$AA@
CONST	SEGMENT
??_C@_08IGAG@m_preset?$AA@ DB 'm_preset', 00H		; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT
_$E39	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E38
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E39	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCAmbientGeneric@@@@QAE@PBD@Z ; CEntityFactory<CAmbientGeneric>::CEntityFactory<CAmbientGeneric>
PUBLIC	??_C@_0BA@IFMB@ambient_generic?$AA@		; `string'
_BSS	SEGMENT
_ambient_generic DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BA@IFMB@ambient_generic?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0BA@IFMB@ambient_generic?$AA@ DB 'ambient_generic', 00H ; `string'
CONST	ENDS
;	COMDAT _$E38
_TEXT	SEGMENT
_$E38	PROC NEAR					; COMDAT

; 141  : LINK_ENTITY_TO_CLASS( ambient_generic, CAmbientGeneric );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BA@IFMB@ambient_generic?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_ambient_generic
	call	??0?$CEntityFactory@VCAmbientGeneric@@@@QAE@PBD@Z ; CEntityFactory<CAmbientGeneric>::CEntityFactory<CAmbientGeneric>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E38	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CAmbientGeneric@@UAEPAUdatamap_s@@XZ ; CAmbientGeneric::GetDataDescMap
;	COMDAT ?GetDataDescMap@CAmbientGeneric@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CAmbientGeneric@@UAEPAUdatamap_s@@XZ PROC NEAR ; CAmbientGeneric::GetDataDescMap, COMDAT

; 143  : BEGIN_DATADESC( CAmbientGeneric )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CAmbientGeneric@@2Udatamap_s@@A ; CAmbientGeneric::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CAmbientGeneric@@UAEPAUdatamap_s@@XZ ENDP ; CAmbientGeneric::GetDataDescMap
_TEXT	ENDS
PUBLIC	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
PUBLIC	?GetBaseMap@CAmbientGeneric@@SAPAUdatamap_s@@XZ	; CAmbientGeneric::GetBaseMap
;	COMDAT ?GetBaseMap@CAmbientGeneric@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CAmbientGeneric@@SAPAUdatamap_s@@XZ PROC NEAR ; CAmbientGeneric::GetBaseMap, COMDAT

; 143  : BEGIN_DATADESC( CAmbientGeneric )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CAmbientGeneric@@SAPAUdatamap_s@@XZ ENDP	; CAmbientGeneric::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E42
_TEXT	SEGMENT
_$E42	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E41
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E42	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z ; DataMapInit
;	COMDAT _$E41
_TEXT	SEGMENT
_$E41	PROC NEAR					; COMDAT

; 143  : BEGIN_DATADESC( CAmbientGeneric )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CAmbientGeneric_DataDescInit@@3PAUdatamap_s@@A, eax ; CAmbientGeneric_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E41	ENDP
_TEXT	ENDS
PUBLIC	??_C@_09NOJP@RampThink?$AA@			; `string'
PUBLIC	??_C@_09CHGA@ToggleUse?$AA@			; `string'
PUBLIC	??_C@_0BC@BCGO@StartDynamicSound?$AA@		; `string'
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
PUBLIC	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
PUBLIC	?ToggleUse@CAmbientGeneric@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CAmbientGeneric::ToggleUse
PUBLIC	?RampThink@CAmbientGeneric@@QAEXXZ		; CAmbientGeneric::RampThink
PUBLIC	?StartDynamicSound@CAmbientGeneric@@QAEXXZ	; CAmbientGeneric::StartDynamicSound
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S44@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09NOJP@RampThink?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_09NOJP@RampThink?$AA@ DB 'RampThink', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CHGA@ToggleUse?$AA@
CONST	SEGMENT
??_C@_09CHGA@ToggleUse?$AA@ DB 'ToggleUse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BCGO@StartDynamicSound?$AA@
CONST	SEGMENT
??_C@_0BC@BCGO@StartDynamicSound?$AA@ DB 'StartDynamicSound', 00H ; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z PROC NEAR ; DataMapInit, COMDAT

; 143  : BEGIN_DATADESC( CAmbientGeneric )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S44@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L38959
	mov	cl, BYTE PTR _?$S44@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S44@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0BA@NFEK@CAmbientGeneric?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E45
	call	_atexit
	add	esp, 4
$L38959:
	call	?GetBaseMap@CAmbientGeneric@@SAPAUdatamap_s@@XZ ; CAmbientGeneric::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CAmbientGeneric@@2Udatamap_s@@A+12, eax

; 144  : 	DEFINE_FIELD( m_flAttenuation, FIELD_FLOAT ),
; 145  : 	DEFINE_FIELD( m_fActive, FIELD_BOOLEAN ),
; 146  : 	DEFINE_FIELD( m_fLooping, FIELD_BOOLEAN ),
; 147  : 
; 148  : 	// HACKHACK - This is not really in the spirit of the save/restore design, but save this
; 149  : 	// out as a binary data block.  If the dynpitchvol_t is changed, old saved games will NOT
; 150  : 	// load these correctly, so bump the save/restore version if you change the size of the struct
; 151  : 	// The right way to do this is to split the input parms (read in keyvalue) into members and re-init this
; 152  : 	// struct in Precache(), but it's unlikely that the struct will change, so it's not worth the time right now.
; 153  : 	DEFINE_ARRAY( m_dpv, FIELD_CHARACTER, sizeof(dynpitchvol_t) ),
; 154  : 	DEFINE_FUNCTION( RampThink ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S44@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L38976
	mov	al, BYTE PTR _?$S44@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S44@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_09NOJP@RampThink?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+124, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+128, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+132, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+134, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+136, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+140, OFFSET FLAT:?RampThink@CAmbientGeneric@@QAEXXZ ; CAmbientGeneric::RampThink

; 155  : 	DEFINE_FUNCTION( ToggleUse ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+144, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_09CHGA@ToggleUse?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+148, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+152, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+156, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+158, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+160, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+164, OFFSET FLAT:?ToggleUse@CAmbientGeneric@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CAmbientGeneric::ToggleUse

; 156  : 	DEFINE_FUNCTION( StartDynamicSound ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+168, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0BC@BCGO@StartDynamicSound?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+172, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+176, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+180, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+182, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+184, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+188, OFFSET FLAT:?StartDynamicSound@CAmbientGeneric@@QAEXXZ ; CAmbientGeneric::StartDynamicSound
$L38976:

; 157  : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L38986
	mov	DWORD PTR ?m_DataMap@CAmbientGeneric@@2Udatamap_s@@A+4, 7
	mov	DWORD PTR ?m_DataMap@CAmbientGeneric@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L38987
$L38986:
	mov	DWORD PTR ?m_DataMap@CAmbientGeneric@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CAmbientGeneric@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4PAUtypedescription_s@@A
$L38987:
	mov	eax, OFFSET FLAT:?m_DataMap@CAmbientGeneric@@2Udatamap_s@@A ; CAmbientGeneric::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z ENDP ; DataMapInit
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
EXTRN	_strlen:NEAR
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_pszBase$ = 8
_this$ = -4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC NEAR	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
PUBLIC	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
PUBLIC	??_C@_04NHIK@?$CFs?3?3?$AA@			; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_strcat:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
; File z:\xashxtsrc\common\datamap.h
CONST	SEGMENT
??_C@_04NHIK@?$CFs?3?3?$AA@ DB '%s::', 00H		; `string'
CONST	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT
$T41138 = -12
_pszIdentifier$ = 8
_this$ = -4
_pBuf$ = -8
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z PROC NEAR ; CDatadescGeneratedNameHolder::GenerateName, COMDAT

; 205  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		char *pBuf = new char[m_nLenBase + strlen(pszIdentifier) + 1];

	mov	eax, DWORD PTR _pszIdentifier$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax+1]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T41138[ebp], eax
	mov	ecx, DWORD PTR $T41138[ebp]
	mov	DWORD PTR _pBuf$[ebp], ecx

; 207  : 		sprintf( pBuf, "%s::", m_pszBase );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_04NHIK@?$CFs?3?3?$AA@	; `string'
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 208  : 		strcat( pBuf, pszIdentifier );

	mov	edx, DWORD PTR _pszIdentifier$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 209  : 		m_Names.AddToTail( pBuf );

	lea	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail

; 210  : 		return pBuf;

	mov	eax, DWORD PTR _pBuf$[ebp]

; 211  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ENDP ; CDatadescGeneratedNameHolder::GenerateName
_TEXT	ENDS
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E45
_TEXT	SEGMENT
_$E45	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCAmbientGeneric@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E45	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT xdata$x
; File z:\xashxtsrc\common\datamap.h
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
$T41143 = -24
__$EHRec$ = -12
_this$ = -16
_i$ = -20
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC NEAR	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L30214
$L30215:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L30214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L30216

; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T41143[ebp], edx
	mov	eax, DWORD PTR $T41143[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 		}

	jmp	SHORT $L30215
$L30216:

; 202  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	ret	0
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
PUBLIC	??_C@_0BO@HCGM@EMPTY?5AMBIENT?5AT?3?5?$CFf?0?5?$CFf?0?5?$CFf?6?$AA@ ; `string'
PUBLIC	??_C@_0BB@HEJM@sprites?1null?4spr?$AA@		; `string'
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	??_C@_0L@KHDH@SUB_Remove?$AA@			; `string'
PUBLIC	?FStringNull@@YAHH@Z				; FStringNull
PUBLIC	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
PUBLIC	?Spawn@CAmbientGeneric@@UAEXXZ			; CAmbientGeneric::Spawn
PUBLIC	?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ; CBaseEntity::UseSet
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
EXTRN	__fltused:NEAR
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	?SUB_Remove@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::SUB_Remove
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0L@KHDH@SUB_Remove?$AA@ DB 'SUB_Remove', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HCGM@EMPTY?5AMBIENT?5AT?3?5?$CFf?0?5?$CFf?0?5?$CFf?6?$AA@
CONST	SEGMENT
??_C@_0BO@HCGM@EMPTY?5AMBIENT?5AT?3?5?$CFf?0?5?$CFf?0?5?$CFf?6?$AA@ DB 'E'
	DB	'MPTY AMBIENT AT: %f, %f, %f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HEJM@sprites?1null?4spr?$AA@
CONST	SEGMENT
??_C@_0BB@HEJM@sprites?1null?4spr?$AA@ DB 'sprites/null.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ?Spawn@CAmbientGeneric@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_szSoundFile$ = -8
_vecOrigin$39009 = -20
?Spawn@CAmbientGeneric@@UAEXXZ PROC NEAR		; CAmbientGeneric::Spawn, COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 164  : /*
; 165  : 		-1 : "Default"
; 166  : 		0  : "Everywhere"
; 167  : 		200 : "Small Radius"
; 168  : 		125 : "Medium Radius"
; 169  : 		80  : "Large Radius"
; 170  : */
; 171  : 
; 172  : 	if ( FBitSet ( pev->spawnflags, AMBIENT_SOUND_EVERYWHERE) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1
	test	edx, edx
	je	SHORT $L38993

; 174  : 		m_flAttenuation = ATTN_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1764], 0

; 176  : 	else if ( FBitSet ( pev->spawnflags, AMBIENT_SOUND_SMALLRADIUS) )

	jmp	SHORT $L39003
$L38993:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 2
	test	eax, eax
	je	SHORT $L38995

; 178  : 		m_flAttenuation = ATTN_IDLE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1764], 1073741824	; 40000000H

; 180  : 	else if ( FBitSet ( pev->spawnflags, AMBIENT_SOUND_MEDIUMRADIUS) )

	jmp	SHORT $L39003
$L38995:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 4
	test	ecx, ecx
	je	SHORT $L38998

; 182  : 		m_flAttenuation = ATTN_STATIC;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1764], 1067450368	; 3fa00000H

; 184  : 	else if ( FBitSet ( pev->spawnflags, AMBIENT_SOUND_LARGERADIUS) )

	jmp	SHORT $L39003
$L38998:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 8
	test	edx, edx
	je	SHORT $L39001

; 186  : 		m_flAttenuation = ATTN_NORM;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1764], 1061997773	; 3f4ccccdH

; 188  : 	else 

	jmp	SHORT $L39003
$L39001:

; 190  : 		// if the designer didn't set a sound attenuation, default to one.
; 191  : 		m_flAttenuation = ATTN_STATIC;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1764], 1067450368	; 3fa00000H
$L39003:

; 193  : 	
; 194  : 	char* szSoundFile = (char*) STRING(pev->message);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+468]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _szSoundFile$[ebp], eax

; 195  : 
; 196  : 	if ( FStringNull( pev->message ) || strlen( szSoundFile ) < 1 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+468]
	push	ecx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39008
	mov	edx, DWORD PTR _szSoundFile$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 1
	jae	SHORT $L39007
$L39008:

; 198  : 		Vector vecOrigin = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecOrigin$39009[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 199  : 		ALERT( at_error, "EMPTY AMBIENT AT: %f, %f, %f\n", vecOrigin.x, vecOrigin.y, vecOrigin.z );

	fld	DWORD PTR _vecOrigin$39009[ebp+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _vecOrigin$39009[ebp+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _vecOrigin$39009[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BO@HCGM@EMPTY?5AMBIENT?5AT?3?5?$CFf?0?5?$CFf?0?5?$CFf?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 32					; 00000020H

; 200  : 		SetThink( SUB_Remove );

	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 201  : 		SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 202  : 		return;

	jmp	$L38992
$L39007:

; 204  : 
; 205  : 	pev->solid = SOLID_NOT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 0

; 206  : 	pev->movetype = MOVETYPE_NONE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 0

; 207  : 
; 208  : 	// if we have a parent...
; 209  : 	if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39013

; 211  : 		// set the model to send entity to the client
; 212  : 		PRECACHE_MODEL( "sprites/null.spr" );

	push	OFFSET FLAT:??_C@_0BB@HEJM@sprites?1null?4spr?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4

; 213  : 		SET_MODEL( edict(), "sprites/null.spr" );

	push	OFFSET FLAT:??_C@_0BB@HEJM@sprites?1null?4spr?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8
$L39013:

; 215  : 
; 216  : 	// Set up think function for dynamic modification 
; 217  : 	// of ambient sound's pitch or volume. Don't
; 218  : 	// start thinking yet.
; 219  : 
; 220  : 	SetThink( RampThink );

	push	OFFSET FLAT:??_C@_09NOJP@RampThink?$AA@	; `string'
	push	OFFSET FLAT:?RampThink@CAmbientGeneric@@QAEXXZ ; CAmbientGeneric::RampThink
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 221  : 	pev->nextthink = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+260], 0

; 222  : 
; 223  : 	// allow on/off switching via 'use' function.
; 224  : 	SetUse( ToggleUse );

	push	OFFSET FLAT:??_C@_09CHGA@ToggleUse?$AA@	; `string'
	push	OFFSET FLAT:?ToggleUse@CAmbientGeneric@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CAmbientGeneric::ToggleUse
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ; CBaseEntity::UseSet

; 225  : 
; 226  : 	m_fSpawning = TRUE;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1876], 1

; 227  : 	m_fActive = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1868], 0

; 228  : 
; 229  : 	if ( FBitSet ( pev->spawnflags, AMBIENT_SOUND_NOT_LOOPING ) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 32					; 00000020H
	test	ecx, ecx
	je	SHORT $L39022

; 230  : 		m_fLooping = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1872], 0

; 231  : 	else

	jmp	SHORT $L39023
$L39022:

; 232  : 		m_fLooping = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1872], 1
$L39023:

; 233  : 
; 234  : 	Precache( );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]
$L38992:

; 235  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CAmbientGeneric@@UAEXXZ ENDP			; CAmbientGeneric::Spawn
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT
_iString$ = 8
?FStringNull@@YAHH@Z PROC NEAR				; FStringNull, COMDAT

; 201  : inline BOOL FStringNull(int iString)			{ return iString == iStringNull; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _iString$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStringNull@@YAHH@Z ENDP				; FStringNull
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
PUBLIC	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z	; CBaseEntity::FunctionCheck
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::ThinkSet, COMDAT

; 560  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 		m_pfnThink = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1744], ecx

; 562  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnThink)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1744]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 563  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 564  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP	; CBaseEntity::ThinkSet
_TEXT	ENDS
PUBLIC	??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:NEAR ; UTIL_FunctionToName
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ DB 'F'
	DB	'UNCTION NOT IN TABLE!: %s:%s (%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT
_this$ = -4
_pFunction$ = 8
_name$ = 12
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z PROC NEAR	; CBaseEntity::FunctionCheck, COMDAT

; 554  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 		if (pFunction && !UTIL_FunctionToName( GetDataDescMap(), pFunction ) )

	cmp	DWORD PTR _pFunction$[ebp], 0
	je	SHORT $L35044
	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	test	eax, eax
	jne	SHORT $L35044

; 556  : 			ALERT( at_warning, "FUNCTION NOT IN TABLE!: %s:%s (%08lx)\n", GetClassname(), name, (unsigned long)pFunction );

	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L35044:

; 557  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ENDP		; CBaseEntity::FunctionCheck
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
;	COMDAT ?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z PROC NEAR ; CBaseEntity::UseSet, COMDAT

; 574  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 575  : 		m_pfnUse = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1752], ecx

; 576  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnUse)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1752]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 577  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 578  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ENDP ; CBaseEntity::UseSet
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	__real@8@3ff8a3d70a3d70a3d800
PUBLIC	?Precache@CAmbientGeneric@@UAEXXZ		; CAmbientGeneric::Precache
PUBLIC	?InitModulationParms@CAmbientGeneric@@QAEXXZ	; CAmbientGeneric::InitModulationParms
EXTRN	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z:NEAR ; UTIL_EmitAmbientSound
;	COMDAT __real@8@3ff8a3d70a3d70a3d800
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
__real@8@3ff8a3d70a3d70a3d800 DQ 03f847ae147ae147br ; 0.01
CONST	ENDS
;	COMDAT ?Precache@CAmbientGeneric@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_szSoundFile$ = -8
?Precache@CAmbientGeneric@@UAEXXZ PROC NEAR		; CAmbientGeneric::Precache, COMDAT

; 238  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 	char* szSoundFile = (char*) STRING(pev->message);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _szSoundFile$[ebp], eax

; 240  : 
; 241  : 	if ( !FStringNull( pev->message ) && strlen( szSoundFile ) > 1 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39031
	mov	eax, DWORD PTR _szSoundFile$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 1
	jbe	SHORT $L39031

; 243  : 		if (*szSoundFile != '!')

	mov	ecx, DWORD PTR _szSoundFile$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 33					; 00000021H
	je	SHORT $L39031

; 244  : 			PRECACHE_SOUND(szSoundFile);

	mov	eax, DWORD PTR _szSoundFile$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4
$L39031:

; 246  : 	// init all dynamic modulation parms
; 247  : 	InitModulationParms();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitModulationParms@CAmbientGeneric@@QAEXXZ ; CAmbientGeneric::InitModulationParms

; 248  : 
; 249  : 	if ( !FBitSet (pev->spawnflags, AMBIENT_SOUND_START_SILENT ) )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L39033

; 251  : 		// start the sound ASAP
; 252  : 		if (m_fLooping)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1872], 0
	je	SHORT $L39033

; 253  : 			m_fActive = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1868], 1
$L39033:

; 255  : 
; 256  : 	if( m_fActive )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1868], 0
	je	$L39034

; 258  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39035

; 260  : 			SetThink( StartDynamicSound ); 

	push	OFFSET FLAT:??_C@_0BC@BCGO@StartDynamicSound?$AA@ ; `string'
	push	OFFSET FLAT:?StartDynamicSound@CAmbientGeneric@@QAEXXZ ; CAmbientGeneric::StartDynamicSound
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 262  : 		else

	jmp	SHORT $L39038
$L39035:

; 264  : 			UTIL_EmitAmbientSound ( edict(), GetAbsOrigin(), szSoundFile, (m_dpv.vol * 0.01), m_flAttenuation, SND_SPAWNING, m_dpv.pitch );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1828]
	push	edx
	push	256					; 00000100H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1764]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx+1844]
	fmul	QWORD PTR __real@8@3ff8a3d70a3d70a3d800
	fst	DWORD PTR -12+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _szSoundFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ; UTIL_EmitAmbientSound
	add	esp, 28					; 0000001cH
$L39038:

; 266  : 		SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]
$L39034:

; 268  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CAmbientGeneric@@UAEXXZ ENDP			; CAmbientGeneric::Precache
_TEXT	ENDS
PUBLIC	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z	; EMIT_SOUND_DYN
;	COMDAT ?StartDynamicSound@CAmbientGeneric@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_szSoundFile$ = -8
?StartDynamicSound@CAmbientGeneric@@QAEXXZ PROC NEAR	; CAmbientGeneric::StartDynamicSound, COMDAT

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 272  : 	char* szSoundFile = (char*) STRING(pev->message);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _szSoundFile$[ebp], eax

; 273  : 
; 274  : 	if( m_fSpawning )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1876], 0
	je	SHORT $L39045

; 275  : 		EMIT_SOUND_DYN( edict(), CHAN_ITEM, szSoundFile,	(m_dpv.vol * 0.01), m_flAttenuation, SND_SPAWNING, m_dpv.pitch);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1828]
	push	edx
	push	256					; 00000100H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1764]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx+1844]
	fmul	QWORD PTR __real@8@3ff8a3d70a3d70a3d800
	fst	DWORD PTR -12+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _szSoundFile$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH
$L39045:

; 276  : 
; 277  : 	SetThink( RampThink );

	push	OFFSET FLAT:??_C@_09NOJP@RampThink?$AA@	; `string'
	push	OFFSET FLAT:?RampThink@CAmbientGeneric@@QAEXXZ ; CAmbientGeneric::RampThink
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 278  : 	SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 279  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartDynamicSound@CAmbientGeneric@@QAEXXZ ENDP		; CAmbientGeneric::StartDynamicSound
_TEXT	ENDS
PUBLIC	__real@8@3ffcccccccccccccd000
EXTRN	_abs:NEAR
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
;	COMDAT __real@8@3ffcccccccccccccd000
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
__real@8@3ffcccccccccccccd000 DQ 03fc999999999999ar ; 0.2
CONST	ENDS
;	COMDAT ?RampThink@CAmbientGeneric@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_szSoundFile$ = -8
_pitch$ = -12
_vol$ = -16
_flags$ = -20
_fChanged$ = -24
_prev$ = -28
_pos$39083 = -32
?RampThink@CAmbientGeneric@@QAEXXZ PROC NEAR		; CAmbientGeneric::RampThink, COMDAT

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 	char* szSoundFile = (char*) STRING(pev->message);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _szSoundFile$[ebp], eax

; 289  : 	int pitch = m_dpv.pitch; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1828]
	mov	DWORD PTR _pitch$[ebp], ecx

; 290  : 	int vol = m_dpv.vol;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1844]
	mov	DWORD PTR _vol$[ebp], eax

; 291  : 	int flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 292  : 	int fChanged = 0;		// FALSE if pitch and vol remain unchanged this round

	mov	DWORD PTR _fChanged$[ebp], 0

; 293  : 	int	prev;
; 294  : 
; 295  : 	if (!m_dpv.spinup && !m_dpv.spindown && !m_dpv.fadein && !m_dpv.fadeout && !m_dpv.lfotype)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1780], 0
	jne	SHORT $L39059
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1784], 0
	jne	SHORT $L39059
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $L39059
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1800], 0
	jne	SHORT $L39059
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1804], 0
	jne	SHORT $L39059

; 296  : 		return;						// no ramps or lfo, stop thinking

	jmp	$L39051
$L39059:

; 297  : 
; 298  : 	// ==============
; 299  : 	// pitch envelope
; 300  : 	// ==============
; 301  : 	if (m_dpv.spinup || m_dpv.spindown)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1780], 0
	jne	SHORT $L39061
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1784], 0
	je	$L39060
$L39061:

; 303  : 		prev = m_dpv.pitchfrac >> 8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1840]
	sar	eax, 8
	mov	DWORD PTR _prev$[ebp], eax

; 304  : 
; 305  : 		if (m_dpv.spinup > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1780], 0
	jle	SHORT $L39062

; 306  : 			m_dpv.pitchfrac += m_dpv.spinup;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1840]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+1780]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1840], eax

; 307  : 		else if (m_dpv.spindown > 0)

	jmp	SHORT $L39064
$L39062:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1784], 0
	jle	SHORT $L39064

; 308  : 			m_dpv.pitchfrac -= m_dpv.spindown;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+1840]
	sub	eax, DWORD PTR [edx+1784]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1840], eax
$L39064:

; 309  : 
; 310  : 		pitch = m_dpv.pitchfrac >> 8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1840]
	sar	eax, 8
	mov	DWORD PTR _pitch$[ebp], eax

; 311  : 		
; 312  : 		if (pitch > m_dpv.pitchrun)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pitch$[ebp]
	cmp	edx, DWORD PTR [ecx+1772]
	jle	SHORT $L39065

; 314  : 			pitch = m_dpv.pitchrun;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1772]
	mov	DWORD PTR _pitch$[ebp], ecx

; 315  : 			m_dpv.spinup = 0;				// done with ramp up

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1780], 0
$L39065:

; 317  : 
; 318  : 		if (pitch < m_dpv.pitchstart)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pitch$[ebp]
	cmp	ecx, DWORD PTR [eax+1776]
	jge	SHORT $L39066

; 320  : 			pitch = m_dpv.pitchstart;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1776]
	mov	DWORD PTR _pitch$[ebp], eax

; 321  : 			m_dpv.spindown = 0;				// done with ramp down

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1784], 0

; 322  : 
; 323  : 			if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39067

; 325  : 				EMIT_SOUND_DYN( edict(), CHAN_ITEM, szSoundFile,	0, 0, SND_STOP, 0 );

	push	0
	push	32					; 00000020H
	push	0
	push	0
	mov	edx, DWORD PTR _szSoundFile$[ebp]
	push	edx
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 327  : 			else

	jmp	SHORT $L39068
$L39067:

; 329  : 				// shut sound off
; 330  : 				UTIL_EmitAmbientSound( edict(), GetAbsOrigin(), szSoundFile, 0, 0, SND_STOP, 0 );

	push	0
	push	32					; 00000020H
	push	0
	push	0
	mov	eax, DWORD PTR _szSoundFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ; UTIL_EmitAmbientSound
	add	esp, 28					; 0000001cH
$L39068:

; 332  : 			// return without setting nextthink
; 333  : 			return;

	jmp	$L39051
$L39066:

; 335  : 
; 336  : 		if (pitch > 255) pitch = 255;

	cmp	DWORD PTR _pitch$[ebp], 255		; 000000ffH
	jle	SHORT $L39069
	mov	DWORD PTR _pitch$[ebp], 255		; 000000ffH
$L39069:

; 337  : 		if (pitch < 1) pitch = 1;

	cmp	DWORD PTR _pitch$[ebp], 1
	jge	SHORT $L39070
	mov	DWORD PTR _pitch$[ebp], 1
$L39070:

; 338  : 
; 339  : 		m_dpv.pitch = pitch;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [ecx+1828], edx

; 340  : 
; 341  : 		fChanged |= (prev != pitch);

	mov	eax, DWORD PTR _prev$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _pitch$[ebp]
	setne	cl
	mov	edx, DWORD PTR _fChanged$[ebp]
	or	edx, ecx
	mov	DWORD PTR _fChanged$[ebp], edx

; 342  : 		flags |= SND_CHANGE_PITCH;

	mov	eax, DWORD PTR _flags$[ebp]
	or	al, -128				; ffffff80H
	mov	DWORD PTR _flags$[ebp], eax
$L39060:

; 344  : 
; 345  : 	// ==================
; 346  : 	// amplitude envelope
; 347  : 	// ==================
; 348  : 	if (m_dpv.fadein || m_dpv.fadeout)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1796], 0
	jne	SHORT $L39072
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1800], 0
	je	$L39071
$L39072:

; 350  : 		prev = m_dpv.volfrac >> 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	sar	ecx, 8
	mov	DWORD PTR _prev$[ebp], ecx

; 351  : 
; 352  : 		if (m_dpv.fadein > 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1796], 0
	jle	SHORT $L39073

; 353  : 			m_dpv.volfrac += m_dpv.fadein;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+1796]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], ecx

; 354  : 		else if (m_dpv.fadeout > 0)

	jmp	SHORT $L39075
$L39073:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1800], 0
	jle	SHORT $L39075

; 355  : 			m_dpv.volfrac -= m_dpv.fadeout;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1856]
	sub	ecx, DWORD PTR [eax+1800]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1856], ecx
$L39075:

; 356  : 
; 357  : 		vol = m_dpv.volfrac >> 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	sar	ecx, 8
	mov	DWORD PTR _vol$[ebp], ecx

; 358  : 
; 359  : 		if (vol > m_dpv.volrun)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vol$[ebp]
	cmp	eax, DWORD PTR [edx+1788]
	jle	SHORT $L39076

; 361  : 			vol = m_dpv.volrun;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1788]
	mov	DWORD PTR _vol$[ebp], edx

; 362  : 			m_dpv.fadein = 0;				// done with ramp up

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1796], 0
$L39076:

; 364  : 
; 365  : 		if (vol < m_dpv.volstart)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vol$[ebp]
	cmp	edx, DWORD PTR [ecx+1792]
	jge	SHORT $L39077

; 367  : 			vol = m_dpv.volstart;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1792]
	mov	DWORD PTR _vol$[ebp], ecx

; 368  : 			m_dpv.fadeout = 0;				// done with ramp down

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1800], 0

; 369  : 
; 370  : 			if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39078

; 372  : 				EMIT_SOUND_DYN( edict(), CHAN_ITEM, szSoundFile,	0, 0, SND_STOP, 0 );

	push	0
	push	32					; 00000020H
	push	0
	push	0
	mov	eax, DWORD PTR _szSoundFile$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 374  : 			else

	jmp	SHORT $L39079
$L39078:

; 376  : 				// shut sound off
; 377  : 				UTIL_EmitAmbientSound( edict(), GetAbsOrigin(), szSoundFile, 0, 0, SND_STOP, 0 );

	push	0
	push	32					; 00000020H
	push	0
	push	0
	mov	ecx, DWORD PTR _szSoundFile$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ; UTIL_EmitAmbientSound
	add	esp, 28					; 0000001cH
$L39079:

; 379  : 
; 380  : 			// return without setting nextthink
; 381  : 			return;

	jmp	$L39051
$L39077:

; 383  : 
; 384  : 		if (vol > 100) vol = 100;

	cmp	DWORD PTR _vol$[ebp], 100		; 00000064H
	jle	SHORT $L39080
	mov	DWORD PTR _vol$[ebp], 100		; 00000064H
$L39080:

; 385  : 		if (vol < 1) vol = 1;

	cmp	DWORD PTR _vol$[ebp], 1
	jge	SHORT $L39081
	mov	DWORD PTR _vol$[ebp], 1
$L39081:

; 386  : 
; 387  : 		m_dpv.vol = vol;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vol$[ebp]
	mov	DWORD PTR [edx+1844], eax

; 388  : 
; 389  : 		fChanged |= (prev != vol);

	mov	ecx, DWORD PTR _prev$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR _vol$[ebp]
	setne	dl
	mov	eax, DWORD PTR _fChanged$[ebp]
	or	eax, edx
	mov	DWORD PTR _fChanged$[ebp], eax

; 390  : 		flags |= SND_CHANGE_VOL;

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 64					; 00000040H
	mov	DWORD PTR _flags$[ebp], ecx
$L39071:

; 392  : 
; 393  : 	// ===================
; 394  : 	// pitch/amplitude LFO
; 395  : 	// ===================
; 396  : 	if (m_dpv.lfotype)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1804], 0
	je	$L39101

; 398  : 		int pos;
; 399  : 
; 400  : 		if (m_dpv.lfofrac > 0x6fffffff)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1860], 1879048191	; 6fffffffH
	jle	SHORT $L39084

; 401  : 			m_dpv.lfofrac = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1860], 0
$L39084:

; 402  : 
; 403  : 		// update lfo, lfofrac/255 makes a triangle wave 0-255
; 404  : 		m_dpv.lfofrac += m_dpv.lforate;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1860]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+1808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1860], eax

; 405  : 		pos = m_dpv.lfofrac >> 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1860]
	sar	ecx, 8
	mov	DWORD PTR _pos$39083[ebp], ecx

; 406  : 
; 407  : 		if (m_dpv.lfofrac < 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1860], 0
	jge	SHORT $L39085

; 409  : 			m_dpv.lfofrac = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1860], 0

; 410  : 			m_dpv.lforate = abs(m_dpv.lforate);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1808]
	push	edx
	call	_abs
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1808], eax

; 411  : 			pos = 0;

	mov	DWORD PTR _pos$39083[ebp], 0

; 413  : 		else if (pos > 255)

	jmp	SHORT $L39087
$L39085:
	cmp	DWORD PTR _pos$39083[ebp], 255		; 000000ffH
	jle	SHORT $L39087

; 415  : 			pos = 255;

	mov	DWORD PTR _pos$39083[ebp], 255		; 000000ffH

; 416  : 			m_dpv.lfofrac = (255 << 8);

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1860], 65280		; 0000ff00H

; 417  : 			m_dpv.lforate = -abs(m_dpv.lforate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1808]
	push	ecx
	call	_abs
	add	esp, 4
	neg	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1808], eax
$L39087:

; 421  : 		{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1804]
	mov	DWORD PTR -36+[ebp], ecx
	cmp	DWORD PTR -36+[ebp], 1
	je	SHORT $L39092
	cmp	DWORD PTR -36+[ebp], 3
	je	SHORT $L39095
	jmp	SHORT $L39097
$L39092:

; 422  : 		case LFO_SQUARE:
; 423  : 			if (pos < 128)

	cmp	DWORD PTR _pos$39083[ebp], 128		; 00000080H
	jge	SHORT $L39093

; 424  : 				m_dpv.lfomult = 255;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1864], 255		; 000000ffH

; 425  : 			else

	jmp	SHORT $L39094
$L39093:

; 426  : 				m_dpv.lfomult = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1864], 0
$L39094:

; 427  : 			
; 428  : 			break;

	jmp	SHORT $L39089
$L39095:

; 429  : 		case LFO_RANDOM:
; 430  : 			if (pos == 255)

	cmp	DWORD PTR _pos$39083[ebp], 255		; 000000ffH
	jne	SHORT $L39096

; 431  : 				m_dpv.lfomult = RANDOM_LONG(0, 255);

	push	255					; 000000ffH
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1864], eax
$L39096:

; 432  : 			break;

	jmp	SHORT $L39089
$L39097:

; 433  : 		case LFO_TRIANGLE:
; 434  : 		default: 
; 435  : 			m_dpv.lfomult = pos;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pos$39083[ebp]
	mov	DWORD PTR [edx+1864], eax
$L39089:

; 438  : 
; 439  : 		if (m_dpv.lfomodpitch)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1812], 0
	je	SHORT $L39098

; 441  : 			prev = pitch;

	mov	edx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR _prev$[ebp], edx

; 442  : 
; 443  : 			// pitch 0-255
; 444  : 			pitch += ((m_dpv.lfomult - 128) * m_dpv.lfomodpitch) / 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1864]
	sub	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+1812]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _pitch$[ebp]
	add	edx, eax
	mov	DWORD PTR _pitch$[ebp], edx

; 445  : 
; 446  : 			if (pitch > 255) pitch = 255;

	cmp	DWORD PTR _pitch$[ebp], 255		; 000000ffH
	jle	SHORT $L39099
	mov	DWORD PTR _pitch$[ebp], 255		; 000000ffH
$L39099:

; 447  : 			if (pitch < 1) pitch = 1;

	cmp	DWORD PTR _pitch$[ebp], 1
	jge	SHORT $L39100
	mov	DWORD PTR _pitch$[ebp], 1
$L39100:

; 448  : 
; 449  : 			
; 450  : 			fChanged |= (prev != pitch);

	mov	eax, DWORD PTR _prev$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _pitch$[ebp]
	setne	cl
	mov	edx, DWORD PTR _fChanged$[ebp]
	or	edx, ecx
	mov	DWORD PTR _fChanged$[ebp], edx

; 451  : 			flags |= SND_CHANGE_PITCH;

	mov	eax, DWORD PTR _flags$[ebp]
	or	al, -128				; ffffff80H
	mov	DWORD PTR _flags$[ebp], eax
$L39098:

; 453  : 
; 454  : 		if (m_dpv.lfomodvol)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 0
	je	SHORT $L39101

; 456  : 			// vol 0-100
; 457  : 			prev = vol;

	mov	edx, DWORD PTR _vol$[ebp]
	mov	DWORD PTR _prev$[ebp], edx

; 458  : 
; 459  : 			vol += ((m_dpv.lfomult - 128) * m_dpv.lfomodvol) / 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1864]
	sub	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+1816]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _vol$[ebp]
	add	edx, eax
	mov	DWORD PTR _vol$[ebp], edx

; 460  : 
; 461  : 			if (vol > 100) vol = 100;

	cmp	DWORD PTR _vol$[ebp], 100		; 00000064H
	jle	SHORT $L39102
	mov	DWORD PTR _vol$[ebp], 100		; 00000064H
$L39102:

; 462  : 			if (vol < 0) vol = 0;

	cmp	DWORD PTR _vol$[ebp], 0
	jge	SHORT $L39103
	mov	DWORD PTR _vol$[ebp], 0
$L39103:

; 463  : 			
; 464  : 			fChanged |= (prev != vol);

	mov	eax, DWORD PTR _prev$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _vol$[ebp]
	setne	cl
	mov	edx, DWORD PTR _fChanged$[ebp]
	or	edx, ecx
	mov	DWORD PTR _fChanged$[ebp], edx

; 465  : 			flags |= SND_CHANGE_VOL;

	mov	eax, DWORD PTR _flags$[ebp]
	or	al, 64					; 00000040H
	mov	DWORD PTR _flags$[ebp], eax
$L39101:

; 469  : 
; 470  : 	// Send update to playing sound only if we actually changed
; 471  : 	// pitch or volume in this routine.
; 472  : 
; 473  : 	if (flags && fChanged) 

	cmp	DWORD PTR _flags$[ebp], 0
	je	$L39107
	cmp	DWORD PTR _fChanged$[ebp], 0
	je	$L39107

; 475  : 		if (pitch == PITCH_NORM)

	cmp	DWORD PTR _pitch$[ebp], 100		; 00000064H
	jne	SHORT $L39105

; 476  : 			pitch = PITCH_NORM + 1; // don't send 'no pitch' !

	mov	DWORD PTR _pitch$[ebp], 101		; 00000065H
$L39105:

; 477  : 
; 478  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39106

; 480  : 			EMIT_SOUND_DYN( edict(), CHAN_ITEM, szSoundFile,	(vol * 0.01), m_flAttenuation, flags, pitch );

	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1764]
	push	ecx
	fild	DWORD PTR _vol$[ebp]
	fmul	QWORD PTR __real@8@3ff8a3d70a3d70a3d800
	fst	DWORD PTR -40+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _szSoundFile$[ebp]
	push	edx
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 482  : 		else

	jmp	SHORT $L39107
$L39106:

; 484  : 			UTIL_EmitAmbientSound( edict(), GetAbsOrigin(), szSoundFile, (vol * 0.01), m_flAttenuation, flags, pitch );

	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1764]
	push	eax
	fild	DWORD PTR _vol$[ebp]
	fmul	QWORD PTR __real@8@3ff8a3d70a3d70a3d800
	fst	DWORD PTR -44+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _szSoundFile$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ; UTIL_EmitAmbientSound
	add	esp, 28					; 0000001cH
$L39107:

; 487  : 
; 488  : 	// update ramps at 5hz
; 489  : 	pev->nextthink = gpGlobals->time + 0.2;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	QWORD PTR __real@8@3ffcccccccccccccd000
	fst	DWORD PTR -48+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+260]
$L39051:

; 490  : 	return;
; 491  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RampThink@CAmbientGeneric@@QAEXXZ ENDP			; CAmbientGeneric::RampThink
_TEXT	ENDS
PUBLIC	__real@4@4002a000000000000000
EXTRN	__ftol:NEAR
;	COMDAT __real@4@4002a000000000000000
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
__real@4@4002a000000000000000 DD 041200000r	; 10
CONST	ENDS
;	COMDAT ?InitModulationParms@CAmbientGeneric@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pitchinc$ = -8
?InitModulationParms@CAmbientGeneric@@QAEXXZ PROC NEAR	; CAmbientGeneric::InitModulationParms, COMDAT

; 497  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 498  : 	int pitchinc;
; 499  : 
; 500  : 	m_dpv.volrun = pev->health * 10;	// 0 - 100

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+352]
	fmul	DWORD PTR __real@4@4002a000000000000000
	call	__ftol
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], eax

; 501  : 	if (m_dpv.volrun > 100) m_dpv.volrun = 100;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1788], 100		; 00000064H
	jle	SHORT $L39113
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 100		; 00000064H
$L39113:

; 502  : 	if (m_dpv.volrun < 0) m_dpv.volrun = 0;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1788], 0
	jge	SHORT $L39114
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 0
$L39114:

; 503  : 
; 504  : 	// get presets
; 505  : 	if (m_dpv.preset != 0 && m_dpv.preset <= CDPVPRESETMAX)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1768], 0
	je	$L39115
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1768], 27		; 0000001bH
	jg	$L39115

; 507  : 		// load preset values
; 508  : 		m_dpv = rgdpvpreset[m_dpv.preset - 1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+1768]
	sub	esi, 1
	imul	esi, 100				; 00000064H
	add	esi, OFFSET FLAT:?rgdpvpreset@@3PAUdynpitchvol@@A ; rgdpvpreset
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 1768				; 000006e8H
	mov	ecx, 25					; 00000019H
	rep movsd

; 509  : 
; 510  : 		// fixup preset values, just like
; 511  : 		// fixups in KeyValue routine.
; 512  : 		if (m_dpv.spindown > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1784], 0
	jle	SHORT $L39116

; 513  : 			m_dpv.spindown = (101 - m_dpv.spindown) * 64;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, 101				; 00000065H
	sub	eax, DWORD PTR [edx+1784]
	shl	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1784], eax
$L39116:

; 514  : 		if (m_dpv.spinup > 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1780], 0
	jle	SHORT $L39117

; 515  : 			m_dpv.spinup = (101 - m_dpv.spinup) * 64;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, 101				; 00000065H
	sub	ecx, DWORD PTR [eax+1780]
	shl	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1780], ecx
$L39117:

; 516  : 
; 517  : 		m_dpv.volstart *= 10;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1792]
	imul	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1792], ecx

; 518  : 		m_dpv.volrun *= 10;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1788]
	imul	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], ecx

; 519  : 
; 520  : 		if (m_dpv.fadein > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1796], 0
	jle	SHORT $L39118

; 521  : 			m_dpv.fadein = (101 - m_dpv.fadein) * 64;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, 101				; 00000065H
	sub	edx, DWORD PTR [ecx+1796]
	shl	edx, 6
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1796], edx
$L39118:

; 522  : 		if (m_dpv.fadeout > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1800], 0
	jle	SHORT $L39119

; 523  : 			m_dpv.fadeout = (101 - m_dpv.fadeout) * 64;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, 101				; 00000065H
	sub	eax, DWORD PTR [edx+1800]
	shl	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1800], eax
$L39119:

; 524  : 
; 525  : 		m_dpv.lforate *= 256;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1808]
	shl	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1808], eax

; 526  : 
; 527  : 		m_dpv.fadeinsav = m_dpv.fadein;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1796]
	mov	DWORD PTR [edx+1848], ecx

; 528  : 		m_dpv.fadeoutsav = m_dpv.fadeout;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1800]
	mov	DWORD PTR [edx+1852], ecx

; 529  : 		m_dpv.spinupsav = m_dpv.spinup;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1780]
	mov	DWORD PTR [edx+1832], ecx

; 530  : 		m_dpv.spindownsav = m_dpv.spindown;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1784]
	mov	DWORD PTR [edx+1836], ecx
$L39115:

; 532  : 
; 533  : 	m_dpv.fadein = m_dpv.fadeinsav;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1848]
	mov	DWORD PTR [edx+1796], ecx

; 534  : 	m_dpv.fadeout = 0; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1800], 0

; 535  : 	
; 536  : 	if (m_dpv.fadein)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1796], 0
	je	SHORT $L39120

; 537  : 		m_dpv.vol = m_dpv.volstart;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1792]
	mov	DWORD PTR [ecx+1844], eax

; 538  : 	else

	jmp	SHORT $L39121
$L39120:

; 539  : 		m_dpv.vol = m_dpv.volrun;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1788]
	mov	DWORD PTR [ecx+1844], eax
$L39121:

; 540  : 
; 541  : 	m_dpv.spinup = m_dpv.spinupsav;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1832]
	mov	DWORD PTR [ecx+1780], eax

; 542  : 	m_dpv.spindown = 0; 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1784], 0

; 543  : 
; 544  : 	if (m_dpv.spinup)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1780], 0
	je	SHORT $L39122

; 545  : 		m_dpv.pitch = m_dpv.pitchstart;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1776]
	mov	DWORD PTR [eax+1828], edx

; 546  : 	else

	jmp	SHORT $L39123
$L39122:

; 547  : 		m_dpv.pitch = m_dpv.pitchrun;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1772]
	mov	DWORD PTR [eax+1828], edx
$L39123:

; 548  : 
; 549  : 	if (m_dpv.pitch == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1828], 0
	jne	SHORT $L39124

; 550  : 		m_dpv.pitch = PITCH_NORM;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1828], 100		; 00000064H
$L39124:

; 551  : 
; 552  : 	m_dpv.pitchfrac = m_dpv.pitch << 8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1828]
	shl	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1840], eax

; 553  : 	m_dpv.volfrac = m_dpv.vol << 8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1844]
	shl	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1856], eax

; 554  : 
; 555  : 	m_dpv.lfofrac = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1860], 0

; 556  : 	m_dpv.lforate = abs(m_dpv.lforate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1808]
	push	ecx
	call	_abs
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1808], eax

; 557  : 
; 558  : 	m_dpv.cspincount = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1824], 1

; 559  : 	
; 560  : 	if (m_dpv.cspinup) 

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1820], 0
	je	SHORT $L39126

; 562  : 		pitchinc = (255 - m_dpv.pitchstart) / m_dpv.cspinup;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, DWORD PTR [edx+1776]
	mov	ecx, DWORD PTR _this$[ebp]
	cdq
	idiv	DWORD PTR [ecx+1820]
	mov	DWORD PTR _pitchinc$[ebp], eax

; 563  : 
; 564  : 		m_dpv.pitchrun = m_dpv.pitchstart + pitchinc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1776]
	add	eax, DWORD PTR _pitchinc$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1772], eax

; 565  : 		if (m_dpv.pitchrun > 255) m_dpv.pitchrun = 255;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1772], 255		; 000000ffH
	jle	SHORT $L39126
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1772], 255		; 000000ffH
$L39126:

; 569  : 		&& (m_dpv.pitch == PITCH_NORM))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1832], 0
	jne	SHORT $L39128
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1836], 0
	jne	SHORT $L39128
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1804], 0
	je	SHORT $L39127
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1812], 0
	je	SHORT $L39127
$L39128:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1828], 100		; 00000064H
	jne	SHORT $L39127

; 570  : 		m_dpv.pitch = PITCH_NORM + 1; // must never send 'no pitch' as first pitch

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1828], 101		; 00000065H
$L39127:

; 571  : 									  // if we intend to pitch shift later!
; 572  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitModulationParms@CAmbientGeneric@@QAEXXZ ENDP	; CAmbientGeneric::InitModulationParms
_TEXT	ENDS
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	__real@8@00000000000000000000
PUBLIC	__real@4@4006ff00000000000000
PUBLIC	__real@8@3ffbccccccccccccd000
;	COMDAT __real@8@3fff8000000000000000
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT __real@8@00000000000000000000
CONST	SEGMENT
__real@8@00000000000000000000 DQ 00000000000000000r ; 0
CONST	ENDS
;	COMDAT __real@4@4006ff00000000000000
CONST	SEGMENT
__real@4@4006ff00000000000000 DD 0437f0000r	; 255
CONST	ENDS
;	COMDAT __real@8@3ffbccccccccccccd000
CONST	SEGMENT
__real@8@3ffbccccccccccccd000 DQ 03fb999999999999ar ; 0.1
CONST	ENDS
;	COMDAT ?ToggleUse@CAmbientGeneric@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_useType$ = 16
_value$ = 20
_this$ = -4
_szSoundFile$ = -8
_fraction$ = -12
_pitchinc$39151 = -16
?ToggleUse@CAmbientGeneric@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CAmbientGeneric::ToggleUse, COMDAT

; 581  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 582  : 	char* szSoundFile = (char*) STRING(pev->message);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _szSoundFile$[ebp], eax

; 583  : 	float fraction;
; 584  : 
; 585  : 	if ( useType != USE_TOGGLE )

	cmp	DWORD PTR _useType$[ebp], 3
	je	SHORT $L39140

; 587  : 		if ( (m_fActive && useType == USE_ON) || (!m_fActive && useType == USE_OFF) )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1868], 0
	je	SHORT $L39142
	cmp	DWORD PTR _useType$[ebp], 1
	je	SHORT $L39141
$L39142:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1868], 0
	jne	SHORT $L39140
	cmp	DWORD PTR _useType$[ebp], 0
	jne	SHORT $L39140
$L39141:

; 588  : 			return;

	jmp	$L39135
$L39140:

; 590  : 	// Directly change pitch if arg passed. Only works if sound is already playing.
; 591  : 
; 592  : 	if (useType == USE_SET && m_fActive)		// Momentary buttons will pass down a float in here

	cmp	DWORD PTR _useType$[ebp], 2
	jne	$L39143
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1868], 0
	je	$L39143

; 594  : 
; 595  : 		fraction = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _fraction$[ebp], eax

; 596  : 		
; 597  : 		if ( fraction > 1.0 )

	fld	DWORD PTR _fraction$[ebp]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39144

; 598  : 			fraction = 1.0;

	mov	DWORD PTR _fraction$[ebp], 1065353216	; 3f800000H
$L39144:

; 599  : 		if (fraction < 0.0)

	fld	DWORD PTR _fraction$[ebp]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39145

; 600  : 			fraction = 0.01;

	mov	DWORD PTR _fraction$[ebp], 1008981770	; 3c23d70aH
$L39145:

; 601  : 
; 602  : 		m_dpv.pitch = fraction * 255;

	fld	DWORD PTR _fraction$[ebp]
	fmul	DWORD PTR __real@4@4006ff00000000000000
	call	__ftol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1828], eax

; 603  : 
; 604  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39146

; 606  : 			EMIT_SOUND_DYN( edict(), CHAN_ITEM, szSoundFile, 0, 0, SND_CHANGE_PITCH, m_dpv.pitch );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1828]
	push	eax
	push	128					; 00000080H
	push	0
	push	0
	mov	ecx, DWORD PTR _szSoundFile$[ebp]
	push	ecx
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 608  : 		else

	jmp	SHORT $L39147
$L39146:

; 610  : 			UTIL_EmitAmbientSound( edict(), GetAbsOrigin(), szSoundFile, 0, 0, SND_CHANGE_PITCH, m_dpv.pitch );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1828]
	push	eax
	push	128					; 00000080H
	push	0
	push	0
	mov	ecx, DWORD PTR _szSoundFile$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ; UTIL_EmitAmbientSound
	add	esp, 28					; 0000001cH
$L39147:

; 612  : 		return;

	jmp	$L39135
$L39143:

; 614  : 
; 615  : 	// Toggle
; 616  : 
; 617  : 	// m_fActive is TRUE only if a looping sound is playing.
; 618  : 	
; 619  : 	if ( m_fActive )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1868], 0
	je	$L39148

; 621  : 
; 622  : 		if (m_dpv.cspinup)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1820], 0
	je	$L39149

; 624  : 			// Don't actually shut off. Each toggle causes
; 625  : 			// incremental spinup to max pitch
; 626  : 
; 627  : 			if (m_dpv.cspincount <= m_dpv.cspinup)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+1824]
	cmp	eax, DWORD PTR [edx+1820]
	jg	$L39150

; 629  : 				int pitchinc;
; 630  : 
; 631  : 				// start a new spinup
; 632  : 				m_dpv.cspincount++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1824]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1824], edx

; 633  : 				
; 634  : 				pitchinc = (255 - m_dpv.pitchstart) / m_dpv.cspinup;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, DWORD PTR [ecx+1776]
	mov	ecx, DWORD PTR _this$[ebp]
	cdq
	idiv	DWORD PTR [ecx+1820]
	mov	DWORD PTR _pitchinc$39151[ebp], eax

; 635  : 
; 636  : 				m_dpv.spinup = m_dpv.spinupsav;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1832]
	mov	DWORD PTR [edx+1780], ecx

; 637  : 				m_dpv.spindown = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1784], 0

; 638  : 
; 639  : 				m_dpv.pitchrun = m_dpv.pitchstart + pitchinc * m_dpv.cspincount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pitchinc$39151[ebp]
	imul	ecx, DWORD PTR [eax+1824]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1776]
	add	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1772], eax

; 640  : 				if (m_dpv.pitchrun > 255) m_dpv.pitchrun = 255;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1772], 255		; 000000ffH
	jle	SHORT $L39152
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1772], 255		; 000000ffH
$L39152:

; 641  : 
; 642  : 				pev->nextthink = gpGlobals->time + 0.1;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -20+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+260]
$L39150:

; 646  : 		else

	jmp	$L39158
$L39149:

; 648  : 			m_fActive = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1868], 0

; 649  : 			
; 650  : 			// HACKHACK - this makes the code in Precache() work properly after a save/restore
; 651  : 			pev->spawnflags |= AMBIENT_SOUND_START_SILENT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+416], ecx

; 652  : 
; 653  : 			if( m_dpv.spindownsav || m_dpv.fadeoutsav )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1836], 0
	jne	SHORT $L39155
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1852], 0
	je	SHORT $L39154
$L39155:

; 655  : 				// spin it down (or fade it) before shutoff if spindown is set
; 656  : 				m_dpv.spindown = m_dpv.spindownsav;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1836]
	mov	DWORD PTR [eax+1784], edx

; 657  : 				m_dpv.spinup = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1780], 0

; 658  : 
; 659  : 				m_dpv.fadeout = m_dpv.fadeoutsav;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1852]
	mov	DWORD PTR [ecx+1800], eax

; 660  : 				m_dpv.fadein = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1796], 0

; 661  : 				pev->nextthink = gpGlobals->time + 0.1;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -24+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+260]

; 663  : 			else

	jmp	SHORT $L39158
$L39154:

; 665  : 				if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39157

; 667  : 					EMIT_SOUND_DYN( edict(), CHAN_ITEM, szSoundFile,	0, 0, SND_STOP, 0 );

	push	0
	push	32					; 00000020H
	push	0
	push	0
	mov	edx, DWORD PTR _szSoundFile$[ebp]
	push	edx
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 669  : 				else

	jmp	SHORT $L39158
$L39157:

; 671  : 					// shut sound off
; 672  : 					UTIL_EmitAmbientSound( edict(), GetAbsOrigin(), szSoundFile, 0, 0, SND_STOP, 0 );

	push	0
	push	32					; 00000020H
	push	0
	push	0
	mov	eax, DWORD PTR _szSoundFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ; UTIL_EmitAmbientSound
	add	esp, 28					; 0000001cH
$L39158:

; 677  : 	else 

	jmp	$L39159
$L39148:

; 679  : 		// turn sound on
; 680  : 
; 681  : 		// only toggle if this is a looping sound.  If not looping, each
; 682  : 		// trigger will cause the sound to play.  If the sound is still
; 683  : 		// playing from a previous trigger press, it will be shut off
; 684  : 		// and then restarted.
; 685  : 
; 686  : 		if (m_fLooping)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1872], 0
	je	SHORT $L39160

; 688  : 			m_fActive = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1868], 1

; 690  : 		else

	jmp	SHORT $L39163
$L39160:

; 692  : 			// shut sound off now - may be interrupting a long non-looping sound
; 693  : 			if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39162

; 695  : 				EMIT_SOUND_DYN( edict(), CHAN_ITEM, szSoundFile,	0, 0, SND_STOP, 0 );

	push	0
	push	32					; 00000020H
	push	0
	push	0
	mov	eax, DWORD PTR _szSoundFile$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 697  : 			else

	jmp	SHORT $L39163
$L39162:

; 699  : 				// shut sound off
; 700  : 				UTIL_EmitAmbientSound( edict(), GetAbsOrigin(), szSoundFile, 0, 0, SND_STOP, 0 );

	push	0
	push	32					; 00000020H
	push	0
	push	0
	mov	ecx, DWORD PTR _szSoundFile$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ; UTIL_EmitAmbientSound
	add	esp, 28					; 0000001cH
$L39163:

; 703  : 
; 704  : 		// init all ramp params for startup
; 705  : 		InitModulationParms();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitModulationParms@CAmbientGeneric@@QAEXXZ ; CAmbientGeneric::InitModulationParms

; 706  : 
; 707  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39164

; 709  : 			EMIT_SOUND_DYN( edict(), CHAN_ITEM, szSoundFile, (m_dpv.vol * 0.01), m_flAttenuation, 0, m_dpv.pitch );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1828]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1764]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	fild	DWORD PTR [eax+1844]
	fmul	QWORD PTR __real@8@3ff8a3d70a3d70a3d800
	fst	DWORD PTR -28+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _szSoundFile$[ebp]
	push	ecx
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 711  : 		else

	jmp	SHORT $L39165
$L39164:

; 713  : 			// shut sound off
; 714  : 			UTIL_EmitAmbientSound( edict(), GetAbsOrigin(), szSoundFile, (m_dpv.vol * 0.01), m_flAttenuation, 0, m_dpv.pitch );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1828]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1764]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	fild	DWORD PTR [eax+1844]
	fmul	QWORD PTR __real@8@3ff8a3d70a3d70a3d800
	fst	DWORD PTR -32+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _szSoundFile$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ; UTIL_EmitAmbientSound
	add	esp, 28					; 0000001cH
$L39165:

; 716  : 		SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]
$L39159:
$L39135:

; 718  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ToggleUse@CAmbientGeneric@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CAmbientGeneric::ToggleUse
_TEXT	ENDS
PUBLIC	??_C@_05LHHB@pitch?$AA@				; `string'
PUBLIC	??_C@_0L@KOLG@pitchstart?$AA@			; `string'
PUBLIC	??_C@_06HKPC@spinup?$AA@			; `string'
PUBLIC	??_C@_08EIAJ@spindown?$AA@			; `string'
PUBLIC	??_C@_08FJGI@volstart?$AA@			; `string'
PUBLIC	??_C@_06DKEJ@fadein?$AA@			; `string'
PUBLIC	??_C@_07FOED@fadeout?$AA@			; `string'
PUBLIC	??_C@_07IMGJ@lfotype?$AA@			; `string'
PUBLIC	??_C@_07LIPA@lforate?$AA@			; `string'
PUBLIC	??_C@_0M@HCFK@lfomodpitch?$AA@			; `string'
PUBLIC	??_C@_09KJLL@lfomodvol?$AA@			; `string'
PUBLIC	??_C@_07HOJA@cspinup?$AA@			; `string'
PUBLIC	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
PUBLIC	?KeyValue@CAmbientGeneric@@UAEXPAUKeyValueData_s@@@Z ; CAmbientGeneric::KeyValue
EXTRN	_atoi:NEAR
;	COMDAT ??_C@_05LHHB@pitch?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_05LHHB@pitch?$AA@ DB 'pitch', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KOLG@pitchstart?$AA@
CONST	SEGMENT
??_C@_0L@KOLG@pitchstart?$AA@ DB 'pitchstart', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HKPC@spinup?$AA@
CONST	SEGMENT
??_C@_06HKPC@spinup?$AA@ DB 'spinup', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EIAJ@spindown?$AA@
CONST	SEGMENT
??_C@_08EIAJ@spindown?$AA@ DB 'spindown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJGI@volstart?$AA@
CONST	SEGMENT
??_C@_08FJGI@volstart?$AA@ DB 'volstart', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKEJ@fadein?$AA@
CONST	SEGMENT
??_C@_06DKEJ@fadein?$AA@ DB 'fadein', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FOED@fadeout?$AA@
CONST	SEGMENT
??_C@_07FOED@fadeout?$AA@ DB 'fadeout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMGJ@lfotype?$AA@
CONST	SEGMENT
??_C@_07IMGJ@lfotype?$AA@ DB 'lfotype', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LIPA@lforate?$AA@
CONST	SEGMENT
??_C@_07LIPA@lforate?$AA@ DB 'lforate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HCFK@lfomodpitch?$AA@
CONST	SEGMENT
??_C@_0M@HCFK@lfomodpitch?$AA@ DB 'lfomodpitch', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KJLL@lfomodvol?$AA@
CONST	SEGMENT
??_C@_09KJLL@lfomodvol?$AA@ DB 'lfomodvol', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HOJA@cspinup?$AA@
CONST	SEGMENT
??_C@_07HOJA@cspinup?$AA@ DB 'cspinup', 00H		; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CAmbientGeneric@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CAmbientGeneric@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CAmbientGeneric::KeyValue, COMDAT

; 724  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 725  : 	// NOTE: changing any of the modifiers in this code
; 726  : 	// NOTE: also requires changing InitModulationParms code.
; 727  : 
; 728  : 	// preset
; 729  : 	if (FStrEq(pkvd->szKeyName, "preset"))

	push	OFFSET FLAT:??_C@_06FAOG@preset?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39170

; 731  : 		m_dpv.preset = atoi(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1768], eax

; 732  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 734  : 
; 735  : 	// pitchrun
; 736  : 	else if (FStrEq(pkvd->szKeyName, "pitch"))

	jmp	$L39235
$L39170:
	push	OFFSET FLAT:??_C@_05LHHB@pitch?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39173

; 738  : 		m_dpv.pitchrun = atoi(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1772], eax

; 739  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 740  : 		
; 741  : 		if (m_dpv.pitchrun > 255) m_dpv.pitchrun = 255;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1772], 255		; 000000ffH
	jle	SHORT $L39175
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1772], 255		; 000000ffH
$L39175:

; 742  : 		if (m_dpv.pitchrun < 0) m_dpv.pitchrun = 0;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1772], 0
	jge	SHORT $L39176
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1772], 0
$L39176:

; 744  : 
; 745  : 	// pitchstart
; 746  : 	else if (FStrEq(pkvd->szKeyName, "pitchstart"))

	jmp	$L39235
$L39173:
	push	OFFSET FLAT:??_C@_0L@KOLG@pitchstart?$AA@ ; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39178

; 748  : 		m_dpv.pitchstart = atoi(pkvd->szValue);

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1776], eax

; 749  : 		pkvd->fHandled = TRUE;		

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 750  : 		
; 751  : 		if (m_dpv.pitchstart > 255) m_dpv.pitchstart = 255;

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1776], 255		; 000000ffH
	jle	SHORT $L39180
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1776], 255		; 000000ffH
$L39180:

; 752  : 		if (m_dpv.pitchstart < 0) m_dpv.pitchstart = 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1776], 0
	jge	SHORT $L39181
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1776], 0
$L39181:

; 754  : 
; 755  : 	// spinup
; 756  : 	else if (FStrEq(pkvd->szKeyName, "spinup"))

	jmp	$L39235
$L39178:
	push	OFFSET FLAT:??_C@_06HKPC@spinup?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	$L39183

; 758  : 		m_dpv.spinup = atoi(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1780], eax

; 759  : 		
; 760  : 		if (m_dpv.spinup > 100) m_dpv.spinup = 100;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1780], 100		; 00000064H
	jle	SHORT $L39185
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1780], 100		; 00000064H
$L39185:

; 761  : 		if (m_dpv.spinup < 0) m_dpv.spinup = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1780], 0
	jge	SHORT $L39186
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1780], 0
$L39186:

; 762  : 
; 763  : 		if (m_dpv.spinup > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1780], 0
	jle	SHORT $L39187

; 764  : 			m_dpv.spinup = (101 - m_dpv.spinup) * 64;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, 101				; 00000065H
	sub	edx, DWORD PTR [ecx+1780]
	shl	edx, 6
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1780], edx
$L39187:

; 765  : 		m_dpv.spinupsav = m_dpv.spinup;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1780]
	mov	DWORD PTR [ecx+1832], eax

; 766  : 		pkvd->fHandled = TRUE;

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 768  : 
; 769  : 	// spindown
; 770  : 	else if (FStrEq(pkvd->szKeyName, "spindown"))

	jmp	$L39235
$L39183:
	push	OFFSET FLAT:??_C@_08EIAJ@spindown?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	$L39189

; 772  : 		m_dpv.spindown = atoi(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1784], eax

; 773  : 		
; 774  : 		if (m_dpv.spindown > 100) m_dpv.spindown = 100;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1784], 100		; 00000064H
	jle	SHORT $L39191
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1784], 100		; 00000064H
$L39191:

; 775  : 		if (m_dpv.spindown < 0) m_dpv.spindown = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1784], 0
	jge	SHORT $L39192
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1784], 0
$L39192:

; 776  : 
; 777  : 		if (m_dpv.spindown > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1784], 0
	jle	SHORT $L39193

; 778  : 			m_dpv.spindown = (101 - m_dpv.spindown) * 64;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, 101				; 00000065H
	sub	edx, DWORD PTR [ecx+1784]
	shl	edx, 6
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1784], edx
$L39193:

; 779  : 		m_dpv.spindownsav = m_dpv.spindown;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1784]
	mov	DWORD PTR [ecx+1836], eax

; 780  : 		pkvd->fHandled = TRUE;

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 782  : 
; 783  : 	// volstart
; 784  : 	else if (FStrEq(pkvd->szKeyName, "volstart"))

	jmp	$L39235
$L39189:
	push	OFFSET FLAT:??_C@_08FJGI@volstart?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39195

; 786  : 		m_dpv.volstart = atoi(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1792], eax

; 787  : 
; 788  : 		if (m_dpv.volstart > 10) m_dpv.volstart = 10;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1792], 10		; 0000000aH
	jle	SHORT $L39197
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1792], 10		; 0000000aH
$L39197:

; 789  : 		if (m_dpv.volstart < 0) m_dpv.volstart = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1792], 0
	jge	SHORT $L39198
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1792], 0
$L39198:

; 790  : 		
; 791  : 		m_dpv.volstart *= 10;	// 0 - 100

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1792]
	imul	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1792], ecx

; 792  : 
; 793  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 795  : 
; 796  : 	// fadein
; 797  : 	else if (FStrEq(pkvd->szKeyName, "fadein"))

	jmp	$L39235
$L39195:
	push	OFFSET FLAT:??_C@_06DKEJ@fadein?$AA@	; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	$L39200

; 799  : 		m_dpv.fadein = atoi(pkvd->szValue);

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1796], eax

; 800  : 		
; 801  : 		if (m_dpv.fadein > 100) m_dpv.fadein = 100;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1796], 100		; 00000064H
	jle	SHORT $L39202
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1796], 100		; 00000064H
$L39202:

; 802  : 		if (m_dpv.fadein < 0) m_dpv.fadein = 0;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1796], 0
	jge	SHORT $L39203
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1796], 0
$L39203:

; 803  : 
; 804  : 		if (m_dpv.fadein > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1796], 0
	jle	SHORT $L39204

; 805  : 			m_dpv.fadein = (101 - m_dpv.fadein) * 64;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, 101				; 00000065H
	sub	eax, DWORD PTR [edx+1796]
	shl	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1796], eax
$L39204:

; 806  : 		m_dpv.fadeinsav = m_dpv.fadein;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1796]
	mov	DWORD PTR [edx+1848], ecx

; 807  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 809  : 
; 810  : 	// fadeout
; 811  : 	else if (FStrEq(pkvd->szKeyName, "fadeout"))

	jmp	$L39235
$L39200:
	push	OFFSET FLAT:??_C@_07FOED@fadeout?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	$L39206

; 813  : 		m_dpv.fadeout = atoi(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1800], eax

; 814  : 		
; 815  : 		if (m_dpv.fadeout > 100) m_dpv.fadeout = 100;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1800], 100		; 00000064H
	jle	SHORT $L39208
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1800], 100		; 00000064H
$L39208:

; 816  : 		if (m_dpv.fadeout < 0) m_dpv.fadeout = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1800], 0
	jge	SHORT $L39209
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1800], 0
$L39209:

; 817  : 
; 818  : 		if (m_dpv.fadeout > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1800], 0
	jle	SHORT $L39210

; 819  : 			m_dpv.fadeout = (101 - m_dpv.fadeout) * 64;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, 101				; 00000065H
	sub	edx, DWORD PTR [ecx+1800]
	shl	edx, 6
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1800], edx
$L39210:

; 820  : 		m_dpv.fadeoutsav = m_dpv.fadeout;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1800]
	mov	DWORD PTR [ecx+1852], eax

; 821  : 		pkvd->fHandled = TRUE;

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 823  : 
; 824  : 	// lfotype
; 825  : 	else if (FStrEq(pkvd->szKeyName, "lfotype"))

	jmp	$L39235
$L39206:
	push	OFFSET FLAT:??_C@_07IMGJ@lfotype?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39212

; 827  : 		m_dpv.lfotype = atoi(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1804], eax

; 828  : 		if (m_dpv.lfotype > 4) m_dpv.lfotype = LFO_TRIANGLE;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1804], 4
	jle	SHORT $L39214
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1804], 2
$L39214:

; 829  : 		pkvd->fHandled = TRUE;

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 831  : 
; 832  : 	// lforate
; 833  : 	else if (FStrEq(pkvd->szKeyName, "lforate"))

	jmp	$L39235
$L39212:
	push	OFFSET FLAT:??_C@_07LIPA@lforate?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39216

; 835  : 		m_dpv.lforate = atoi(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1808], eax

; 836  : 		
; 837  : 		if (m_dpv.lforate > 1000) m_dpv.lforate = 1000;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1808], 1000		; 000003e8H
	jle	SHORT $L39218
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1808], 1000		; 000003e8H
$L39218:

; 838  : 		if (m_dpv.lforate < 0) m_dpv.lforate = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1808], 0
	jge	SHORT $L39219
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1808], 0
$L39219:

; 839  : 
; 840  : 		m_dpv.lforate *= 256;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1808]
	shl	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1808], ecx

; 841  : 
; 842  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 844  : 	// lfomodpitch
; 845  : 	else if (FStrEq(pkvd->szKeyName, "lfomodpitch"))

	jmp	$L39235
$L39216:
	push	OFFSET FLAT:??_C@_0M@HCFK@lfomodpitch?$AA@ ; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39221

; 847  : 		m_dpv.lfomodpitch = atoi(pkvd->szValue);

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1812], eax

; 848  : 		if (m_dpv.lfomodpitch > 100) m_dpv.lfomodpitch = 100;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1812], 100		; 00000064H
	jle	SHORT $L39223
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1812], 100		; 00000064H
$L39223:

; 849  : 		if (m_dpv.lfomodpitch < 0) m_dpv.lfomodpitch = 0;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1812], 0
	jge	SHORT $L39224
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1812], 0
$L39224:

; 850  : 		
; 851  : 
; 852  : 		pkvd->fHandled = TRUE;

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 854  : 
; 855  : 	// lfomodvol
; 856  : 	else if (FStrEq(pkvd->szKeyName, "lfomodvol"))

	jmp	$L39235
$L39221:
	push	OFFSET FLAT:??_C@_09KJLL@lfomodvol?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39226

; 858  : 		m_dpv.lfomodvol = atoi(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1816], eax

; 859  : 		if (m_dpv.lfomodvol > 100) m_dpv.lfomodvol = 100;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1816], 100		; 00000064H
	jle	SHORT $L39228
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1816], 100		; 00000064H
$L39228:

; 860  : 		if (m_dpv.lfomodvol < 0) m_dpv.lfomodvol = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 0
	jge	SHORT $L39229
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1816], 0
$L39229:

; 861  : 
; 862  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 864  : 
; 865  : 	// cspinup
; 866  : 	else if (FStrEq(pkvd->szKeyName, "cspinup"))

	jmp	SHORT $L39235
$L39226:
	push	OFFSET FLAT:??_C@_07HOJA@cspinup?$AA@	; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39231

; 868  : 		m_dpv.cspinup = atoi(pkvd->szValue);

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1820], eax

; 869  : 		if (m_dpv.cspinup > 100) m_dpv.cspinup = 100;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1820], 100		; 00000064H
	jle	SHORT $L39233
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1820], 100		; 00000064H
$L39233:

; 870  : 		if (m_dpv.cspinup < 0) m_dpv.cspinup = 0;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1820], 0
	jge	SHORT $L39234
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1820], 0
$L39234:

; 871  : 
; 872  : 		pkvd->fHandled = TRUE;

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 874  : 	else

	jmp	SHORT $L39235
$L39231:

; 875  : 		CBaseEntity::KeyValue( pkvd );

	mov	edx, DWORD PTR _pkvd$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
$L39235:

; 876  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CAmbientGeneric@@UAEXPAUKeyValueData_s@@@Z ENDP ; CAmbientGeneric::KeyValue
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
PUBLIC	??_C@_06FOPF@parent?$AA@			; `string'
PUBLIC	??_C@_08IDGH@movewith?$AA@			; `string'
PUBLIC	??_C@_0M@FCIN@parentflags?$AA@			; `string'
PUBLIC	??_C@_05JCDO@style?$AA@				; `string'
PUBLIC	??_C@_0L@MCHI@reflection?$AA@			; `string'
PUBLIC	??_C@_0N@DCCA@vlight_cache?$AA@			; `string'
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
;	COMDAT ??_C@_06FOPF@parent?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_06FOPF@parent?$AA@ DB 'parent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT
??_C@_08IDGH@movewith?$AA@ DB 'movewith', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT
??_C@_0M@FCIN@parentflags?$AA@ DB 'parentflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT
??_C@_05JCDO@style?$AA@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT
??_C@_0L@MCHI@reflection?$AA@ DB 'reflection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT
??_C@_0N@DCCA@vlight_cache?$AA@ DB 'vlight_cache', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pkvd$ = 8
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseEntity::KeyValue, COMDAT

; 328  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 		// get support for spirit field too
; 330  : 		if( FStrEq( pkvd->szKeyName, "parent" ) || FStrEq( pkvd->szKeyName, "movewith" ))

	push	OFFSET FLAT:??_C@_06FOPF@parent?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L34875
	push	OFFSET FLAT:??_C@_08IDGH@movewith?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34874
$L34875:

; 332  : 			m_iParent = ALLOC_STRING(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 333  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 335  : 		else if( FStrEq( pkvd->szKeyName, "parentflags" ))

	jmp	$L34896
$L34874:
	push	OFFSET FLAT:??_C@_0M@FCIN@parentflags?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34879

; 337  : 			m_iParentFlags = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 338  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 340  : 		else if( FStrEq( pkvd->szKeyName, "style" ))

	jmp	$L34896
$L34879:
	push	OFFSET FLAT:??_C@_05JCDO@style?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34882

; 342  : 			m_iStyle = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 343  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 345  : 		else if( FStrEq( pkvd->szKeyName, "reflection" ))

	jmp	$L34896
$L34882:
	push	OFFSET FLAT:??_C@_0L@MCHI@reflection?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34885

; 348  : 			{

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L34891
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L34892
	jmp	SHORT $L34888
$L34891:

; 349  : 			case 1: pev->effects |= EF_NOREFLECT; break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
	jmp	SHORT $L34888
$L34892:

; 350  : 			case 2: pev->effects |= EF_REFLECTONLY; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L34888:

; 352  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 354  : 		else if( FStrEq(pkvd->szKeyName, "vlight_cache"))

	jmp	SHORT $L34896
$L34885:
	push	OFFSET FLAT:??_C@_0N@DCCA@vlight_cache?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34894

; 356  : 			pev->iuser3 = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+588], eax

; 357  : 			pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 359  : 		else pkvd->fHandled = FALSE;

	jmp	SHORT $L34896
$L34894:
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L34896:

; 360  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseEntity::KeyValue
_TEXT	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT
_$E48	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E47
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E48	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCEnvSound@@@@QAE@PBD@Z	; CEntityFactory<CEnvSound>::CEntityFactory<CEnvSound>
PUBLIC	??_C@_09DMEH@env_sound?$AA@			; `string'
_BSS	SEGMENT
	ALIGN	4

_env_sound DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09DMEH@env_sound?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_09DMEH@env_sound?$AA@ DB 'env_sound', 00H		; `string'
CONST	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT
_$E47	PROC NEAR					; COMDAT

; 896  : LINK_ENTITY_TO_CLASS( env_sound, CEnvSound );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_09DMEH@env_sound?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_env_sound
	call	??0?$CEntityFactory@VCEnvSound@@@@QAE@PBD@Z ; CEntityFactory<CEnvSound>::CEntityFactory<CEnvSound>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E47	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CEnvSound@@UAEPAUdatamap_s@@XZ	; CEnvSound::GetDataDescMap
;	COMDAT ?GetDataDescMap@CEnvSound@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CEnvSound@@UAEPAUdatamap_s@@XZ PROC NEAR ; CEnvSound::GetDataDescMap, COMDAT

; 898  : BEGIN_DATADESC( CEnvSound )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CEnvSound@@2Udatamap_s@@A ; CEnvSound::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CEnvSound@@UAEPAUdatamap_s@@XZ ENDP	; CEnvSound::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CEnvSound@@SAPAUdatamap_s@@XZ	; CEnvSound::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCPointEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CEnvSound@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CEnvSound@@SAPAUdatamap_s@@XZ PROC NEAR	; CEnvSound::GetBaseMap, COMDAT

; 898  : BEGIN_DATADESC( CEnvSound )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCPointEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CEnvSound@@SAPAUdatamap_s@@XZ ENDP		; CEnvSound::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E51
_TEXT	SEGMENT
_$E51	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E50
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E51	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z	; DataMapInit
;	COMDAT _$E50
_TEXT	SEGMENT
_$E50	PROC NEAR					; COMDAT

; 898  : BEGIN_DATADESC( CEnvSound )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CEnvSound_DataDescInit@@3PAUdatamap_s@@A, eax ; CEnvSound_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E50	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S53@?1??DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z PROC NEAR ; DataMapInit, COMDAT

; 898  : BEGIN_DATADESC( CEnvSound )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S53@?1??DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L39336
	mov	cl, BYTE PTR _?$S53@?1??DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S53@?1??DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_09HBNP@CEnvSound?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E54
	call	_atexit
	add	esp, 4
$L39336:
	call	?GetBaseMap@CEnvSound@@SAPAUdatamap_s@@XZ ; CEnvSound::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CEnvSound@@2Udatamap_s@@A+12, eax

; 899  : 	DEFINE_KEYFIELD( m_flRadius, FIELD_FLOAT, "radius" ),
; 900  : 	DEFINE_KEYFIELD( m_flRoomtype, FIELD_FLOAT, "roomtype" ),
; 901  : END_DATADESC()

	mov	edx, 1
	test	edx, edx
	je	SHORT $L39348
	mov	DWORD PTR ?m_DataMap@CEnvSound@@2Udatamap_s@@A+4, 2
	mov	DWORD PTR ?m_DataMap@CEnvSound@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L39349
$L39348:
	mov	DWORD PTR ?m_DataMap@CEnvSound@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CEnvSound@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z@4PAUtypedescription_s@@A
$L39349:
	mov	eax, OFFSET FLAT:?m_DataMap@CEnvSound@@2Udatamap_s@@A ; CEnvSound::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z ENDP	; DataMapInit
_TEXT	ENDS
;	COMDAT _$E54
_TEXT	SEGMENT
_$E54	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCEnvSound@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E54	ENDP
_TEXT	ENDS
PUBLIC	?KeyValue@CEnvSound@@UAEXPAUKeyValueData_s@@@Z	; CEnvSound::KeyValue
EXTRN	_atof:NEAR
;	COMDAT ?KeyValue@CEnvSound@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CEnvSound@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CEnvSound::KeyValue, COMDAT

; 904  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 905  : 	
; 906  : 	if (FStrEq(pkvd->szKeyName, "radius"))

	push	OFFSET FLAT:??_C@_06JGHA@radius?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39355

; 908  : 		m_flRadius = atof(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1764]

; 909  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1
$L39355:

; 911  : 	if (FStrEq(pkvd->szKeyName, "roomtype"))

	push	OFFSET FLAT:??_C@_08JLPP@roomtype?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39356

; 913  : 		m_flRoomtype = atof(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1768]

; 914  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1
$L39356:

; 916  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CEnvSound@@UAEXPAUKeyValueData_s@@@Z ENDP	; CEnvSound::KeyValue
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	?FEnvSoundInRange@@YAHPAVCBaseEntity@@0PAM@Z	; FEnvSoundInRange
PUBLIC	?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z		; GetClassPtr
PUBLIC	??0gametrace_s@@QAE@XZ				; gametrace_s::gametrace_s
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
;	COMDAT ?FEnvSoundInRange@@YAHPAVCBaseEntity@@0PAM@Z
_TEXT	SEGMENT
$T41229 = -112
$T41230 = -124
$T41231 = -136
_pSource$ = 8
_pTarget$ = 12
_pflRange$ = 16
_pSound$ = -4
_vecSpot1$ = -16
_vecSpot2$ = -28
_vecRange$ = -40
_flRange$ = -44
_tr$ = -100
?FEnvSoundInRange@@YAHPAVCBaseEntity@@0PAM@Z PROC NEAR	; FEnvSoundInRange, COMDAT

; 922  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi

; 923  : 	CEnvSound *pSound = GetClassPtr( (CEnvSound *)pSource->pev );

	mov	eax, DWORD PTR _pSource$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z	; GetClassPtr
	add	esp, 4
	mov	DWORD PTR _pSound$[ebp], eax

; 924  : 
; 925  : 	Vector vecSpot1 = pSource->EyePosition();

	lea	edx, DWORD PTR $T41229[ebp]
	push	edx
	mov	eax, DWORD PTR _pSource$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pSource$[ebp]
	call	DWORD PTR [edx+308]
	push	eax
	lea	ecx, DWORD PTR _vecSpot1$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 926  : 	Vector vecSpot2 = pTarget->EyePosition();

	lea	eax, DWORD PTR $T41230[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [edx+308]
	push	eax
	lea	ecx, DWORD PTR _vecSpot2$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 927  : 	Vector vecRange;

	lea	ecx, DWORD PTR _vecRange$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 928  : 	float flRange;
; 929  : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 930  : 
; 931  : 	UTIL_TraceLine( vecSpot1, vecSpot2, ignore_monsters, pSource->edict(), &tr );

	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSource$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	lea	ecx, DWORD PTR _vecSpot2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecSpot1$[ebp]
	push	edx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 932  : 	
; 933  : 	// check if line of sight crosses water boundary, or is blocked
; 934  : 
; 935  : 	if ((tr.fInOpen && tr.fInWater) || tr.flFraction != 1)

	cmp	DWORD PTR _tr$[ebp+8], 0
	je	SHORT $L39377
	cmp	DWORD PTR _tr$[ebp+12], 0
	jne	SHORT $L39376
$L39377:
	cmp	DWORD PTR _tr$[ebp+16], 1065353216	; 3f800000H
	je	SHORT $L39375
$L39376:

; 936  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L39361
$L39375:

; 937  : 
; 938  : 	// calc range from sound entity to player
; 939  : 
; 940  : 	vecRange = tr.vecEndPos - vecSpot1;

	lea	eax, DWORD PTR _vecSpot1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41231[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tr$[ebp+20]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecRange$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecRange$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecRange$[ebp+8], edx

; 941  : 	flRange = vecRange.Length();

	lea	ecx, DWORD PTR _vecRange$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flRange$[ebp]

; 942  : 
; 943  : 	if (pSound->m_flRadius < flRange)		

	mov	eax, DWORD PTR _pSound$[ebp]
	fld	DWORD PTR [eax+1764]
	fcomp	DWORD PTR _flRange$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39379

; 944  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L39361
$L39379:

; 945  : 	
; 946  : 	if (pflRange)

	cmp	DWORD PTR _pflRange$[ebp], 0
	je	SHORT $L39380

; 947  : 		*pflRange = flRange;

	mov	ecx, DWORD PTR _pflRange$[ebp]
	mov	edx, DWORD PTR _flRange$[ebp]
	mov	DWORD PTR [ecx], edx
$L39380:

; 948  : 
; 949  : 	return TRUE;

	mov	eax, 1
$L39361:

; 950  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FEnvSoundInRange@@YAHPAVCBaseEntity@@0PAM@Z ENDP	; FEnvSoundInRange
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T41236 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41236[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
EXTRN	_sqrt:NEAR
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0gametrace_s@@QAE@XZ PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0gametrace_s@@QAE@XZ ENDP				; gametrace_s::gametrace_s
_TEXT	ENDS
PUBLIC	__real@4@00000000000000000000
PUBLIC	__real@8@3ffd8000000000000000
PUBLIC	__real@8@3ffec000000000000000
PUBLIC	?Think@CEnvSound@@UAEXXZ			; CEnvSound::Think
PUBLIC	?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z		; GetClassPtr
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
PUBLIC	?FNullEnt@@YAHPBUedict_s@@@Z			; FNullEnt
;	COMDAT __real@4@00000000000000000000
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT __real@8@3ffd8000000000000000
CONST	SEGMENT
__real@8@3ffd8000000000000000 DQ 03fd0000000000000r ; 0.25
CONST	ENDS
;	COMDAT __real@8@3ffec000000000000000
CONST	SEGMENT
__real@8@3ffec000000000000000 DQ 03fe8000000000000r ; 0.75
CONST	ENDS
;	COMDAT ?Think@CEnvSound@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pentPlayer$ = -8
_pPlayer$ = -12
_flRange$ = -16
?Think@CEnvSound@@UAEXXZ PROC NEAR			; CEnvSound::Think, COMDAT

; 964  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 965  : 	// get pointer to client if visible; FIND_CLIENT_IN_PVS will
; 966  : 	// cycle through visible clients on consecutive calls.
; 967  : 
; 968  : 	edict_t *pentPlayer = FIND_CLIENT_IN_PVS(edict());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+68
	add	esp, 4
	mov	DWORD PTR _pentPlayer$[ebp], eax

; 969  : 	CBasePlayer *pPlayer = NULL;

	mov	DWORD PTR _pPlayer$[ebp], 0

; 970  : 
; 971  : 	if (FNullEnt(pentPlayer))

	mov	eax, DWORD PTR _pentPlayer$[ebp]
	push	eax
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L39389

; 972  : 		goto env_sound_Think_slow; // no player in pvs of sound entity, slow it down

	jmp	$L39391
$L39389:

; 973  :  
; 974  : 	pPlayer = GetClassPtr( (CBasePlayer *)VARS(pentPlayer));

	mov	ecx, DWORD PTR _pentPlayer$[ebp]
	push	ecx
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	push	eax
	call	?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z	; GetClassPtr
	add	esp, 4
	mov	DWORD PTR _pPlayer$[ebp], eax

; 975  : 	float flRange;
; 976  : 
; 977  : 	// check to see if this is the sound entity that is 
; 978  : 	// currently affecting this player
; 979  : 
; 980  : 	if(!FNullEnt(pPlayer->m_pentSndLast) && (pPlayer->m_pentSndLast == ENT(pev))) {

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+2444]
	push	eax
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	$L39405
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	cmp	DWORD PTR [ecx+2444], eax
	jne	SHORT $L39405

; 981  : 
; 982  : 		// this is the entity currently affecting player, check
; 983  : 		// for validity
; 984  : 
; 985  : 		if (pPlayer->m_flSndRoomtype != 0 && pPlayer->m_flSndRange != 0) {

	mov	edx, DWORD PTR _pPlayer$[ebp]
	fld	DWORD PTR [edx+2452]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39399
	mov	eax, DWORD PTR _pPlayer$[ebp]
	fld	DWORD PTR [eax+2448]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39399

; 986  : 		
; 987  : 			// we're looking at a valid sound entity affecting
; 988  : 			// player, make sure it's still valid, update range
; 989  : 
; 990  : 			if (FEnvSoundInRange( this, pPlayer, &flRange ))

	lea	ecx, DWORD PTR _flRange$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?FEnvSoundInRange@@YAHPAVCBaseEntity@@0PAM@Z ; FEnvSoundInRange
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L39400

; 992  : 				pPlayer->m_flSndRange = flRange;

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR _flRange$[ebp]
	mov	DWORD PTR [ecx+2448], edx

; 993  : 				goto env_sound_Think_fast;

	jmp	$L39402
$L39400:

; 997  : 				
; 998  : 				// current sound entity affecting player is no longer valid,
; 999  : 				// flag this state by clearing room_type and range.
; 1000 : 				// NOTE: we do not actually change the player's room_type
; 1001 : 				// NOTE: until we have a new valid room_type to change it to.
; 1002 : 
; 1003 : 				pPlayer->m_flSndRange = 0;

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [eax+2448], 0

; 1004 : 				pPlayer->m_flSndRoomtype = 0;

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [ecx+2452], 0

; 1005 : 				goto env_sound_Think_slow;

	jmp	$L39404
$L39399:

; 1008 : 			// entity is affecting player but is out of range,
; 1009 : 			// wait passively for another entity to usurp it...
; 1010 : 			goto env_sound_Think_slow;

	jmp	$L39406
$L39405:

; 1013 : 
; 1014 : 	// if we got this far, we're looking at an entity that is contending
; 1015 : 	// for current player sound. the closest entity to player wins.
; 1016 : 
; 1017 : 	if (FEnvSoundInRange( this, pPlayer, &flRange)) 

	lea	edx, DWORD PTR _flRange$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?FEnvSoundInRange@@YAHPAVCBaseEntity@@0PAM@Z ; FEnvSoundInRange
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $env_sound_Think_fast$39401

; 1019 : 		if (flRange < pPlayer->m_flSndRange || pPlayer->m_flSndRange == 0) 

	mov	edx, DWORD PTR _pPlayer$[ebp]
	fld	DWORD PTR _flRange$[ebp]
	fcomp	DWORD PTR [edx+2448]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39409
	mov	eax, DWORD PTR _pPlayer$[ebp]
	fld	DWORD PTR [eax+2448]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $env_sound_Think_fast$39401
$L39409:

; 1021 : 			// new entity is closer to player, so it wins.
; 1022 : 			pPlayer->m_pentSndLast = ENT(pev);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [ecx+2444], eax

; 1023 : 			pPlayer->m_flSndRoomtype = m_flRoomtype;

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1768]
	mov	DWORD PTR [edx+2452], ecx

; 1024 : 			pPlayer->m_flSndRange = flRange;

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR _flRange$[ebp]
	mov	DWORD PTR [edx+2448], eax

; 1025 : 			
; 1026 : 			// send room_type command to player's server.
; 1027 : 			// this should be a rare event - once per change of room_type
; 1028 : 			// only!
; 1029 : 			pPlayer->m_iSndRoomtype = (short)m_flRoomtype;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1768]
	call	__ftol
	movsx	edx, ax
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [eax+4140], edx
$env_sound_Think_fast$39401:

; 1049 : 	pev->nextthink = gpGlobals->time + 0.25;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	QWORD PTR __real@8@3ffd8000000000000000
	fst	DWORD PTR -20+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+260]

; 1050 : 	return;

	jmp	SHORT $L39386
$env_sound_Think_slow$39390:

; 1051 : 
; 1052 : env_sound_Think_slow:
; 1053 : 	pev->nextthink = gpGlobals->time + 0.75;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	QWORD PTR __real@8@3ffec000000000000000
	fst	DWORD PTR -24+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+260]

; 1054 : 	return;

	jmp	SHORT $L39386
$L39406:

; 1055 : }

	jmp	SHORT $env_sound_Think_slow$39390
$L39404:
	jmp	SHORT $env_sound_Think_slow$39390
$L39402:
	jmp	SHORT $env_sound_Think_fast$39401
$L39391:
	jmp	SHORT $env_sound_Think_slow$39390
$L39386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CEnvSound@@UAEXXZ ENDP				; CEnvSound::Think
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC NEAR		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32448

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L32447
$L32448:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$L32447:

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?FNullEnt@@YAHPBUedict_s@@@Z PROC NEAR			; FNullEnt, COMDAT

; 195  : inline BOOL FNullEnt(const edict_t* pent)	{ return pent == NULL || FNullEnt(OFFSET(pent)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L41255
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41255
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L41256
$L41255:
	mov	DWORD PTR -4+[ebp], 1
$L41256:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPBUedict_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
PUBLIC	?Spawn@CEnvSound@@UAEXXZ			; CEnvSound::Spawn
;	COMDAT ?Spawn@CEnvSound@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CEnvSound@@UAEXXZ PROC NEAR			; CEnvSound::Spawn, COMDAT

; 1063 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1064 : 	// spread think times
; 1065 : 	pev->nextthink = gpGlobals->time + RANDOM_FLOAT(0.0, 0.5); 

	push	1056964608				; 3f000000H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 1066 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CEnvSound@@UAEXXZ ENDP				; CEnvSound::Spawn
_TEXT	ENDS
;	COMDAT _$E56
_TEXT	SEGMENT
_$E56	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E55
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E56	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCTriggerSound@@@@QAE@PBD@Z	; CEntityFactory<CTriggerSound>::CEntityFactory<CTriggerSound>
PUBLIC	??_C@_0O@JHMK@trigger_sound?$AA@		; `string'
_BSS	SEGMENT
	ALIGN	4

_trigger_sound DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@JHMK@trigger_sound?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0O@JHMK@trigger_sound?$AA@ DB 'trigger_sound', 00H ; `string'
CONST	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT
_$E55	PROC NEAR					; COMDAT

; 1081 : LINK_ENTITY_TO_CLASS( trigger_sound, CTriggerSound );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0O@JHMK@trigger_sound?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_trigger_sound
	call	??0?$CEntityFactory@VCTriggerSound@@@@QAE@PBD@Z ; CEntityFactory<CTriggerSound>::CEntityFactory<CTriggerSound>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E55	ENDP
_TEXT	ENDS
PUBLIC	?KeyValue@CTriggerSound@@UAEXPAUKeyValueData_s@@@Z ; CTriggerSound::KeyValue
EXTRN	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseDelay::KeyValue
;	COMDAT ?KeyValue@CTriggerSound@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CTriggerSound@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CTriggerSound::KeyValue, COMDAT

; 1084 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1085 : 	if (FStrEq(pkvd->szKeyName, "roomtype"))

	push	OFFSET FLAT:??_C@_08JLPP@roomtype?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39469

; 1087 : 		pev->frags = atof(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atof
	add	esp, 4
	fst	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+356]

; 1088 : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 1090 : 	else

	jmp	SHORT $L39470
$L39469:

; 1091 : 		CBaseDelay::KeyValue( pkvd );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z ; CBaseDelay::KeyValue
$L39470:

; 1092 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CTriggerSound@@UAEXPAUKeyValueData_s@@@Z ENDP	; CTriggerSound::KeyValue
_TEXT	ENDS
PUBLIC	?Touch@CTriggerSound@@UAEXPAVCBaseEntity@@@Z	; CTriggerSound::Touch
EXTRN	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z:NEAR ; CBaseDelay::IsLockedByMaster
EXTRN	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z:NEAR ; CBaseDelay::SUB_UseTargets
;	COMDAT ?Touch@CTriggerSound@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
_pPlayer$39477 = -8
?Touch@CTriggerSound@@UAEXPAVCBaseEntity@@@Z PROC NEAR	; CTriggerSound::Touch, COMDAT

; 1095 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1096 : 	if (IsLockedByMaster( pOther ))

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z ; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L39475

; 1097 : 		return;

	jmp	$L39474
$L39475:

; 1098 : 
; 1099 : 	if (pOther->IsPlayer())

	mov	ecx, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	$L39479

; 1101 : 		CBasePlayer *pPlayer = (CBasePlayer*)pOther;

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	DWORD PTR _pPlayer$39477[ebp], eax

; 1102 : 		if (pPlayer->m_pentSndLast != this->edict())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	ecx, DWORD PTR _pPlayer$39477[ebp]
	cmp	DWORD PTR [ecx+2444], eax
	je	SHORT $L39479

; 1104 : 			pPlayer->m_pentSndLast = ENT(pev);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _pPlayer$39477[ebp]
	mov	DWORD PTR [ecx+2444], eax

; 1105 : 			pPlayer->m_flSndRoomtype = pev->frags;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _pPlayer$39477[ebp]
	mov	edx, DWORD PTR [eax+356]
	mov	DWORD PTR [ecx+2452], edx

; 1106 : 			pPlayer->m_iSndRoomtype = (short)pev->frags;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+356]
	call	__ftol
	movsx	edx, ax
	mov	eax, DWORD PTR _pPlayer$39477[ebp]
	mov	DWORD PTR [eax+4140], edx

; 1107 : 			pPlayer->m_flSndRange = 0;

	mov	ecx, DWORD PTR _pPlayer$39477[ebp]
	mov	DWORD PTR [ecx+2448], 0

; 1108 : 
; 1109 : 			SUB_UseTargets(pPlayer, USE_TOGGLE, 0);

	push	0
	push	0
	push	3
	mov	edx, DWORD PTR _pPlayer$39477[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets
$L39479:
$L39474:

; 1112 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CTriggerSound@@UAEXPAVCBaseEntity@@@Z ENDP	; CTriggerSound::Touch
_TEXT	ENDS
PUBLIC	?Spawn@CTriggerSound@@UAEXXZ			; CTriggerSound::Spawn
;	COMDAT ?Spawn@CTriggerSound@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CTriggerSound@@UAEXXZ PROC NEAR			; CTriggerSound::Spawn, COMDAT

; 1115 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1116 : 	pev->solid = SOLID_TRIGGER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 1

; 1117 : 	pev->movetype = MOVETYPE_NONE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 0

; 1118 : 	SET_MODEL(ENT(pev), STRING(pev->model));    // set size and link into world

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+184]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 1119 : 	SetBits( pev->effects, EF_NODRAW );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx

; 1120 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CTriggerSound@@UAEXXZ ENDP			; CTriggerSound::Spawn
_TEXT	ENDS
PUBLIC	?USENTENCEG_InitLRU@@YAXPAEH@Z			; USENTENCEG_InitLRU
;	COMDAT ?USENTENCEG_InitLRU@@YAXPAEH@Z
_TEXT	SEGMENT
_plru$ = 8
_count$ = 12
_i$ = -4
_j$ = -8
_k$ = -12
_temp$ = -16
?USENTENCEG_InitLRU@@YAXPAEH@Z PROC NEAR		; USENTENCEG_InitLRU, COMDAT

; 1148 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1149 : 	int i, j, k;
; 1150 : 	unsigned char temp;
; 1151 : 	
; 1152 : 	if (!fSentencesInit)

	cmp	DWORD PTR ?fSentencesInit@@3HA, 0	; fSentencesInit
	jne	SHORT $L39509

; 1153 : 		return;

	jmp	$L39504
$L39509:

; 1154 : 
; 1155 : 	if (count > CSENTENCE_LRU_MAX)

	cmp	DWORD PTR _count$[ebp], 64		; 00000040H
	jle	SHORT $L39510

; 1156 : 		count = CSENTENCE_LRU_MAX;

	mov	DWORD PTR _count$[ebp], 64		; 00000040H
$L39510:

; 1157 : 
; 1158 : 	for (i = 0; i < count; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39511
$L39512:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L39511:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jge	SHORT $L39513

; 1159 : 		plru[i] = (unsigned char) i;

	mov	edx, DWORD PTR _plru$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR _i$[ebp]
	mov	BYTE PTR [edx], al
	jmp	SHORT $L39512
$L39513:

; 1160 : 
; 1161 : 	// randomize array
; 1162 : 	for (i = 0; i < (count * 4); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39515
$L39516:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L39515:
	mov	edx, DWORD PTR _count$[ebp]
	shl	edx, 2
	cmp	DWORD PTR _i$[ebp], edx
	jge	SHORT $L39517

; 1164 : 		j = RANDOM_LONG(0,count-1);

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	push	eax
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR _j$[ebp], eax

; 1165 : 		k = RANDOM_LONG(0,count-1);

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR _k$[ebp], eax

; 1166 : 		temp = plru[j];

	mov	edx, DWORD PTR _plru$[ebp]
	add	edx, DWORD PTR _j$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _temp$[ebp], al

; 1167 : 		plru[j] = plru[k];

	mov	ecx, DWORD PTR _plru$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _plru$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 1168 : 		plru[k] = temp;

	mov	ecx, DWORD PTR _plru$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR _temp$[ebp]
	mov	BYTE PTR [ecx], dl

; 1169 : 	}

	jmp	SHORT $L39516
$L39517:
$L39504:

; 1170 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?USENTENCEG_InitLRU@@YAXPAEH@Z ENDP			; USENTENCEG_InitLRU
_TEXT	ENDS
PUBLIC	?USENTENCEG_PickSequential@@YAHHPADHH@Z		; USENTENCEG_PickSequential
PUBLIC	??_C@_01PIHH@?$CB?$AA@				; `string'
PUBLIC	??_C@_02MECO@?$CFd?$AA@				; `string'
EXTRN	_strcpy:NEAR
;	COMDAT ??_C@_01PIHH@?$CB?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_01PIHH@?$CB?$AA@ DB '!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
CONST	SEGMENT
??_C@_02MECO@?$CFd?$AA@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ?USENTENCEG_PickSequential@@YAHHPADHH@Z
_TEXT	SEGMENT
_isentenceg$ = 8
_szfound$ = 12
_ipick$ = 16
_freset$ = 20
_szgroupname$ = -4
_count$ = -8
_sznum$ = -16
?USENTENCEG_PickSequential@@YAHHPADHH@Z PROC NEAR	; USENTENCEG_PickSequential, COMDAT

; 1179 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1180 : 	char *szgroupname;
; 1181 : 	unsigned char count;
; 1182 : 	char sznum[8];
; 1183 : 	
; 1184 : 	if (!fSentencesInit)

	cmp	DWORD PTR ?fSentencesInit@@3HA, 0	; fSentencesInit
	jne	SHORT $L39527

; 1185 : 		return -1;

	or	eax, -1
	jmp	$L39523
$L39527:

; 1186 : 
; 1187 : 	if (isentenceg < 0)

	cmp	DWORD PTR _isentenceg$[ebp], 0
	jge	SHORT $L39528

; 1188 : 		return -1;

	or	eax, -1
	jmp	$L39523
$L39528:

; 1189 : 
; 1190 : 	szgroupname = rgsentenceg[isentenceg].szgroupname;

	mov	eax, DWORD PTR _isentenceg$[ebp]
	imul	eax, 100				; 00000064H
	add	eax, OFFSET FLAT:?rgsentenceg@@3PAUsentenceg@@A ; rgsentenceg
	mov	DWORD PTR _szgroupname$[ebp], eax

; 1191 : 	count = rgsentenceg[isentenceg].count;

	mov	ecx, DWORD PTR _isentenceg$[ebp]
	imul	ecx, 100				; 00000064H
	mov	dl, BYTE PTR ?rgsentenceg@@3PAUsentenceg@@A[ecx+32]
	mov	BYTE PTR _count$[ebp], dl

; 1192 : 	
; 1193 : 	if (count == 0)

	mov	eax, DWORD PTR _count$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39529

; 1194 : 		return -1;

	or	eax, -1
	jmp	$L39523
$L39529:

; 1195 : 
; 1196 : 	if (ipick >= count)

	mov	ecx, DWORD PTR _count$[ebp]
	and	ecx, 255				; 000000ffH
	cmp	DWORD PTR _ipick$[ebp], ecx
	jl	SHORT $L39530

; 1197 : 		ipick = count-1;

	mov	edx, DWORD PTR _count$[ebp]
	and	edx, 255				; 000000ffH
	sub	edx, 1
	mov	DWORD PTR _ipick$[ebp], edx
$L39530:

; 1198 : 
; 1199 : 	strcpy(szfound, "!");

	push	OFFSET FLAT:??_C@_01PIHH@?$CB?$AA@	; `string'
	mov	eax, DWORD PTR _szfound$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1200 : 	strcat(szfound, szgroupname);

	mov	ecx, DWORD PTR _szgroupname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szfound$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1201 : 	sprintf(sznum, "%d", ipick);

	mov	eax, DWORD PTR _ipick$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	lea	ecx, DWORD PTR _sznum$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1202 : 	strcat(szfound, sznum);

	lea	edx, DWORD PTR _sznum$[ebp]
	push	edx
	mov	eax, DWORD PTR _szfound$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1203 : 	
; 1204 : 	if (ipick >= count)

	mov	ecx, DWORD PTR _count$[ebp]
	and	ecx, 255				; 000000ffH
	cmp	DWORD PTR _ipick$[ebp], ecx
	jl	SHORT $L39535

; 1206 : 		if (freset)

	cmp	DWORD PTR _freset$[ebp], 0
	je	SHORT $L39534

; 1207 : 			// reset at end of list
; 1208 : 			return 0;

	xor	eax, eax
	jmp	SHORT $L39523
$L39534:

; 1210 : 			return count;

	mov	eax, DWORD PTR _count$[ebp]
	and	eax, 255				; 000000ffH
	jmp	SHORT $L39523
$L39535:

; 1212 : 
; 1213 : 	return ipick + 1;

	mov	eax, DWORD PTR _ipick$[ebp]
	add	eax, 1
$L39523:

; 1214 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?USENTENCEG_PickSequential@@YAHHPADHH@Z ENDP		; USENTENCEG_PickSequential
_TEXT	ENDS
PUBLIC	?USENTENCEG_Pick@@YAHHPAD@Z			; USENTENCEG_Pick
;	COMDAT ?USENTENCEG_Pick@@YAHHPAD@Z
_TEXT	SEGMENT
_isentenceg$ = 8
_szfound$ = 12
_szgroupname$ = -4
_plru$ = -8
_i$ = -12
_count$ = -16
_sznum$ = -24
_ipick$ = -28
_ffound$ = -32
?USENTENCEG_Pick@@YAHHPAD@Z PROC NEAR			; USENTENCEG_Pick, COMDAT

; 1227 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 1228 : 	char *szgroupname;
; 1229 : 	unsigned char *plru;
; 1230 : 	unsigned char i;
; 1231 : 	unsigned char count;
; 1232 : 	char sznum[8];
; 1233 : 	unsigned char ipick;
; 1234 : 	int ffound = FALSE;

	mov	DWORD PTR _ffound$[ebp], 0

; 1235 : 	
; 1236 : 	if (!fSentencesInit)

	cmp	DWORD PTR ?fSentencesInit@@3HA, 0	; fSentencesInit
	jne	SHORT $L39547

; 1237 : 		return -1;

	or	eax, -1
	jmp	$L39539
$L39547:

; 1238 : 
; 1239 : 	if (isentenceg < 0)

	cmp	DWORD PTR _isentenceg$[ebp], 0
	jge	SHORT $L39548

; 1240 : 		return -1;

	or	eax, -1
	jmp	$L39539
$L39548:

; 1241 : 
; 1242 : 	szgroupname = rgsentenceg[isentenceg].szgroupname;

	mov	eax, DWORD PTR _isentenceg$[ebp]
	imul	eax, 100				; 00000064H
	add	eax, OFFSET FLAT:?rgsentenceg@@3PAUsentenceg@@A ; rgsentenceg
	mov	DWORD PTR _szgroupname$[ebp], eax

; 1243 : 	count = rgsentenceg[isentenceg].count;

	mov	ecx, DWORD PTR _isentenceg$[ebp]
	imul	ecx, 100				; 00000064H
	mov	dl, BYTE PTR ?rgsentenceg@@3PAUsentenceg@@A[ecx+32]
	mov	BYTE PTR _count$[ebp], dl

; 1244 : 	plru = rgsentenceg[isentenceg].rgblru;

	mov	eax, DWORD PTR _isentenceg$[ebp]
	imul	eax, 100				; 00000064H
	add	eax, OFFSET FLAT:?rgsentenceg@@3PAUsentenceg@@A+36
	mov	DWORD PTR _plru$[ebp], eax
$L39550:

; 1245 : 
; 1246 : 	while (!ffound)

	cmp	DWORD PTR _ffound$[ebp], 0
	jne	$L39551

; 1248 : 		for (i = 0; i < count; i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $L39552
$L39553:
	mov	cl, BYTE PTR _i$[ebp]
	add	cl, 1
	mov	BYTE PTR _i$[ebp], cl
$L39552:
	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _count$[ebp]
	and	eax, 255				; 000000ffH
	cmp	edx, eax
	jge	SHORT $L39554

; 1249 : 			if (plru[i] != 0xFF)

	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _plru$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+ecx]
	cmp	eax, 255				; 000000ffH
	je	SHORT $L39555

; 1251 : 				ipick = plru[i];

	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _plru$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _ipick$[ebp], al

; 1252 : 				plru[i] = 0xFF;

	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _plru$[ebp]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 1253 : 				ffound = TRUE;

	mov	DWORD PTR _ffound$[ebp], 1

; 1254 : 				break;

	jmp	SHORT $L39554
$L39555:

; 1256 : 
; 1257 : 		if (!ffound)

	jmp	SHORT $L39553
$L39554:
	cmp	DWORD PTR _ffound$[ebp], 0
	jne	SHORT $L39556

; 1258 : 			USENTENCEG_InitLRU(plru, count);

	mov	eax, DWORD PTR _count$[ebp]
	and	eax, 255				; 000000ffH
	push	eax
	mov	ecx, DWORD PTR _plru$[ebp]
	push	ecx
	call	?USENTENCEG_InitLRU@@YAXPAEH@Z		; USENTENCEG_InitLRU
	add	esp, 8

; 1259 : 		else

	jmp	SHORT $L39557
$L39556:

; 1261 : 			strcpy(szfound, "!");

	push	OFFSET FLAT:??_C@_01PIHH@?$CB?$AA@	; `string'
	mov	edx, DWORD PTR _szfound$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1262 : 			strcat(szfound, szgroupname);

	mov	eax, DWORD PTR _szgroupname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szfound$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1263 : 			sprintf(sznum, "%d", ipick);

	mov	edx, DWORD PTR _ipick$[ebp]
	and	edx, 255				; 000000ffH
	push	edx
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	lea	eax, DWORD PTR _sznum$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1264 : 			strcat(szfound, sznum);

	lea	ecx, DWORD PTR _sznum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szfound$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1265 : 			return ipick;

	mov	eax, DWORD PTR _ipick$[ebp]
	and	eax, 255				; 000000ffH
	jmp	SHORT $L39539
$L39557:

; 1267 : 	}

	jmp	$L39550
$L39551:

; 1268 : 	return -1;

	or	eax, -1
$L39539:

; 1269 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?USENTENCEG_Pick@@YAHHPAD@Z ENDP			; USENTENCEG_Pick
_TEXT	ENDS
PUBLIC	?SENTENCEG_GetIndex@@YAHPBD@Z			; SENTENCEG_GetIndex
EXTRN	_strcmp:NEAR
;	COMDAT ?SENTENCEG_GetIndex@@YAHPBD@Z
_TEXT	SEGMENT
_szgroupname$ = 8
_i$ = -4
?SENTENCEG_GetIndex@@YAHPBD@Z PROC NEAR			; SENTENCEG_GetIndex, COMDAT

; 1277 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1278 : 	int i;
; 1279 : 
; 1280 : 	if (!fSentencesInit || !szgroupname)

	cmp	DWORD PTR ?fSentencesInit@@3HA, 0	; fSentencesInit
	je	SHORT $L39563
	cmp	DWORD PTR _szgroupname$[ebp], 0
	jne	SHORT $L39562
$L39563:

; 1281 : 		return -1;

	or	eax, -1
	jmp	SHORT $L39560
$L39562:

; 1282 : 
; 1283 : 	// search rgsentenceg for match on szgroupname
; 1284 : 
; 1285 : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0
$L39565:

; 1286 : 	while (rgsentenceg[i].count)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 100				; 00000064H
	cmp	DWORD PTR ?rgsentenceg@@3PAUsentenceg@@A[eax+32], 0
	je	SHORT $L39566

; 1288 : 		if (!strcmp(szgroupname, rgsentenceg[i].szgroupname))

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 100				; 00000064H
	add	ecx, OFFSET FLAT:?rgsentenceg@@3PAUsentenceg@@A ; rgsentenceg
	push	ecx
	mov	edx, DWORD PTR _szgroupname$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L39567

; 1289 : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $L39560
$L39567:

; 1290 : 	i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 1291 : 	}

	jmp	SHORT $L39565
$L39566:

; 1292 : 
; 1293 : 	return -1;

	or	eax, -1
$L39560:

; 1294 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SENTENCEG_GetIndex@@YAHPBD@Z ENDP			; SENTENCEG_GetIndex
_TEXT	ENDS
PUBLIC	?SENTENCEG_PlayRndI@@YAHPAUedict_s@@HMMHH@Z	; SENTENCEG_PlayRndI
;	COMDAT ?SENTENCEG_PlayRndI@@YAHPAUedict_s@@HMMHH@Z
_TEXT	SEGMENT
_entity$ = 8
_isentenceg$ = 12
_volume$ = 16
_attenuation$ = 20
_flags$ = 24
_pitch$ = 28
_name$ = -64
_ipick$ = -68
?SENTENCEG_PlayRndI@@YAHPAUedict_s@@HMMHH@Z PROC NEAR	; SENTENCEG_PlayRndI, COMDAT

; 1303 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 1304 : 	char name[64];
; 1305 : 	int ipick;
; 1306 : 
; 1307 : 	if (!fSentencesInit)

	cmp	DWORD PTR ?fSentencesInit@@3HA, 0	; fSentencesInit
	jne	SHORT $L39578

; 1308 : 		return -1;

	or	eax, -1
	jmp	SHORT $L39575
$L39578:

; 1309 : 
; 1310 : 	name[0] = 0;

	mov	BYTE PTR _name$[ebp], 0

; 1311 : 
; 1312 : 	ipick = USENTENCEG_Pick(isentenceg, name);

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _isentenceg$[ebp]
	push	ecx
	call	?USENTENCEG_Pick@@YAHHPAD@Z		; USENTENCEG_Pick
	add	esp, 8
	mov	DWORD PTR _ipick$[ebp], eax

; 1313 : 	if (ipick > 0 && name)

	cmp	DWORD PTR _ipick$[ebp], 0
	jle	SHORT $L39579
	lea	edx, DWORD PTR _name$[ebp]
	test	edx, edx
	je	SHORT $L39579

; 1314 : 		EMIT_SOUND_DYN(entity, CHAN_VOICE, name, volume, attenuation, flags, pitch);

	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _attenuation$[ebp]
	push	edx
	mov	eax, DWORD PTR _volume$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _entity$[ebp]
	push	edx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH
$L39579:

; 1315 : 	return ipick;

	mov	eax, DWORD PTR _ipick$[ebp]
$L39575:

; 1316 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SENTENCEG_PlayRndI@@YAHPAUedict_s@@HMMHH@Z ENDP	; SENTENCEG_PlayRndI
_TEXT	ENDS
PUBLIC	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z	; SENTENCEG_PlayRndSz
PUBLIC	??_C@_0BL@GEEN@No?5such?5sentence?5group?5?$CFs?6?$AA@ ; `string'
;	COMDAT ??_C@_0BL@GEEN@No?5such?5sentence?5group?5?$CFs?6?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0BL@GEEN@No?5such?5sentence?5group?5?$CFs?6?$AA@ DB 'No such senten'
	DB	'ce group %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z
_TEXT	SEGMENT
_entity$ = 8
_szgroupname$ = 12
_volume$ = 16
_attenuation$ = 20
_flags$ = 24
_pitch$ = 28
_name$ = -64
_ipick$ = -68
_isentenceg$ = -72
?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z PROC NEAR ; SENTENCEG_PlayRndSz, COMDAT

; 1322 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi

; 1323 : 	char name[64];
; 1324 : 	int ipick;
; 1325 : 	int isentenceg;
; 1326 : 
; 1327 : 	if (!fSentencesInit)

	cmp	DWORD PTR ?fSentencesInit@@3HA, 0	; fSentencesInit
	jne	SHORT $L39591

; 1328 : 		return -1;

	or	eax, -1
	jmp	SHORT $L39587
$L39591:

; 1329 : 
; 1330 : 	name[0] = 0;

	mov	BYTE PTR _name$[ebp], 0

; 1331 : 
; 1332 : 	isentenceg = SENTENCEG_GetIndex(szgroupname);

	mov	eax, DWORD PTR _szgroupname$[ebp]
	push	eax
	call	?SENTENCEG_GetIndex@@YAHPBD@Z		; SENTENCEG_GetIndex
	add	esp, 4
	mov	DWORD PTR _isentenceg$[ebp], eax

; 1333 : 	if (isentenceg < 0)

	cmp	DWORD PTR _isentenceg$[ebp], 0
	jge	SHORT $L39592

; 1335 : 		ALERT( at_console, "No such sentence group %s\n", szgroupname );

	mov	ecx, DWORD PTR _szgroupname$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BL@GEEN@No?5such?5sentence?5group?5?$CFs?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1336 : 		return -1;

	or	eax, -1
	jmp	SHORT $L39587
$L39592:

; 1338 : 
; 1339 : 	ipick = USENTENCEG_Pick(isentenceg, name);

	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _isentenceg$[ebp]
	push	eax
	call	?USENTENCEG_Pick@@YAHHPAD@Z		; USENTENCEG_Pick
	add	esp, 8
	mov	DWORD PTR _ipick$[ebp], eax

; 1340 : 	if (ipick >= 0 && name[0])

	cmp	DWORD PTR _ipick$[ebp], 0
	jl	SHORT $L39594
	movsx	ecx, BYTE PTR _name$[ebp]
	test	ecx, ecx
	je	SHORT $L39594

; 1341 : 		EMIT_SOUND_DYN(entity, CHAN_VOICE, name, volume, attenuation, flags, pitch);

	mov	edx, DWORD PTR _pitch$[ebp]
	push	edx
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _attenuation$[ebp]
	push	ecx
	mov	edx, DWORD PTR _volume$[ebp]
	push	edx
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH
$L39594:

; 1342 : 
; 1343 : 	return ipick;

	mov	eax, DWORD PTR _ipick$[ebp]
$L39587:

; 1344 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ENDP	; SENTENCEG_PlayRndSz
_TEXT	ENDS
PUBLIC	?SENTENCEG_PlaySequentialSz@@YAHPAUedict_s@@PBDMMHHHH@Z ; SENTENCEG_PlaySequentialSz
;	COMDAT ?SENTENCEG_PlaySequentialSz@@YAHPAUedict_s@@PBDMMHHHH@Z
_TEXT	SEGMENT
_entity$ = 8
_szgroupname$ = 12
_volume$ = 16
_attenuation$ = 20
_flags$ = 24
_pitch$ = 28
_ipick$ = 32
_freset$ = 36
_name$ = -64
_ipicknext$ = -68
_isentenceg$ = -72
?SENTENCEG_PlaySequentialSz@@YAHPAUedict_s@@PBDMMHHHH@Z PROC NEAR ; SENTENCEG_PlaySequentialSz, COMDAT

; 1350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi

; 1351 : 	char name[64];
; 1352 : 	int ipicknext;
; 1353 : 	int isentenceg;
; 1354 : 
; 1355 : 	if (!fSentencesInit)

	cmp	DWORD PTR ?fSentencesInit@@3HA, 0	; fSentencesInit
	jne	SHORT $L39608

; 1356 : 		return -1;

	or	eax, -1
	jmp	SHORT $L39604
$L39608:

; 1357 : 
; 1358 : 	name[0] = 0;

	mov	BYTE PTR _name$[ebp], 0

; 1359 : 
; 1360 : 	isentenceg = SENTENCEG_GetIndex(szgroupname);

	mov	eax, DWORD PTR _szgroupname$[ebp]
	push	eax
	call	?SENTENCEG_GetIndex@@YAHPBD@Z		; SENTENCEG_GetIndex
	add	esp, 4
	mov	DWORD PTR _isentenceg$[ebp], eax

; 1361 : 	if (isentenceg < 0)

	cmp	DWORD PTR _isentenceg$[ebp], 0
	jge	SHORT $L39609

; 1362 : 		return -1;

	or	eax, -1
	jmp	SHORT $L39604
$L39609:

; 1363 : 
; 1364 : 	ipicknext = USENTENCEG_PickSequential(isentenceg, name, ipick, freset);

	mov	ecx, DWORD PTR _freset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ipick$[ebp]
	push	edx
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _isentenceg$[ebp]
	push	ecx
	call	?USENTENCEG_PickSequential@@YAHHPADHH@Z	; USENTENCEG_PickSequential
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ipicknext$[ebp], eax

; 1365 : 	if (ipicknext >= 0 && name[0])

	cmp	DWORD PTR _ipicknext$[ebp], 0
	jl	SHORT $L39610
	movsx	edx, BYTE PTR _name$[ebp]
	test	edx, edx
	je	SHORT $L39610

; 1366 : 		EMIT_SOUND_DYN(entity, CHAN_VOICE, name, volume, attenuation, flags, pitch);

	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _attenuation$[ebp]
	push	edx
	mov	eax, DWORD PTR _volume$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _entity$[ebp]
	push	edx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH
$L39610:

; 1367 : 	return ipicknext;

	mov	eax, DWORD PTR _ipicknext$[ebp]
$L39604:

; 1368 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SENTENCEG_PlaySequentialSz@@YAHPAUedict_s@@PBDMMHHHH@Z ENDP ; SENTENCEG_PlaySequentialSz
_TEXT	ENDS
PUBLIC	?SENTENCEG_Stop@@YAXPAUedict_s@@HH@Z		; SENTENCEG_Stop
PUBLIC	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z		; STOP_SOUND
;	COMDAT ?SENTENCEG_Stop@@YAXPAUedict_s@@HH@Z
_TEXT	SEGMENT
_entity$ = 8
_isentenceg$ = 12
_ipick$ = 16
_buffer$ = -64
_sznum$ = -72
?SENTENCEG_Stop@@YAXPAUedict_s@@HH@Z PROC NEAR		; SENTENCEG_Stop, COMDAT

; 1375 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi

; 1376 : 	char buffer[64];
; 1377 : 	char sznum[8];
; 1378 : 	
; 1379 : 	if (!fSentencesInit)

	cmp	DWORD PTR ?fSentencesInit@@3HA, 0	; fSentencesInit
	jne	SHORT $L39618

; 1380 : 		return;

	jmp	SHORT $L39615
$L39618:

; 1381 : 
; 1382 : 	if (isentenceg < 0 || ipick < 0)

	cmp	DWORD PTR _isentenceg$[ebp], 0
	jl	SHORT $L39620
	cmp	DWORD PTR _ipick$[ebp], 0
	jge	SHORT $L39619
$L39620:

; 1383 : 		return;

	jmp	SHORT $L39615
$L39619:

; 1384 : 	
; 1385 : 	strcpy(buffer, "!");

	push	OFFSET FLAT:??_C@_01PIHH@?$CB?$AA@	; `string'
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1386 : 	strcat(buffer, rgsentenceg[isentenceg].szgroupname);

	mov	ecx, DWORD PTR _isentenceg$[ebp]
	imul	ecx, 100				; 00000064H
	add	ecx, OFFSET FLAT:?rgsentenceg@@3PAUsentenceg@@A ; rgsentenceg
	push	ecx
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1387 : 	sprintf(sznum, "%d", ipick);

	mov	eax, DWORD PTR _ipick$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	lea	ecx, DWORD PTR _sznum$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1388 : 	strcat(buffer, sznum);

	lea	edx, DWORD PTR _sznum$[ebp]
	push	edx
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1389 : 
; 1390 : 	STOP_SOUND(entity, CHAN_VOICE, buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _entity$[ebp]
	push	edx
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH
$L39615:

; 1391 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SENTENCEG_Stop@@YAXPAUedict_s@@HH@Z ENDP		; SENTENCEG_Stop
_TEXT	ENDS
;	COMDAT ?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z PROC NEAR		; STOP_SOUND, COMDAT

; 614  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 615  : 	EMIT_SOUND_DYN( entity, channel, sample, 0, 0, SND_STOP, PITCH_NORM );

	push	100					; 00000064H
	push	32					; 00000020H
	push	0
	push	0
	mov	eax, DWORD PTR _sample$[ebp]
	push	eax
	mov	ecx, DWORD PTR _channel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entity$[ebp]
	push	edx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 616  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z ENDP			; STOP_SOUND
_TEXT	ENDS
PUBLIC	?SENTENCEG_Init@@YAXXZ				; SENTENCEG_Init
PUBLIC	??_C@_0BE@HEJL@sound?1sentences?4txt?$AA@	; `string'
PUBLIC	??_C@_0CG@DGLM@Too?5many?5sentences?5in?5sentences?4@ ; `string'
PUBLIC	??_C@_0CE@NHFB@Sentence?5?$CFs?5longer?5than?5?$CFd?5lette@ ; `string'
PUBLIC	??_C@_0CM@LDAL@Too?5many?5sentence?5groups?5in?5sent@ ; `string'
EXTRN	_isalpha:NEAR
EXTRN	_isdigit:NEAR
EXTRN	_memset:NEAR
;	COMDAT ??_C@_0BE@HEJL@sound?1sentences?4txt?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0BE@HEJL@sound?1sentences?4txt?$AA@ DB 'sound/sentences.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DGLM@Too?5many?5sentences?5in?5sentences?4@
CONST	SEGMENT
??_C@_0CG@DGLM@Too?5many?5sentences?5in?5sentences?4@ DB 'Too many senten'
	DB	'ces in sentences.txt!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NHFB@Sentence?5?$CFs?5longer?5than?5?$CFd?5lette@
CONST	SEGMENT
??_C@_0CE@NHFB@Sentence?5?$CFs?5longer?5than?5?$CFd?5lette@ DB 'Sentence '
	DB	'%s longer than %d letters', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LDAL@Too?5many?5sentence?5groups?5in?5sent@
CONST	SEGMENT
??_C@_0CM@LDAL@Too?5many?5sentence?5groups?5in?5sent@ DB 'Too many senten'
	DB	'ce groups in sentences.txt!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?SENTENCEG_Init@@YAXXZ
_TEXT	SEGMENT
_buffer$ = -512
_szgroup$ = -576
_i$ = -580
_j$ = -584
_isentencegs$ = -588
_filePos$ = -592
_fileSize$ = -596
_pMemFile$ = -600
_pString$39650 = -604
?SENTENCEG_Init@@YAXXZ PROC NEAR			; SENTENCEG_Init, COMDAT

; 1398 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 672				; 000002a0H
	push	ebx
	push	esi
	push	edi

; 1399 : 	char buffer[512];
; 1400 : 	char szgroup[64];
; 1401 : 	int i, j;
; 1402 : 	int isentencegs;
; 1403 : 
; 1404 : 	if (fSentencesInit)

	cmp	DWORD PTR ?fSentencesInit@@3HA, 0	; fSentencesInit
	je	SHORT $L39628

; 1405 : 		return;

	jmp	$L39622
$L39628:

; 1406 : 
; 1407 : 	memset(gszallsentencenames, 0, CVOXFILESENTENCEMAX * CBSENTENCENAME_MAX);

	push	131072					; 00020000H
	push	0
	push	OFFSET FLAT:?gszallsentencenames@@3PAY0CA@DA ; gszallsentencenames
	call	_memset
	add	esp, 12					; 0000000cH

; 1408 : 	gcallsentences = 0;

	mov	DWORD PTR ?gcallsentences@@3HA, 0	; gcallsentences

; 1409 : 
; 1410 : 	memset(rgsentenceg, 0, CSENTENCEG_MAX * sizeof(SENTENCEG));

	push	409600					; 00064000H
	push	0
	push	OFFSET FLAT:?rgsentenceg@@3PAUsentenceg@@A ; rgsentenceg
	call	_memset
	add	esp, 12					; 0000000cH

; 1411 : 	memset(buffer, 0, 512);

	push	512					; 00000200H
	push	0
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1412 : 	memset(szgroup, 0, 64);

	push	64					; 00000040H
	push	0
	lea	ecx, DWORD PTR _szgroup$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1413 : 	isentencegs = -1;

	mov	DWORD PTR _isentencegs$[ebp], -1

; 1414 : 
; 1415 : 	
; 1416 : 	int filePos = 0, fileSize;

	mov	DWORD PTR _filePos$[ebp], 0

; 1417 : 	byte *pMemFile = g_engfuncs.pfnLoadFileForMe( "sound/sentences.txt", &fileSize );

	lea	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BE@HEJL@sound?1sentences?4txt?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+380
	add	esp, 8
	mov	DWORD PTR _pMemFile$[ebp], eax

; 1418 : 	if ( !pMemFile )

	cmp	DWORD PTR _pMemFile$[ebp], 0
	jne	SHORT $L39634

; 1419 : 		return;

	jmp	$L39622
$L39634:

; 1420 : 
; 1421 : 	// for each line in the file...
; 1422 : 	while ( memfgets(pMemFile, fileSize, filePos, buffer, 511) != NULL )

	push	511					; 000001ffH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _filePos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _pMemFile$[ebp]
	push	eax
	call	?memfgets@@YAPADPAEHAAHPADH@Z		; memfgets
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$L39637

; 1424 : 		// skip whitespace
; 1425 : 		i = 0;

	mov	DWORD PTR _i$[ebp], 0
$L39639:

; 1426 : 		while(buffer[i] && buffer[i] == ' ')

	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	test	edx, edx
	je	SHORT $L39640
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $L39640

; 1427 : 			i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $L39639
$L39640:

; 1428 : 		
; 1429 : 		if (!buffer[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $L39641

; 1430 : 			continue;

	jmp	$L39634
$L39641:

; 1431 : 
; 1432 : 		if (buffer[i] == '/' || !isalpha(buffer[i]))

	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $L39643
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	push	edx
	call	_isalpha
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39642
$L39643:

; 1433 : 			continue;

	jmp	$L39634
$L39642:

; 1434 : 
; 1435 : 		// get sentence name
; 1436 : 		j = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _j$[ebp], eax
$L39645:

; 1437 : 		while (buffer[j] && buffer[j] != ' ')

	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	test	edx, edx
	je	SHORT $L39646
	mov	eax, DWORD PTR _j$[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $L39646

; 1438 : 			j++;

	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	jmp	SHORT $L39645
$L39646:

; 1439 : 
; 1440 : 		if (!buffer[j])

	mov	eax, DWORD PTR _j$[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $L39647

; 1441 : 			continue;

	jmp	$L39634
$L39647:

; 1442 : 
; 1443 : 		if (gcallsentences > CVOXFILESENTENCEMAX)

	cmp	DWORD PTR ?gcallsentences@@3HA, 4096	; gcallsentences, 00001000H
	jle	SHORT $L39648

; 1445 : 			ALERT (at_error, "Too many sentences in sentences.txt!\n");

	push	OFFSET FLAT:??_C@_0CG@DGLM@Too?5many?5sentences?5in?5sentences?4@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1446 : 			break;

	jmp	$L39637
$L39648:

; 1448 : 
; 1449 : 		// null-terminate name and save in sentences array
; 1450 : 		buffer[j] = 0;

	mov	edx, DWORD PTR _j$[ebp]
	mov	BYTE PTR _buffer$[ebp+edx], 0

; 1451 : 		const char *pString = buffer + i;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _buffer$[ebp+eax]
	mov	DWORD PTR _pString$39650[ebp], ecx

; 1452 : 
; 1453 : 		if ( strlen( pString ) >= CBSENTENCENAME_MAX )

	mov	edx, DWORD PTR _pString$39650[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 32					; 00000020H
	jb	SHORT $L39651

; 1454 : 			ALERT( at_warning, "Sentence %s longer than %d letters\n", pString, CBSENTENCENAME_MAX-1 );

	push	31					; 0000001fH
	mov	eax, DWORD PTR _pString$39650[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CE@NHFB@Sentence?5?$CFs?5longer?5than?5?$CFd?5lette@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H
$L39651:

; 1455 : 
; 1456 : 		strcpy( gszallsentencenames[gcallsentences++], pString );

	mov	ecx, DWORD PTR _pString$39650[ebp]
	push	ecx
	mov	edx, DWORD PTR ?gcallsentences@@3HA	; gcallsentences
	shl	edx, 5
	add	edx, OFFSET FLAT:?gszallsentencenames@@3PAY0CA@DA ; gszallsentencenames
	mov	DWORD PTR -608+[ebp], edx
	mov	eax, DWORD PTR -608+[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gcallsentences@@3HA	; gcallsentences
	add	ecx, 1
	mov	DWORD PTR ?gcallsentences@@3HA, ecx	; gcallsentences
	call	_strcpy
	add	esp, 8

; 1457 : 
; 1458 : 		j--;

	mov	edx, DWORD PTR _j$[ebp]
	sub	edx, 1
	mov	DWORD PTR _j$[ebp], edx

; 1459 : 		if (j <= i)

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jg	SHORT $L39653

; 1460 : 			continue;

	jmp	$L39634
$L39653:

; 1461 : 		if (!isdigit(buffer[j]))

	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39654

; 1462 : 			continue;

	jmp	$L39634
$L39654:

; 1463 : 
; 1464 : 		// cut out suffix numbers
; 1465 : 		while (j > i && isdigit(buffer[j]))

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jle	SHORT $L39657
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $L39657

; 1466 : 			j--;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L39654
$L39657:

; 1467 : 
; 1468 : 		if (j <= i)

	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _i$[ebp]
	jg	SHORT $L39658

; 1469 : 			continue;

	jmp	$L39634
$L39658:

; 1470 : 
; 1471 : 		buffer[j+1] = 0;

	mov	edx, DWORD PTR _j$[ebp]
	mov	BYTE PTR _buffer$[ebp+edx+1], 0

; 1472 : 		
; 1473 : 		// if new name doesn't match previous group name, 
; 1474 : 		// make a new group.
; 1475 : 
; 1476 : 		if (strcmp(szgroup, &(buffer[i])))

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _buffer$[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _szgroup$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	$L39659

; 1478 : 			// name doesn't match with prev name,
; 1479 : 			// copy name into group, init count to 1
; 1480 : 			isentencegs++;

	mov	eax, DWORD PTR _isentencegs$[ebp]
	add	eax, 1
	mov	DWORD PTR _isentencegs$[ebp], eax

; 1481 : 			if (isentencegs >= CSENTENCEG_MAX)

	cmp	DWORD PTR _isentencegs$[ebp], 4096	; 00001000H
	jl	SHORT $L39660

; 1483 : 				ALERT (at_error, "Too many sentence groups in sentences.txt!\n");

	push	OFFSET FLAT:??_C@_0CM@LDAL@Too?5many?5sentence?5groups?5in?5sent@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1484 : 				break;

	jmp	$L39637
$L39660:

; 1486 : 
; 1487 : 			strcpy(rgsentenceg[isentencegs].szgroupname, &(buffer[i]));

	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _buffer$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _isentencegs$[ebp]
	imul	eax, 100				; 00000064H
	add	eax, OFFSET FLAT:?rgsentenceg@@3PAUsentenceg@@A ; rgsentenceg
	push	eax
	call	_strcpy
	add	esp, 8

; 1488 : 			rgsentenceg[isentencegs].count = 1;

	mov	ecx, DWORD PTR _isentencegs$[ebp]
	imul	ecx, 100				; 00000064H
	mov	DWORD PTR ?rgsentenceg@@3PAUsentenceg@@A[ecx+32], 1

; 1489 : 
; 1490 : 			strcpy(szgroup, &(buffer[i]));

	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR _buffer$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR _szgroup$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1491 : 
; 1492 : 			continue;

	jmp	$L39634
$L39659:

; 1496 : 			//name matches with previous, increment group count
; 1497 : 			if (isentencegs >= 0)

	cmp	DWORD PTR _isentencegs$[ebp], 0
	jl	SHORT $L39663

; 1498 : 				rgsentenceg[isentencegs].count++;

	mov	edx, DWORD PTR _isentencegs$[ebp]
	imul	edx, 100				; 00000064H
	mov	eax, DWORD PTR ?rgsentenceg@@3PAUsentenceg@@A[edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _isentencegs$[ebp]
	imul	ecx, 100				; 00000064H
	mov	DWORD PTR ?rgsentenceg@@3PAUsentenceg@@A[ecx+32], eax
$L39663:

; 1500 : 	}

	jmp	$L39634
$L39637:

; 1501 : 
; 1502 : 	g_engfuncs.pfnFreeFile( pMemFile );

	mov	edx, DWORD PTR _pMemFile$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+384
	add	esp, 4

; 1503 : 	
; 1504 : 	fSentencesInit = TRUE;

	mov	DWORD PTR ?fSentencesInit@@3HA, 1	; fSentencesInit

; 1505 : 
; 1506 : 	// init lru lists
; 1507 : 
; 1508 : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0
$L39665:

; 1509 : 
; 1510 : 	while (rgsentenceg[i].count && i < CSENTENCEG_MAX)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 100				; 00000064H
	cmp	DWORD PTR ?rgsentenceg@@3PAUsentenceg@@A[eax+32], 0
	je	SHORT $L39666
	cmp	DWORD PTR _i$[ebp], 4096		; 00001000H
	jge	SHORT $L39666

; 1512 : 		USENTENCEG_InitLRU(&(rgsentenceg[i].rgblru[0]), rgsentenceg[i].count);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 100				; 00000064H
	mov	edx, DWORD PTR ?rgsentenceg@@3PAUsentenceg@@A[ecx+32]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 100				; 00000064H
	add	eax, OFFSET FLAT:?rgsentenceg@@3PAUsentenceg@@A+36
	push	eax
	call	?USENTENCEG_InitLRU@@YAXPAEH@Z		; USENTENCEG_InitLRU
	add	esp, 8

; 1513 : 		i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 1514 : 	}

	jmp	SHORT $L39665
$L39666:
$L39622:

; 1515 : 
; 1516 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SENTENCEG_Init@@YAXXZ ENDP				; SENTENCEG_Init
_TEXT	ENDS
PUBLIC	?SENTENCEG_Lookup@@YAHPBDPAD@Z			; SENTENCEG_Lookup
EXTRN	_stricmp:NEAR
;	COMDAT ?SENTENCEG_Lookup@@YAHPBDPAD@Z
_TEXT	SEGMENT
_sample$ = 8
_sentencenum$ = 12
_sznum$ = -8
_i$ = -12
?SENTENCEG_Lookup@@YAHPBDPAD@Z PROC NEAR		; SENTENCEG_Lookup, COMDAT

; 1521 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1522 : 	char sznum[8];
; 1523 : 
; 1524 : 	int i;
; 1525 : 	// this is a sentence name; lookup sentence number
; 1526 : 	// and give to engine as string.
; 1527 : 	for (i = 0; i < gcallsentences; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39673
$L39674:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L39673:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?gcallsentences@@3HA	; gcallsentences
	jge	SHORT $L39675

; 1528 : 		if (!stricmp(gszallsentencenames[i], sample+1))

	mov	edx, DWORD PTR _sample$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	add	eax, OFFSET FLAT:?gszallsentencenames@@3PAY0CA@DA ; gszallsentencenames
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L39676

; 1530 : 			if (sentencenum)

	cmp	DWORD PTR _sentencenum$[ebp], 0
	je	SHORT $L39677

; 1532 : 				strcpy(sentencenum, "!");

	push	OFFSET FLAT:??_C@_01PIHH@?$CB?$AA@	; `string'
	mov	ecx, DWORD PTR _sentencenum$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1533 : 				sprintf(sznum, "%d", i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	lea	eax, DWORD PTR _sznum$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1534 : 				strcat(sentencenum, sznum);

	lea	ecx, DWORD PTR _sznum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sentencenum$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$L39677:

; 1536 : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $L39670
$L39676:

; 1538 : 	// sentence name not found!
; 1539 : 	return -1;

	jmp	SHORT $L39674
$L39675:
	or	eax, -1
$L39670:

; 1540 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SENTENCEG_Lookup@@YAHPBDPAD@Z ENDP			; SENTENCEG_Lookup
_TEXT	ENDS
PUBLIC	??_C@_0CE@HOCG@Unable?5to?5find?5?$CFs?5in?5sentences?4t@ ; `string'
;	COMDAT ??_C@_0CE@HOCG@Unable?5to?5find?5?$CFs?5in?5sentences?4t@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0CE@HOCG@Unable?5to?5find?5?$CFs?5in?5sentences?4t@ DB 'Unable to f'
	DB	'ind %s in sentences.txt', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
_volume$ = 20
_attenuation$ = 24
_flags$ = 28
_pitch$ = 32
_name$39688 = -32
?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z PROC NEAR	; EMIT_SOUND_DYN, COMDAT

; 1544 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 1545 : 	if (sample && *sample == '!')

	cmp	DWORD PTR _sample$[ebp], 0
	je	SHORT $L39687
	mov	eax, DWORD PTR _sample$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	jne	SHORT $L39687

; 1547 : 		char name[32];
; 1548 : 		if (SENTENCEG_Lookup(sample, name) >= 0)

	lea	edx, DWORD PTR _name$39688[ebp]
	push	edx
	mov	eax, DWORD PTR _sample$[ebp]
	push	eax
	call	?SENTENCEG_Lookup@@YAHPBDPAD@Z		; SENTENCEG_Lookup
	add	esp, 8
	test	eax, eax
	jl	SHORT $L39689

; 1549 : 				EMIT_SOUND_DYN2(entity, channel, name, volume, attenuation, flags, pitch);

	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	lea	edx, DWORD PTR _name$39688[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+116
	add	esp, 28					; 0000001cH

; 1550 : 		else

	jmp	SHORT $L39690
$L39689:

; 1551 : 			ALERT( at_aiconsole, "Unable to find %s in sentences.txt\n", sample );

	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CE@HOCG@Unable?5to?5find?5?$CFs?5in?5sentences?4t@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L39690:

; 1553 : 	else

	jmp	SHORT $L39692
$L39687:

; 1554 : 		EMIT_SOUND_DYN2(entity, channel, sample, volume, attenuation, flags, pitch);

	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _attenuation$[ebp]
	push	edx
	mov	eax, DWORD PTR _volume$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sample$[ebp]
	push	ecx
	mov	edx, DWORD PTR _channel$[ebp]
	push	edx
	mov	eax, DWORD PTR _entity$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+116
	add	esp, 28					; 0000001cH
$L39692:

; 1555 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ENDP		; EMIT_SOUND_DYN
_TEXT	ENDS
PUBLIC	__real@8@3ffaccccccccccccd000
PUBLIC	?EMIT_SOUND_SUIT@@YAXPAUedict_s@@PBD@Z		; EMIT_SOUND_SUIT
PUBLIC	??_C@_0L@CIEP@suitvolume?$AA@			; `string'
;	COMDAT ??_C@_0L@CIEP@suitvolume?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0L@CIEP@suitvolume?$AA@ DB 'suitvolume', 00H	; `string'
CONST	ENDS
;	COMDAT __real@8@3ffaccccccccccccd000
CONST	SEGMENT
__real@8@3ffaccccccccccccd000 DQ 03fa999999999999ar ; 0.05
CONST	ENDS
;	COMDAT ?EMIT_SOUND_SUIT@@YAXPAUedict_s@@PBD@Z
_TEXT	SEGMENT
_entity$ = 8
_sample$ = 12
_fvol$ = -4
_pitch$ = -8
?EMIT_SOUND_SUIT@@YAXPAUedict_s@@PBD@Z PROC NEAR	; EMIT_SOUND_SUIT, COMDAT

; 1560 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1561 : 	float fvol;
; 1562 : 	int pitch = PITCH_NORM;

	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H

; 1563 : 
; 1564 : 	fvol = CVAR_GET_FLOAT("suitvolume");

	push	OFFSET FLAT:??_C@_0L@CIEP@suitvolume?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fstp	DWORD PTR _fvol$[ebp]

; 1565 : 	if (RANDOM_LONG(0,1))

	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	je	SHORT $L39700

; 1566 : 		pitch = RANDOM_LONG(0,6) + 98;

	push	6
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 98					; 00000062H
	mov	DWORD PTR _pitch$[ebp], eax
$L39700:

; 1567 : 
; 1568 : 	if (fvol > 0.05)

	fld	DWORD PTR _fvol$[ebp]
	fcomp	QWORD PTR __real@8@3ffaccccccccccccd000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39701

; 1569 : 		EMIT_SOUND_DYN(entity, CHAN_STATIC, sample, fvol, ATTN_NORM, 0, pitch);

	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	push	0
	push	1061997773				; 3f4ccccdH
	mov	ecx, DWORD PTR _fvol$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	push	6
	mov	eax, DWORD PTR _entity$[ebp]
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH
$L39701:

; 1570 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND_SUIT@@YAXPAUedict_s@@PBD@Z ENDP		; EMIT_SOUND_SUIT
_TEXT	ENDS
PUBLIC	?EMIT_GROUPID_SUIT@@YAXPAUedict_s@@H@Z		; EMIT_GROUPID_SUIT
;	COMDAT ?EMIT_GROUPID_SUIT@@YAXPAUedict_s@@H@Z
_TEXT	SEGMENT
_entity$ = 8
_isentenceg$ = 12
_fvol$ = -4
_pitch$ = -8
?EMIT_GROUPID_SUIT@@YAXPAUedict_s@@H@Z PROC NEAR	; EMIT_GROUPID_SUIT, COMDAT

; 1575 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1576 : 	float fvol;
; 1577 : 	int pitch = PITCH_NORM;

	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H

; 1578 : 
; 1579 : 	fvol = CVAR_GET_FLOAT("suitvolume");

	push	OFFSET FLAT:??_C@_0L@CIEP@suitvolume?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fstp	DWORD PTR _fvol$[ebp]

; 1580 : 	if (RANDOM_LONG(0,1))

	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	je	SHORT $L39709

; 1581 : 		pitch = RANDOM_LONG(0,6) + 98;

	push	6
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 98					; 00000062H
	mov	DWORD PTR _pitch$[ebp], eax
$L39709:

; 1582 : 
; 1583 : 	if (fvol > 0.05)

	fld	DWORD PTR _fvol$[ebp]
	fcomp	QWORD PTR __real@8@3ffaccccccccccccd000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39710

; 1584 : 		SENTENCEG_PlayRndI(entity, isentenceg, fvol, ATTN_NORM, 0, pitch);

	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	push	0
	push	1061997773				; 3f4ccccdH
	mov	ecx, DWORD PTR _fvol$[ebp]
	push	ecx
	mov	edx, DWORD PTR _isentenceg$[ebp]
	push	edx
	mov	eax, DWORD PTR _entity$[ebp]
	push	eax
	call	?SENTENCEG_PlayRndI@@YAHPAUedict_s@@HMMHH@Z ; SENTENCEG_PlayRndI
	add	esp, 24					; 00000018H
$L39710:

; 1585 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_GROUPID_SUIT@@YAXPAUedict_s@@H@Z ENDP		; EMIT_GROUPID_SUIT
_TEXT	ENDS
PUBLIC	?EMIT_GROUPNAME_SUIT@@YAXPAUedict_s@@PBD@Z	; EMIT_GROUPNAME_SUIT
;	COMDAT ?EMIT_GROUPNAME_SUIT@@YAXPAUedict_s@@PBD@Z
_TEXT	SEGMENT
_entity$ = 8
_groupname$ = 12
_fvol$ = -4
_pitch$ = -8
?EMIT_GROUPNAME_SUIT@@YAXPAUedict_s@@PBD@Z PROC NEAR	; EMIT_GROUPNAME_SUIT, COMDAT

; 1590 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1591 : 	float fvol;
; 1592 : 	int pitch = PITCH_NORM;

	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H

; 1593 : 
; 1594 : 	fvol = CVAR_GET_FLOAT("suitvolume");

	push	OFFSET FLAT:??_C@_0L@CIEP@suitvolume?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fstp	DWORD PTR _fvol$[ebp]

; 1595 : 	if (RANDOM_LONG(0,1))

	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	je	SHORT $L39718

; 1596 : 		pitch = RANDOM_LONG(0,6) + 98;

	push	6
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 98					; 00000062H
	mov	DWORD PTR _pitch$[ebp], eax
$L39718:

; 1597 : 
; 1598 : 	if (fvol > 0.05)

	fld	DWORD PTR _fvol$[ebp]
	fcomp	QWORD PTR __real@8@3ffaccccccccccccd000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39719

; 1599 : 		SENTENCEG_PlayRndSz(entity, groupname, fvol, ATTN_NORM, 0, pitch);

	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	push	0
	push	1061997773				; 3f4ccccdH
	mov	ecx, DWORD PTR _fvol$[ebp]
	push	ecx
	mov	edx, DWORD PTR _groupname$[ebp]
	push	edx
	mov	eax, DWORD PTR _entity$[ebp]
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H
$L39719:

; 1600 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_GROUPNAME_SUIT@@YAXPAUedict_s@@PBD@Z ENDP		; EMIT_GROUPNAME_SUIT
_TEXT	ENDS
PUBLIC	__real@4@4001c000000000000000
PUBLIC	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z		; EMIT_SOUND
PUBLIC	?PlayLockSounds@@YAXPAUentvars_s@@PAUlocksounds@@HH@Z ; PlayLockSounds
;	COMDAT __real@4@4001c000000000000000
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
__real@4@4001c000000000000000 DD 040c00000r	; 6
CONST	ENDS
;	COMDAT ?PlayLockSounds@@YAXPAUentvars_s@@PAUlocksounds@@HH@Z
_TEXT	SEGMENT
_pev$ = 8
_pls$ = 12
_flocked$ = 16
_fbutton$ = 20
_flsoundwait$ = -4
_fplaysound$39734 = -8
_fplaysentence$39735 = -12
_fvol$39736 = -16
_iprev$39743 = -20
_fplaysound$39746 = -24
_fplaysentence$39747 = -28
_fvol$39748 = -32
_iprev$39755 = -36
?PlayLockSounds@@YAXPAUentvars_s@@PAUlocksounds@@HH@Z PROC NEAR ; PlayLockSounds, COMDAT

; 1613 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 1614 : 	// LOCKED SOUND
; 1615 : 	
; 1616 : 	// CONSIDER: consolidate the locksound_t struct (all entries are duplicates for lock/unlock)
; 1617 : 	// CONSIDER: and condense this code.
; 1618 : 	float flsoundwait;
; 1619 : 
; 1620 : 	if (fbutton)

	cmp	DWORD PTR _fbutton$[ebp], 0
	je	SHORT $L39731

; 1621 : 		flsoundwait = BUTTON_SOUNDWAIT;

	mov	DWORD PTR _flsoundwait$[ebp], 1056964608 ; 3f000000H

; 1622 : 	else

	jmp	SHORT $L39732
$L39731:

; 1623 : 		flsoundwait = DOOR_SOUNDWAIT;

	mov	DWORD PTR _flsoundwait$[ebp], 1077936128 ; 40400000H
$L39732:

; 1624 : 
; 1625 : 	if (flocked)

	cmp	DWORD PTR _flocked$[ebp], 0
	je	$L39733

; 1627 : 		int fplaysound = (pls->sLockedSound && gpGlobals->time > pls->flwaitSound);

	mov	eax, DWORD PTR _pls$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L41307
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _pls$[ebp]
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR [edx+24]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41307
	mov	DWORD PTR -40+[ebp], 1
	jmp	SHORT $L41308
$L41307:
	mov	DWORD PTR -40+[ebp], 0
$L41308:
	mov	eax, DWORD PTR -40+[ebp]
	mov	DWORD PTR _fplaysound$39734[ebp], eax

; 1628 : 		int fplaysentence = (pls->sLockedSentence && !pls->bEOFLocked && gpGlobals->time > pls->flwaitSentence);

	mov	ecx, DWORD PTR _pls$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L41309
	mov	edx, DWORD PTR _pls$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+32]
	test	eax, eax
	jne	SHORT $L41309
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _pls$[ebp]
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR [edx+28]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41309
	mov	DWORD PTR -44+[ebp], 1
	jmp	SHORT $L41310
$L41309:
	mov	DWORD PTR -44+[ebp], 0
$L41310:
	mov	eax, DWORD PTR -44+[ebp]
	mov	DWORD PTR _fplaysentence$39735[ebp], eax

; 1629 : 		float fvol;
; 1630 : 
; 1631 : 		if (fplaysound && fplaysentence)

	cmp	DWORD PTR _fplaysound$39734[ebp], 0
	je	SHORT $L39737
	cmp	DWORD PTR _fplaysentence$39735[ebp], 0
	je	SHORT $L39737

; 1632 : 			fvol = 0.25;

	mov	DWORD PTR _fvol$39736[ebp], 1048576000	; 3e800000H

; 1633 : 		else

	jmp	SHORT $L39738
$L39737:

; 1634 : 			fvol = 1.0;

	mov	DWORD PTR _fvol$39736[ebp], 1065353216	; 3f800000H
$L39738:

; 1635 : 
; 1636 : 		// if there is a locked sound, and we've debounced, play sound
; 1637 : 		if (fplaysound)

	cmp	DWORD PTR _fplaysound$39734[ebp], 0
	je	SHORT $L39739

; 1639 : 			// play 'door locked' sound
; 1640 : 			EMIT_SOUND(ENT(pev), CHAN_ITEM, (char*)STRING(pls->sLockedSound), fvol, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	mov	ecx, DWORD PTR _fvol$39736[ebp]
	push	ecx
	mov	edx, DWORD PTR _pls$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	3
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1641 : 			pls->flwaitSound = gpGlobals->time + flsoundwait;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _flsoundwait$[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _pls$[ebp]
	fstp	DWORD PTR [eax+24]
$L39739:

; 1643 : 
; 1644 : 		// if there is a sentence, we've not played all in list, and we've debounced, play sound
; 1645 : 		if (fplaysentence)

	cmp	DWORD PTR _fplaysentence$39735[ebp], 0
	je	SHORT $L39742

; 1647 : 			// play next 'door locked' sentence in group
; 1648 : 			int iprev = pls->iLockedSentence;

	mov	ecx, DWORD PTR _pls$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _iprev$39743[ebp], edx

; 1649 : 			
; 1650 : 			pls->iLockedSentence = SENTENCEG_PlaySequentialSz(ENT(pev), STRING(pls->sLockedSentence), 
; 1651 : 					  0.85, ATTN_NORM, 0, 100, pls->iLockedSentence, FALSE);

	push	0
	mov	eax, DWORD PTR _pls$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	100					; 00000064H
	push	0
	push	1061997773				; 3f4ccccdH
	push	1062836634				; 3f59999aH
	mov	edx, DWORD PTR _pls$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlaySequentialSz@@YAHPAUedict_s@@PBDMMHHHH@Z ; SENTENCEG_PlaySequentialSz
	add	esp, 32					; 00000020H
	mov	edx, DWORD PTR _pls$[ebp]
	mov	DWORD PTR [edx+16], eax

; 1652 : 			pls->iUnlockedSentence = 0;

	mov	eax, DWORD PTR _pls$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1653 : 
; 1654 : 			// make sure we don't keep calling last sentence in list
; 1655 : 			pls->bEOFLocked = (iprev == pls->iLockedSentence);

	mov	ecx, DWORD PTR _pls$[ebp]
	mov	edx, DWORD PTR _iprev$39743[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+16]
	sete	al
	mov	ecx, DWORD PTR _pls$[ebp]
	mov	BYTE PTR [ecx+32], al

; 1656 : 		
; 1657 : 			pls->flwaitSentence = gpGlobals->time + DOOR_SENTENCEWAIT;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	DWORD PTR __real@4@4001c000000000000000
	mov	eax, DWORD PTR _pls$[ebp]
	fstp	DWORD PTR [eax+28]
$L39742:

; 1660 : 	else

	jmp	$L39754
$L39733:

; 1662 : 		// UNLOCKED SOUND
; 1663 : 
; 1664 : 		int fplaysound = (pls->sUnlockedSound && gpGlobals->time > pls->flwaitSound);

	mov	ecx, DWORD PTR _pls$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $L41311
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR _pls$[ebp]
	fld	DWORD PTR [edx]
	fcomp	DWORD PTR [eax+24]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41311
	mov	DWORD PTR -48+[ebp], 1
	jmp	SHORT $L41312
$L41311:
	mov	DWORD PTR -48+[ebp], 0
$L41312:
	mov	ecx, DWORD PTR -48+[ebp]
	mov	DWORD PTR _fplaysound$39746[ebp], ecx

; 1665 : 		int fplaysentence = (pls->sUnlockedSentence && !pls->bEOFUnlocked && gpGlobals->time > pls->flwaitSentence);

	mov	edx, DWORD PTR _pls$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $L41313
	mov	eax, DWORD PTR _pls$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+33]
	test	ecx, ecx
	jne	SHORT $L41313
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR _pls$[ebp]
	fld	DWORD PTR [edx]
	fcomp	DWORD PTR [eax+28]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41313
	mov	DWORD PTR -52+[ebp], 1
	jmp	SHORT $L41314
$L41313:
	mov	DWORD PTR -52+[ebp], 0
$L41314:
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR _fplaysentence$39747[ebp], ecx

; 1666 : 		float fvol;
; 1667 : 
; 1668 : 		// if playing both sentence and sound, lower sound volume so we hear sentence
; 1669 : 		if (fplaysound && fplaysentence)

	cmp	DWORD PTR _fplaysound$39746[ebp], 0
	je	SHORT $L39749
	cmp	DWORD PTR _fplaysentence$39747[ebp], 0
	je	SHORT $L39749

; 1670 : 			fvol = 0.25;

	mov	DWORD PTR _fvol$39748[ebp], 1048576000	; 3e800000H

; 1671 : 		else

	jmp	SHORT $L39750
$L39749:

; 1672 : 			fvol = 1.0;

	mov	DWORD PTR _fvol$39748[ebp], 1065353216	; 3f800000H
$L39750:

; 1673 : 
; 1674 : 		// play 'door unlocked' sound if set
; 1675 : 		if (fplaysound)

	cmp	DWORD PTR _fplaysound$39746[ebp], 0
	je	SHORT $L39751

; 1677 : 			EMIT_SOUND(ENT(pev), CHAN_ITEM, (char*)STRING(pls->sUnlockedSound), fvol, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	mov	edx, DWORD PTR _fvol$39748[ebp]
	push	edx
	mov	eax, DWORD PTR _pls$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	3
	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1678 : 			pls->flwaitSound = gpGlobals->time + flsoundwait;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _flsoundwait$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pls$[ebp]
	fstp	DWORD PTR [ecx+24]
$L39751:

; 1680 : 
; 1681 : 		// play next 'door unlocked' sentence in group
; 1682 : 		if (fplaysentence)

	cmp	DWORD PTR _fplaysentence$39747[ebp], 0
	je	SHORT $L39754

; 1684 : 			int iprev = pls->iUnlockedSentence;

	mov	edx, DWORD PTR _pls$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _iprev$39755[ebp], eax

; 1685 : 			
; 1686 : 			pls->iUnlockedSentence = SENTENCEG_PlaySequentialSz(ENT(pev), STRING(pls->sUnlockedSentence), 
; 1687 : 					  0.85, ATTN_NORM, 0, 100, pls->iUnlockedSentence, FALSE);

	push	0
	mov	ecx, DWORD PTR _pls$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	push	100					; 00000064H
	push	0
	push	1061997773				; 3f4ccccdH
	push	1062836634				; 3f59999aH
	mov	eax, DWORD PTR _pls$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlaySequentialSz@@YAHPAUedict_s@@PBDMMHHHH@Z ; SENTENCEG_PlaySequentialSz
	add	esp, 32					; 00000020H
	mov	ecx, DWORD PTR _pls$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1688 : 			pls->iLockedSentence = 0;

	mov	edx, DWORD PTR _pls$[ebp]
	mov	DWORD PTR [edx+16], 0

; 1689 : 
; 1690 : 			// make sure we don't keep calling last sentence in list
; 1691 : 			pls->bEOFUnlocked = (iprev == pls->iUnlockedSentence);

	mov	eax, DWORD PTR _pls$[ebp]
	mov	ecx, DWORD PTR _iprev$39755[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+20]
	sete	dl
	mov	eax, DWORD PTR _pls$[ebp]
	mov	BYTE PTR [eax+33], dl

; 1692 : 			pls->flwaitSentence = gpGlobals->time + DOOR_SENTENCEWAIT;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@4001c000000000000000
	mov	edx, DWORD PTR _pls$[ebp]
	fstp	DWORD PTR [edx+28]
$L39754:

; 1695 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PlayLockSounds@@YAXPAUentvars_s@@PAUlocksounds@@HH@Z ENDP ; PlayLockSounds
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
_volume$ = 20
_attenuation$ = 24
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z PROC NEAR		; EMIT_SOUND, COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 610  : 	EMIT_SOUND_DYN( entity, channel, sample, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 611  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z ENDP		; EMIT_SOUND
_TEXT	ENDS
EXTRN	_memcpy:NEAR
;	COMDAT ?memfgets@@YAPADPAEHAAHPADH@Z
_TEXT	SEGMENT
_pMemFile$ = 8
_fileSize$ = 12
_filePos$ = 16
_pBuffer$ = 20
_bufferSize$ = 24
_i$ = -4
_last$ = -8
_stop$ = -12
_size$39781 = -16
?memfgets@@YAPADPAEHAAHPADH@Z PROC NEAR			; memfgets, COMDAT

; 1716 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1717 : 	// Bullet-proofing
; 1718 : 	if ( !pMemFile || !pBuffer )

	cmp	DWORD PTR _pMemFile$[ebp], 0
	je	SHORT $L39770
	cmp	DWORD PTR _pBuffer$[ebp], 0
	jne	SHORT $L39769
$L39770:

; 1719 : 		return NULL;

	xor	eax, eax
	jmp	$L39768
$L39769:

; 1720 : 
; 1721 : 	if ( filePos >= fileSize )

	mov	eax, DWORD PTR _filePos$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _fileSize$[ebp]
	jl	SHORT $L39771

; 1722 : 		return NULL;

	xor	eax, eax
	jmp	$L39768
$L39771:

; 1723 : 
; 1724 : 	int i = filePos;

	mov	edx, DWORD PTR _filePos$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _i$[ebp], eax

; 1725 : 	int last = fileSize;

	mov	ecx, DWORD PTR _fileSize$[ebp]
	mov	DWORD PTR _last$[ebp], ecx

; 1726 : 
; 1727 : 	// fgets always NULL terminates, so only read bufferSize-1 characters
; 1728 : 	if ( last - filePos > (bufferSize-1) )

	mov	edx, DWORD PTR _filePos$[ebp]
	mov	eax, DWORD PTR _last$[ebp]
	sub	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _bufferSize$[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jle	SHORT $L39774

; 1729 : 		last = filePos + (bufferSize-1);

	mov	edx, DWORD PTR _filePos$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _bufferSize$[ebp]
	lea	edx, DWORD PTR [eax+ecx-1]
	mov	DWORD PTR _last$[ebp], edx
$L39774:

; 1730 : 
; 1731 : 	int stop = 0;

	mov	DWORD PTR _stop$[ebp], 0
$L39777:

; 1732 : 
; 1733 : 	// Stop at the next newline (inclusive) or end of buffer
; 1734 : 	while ( i < last && !stop )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _last$[ebp]
	jge	SHORT $L39778
	cmp	DWORD PTR _stop$[ebp], 0
	jne	SHORT $L39778

; 1736 : 		if ( pMemFile[i] == '\n' )

	mov	ecx, DWORD PTR _pMemFile$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $L39779

; 1737 : 			stop = 1;

	mov	DWORD PTR _stop$[ebp], 1
$L39779:

; 1738 : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 1739 : 	}

	jmp	SHORT $L39777
$L39778:

; 1740 : 
; 1741 : 
; 1742 : 	// If we actually advanced the pointer, copy it over
; 1743 : 	if ( i != filePos )

	mov	ecx, DWORD PTR _filePos$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $L39780

; 1745 : 		// We read in size bytes
; 1746 : 		int size = i - filePos;

	mov	eax, DWORD PTR _filePos$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR _size$39781[ebp], ecx

; 1747 : 		// copy it out
; 1748 : 		memcpy( pBuffer, pMemFile + filePos, sizeof(byte)*size );

	mov	edx, DWORD PTR _size$39781[ebp]
	push	edx
	mov	eax, DWORD PTR _filePos$[ebp]
	mov	ecx, DWORD PTR _pMemFile$[ebp]
	add	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pBuffer$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1749 : 		
; 1750 : 		// If the buffer isn't full, terminate (this is always true)
; 1751 : 		if ( size < bufferSize )

	mov	eax, DWORD PTR _size$39781[ebp]
	cmp	eax, DWORD PTR _bufferSize$[ebp]
	jge	SHORT $L39783

; 1752 : 			pBuffer[size] = 0;

	mov	ecx, DWORD PTR _pBuffer$[ebp]
	add	ecx, DWORD PTR _size$39781[ebp]
	mov	BYTE PTR [ecx], 0
$L39783:

; 1753 : 
; 1754 : 		// Update file pointer
; 1755 : 		filePos = i;

	mov	edx, DWORD PTR _filePos$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx], eax

; 1756 : 		return pBuffer;

	mov	eax, DWORD PTR _pBuffer$[ebp]
	jmp	SHORT $L39768
$L39780:

; 1758 : 
; 1759 : 	// No data read, bail
; 1760 : 	return NULL;

	xor	eax, eax
$L39768:

; 1761 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?memfgets@@YAPADPAEHAAHPADH@Z ENDP			; memfgets
_TEXT	ENDS
PUBLIC	?TEXTURETYPE_Init@@YAXXZ			; TEXTURETYPE_Init
PUBLIC	??_C@_0BE@BFKO@sound?1materials?4txt?$AA@	; `string'
EXTRN	_isspace:NEAR
EXTRN	_toupper:NEAR
;	COMDAT ??_C@_0BE@BFKO@sound?1materials?4txt?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0BE@BFKO@sound?1materials?4txt?$AA@ DB 'sound/materials.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ?TEXTURETYPE_Init@@YAXXZ
_TEXT	SEGMENT
_buffer$ = -512
_i$ = -516
_j$ = -520
_pMemFile$ = -524
_fileSize$ = -528
_filePos$ = -532
?TEXTURETYPE_Init@@YAXXZ PROC NEAR			; TEXTURETYPE_Init, COMDAT

; 1765 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 608				; 00000260H
	push	ebx
	push	esi
	push	edi

; 1766 : 	char buffer[512];
; 1767 : 	int i, j;
; 1768 : 	byte *pMemFile;
; 1769 : 	int fileSize, filePos;
; 1770 : 
; 1771 : 	if (fTextureTypeInit)

	cmp	DWORD PTR ?fTextureTypeInit@@3HA, 0	; fTextureTypeInit
	je	SHORT $L39792

; 1772 : 		return;

	jmp	$L39785
$L39792:

; 1773 : 
; 1774 : 	memset(&(grgszTextureName[0][0]), 0, CTEXTURESMAX * CBTEXTURENAMEMAX);

	push	6656					; 00001a00H
	push	0
	push	OFFSET FLAT:?grgszTextureName@@3PAY0N@DA ; grgszTextureName
	call	_memset
	add	esp, 12					; 0000000cH

; 1775 : 	memset(grgchTextureType, 0, CTEXTURESMAX);

	push	512					; 00000200H
	push	0
	push	OFFSET FLAT:?grgchTextureType@@3PADA	; grgchTextureType
	call	_memset
	add	esp, 12					; 0000000cH

; 1776 : 
; 1777 : 	gcTextures = 0;

	mov	DWORD PTR ?gcTextures@@3HA, 0		; gcTextures

; 1778 : 	memset(buffer, 0, 512);

	push	512					; 00000200H
	push	0
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1779 : 
; 1780 : 	pMemFile = g_engfuncs.pfnLoadFileForMe( "sound/materials.txt", &fileSize );

	lea	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BE@BFKO@sound?1materials?4txt?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+380
	add	esp, 8
	mov	DWORD PTR _pMemFile$[ebp], eax

; 1781 : 	if ( !pMemFile )

	cmp	DWORD PTR _pMemFile$[ebp], 0
	jne	SHORT $L39794

; 1782 : 		return;

	jmp	$L39785
$L39794:

; 1783 : 
; 1784 : 	// for each line in the file...
; 1785 : 	while (memfgets(pMemFile, fileSize, filePos, buffer, 511) != NULL && (gcTextures < CTEXTURESMAX))

	push	511					; 000001ffH
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	lea	eax, DWORD PTR _filePos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMemFile$[ebp]
	push	edx
	call	?memfgets@@YAPADPAEHAAHPADH@Z		; memfgets
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$L39797
	cmp	DWORD PTR ?gcTextures@@3HA, 512		; gcTextures, 00000200H
	jge	$L39797

; 1787 : 		// skip whitespace
; 1788 : 		i = 0;

	mov	DWORD PTR _i$[ebp], 0
$L39799:

; 1789 : 		while(buffer[i] && isspace(buffer[i]))

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	test	ecx, ecx
	je	SHORT $L39800
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	push	eax
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L39800

; 1790 : 			i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $L39799
$L39800:

; 1791 : 		
; 1792 : 		if (!buffer[i])

	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	test	eax, eax
	jne	SHORT $L39801

; 1793 : 			continue;

	jmp	$L39794
$L39801:

; 1794 : 
; 1795 : 		// skip comment lines
; 1796 : 		if (buffer[i] == '/' || !isalpha(buffer[i]))

	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	cmp	edx, 47					; 0000002fH
	je	SHORT $L39803
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	push	ecx
	call	_isalpha
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39802
$L39803:

; 1797 : 			continue;

	jmp	$L39794
$L39802:

; 1798 : 
; 1799 : 		// get texture type
; 1800 : 		grgchTextureType[gcTextures] = toupper(buffer[i++]);

	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	mov	DWORD PTR -536+[ebp], eax
	mov	ecx, DWORD PTR -536+[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	call	_toupper
	add	esp, 4
	mov	ecx, DWORD PTR ?gcTextures@@3HA		; gcTextures
	mov	BYTE PTR ?grgchTextureType@@3PADA[ecx], al
$L39805:

; 1801 : 
; 1802 : 		// skip whitespace
; 1803 : 		while(buffer[i] && isspace(buffer[i]))

	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	test	eax, eax
	je	SHORT $L39806
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	push	edx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L39806

; 1804 : 			i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L39805
$L39806:

; 1805 : 		
; 1806 : 		if (!buffer[i])

	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	test	edx, edx
	jne	SHORT $L39807

; 1807 : 			continue;

	jmp	$L39794
$L39807:

; 1808 : 
; 1809 : 		// get sentence name
; 1810 : 		j = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _j$[ebp], eax
$L39809:

; 1811 : 		while (buffer[j] && !isspace(buffer[j]))

	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	test	edx, edx
	je	SHORT $L39810
	mov	eax, DWORD PTR _j$[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39810

; 1812 : 			j++;

	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	jmp	SHORT $L39809
$L39810:

; 1813 : 
; 1814 : 		if (!buffer[j])

	mov	eax, DWORD PTR _j$[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $L39811

; 1815 : 			continue;

	jmp	$L39794
$L39811:

; 1816 : 
; 1817 : 		// null-terminate name and save in sentences array
; 1818 : 		j = Q_min (j, CBTEXTURENAMEMAX-1+i);

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR _j$[ebp], edx
	jge	SHORT $L41323
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR -540+[ebp], eax
	jmp	SHORT $L41324
$L41323:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR -540+[ebp], ecx
$L41324:
	mov	edx, DWORD PTR -540+[ebp]
	mov	DWORD PTR _j$[ebp], edx

; 1819 : 		buffer[j] = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR _buffer$[ebp+eax], 0

; 1820 : 		strcpy(&(grgszTextureName[gcTextures++][0]), &(buffer[i]));

	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _buffer$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR ?gcTextures@@3HA		; gcTextures
	imul	eax, 13					; 0000000dH
	add	eax, OFFSET FLAT:?grgszTextureName@@3PAY0N@DA ; grgszTextureName
	mov	DWORD PTR -544+[ebp], eax
	mov	ecx, DWORD PTR -544+[ebp]
	push	ecx
	mov	edx, DWORD PTR ?gcTextures@@3HA		; gcTextures
	add	edx, 1
	mov	DWORD PTR ?gcTextures@@3HA, edx		; gcTextures
	call	_strcpy
	add	esp, 8

; 1821 : 	}

	jmp	$L39794
$L39797:

; 1822 : 
; 1823 : 	g_engfuncs.pfnFreeFile( pMemFile );

	mov	eax, DWORD PTR _pMemFile$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+384
	add	esp, 4

; 1824 : 	
; 1825 : 	fTextureTypeInit = TRUE;

	mov	DWORD PTR ?fTextureTypeInit@@3HA, 1	; fTextureTypeInit
$L39785:

; 1826 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TEXTURETYPE_Init@@YAXXZ ENDP				; TEXTURETYPE_Init
_TEXT	ENDS
PUBLIC	?TEXTURETYPE_Find@@YADPAD@Z			; TEXTURETYPE_Find
EXTRN	_strnicmp:NEAR
;	COMDAT ?TEXTURETYPE_Find@@YADPAD@Z
_TEXT	SEGMENT
_name$ = 8
_i$ = -4
?TEXTURETYPE_Find@@YADPAD@Z PROC NEAR			; TEXTURETYPE_Find, COMDAT

; 1835 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1836 : 	// CONSIDER: pre-sort texture names and perform faster binary search here
; 1837 : 
; 1838 : 	for (int i = 0; i < gcTextures; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39816
$L39817:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L39816:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?gcTextures@@3HA		; gcTextures
	jge	SHORT $L39818

; 1840 : 		if (!strnicmp(name, &(grgszTextureName[i][0]), CBTEXTURENAMEMAX-1))

	push	12					; 0000000cH
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 13					; 0000000dH
	add	edx, OFFSET FLAT:?grgszTextureName@@3PAY0N@DA ; grgszTextureName
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L39819

; 1841 : 			return (grgchTextureType[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR ?grgchTextureType@@3PADA[ecx]
	jmp	SHORT $L39814
$L39819:

; 1842 : 	}

	jmp	SHORT $L39817
$L39818:

; 1843 : 
; 1844 : 	return CHAR_TEX_CONCRETE;

	mov	al, 67					; 00000043H
$L39814:

; 1845 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TEXTURETYPE_Find@@YADPAD@Z ENDP			; TEXTURETYPE_Find
_TEXT	ENDS
PUBLIC	?CopyToArray@Vector@@QBEXPAM@Z			; Vector::CopyToArray
PUBLIC	?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z ; TEXTURETYPE_PlaySound
PUBLIC	__real@8@3fffc000000000000000
PUBLIC	__real@8@40008000000000000000
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
PUBLIC	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z		; FClassnameIs
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
PUBLIC	??_C@_0BE@DAFA@player?1pl_step1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@NADP@player?1pl_step2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@LBED@player?1pl_metal1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@FBCM@player?1pl_metal2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@IGBB@player?1pl_dirt1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@GGHO@player?1pl_dirt2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@MGFL@player?1pl_dirt3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@KCPJ@player?1pl_duct1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@BEOK@player?1pl_grate1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@DEFK@player?1pl_grate4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@BHLL@player?1pl_tile1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@FHPB@player?1pl_tile3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@PHNE@player?1pl_tile2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@DHAL@player?1pl_tile4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@DKOO@player?1pl_slosh1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@HKKE@player?1pl_slosh3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@NKIB@player?1pl_slosh2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@BKFO@player?1pl_slosh4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BB@MAKG@debris?1wood1?4wav?$AA@		; `string'
PUBLIC	??_C@_0BB@CAMJ@debris?1wood2?4wav?$AA@		; `string'
PUBLIC	??_C@_0BB@IAOM@debris?1wood3?4wav?$AA@		; `string'
PUBLIC	??_C@_0BC@JOHE@debris?1glass1?4wav?$AA@		; `string'
PUBLIC	??_C@_0BC@HOBL@debris?1glass2?4wav?$AA@		; `string'
PUBLIC	??_C@_0BC@NODO@debris?1glass3?4wav?$AA@		; `string'
PUBLIC	??_C@_0BI@JLBM@weapons?1bullet_hit1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BI@HLHD@weapons?1bullet_hit2?4wav?$AA@	; `string'
PUBLIC	??_C@_0P@KFIJ@func_breakable?$AA@		; `string'
PUBLIC	??_C@_0BD@GNEE@buttons?1spark5?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@INCL@buttons?1spark6?4wav?$AA@	; `string'
EXTRN	?UTIL_Sparks@@YAXABVVector@@@Z:NEAR		; UTIL_Sparks
EXTRN	?g_pGameRules@@3PAVCGameRules@@A:DWORD		; g_pGameRules
;	COMDAT ??_C@_0BE@DAFA@player?1pl_step1?4wav?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0BE@DAFA@player?1pl_step1?4wav?$AA@ DB 'player/pl_step1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NADP@player?1pl_step2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@NADP@player?1pl_step2?4wav?$AA@ DB 'player/pl_step2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LBED@player?1pl_metal1?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@LBED@player?1pl_metal1?4wav?$AA@ DB 'player/pl_metal1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FBCM@player?1pl_metal2?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@FBCM@player?1pl_metal2?4wav?$AA@ DB 'player/pl_metal2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IGBB@player?1pl_dirt1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@IGBB@player?1pl_dirt1?4wav?$AA@ DB 'player/pl_dirt1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGHO@player?1pl_dirt2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@GGHO@player?1pl_dirt2?4wav?$AA@ DB 'player/pl_dirt2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGFL@player?1pl_dirt3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@MGFL@player?1pl_dirt3?4wav?$AA@ DB 'player/pl_dirt3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KCPJ@player?1pl_duct1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@KCPJ@player?1pl_duct1?4wav?$AA@ DB 'player/pl_duct1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BEOK@player?1pl_grate1?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@BEOK@player?1pl_grate1?4wav?$AA@ DB 'player/pl_grate1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DEFK@player?1pl_grate4?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@DEFK@player?1pl_grate4?4wav?$AA@ DB 'player/pl_grate4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BHLL@player?1pl_tile1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@BHLL@player?1pl_tile1?4wav?$AA@ DB 'player/pl_tile1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FHPB@player?1pl_tile3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@FHPB@player?1pl_tile3?4wav?$AA@ DB 'player/pl_tile3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PHNE@player?1pl_tile2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@PHNE@player?1pl_tile2?4wav?$AA@ DB 'player/pl_tile2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DHAL@player?1pl_tile4?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@DHAL@player?1pl_tile4?4wav?$AA@ DB 'player/pl_tile4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DKOO@player?1pl_slosh1?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@DKOO@player?1pl_slosh1?4wav?$AA@ DB 'player/pl_slosh1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HKKE@player?1pl_slosh3?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@HKKE@player?1pl_slosh3?4wav?$AA@ DB 'player/pl_slosh3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NKIB@player?1pl_slosh2?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@NKIB@player?1pl_slosh2?4wav?$AA@ DB 'player/pl_slosh2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BKFO@player?1pl_slosh4?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@BKFO@player?1pl_slosh4?4wav?$AA@ DB 'player/pl_slosh4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MAKG@debris?1wood1?4wav?$AA@
CONST	SEGMENT
??_C@_0BB@MAKG@debris?1wood1?4wav?$AA@ DB 'debris/wood1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CAMJ@debris?1wood2?4wav?$AA@
CONST	SEGMENT
??_C@_0BB@CAMJ@debris?1wood2?4wav?$AA@ DB 'debris/wood2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IAOM@debris?1wood3?4wav?$AA@
CONST	SEGMENT
??_C@_0BB@IAOM@debris?1wood3?4wav?$AA@ DB 'debris/wood3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JOHE@debris?1glass1?4wav?$AA@
CONST	SEGMENT
??_C@_0BC@JOHE@debris?1glass1?4wav?$AA@ DB 'debris/glass1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HOBL@debris?1glass2?4wav?$AA@
CONST	SEGMENT
??_C@_0BC@HOBL@debris?1glass2?4wav?$AA@ DB 'debris/glass2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NODO@debris?1glass3?4wav?$AA@
CONST	SEGMENT
??_C@_0BC@NODO@debris?1glass3?4wav?$AA@ DB 'debris/glass3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JLBM@weapons?1bullet_hit1?4wav?$AA@
CONST	SEGMENT
??_C@_0BI@JLBM@weapons?1bullet_hit1?4wav?$AA@ DB 'weapons/bullet_hit1.wav'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HLHD@weapons?1bullet_hit2?4wav?$AA@
CONST	SEGMENT
??_C@_0BI@HLHD@weapons?1bullet_hit2?4wav?$AA@ DB 'weapons/bullet_hit2.wav'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KFIJ@func_breakable?$AA@
CONST	SEGMENT
??_C@_0P@KFIJ@func_breakable?$AA@ DB 'func_breakable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNEE@buttons?1spark5?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@GNEE@buttons?1spark5?4wav?$AA@ DB 'buttons/spark5.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@INCL@buttons?1spark6?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@INCL@buttons?1spark6?4wav?$AA@ DB 'buttons/spark6.wav', 00H ; `string'
CONST	ENDS
;	COMDAT __real@8@3fffc000000000000000
CONST	SEGMENT
__real@8@3fffc000000000000000 DQ 03ff8000000000000r ; 1.5
CONST	ENDS
;	COMDAT __real@8@40008000000000000000
CONST	SEGMENT
__real@8@40008000000000000000 DQ 04000000000000000r ; 2
CONST	ENDS
;	COMDAT ?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z
_TEXT	SEGMENT
_ptr$ = 8
_vecSrc$ = 12
_vecEnd$ = 24
_iBulletType$ = 36
_chTextureType$ = -4
_fvol$ = -8
_fvolbar$ = -12
_szbuffer$ = -76
_pTextureName$ = -80
_rgfl1$ = -92
_rgfl2$ = -104
_rgsz$ = -120
_cnt$ = -124
_fattn$ = -128
_pEntity$ = -132
_flVolume$39894 = -136
?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z PROC NEAR ; TEXTURETYPE_PlaySound, COMDAT

; 1852 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi

; 1853 : // hit the world, try to play sound based on texture material type
; 1854 : 	
; 1855 : 	char chTextureType;
; 1856 : 	float fvol;
; 1857 : 	float fvolbar;
; 1858 : 	char szbuffer[64];
; 1859 : 	const char *pTextureName;
; 1860 : 	float rgfl1[3];
; 1861 : 	float rgfl2[3];
; 1862 : 	char *rgsz[4];
; 1863 : 	int cnt;
; 1864 : 	float fattn = ATTN_NORM;

	mov	DWORD PTR _fattn$[ebp], 1061997773	; 3f4ccccdH

; 1865 : 
; 1866 : 	if ( !g_pGameRules->PlayTextureSounds() )

	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L39837

; 1867 : 		return 0.0;

	fld	DWORD PTR __real@4@00000000000000000000
	jmp	$L39825
$L39837:

; 1868 : 
; 1869 : 	CBaseEntity *pEntity = CBaseEntity::Instance(ptr->pHit);

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 1870 : 
; 1871 : 	chTextureType = 0;

	mov	BYTE PTR _chTextureType$[ebp], 0

; 1872 : 
; 1873 : 	if (pEntity && pEntity->Classify() != CLASS_NONE && pEntity->Classify() != CLASS_MACHINE)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L39839
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [eax+68]
	test	eax, eax
	je	SHORT $L39839
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+68]
	cmp	eax, 1
	je	SHORT $L39839

; 1874 : 		// hit body
; 1875 : 		chTextureType = CHAR_TEX_FLESH;

	mov	BYTE PTR _chTextureType$[ebp], 70	; 00000046H

; 1876 : 	else

	jmp	$L39843
$L39839:

; 1878 : 		// hit world
; 1879 : 
; 1880 : 		// find texture under strike, get material type
; 1881 : 
; 1882 : 		// copy trace vector into array for trace_texture
; 1883 : 
; 1884 : 		vecSrc.CopyToArray(rgfl1);

	lea	eax, DWORD PTR _rgfl1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	?CopyToArray@Vector@@QBEXPAM@Z		; Vector::CopyToArray

; 1885 : 		vecEnd.CopyToArray(rgfl2);

	lea	ecx, DWORD PTR _rgfl2$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	?CopyToArray@Vector@@QBEXPAM@Z		; Vector::CopyToArray

; 1886 : 
; 1887 : 		// get texture from entity or world (world is ent(0))
; 1888 : 		if (pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L39841

; 1889 : 			pTextureName = TRACE_TEXTURE( ENT(pEntity->pev), rgfl1, rgfl2 );

	lea	edx, DWORD PTR _rgfl2$[ebp]
	push	edx
	lea	eax, DWORD PTR _rgfl1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+144
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTextureName$[ebp], eax

; 1890 : 		else

	jmp	SHORT $L39842
$L39841:

; 1891 : 			pTextureName = TRACE_TEXTURE( ENT(0), rgfl1, rgfl2 );

	lea	eax, DWORD PTR _rgfl2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rgfl1$[ebp]
	push	ecx
	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+144
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTextureName$[ebp], eax
$L39842:

; 1892 : 			
; 1893 : 		if ( pTextureName )

	cmp	DWORD PTR _pTextureName$[ebp], 0
	je	SHORT $L39843

; 1895 : 			// strip leading '-0' or '+0~' or '{' or '!'
; 1896 : 			if (*pTextureName == '-' || *pTextureName == '+')

	mov	edx, DWORD PTR _pTextureName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $L39845
	mov	ecx, DWORD PTR _pTextureName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	jne	SHORT $L39844
$L39845:

; 1897 : 				pTextureName += 2;

	mov	eax, DWORD PTR _pTextureName$[ebp]
	add	eax, 2
	mov	DWORD PTR _pTextureName$[ebp], eax
$L39844:

; 1898 : 
; 1899 : 			if (*pTextureName == '{' || *pTextureName == '!' || *pTextureName == '~' || *pTextureName == ' ')

	mov	ecx, DWORD PTR _pTextureName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 123				; 0000007bH
	je	SHORT $L39847
	mov	eax, DWORD PTR _pTextureName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	je	SHORT $L39847
	mov	edx, DWORD PTR _pTextureName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 126				; 0000007eH
	je	SHORT $L39847
	mov	ecx, DWORD PTR _pTextureName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $L39846
$L39847:

; 1900 : 				pTextureName++;

	mov	eax, DWORD PTR _pTextureName$[ebp]
	add	eax, 1
	mov	DWORD PTR _pTextureName$[ebp], eax
$L39846:

; 1901 : 			// '}}'
; 1902 : 			strcpy(szbuffer, pTextureName);

	mov	ecx, DWORD PTR _pTextureName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szbuffer$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1903 : 			szbuffer[CBTEXTURENAMEMAX - 1] = 0;

	mov	BYTE PTR _szbuffer$[ebp+12], 0

; 1904 : 				
; 1905 : 			// ALERT ( at_console, "texture hit: %s\n", szbuffer);
; 1906 : 
; 1907 : 			// get texture type
; 1908 : 			chTextureType = TEXTURETYPE_Find(szbuffer);	

	lea	eax, DWORD PTR _szbuffer$[ebp]
	push	eax
	call	?TEXTURETYPE_Find@@YADPAD@Z		; TEXTURETYPE_Find
	add	esp, 4
	mov	BYTE PTR _chTextureType$[ebp], al
$L39843:

; 1913 : 	{

	movsx	ecx, BYTE PTR _chTextureType$[ebp]
	mov	DWORD PTR -140+[ebp], ecx
	mov	edx, DWORD PTR -140+[ebp]
	sub	edx, 68					; 00000044H
	mov	DWORD PTR -140+[ebp], edx
	cmp	DWORD PTR -140+[ebp], 21		; 00000015H
	ja	SHORT $L39852
	mov	ecx, DWORD PTR -140+[ebp]
	xor	eax, eax
	mov	al, BYTE PTR $L41333[ecx]
	jmp	DWORD PTR $L41334[eax*4]
$L39852:

; 1914 : 	default:
; 1915 : 	case CHAR_TEX_CONCRETE: fvol = 0.9;	fvolbar = 0.6;

	mov	DWORD PTR _fvol$[ebp], 1063675494	; 3f666666H
	mov	DWORD PTR _fvolbar$[ebp], 1058642330	; 3f19999aH

; 1916 : 		rgsz[0] = "player/pl_step1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BE@DAFA@player?1pl_step1?4wav?$AA@ ; `string'

; 1917 : 		rgsz[1] = "player/pl_step2.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BE@NADP@player?1pl_step2?4wav?$AA@ ; `string'

; 1918 : 		cnt = 2;

	mov	DWORD PTR _cnt$[ebp], 2

; 1919 : 		break;

	jmp	$L39849
$L39855:

; 1920 : 	case CHAR_TEX_METAL: fvol = 0.9; fvolbar = 0.3;

	mov	DWORD PTR _fvol$[ebp], 1063675494	; 3f666666H
	mov	DWORD PTR _fvolbar$[ebp], 1050253722	; 3e99999aH

; 1921 : 		rgsz[0] = "player/pl_metal1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BF@LBED@player?1pl_metal1?4wav?$AA@ ; `string'

; 1922 : 		rgsz[1] = "player/pl_metal2.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BF@FBCM@player?1pl_metal2?4wav?$AA@ ; `string'

; 1923 : 		cnt = 2;

	mov	DWORD PTR _cnt$[ebp], 2

; 1924 : 		break;

	jmp	$L39849
$L39858:

; 1925 : 	case CHAR_TEX_DIRT:	fvol = 0.9; fvolbar = 0.1;

	mov	DWORD PTR _fvol$[ebp], 1063675494	; 3f666666H
	mov	DWORD PTR _fvolbar$[ebp], 1036831949	; 3dcccccdH

; 1926 : 		rgsz[0] = "player/pl_dirt1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BE@IGBB@player?1pl_dirt1?4wav?$AA@ ; `string'

; 1927 : 		rgsz[1] = "player/pl_dirt2.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BE@GGHO@player?1pl_dirt2?4wav?$AA@ ; `string'

; 1928 : 		rgsz[2] = "player/pl_dirt3.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BE@MGFL@player?1pl_dirt3?4wav?$AA@ ; `string'

; 1929 : 		cnt = 3;

	mov	DWORD PTR _cnt$[ebp], 3

; 1930 : 		break;

	jmp	$L39849
$L39862:

; 1931 : 	case CHAR_TEX_VENT:	fvol = 0.5; fvolbar = 0.3;

	mov	DWORD PTR _fvol$[ebp], 1056964608	; 3f000000H
	mov	DWORD PTR _fvolbar$[ebp], 1050253722	; 3e99999aH

; 1932 : 		rgsz[0] = "player/pl_duct1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BE@KCPJ@player?1pl_duct1?4wav?$AA@ ; `string'

; 1933 : 		rgsz[1] = "player/pl_duct1.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BE@KCPJ@player?1pl_duct1?4wav?$AA@ ; `string'

; 1934 : 		cnt = 2;

	mov	DWORD PTR _cnt$[ebp], 2

; 1935 : 		break;

	jmp	$L39849
$L39864:

; 1936 : 	case CHAR_TEX_GRATE: fvol = 0.9; fvolbar = 0.5;

	mov	DWORD PTR _fvol$[ebp], 1063675494	; 3f666666H
	mov	DWORD PTR _fvolbar$[ebp], 1056964608	; 3f000000H

; 1937 : 		rgsz[0] = "player/pl_grate1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BF@BEOK@player?1pl_grate1?4wav?$AA@ ; `string'

; 1938 : 		rgsz[1] = "player/pl_grate4.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BF@DEFK@player?1pl_grate4?4wav?$AA@ ; `string'

; 1939 : 		cnt = 2;

	mov	DWORD PTR _cnt$[ebp], 2

; 1940 : 		break;

	jmp	$L39849
$L39867:

; 1941 : 	case CHAR_TEX_TILE:	fvol = 0.8; fvolbar = 0.2;

	mov	DWORD PTR _fvol$[ebp], 1061997773	; 3f4ccccdH
	mov	DWORD PTR _fvolbar$[ebp], 1045220557	; 3e4ccccdH

; 1942 : 		rgsz[0] = "player/pl_tile1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BE@BHLL@player?1pl_tile1?4wav?$AA@ ; `string'

; 1943 : 		rgsz[1] = "player/pl_tile3.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BE@FHPB@player?1pl_tile3?4wav?$AA@ ; `string'

; 1944 : 		rgsz[2] = "player/pl_tile2.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BE@PHNE@player?1pl_tile2?4wav?$AA@ ; `string'

; 1945 : 		rgsz[3] = "player/pl_tile4.wav";

	mov	DWORD PTR _rgsz$[ebp+12], OFFSET FLAT:??_C@_0BE@DHAL@player?1pl_tile4?4wav?$AA@ ; `string'

; 1946 : 		cnt = 4;

	mov	DWORD PTR _cnt$[ebp], 4

; 1947 : 		break;

	jmp	$L39849
$L39872:

; 1948 : 	case CHAR_TEX_SLOSH: fvol = 0.9; fvolbar = 0.0;

	mov	DWORD PTR _fvol$[ebp], 1063675494	; 3f666666H
	mov	DWORD PTR _fvolbar$[ebp], 0

; 1949 : 		rgsz[0] = "player/pl_slosh1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BF@DKOO@player?1pl_slosh1?4wav?$AA@ ; `string'

; 1950 : 		rgsz[1] = "player/pl_slosh3.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BF@HKKE@player?1pl_slosh3?4wav?$AA@ ; `string'

; 1951 : 		rgsz[2] = "player/pl_slosh2.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BF@NKIB@player?1pl_slosh2?4wav?$AA@ ; `string'

; 1952 : 		rgsz[3] = "player/pl_slosh4.wav";

	mov	DWORD PTR _rgsz$[ebp+12], OFFSET FLAT:??_C@_0BF@BKFO@player?1pl_slosh4?4wav?$AA@ ; `string'

; 1953 : 		cnt = 4;

	mov	DWORD PTR _cnt$[ebp], 4

; 1954 : 		break;

	jmp	$L39849
$L39877:

; 1955 : 	case CHAR_TEX_WOOD: fvol = 0.9; fvolbar = 0.2;

	mov	DWORD PTR _fvol$[ebp], 1063675494	; 3f666666H
	mov	DWORD PTR _fvolbar$[ebp], 1045220557	; 3e4ccccdH

; 1956 : 		rgsz[0] = "debris/wood1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BB@MAKG@debris?1wood1?4wav?$AA@ ; `string'

; 1957 : 		rgsz[1] = "debris/wood2.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BB@CAMJ@debris?1wood2?4wav?$AA@ ; `string'

; 1958 : 		rgsz[2] = "debris/wood3.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BB@IAOM@debris?1wood3?4wav?$AA@ ; `string'

; 1959 : 		cnt = 3;

	mov	DWORD PTR _cnt$[ebp], 3

; 1960 : 		break;

	jmp	SHORT $L39849
$L39881:

; 1961 : 	case CHAR_TEX_GLASS:
; 1962 : 	case CHAR_TEX_COMPUTER:
; 1963 : 		fvol = 0.8; fvolbar = 0.2;

	mov	DWORD PTR _fvol$[ebp], 1061997773	; 3f4ccccdH
	mov	DWORD PTR _fvolbar$[ebp], 1045220557	; 3e4ccccdH

; 1964 : 		rgsz[0] = "debris/glass1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BC@JOHE@debris?1glass1?4wav?$AA@ ; `string'

; 1965 : 		rgsz[1] = "debris/glass2.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BC@HOBL@debris?1glass2?4wav?$AA@ ; `string'

; 1966 : 		rgsz[2] = "debris/glass3.wav";

	mov	DWORD PTR _rgsz$[ebp+8], OFFSET FLAT:??_C@_0BC@NODO@debris?1glass3?4wav?$AA@ ; `string'

; 1967 : 		cnt = 3;

	mov	DWORD PTR _cnt$[ebp], 3

; 1968 : 		break;

	jmp	SHORT $L39849
$L39885:

; 1969 : 	case CHAR_TEX_FLESH:
; 1970 : 		if (iBulletType == BULLET_PLAYER_CROWBAR)

	cmp	DWORD PTR _iBulletType$[ebp], 5
	jne	SHORT $L39886

; 1971 : 			return 0.0; // crowbar already makes this sound

	fld	DWORD PTR __real@4@00000000000000000000
	jmp	$L39825
$L39886:

; 1972 : 		fvol = 1.0;	fvolbar = 0.2;

	mov	DWORD PTR _fvol$[ebp], 1065353216	; 3f800000H
	mov	DWORD PTR _fvolbar$[ebp], 1045220557	; 3e4ccccdH

; 1973 : 		rgsz[0] = "weapons/bullet_hit1.wav";

	mov	DWORD PTR _rgsz$[ebp], OFFSET FLAT:??_C@_0BI@JLBM@weapons?1bullet_hit1?4wav?$AA@ ; `string'

; 1974 : 		rgsz[1] = "weapons/bullet_hit2.wav";

	mov	DWORD PTR _rgsz$[ebp+4], OFFSET FLAT:??_C@_0BI@HLHD@weapons?1bullet_hit2?4wav?$AA@ ; `string'

; 1975 : 		fattn = 1.0;

	mov	DWORD PTR _fattn$[ebp], 1065353216	; 3f800000H

; 1976 : 		cnt = 2;

	mov	DWORD PTR _cnt$[ebp], 2
$L39849:

; 1979 : 
; 1980 : 	// did we hit a breakable?
; 1981 : 
; 1982 : 	if (pEntity && FClassnameIs(pEntity->pev, "func_breakable"))

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L39889
	push	OFFSET FLAT:??_C@_0P@KFIJ@func_breakable?$AA@ ; `string'
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L39889

; 1984 : 		// drop volumes, the object will already play a damaged sound
; 1985 : 		fvol /= 1.5;

	fld	DWORD PTR _fvol$[ebp]
	fdiv	QWORD PTR __real@8@3fffc000000000000000
	fstp	DWORD PTR _fvol$[ebp]

; 1986 : 		fvolbar /= 2.0;	

	fld	DWORD PTR _fvolbar$[ebp]
	fdiv	QWORD PTR __real@8@40008000000000000000
	fstp	DWORD PTR _fvolbar$[ebp]

; 1988 : 	else if (chTextureType == CHAR_TEX_COMPUTER)

	jmp	$L39896
$L39889:
	movsx	ecx, BYTE PTR _chTextureType$[ebp]
	cmp	ecx, 80					; 00000050H
	jne	$L39896

; 1990 : 		// play random spark if computer
; 1991 : 
; 1992 : 		if ( ptr->flFraction != 1.0 && RANDOM_LONG(0,1))

	mov	edx, DWORD PTR _ptr$[ebp]
	fld	DWORD PTR [edx+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L39896
	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	je	$L39896

; 1994 : 			UTIL_Sparks( ptr->vecEndPos );

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	?UTIL_Sparks@@YAXABVVector@@@Z		; UTIL_Sparks
	add	esp, 4

; 1995 : 
; 1996 : 			float flVolume = RANDOM_FLOAT ( 0.7 , 1.0 );//random volume range

	push	1065353216				; 3f800000H
	push	1060320051				; 3f333333H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fstp	DWORD PTR _flVolume$39894[ebp]

; 1998 : 			{

	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR -144+[ebp], eax
	cmp	DWORD PTR -144+[ebp], 0
	je	SHORT $L39899
	cmp	DWORD PTR -144+[ebp], 1
	je	SHORT $L39902
	jmp	SHORT $L39896
$L39899:

; 1999 : 				case 0: UTIL_EmitAmbientSound(ENT(0), ptr->vecEndPos, "buttons/spark5.wav", flVolume, ATTN_NORM, 0, 100); break;

	push	100					; 00000064H
	push	0
	push	1061997773				; 3f4ccccdH
	mov	ecx, DWORD PTR _flVolume$39894[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BD@GNEE@buttons?1spark5?4wav?$AA@ ; `string'
	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	push	eax
	call	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ; UTIL_EmitAmbientSound
	add	esp, 28					; 0000001cH
	jmp	SHORT $L39896
$L39902:

; 2000 : 				case 1: UTIL_EmitAmbientSound(ENT(0), ptr->vecEndPos, "buttons/spark6.wav", flVolume, ATTN_NORM, 0, 100); break;

	push	100					; 00000064H
	push	0
	push	1061997773				; 3f4ccccdH
	mov	eax, DWORD PTR _flVolume$39894[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BD@INCL@buttons?1spark6?4wav?$AA@ ; `string'
	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	push	eax
	call	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ; UTIL_EmitAmbientSound
	add	esp, 28					; 0000001cH
$L39896:

; 2004 : 
; 2005 : 	// play material hit sound
; 2006 : 	UTIL_EmitAmbientSound(ENT(0), ptr->vecEndPos, rgsz[RANDOM_LONG(0,cnt-1)], fvol, fattn, 0, 96 + RANDOM_LONG(0,0xf));

	push	15					; 0000000fH
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 96					; 00000060H
	push	eax
	push	0
	mov	edx, DWORD PTR _fattn$[ebp]
	push	edx
	mov	eax, DWORD PTR _fvol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cnt$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	edx, DWORD PTR _rgsz$[ebp+eax*4]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	push	eax
	call	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ; UTIL_EmitAmbientSound
	add	esp, 28					; 0000001cH

; 2007 : 			
; 2008 : 	return fvolbar;

	fld	DWORD PTR _fvolbar$[ebp]
$L39825:

; 2009 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L41334:
	DD	$L39858
	DD	$L39885
	DD	$L39864
	DD	$L39855
	DD	$L39881
	DD	$L39872
	DD	$L39867
	DD	$L39862
	DD	$L39877
	DD	$L39852
$L41333:
	DB	0
	DB	9
	DB	1
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	5
	DB	6
	DB	9
	DB	7
	DB	8
	DB	9
	DB	4
?TEXTURETYPE_PlaySound@@YAMPAUgametrace_s@@VVector@@1H@Z ENDP ; TEXTURETYPE_PlaySound
_TEXT	ENDS
;	COMDAT ?CopyToArray@Vector@@QBEXPAM@Z
_TEXT	SEGMENT
_rgfl$ = 8
_this$ = -4
?CopyToArray@Vector@@QBEXPAM@Z PROC NEAR		; Vector::CopyToArray, COMDAT

; 225  : 	inline void CopyToArray( float *rgfl ) const	{ rgfl[0] = x, rgfl[1] = y, rgfl[2] = z; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _rgfl$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _rgfl$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _rgfl$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CopyToArray@Vector@@QBEXPAM@Z ENDP			; Vector::CopyToArray
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
PUBLIC	?FNullEnt@@YAHPAUentvars_s@@@Z			; FNullEnt
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT
_pev$ = 8
_szClassname$ = 12
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z PROC NEAR		; FClassnameIs, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 295  : 	if( FNullEnt( pev )) return FALSE;

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L32565
	xor	eax, eax
	jmp	SHORT $L32564
$L32565:

; 296  : 	return FStrEq( STRING( pev->classname ), szClassname );

	mov	ecx, DWORD PTR _szClassname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pev$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
$L32564:

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z ENDP		; FClassnameIs
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?FNullEnt@@YAHPAUentvars_s@@@Z PROC NEAR		; FNullEnt, COMDAT

; 196  : inline BOOL FNullEnt(entvars_t* pev)				{ return pev == NULL || FNullEnt(OFFSET(pev)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pev$[ebp], 0
	je	SHORT $L41343
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41343
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L41344
$L41343:
	mov	DWORD PTR -4+[ebp], 1
$L41344:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAUentvars_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad pev in OFFSET()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?OFFSET@@YAHPAUentvars_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L32439

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32439:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT _$E60
_TEXT	SEGMENT
_$E60	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E59
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E60	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCSpeaker@@@@QAE@PBD@Z	; CEntityFactory<CSpeaker>::CEntityFactory<CSpeaker>
PUBLIC	??_C@_07EJE@speaker?$AA@			; `string'
_BSS	SEGMENT
_speaker DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_07EJE@speaker?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_07EJE@speaker?$AA@ DB 'speaker', 00H		; `string'
CONST	ENDS
;	COMDAT _$E59
_TEXT	SEGMENT
_$E59	PROC NEAR					; COMDAT

; 2033 : LINK_ENTITY_TO_CLASS( speaker, CSpeaker );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_07EJE@speaker?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_speaker
	call	??0?$CEntityFactory@VCSpeaker@@@@QAE@PBD@Z ; CEntityFactory<CSpeaker>::CEntityFactory<CSpeaker>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E59	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CSpeaker@@UAEPAUdatamap_s@@XZ	; CSpeaker::GetDataDescMap
;	COMDAT ?GetDataDescMap@CSpeaker@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CSpeaker@@UAEPAUdatamap_s@@XZ PROC NEAR	; CSpeaker::GetDataDescMap, COMDAT

; 2035 : BEGIN_DATADESC( CSpeaker )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CSpeaker@@2Udatamap_s@@A ; CSpeaker::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CSpeaker@@UAEPAUdatamap_s@@XZ ENDP	; CSpeaker::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CSpeaker@@SAPAUdatamap_s@@XZ	; CSpeaker::GetBaseMap
;	COMDAT ?GetBaseMap@CSpeaker@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CSpeaker@@SAPAUdatamap_s@@XZ PROC NEAR	; CSpeaker::GetBaseMap, COMDAT

; 2035 : BEGIN_DATADESC( CSpeaker )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CSpeaker@@SAPAUdatamap_s@@XZ ENDP		; CSpeaker::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E63
_TEXT	SEGMENT
_$E63	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E62
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E63	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z	; DataMapInit
;	COMDAT _$E62
_TEXT	SEGMENT
_$E62	PROC NEAR					; COMDAT

; 2035 : BEGIN_DATADESC( CSpeaker )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CSpeaker_DataDescInit@@3PAUdatamap_s@@A, eax ; CSpeaker_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E62	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@ILNE@SpeakerThink?$AA@			; `string'
PUBLIC	?ToggleUse@CSpeaker@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CSpeaker::ToggleUse
PUBLIC	?SpeakerThink@CSpeaker@@QAEXXZ			; CSpeaker::SpeakerThink
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0N@ILNE@SpeakerThink?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0N@ILNE@SpeakerThink?$AA@ DB 'SpeakerThink', 00H	; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z PROC NEAR	; DataMapInit, COMDAT

; 2035 : BEGIN_DATADESC( CSpeaker )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L40014
	mov	cl, BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_08FPG@CSpeaker?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E66
	call	_atexit
	add	esp, 4
$L40014:
	call	?GetBaseMap@CSpeaker@@SAPAUdatamap_s@@XZ ; CSpeaker::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CSpeaker@@2Udatamap_s@@A+12, eax

; 2036 : 	DEFINE_KEYFIELD( m_preset, FIELD_INTEGER, "preset" ),
; 2037 : 	DEFINE_FUNCTION( SpeakerThink ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L40021
	mov	al, BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_0N@ILNE@SpeakerThink?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+52, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+56, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+60, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+62, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+64, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+68, OFFSET FLAT:?SpeakerThink@CSpeaker@@QAEXXZ ; CSpeaker::SpeakerThink

; 2038 : 	DEFINE_FUNCTION( ToggleUse ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+72, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_09CHGA@ToggleUse?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+76, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+80, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+84, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+86, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+88, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+92, OFFSET FLAT:?ToggleUse@CSpeaker@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CSpeaker::ToggleUse
$L40021:

; 2039 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L40027
	mov	DWORD PTR ?m_DataMap@CSpeaker@@2Udatamap_s@@A+4, 3
	mov	DWORD PTR ?m_DataMap@CSpeaker@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L40028
$L40027:
	mov	DWORD PTR ?m_DataMap@CSpeaker@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CSpeaker@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4PAUtypedescription_s@@A
$L40028:
	mov	eax, OFFSET FLAT:?m_DataMap@CSpeaker@@2Udatamap_s@@A ; CSpeaker::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z ENDP	; DataMapInit
_TEXT	ENDS
;	COMDAT _$E66
_TEXT	SEGMENT
_$E66	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCSpeaker@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E66	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@LKBA@SPEAKER?5with?5no?5Level?1Sentence?$CB?5@ ; `string'
PUBLIC	?Spawn@CSpeaker@@UAEXXZ				; CSpeaker::Spawn
;	COMDAT ??_C@_0DA@LKBA@SPEAKER?5with?5no?5Level?1Sentence?$CB?5@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0DA@LKBA@SPEAKER?5with?5no?5Level?1Sentence?$CB?5@ DB 'SPEAKER with'
	DB	' no Level/Sentence! at: %f, %f, %f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?Spawn@CSpeaker@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_szSoundFile$ = -8
_vecOrigin$40038 = -20
?Spawn@CSpeaker@@UAEXXZ PROC NEAR			; CSpeaker::Spawn, COMDAT

; 2045 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2046 : 	char* szSoundFile = (char*) STRING(pev->message);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _szSoundFile$[ebp], eax

; 2047 : 
; 2048 : 	if ( !m_preset && (FStringNull( pev->message ) || strlen( szSoundFile ) < 1 ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1764], 0
	jne	$L40036
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+468]
	push	eax
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40037
	mov	ecx, DWORD PTR _szSoundFile$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	eax, 1
	jae	SHORT $L40036
$L40037:

; 2050 : 		Vector vecOrigin = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecOrigin$40038[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2051 : 		ALERT( at_error, "SPEAKER with no Level/Sentence! at: %f, %f, %f\n", vecOrigin.x, vecOrigin.y, vecOrigin.z );

	fld	DWORD PTR _vecOrigin$40038[ebp+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _vecOrigin$40038[ebp+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _vecOrigin$40038[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0DA@LKBA@SPEAKER?5with?5no?5Level?1Sentence?$CB?5@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 32					; 00000020H

; 2052 : 		SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]

; 2053 : 		SetThink( SUB_Remove );

	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 2054 : 		return;

	jmp	SHORT $L40033
$L40036:

; 2056 : 
; 2057 : 	pev->solid = SOLID_NOT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 0

; 2058 : 	pev->movetype = MOVETYPE_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 0

; 2059 : 
; 2060 : 	SetThink( SpeakerThink );

	push	OFFSET FLAT:??_C@_0N@ILNE@SpeakerThink?$AA@ ; `string'
	push	OFFSET FLAT:?SpeakerThink@CSpeaker@@QAEXXZ ; CSpeaker::SpeakerThink
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 2061 : 	pev->nextthink = 0.0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+260], 0

; 2062 : 
; 2063 : 	// allow on/off switching via 'use' function.
; 2064 : 
; 2065 : 	SetUse ( ToggleUse );

	push	OFFSET FLAT:??_C@_09CHGA@ToggleUse?$AA@	; `string'
	push	OFFSET FLAT:?ToggleUse@CSpeaker@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CSpeaker::ToggleUse
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ; CBaseEntity::UseSet

; 2066 : 
; 2067 : 	Precache( );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]
$L40033:

; 2068 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CSpeaker@@UAEXXZ ENDP				; CSpeaker::Spawn
_TEXT	ENDS
PUBLIC	?Precache@CSpeaker@@UAEXXZ			; CSpeaker::Precache
;	COMDAT ?Precache@CSpeaker@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CSpeaker@@UAEXXZ PROC NEAR			; CSpeaker::Precache, COMDAT

; 2074 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2075 : 	if ( !FBitSet (pev->spawnflags, SPEAKER_START_SILENT ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1
	test	edx, edx
	jne	SHORT $L40055

; 2076 : 		// set first announcement time for random n second
; 2077 : 		pev->nextthink = gpGlobals->time + RANDOM_FLOAT(5.0, 15.0);

	push	1097859072				; 41700000H
	push	1084227584				; 40a00000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]
$L40055:

; 2078 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CSpeaker@@UAEXXZ ENDP				; CSpeaker::Precache
_TEXT	ENDS
PUBLIC	??_C@_05FGKA@C1A0_?$AA@				; `string'
PUBLIC	??_C@_05EAAK@C1A1_?$AA@				; `string'
PUBLIC	??_C@_05HLPF@C1A2_?$AA@				; `string'
PUBLIC	??_C@_05GNFP@C1A3_?$AA@				; `string'
PUBLIC	??_C@_05MAK@C1A4_?$AA@				; `string'
PUBLIC	??_C@_05CPPM@C2A1_?$AA@				; `string'
PUBLIC	??_C@_05BEAD@C2A2_?$AA@				; `string'
PUBLIC	??_C@_05CKJ@C2A3_?$AA@				; `string'
PUBLIC	??_C@_05GDPM@C2A4_?$AA@				; `string'
PUBLIC	??_C@_05HFFG@C2A5_?$AA@				; `string'
PUBLIC	??_C@_05KKO@C3A1_?$AA@				; `string'
PUBLIC	??_C@_05DBFB@C3A2_?$AA@				; `string'
PUBLIC	??_C@_0DN@CCLF@Level?5Design?5Error?$CB?6SPEAKER?5has?5@ ; `string'
PUBLIC	__real@4@4001a000000000000000
EXTRN	?g_talkWaitTime@CTalkMonster@@2MA:DWORD		; CTalkMonster::g_talkWaitTime
;	COMDAT ??_C@_05FGKA@C1A0_?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_05FGKA@C1A0_?$AA@ DB 'C1A0_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05EAAK@C1A1_?$AA@
CONST	SEGMENT
??_C@_05EAAK@C1A1_?$AA@ DB 'C1A1_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HLPF@C1A2_?$AA@
CONST	SEGMENT
??_C@_05HLPF@C1A2_?$AA@ DB 'C1A2_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GNFP@C1A3_?$AA@
CONST	SEGMENT
??_C@_05GNFP@C1A3_?$AA@ DB 'C1A3_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAK@C1A4_?$AA@
CONST	SEGMENT
??_C@_05MAK@C1A4_?$AA@ DB 'C1A4_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CPPM@C2A1_?$AA@
CONST	SEGMENT
??_C@_05CPPM@C2A1_?$AA@ DB 'C2A1_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BEAD@C2A2_?$AA@
CONST	SEGMENT
??_C@_05BEAD@C2A2_?$AA@ DB 'C2A2_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CKJ@C2A3_?$AA@
CONST	SEGMENT
??_C@_05CKJ@C2A3_?$AA@ DB 'C2A3_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GDPM@C2A4_?$AA@
CONST	SEGMENT
??_C@_05GDPM@C2A4_?$AA@ DB 'C2A4_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HFFG@C2A5_?$AA@
CONST	SEGMENT
??_C@_05HFFG@C2A5_?$AA@ DB 'C2A5_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKO@C3A1_?$AA@
CONST	SEGMENT
??_C@_05KKO@C3A1_?$AA@ DB 'C3A1_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DBFB@C3A2_?$AA@
CONST	SEGMENT
??_C@_05DBFB@C3A2_?$AA@ DB 'C3A2_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CCLF@Level?5Design?5Error?$CB?6SPEAKER?5has?5@
CONST	SEGMENT
??_C@_0DN@CCLF@Level?5Design?5Error?$CB?6SPEAKER?5has?5@ DB 'Level Design'
	DB	' Error!', 0aH, 'SPEAKER has bad sentence group name: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __real@4@4001a000000000000000
CONST	SEGMENT
__real@4@4001a000000000000000 DD 040a00000r	; 5
CONST	ENDS
;	COMDAT ?SpeakerThink@CSpeaker@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_szSoundFile$ = -8
_flvolume$ = -12
_flattenuation$ = -16
_flags$ = -20
_pitch$ = -24
?SpeakerThink@CSpeaker@@QAEXXZ PROC NEAR		; CSpeaker::SpeakerThink, COMDAT

; 2080 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2081 : 	char* szSoundFile;
; 2082 : 	float flvolume = pev->health * 0.1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+352]
	fmul	QWORD PTR __real@8@3ffbccccccccccccd000
	fstp	DWORD PTR _flvolume$[ebp]

; 2083 : 	float flattenuation = 0.3;

	mov	DWORD PTR _flattenuation$[ebp], 1050253722 ; 3e99999aH

; 2084 : 	int flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 2085 : 	int pitch = 100;

	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H

; 2086 : 
; 2087 : 
; 2088 : 	// Wait for the talkmonster to finish first.
; 2089 : 	if (gpGlobals->time <= CTalkMonster::g_talkWaitTime)

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fcomp	DWORD PTR ?g_talkWaitTime@CTalkMonster@@2MA ; CTalkMonster::g_talkWaitTime
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40065

; 2091 : 		pev->nextthink = CTalkMonster::g_talkWaitTime + RANDOM_FLOAT( 5, 10 );

	push	1092616192				; 41200000H
	push	1084227584				; 40a00000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR ?g_talkWaitTime@CTalkMonster@@2MA ; CTalkMonster::g_talkWaitTime
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+260]

; 2092 : 		return;

	jmp	$L40059
$L40065:

; 2094 : 	
; 2095 : 	if (m_preset)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1764], 0
	je	$L40066

; 2099 : 		{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1764]
	mov	DWORD PTR -28+[ebp], ecx
	mov	edx, DWORD PTR -28+[ebp]
	sub	edx, 1
	mov	DWORD PTR -28+[ebp], edx
	cmp	DWORD PTR -28+[ebp], 11			; 0000000bH
	ja	SHORT $L40068
	mov	eax, DWORD PTR -28+[ebp]
	jmp	DWORD PTR $L41375[eax*4]
$L40071:

; 2100 : 		case 1: szSoundFile =  "C1A0_"; break;

	mov	DWORD PTR _szSoundFile$[ebp], OFFSET FLAT:??_C@_05FGKA@C1A0_?$AA@ ; `string'
	jmp	SHORT $L40068
$L40073:

; 2101 : 		case 2: szSoundFile =  "C1A1_"; break;

	mov	DWORD PTR _szSoundFile$[ebp], OFFSET FLAT:??_C@_05EAAK@C1A1_?$AA@ ; `string'
	jmp	SHORT $L40068
$L40075:

; 2102 : 		case 3: szSoundFile =  "C1A2_"; break;

	mov	DWORD PTR _szSoundFile$[ebp], OFFSET FLAT:??_C@_05HLPF@C1A2_?$AA@ ; `string'
	jmp	SHORT $L40068
$L40077:

; 2103 : 		case 4: szSoundFile =  "C1A3_"; break;

	mov	DWORD PTR _szSoundFile$[ebp], OFFSET FLAT:??_C@_05GNFP@C1A3_?$AA@ ; `string'
	jmp	SHORT $L40068
$L40079:

; 2104 : 		case 5: szSoundFile =  "C1A4_"; break; 

	mov	DWORD PTR _szSoundFile$[ebp], OFFSET FLAT:??_C@_05MAK@C1A4_?$AA@ ; `string'
	jmp	SHORT $L40068
$L40081:

; 2105 : 		case 6: szSoundFile =  "C2A1_"; break;

	mov	DWORD PTR _szSoundFile$[ebp], OFFSET FLAT:??_C@_05CPPM@C2A1_?$AA@ ; `string'
	jmp	SHORT $L40068
$L40083:

; 2106 : 		case 7: szSoundFile =  "C2A2_"; break;

	mov	DWORD PTR _szSoundFile$[ebp], OFFSET FLAT:??_C@_05BEAD@C2A2_?$AA@ ; `string'
	jmp	SHORT $L40068
$L40085:

; 2107 : 		case 8: szSoundFile =  "C2A3_"; break;

	mov	DWORD PTR _szSoundFile$[ebp], OFFSET FLAT:??_C@_05CKJ@C2A3_?$AA@ ; `string'
	jmp	SHORT $L40068
$L40087:

; 2108 : 		case 9: szSoundFile =  "C2A4_"; break;

	mov	DWORD PTR _szSoundFile$[ebp], OFFSET FLAT:??_C@_05GDPM@C2A4_?$AA@ ; `string'
	jmp	SHORT $L40068
$L40089:

; 2109 : 		case 10: szSoundFile = "C2A5_"; break;

	mov	DWORD PTR _szSoundFile$[ebp], OFFSET FLAT:??_C@_05HFFG@C2A5_?$AA@ ; `string'
	jmp	SHORT $L40068
$L40091:

; 2110 : 		case 11: szSoundFile = "C3A1_"; break;

	mov	DWORD PTR _szSoundFile$[ebp], OFFSET FLAT:??_C@_05KKO@C3A1_?$AA@ ; `string'
	jmp	SHORT $L40068
$L40093:

; 2111 : 		case 12: szSoundFile = "C3A2_"; break;

	mov	DWORD PTR _szSoundFile$[ebp], OFFSET FLAT:??_C@_05DBFB@C3A2_?$AA@ ; `string'
$L40068:

; 2113 : 	} else

	jmp	SHORT $L40095
$L40066:

; 2114 : 		szSoundFile = (char*) STRING(pev->message);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+468]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _szSoundFile$[ebp], eax
$L40095:

; 2115 : 	
; 2116 : 	if (szSoundFile[0] == '!')

	mov	ecx, DWORD PTR _szSoundFile$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 33					; 00000021H
	jne	SHORT $L40097

; 2118 : 		// play single sentence, one shot
; 2119 : 		UTIL_EmitAmbientSound( edict(), GetAbsOrigin(), szSoundFile, flvolume, flattenuation, flags, pitch );

	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flattenuation$[ebp]
	push	edx
	mov	eax, DWORD PTR _flvolume$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szSoundFile$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ; UTIL_EmitAmbientSound
	add	esp, 28					; 0000001cH

; 2120 : 
; 2121 : 		// shut off and reset
; 2122 : 		pev->nextthink = 0.0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+260], 0

; 2124 : 	else

	jmp	SHORT $L40098
$L40097:

; 2126 : 		// make random announcement from sentence group
; 2127 : 
; 2128 : 		if (SENTENCEG_PlayRndSz(ENT(pev), szSoundFile, flvolume, flattenuation, flags, pitch) < 0)

	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _flattenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flvolume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szSoundFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H
	test	eax, eax
	jge	SHORT $L40099

; 2129 : 			ALERT(at_console, "Level Design Error!\nSPEAKER has bad sentence group name: %s\n",szSoundFile); 

	mov	edx, DWORD PTR _szSoundFile$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0DN@CCLF@Level?5Design?5Error?$CB?6SPEAKER?5has?5@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L40099:

; 2133 : 						RANDOM_FLOAT(ANNOUNCE_MINUTES_MIN * 60.0, ANNOUNCE_MINUTES_MAX * 60.0);

	push	1124532224				; 43070000H
	push	1097859072				; 41700000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 2134 : 
; 2135 : 		CTalkMonster::g_talkWaitTime = gpGlobals->time + 5;		// time delay until it's ok to speak: used so that two NPCs don't talk at once

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@4001a000000000000000
	fstp	DWORD PTR ?g_talkWaitTime@CTalkMonster@@2MA ; CTalkMonster::g_talkWaitTime
$L40098:
$L40059:

; 2137 : 
; 2138 : 	return;
; 2139 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L41375:
	DD	$L40071
	DD	$L40073
	DD	$L40075
	DD	$L40077
	DD	$L40079
	DD	$L40081
	DD	$L40083
	DD	$L40085
	DD	$L40087
	DD	$L40089
	DD	$L40091
	DD	$L40093
?SpeakerThink@CSpeaker@@QAEXXZ ENDP			; CSpeaker::SpeakerThink
_TEXT	ENDS
;	COMDAT ?ToggleUse@CSpeaker@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_useType$ = 16
_this$ = -4
_fActive$ = -8
?ToggleUse@CSpeaker@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CSpeaker::ToggleUse, COMDAT

; 2146 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2147 : 	int fActive = (pev->nextthink > 0.0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+260]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41378
	mov	DWORD PTR -12+[ebp], 1
	jmp	SHORT $L41379
$L41378:
	mov	DWORD PTR -12+[ebp], 0
$L41379:
	mov	edx, DWORD PTR -12+[ebp]
	mov	DWORD PTR _fActive$[ebp], edx

; 2148 : 
; 2149 : 	// fActive is TRUE only if an announcement is pending
; 2150 : 	
; 2151 : 	if ( useType != USE_TOGGLE )

	cmp	DWORD PTR _useType$[ebp], 3
	je	SHORT $L40110

; 2153 : 		// ignore if we're just turning something on that's already on, or
; 2154 : 		// turning something off that's already off.
; 2155 : 		if ( (fActive && useType == USE_ON) || (!fActive && useType == USE_OFF) )

	cmp	DWORD PTR _fActive$[ebp], 0
	je	SHORT $L40112
	cmp	DWORD PTR _useType$[ebp], 1
	je	SHORT $L40111
$L40112:
	cmp	DWORD PTR _fActive$[ebp], 0
	jne	SHORT $L40110
	cmp	DWORD PTR _useType$[ebp], 0
	jne	SHORT $L40110
$L40111:

; 2156 : 			return;

	jmp	SHORT $L40107
$L40110:

; 2158 : 
; 2159 : 	if ( useType == USE_ON )

	cmp	DWORD PTR _useType$[ebp], 1
	jne	SHORT $L40113

; 2161 : 		// turn on announcements
; 2162 : 		pev->nextthink = gpGlobals->time + 0.1;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -16+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 2163 : 		return;

	jmp	SHORT $L40107
$L40113:

; 2165 : 
; 2166 : 	if ( useType == USE_OFF )

	cmp	DWORD PTR _useType$[ebp], 0
	jne	SHORT $L40114

; 2168 : 		// turn off announcements
; 2169 : 		pev->nextthink = 0.0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+260], 0

; 2170 : 		return;

	jmp	SHORT $L40107
$L40114:

; 2173 : 
; 2174 : 	// Toggle announcements
; 2175 : 
; 2176 : 	
; 2177 : 	if ( fActive )

	cmp	DWORD PTR _fActive$[ebp], 0
	je	SHORT $L40115

; 2179 : 		// turn off announcements
; 2180 : 		pev->nextthink = 0.0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+260], 0

; 2182 : 	else 

	jmp	SHORT $L40116
$L40115:

; 2184 : 		// turn on announcements
; 2185 : 		pev->nextthink = gpGlobals->time + 0.1;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -20+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+260]
$L40116:
$L40107:

; 2187 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ToggleUse@CSpeaker@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CSpeaker::ToggleUse
_TEXT	ENDS
PUBLIC	?KeyValue@CSpeaker@@UAEXPAUKeyValueData_s@@@Z	; CSpeaker::KeyValue
;	COMDAT ?KeyValue@CSpeaker@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CSpeaker@@UAEXPAUKeyValueData_s@@@Z PROC NEAR	; CSpeaker::KeyValue, COMDAT

; 2193 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2194 : 	
; 2195 : 	// preset
; 2196 : 	if (FStrEq(pkvd->szKeyName, "preset"))

	push	OFFSET FLAT:??_C@_06FAOG@preset?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L40121

; 2198 : 		m_preset = atoi(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1764], eax

; 2199 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 2201 : 	else

	jmp	SHORT $L40122
$L40121:

; 2202 : 		BaseClass::KeyValue( pkvd );

	mov	eax, DWORD PTR _pkvd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
$L40122:

; 2203 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CSpeaker@@UAEXPAUKeyValueData_s@@@Z ENDP	; CSpeaker::KeyValue
_TEXT	ENDS
;	COMDAT _$E68
_TEXT	SEGMENT
_$E68	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E67
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E68	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCAmbientMusic@@@@QAE@PBD@Z	; CEntityFactory<CAmbientMusic>::CEntityFactory<CAmbientMusic>
PUBLIC	??_C@_0O@MEEO@ambient_music?$AA@		; `string'
_BSS	SEGMENT
	ALIGN	4

_ambient_music DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@MEEO@ambient_music?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0O@MEEO@ambient_music?$AA@ DB 'ambient_music', 00H ; `string'
CONST	ENDS
;	COMDAT _$E67
_TEXT	SEGMENT
_$E67	PROC NEAR					; COMDAT

; 2221 : LINK_ENTITY_TO_CLASS( ambient_music, CAmbientMusic );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0O@MEEO@ambient_music?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_ambient_music
	call	??0?$CEntityFactory@VCAmbientMusic@@@@QAE@PBD@Z ; CEntityFactory<CAmbientMusic>::CEntityFactory<CAmbientMusic>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E67	ENDP
_TEXT	ENDS
PUBLIC	?KeyValue@CAmbientMusic@@UAEXPAUKeyValueData_s@@@Z ; CAmbientMusic::KeyValue
PUBLIC	??_C@_0BA@NPLG@m_iszIntroTrack?$AA@		; `string'
PUBLIC	??_C@_0P@LDKH@m_iszMainTrack?$AA@		; `string'
PUBLIC	??_C@_08KCA@fadetime?$AA@			; `string'
;	COMDAT ??_C@_0BA@NPLG@m_iszIntroTrack?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0BA@NPLG@m_iszIntroTrack?$AA@ DB 'm_iszIntroTrack', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LDKH@m_iszMainTrack?$AA@
CONST	SEGMENT
??_C@_0P@LDKH@m_iszMainTrack?$AA@ DB 'm_iszMainTrack', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KCA@fadetime?$AA@
CONST	SEGMENT
??_C@_08KCA@fadetime?$AA@ DB 'fadetime', 00H		; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CAmbientMusic@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CAmbientMusic@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CAmbientMusic::KeyValue, COMDAT

; 2224 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2225 : 	if (FStrEq(pkvd->szKeyName, "m_iszIntroTrack"))

	push	OFFSET FLAT:??_C@_0BA@NPLG@m_iszIntroTrack?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L40190

; 2227 : 		pev->netname = ALLOC_STRING(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+464], eax

; 2228 : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 2230 : 	else if (FStrEq(pkvd->szKeyName, "m_iszMainTrack"))

	jmp	$L40198
$L40190:
	push	OFFSET FLAT:??_C@_0P@LDKH@m_iszMainTrack?$AA@ ; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L40193

; 2232 : 		pev->message = ALLOC_STRING( pkvd->szValue );

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+468], eax

; 2233 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 2235 : 	else if (FStrEq(pkvd->szKeyName, "fadetime"))

	jmp	SHORT $L40198
$L40193:
	push	OFFSET FLAT:??_C@_08KCA@fadetime?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L40196

; 2237 : 		pev->frags = atoi(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	fild	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+356]

; 2238 : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 2240 : 	else

	jmp	SHORT $L40198
$L40196:

; 2241 : 		BaseClass::KeyValue( pkvd );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z ; CBaseDelay::KeyValue
$L40198:

; 2242 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CAmbientMusic@@UAEXPAUKeyValueData_s@@@Z ENDP	; CAmbientMusic::KeyValue
_TEXT	ENDS
PUBLIC	?Spawn@CAmbientMusic@@UAEXXZ			; CAmbientMusic::Spawn
;	COMDAT ?Spawn@CAmbientMusic@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CAmbientMusic@@UAEXXZ PROC NEAR			; CAmbientMusic::Spawn, COMDAT

; 2245 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2246 : 	// check for possible errors
; 2247 : 	if( !pev->message && pev->netname )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+468], 0
	jne	SHORT $L40203
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+464], 0
	je	SHORT $L40203

; 2249 : 		pev->message = pev->netname;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+464]
	mov	DWORD PTR [ecx+468], edx

; 2250 : 		pev->netname = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+464], 0
$L40203:

; 2252 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CAmbientMusic@@UAEXXZ ENDP			; CAmbientMusic::Spawn
_TEXT	ENDS
PUBLIC	?PlayStream@CAmbientMusic@@QAEXPAVCBasePlayer@@_N@Z ; CAmbientMusic::PlayStream
PUBLIC	?StartMessage@CAmbientMusic@@UAEXPAVCBasePlayer@@@Z ; CAmbientMusic::StartMessage
;	COMDAT ?StartMessage@CAmbientMusic@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_this$ = -4
?StartMessage@CAmbientMusic@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CAmbientMusic::StartMessage, COMDAT

; 2255 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2256 : 	if( pev->button ) return; // fire once at spawn

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+384], 0
	je	SHORT $L40208
	jmp	SHORT $L40207
$L40208:

; 2257 : 
; 2258 : 	if( FBitSet( pev->spawnflags, SF_START_ON ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L40209

; 2259 : 		PlayStream( pPlayer, true );

	push	1
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlayStream@CAmbientMusic@@QAEXPAVCBasePlayer@@_N@Z ; CAmbientMusic::PlayStream
$L40209:

; 2260 : 	pev->button = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+384], 1
$L40207:

; 2261 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartMessage@CAmbientMusic@@UAEXPAVCBasePlayer@@@Z ENDP ; CAmbientMusic::StartMessage
_TEXT	ENDS
PUBLIC	??_C@_0BB@DEKJ@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6?$AA@ ; `string'
PUBLIC	??_C@_0M@BLOK@music?5?$CC?$CFs?$CC?6?$AA@	; `string'
PUBLIC	??_C@_06BJGF@music?6?$AA@			; `string'
PUBLIC	?GetMessageA@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetMessageA
PUBLIC	?GetNetname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetNetname
;	COMDAT ??_C@_0BB@DEKJ@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6?$AA@
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
??_C@_0BB@DEKJ@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6?$AA@ DB 'music "%s" '
	DB	'"%s"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BLOK@music?5?$CC?$CFs?$CC?6?$AA@
CONST	SEGMENT
??_C@_0M@BLOK@music?5?$CC?$CFs?$CC?6?$AA@ DB 'music "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BJGF@music?6?$AA@
CONST	SEGMENT
??_C@_06BJGF@music?6?$AA@ DB 'music', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?PlayStream@CAmbientMusic@@QAEXPAVCBasePlayer@@_N@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_bPlay$ = 12
_this$ = -4
?PlayStream@CAmbientMusic@@QAEXPAVCBasePlayer@@_N@Z PROC NEAR ; CAmbientMusic::PlayStream, COMDAT

; 2264 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2265 : 	if( !pPlayer ) return; // not spawned?

	cmp	DWORD PTR _pPlayer$[ebp], 0
	jne	SHORT $L40215
	jmp	$L40214
$L40215:

; 2266 : 
; 2267 : 	if( bPlay )

	mov	eax, DWORD PTR _bPlay$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L40216

; 2269 : 		if( pev->netname && pev->message )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+464], 0
	je	SHORT $L40217
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+468], 0
	je	SHORT $L40217

; 2270 : 			CLIENT_COMMAND( pPlayer->edict(), "music \"%s\" \"%s\"\n", GetNetname(), GetMessage());	// intro + loop

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMessageA@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetMessageA
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetNetname
	push	eax
	push	OFFSET FLAT:??_C@_0BB@DEKJ@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6?$AA@ ; `string'
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+164
	add	esp, 16					; 00000010H

; 2271 : 		else if( FBitSet( pev->spawnflags, SF_LOOP ))

	jmp	SHORT $L40221
$L40217:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L40220

; 2272 : 			CLIENT_COMMAND( pPlayer->edict(), "music \"%s\" \"%s\"\n", GetMessage(), GetMessage());	// loop

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMessageA@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetMessageA
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMessageA@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetMessageA
	push	eax
	push	OFFSET FLAT:??_C@_0BB@DEKJ@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6?$AA@ ; `string'
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+164
	add	esp, 16					; 00000010H

; 2273 : 		else

	jmp	SHORT $L40221
$L40220:

; 2274 : 			CLIENT_COMMAND( pPlayer->edict(), "music \"%s\"\n", GetMessage());			// one pass

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMessageA@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetMessageA
	push	eax
	push	OFFSET FLAT:??_C@_0M@BLOK@music?5?$CC?$CFs?$CC?6?$AA@ ; `string'
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+164
	add	esp, 12					; 0000000cH
$L40221:

; 2276 : 	else if( pev->frags )

	jmp	SHORT $L40225
$L40216:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+356]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L40224

; 2278 : 		// run fading out like in Paranoia
; 2279 : 		pev->dmgtime = gpGlobals->time;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+484], ecx

; 2280 : 		SetNextThink( 0.01 );

	push	1008981770				; 3c23d70aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]

; 2282 : 	else

	jmp	SHORT $L40225
$L40224:

; 2284 : 		CLIENT_COMMAND( pPlayer->edict(), "music\n" );						// stop

	push	OFFSET FLAT:??_C@_06BJGF@music?6?$AA@	; `string'
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+164
	add	esp, 8
$L40225:
$L40214:

; 2286 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?PlayStream@CAmbientMusic@@QAEXPAVCBasePlayer@@_N@Z ENDP ; CAmbientMusic::PlayStream
_TEXT	ENDS
;	COMDAT ?GetMessageA@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetMessageA@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetMessageA, COMDAT

; 286  : 	const char*	GetMessage() { return STRING( pev->message ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMessageA@CBaseEntity@@QAEPBDXZ ENDP			; CBaseEntity::GetMessageA
_TEXT	ENDS
;	COMDAT ?GetNetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetNetname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetNetname, COMDAT

; 287  : 	const char*	GetNetname() { return STRING( pev->netname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNetname@CBaseEntity@@QAEPBDXZ ENDP			; CBaseEntity::GetNetname
_TEXT	ENDS
PUBLIC	?Use@CAmbientMusic@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CAmbientMusic::Use
EXTRN	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z:NEAR ; CBaseEntity::ShouldToggle
EXTRN	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z:NEAR	; UTIL_PlayerByIndex
;	COMDAT ?Use@CAmbientMusic@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_useType$ = 16
_this$ = -4
_i$ = -8
_pPlayer$40240 = -12
?Use@CAmbientMusic@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CAmbientMusic::Use, COMDAT

; 2289 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2290 : 	if( !ShouldToggle( useType ))

	mov	eax, DWORD PTR _useType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z ; CBaseEntity::ShouldToggle
	test	eax, eax
	jne	SHORT $L40234

; 2291 : 		return;

	jmp	$L40233
$L40234:

; 2292 : 
; 2293 : 	if( pev->dmgtime ) return; // soundtrack is fading out	

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+484]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L40235
	jmp	$L40233
$L40235:

; 2294 : 
; 2295 : 	// send to all the clients
; 2296 : 	for( int i = 1; i <= gpGlobals->maxClients; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L40237
$L40238:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L40237:
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+144]
	jg	SHORT $L40239

; 2298 : 		CBasePlayer *pPlayer = (CBasePlayer *)UTIL_PlayerByIndex( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pPlayer$40240[ebp], eax

; 2299 : 		PlayStream( pPlayer, !FBitSet( pev->spawnflags, SF_START_ON ));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 1
	neg	eax
	sbb	eax, eax
	inc	eax
	push	eax
	mov	ecx, DWORD PTR _pPlayer$40240[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlayStream@CAmbientMusic@@QAEXPAVCBasePlayer@@_N@Z ; CAmbientMusic::PlayStream

; 2300 : 	}

	jmp	SHORT $L40238
$L40239:

; 2301 : 
; 2302 : 	if( FBitSet( pev->spawnflags, SF_START_ON ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L40242

; 2303 : 		ClearBits( pev->spawnflags, SF_START_ON );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+416], ecx

; 2304 : 	else SetBits( pev->spawnflags, SF_START_ON );

	jmp	SHORT $L40243
$L40242:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	or	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+416], eax
$L40243:
$L40233:

; 2305 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CAmbientMusic@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CAmbientMusic::Use
_TEXT	ENDS
PUBLIC	?Think@CAmbientMusic@@UAEXXZ			; CAmbientMusic::Think
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	__real@4@400c9c40000000000000
PUBLIC	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z		; MESSAGE_BEGIN
EXTRN	?gmsgMusicFade@@3HA:DWORD			; gmsgMusicFade
;	COMDAT __real@4@3fff8000000000000000
; File z:\xashxtsrc\server\sound.cpp
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT __real@4@400c9c40000000000000
CONST	SEGMENT
__real@4@400c9c40000000000000 DD 0461c4000r	; 10000
CONST	ENDS
;	COMDAT ?Think@CAmbientMusic@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_elapsed$ = -8
_f$ = -12
_i$40251 = -16
_pPlayer$40255 = -20
?Think@CAmbientMusic@@UAEXXZ PROC NEAR			; CAmbientMusic::Think, COMDAT

; 2308 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2309 : 	float elapsed = gpGlobals->time - pev->dmgtime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [ecx+484]
	fstp	DWORD PTR _elapsed$[ebp]

; 2310 : 	float f = elapsed / pev->frags;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR _elapsed$[ebp]
	fdiv	DWORD PTR [ecx+356]
	fst	DWORD PTR _f$[ebp]

; 2311 : 	f = bound( 0.0f, f, 1.0f );

	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L41404
	fld	DWORD PTR _f$[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41402
	mov	edx, DWORD PTR _f$[ebp]
	mov	DWORD PTR -24+[ebp], edx
	jmp	SHORT $L41403
$L41402:
	mov	DWORD PTR -24+[ebp], 1065353216		; 3f800000H
$L41403:
	mov	eax, DWORD PTR -24+[ebp]
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41405
$L41404:
	mov	DWORD PTR -28+[ebp], 0
$L41405:
	mov	ecx, DWORD PTR -28+[ebp]
	mov	DWORD PTR _f$[ebp], ecx

; 2312 : 
; 2313 : 	MESSAGE_BEGIN( MSG_ALL, gmsgMusicFade );

	push	0
	push	0
	mov	edx, DWORD PTR ?gmsgMusicFade@@3HA	; gmsgMusicFade
	push	edx
	push	2
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 2314 : 		WRITE_SHORT( f * 10000 );

	fld	DWORD PTR _f$[ebp]
	fmul	DWORD PTR __real@4@400c9c40000000000000
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 2315 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 2316 : 
; 2317 : 	if( f == 1.0f )	// hit 100% fade

	cmp	DWORD PTR _f$[ebp], 1065353216		; 3f800000H
	jne	SHORT $L40250

; 2319 : 		// send stop to all the clients
; 2320 : 		for( int i = 1; i <= gpGlobals->maxClients; i++ )

	mov	DWORD PTR _i$40251[ebp], 1
	jmp	SHORT $L40252
$L40253:
	mov	eax, DWORD PTR _i$40251[ebp]
	add	eax, 1
	mov	DWORD PTR _i$40251[ebp], eax
$L40252:
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _i$40251[ebp]
	cmp	edx, DWORD PTR [ecx+144]
	jg	SHORT $L40254

; 2322 : 			CBasePlayer *pPlayer = (CBasePlayer *)UTIL_PlayerByIndex( i );

	mov	eax, DWORD PTR _i$40251[ebp]
	push	eax
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pPlayer$40255[ebp], eax

; 2323 : 			if( pPlayer ) CLIENT_COMMAND( pPlayer->edict(), "music\n" );

	cmp	DWORD PTR _pPlayer$40255[ebp], 0
	je	SHORT $L40257
	push	OFFSET FLAT:??_C@_06BJGF@music?6?$AA@	; `string'
	mov	ecx, DWORD PTR _pPlayer$40255[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+164
	add	esp, 8
$L40257:

; 2324 : 		}

	jmp	SHORT $L40253
$L40254:

; 2325 : 
; 2326 : 		ClearBits( pev->spawnflags, SF_START_ON );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	al, -2					; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+416], eax

; 2327 : 		pev->dmgtime = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+484], 0

; 2328 : 		return;

	jmp	SHORT $L40247
$L40250:

; 2330 : 
; 2331 : 	SetNextThink( 0.01 );

	push	1008981770				; 3c23d70aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]
$L40247:

; 2332 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CAmbientMusic@@UAEXXZ ENDP			; CAmbientMusic::Think
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_type$ = 12
_pOrigin$ = 16
_ed$ = 20
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z PROC NEAR	; MESSAGE_BEGIN, COMDAT

; 72   : inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin = NULL, edict_t *ed = NULL ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 73   : 	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ed);

	mov	eax, DWORD PTR _ed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+184
	add	esp, 16					; 00000010H

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z ENDP		; MESSAGE_BEGIN
_TEXT	ENDS
PUBLIC	??0IEntityFactory@@QAE@XZ			; IEntityFactory::IEntityFactory
PUBLIC	?Create@?$CEntityFactory@VCAmbientGeneric@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CAmbientGeneric>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCAmbientGeneric@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CAmbientGeneric>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCAmbientGeneric@@@@UAEIXZ ; CEntityFactory<CAmbientGeneric>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCAmbientGeneric@@@@6B@	; CEntityFactory<CAmbientGeneric>::`vftable'
EXTRN	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ:NEAR ; EntityFactoryDictionary
;	COMDAT ??_7?$CEntityFactory@VCAmbientGeneric@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCAmbientGeneric@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCAmbientGeneric@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CAmbientGeneric>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCAmbientGeneric@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCAmbientGeneric@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCAmbientGeneric@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCAmbientGeneric@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CAmbientGeneric>::CEntityFactory<CAmbientGeneric>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCAmbientGeneric@@@@6B@ ; CEntityFactory<CAmbientGeneric>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCAmbientGeneric@@@@QAE@PBD@Z ENDP	; CEntityFactory<CAmbientGeneric>::CEntityFactory<CAmbientGeneric>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCAmbientGeneric@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCAmbientGeneric@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CAmbientGeneric>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCAmbientGeneric@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CAmbientGeneric>::Create
_TEXT	ENDS
EXTRN	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_Remove
;	COMDAT ?Destroy@?$CEntityFactory@VCAmbientGeneric@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCAmbientGeneric@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CAmbientGeneric>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCAmbientGeneric@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CAmbientGeneric>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCAmbientGeneric@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCAmbientGeneric@@@@UAEIXZ PROC NEAR ; CEntityFactory<CAmbientGeneric>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1880				; 00000758H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCAmbientGeneric@@@@UAEIXZ ENDP ; CEntityFactory<CAmbientGeneric>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCEnvSound@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CEnvSound>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCEnvSound@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CEnvSound>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCEnvSound@@@@UAEIXZ ; CEntityFactory<CEnvSound>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCEnvSound@@@@6B@		; CEntityFactory<CEnvSound>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCEnvSound@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCEnvSound@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCEnvSound@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CEnvSound>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCEnvSound@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCEnvSound@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCEnvSound@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCEnvSound@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CEnvSound>::CEntityFactory<CEnvSound>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCEnvSound@@@@6B@ ; CEntityFactory<CEnvSound>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCEnvSound@@@@QAE@PBD@Z ENDP	; CEntityFactory<CEnvSound>::CEntityFactory<CEnvSound>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCEnvSound@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCEnvSound@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CEnvSound>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCEnvSound@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CEnvSound>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCEnvSound@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCEnvSound@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CEnvSound>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCEnvSound@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CEnvSound>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCEnvSound@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCEnvSound@@@@UAEIXZ PROC NEAR ; CEntityFactory<CEnvSound>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1772				; 000006ecH

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCEnvSound@@@@UAEIXZ ENDP ; CEntityFactory<CEnvSound>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCTriggerSound@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CTriggerSound>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCTriggerSound@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CTriggerSound>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCTriggerSound@@@@UAEIXZ ; CEntityFactory<CTriggerSound>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCTriggerSound@@@@6B@	; CEntityFactory<CTriggerSound>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCTriggerSound@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCTriggerSound@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCTriggerSound@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CTriggerSound>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCTriggerSound@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCTriggerSound@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCTriggerSound@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCTriggerSound@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CTriggerSound>::CEntityFactory<CTriggerSound>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCTriggerSound@@@@6B@ ; CEntityFactory<CTriggerSound>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCTriggerSound@@@@QAE@PBD@Z ENDP	; CEntityFactory<CTriggerSound>::CEntityFactory<CTriggerSound>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCTriggerSound@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCTriggerSound@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CTriggerSound>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCTriggerSound@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CTriggerSound>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCTriggerSound@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCTriggerSound@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CTriggerSound>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCTriggerSound@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CTriggerSound>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCTriggerSound@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCTriggerSound@@@@UAEIXZ PROC NEAR ; CEntityFactory<CTriggerSound>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1792				; 00000700H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCTriggerSound@@@@UAEIXZ ENDP ; CEntityFactory<CTriggerSound>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCSpeaker@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CSpeaker>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCSpeaker@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CSpeaker>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCSpeaker@@@@UAEIXZ ; CEntityFactory<CSpeaker>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCSpeaker@@@@6B@		; CEntityFactory<CSpeaker>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCSpeaker@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCSpeaker@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCSpeaker@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CSpeaker>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCSpeaker@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCSpeaker@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCSpeaker@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCSpeaker@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CSpeaker>::CEntityFactory<CSpeaker>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCSpeaker@@@@6B@ ; CEntityFactory<CSpeaker>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCSpeaker@@@@QAE@PBD@Z ENDP		; CEntityFactory<CSpeaker>::CEntityFactory<CSpeaker>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z		; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCSpeaker@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCSpeaker@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CSpeaker>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z	; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCSpeaker@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CSpeaker>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCSpeaker@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCSpeaker@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CSpeaker>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCSpeaker@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CSpeaker>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCSpeaker@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCSpeaker@@@@UAEIXZ PROC NEAR ; CEntityFactory<CSpeaker>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1768				; 000006e8H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCSpeaker@@@@UAEIXZ ENDP ; CEntityFactory<CSpeaker>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCAmbientMusic@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CAmbientMusic>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCAmbientMusic@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CAmbientMusic>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCAmbientMusic@@@@UAEIXZ ; CEntityFactory<CAmbientMusic>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCAmbientMusic@@@@6B@	; CEntityFactory<CAmbientMusic>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCAmbientMusic@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCAmbientMusic@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCAmbientMusic@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CAmbientMusic>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCAmbientMusic@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCAmbientMusic@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCAmbientMusic@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCAmbientMusic@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CAmbientMusic>::CEntityFactory<CAmbientMusic>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCAmbientMusic@@@@6B@ ; CEntityFactory<CAmbientMusic>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCAmbientMusic@@@@QAE@PBD@Z ENDP	; CEntityFactory<CAmbientMusic>::CEntityFactory<CAmbientMusic>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCAmbientMusic@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCAmbientMusic@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CAmbientMusic>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCAmbientMusic@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CAmbientMusic>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCAmbientMusic@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCAmbientMusic@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CAmbientMusic>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCAmbientMusic@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CAmbientMusic>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCAmbientMusic@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCAmbientMusic@@@@UAEIXZ PROC NEAR ; CEntityFactory<CAmbientMusic>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1792				; 00000700H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCAmbientMusic@@@@UAEIXZ ENDP ; CEntityFactory<CAmbientMusic>::GetEntitySize
_TEXT	ENDS
PUBLIC	??_7IEntityFactory@@6B@				; IEntityFactory::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT
??_7IEntityFactory@@6B@ DD FLAT:__purecall		; IEntityFactory::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IEntityFactory@@QAE@XZ PROC NEAR			; IEntityFactory::IEntityFactory, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IEntityFactory@@6B@ ; IEntityFactory::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0IEntityFactory@@QAE@XZ ENDP				; IEntityFactory::IEntityFactory
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_this$ = -16
__$EHRec$ = -12
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
PUBLIC	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
PUBLIC	??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
PUBLIC	??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT
??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ DB '('
	DB	'Base() == NULL) || (&src < Base()) || (&src >= (Base() + Coun'
	DB	't()) )', 00H				; `string'
CONST	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L41478
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L41478
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L41478
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41478:

; 520  : 	return InsertBefore( m_Size, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseEntity@@2Udatamap_s@@A:BYTE	; CBaseEntity::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseEntity@@2Udatamap_s@@A ; CBaseEntity::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCPointEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCPointEntity@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseEntity@@2Udatamap_s@@A ; CBaseEntity::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCPointEntity@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	??0CEnvSound@@QAE@XZ				; CEnvSound::CEnvSound
PUBLIC	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z		; CBaseEntity::operator new
PUBLIC	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z		; CBaseEntity::operator delete
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z
_TEXT	SEGMENT
_pev$ = -16
_a$ = 8
$T41485 = -20
$T41486 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z PROC NEAR		; GetClassPtr, COMDAT

; 1073 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1074 : 	entvars_t *pev = (entvars_t *)a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1075 : 
; 1076 : 	// allocate entity if necessary
; 1077 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L40367

; 1078 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L40367:

; 1079 : 
; 1080 : 	// get the private data
; 1081 : 	a = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 1082 : 
; 1083 : 	if (a == NULL) 

	cmp	DWORD PTR _a$[ebp], 0
	jne	SHORT $L40369

; 1085 : 		// allocate private data 
; 1086 : 		a = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1772					; 000006ecH
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41486[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41486[ebp], 0
	je	SHORT $L41487
	mov	ecx, DWORD PTR $T41486[ebp]
	call	??0CEnvSound@@QAE@XZ			; CEnvSound::CEnvSound
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41488
$L41487:
	mov	DWORD PTR -28+[ebp], 0
$L41488:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41485[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41485[ebp]
	mov	DWORD PTR _a$[ebp], ecx

; 1087 : 		a->pev = pev;

	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L40369:

; 1089 : 	return a;

	mov	eax, DWORD PTR _a$[ebp]

; 1090 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41486[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCEnvSound@@PAV1@@Z ENDP		; GetClassPtr
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT
_stAllocateBlock$ = 8
_pev$ = 12
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator new, COMDAT

; 489  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 490  : 		return (void *)ALLOC_PRIVATE(ENT(pev), stAllocateBlock);

	mov	eax, DWORD PTR _stAllocateBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+252
	add	esp, 8

; 491  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z ENDP		; CBaseEntity::operator new
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 12
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator delete, COMDAT

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 497  : 		pev->flags |= FL_KILLME;

	mov	eax, DWORD PTR _pev$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+420], ecx

; 498  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z ENDP		; CBaseEntity::operator delete
_TEXT	ENDS
PUBLIC	??0CBasePlayer@@QAE@XZ				; CBasePlayer::CBasePlayer
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z
_TEXT	SEGMENT
_pev$ = -16
_a$ = 8
$T41502 = -20
$T41503 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z PROC NEAR	; GetClassPtr, COMDAT

; 1073 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1074 : 	entvars_t *pev = (entvars_t *)a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1075 : 
; 1076 : 	// allocate entity if necessary
; 1077 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L40378

; 1078 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L40378:

; 1079 : 
; 1080 : 	// get the private data
; 1081 : 	a = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 1082 : 
; 1083 : 	if (a == NULL) 

	cmp	DWORD PTR _a$[ebp], 0
	jne	SHORT $L40380

; 1085 : 		// allocate private data 
; 1086 : 		a = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	4224					; 00001080H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41503[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41503[ebp], 0
	je	SHORT $L41504
	mov	ecx, DWORD PTR $T41503[ebp]
	call	??0CBasePlayer@@QAE@XZ			; CBasePlayer::CBasePlayer
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41505
$L41504:
	mov	DWORD PTR -28+[ebp], 0
$L41505:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41502[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41502[ebp]
	mov	DWORD PTR _a$[ebp], ecx

; 1087 : 		a->pev = pev;

	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L40380:

; 1089 : 	return a;

	mov	eax, DWORD PTR _a$[ebp]

; 1090 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41503[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCBasePlayer@@PAV1@@Z ENDP		; GetClassPtr
PUBLIC	?SetClassname@CBaseEntity@@QAEXPBD@Z		; CBaseEntity::SetClassname
PUBLIC	??0CAmbientGeneric@@QAE@XZ			; CAmbientGeneric::CAmbientGeneric
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41515 = -20
$T41516 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z PROC NEAR ; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L40389

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L40389:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L40391

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1880					; 00000758H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41516[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41516[ebp], 0
	je	SHORT $L41517
	mov	ecx, DWORD PTR $T41516[ebp]
	call	??0CAmbientGeneric@@QAE@XZ		; CAmbientGeneric::CAmbientGeneric
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41518
$L41517:
	mov	DWORD PTR -28+[ebp], 0
$L41518:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41515[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41515[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L40391:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41516[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCAmbientGeneric@@PAV1@PBD@Z ENDP	; GetClassPtr
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4
_pszClassName$ = 8
?SetClassname@CBaseEntity@@QAEXPBD@Z PROC NEAR		; CBaseEntity::SetClassname, COMDAT

; 302  : 	void		SetClassname( const char *pszClassName ) { pev->classname = MAKE_STRING( pszClassName ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClassname@CBaseEntity@@QAEXPBD@Z ENDP		; CBaseEntity::SetClassname
_TEXT	ENDS
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41530 = -20
$T41531 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L40400

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L40400:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L40402

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1772					; 000006ecH
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41531[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41531[ebp], 0
	je	SHORT $L41532
	mov	ecx, DWORD PTR $T41531[ebp]
	call	??0CEnvSound@@QAE@XZ			; CEnvSound::CEnvSound
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41533
$L41532:
	mov	DWORD PTR -28+[ebp], 0
$L41533:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41530[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41530[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L40402:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41531[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCEnvSound@@PAV1@PBD@Z ENDP		; GetClassPtr
PUBLIC	??0CTriggerSound@@QAE@XZ			; CTriggerSound::CTriggerSound
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41543 = -20
$T41544 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L40411

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L40411:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L40413

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1792					; 00000700H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41544[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41544[ebp], 0
	je	SHORT $L41545
	mov	ecx, DWORD PTR $T41544[ebp]
	call	??0CTriggerSound@@QAE@XZ		; CTriggerSound::CTriggerSound
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41546
$L41545:
	mov	DWORD PTR -28+[ebp], 0
$L41546:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41543[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41543[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L40413:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41544[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCTriggerSound@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CSpeaker@@QAE@XZ				; CSpeaker::CSpeaker
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41556 = -20
$T41557 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L40422

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L40422:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L40424

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1768					; 000006e8H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41557[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41557[ebp], 0
	je	SHORT $L41558
	mov	ecx, DWORD PTR $T41557[ebp]
	call	??0CSpeaker@@QAE@XZ			; CSpeaker::CSpeaker
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41559
$L41558:
	mov	DWORD PTR -28+[ebp], 0
$L41559:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41556[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41556[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L40424:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41557[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCSpeaker@@PAV1@PBD@Z ENDP		; GetClassPtr
PUBLIC	??0CAmbientMusic@@QAE@XZ			; CAmbientMusic::CAmbientMusic
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41569 = -20
$T41570 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L40433

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L40433:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L40435

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1792					; 00000700H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41570[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41570[ebp], 0
	je	SHORT $L41571
	mov	ecx, DWORD PTR $T41570[ebp]
	call	??0CAmbientMusic@@QAE@XZ		; CAmbientMusic::CAmbientMusic
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41572
$L41571:
	mov	DWORD PTR -28+[ebp], 0
$L41572:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41569[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41569[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L40435:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41570[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCAmbientMusic@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	?EarPosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EarPosition
PUBLIC	?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z	; CBaseEntity::BodyTarget
PUBLIC	?IsPointSized@CBaseEntity@@UBEHXZ		; CBaseEntity::IsPointSized
PUBLIC	?Illumination@CBaseEntity@@UAEHXZ		; CBaseEntity::Illumination
PUBLIC	??_7CEnvSound@@6B@				; CEnvSound::`vftable'
PUBLIC	?ObjectCaps@CPointEntity@@UAEHXZ		; CPointEntity::ObjectCaps
PUBLIC	??0CPointEntity@@QAE@XZ				; CPointEntity::CPointEntity
PUBLIC	?Precache@CBaseEntity@@UAEXXZ			; CBaseEntity::Precache
PUBLIC	?Activate@CBaseEntity@@UAEXXZ			; CBaseEntity::Activate
PUBLIC	?OnChangeLevel@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeLevel
PUBLIC	?OnTeleport@CBaseEntity@@UAEXXZ			; CBaseEntity::OnTeleport
PUBLIC	?PortalSleep@CBaseEntity@@UAEXM@Z		; CBaseEntity::PortalSleep
PUBLIC	?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ; CBaseEntity::StartMessage
PUBLIC	?GetPosition@CBaseEntity@@UAEMXZ		; CBaseEntity::GetPosition
PUBLIC	?OnChangeParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeParent
PUBLIC	?OnClearParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnClearParent
PUBLIC	?OnRemove@CBaseEntity@@UAEXXZ			; CBaseEntity::OnRemove
PUBLIC	?Classify@CBaseEntity@@UAEHXZ			; CBaseEntity::Classify
PUBLIC	?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z	; CBaseEntity::DeathNotice
PUBLIC	?IsRigidBody@CBaseEntity@@UAEHXZ		; CBaseEntity::IsRigidBody
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@XZ		; CBaseEntity::GetState
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z	; CBaseEntity::GetState
PUBLIC	?BloodColor@CBaseEntity@@UAEHXZ			; CBaseEntity::BloodColor
PUBLIC	?IsTriggered@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::IsTriggered
PUBLIC	?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ; CBaseEntity::MyMonsterPointer
PUBLIC	?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ; CBaseEntity::MySquadMonsterPointer
PUBLIC	?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ	; CBaseEntity::GetVehicleDriver
PUBLIC	?GetToggleState@CBaseEntity@@UAEHXZ		; CBaseEntity::GetToggleState
PUBLIC	?AddPoints@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPoints
PUBLIC	?AddPointsToTeam@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPointsToTeam
PUBLIC	?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::AddPlayerItem
PUBLIC	?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::RemovePlayerItem
PUBLIC	?GiveAmmo@CBaseEntity@@UAEHHPADH@Z		; CBaseEntity::GiveAmmo
PUBLIC	?GetDelay@CBaseEntity@@UAEMXZ			; CBaseEntity::GetDelay
PUBLIC	?IsMoving@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMoving
PUBLIC	?OverrideReset@CBaseEntity@@UAEXXZ		; CBaseEntity::OverrideReset
PUBLIC	?TransferReset@CBaseEntity@@UAEXXZ		; CBaseEntity::TransferReset
PUBLIC	?SetToggleState@CBaseEntity@@UAEXH@Z		; CBaseEntity::SetToggleState
PUBLIC	?StartSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StartSneaking
PUBLIC	?StopSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StopSneaking
PUBLIC	?OnControls@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::OnControls
PUBLIC	?IsSneaking@CBaseEntity@@UAEHXZ			; CBaseEntity::IsSneaking
PUBLIC	?IsAlive@CBaseEntity@@UAEHXZ			; CBaseEntity::IsAlive
PUBLIC	?IsBSPModel@CBaseEntity@@UAEHXZ			; CBaseEntity::IsBSPModel
PUBLIC	?IsCustomModel@CBaseEntity@@UAEHXZ		; CBaseEntity::IsCustomModel
PUBLIC	?ReflectGauss@CBaseEntity@@UAEHXZ		; CBaseEntity::ReflectGauss
PUBLIC	?HasTarget@CBaseEntity@@UAEHH@Z			; CBaseEntity::HasTarget
PUBLIC	?IsPlayer@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPlayer
PUBLIC	?IsNetClient@CBaseEntity@@UAEHXZ		; CBaseEntity::IsNetClient
PUBLIC	?IsMonster@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMonster
PUBLIC	?IsPushable@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPushable
PUBLIC	?IsProjectile@CBaseEntity@@UAEHXZ		; CBaseEntity::IsProjectile
PUBLIC	?IsFuncScreen@CBaseEntity@@UAEHXZ		; CBaseEntity::IsFuncScreen
PUBLIC	?IsPortal@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPortal
PUBLIC	?IsTank@CBaseEntity@@UAEHXZ			; CBaseEntity::IsTank
PUBLIC	?IsMover@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMover
PUBLIC	?IsBreakable@CBaseEntity@@UAEHXZ		; CBaseEntity::IsBreakable
PUBLIC	?TeamID@CBaseEntity@@UAEPBDXZ			; CBaseEntity::TeamID
PUBLIC	?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z	; CBaseEntity::Use
PUBLIC	?Touch@CBaseEntity@@UAEXPAV1@@Z			; CBaseEntity::Touch
PUBLIC	?Blocked@CBaseEntity@@UAEXPAV1@@Z		; CBaseEntity::Blocked
PUBLIC	?MoveDone@CBaseEntity@@UAEXXZ			; CBaseEntity::MoveDone
PUBLIC	?Respawn@CBaseEntity@@UAEPAV1@XZ		; CBaseEntity::Respawn
PUBLIC	?UpdateOwner@CBaseEntity@@UAEXXZ		; CBaseEntity::UpdateOwner
PUBLIC	?FBecomeProne@CBaseEntity@@UAEHXZ		; CBaseEntity::FBecomeProne
PUBLIC	?Center@CBaseEntity@@UAE?AVVector@@XZ		; CBaseEntity::Center
PUBLIC	?EyePosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EyePosition
EXTRN	?FVisible@CBaseEntity@@UAEHPAV1@@Z:NEAR		; CBaseEntity::FVisible
EXTRN	?FVisible@CBaseEntity@@UAEHABVVector@@@Z:NEAR	; CBaseEntity::FVisible
EXTRN	?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z:NEAR	; CBaseEntity::ShouldCollide
EXTRN	?Save@CBaseEntity@@UAEHAAVCSave@@@Z:NEAR	; CBaseEntity::Save
EXTRN	?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z:NEAR	; CBaseEntity::Restore
EXTRN	?SetObjectCollisionBox@CBaseEntity@@UAEXXZ:NEAR	; CBaseEntity::SetObjectCollisionBox
EXTRN	?SetNextThink@CBaseEntity@@UAEXM@Z:NEAR		; CBaseEntity::SetNextThink
EXTRN	?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceAttack
EXTRN	?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseEntity::TakeDamage
EXTRN	?TakeHealth@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeHealth
EXTRN	?TakeArmor@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeArmor
EXTRN	?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z:NEAR	; CBaseEntity::Killed
EXTRN	?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceBleed
EXTRN	?DamageDecal@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::DamageDecal
EXTRN	?IsInWorld@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::IsInWorld
EXTRN	?GetNextTarget@CBaseEntity@@UAEPAV1@XZ:NEAR	; CBaseEntity::GetNextTarget
;	COMDAT ??_7CEnvSound@@6B@
CONST	SEGMENT
??_7CEnvSound@@6B@ DD FLAT:?GetDataDescMap@CEnvSound@@UAEPAUdatamap_s@@XZ ; CEnvSound::`vftable'
	DD	FLAT:?Spawn@CEnvSound@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CEnvSound@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CPointEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CEnvSound@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CEnvSound@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CEnvSound@@QAE@XZ PROC NEAR				; CEnvSound::CEnvSound, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CPointEntity@@QAE@XZ			; CPointEntity::CPointEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CEnvSound@@6B@ ; CEnvSound::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CEnvSound@@QAE@XZ ENDP				; CEnvSound::CEnvSound
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Precache, COMDAT

; 326  : 	virtual void	Precache( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Precache
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Activate@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Activate, COMDAT

; 365  : 	virtual void	Activate( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Activate
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeLevel@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeLevel, COMDAT

; 366  : 	virtual void	OnChangeLevel( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeLevel@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnChangeLevel
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnTeleport@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnTeleport, COMDAT

; 367  : 	virtual void	OnTeleport( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnTeleport@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnTeleport
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4
?PortalSleep@CBaseEntity@@UAEXM@Z PROC NEAR		; CBaseEntity::PortalSleep, COMDAT

; 368  : 	virtual void	PortalSleep( float seconds ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PortalSleep@CBaseEntity@@UAEXM@Z ENDP			; CBaseEntity::PortalSleep
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CBaseEntity::StartMessage, COMDAT

; 369  :           virtual void	StartMessage( CBasePlayer *pPlayer ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ENDP	; CBaseEntity::StartMessage
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetPosition@CBaseEntity@@UAEMXZ PROC NEAR		; CBaseEntity::GetPosition, COMDAT

; 370  : 	virtual float	GetPosition( void ) { return 0.0f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPosition@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetPosition
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeParent, COMDAT

; 371  : 	virtual void	OnChangeParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CBaseEntity@@UAEXXZ ENDP		; CBaseEntity::OnChangeParent
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnClearParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnClearParent, COMDAT

; 372  : 	virtual void	OnClearParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnClearParent
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnRemove@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::OnRemove, COMDAT

; 373  : 	virtual void	OnRemove( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnRemove@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnRemove
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::Classify, COMDAT

; 385  : 	virtual int Classify ( void ) { return CLASS_NONE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Classify
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z PROC NEAR ; CBaseEntity::DeathNotice, COMDAT

; 386  : 	virtual void DeathNotice ( entvars_t *pevChild ) { } // monster maker children use this to tell the monster maker that they have died.

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z ENDP	; CBaseEntity::DeathNotice
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsRigidBody@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsRigidBody, COMDAT

; 387  : 	virtual BOOL IsRigidBody( void ) { return (m_iActorType == ACTOR_DYNAMIC); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	mov	eax, ecx
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsRigidBody@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsRigidBody
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseEntity::GetState, COMDAT

; 398  : 	virtual STATE GetState ( void ) { return STATE_OFF; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ ENDP		; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z PROC NEAR	; CBaseEntity::GetState, COMDAT

; 401  : 	virtual STATE GetState ( CBaseEntity* pEnt ) { return GetState(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z ENDP	; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::BloodColor, COMDAT

; 408  : 	virtual int	BloodColor( void ) { return DONT_BLEED; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::BloodColor
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::IsTriggered, COMDAT

; 410  : 	virtual BOOL	IsTriggered( CBaseEntity *pActivator ) {return TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::IsTriggered
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ PROC NEAR ; CBaseEntity::MyMonsterPointer, COMDAT

; 411  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ENDP ; CBaseEntity::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ PROC NEAR ; CBaseEntity::MySquadMonsterPointer, COMDAT

; 412  : 	virtual CSquadMonster *MySquadMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ENDP ; CBaseEntity::MySquadMonsterPointer
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ PROC NEAR	; CBaseEntity::GetVehicleDriver, COMDAT

; 413  : 	virtual CBaseEntity *GetVehicleDriver( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ ENDP		; CBaseEntity::GetVehicleDriver
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::GetToggleState, COMDAT

; 414  : 	virtual int	GetToggleState( void ) { return TS_AT_TOP; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseEntity@@UAEHXZ ENDP		; CBaseEntity::GetToggleState
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPoints@CBaseEntity@@UAEXHH@Z PROC NEAR		; CBaseEntity::AddPoints, COMDAT

; 415  : 	virtual void	AddPoints( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPoints@CBaseEntity@@UAEXHH@Z ENDP			; CBaseEntity::AddPoints
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z PROC NEAR	; CBaseEntity::AddPointsToTeam, COMDAT

; 416  : 	virtual void	AddPointsToTeam( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z ENDP		; CBaseEntity::AddPointsToTeam
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::AddPlayerItem, COMDAT

; 417  : 	virtual BOOL	AddPlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::AddPlayerItem
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::RemovePlayerItem, COMDAT

; 418  : 	virtual BOOL	RemovePlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::RemovePlayerItem
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT
_this$ = -4
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z PROC NEAR		; CBaseEntity::GiveAmmo, COMDAT

; 419  : 	virtual int 	GiveAmmo( int iAmount, char *szName, int iMax ) { return -1; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z ENDP			; CBaseEntity::GiveAmmo
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseEntity@@UAEMXZ PROC NEAR			; CBaseEntity::GetDelay, COMDAT

; 420  : 	virtual float	GetDelay( void ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetDelay
_TEXT	ENDS
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMoving, COMDAT

; 421  : 	virtual int	IsMoving( void ) { return GetAbsVelocity() != g_vecZero; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMoving
_TEXT	ENDS
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41643
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41643
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41643
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41644
$L41643:
	mov	DWORD PTR -8+[ebp], 0
$L41644:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OverrideReset, COMDAT

; 422  : 	virtual void	OverrideReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OverrideReset
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TransferReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::TransferReset, COMDAT

; 423  : 	virtual void	TransferReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransferReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::TransferReset
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?SetToggleState@CBaseEntity@@UAEXH@Z PROC NEAR		; CBaseEntity::SetToggleState, COMDAT

; 426  : 	virtual void	SetToggleState( int state ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetToggleState@CBaseEntity@@UAEXH@Z ENDP		; CBaseEntity::SetToggleState
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StartSneaking, COMDAT

; 427  : 	virtual void	StartSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StartSneaking
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StopSneaking, COMDAT

; 428  : 	virtual void	StopSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StopSneaking
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?OnControls@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::OnControls, COMDAT

; 429  : 	virtual BOOL	OnControls( CBaseEntity *pTest ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnControls@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::OnControls
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSneaking@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsSneaking, COMDAT

; 430  : 	virtual BOOL	IsSneaking( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSneaking@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsSneaking
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsAlive, COMDAT

; 431  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	jne	SHORT $L41661
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41661
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41662
$L41661:
	mov	DWORD PTR -8+[ebp], 0
$L41662:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsAlive
_TEXT	ENDS
EXTRN	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z:NEAR	; UTIL_GetModelType
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBSPModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBSPModel, COMDAT

; 432  : 	virtual BOOL	IsBSPModel( void ) { return UTIL_GetModelType( pev->modelindex ) == mod_brush; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBSPModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBSPModel
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsCustomModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsCustomModel, COMDAT

; 433  : 	virtual BOOL	IsCustomModel( void ) { return pev->solid == SOLID_CUSTOM; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+268], 5
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCustomModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsCustomModel
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ReflectGauss@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ReflectGauss, COMDAT

; 434  : 	virtual BOOL	ReflectGauss( void ) { return (( IsBSPModel() || IsCustomModel()) && !pev->takedamage ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	test	eax, eax
	jne	SHORT $L41669
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+208]
	test	eax, eax
	je	SHORT $L41670
$L41669:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41670
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41671
$L41670:
	mov	DWORD PTR -8+[ebp], 0
$L41671:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReflectGauss@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ReflectGauss
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_targetname$ = 8
?HasTarget@CBaseEntity@@UAEHH@Z PROC NEAR		; CBaseEntity::HasTarget, COMDAT

; 435  : 	virtual BOOL	HasTarget( string_t targetname ) { return FStrEq(STRING(targetname), STRING(pev->targetname) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _targetname$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasTarget@CBaseEntity@@UAEHH@Z ENDP			; CBaseEntity::HasTarget
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPlayer@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPlayer, COMDAT

; 437  : 	virtual BOOL	IsPlayer( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPlayer
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsNetClient@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsNetClient, COMDAT

; 438  : 	virtual BOOL	IsNetClient( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetClient@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsNetClient
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMonster@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsMonster, COMDAT

; 439  : 	virtual BOOL	IsMonster( void ) { return (pev->flags & FL_MONSTER ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+420]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMonster@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMonster
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPushable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsPushable, COMDAT

; 440  : 	virtual BOOL	IsPushable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPushable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPushable
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsProjectile@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsProjectile, COMDAT

; 441  : 	virtual BOOL	IsProjectile( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsProjectile@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsProjectile
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsFuncScreen@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsFuncScreen, COMDAT

; 442  : 	virtual BOOL	IsFuncScreen( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFuncScreen@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsFuncScreen
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPortal@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPortal, COMDAT

; 443  : 	virtual BOOL	IsPortal( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPortal@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPortal
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTank@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsTank, COMDAT

; 444  : 	virtual BOOL	IsTank( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTank@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsTank
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMover@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMover, COMDAT

; 445  : 	virtual BOOL	IsMover( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMover
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBreakable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBreakable, COMDAT

; 446  : 	virtual BOOL	IsBreakable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBreakable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBreakable
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?TeamID@CBaseEntity@@UAEPBDXZ PROC NEAR			; CBaseEntity::TeamID, COMDAT

; 447  : 	virtual const char	*TeamID( void ) { return ""; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TeamID@CBaseEntity@@UAEPBDXZ ENDP			; CBaseEntity::TeamID
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
_pActivator$ = 8
_pCaller$ = 12
_useType$ = 16
_value$ = 20
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z PROC NEAR	; CBaseEntity::Use, COMDAT

; 461  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 		if (m_pfnUse) (this->*m_pfnUse)( pActivator, pCaller, useType, value );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1752], 0
	je	SHORT $L35009
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCaller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1752]
$L35009:

; 463  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z ENDP	; CBaseEntity::Use
_TEXT	ENDS
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Touch@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Touch, COMDAT

; 466  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 		if( m_pfnTouch )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1748], 0
	je	SHORT $L35012

; 468  : 			(this->*m_pfnTouch)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1748]
$L35012:

; 469  : 
; 470  : 		// forward the blocked event to our parent, if any.
; 471  : 		if( m_hParent != NULL && !m_isChaining )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35013
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1628]
	test	ecx, ecx
	jne	SHORT $L35013

; 472  : 			m_hParent->Touch( pOther );

	mov	edx, DWORD PTR _pOther$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+280]
$L35013:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Touch
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator->, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Blocked@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Blocked, COMDAT

; 476  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 		if( m_pfnBlocked )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1756], 0
	je	SHORT $L35016

; 478  : 			(this->*m_pfnBlocked)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1756]
$L35016:

; 479  : 
; 480  : 		// forward the blocked event to our parent, if any.
; 481  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35017

; 482  : 			m_hParent->Blocked( pOther );

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+284]
$L35017:

; 483  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Blocked
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MoveDone@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::MoveDone, COMDAT

; 485  : 	virtual void MoveDone( void ) { if( m_pfnMoveDone )(this->*m_pfnMoveDone)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1760], 0
	je	SHORT $L35020
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1760]
$L35020:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveDone@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::MoveDone
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?Respawn@CBaseEntity@@UAEPAV1@XZ PROC NEAR		; CBaseEntity::Respawn, COMDAT

; 513  : 	virtual CBaseEntity *Respawn( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Respawn@CBaseEntity@@UAEPAV1@XZ ENDP			; CBaseEntity::Respawn
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?UpdateOwner@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::UpdateOwner, COMDAT

; 705  : 	virtual	void UpdateOwner( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateOwner@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::UpdateOwner
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FBecomeProne@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::FBecomeProne, COMDAT

; 709  : 	virtual BOOL FBecomeProne( void ) {return FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FBecomeProne@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::FBecomeProne
_TEXT	ENDS
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T41714 = -16
$T41715 = -28
?Center@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR		; CBaseEntity::Center, COMDAT

; 714  : 	virtual Vector Center( ) { return (pev->absmax + pev->absmin) * 0.5; }; // center point of entity

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T41715[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	push	edx
	lea	eax, DWORD PTR $T41714[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 208				; 000000d0H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Center@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::Center
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T41718 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41718[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T41721 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41721[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T41724 = -16
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EyePosition, COMDAT

; 715  : 	virtual Vector EyePosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of eyes

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T41724[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EyePosition
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T41727 = -16
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EarPosition, COMDAT

; 716  : 	virtual Vector EarPosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of ears

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T41727[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EarPosition
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T41730 = -16
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseEntity::BodyTarget, COMDAT

; 717  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ); };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T41730[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseEntity::BodyTarget
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPointSized@CBaseEntity@@UBEHXZ PROC NEAR		; CBaseEntity::IsPointSized, COMDAT

; 718  : 	virtual BOOL IsPointSized() const { return (pev->size == g_vecZero) ? true : false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	setne	al
	and	eax, 255				; 000000ffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPointSized@CBaseEntity@@UBEHXZ ENDP			; CBaseEntity::IsPointSized
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Illumination@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::Illumination, COMDAT

; 720  : 	virtual int Illumination( ) { return GETENTITYILLUM( ENT( pev ) ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+60
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Illumination@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Illumination
_TEXT	ENDS
PUBLIC	?ObjectCaps@CBaseEntity@@UAEHXZ			; CBaseEntity::ObjectCaps
;	COMDAT ?ObjectCaps@CPointEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CPointEntity@@UAEHXZ PROC NEAR		; CPointEntity::ObjectCaps, COMDAT

; 837  : 	virtual int ObjectCaps( void ) { return CBaseEntity :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CPointEntity@@UAEHXZ ENDP			; CPointEntity::ObjectCaps
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ObjectCaps, COMDAT

; 364  : 	virtual int	ObjectCaps( void ) { return FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 2
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ObjectCaps
_TEXT	ENDS
PUBLIC	?SetYawSpeed@CBaseMonster@@UAEXXZ		; CBaseMonster::SetYawSpeed
PUBLIC	?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z	; CBaseMonster::FValidateCover
PUBLIC	?CoverRadius@CBaseMonster@@UAEMXZ		; CBaseMonster::CoverRadius
PUBLIC	?CheckAmmo@CBaseMonster@@UAEXXZ			; CBaseMonster::CheckAmmo
PUBLIC	?HearingSensitivity@CBaseMonster@@UAEMXZ	; CBaseMonster::HearingSensitivity
PUBLIC	?PrescheduleThink@CBaseMonster@@UAEXXZ		; CBaseMonster::PrescheduleThink
PUBLIC	?IsMoving@CBaseMonster@@UAEHXZ			; CBaseMonster::IsMoving
PUBLIC	?AlertSound@CBaseMonster@@UAEXXZ		; CBaseMonster::AlertSound
PUBLIC	?IdleSound@CBaseMonster@@UAEXXZ			; CBaseMonster::IdleSound
PUBLIC	?PainSound@CBaseMonster@@UAEXXZ			; CBaseMonster::PainSound
PUBLIC	?StopFollowing@CBaseMonster@@UAEXH@Z		; CBaseMonster::StopFollowing
PUBLIC	??0CBaseMonster@@QAE@XZ				; CBaseMonster::CBaseMonster
PUBLIC	??1CBaseMonster@@QAE@XZ				; CBaseMonster::~CBaseMonster
PUBLIC	?GetToggleState@CBaseToggle@@UAEHXZ		; CBaseToggle::GetToggleState
PUBLIC	?GetDelay@CBaseToggle@@UAEMXZ			; CBaseToggle::GetDelay
PUBLIC	?BodyTarget@CBasePlayer@@UAE?AVVector@@ABV2@@Z	; CBasePlayer::BodyTarget
PUBLIC	?StartSneaking@CBasePlayer@@UAEXXZ		; CBasePlayer::StartSneaking
PUBLIC	?StopSneaking@CBasePlayer@@UAEXXZ		; CBasePlayer::StopSneaking
PUBLIC	?IsSneaking@CBasePlayer@@UAEHXZ			; CBasePlayer::IsSneaking
PUBLIC	?IsAlive@CBasePlayer@@UAEHXZ			; CBasePlayer::IsAlive
PUBLIC	?ShouldFadeOnDeath@CBasePlayer@@UAEHXZ		; CBasePlayer::ShouldFadeOnDeath
PUBLIC	?IsPlayer@CBasePlayer@@UAEHXZ			; CBasePlayer::IsPlayer
PUBLIC	?IsNetClient@CBasePlayer@@UAEHXZ		; CBasePlayer::IsNetClient
PUBLIC	?ObjectCaps@CBasePlayer@@UAEHXZ			; CBasePlayer::ObjectCaps
PUBLIC	?BloodColor@CBaseMonster@@UAEHXZ		; CBaseMonster::BloodColor
PUBLIC	?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ	; CBaseMonster::MyMonsterPointer
PUBLIC	?Think@CBaseEntity@@UAEXXZ			; CBaseEntity::Think
PUBLIC	?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ ; CBaseMonster::GetStoppedActivity
PUBLIC	?Stop@CBaseMonster@@UAEXXZ			; CBaseMonster::Stop
PUBLIC	??_7CBasePlayer@@6B@				; CBasePlayer::`vftable'
PUBLIC	?ScheduleChange@CBaseMonster@@UAEXXZ		; CBaseMonster::ScheduleChange
PUBLIC	?CanPlaySentence@CBaseMonster@@UAEHH@Z		; CBaseMonster::CanPlaySentence
EXTRN	?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z:NEAR ; CBaseMonster::BuildNearestRoute
EXTRN	?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z:NEAR ; CBaseMonster::FindCover
EXTRN	?FCanCheckAttacks@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::FCanCheckAttacks
EXTRN	?IgnoreConditions@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::IgnoreConditions
EXTRN	?FValidateHintType@CBaseMonster@@UAEHF@Z:NEAR	; CBaseMonster::FValidateHintType
EXTRN	?FCanActiveIdle@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::FCanActiveIdle
EXTRN	?ISoundMask@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::ISoundMask
EXTRN	?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ:NEAR	; CBaseMonster::PBestSound
EXTRN	?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ:NEAR	; CBaseMonster::PBestScent
EXTRN	?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ:NEAR ; CBaseMonster::GetDeathActivity
EXTRN	?GibMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::GibMonster
EXTRN	?DamageDecal@CBaseMonster@@UAEHH@Z:NEAR		; CBaseMonster::DamageDecal
EXTRN	?HasHumanGibs@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::HasHumanGibs
EXTRN	?HasAlienGibs@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::HasAlienGibs
EXTRN	?FadeMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::FadeMonster
EXTRN	?StepSound@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::StepSound
EXTRN	?GetState@CBaseToggle@@UAE?AW4STATE@@XZ:NEAR	; CBaseToggle::GetState
EXTRN	?MoveDone@CBaseToggle@@UAEXXZ:NEAR		; CBaseToggle::MoveDone
EXTRN	?Spawn@CBasePlayer@@UAEXXZ:NEAR			; CBasePlayer::Spawn
EXTRN	?Jump@CBasePlayer@@UAEXXZ:NEAR			; CBasePlayer::Jump
EXTRN	?Duck@CBasePlayer@@UAEXXZ:NEAR			; CBasePlayer::Duck
EXTRN	?PreThink@CBasePlayer@@UAEXXZ:NEAR		; CBasePlayer::PreThink
EXTRN	?PostThink@CBasePlayer@@UAEXXZ:NEAR		; CBasePlayer::PostThink
EXTRN	?GetGunPosition@CBasePlayer@@UAE?AVVector@@XZ:NEAR ; CBasePlayer::GetGunPosition
EXTRN	?TakeHealth@CBasePlayer@@UAEHMH@Z:NEAR		; CBasePlayer::TakeHealth
EXTRN	?TraceAttack@CBasePlayer@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBasePlayer::TraceAttack
EXTRN	?TakeDamage@CBasePlayer@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBasePlayer::TakeDamage
EXTRN	?Killed@CBasePlayer@@UAEXPAUentvars_s@@H@Z:NEAR	; CBasePlayer::Killed
EXTRN	?TeamID@CBasePlayer@@UAEPBDXZ:NEAR		; CBasePlayer::TeamID
EXTRN	?Restore@CBasePlayer@@UAEHAAVCRestore@@@Z:NEAR	; CBasePlayer::Restore
EXTRN	?UpdateClientData@CBasePlayer@@UAEXXZ:NEAR	; CBasePlayer::UpdateClientData
EXTRN	?GetDataDescMap@CBasePlayer@@UAEPAUdatamap_s@@XZ:NEAR ; CBasePlayer::GetDataDescMap
EXTRN	?Precache@CBasePlayer@@UAEXXZ:NEAR		; CBasePlayer::Precache
EXTRN	?DeathSound@CBasePlayer@@UAEXXZ:NEAR		; CBasePlayer::DeathSound
EXTRN	?TransferReset@CBasePlayer@@UAEXXZ:NEAR		; CBasePlayer::TransferReset
EXTRN	?Classify@CBasePlayer@@UAEHXZ:NEAR		; CBasePlayer::Classify
EXTRN	?ImpulseCommands@CBasePlayer@@UAEXXZ:NEAR	; CBasePlayer::ImpulseCommands
EXTRN	?AddPoints@CBasePlayer@@UAEXHH@Z:NEAR		; CBasePlayer::AddPoints
EXTRN	?AddPointsToTeam@CBasePlayer@@UAEXHH@Z:NEAR	; CBasePlayer::AddPointsToTeam
EXTRN	?AddPlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z:NEAR ; CBasePlayer::AddPlayerItem
EXTRN	?RemovePlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z:NEAR ; CBasePlayer::RemovePlayerItem
EXTRN	?GiveAmmo@CBasePlayer@@UAEHHPADH@Z:NEAR		; CBasePlayer::GiveAmmo
EXTRN	?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseMonster::KeyValue
EXTRN	?FBecomeProne@CBasePlayer@@UAEHXZ:NEAR		; CBasePlayer::FBecomeProne
EXTRN	?Look@CBaseMonster@@UAEXH@Z:NEAR		; CBaseMonster::Look
EXTRN	?BarnacleVictimBitten@CBasePlayer@@UAEXPAUentvars_s@@@Z:NEAR ; CBasePlayer::BarnacleVictimBitten
EXTRN	?RunAI@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::RunAI
EXTRN	?BarnacleVictimReleased@CBasePlayer@@UAEXXZ:NEAR ; CBasePlayer::BarnacleVictimReleased
EXTRN	?Illumination@CBasePlayer@@UAEHXZ:NEAR		; CBasePlayer::Illumination
EXTRN	?ChangeYaw@CBaseMonster@@UAEMH@Z:NEAR		; CBaseMonster::ChangeYaw
EXTRN	?MonsterThink@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::MonsterThink
EXTRN	?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::IRelationship
EXTRN	?MonsterInit@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::MonsterInit
EXTRN	?MonsterInitDead@CBaseMonster@@UAEXXZ:NEAR	; CBaseMonster::MonsterInitDead
EXTRN	?BecomeDead@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::BecomeDead
EXTRN	?StartMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::StartMonster
EXTRN	?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ:NEAR ; CBaseMonster::BestVisibleEnemy
EXTRN	?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::FInViewCone
EXTRN	?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z:NEAR ; CBaseMonster::FInViewCone
EXTRN	?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z:NEAR ; CBaseMonster::HandleAnimEvent
EXTRN	?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z:NEAR ; CBaseMonster::CheckLocalMove
EXTRN	?Move@CBaseMonster@@UAEXM@Z:NEAR		; CBaseMonster::Move
EXTRN	?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z:NEAR ; CBaseMonster::MoveExecute
EXTRN	?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z:NEAR	; CBaseMonster::ShouldAdvanceRoute
EXTRN	?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckRangeAttack1
EXTRN	?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckRangeAttack2
EXTRN	?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckMeleeAttack1
EXTRN	?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckMeleeAttack2
EXTRN	?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z:NEAR ; CBaseMonster::ScheduleFromName
EXTRN	?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z:NEAR	; CBaseMonster::StartTask
EXTRN	?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z:NEAR	; CBaseMonster::RunTask
EXTRN	?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z:NEAR ; CBaseMonster::GetScheduleOfType
EXTRN	?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ:NEAR ; CBaseMonster::GetSchedule
EXTRN	?CanPlaySequence@CBaseMonster@@UAEHHH@Z:NEAR	; CBaseMonster::CanPlaySequence
EXTRN	?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z:NEAR	; CBaseMonster::PlaySentence
EXTRN	?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::PlayScriptedSentence
EXTRN	?SentenceStop@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::SentenceStop
EXTRN	?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ:NEAR ; CBaseMonster::GetIdealState
EXTRN	?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z:NEAR ; CBaseMonster::SetActivity
EXTRN	?ReportAIState@CBaseMonster@@UAEXXZ:NEAR	; CBaseMonster::ReportAIState
EXTRN	?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::CheckEnemy
EXTRN	?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z:NEAR ; CBaseMonster::FTriangulate
;	COMDAT ??_7CBasePlayer@@6B@
CONST	SEGMENT
??_7CBasePlayer@@6B@ DD FLAT:?GetDataDescMap@CBasePlayer@@UAEPAUdatamap_s@@XZ ; CBasePlayer::`vftable'
	DD	FLAT:?Spawn@CBasePlayer@@UAEXXZ
	DD	FLAT:?Precache@CBasePlayer@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBasePlayer@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBasePlayer@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBasePlayer@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBasePlayer@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBasePlayer@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBasePlayer@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBasePlayer@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseMonster@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBasePlayer@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBasePlayer@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBasePlayer@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBasePlayer@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBasePlayer@@UAEXXZ
	DD	FLAT:?StopSneaking@CBasePlayer@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBasePlayer@@UAEHXZ
	DD	FLAT:?IsAlive@CBasePlayer@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBasePlayer@@UAEHXZ
	DD	FLAT:?IsNetClient@CBasePlayer@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBasePlayer@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBasePlayer@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBasePlayer@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBasePlayer@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBasePlayer@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CBaseMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CBaseMonster@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CBaseMonster@@UAEHXZ
	DD	FLAT:?CheckAmmo@CBaseMonster@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CBaseMonster@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBasePlayer@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBasePlayer@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CBasePlayer@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CBasePlayer@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?PainSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
	DD	FLAT:?Jump@CBasePlayer@@UAEXXZ
	DD	FLAT:?Duck@CBasePlayer@@UAEXXZ
	DD	FLAT:?PreThink@CBasePlayer@@UAEXXZ
	DD	FLAT:?PostThink@CBasePlayer@@UAEXXZ
	DD	FLAT:?UpdateClientData@CBasePlayer@@UAEXXZ
	DD	FLAT:?ImpulseCommands@CBasePlayer@@UAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBasePlayer@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBasePlayer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBasePlayer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBasePlayer@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBasePlayer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBasePlayer@@QAE@XZ PROC NEAR			; CBasePlayer::CBasePlayer, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBasePlayer@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseMonster@@QAE@XZ			; CBaseMonster::CBaseMonster
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3764				; 00000eb4H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4148				; 00001034H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBasePlayer@@6B@ ; CBasePlayer::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBasePlayer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseMonster@@QAE@XZ			; CBaseMonster::~CBaseMonster
	ret	0
__ehhandler$??0CBasePlayer@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBasePlayer@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBasePlayer@@QAE@XZ ENDP				; CBasePlayer::CBasePlayer
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Think@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Think, COMDAT

; 458  : 	virtual void Think( void ) { if (m_pfnThink) (this->*m_pfnThink)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1744], 0
	je	SHORT $L35006
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1744]
$L35006:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Think
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseToggle@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseToggle@@UAEHXZ PROC NEAR		; CBaseToggle::GetToggleState, COMDAT

; 978  : 	virtual int GetToggleState( void ) { return m_toggle_state; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1816]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseToggle@@UAEHXZ ENDP		; CBaseToggle::GetToggleState
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseToggle@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseToggle@@UAEMXZ PROC NEAR			; CBaseToggle::GetDelay, COMDAT

; 979  : 	virtual float GetDelay( void ) { return m_flWait; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1764]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseToggle@@UAEMXZ ENDP			; CBaseToggle::GetDelay
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::BloodColor, COMDAT

; 132  : 	virtual int	 BloodColor( void ) { return m_bloodColor; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+2328]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::BloodColor
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ PROC NEAR	; CBaseMonster::MyMonsterPointer, COMDAT

; 134  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return this; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ ENDP		; CBaseMonster::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ PROC NEAR ; CBaseMonster::GetStoppedActivity, COMDAT

; 175  : 		virtual Activity GetStoppedActivity( void ) { return ACT_IDLE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ ENDP ; CBaseMonster::GetStoppedActivity
_TEXT	ENDS
;	COMDAT ?Stop@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Stop@CBaseMonster@@UAEXXZ PROC NEAR			; CBaseMonster::Stop, COMDAT

; 176  : 		virtual void Stop( void ) { m_IdealActivity = GetStoppedActivity(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2072], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@CBaseMonster@@UAEXXZ ENDP				; CBaseMonster::Stop
_TEXT	ENDS
;	COMDAT ?ScheduleChange@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ScheduleChange@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::ScheduleChange, COMDAT

; 203  : 		virtual void ScheduleChange( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ScheduleChange@CBaseMonster@@UAEXXZ ENDP		; CBaseMonster::ScheduleChange
_TEXT	ENDS
;	COMDAT ?CanPlaySentence@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
?CanPlaySentence@CBaseMonster@@UAEHH@Z PROC NEAR	; CBaseMonster::CanPlaySentence, COMDAT

; 206  : 		virtual int CanPlaySentence( BOOL fDisregardState ) { return IsAlive(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CanPlaySentence@CBaseMonster@@UAEHH@Z ENDP		; CBaseMonster::CanPlaySentence
_TEXT	ENDS
;	COMDAT ?SetYawSpeed@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SetYawSpeed@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::SetYawSpeed, COMDAT

; 241  : 		virtual void SetYawSpeed ( void ) { return; };// allows different yaw_speeds for each activity

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetYawSpeed@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::SetYawSpeed
_TEXT	ENDS
;	COMDAT ?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4
?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z PROC NEAR ; CBaseMonster::FValidateCover, COMDAT

; 249  : 		virtual BOOL FValidateCover ( const Vector &vecCoverLocation ) { return TRUE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z ENDP	; CBaseMonster::FValidateCover
_TEXT	ENDS
PUBLIC	__real@4@4008c400000000000000
;	COMDAT __real@4@4008c400000000000000
; File z:\xashxtsrc\server\monsters\basemonster.h
CONST	SEGMENT
__real@4@4008c400000000000000 DD 044440000r	; 784
CONST	ENDS
;	COMDAT ?CoverRadius@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?CoverRadius@CBaseMonster@@UAEMXZ PROC NEAR		; CBaseMonster::CoverRadius, COMDAT

; 250  : 		virtual float CoverRadius( void ) { return 784; } // Default cover radius

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@4008c400000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CoverRadius@CBaseMonster@@UAEMXZ ENDP			; CBaseMonster::CoverRadius
_TEXT	ENDS
;	COMDAT ?CheckAmmo@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CheckAmmo@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::CheckAmmo, COMDAT

; 253  : 		virtual void CheckAmmo( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckAmmo@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::CheckAmmo
_TEXT	ENDS
;	COMDAT ?HearingSensitivity@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?HearingSensitivity@CBaseMonster@@UAEMXZ PROC NEAR	; CBaseMonster::HearingSensitivity, COMDAT

; 278  : 		virtual float HearingSensitivity( void ) { return 1.0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@3fff8000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HearingSensitivity@CBaseMonster@@UAEMXZ ENDP		; CBaseMonster::HearingSensitivity
_TEXT	ENDS
;	COMDAT ?PrescheduleThink@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PrescheduleThink@CBaseMonster@@UAEXXZ PROC NEAR	; CBaseMonster::PrescheduleThink, COMDAT

; 298  : 		virtual void PrescheduleThink( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrescheduleThink@CBaseMonster@@UAEXXZ ENDP		; CBaseMonster::PrescheduleThink
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::IsMoving, COMDAT

; 328  : 	virtual int		IsMoving( void ) { return m_movementGoal != MOVEGOAL_NONE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+2228], 0
	setne	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::IsMoving
_TEXT	ENDS
;	COMDAT ?AlertSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?AlertSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::AlertSound, COMDAT

; 334  : 	virtual void AlertSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AlertSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::AlertSound
_TEXT	ENDS
;	COMDAT ?IdleSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?IdleSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::IdleSound, COMDAT

; 335  : 	virtual void IdleSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IdleSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::IdleSound
_TEXT	ENDS
;	COMDAT ?PainSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PainSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::PainSound, COMDAT

; 336  : 	virtual void PainSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PainSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::PainSound
_TEXT	ENDS
;	COMDAT ?StopFollowing@CBaseMonster@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?StopFollowing@CBaseMonster@@UAEXH@Z PROC NEAR		; CBaseMonster::StopFollowing, COMDAT

; 339  : 	virtual void StopFollowing( BOOL clearSchedule ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StopFollowing@CBaseMonster@@UAEXH@Z ENDP		; CBaseMonster::StopFollowing
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBasePlayer@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
$T41792 = -16
$T41793 = -28
$T41794 = -40
___$ReturnUdt$ = 8
_this$ = -4
?BodyTarget@CBasePlayer@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBasePlayer::BodyTarget, COMDAT

; 242  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ) + pev->view_ofs * RANDOM_FLOAT( 0.5, 1.1 ); };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1066192077				; 3f8ccccdH
	push	1056964608				; 3f000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T41793[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 372				; 00000174H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T41794[ebp]
	push	edx
	lea	eax, DWORD PTR $T41792[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBasePlayer@@UAE?AVVector@@ABV2@@Z ENDP	; CBasePlayer::BodyTarget
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartSneaking@CBasePlayer@@UAEXXZ PROC NEAR		; CBasePlayer::StartSneaking, COMDAT

; 243  : 	virtual void StartSneaking( void ) { m_tSneaking = gpGlobals->time - 1; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2912]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartSneaking@CBasePlayer@@UAEXXZ ENDP			; CBasePlayer::StartSneaking
_TEXT	ENDS
PUBLIC	__real@4@4003f000000000000000
;	COMDAT __real@4@4003f000000000000000
; File z:\xashxtsrc\server\player.h
CONST	SEGMENT
__real@4@4003f000000000000000 DD 041f00000r	; 30
CONST	ENDS
;	COMDAT ?StopSneaking@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSneaking@CBasePlayer@@UAEXXZ PROC NEAR		; CBasePlayer::StopSneaking, COMDAT

; 244  : 	virtual void StopSneaking( void ) { m_tSneaking = gpGlobals->time + 30; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@4003f000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2912]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSneaking@CBasePlayer@@UAEXXZ ENDP			; CBasePlayer::StopSneaking
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSneaking@CBasePlayer@@UAEHXZ PROC NEAR		; CBasePlayer::IsSneaking, COMDAT

; 245  : 	virtual BOOL IsSneaking( void ) { return m_tSneaking <= gpGlobals->time; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+2912]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L41803
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41804
$L41803:
	mov	DWORD PTR -8+[ebp], 0
$L41804:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSneaking@CBasePlayer@@UAEHXZ ENDP			; CBasePlayer::IsSneaking
_TEXT	ENDS
;	COMDAT ?IsAlive@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBasePlayer@@UAEHXZ PROC NEAR			; CBasePlayer::IsAlive, COMDAT

; 246  : 	virtual BOOL IsAlive( void ) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	jne	SHORT $L41807
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41807
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41808
$L41807:
	mov	DWORD PTR -8+[ebp], 0
$L41808:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBasePlayer@@UAEHXZ ENDP			; CBasePlayer::IsAlive
_TEXT	ENDS
;	COMDAT ?ShouldFadeOnDeath@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ShouldFadeOnDeath@CBasePlayer@@UAEHXZ PROC NEAR	; CBasePlayer::ShouldFadeOnDeath, COMDAT

; 247  : 	virtual BOOL ShouldFadeOnDeath( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ShouldFadeOnDeath@CBasePlayer@@UAEHXZ ENDP		; CBasePlayer::ShouldFadeOnDeath
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPlayer@CBasePlayer@@UAEHXZ PROC NEAR			; CBasePlayer::IsPlayer, COMDAT

; 248  : 	virtual BOOL IsPlayer( void ) { return TRUE; }		// Spectators should return FALSE for this, they aren't "players" as far as game logic is concerned

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@CBasePlayer@@UAEHXZ ENDP			; CBasePlayer::IsPlayer
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsNetClient@CBasePlayer@@UAEHXZ PROC NEAR		; CBasePlayer::IsNetClient, COMDAT

; 250  : 	virtual BOOL IsNetClient( void ) { return TRUE; }		// Bots should return FALSE for this, they can't receive NET messages

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetClient@CBasePlayer@@UAEHXZ ENDP			; CBasePlayer::IsNetClient
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBasePlayer@@UAEHXZ PROC NEAR		; CBasePlayer::ObjectCaps, COMDAT

; 267  : 	virtual int	ObjectCaps( void ) { return CBaseMonster :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBasePlayer@@UAEHXZ ENDP			; CBasePlayer::ObjectCaps
_TEXT	ENDS
PUBLIC	??0CBaseEntity@@QAE@XZ				; CBaseEntity::CBaseEntity
PUBLIC	?ObjectCaps@CAmbientGeneric@@UAEHXZ		; CAmbientGeneric::ObjectCaps
PUBLIC	??_7CAmbientGeneric@@6B@			; CAmbientGeneric::`vftable'
;	COMDAT ??_7CAmbientGeneric@@6B@
CONST	SEGMENT
??_7CAmbientGeneric@@6B@ DD FLAT:?GetDataDescMap@CAmbientGeneric@@UAEPAUdatamap_s@@XZ ; CAmbientGeneric::`vftable'
	DD	FLAT:?Spawn@CAmbientGeneric@@UAEXXZ
	DD	FLAT:?Precache@CAmbientGeneric@@UAEXXZ
	DD	FLAT:?KeyValue@CAmbientGeneric@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CAmbientGeneric@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CAmbientGeneric@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CAmbientGeneric@@QAE@XZ PROC NEAR			; CAmbientGeneric::CAmbientGeneric, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CAmbientGeneric@@6B@ ; CAmbientGeneric::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAmbientGeneric@@QAE@XZ ENDP				; CAmbientGeneric::CAmbientGeneric
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CAmbientGeneric@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CAmbientGeneric@@UAEHXZ PROC NEAR		; CAmbientGeneric::ObjectCaps, COMDAT

; 131  : 	virtual int ObjectCaps( void ) { return (BaseClass :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CAmbientGeneric@@UAEHXZ ENDP		; CAmbientGeneric::ObjectCaps
_TEXT	ENDS
PUBLIC	?GetState@CBaseDelay@@UAE?AW4STATE@@XZ		; CBaseDelay::GetState
PUBLIC	??0CBaseDelay@@QAE@XZ				; CBaseDelay::CBaseDelay
PUBLIC	?ObjectCaps@CTriggerSound@@UAEHXZ		; CTriggerSound::ObjectCaps
PUBLIC	??_7CTriggerSound@@6B@				; CTriggerSound::`vftable'
EXTRN	?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseDelay::GetDataDescMap
;	COMDAT ??_7CTriggerSound@@6B@
CONST	SEGMENT
??_7CTriggerSound@@6B@ DD FLAT:?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ ; CTriggerSound::`vftable'
	DD	FLAT:?Spawn@CTriggerSound@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CTriggerSound@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CTriggerSound@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CTriggerSound@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CTriggerSound@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CTriggerSound@@QAE@XZ PROC NEAR			; CTriggerSound::CTriggerSound, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CTriggerSound@@6B@ ; CTriggerSound::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CTriggerSound@@QAE@XZ ENDP				; CTriggerSound::CTriggerSound
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseDelay::GetState, COMDAT

; 881  : 	virtual STATE GetState( void ) { return m_iState; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1788]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ ENDP		; CBaseDelay::GetState
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CTriggerSound@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CTriggerSound@@UAEHXZ PROC NEAR		; CTriggerSound::ObjectCaps, COMDAT

; 1078 : 	virtual int ObjectCaps( void ) { return BaseClass :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CTriggerSound@@UAEHXZ ENDP			; CTriggerSound::ObjectCaps
_TEXT	ENDS
PUBLIC	??_7CSpeaker@@6B@				; CSpeaker::`vftable'
PUBLIC	?ObjectCaps@CSpeaker@@UAEHXZ			; CSpeaker::ObjectCaps
;	COMDAT ??_7CSpeaker@@6B@
CONST	SEGMENT
??_7CSpeaker@@6B@ DD FLAT:?GetDataDescMap@CSpeaker@@UAEPAUdatamap_s@@XZ ; CSpeaker::`vftable'
	DD	FLAT:?Spawn@CSpeaker@@UAEXXZ
	DD	FLAT:?Precache@CSpeaker@@UAEXXZ
	DD	FLAT:?KeyValue@CSpeaker@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CSpeaker@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CSpeaker@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CSpeaker@@QAE@XZ PROC NEAR				; CSpeaker::CSpeaker, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CSpeaker@@6B@ ; CSpeaker::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CSpeaker@@QAE@XZ ENDP				; CSpeaker::CSpeaker
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CSpeaker@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CSpeaker@@UAEHXZ PROC NEAR			; CSpeaker::ObjectCaps, COMDAT

; 2028 : 	virtual int ObjectCaps( void ) { return (BaseClass :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CSpeaker@@UAEHXZ ENDP			; CSpeaker::ObjectCaps
_TEXT	ENDS
PUBLIC	?GetState@CAmbientMusic@@UAE?AW4STATE@@XZ	; CAmbientMusic::GetState
PUBLIC	??_7CAmbientMusic@@6B@				; CAmbientMusic::`vftable'
;	COMDAT ??_7CAmbientMusic@@6B@
CONST	SEGMENT
??_7CAmbientMusic@@6B@ DD FLAT:?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ ; CAmbientMusic::`vftable'
	DD	FLAT:?Spawn@CAmbientMusic@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CAmbientMusic@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CAmbientMusic@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CAmbientMusic@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CAmbientMusic@@UAEXXZ
	DD	FLAT:?Use@CAmbientMusic@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CAmbientMusic@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CAmbientMusic@@QAE@XZ PROC NEAR			; CAmbientMusic::CAmbientMusic, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CAmbientMusic@@6B@ ; CAmbientMusic::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAmbientMusic@@QAE@XZ ENDP				; CAmbientMusic::CAmbientMusic
_TEXT	ENDS
;	COMDAT ?GetState@CAmbientMusic@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CAmbientMusic@@UAE?AW4STATE@@XZ PROC NEAR	; CAmbientMusic::GetState, COMDAT

; 2212 : 	virtual STATE GetState( void ) { return FBitSet( pev->spawnflags, SF_START_ON ) ? STATE_ON : STATE_OFF; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+416]
	and	eax, 1
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CAmbientMusic@@UAE?AW4STATE@@XZ ENDP		; CAmbientMusic::GetState
_TEXT	ENDS
PUBLIC	??_7CPointEntity@@6B@				; CPointEntity::`vftable'
EXTRN	?Spawn@CPointEntity@@UAEXXZ:NEAR		; CPointEntity::Spawn
EXTRN	?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseEntity::GetDataDescMap
;	COMDAT ??_7CPointEntity@@6B@
CONST	SEGMENT
??_7CPointEntity@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CPointEntity::`vftable'
	DD	FLAT:?Spawn@CPointEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CPointEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CPointEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CPointEntity@@QAE@XZ PROC NEAR			; CPointEntity::CPointEntity, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CPointEntity@@6B@ ; CPointEntity::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CPointEntity@@QAE@XZ ENDP				; CPointEntity::CPointEntity
_TEXT	ENDS
PUBLIC	??0WayPoint_t@@QAE@XZ				; WayPoint_t::WayPoint_t
PUBLIC	?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z	; CBaseMonster::BodyTarget
PUBLIC	?DeathSound@CBaseMonster@@UAEXXZ		; CBaseMonster::DeathSound
PUBLIC	??_7CBaseMonster@@6B@				; CBaseMonster::`vftable'
PUBLIC	??0CBaseToggle@@QAE@XZ				; CBaseToggle::CBaseToggle
PUBLIC	??1CBaseToggle@@QAE@XZ				; CBaseToggle::~CBaseToggle
PUBLIC	?Spawn@CBaseEntity@@UAEXXZ			; CBaseEntity::Spawn
PUBLIC	?Classify@CBaseMonster@@UAEHXZ			; CBaseMonster::Classify
PUBLIC	?IsAlive@CBaseMonster@@UAEHXZ			; CBaseMonster::IsAlive
EXTRN	?FBecomeProne@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::FBecomeProne
EXTRN	?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z:NEAR ; CBaseMonster::BarnacleVictimBitten
EXTRN	?BarnacleVictimReleased@CBaseMonster@@UAEXXZ:NEAR ; CBaseMonster::BarnacleVictimReleased
EXTRN	?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseMonster::TraceAttack
EXTRN	?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z:NEAR ; CBaseMonster::Killed
EXTRN	?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ:NEAR ; CBaseMonster::GetGunPosition
EXTRN	?TakeHealth@CBaseMonster@@UAEHMH@Z:NEAR		; CBaseMonster::TakeHealth
EXTRN	?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseMonster::TakeDamage
EXTRN	?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseMonster::GetDataDescMap
EXTRN	?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z:NEAR	; CBaseMonster::Restore
EXTRN	?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::ShouldFadeOnDeath
;	COMDAT ??_7CBaseMonster@@6B@
CONST	SEGMENT
??_7CBaseMonster@@6B@ DD FLAT:?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ ; CBaseMonster::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseMonster@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseMonster@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseMonster@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseMonster@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseMonster@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CBaseMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CBaseMonster@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CBaseMonster@@UAEHXZ
	DD	FLAT:?CheckAmmo@CBaseMonster@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CBaseMonster@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?PainSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseMonster@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseMonster@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseMonster@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseMonster@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseMonster@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseMonster@@QAE@XZ PROC NEAR			; CBaseMonster::CBaseMonster, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseMonster@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseToggle@@QAE@XZ			; CBaseToggle::CBaseToggle
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2008				; 000007d8H
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0WayPoint_t@@QAE@XZ	; WayPoint_t::WayPoint_t
	push	8
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2100				; 00000834H
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2240				; 000008c0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2264				; 000008d8H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2364				; 0000093cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET FLAT:??_7CBaseMonster@@6B@ ; CBaseMonster::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseMonster@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseToggle@@QAE@XZ			; CBaseToggle::~CBaseToggle
	ret	0
__ehhandler$??0CBaseMonster@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseMonster@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseMonster@@QAE@XZ ENDP				; CBaseMonster::CBaseMonster
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Spawn, COMDAT

; 325  : 	virtual void	Spawn( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Spawn
_TEXT	ENDS
;	COMDAT ?Classify@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::Classify, COMDAT

; 130  : 	virtual int	Classify( void ) { return m_iClass ? m_iClass : CLASS_NONE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2388], 0
	je	SHORT $L41855
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2388]
	mov	DWORD PTR -8+[ebp], edx
	jmp	SHORT $L41856
$L41855:
	mov	DWORD PTR -8+[ebp], 0
$L41856:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::Classify
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseMonster@@UAEHXZ PROC NEAR			; CBaseMonster::IsAlive, COMDAT

; 139  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag != DEAD_DEAD); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+368], 2
	setne	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::IsAlive
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T41861 = -16
$T41862 = -28
$T41863 = -40
$T41864 = -52
$T41865 = -64
?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseMonster::BodyTarget, COMDAT

; 318  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ) * 0.75 + EyePosition() * 0.25; };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1048576000				; 3e800000H
	lea	eax, DWORD PTR $T41864[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41863[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+308]
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T41865[ebp]
	push	ecx
	push	1061158912				; 3f400000H
	lea	edx, DWORD PTR $T41862[ebp]
	push	edx
	lea	eax, DWORD PTR $T41861[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseMonster::BodyTarget
_TEXT	ENDS
;	COMDAT ?DeathSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DeathSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::DeathSound, COMDAT

; 333  : 	virtual void DeathSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DeathSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::DeathSound
_TEXT	ENDS
;	COMDAT ??1CBaseMonster@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseMonster@@QAE@XZ PROC NEAR			; CBaseMonster::~CBaseMonster, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseToggle@@QAE@XZ			; CBaseToggle::~CBaseToggle
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseMonster@@QAE@XZ ENDP				; CBaseMonster::~CBaseMonster
_TEXT	ENDS
PUBLIC	??_7CBaseEntity@@6B@				; CBaseEntity::`vftable'
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	??0CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::CMeshDesc
EXTRN	??1CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::~CMeshDesc
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT
??_7CBaseEntity@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CBaseEntity::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseEntity@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseEntity@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseEntity@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseEntity@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseEntity@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??0CMeshDesc@@QAE@XZ			; CMeshDesc::CMeshDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1632				; 00000660H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseEntity@@6B@ ; CBaseEntity::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseEntity@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	ret	0
__ehhandler$??0CBaseEntity@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseEntity@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::CBaseEntity
PUBLIC	??_7CBaseDelay@@6B@				; CBaseDelay::`vftable'
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT
??_7CBaseDelay@@6B@ DD FLAT:?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ ; CBaseDelay::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseDelay@@6B@ ; CBaseDelay::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::CBaseDelay
_TEXT	ENDS
PUBLIC	?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z ; CBaseAnimating::HandleAnimEvent
PUBLIC	??0CBaseAnimating@@QAE@XZ			; CBaseAnimating::CBaseAnimating
PUBLIC	??1CBaseAnimating@@QAE@XZ			; CBaseAnimating::~CBaseAnimating
PUBLIC	??_7CBaseToggle@@6B@				; CBaseToggle::`vftable'
EXTRN	?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseToggle::KeyValue
EXTRN	?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z:NEAR	; CBaseToggle::Restore
EXTRN	?GetDataDescMap@CBaseToggle@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseToggle::GetDataDescMap
;	COMDAT ??_7CBaseToggle@@6B@
CONST	SEGMENT
??_7CBaseToggle@@6B@ DD FLAT:?GetDataDescMap@CBaseToggle@@UAEPAUdatamap_s@@XZ ; CBaseToggle::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseToggle@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseToggle@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseToggle@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseToggle@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseToggle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseToggle@@QAE@XZ PROC NEAR			; CBaseToggle::CBaseToggle, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseToggle@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseAnimating@@QAE@XZ		; CBaseAnimating::CBaseAnimating
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1864				; 00000748H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1912				; 00000778H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1924				; 00000784H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1936				; 00000790H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseToggle@@6B@ ; CBaseToggle::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseToggle@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseAnimating@@QAE@XZ		; CBaseAnimating::~CBaseAnimating
	ret	0
__ehhandler$??0CBaseToggle@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseToggle@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseToggle@@QAE@XZ ENDP				; CBaseToggle::CBaseToggle
;	COMDAT ?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT
_this$ = -4
?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z PROC NEAR ; CBaseAnimating::HandleAnimEvent, COMDAT

; 909  : 	virtual void HandleAnimEvent( MonsterEvent_t *pEvent ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z ENDP ; CBaseAnimating::HandleAnimEvent
_TEXT	ENDS
;	COMDAT ??1CBaseToggle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseToggle@@QAE@XZ PROC NEAR			; CBaseToggle::~CBaseToggle, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseAnimating@@QAE@XZ		; CBaseAnimating::~CBaseAnimating
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseToggle@@QAE@XZ ENDP				; CBaseToggle::~CBaseToggle
_TEXT	ENDS
;	COMDAT ??0WayPoint_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0WayPoint_t@@QAE@XZ PROC NEAR				; WayPoint_t::WayPoint_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0WayPoint_t@@QAE@XZ ENDP				; WayPoint_t::WayPoint_t
_TEXT	ENDS
PUBLIC	??_7CBaseAnimating@@6B@				; CBaseAnimating::`vftable'
EXTRN	?GetDataDescMap@CBaseAnimating@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseAnimating::GetDataDescMap
;	COMDAT ??_7CBaseAnimating@@6B@
CONST	SEGMENT
??_7CBaseAnimating@@6B@ DD FLAT:?GetDataDescMap@CBaseAnimating@@UAEPAUdatamap_s@@XZ ; CBaseAnimating::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
CONST	ENDS
;	COMDAT ??0CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseAnimating@@QAE@XZ PROC NEAR			; CBaseAnimating::CBaseAnimating, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseAnimating@@6B@ ; CBaseAnimating::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseAnimating@@QAE@XZ ENDP				; CBaseAnimating::CBaseAnimating
_TEXT	ENDS
PUBLIC	??1CBaseDelay@@QAE@XZ				; CBaseDelay::~CBaseDelay
;	COMDAT ??1CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseAnimating@@QAE@XZ PROC NEAR			; CBaseAnimating::~CBaseAnimating, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseDelay@@QAE@XZ			; CBaseDelay::~CBaseDelay
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseAnimating@@QAE@XZ ENDP				; CBaseAnimating::~CBaseAnimating
_TEXT	ENDS
PUBLIC	??1CBaseEntity@@QAE@XZ				; CBaseEntity::~CBaseEntity
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::~CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseEntity@@QAE@XZ			; CBaseEntity::~CBaseEntity
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::~CBaseDelay
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::~CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::~CBaseEntity
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
PUBLIC	??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
PUBLIC	?CopyConstruct@@YAXPAPADABQAD@Z			; CopyConstruct
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ DB '('
	DB	'elem == Count()) || IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L41917
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L41917
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L41917
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41917:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L41918
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41918
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41918:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAPADABQAD@Z		; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC NEAR		; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L41923
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41923:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L40509

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L40509:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PADH@@QAE@XZ PROC NEAR			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC NEAR		; CUtlMemory<char *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41928
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41928:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41929
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41929:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC NEAR		; CUtlMemory<char *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41932
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41932:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC NEAR	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41939
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L41939
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41940
$L41939:
	mov	DWORD PTR -8+[ebp], 0
$L41940:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAPAD@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L40542:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40543

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAD@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L40542
$L40543:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ		; CUtlMemory<char *,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@PADH@@QAEXH@Z		; CUtlMemory<char *,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L40552

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@PADH@@QAEXH@Z	; CUtlMemory<char *,int>::Grow
$L40552:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
_TEXT	ENDS
PUBLIC	??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
EXTRN	_memmove:NEAR
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ DB 'I'
	DB	'sValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 )', 00H ; `string'
CONST	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41947
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L41947
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L41947
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41947:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L40561
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L40561

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L40561:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
_src$ = 12
$T41950 = -4
?CopyConstruct@@YAXPAPADABQAD@Z PROC NEAR		; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T41950[ebp], eax
	cmp	DWORD PTR $T41950[ebp], 0
	je	SHORT $L41951
	mov	ecx, DWORD PTR $T41950[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T41950[ebp]
	mov	DWORD PTR -8+[ebp], ecx
	jmp	SHORT $L41952
$L41951:
	mov	DWORD PTR -8+[ebp], 0
$L41952:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyConstruct@@YAXPAPADABQAD@Z ENDP			; CopyConstruct
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC NEAR	; CUtlMemory<char *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41957
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L41957
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41958
$L41957:
	mov	DWORD PTR -8+[ebp], 0
$L41958:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC NEAR		; CUtlMemory<char *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40575

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L40576

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L40576:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L40575:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR	; CUtlMemory<char *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ PROC NEAR	; CUtlMemory<char *,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ ENDP		; CUtlMemory<char *,int>::NumAllocated
_TEXT	ENDS
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@PADH@@QAEXH@Z PROC NEAR		; CUtlMemory<char *,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L41967
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41967:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40590

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L41968
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41968:

; 567  : 		return;

	jmp	$L40587
$L40590:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	4
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L40610

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L40602
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L40602

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L40610
$L40602:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L40606

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L41969
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41969:

; 589  : 				return;

	jmp	$L40587
$L40606:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L40610

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L40606
$L40610:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L40613

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L41970
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41970:

; 603  : 	else

	jmp	SHORT $L41971
$L40613:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L41971
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41971:
$L40587:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@PADH@@QAEXH@Z ENDP			; CUtlMemory<char *,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L28985

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L28990
$L28985:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L28987

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L28987:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L28990

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L28987
$L28990:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR ; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAD@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAD@Z ENDP				; Destruct
_TEXT	ENDS
END
