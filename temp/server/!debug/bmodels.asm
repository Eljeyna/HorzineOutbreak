	TITLE	Z:\XashXTSRC\server\bmodels.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DHI@func_wall?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FNLH@a?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FPMG@z?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@LACP@func_wall_toggle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@ONIM@func_conveyor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@HPNC@CFuncConveyor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@PDDA@m_flMaxSpeed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@INGH@func_transporter?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@LIDA@CFuncTransporter?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HMEM@m_flWidth?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@PBDJ@?$CFs?3?5unable?5to?5fetch?5model?5pointe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@IHDD@?$CFs?3?5unable?5to?5find?5scrolling?5tex@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@ECKI@func_illusionary?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FHFO@func_monsterclip?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@HHKP@func_rotating?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@OFPB@CFuncRotating?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@LKJN@m_bStopAtStartPos?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HPGA@m_flFanFriction?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLK@m_flAttenuation?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LGMC@m_flTargetSpeed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DHKE@m_angStart?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MFGO@m_flVolume?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08KGNE@m_sounds?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06HADE@sounds?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06BLKE@SpinUp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08OHJJ@SpinDown?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MJNG@HurtTouch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MKBN@RotateFriction?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BGDO@ReverseMove?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06GGLN@Rotate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@PGKA@fanfriction?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@MGPD@spawnorigin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FLOP@volume?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@FMAO@SUB_CallUseToggle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@BABK@fans?1fan1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@PAHF@fans?1fan2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@FAFA@fans?1fan3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@DAKK@fans?1fan4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@JAIP@fans?1fan5?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LNFJ@common?1null?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@GEEH@momentary_rot_button?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@GGEE@momentary_rot_door?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@OIAN@func_pendulum?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MBEG@CPendulum?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07NHEF@m_accel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EKAB@m_distance?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GHDD@distance?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06JCMH@m_time?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06POOI@m_damp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@ILNC@m_maxSpeed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@ENNH@m_dampSpeed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EDO@m_center?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07GINM@m_start?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KAHD@Swing?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04DFLL@Stop?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LKMM@RopeTouch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04CGBF@damp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@GBDF@?$CFs?5?$FL?$CFi?$FN?5has?5invalid?5distance?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@LOEB@Not?5a?5client?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MNFC@func_clock?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EECC@CFuncClock?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DMAJ@m_vecCurtime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@GBGP@m_vecFinaltime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@DOEK@m_flCurTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@OMHK@m_iClockType?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KOF@m_iHoursCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07OFAG@m_fInit?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PIKN@type?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07EEJG@curtime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MNCH@event?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KKKL@func_light?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@CDNL@CFuncLight?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@BFGN@m_iFlickerMode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@OADN@m_flNextFlickerTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@KEJI@m_vecLastDmgPoint?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07MBCB@Flicker?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@LGDD@?$CFs?5with?5name?5?$CFs?5has?5bad?5lightsty@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CNNL@?$CFs?5?$FL?$CFi?$FN?5has?5bad?5lightstyle?5?$CFi?4?5D@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@CINK@mmamammmmammamamaaamammma?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FMCB@k?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03GODK@?$CL0?$HO?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@JCLM@debris?1bustglass1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCND@debris?1bustglass2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@ONJ@abcaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@BKKA@acaaabaaaaaaaaaaaaaaaaaaaaaaaaaa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@MFGL@aaafbaaaaaaaaaaaaaaaaaaaaaaaaaaa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@OOHK@aaaaaaaaaaaaagaaaaaaaaacaaaacaaa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@ONNB@buttons?1spark1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@NLO@buttons?1spark2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@KNJL@buttons?1spark3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?anglemod@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModel@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDebugName@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SUB_CallUseToggle@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?entindex@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMoveDoneTime@CBaseEntity@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBreakable@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExplosionMagnitude@CBreakable@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncWall@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E28
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E29
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncWall@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TurnOff@CFuncWall@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TurnOn@CFuncWall@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CFuncWall@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E31
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E32
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncWallToggle@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TurnOff@CFuncWallToggle@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TurnOn@CFuncWallToggle@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncConveyor@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E35
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CFuncConveyor@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CFuncConveyor@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E38
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E42
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncConveyor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateSpeed@CFuncConveyor@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CFuncConveyor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncTransporter@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E44
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E45
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CFuncTransporter@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CFuncTransporter@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E51
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncTransporter@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateSpeed@CFuncTransporter@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CFuncTransporter@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CFuncTransporter@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncIllusionary@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E52
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E53
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncIllusionary@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncMonsterClip@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E56
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncMonsterClip@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncRotating@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E59
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E60
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CFuncRotating@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CFuncRotating@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E62
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E63
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E66
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CFuncRotating@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncRotating@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextMoveInterval@CFuncRotating@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CFuncRotating@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HurtTouch@CFuncRotating@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RampPitchVol@CFuncRotating@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateSpeed@CFuncRotating@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpinUp@CFuncRotating@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpinDown@CFuncRotating@@QAE_NM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpinDown@CFuncRotating@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rotate@CFuncRotating@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotateFriction@CFuncRotating@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReverseMove@CFuncRotating@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTargetSpeed@CFuncRotating@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CFuncRotating@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CFuncRotating@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPendulum@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E68
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E69
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CPendulum@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CPendulum@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E71
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E72
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E75
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CPendulum@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CPendulum@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CPendulum@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stop@CPendulum@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CPendulum@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Swing@CPendulum@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CPendulum@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RopeTouch@CPendulum@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncClock@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E77
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E78
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CFuncClock@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CFuncClock@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E80
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E81
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E84
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CFuncClock@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncClock@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CFuncClock@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CFuncClock@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E86
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E87
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CFuncLight@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CFuncLight@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E89
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E90
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E93
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncLight@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CFuncLight@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceAttack@CFuncLight@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TakeDamage@CFuncLight@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Die@CFuncLight@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Flicker@CFuncLight@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncWall@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncWall@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncWall@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncWall@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncWallToggle@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncWallToggle@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncWallToggle@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncWallToggle@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncConveyor@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncConveyor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncConveyor@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncConveyor@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTransporter@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncTransporter@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTransporter@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTransporter@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncIllusionary@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncIllusionary@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncIllusionary@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncIllusionary@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncMonsterClip@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncMonsterClip@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncMonsterClip@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncMonsterClip@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncRotating@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncRotating@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncRotating@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncRotating@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCPendulum@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCPendulum@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCPendulum@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCPendulum@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncClock@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncClock@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncClock@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncClock@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncLight@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncLight@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncLight@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncLight@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBreakable@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncWall@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncWallToggle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncConveyor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncTransporter@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncIllusionary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncMonsterClip@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncRotating@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPendulum@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncClock@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncLight@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFuncWall@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBreakable@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBreakable@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncLight@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CPendulum@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCPendulum@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncClock@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncRotating@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncRotating@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncTransporter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncClock@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncConveyor@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncConveyor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncIllusionary@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncIllusionary@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncMonsterClip@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBreakable@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncWall@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncLight@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncWallToggle@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncMonsterClip@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncWallToggle@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncTransporter@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncWall@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?m_DataMap@CPendulum@@2Udatamap_s@@A		; CPendulum::m_DataMap
PUBLIC	??_C@_09MBEG@CPendulum?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CPendulum_DataDescInit@@3PAUdatamap_s@@A ; CPendulum_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_07NHEF@m_accel?$AA@			; `string'
PUBLIC	??_C@_0L@EKAB@m_distance?$AA@			; `string'
PUBLIC	??_C@_08GHDD@distance?$AA@			; `string'
PUBLIC	??_C@_06JCMH@m_time?$AA@			; `string'
PUBLIC	??_C@_06POOI@m_damp?$AA@			; `string'
PUBLIC	??_C@_0L@ILNC@m_maxSpeed?$AA@			; `string'
PUBLIC	??_C@_0M@ENNH@m_dampSpeed?$AA@			; `string'
PUBLIC	??_C@_08EDO@m_center?$AA@			; `string'
PUBLIC	??_C@_07GINM@m_start?$AA@			; `string'
PUBLIC	?m_DataMap@CFuncConveyor@@2Udatamap_s@@A	; CFuncConveyor::m_DataMap
PUBLIC	??_C@_0O@HPNC@CFuncConveyor?$AA@		; `string'
PUBLIC	?g_DataMapHolder@CFuncConveyor_DataDescInit@@3PAUdatamap_s@@A ; CFuncConveyor_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0N@PDDA@m_flMaxSpeed?$AA@			; `string'
PUBLIC	?m_DataMap@CFuncClock@@2Udatamap_s@@A		; CFuncClock::m_DataMap
PUBLIC	?m_DataMap@CFuncTransporter@@2Udatamap_s@@A	; CFuncTransporter::m_DataMap
PUBLIC	??_C@_0L@EECC@CFuncClock?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CFuncClock_DataDescInit@@3PAUdatamap_s@@A ; CFuncClock_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0BB@LIDA@CFuncTransporter?$AA@		; `string'
PUBLIC	??_C@_0N@DMAJ@m_vecCurtime?$AA@			; `string'
PUBLIC	??_C@_0P@GBGP@m_vecFinaltime?$AA@		; `string'
PUBLIC	??_C@_0M@DOEK@m_flCurTime?$AA@			; `string'
PUBLIC	??_C@_0N@OMHK@m_iClockType?$AA@			; `string'
PUBLIC	??_C@_0O@KOF@m_iHoursCount?$AA@			; `string'
PUBLIC	??_C@_07OFAG@m_fInit?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CFuncTransporter_DataDescInit@@3PAUdatamap_s@@A ; CFuncTransporter_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_09HMEM@m_flWidth?$AA@			; `string'
PUBLIC	?m_DataMap@CFuncLight@@2Udatamap_s@@A		; CFuncLight::m_DataMap
PUBLIC	??_C@_0L@CDNL@CFuncLight?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CFuncLight_DataDescInit@@3PAUdatamap_s@@A ; CFuncLight_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0P@BFGN@m_iFlickerMode?$AA@		; `string'
PUBLIC	??_C@_0BE@OADN@m_flNextFlickerTime?$AA@		; `string'
PUBLIC	??_C@_0BC@KEJI@m_vecLastDmgPoint?$AA@		; `string'
PUBLIC	?m_DataMap@CFuncRotating@@2Udatamap_s@@A	; CFuncRotating::m_DataMap
PUBLIC	??_C@_0O@OFPB@CFuncRotating?$AA@		; `string'
PUBLIC	?g_DataMapHolder@CFuncRotating_DataDescInit@@3PAUdatamap_s@@A ; CFuncRotating_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0BC@LKJN@m_bStopAtStartPos?$AA@		; `string'
PUBLIC	??_C@_0BA@HPGA@m_flFanFriction?$AA@		; `string'
PUBLIC	??_C@_0BA@PLK@m_flAttenuation?$AA@		; `string'
PUBLIC	??_C@_0BA@LGMC@m_flTargetSpeed?$AA@		; `string'
PUBLIC	??_C@_0L@DHKE@m_angStart?$AA@			; `string'
PUBLIC	??_C@_0L@MFGO@m_flVolume?$AA@			; `string'
PUBLIC	??_C@_08KGNE@m_sounds?$AA@			; `string'
PUBLIC	??_C@_06HADE@sounds?$AA@			; `string'
_BSS	SEGMENT
?g_DataMapHolder@CPendulum_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CPendulum_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CFuncConveyor_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CFuncConveyor_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CFuncClock_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CFuncClock_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CFuncTransporter_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CFuncTransporter_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CFuncLight_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CFuncLight_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CFuncRotating_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CFuncRotating_DataDescInit::g_DataMapHolder
_BSS	ENDS
CRT$XCU	SEGMENT
_$S30	DD	FLAT:_$E29
_$S33	DD	FLAT:_$E32
_$S37	DD	FLAT:_$E36
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CFuncConveyor@@2Udatamap_s@@A DD 00H		; CFuncConveyor::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0O@HPNC@CFuncConveyor?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S40	DD	FLAT:_$E39
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0N@PDDA@m_flMaxSpeed?$AA@
	DD	0700H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S46	DD	FLAT:_$E45
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CFuncTransporter@@2Udatamap_s@@A DD 00H	; CFuncTransporter::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0BB@LIDA@CFuncTransporter?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S49	DD	FLAT:_$E48
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0N@PDDA@m_flMaxSpeed?$AA@
	DD	0700H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_09HMEM@m_flWidth?$AA@
	DD	0704H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S54	DD	FLAT:_$E53
_$S57	DD	FLAT:_$E56
_$S61	DD	FLAT:_$E60
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CFuncRotating@@2Udatamap_s@@A DD 00H		; CFuncRotating::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0O@OFPB@CFuncRotating?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S64	DD	FLAT:_$E63
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BC@LKJN@m_bStopAtStartPos?$AA@
	DD	0700H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BA@HPGA@m_flFanFriction?$AA@
	DD	0704H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BA@PLK@m_flAttenuation?$AA@
	DD	0708H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BA@LGMC@m_flTargetSpeed?$AA@
	DD	070cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0N@PDDA@m_flMaxSpeed?$AA@
	DD	0710H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0L@DHKE@m_angStart?$AA@
	DD	0718H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@MFGO@m_flVolume?$AA@
	DD	0714H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:??_C@_08KGNE@m_sounds?$AA@
	DD	0724H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06HADE@sounds?$AA@
	DD	00H
	DD	012H
	ORG $+140
_DATA	ENDS
CRT$XCU	SEGMENT
_$S70	DD	FLAT:_$E69
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CPendulum@@2Udatamap_s@@A DD 00H		; CPendulum::m_DataMap
	DD	00H
	DD	FLAT:??_C@_09MBEG@CPendulum?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S73	DD	FLAT:_$E72
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_07NHEF@m_accel?$AA@
	DD	0700H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@EKAB@m_distance?$AA@
	DD	0704H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08GHDD@distance?$AA@
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_06JCMH@m_time?$AA@
	DD	0708H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_06POOI@m_damp?$AA@
	DD	070cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@ILNC@m_maxSpeed?$AA@
	DD	0710H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0M@ENNH@m_dampSpeed?$AA@
	DD	0714H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_08EDO@m_center?$AA@
	DD	0718H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_07GINM@m_start?$AA@
	DD	0724H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+68
_DATA	ENDS
CRT$XCU	SEGMENT
_$S79	DD	FLAT:_$E78
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CFuncClock@@2Udatamap_s@@A DD 00H		; CFuncClock::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0L@EECC@CFuncClock?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S82	DD	FLAT:_$E81
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0N@DMAJ@m_vecCurtime?$AA@
	DD	0700H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0P@GBGP@m_vecFinaltime?$AA@
	DD	070cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0M@DOEK@m_flCurTime?$AA@
	DD	0718H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0N@OMHK@m_iClockType?$AA@
	DD	071cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0O@KOF@m_iHoursCount?$AA@
	DD	0720H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_07OFAG@m_fInit?$AA@
	DD	0724H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S88	DD	FLAT:_$E87
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CFuncLight@@2Udatamap_s@@A DD 00H		; CFuncLight::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0L@CDNL@CFuncLight?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S91	DD	FLAT:_$E90
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0P@BFGN@m_iFlickerMode?$AA@
	DD	0718H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BE@OADN@m_flNextFlickerTime?$AA@
	DD	0728H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	08H
	DD	FLAT:??_C@_0BC@KEJI@m_vecLastDmgPoint?$AA@
	DD	071cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+20
_DATA	ENDS
;	COMDAT ??_C@_0O@HPNC@CFuncConveyor?$AA@
CONST	SEGMENT
??_C@_0O@HPNC@CFuncConveyor?$AA@ DB 'CFuncConveyor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PDDA@m_flMaxSpeed?$AA@
CONST	SEGMENT
??_C@_0N@PDDA@m_flMaxSpeed?$AA@ DB 'm_flMaxSpeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LIDA@CFuncTransporter?$AA@
CONST	SEGMENT
??_C@_0BB@LIDA@CFuncTransporter?$AA@ DB 'CFuncTransporter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HMEM@m_flWidth?$AA@
CONST	SEGMENT
??_C@_09HMEM@m_flWidth?$AA@ DB 'm_flWidth', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OFPB@CFuncRotating?$AA@
CONST	SEGMENT
??_C@_0O@OFPB@CFuncRotating?$AA@ DB 'CFuncRotating', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LKJN@m_bStopAtStartPos?$AA@
CONST	SEGMENT
??_C@_0BC@LKJN@m_bStopAtStartPos?$AA@ DB 'm_bStopAtStartPos', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HPGA@m_flFanFriction?$AA@
CONST	SEGMENT
??_C@_0BA@HPGA@m_flFanFriction?$AA@ DB 'm_flFanFriction', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLK@m_flAttenuation?$AA@
CONST	SEGMENT
??_C@_0BA@PLK@m_flAttenuation?$AA@ DB 'm_flAttenuation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LGMC@m_flTargetSpeed?$AA@
CONST	SEGMENT
??_C@_0BA@LGMC@m_flTargetSpeed?$AA@ DB 'm_flTargetSpeed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHKE@m_angStart?$AA@
CONST	SEGMENT
??_C@_0L@DHKE@m_angStart?$AA@ DB 'm_angStart', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MFGO@m_flVolume?$AA@
CONST	SEGMENT
??_C@_0L@MFGO@m_flVolume?$AA@ DB 'm_flVolume', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KGNE@m_sounds?$AA@
CONST	SEGMENT
??_C@_08KGNE@m_sounds?$AA@ DB 'm_sounds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HADE@sounds?$AA@
CONST	SEGMENT
??_C@_06HADE@sounds?$AA@ DB 'sounds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBEG@CPendulum?$AA@
CONST	SEGMENT
??_C@_09MBEG@CPendulum?$AA@ DB 'CPendulum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NHEF@m_accel?$AA@
CONST	SEGMENT
??_C@_07NHEF@m_accel?$AA@ DB 'm_accel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EKAB@m_distance?$AA@
CONST	SEGMENT
??_C@_0L@EKAB@m_distance?$AA@ DB 'm_distance', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHDD@distance?$AA@
CONST	SEGMENT
??_C@_08GHDD@distance?$AA@ DB 'distance', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JCMH@m_time?$AA@
CONST	SEGMENT
??_C@_06JCMH@m_time?$AA@ DB 'm_time', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06POOI@m_damp?$AA@
CONST	SEGMENT
??_C@_06POOI@m_damp?$AA@ DB 'm_damp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ILNC@m_maxSpeed?$AA@
CONST	SEGMENT
??_C@_0L@ILNC@m_maxSpeed?$AA@ DB 'm_maxSpeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ENNH@m_dampSpeed?$AA@
CONST	SEGMENT
??_C@_0M@ENNH@m_dampSpeed?$AA@ DB 'm_dampSpeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EDO@m_center?$AA@
CONST	SEGMENT
??_C@_08EDO@m_center?$AA@ DB 'm_center', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GINM@m_start?$AA@
CONST	SEGMENT
??_C@_07GINM@m_start?$AA@ DB 'm_start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EECC@CFuncClock?$AA@
CONST	SEGMENT
??_C@_0L@EECC@CFuncClock?$AA@ DB 'CFuncClock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DMAJ@m_vecCurtime?$AA@
CONST	SEGMENT
??_C@_0N@DMAJ@m_vecCurtime?$AA@ DB 'm_vecCurtime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GBGP@m_vecFinaltime?$AA@
CONST	SEGMENT
??_C@_0P@GBGP@m_vecFinaltime?$AA@ DB 'm_vecFinaltime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DOEK@m_flCurTime?$AA@
CONST	SEGMENT
??_C@_0M@DOEK@m_flCurTime?$AA@ DB 'm_flCurTime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OMHK@m_iClockType?$AA@
CONST	SEGMENT
??_C@_0N@OMHK@m_iClockType?$AA@ DB 'm_iClockType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KOF@m_iHoursCount?$AA@
CONST	SEGMENT
??_C@_0O@KOF@m_iHoursCount?$AA@ DB 'm_iHoursCount', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OFAG@m_fInit?$AA@
CONST	SEGMENT
??_C@_07OFAG@m_fInit?$AA@ DB 'm_fInit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CDNL@CFuncLight?$AA@
CONST	SEGMENT
??_C@_0L@CDNL@CFuncLight?$AA@ DB 'CFuncLight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BFGN@m_iFlickerMode?$AA@
CONST	SEGMENT
??_C@_0P@BFGN@m_iFlickerMode?$AA@ DB 'm_iFlickerMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OADN@m_flNextFlickerTime?$AA@
CONST	SEGMENT
??_C@_0BE@OADN@m_flNextFlickerTime?$AA@ DB 'm_flNextFlickerTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KEJI@m_vecLastDmgPoint?$AA@
CONST	SEGMENT
??_C@_0BC@KEJI@m_vecLastDmgPoint?$AA@ DB 'm_vecLastDmgPoint', 00H ; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
;	COMDAT _$E29
_TEXT	SEGMENT
_$E29	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E28
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E29	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncWall@@@@QAE@PBD@Z	; CEntityFactory<CFuncWall>::CEntityFactory<CFuncWall>
PUBLIC	??_C@_09DHI@func_wall?$AA@			; `string'
_BSS	SEGMENT
_func_wall DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09DHI@func_wall?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_09DHI@func_wall?$AA@ DB 'func_wall', 00H		; `string'
CONST	ENDS
;	COMDAT _$E28
_TEXT	SEGMENT
_$E28	PROC NEAR					; COMDAT

; 36   : LINK_ENTITY_TO_CLASS( func_wall, CFuncWall );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_09DHI@func_wall?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_func_wall
	call	??0?$CEntityFactory@VCFuncWall@@@@QAE@PBD@Z ; CEntityFactory<CFuncWall>::CEntityFactory<CFuncWall>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E28	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CFuncWall@@UAEXXZ			; CFuncWall::Spawn
PUBLIC	??_C@_01FNLH@a?$AA@				; `string'
PUBLIC	??_C@_01FPMG@z?$AA@				; `string'
PUBLIC	??_C@_0BB@LACP@func_wall_toggle?$AA@		; `string'
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	?GetModel@CBaseEntity@@QAEPBDXZ			; CBaseEntity::GetModel
PUBLIC	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z		; FClassnameIs
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
EXTRN	?WorldPhysic@@3PAVIPhysicLayer@@A:DWORD		; WorldPhysic
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAngles
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
;	COMDAT ??_C@_01FNLH@a?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_01FNLH@a?$AA@ DB 'a', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01FPMG@z?$AA@
CONST	SEGMENT
??_C@_01FPMG@z?$AA@ DB 'z', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LACP@func_wall_toggle?$AA@
CONST	SEGMENT
??_C@_0BB@LACP@func_wall_toggle?$AA@ DB 'func_wall_toggle', 00H ; `string'
CONST	ENDS
;	COMDAT ?Spawn@CFuncWall@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CFuncWall@@UAEXXZ PROC NEAR			; CFuncWall::Spawn, COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 40   : 	pev->flags |= FL_WORLDBRUSH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 41   : 	pev->solid = SOLID_BSP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 4

; 42   : 	pev->movetype = MOVETYPE_PUSH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+264], 7

; 43   : 	m_iState = STATE_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 0

; 44   : 
; 45   : 	SetLocalAngles( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 46   : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 47   : 
; 48   : 	// LRC (support generic switchable texlight)
; 49   : 	if( m_iStyle >= 32 )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+64], 32			; 00000020H
	jl	SHORT $L37027

; 50   : 		LIGHT_STYLE( m_iStyle, "a" );

	push	OFFSET FLAT:??_C@_01FNLH@a?$AA@		; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8

; 51   : 	else if( m_iStyle <= -32 )

	jmp	SHORT $L37030
$L37027:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+64], -32			; ffffffe0H
	jg	SHORT $L37030

; 52   : 		LIGHT_STYLE( -m_iStyle, "z" );

	push	OFFSET FLAT:??_C@_01FPMG@z?$AA@		; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	neg	eax
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8
$L37030:

; 53   : 
; 54   : 	if( m_hParent != NULL || FClassnameIs( pev, "func_wall_toggle" ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $L37033
	push	OFFSET FLAT:??_C@_0BB@LACP@func_wall_toggle?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L37032
$L37033:

; 55   : 		m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 56   : 	else m_pUserData = WorldPhysic->CreateStaticBodyFromEntity( this );

	jmp	SHORT $L37035
$L37032:
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax
$L37035:

; 57   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncWall@@UAEXXZ ENDP				; CFuncWall::Spawn
_TEXT	ENDS
PUBLIC	?FNullEnt@@YAHPAUentvars_s@@@Z			; FNullEnt
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT
_pev$ = 8
_szClassname$ = 12
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z PROC NEAR		; FClassnameIs, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 295  : 	if( FNullEnt( pev )) return FALSE;

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L32565
	xor	eax, eax
	jmp	SHORT $L32564
$L32565:

; 296  : 	return FStrEq( STRING( pev->classname ), szClassname );

	mov	ecx, DWORD PTR _szClassname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pev$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
$L32564:

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z ENDP		; FClassnameIs
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?FNullEnt@@YAHPAUentvars_s@@@Z PROC NEAR		; FNullEnt, COMDAT

; 196  : inline BOOL FNullEnt(entvars_t* pev)				{ return pev == NULL || FNullEnt(OFFSET(pev)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pev$[ebp], 0
	je	SHORT $L39739
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39739
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L39740
$L39739:
	mov	DWORD PTR -4+[ebp], 1
$L39740:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAUentvars_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad pev in OFFSET()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?OFFSET@@YAHPAUentvars_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L32439

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32439:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
;	COMDAT ?GetModel@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetModel@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetModel, COMDAT

; 288  : 	const char*	GetModel() { return STRING( pev->model ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+184]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetModel@CBaseEntity@@QAEPBDXZ ENDP			; CBaseEntity::GetModel
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
PUBLIC	?TurnOff@CFuncWall@@UAEXXZ			; CFuncWall::TurnOff
EXTRN	__fltused:NEAR
;	COMDAT ?TurnOff@CFuncWall@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TurnOff@CFuncWall@@UAEXXZ PROC NEAR			; CFuncWall::TurnOff, COMDAT

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 	pev->frame = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+304], 0

; 62   : 	m_iState = STATE_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 0

; 63   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TurnOff@CFuncWall@@UAEXXZ ENDP				; CFuncWall::TurnOff
_TEXT	ENDS
PUBLIC	?TurnOn@CFuncWall@@UAEXXZ			; CFuncWall::TurnOn
;	COMDAT ?TurnOn@CFuncWall@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TurnOn@CFuncWall@@UAEXXZ PROC NEAR			; CFuncWall::TurnOn, COMDAT

; 66   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 	pev->frame = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+304], 1065353216		; 3f800000H

; 68   : 	m_iState = STATE_ON;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 1

; 69   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TurnOn@CFuncWall@@UAEXXZ ENDP				; CFuncWall::TurnOn
_TEXT	ENDS
PUBLIC	?Use@CFuncWall@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncWall::Use
PUBLIC	__real@4@00000000000000000000
EXTRN	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z:NEAR ; CBaseDelay::IsLockedByMaster
EXTRN	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z:NEAR ; CBaseEntity::ShouldToggle
;	COMDAT __real@4@00000000000000000000
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT ?Use@CFuncWall@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_this$ = -4
?Use@CFuncWall@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CFuncWall::Use, COMDAT

; 72   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 73   : 	if( IsLockedByMaster( pActivator ))

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z ; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L37051

; 74   : 		return;

	jmp	$L37050
$L37051:

; 75   : 
; 76   : 	if( ShouldToggle( useType ))

	mov	ecx, DWORD PTR _useType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z ; CBaseEntity::ShouldToggle
	test	eax, eax
	je	$L37061

; 78   : 		if( GetState() == STATE_ON )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+88]
	cmp	eax, 1
	jne	SHORT $L37053

; 79   : 			TurnOff();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+344]

; 80   : 		else TurnOn();

	jmp	SHORT $L37054
$L37053:
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+340]
$L37054:

; 81   : 
; 82   : 		// LRC (support generic switchable texlight)
; 83   : 		if( m_iStyle >= 32 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+64], 32			; 00000020H
	jl	SHORT $L37055

; 85   : 			if( pev->frame )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+304]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L37056

; 86   : 				LIGHT_STYLE( m_iStyle, "z" );

	push	OFFSET FLAT:??_C@_01FPMG@z?$AA@		; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8

; 87   : 			else

	jmp	SHORT $L37057
$L37056:

; 88   : 				LIGHT_STYLE( m_iStyle, "a" );

	push	OFFSET FLAT:??_C@_01FNLH@a?$AA@		; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8
$L37057:

; 90   : 		else if( m_iStyle <= -32 )

	jmp	SHORT $L37061
$L37055:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+64], -32			; ffffffe0H
	jg	SHORT $L37061

; 92   : 			if( pev->frame )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+304]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L37060

; 93   : 				LIGHT_STYLE( -m_iStyle, "a" );

	push	OFFSET FLAT:??_C@_01FNLH@a?$AA@		; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	neg	edx
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8

; 94   : 			else

	jmp	SHORT $L37061
$L37060:

; 95   : 				LIGHT_STYLE( -m_iStyle, "z" );

	push	OFFSET FLAT:??_C@_01FPMG@z?$AA@		; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	neg	ecx
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8
$L37061:
$L37050:

; 98   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CFuncWall@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CFuncWall::Use
_TEXT	ENDS
;	COMDAT _$E32
_TEXT	SEGMENT
_$E32	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E31
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E32	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncWallToggle@@@@QAE@PBD@Z ; CEntityFactory<CFuncWallToggle>::CEntityFactory<CFuncWallToggle>
_BSS	SEGMENT
_func_wall_toggle DD 01H DUP (?)
_BSS	ENDS
;	COMDAT _$E31
_TEXT	SEGMENT
_$E31	PROC NEAR					; COMDAT

; 113  : LINK_ENTITY_TO_CLASS( func_wall_toggle, CFuncWallToggle );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BB@LACP@func_wall_toggle?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_wall_toggle
	call	??0?$CEntityFactory@VCFuncWallToggle@@@@QAE@PBD@Z ; CEntityFactory<CFuncWallToggle>::CEntityFactory<CFuncWallToggle>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E31	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CFuncWallToggle@@UAEXXZ			; CFuncWallToggle::Spawn
;	COMDAT ?Spawn@CFuncWallToggle@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CFuncWallToggle@@UAEXXZ PROC NEAR		; CFuncWallToggle::Spawn, COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 	BaseClass::Spawn();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Spawn@CFuncWall@@UAEXXZ		; CFuncWall::Spawn

; 118  : 
; 119  : 	if( FBitSet( pev->spawnflags, SF_WALL_START_OFF ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1
	test	edx, edx
	je	SHORT $L37113

; 120  : 		TurnOff();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+344]

; 121  : 	else TurnOn();

	jmp	SHORT $L37114
$L37113:
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+340]
$L37114:

; 122  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncWallToggle@@UAEXXZ ENDP			; CFuncWallToggle::Spawn
_TEXT	ENDS
PUBLIC	?TurnOff@CFuncWallToggle@@UAEXXZ		; CFuncWallToggle::TurnOff
EXTRN	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z:NEAR ; CBaseEntity::RelinkEntity
;	COMDAT ?TurnOff@CFuncWallToggle@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TurnOff@CFuncWallToggle@@UAEXXZ PROC NEAR		; CFuncWallToggle::TurnOff, COMDAT

; 125  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 126  : 	WorldPhysic->EnableCollision( this, FALSE );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+92]

; 127  : 	pev->solid = SOLID_NOT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 0

; 128  : 	pev->effects |= EF_NODRAW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+280]
	or	cl, -128				; ffffff80H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+280], ecx

; 129  : 	RelinkEntity( FALSE );

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 130  : 	m_iState = STATE_OFF;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 0

; 131  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TurnOff@CFuncWallToggle@@UAEXXZ ENDP			; CFuncWallToggle::TurnOff
_TEXT	ENDS
PUBLIC	?TurnOn@CFuncWallToggle@@UAEXXZ			; CFuncWallToggle::TurnOn
;	COMDAT ?TurnOn@CFuncWallToggle@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TurnOn@CFuncWallToggle@@UAEXXZ PROC NEAR		; CFuncWallToggle::TurnOn, COMDAT

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 135  : 	WorldPhysic->EnableCollision( this, TRUE );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+92]

; 136  : 	pev->solid = SOLID_BSP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 4

; 137  : 	pev->effects &= ~EF_NODRAW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+280]
	and	cl, 127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+280], ecx

; 138  : 	RelinkEntity( FALSE );

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 139  : 	m_iState = STATE_ON;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 1

; 140  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TurnOn@CFuncWallToggle@@UAEXXZ ENDP			; CFuncWallToggle::TurnOn
_TEXT	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT
_$E36	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E35
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E36	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncConveyor@@@@QAE@PBD@Z	; CEntityFactory<CFuncConveyor>::CEntityFactory<CFuncConveyor>
PUBLIC	??_C@_0O@ONIM@func_conveyor?$AA@		; `string'
_BSS	SEGMENT
_func_conveyor DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@ONIM@func_conveyor?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0O@ONIM@func_conveyor?$AA@ DB 'func_conveyor', 00H ; `string'
CONST	ENDS
;	COMDAT _$E35
_TEXT	SEGMENT
_$E35	PROC NEAR					; COMDAT

; 162  : LINK_ENTITY_TO_CLASS( func_conveyor, CFuncConveyor );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0O@ONIM@func_conveyor?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_conveyor
	call	??0?$CEntityFactory@VCFuncConveyor@@@@QAE@PBD@Z ; CEntityFactory<CFuncConveyor>::CEntityFactory<CFuncConveyor>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E35	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CFuncConveyor@@UAEPAUdatamap_s@@XZ ; CFuncConveyor::GetDataDescMap
;	COMDAT ?GetDataDescMap@CFuncConveyor@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CFuncConveyor@@UAEPAUdatamap_s@@XZ PROC NEAR ; CFuncConveyor::GetDataDescMap, COMDAT

; 164  : BEGIN_DATADESC( CFuncConveyor )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncConveyor@@2Udatamap_s@@A ; CFuncConveyor::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CFuncConveyor@@UAEPAUdatamap_s@@XZ ENDP	; CFuncConveyor::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CFuncConveyor@@SAPAUdatamap_s@@XZ	; CFuncConveyor::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CFuncConveyor@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CFuncConveyor@@SAPAUdatamap_s@@XZ PROC NEAR	; CFuncConveyor::GetBaseMap, COMDAT

; 164  : BEGIN_DATADESC( CFuncConveyor )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CFuncConveyor@@SAPAUdatamap_s@@XZ ENDP	; CFuncConveyor::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT
_$E39	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E38
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E39	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z ; DataMapInit
;	COMDAT _$E38
_TEXT	SEGMENT
_$E38	PROC NEAR					; COMDAT

; 164  : BEGIN_DATADESC( CFuncConveyor )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CFuncConveyor_DataDescInit@@3PAUdatamap_s@@A, eax ; CFuncConveyor_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E38	ENDP
_TEXT	ENDS
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z PROC NEAR ; DataMapInit, COMDAT

; 164  : BEGIN_DATADESC( CFuncConveyor )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L37232
	mov	cl, BYTE PTR _?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0O@HPNC@CFuncConveyor?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E42
	call	_atexit
	add	esp, 4
$L37232:
	call	?GetBaseMap@CFuncConveyor@@SAPAUdatamap_s@@XZ ; CFuncConveyor::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CFuncConveyor@@2Udatamap_s@@A+12, eax

; 165  : 	DEFINE_FIELD( m_flMaxSpeed, FIELD_FLOAT ),
; 166  : END_DATADESC()

	mov	edx, 1
	test	edx, edx
	je	SHORT $L37239
	mov	DWORD PTR ?m_DataMap@CFuncConveyor@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncConveyor@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L37240
$L37239:
	mov	DWORD PTR ?m_DataMap@CFuncConveyor@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncConveyor@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z@4PAUtypedescription_s@@A
$L37240:
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncConveyor@@2Udatamap_s@@A ; CFuncConveyor::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z ENDP	; DataMapInit
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
EXTRN	_strlen:NEAR
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_pszBase$ = 8
_this$ = -4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC NEAR	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E42
_TEXT	SEGMENT
_$E42	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncConveyor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E42	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File z:\xashxtsrc\common\datamap.h
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
_i$ = -20
$T39799 = -24
__$EHRec$ = -12
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC NEAR	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L30214
$L30215:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L30214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L30216

; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T39799[ebp], edx
	mov	eax, DWORD PTR $T39799[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 		}

	jmp	SHORT $L30215
$L30216:

; 202  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	ret	0
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
PUBLIC	?Spawn@CFuncConveyor@@UAEXXZ			; CFuncConveyor::Spawn
PUBLIC	?UpdateSpeed@CFuncConveyor@@QAEXM@Z		; CFuncConveyor::UpdateSpeed
;	COMDAT ?Spawn@CFuncConveyor@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
$T39813 = -16
?Spawn@CFuncConveyor@@UAEXXZ PROC NEAR			; CFuncConveyor::Spawn, COMDAT

; 169  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 	pev->flags |= FL_WORLDBRUSH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 171  : 	pev->solid = SOLID_BSP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 4

; 172  : 	pev->movetype = MOVETYPE_PUSH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+264], 7

; 173  : 
; 174  : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 175  : 
; 176  : 	if( !FBitSet( pev->spawnflags, SF_CONVEYOR_VISUAL ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1
	test	edx, edx
	jne	SHORT $L37246

; 177  : 		SetBits( pev->flags, FL_CONVEYOR );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	or	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx
$L37246:

; 178  : 
; 179  : 	// is mapper forgot set angles?
; 180  : 	if( pev->movedir == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L37247

; 181  : 		pev->movedir = Vector( 1, 0, 0 );

	push	0
	push	0
	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR $T39813[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L37247:

; 182  : 
; 183  : 	// HACKHACK - This is to allow for some special effects
; 184  : 	if( FBitSet( pev->spawnflags, SF_CONVEYOR_NOTSOLID ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 2
	test	eax, eax
	je	SHORT $L37249

; 186  : 		pev->solid = SOLID_NOT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 0

; 187  : 		pev->skin = 0; // don't want the engine thinking we've got special contents on this brush

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+272], 0

; 189  : 	else

	jmp	SHORT $L37252
$L37249:

; 191  : 		if( m_hParent )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37251

; 192  : 			m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 193  : 		else m_pUserData = WorldPhysic->CreateStaticBodyFromEntity( this );

	jmp	SHORT $L37252
$L37251:
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax
$L37252:

; 195  : 
; 196  : 	if( pev->speed == 0 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37253

; 197  : 		pev->speed = 100;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+504], 1120403456		; 42c80000H
$L37253:

; 198  : 
; 199  : 	m_flMaxSpeed = pev->speed;	// save initial speed

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+504]
	mov	DWORD PTR [edx+1792], eax

; 200  : 
; 201  : 	if( FBitSet( pev->spawnflags, SF_CONVEYOR_STARTOFF ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 4
	test	eax, eax
	je	SHORT $L37254

; 202  : 		UpdateSpeed( 0 );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSpeed@CFuncConveyor@@QAEXM@Z	; CFuncConveyor::UpdateSpeed

; 203  : 	else UpdateSpeed( m_flMaxSpeed );

	jmp	SHORT $L37255
$L37254:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1792]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSpeed@CFuncConveyor@@QAEXM@Z	; CFuncConveyor::UpdateSpeed
$L37255:

; 204  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncConveyor@@UAEXXZ ENDP			; CFuncConveyor::Spawn
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39818
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39818
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39818
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39819
$L39818:
	mov	DWORD PTR -8+[ebp], 0
$L39819:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
PUBLIC	__real@4@bfff8000000000000000
PUBLIC	__real@8@40038000000000000000
EXTRN	_fabs:NEAR
EXTRN	__ftol:NEAR
;	COMDAT __real@4@bfff8000000000000000
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
__real@4@bfff8000000000000000 DD 0bf800000r	; -1
CONST	ENDS
;	COMDAT __real@8@40038000000000000000
CONST	SEGMENT
__real@8@40038000000000000000 DQ 04030000000000000r ; 16
CONST	ENDS
;	COMDAT ?UpdateSpeed@CFuncConveyor@@QAEXM@Z
_TEXT	SEGMENT
_speed$ = 8
_this$ = -4
_speedCode$ = -8
?UpdateSpeed@CFuncConveyor@@QAEXM@Z PROC NEAR		; CFuncConveyor::UpdateSpeed, COMDAT

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 208  : 	// make sure the sign is correct - positive for forward rotation,
; 209  : 	// negative for reverse rotation.
; 210  : 	speed = fabs( speed );

	fld	DWORD PTR _speed$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _speed$[ebp]

; 211  : 	if( pev->impulse ) speed *= -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+388], 0
	je	SHORT $L37260
	fld	DWORD PTR _speed$[ebp]
	fmul	DWORD PTR __real@4@bfff8000000000000000
	fstp	DWORD PTR _speed$[ebp]
$L37260:

; 212  : 
; 213  : 	// encode it as an integer with 4 fractional bits
; 214  : 	int speedCode = (int)(fabs( speed ) * 16.0f);

	fld	DWORD PTR _speed$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fmul	QWORD PTR __real@8@40038000000000000000
	call	__ftol
	mov	DWORD PTR _speedCode$[ebp], eax

; 215  : 
; 216  : 	// HACKHACK -- This is ugly, but encode the speed in the rendercolor
; 217  : 	// to avoid adding more data to the network stream
; 218  : 	pev->rendercolor.x = (speed < 0) ? 1 : 0;

	fld	DWORD PTR _speed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39822
	mov	DWORD PTR -12+[ebp], 1
	jmp	SHORT $L39823
$L39822:
	mov	DWORD PTR -12+[ebp], 0
$L39823:
	fild	DWORD PTR -12+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+336]

; 219  : 	pev->rendercolor.y = (speedCode >> 8);

	mov	ecx, DWORD PTR _speedCode$[ebp]
	sar	ecx, 8
	mov	DWORD PTR -16+[ebp], ecx
	fild	DWORD PTR -16+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+340]

; 220  : 	pev->rendercolor.z = (speedCode & 0xFF);

	mov	ecx, DWORD PTR _speedCode$[ebp]
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR -20+[ebp], ecx
	fild	DWORD PTR -20+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+344]

; 221  : 
; 222  : 	// set conveyor state
; 223  : 	m_iState = ( speed != 0 ) ? STATE_ON : STATE_OFF;

	fld	DWORD PTR _speed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39824
	mov	DWORD PTR -24+[ebp], 1
	jmp	SHORT $L39825
$L39824:
	mov	DWORD PTR -24+[ebp], 0
$L39825:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR -24+[ebp]
	mov	DWORD PTR [ecx+1788], edx

; 224  : 	pev->speed = speed;	// update physical speed too

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _speed$[ebp]
	mov	DWORD PTR [ecx+504], edx

; 225  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateSpeed@CFuncConveyor@@QAEXM@Z ENDP		; CFuncConveyor::UpdateSpeed
_TEXT	ENDS
PUBLIC	?Use@CFuncConveyor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncConveyor::Use
PUBLIC	__real@8@3ffbccccccccccccd000
PUBLIC	__real@4@3fff8000000000000000
;	COMDAT __real@8@3ffbccccccccccccd000
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
__real@8@3ffbccccccccccccd000 DQ 03fb999999999999ar ; 0.1
CONST	ENDS
;	COMDAT __real@4@3fff8000000000000000
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT ?Use@CFuncConveyor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_value$ = 20
_this$ = -4
?Use@CFuncConveyor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CFuncConveyor::Use, COMDAT

; 228  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 229  : 	if( IsLockedByMaster( pActivator ))

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z ; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L37270

; 230  : 		return;

	jmp	$L37269
$L37270:

; 231  : 
; 232  : 	if( ShouldToggle( useType ))

	mov	ecx, DWORD PTR _useType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z ; CBaseEntity::ShouldToggle
	test	eax, eax
	je	$L37271

; 234  : 		if( useType == USE_SET )

	cmp	DWORD PTR _useType$[ebp], 2
	jne	$L37272

; 236  : 			if( value != 0 ) 

	fld	DWORD PTR _value$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L37273

; 238  : 				pev->impulse = value < 0 ? true : false;

	fld	DWORD PTR _value$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39833
	mov	BYTE PTR -8+[ebp], 1
	jmp	SHORT $L39834
$L39833:
	mov	BYTE PTR -8+[ebp], 0
$L39834:
	mov	edx, DWORD PTR -8+[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+388], edx

; 239  : 				value = fabs( value );

	fld	DWORD PTR _value$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fst	DWORD PTR _value$[ebp]

; 240  : 				pev->dmg = bound( 0.1, value, 1 ) * m_flMaxSpeed;

	fcomp	QWORD PTR __real@8@3ffbccccccccccccd000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39837
	fld	DWORD PTR _value$[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39835
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR -12+[ebp], edx
	jmp	SHORT $L39836
$L39835:
	mov	DWORD PTR -12+[ebp], 1065353216		; 3f800000H
$L39836:
	fld	DWORD PTR -12+[ebp]
	fstp	QWORD PTR -20+[ebp]
	jmp	SHORT $L39838
$L39837:
	mov	DWORD PTR -20+[ebp], -1717986918	; 9999999aH
	mov	DWORD PTR -20+[ebp+4], 1069128089	; 3fb99999H
$L39838:
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1792]
	fmul	QWORD PTR -20+[ebp]
	fst	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+480]

; 242  : 			else UpdateSpeed( 0 ); // stop

	jmp	SHORT $L37274
$L37273:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSpeed@CFuncConveyor@@QAEXM@Z	; CFuncConveyor::UpdateSpeed
$L37274:

; 243  : 			return;

	jmp	SHORT $L37269
$L37272:

; 245  : 		else if( useType == USE_RESET )

	cmp	DWORD PTR _useType$[ebp], 4
	jne	SHORT $L37276

; 247  : 			// restore last speed
; 248  : 			UpdateSpeed( pev->dmg );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+480]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSpeed@CFuncConveyor@@QAEXM@Z	; CFuncConveyor::UpdateSpeed

; 249  : 			return;

	jmp	SHORT $L37269
$L37276:

; 251  :   
; 252  : 		pev->impulse = !pev->impulse;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	edx, edx
	cmp	DWORD PTR [ecx+388], 0
	sete	dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+388], edx

; 253  : 		UpdateSpeed( m_flMaxSpeed );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1792]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSpeed@CFuncConveyor@@QAEXM@Z	; CFuncConveyor::UpdateSpeed
$L37271:
$L37269:

; 255  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CFuncConveyor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CFuncConveyor::Use
_TEXT	ENDS
;	COMDAT _$E45
_TEXT	SEGMENT
_$E45	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E44
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E45	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncTransporter@@@@QAE@PBD@Z ; CEntityFactory<CFuncTransporter>::CEntityFactory<CFuncTransporter>
PUBLIC	??_C@_0BB@INGH@func_transporter?$AA@		; `string'
_BSS	SEGMENT
	ALIGN	4

_func_transporter DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BB@INGH@func_transporter?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0BB@INGH@func_transporter?$AA@ DB 'func_transporter', 00H ; `string'
CONST	ENDS
;	COMDAT _$E44
_TEXT	SEGMENT
_$E44	PROC NEAR					; COMDAT

; 279  : LINK_ENTITY_TO_CLASS( func_transporter, CFuncTransporter );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BB@INGH@func_transporter?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_transporter
	call	??0?$CEntityFactory@VCFuncTransporter@@@@QAE@PBD@Z ; CEntityFactory<CFuncTransporter>::CEntityFactory<CFuncTransporter>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E44	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CFuncTransporter@@UAEPAUdatamap_s@@XZ ; CFuncTransporter::GetDataDescMap
;	COMDAT ?GetDataDescMap@CFuncTransporter@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CFuncTransporter@@UAEPAUdatamap_s@@XZ PROC NEAR ; CFuncTransporter::GetDataDescMap, COMDAT

; 281  : BEGIN_DATADESC( CFuncTransporter )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTransporter@@2Udatamap_s@@A ; CFuncTransporter::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CFuncTransporter@@UAEPAUdatamap_s@@XZ ENDP ; CFuncTransporter::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CFuncTransporter@@SAPAUdatamap_s@@XZ ; CFuncTransporter::GetBaseMap
;	COMDAT ?GetBaseMap@CFuncTransporter@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CFuncTransporter@@SAPAUdatamap_s@@XZ PROC NEAR ; CFuncTransporter::GetBaseMap, COMDAT

; 281  : BEGIN_DATADESC( CFuncTransporter )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CFuncTransporter@@SAPAUdatamap_s@@XZ ENDP	; CFuncTransporter::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT
_$E48	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E47
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E48	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z ; DataMapInit
;	COMDAT _$E47
_TEXT	SEGMENT
_$E47	PROC NEAR					; COMDAT

; 281  : BEGIN_DATADESC( CFuncTransporter )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CFuncTransporter_DataDescInit@@3PAUdatamap_s@@A, eax ; CFuncTransporter_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E47	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S50@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z PROC NEAR ; DataMapInit, COMDAT

; 281  : BEGIN_DATADESC( CFuncTransporter )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S50@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L37387
	mov	cl, BYTE PTR _?$S50@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S50@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0BB@LIDA@CFuncTransporter?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E51
	call	_atexit
	add	esp, 4
$L37387:
	call	?GetBaseMap@CFuncTransporter@@SAPAUdatamap_s@@XZ ; CFuncTransporter::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CFuncTransporter@@2Udatamap_s@@A+12, eax

; 282  : 	DEFINE_FIELD( m_flMaxSpeed, FIELD_FLOAT ),
; 283  : 	DEFINE_FIELD( m_flWidth, FIELD_FLOAT ),
; 284  : END_DATADESC()

	mov	edx, 1
	test	edx, edx
	je	SHORT $L37396
	mov	DWORD PTR ?m_DataMap@CFuncTransporter@@2Udatamap_s@@A+4, 2
	mov	DWORD PTR ?m_DataMap@CFuncTransporter@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L37397
$L37396:
	mov	DWORD PTR ?m_DataMap@CFuncTransporter@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncTransporter@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z@4PAUtypedescription_s@@A
$L37397:
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTransporter@@2Udatamap_s@@A ; CFuncTransporter::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z ENDP ; DataMapInit
_TEXT	ENDS
;	COMDAT _$E51
_TEXT	SEGMENT
_$E51	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTransporter@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E51	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CFuncTransporter@@UAEXXZ			; CFuncTransporter::Spawn
PUBLIC	?UpdateSpeed@CFuncTransporter@@QAEXM@Z		; CFuncTransporter::UpdateSpeed
PUBLIC	??_C@_0CG@PBDJ@?$CFs?3?5unable?5to?5fetch?5model?5pointe@ ; `string'
PUBLIC	??_C@_0CG@IHDD@?$CFs?3?5unable?5to?5find?5scrolling?5tex@ ; `string'
PUBLIC	?GetDebugName@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetDebugName
PUBLIC	__real@8@00000000000000000000
EXTRN	?g_physfuncs@@3Userver_physics_api_s@@A:BYTE	; g_physfuncs
;	COMDAT ??_C@_0CG@PBDJ@?$CFs?3?5unable?5to?5fetch?5model?5pointe@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0CG@PBDJ@?$CFs?3?5unable?5to?5fetch?5model?5pointe@ DB '%s: unable '
	DB	'to fetch model pointer %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IHDD@?$CFs?3?5unable?5to?5find?5scrolling?5tex@
CONST	SEGMENT
??_C@_0CG@IHDD@?$CFs?3?5unable?5to?5find?5scrolling?5tex@ DB '%s: unable '
	DB	'to find scrolling texture', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@8@00000000000000000000
CONST	SEGMENT
__real@8@00000000000000000000 DQ 00000000000000000r ; 0
CONST	ENDS
;	COMDAT ?Spawn@CFuncTransporter@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_bmodel$ = -8
_i$37410 = -12
_face$37414 = -16
$T39861 = -28
?Spawn@CFuncTransporter@@UAEXXZ PROC NEAR		; CFuncTransporter::Spawn, COMDAT

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 	pev->flags |= FL_WORLDBRUSH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 289  : 	pev->movetype = MOVETYPE_PUSH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 7

; 290  : 	pev->solid = SOLID_BSP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 4

; 291  : 
; 292  : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 293  : 	SetBits( pev->effects, EF_CONVEYOR );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	dh, -128				; ffffff80H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx

; 294  : 
; 295  : 	// is mapper forgot set angles?
; 296  : 	if( pev->movedir == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L37403

; 297  : 		pev->movedir = Vector( 1, 0, 0 );

	push	0
	push	0
	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR $T39861[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L37403:

; 300  : 
; 301  : 	// get a world struct
; 302  : 	if(( bmodel = (model_t *)MODEL_HANDLE( pev->modelindex )) == NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _bmodel$[ebp], eax
	cmp	DWORD PTR _bmodel$[ebp], 0
	jne	SHORT $L37407

; 304  : 		ALERT( at_warning, "%s: unable to fetch model pointer %s\n", GetDebugName(), GetModel( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDebugName@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetDebugName
	push	eax
	push	OFFSET FLAT:??_C@_0CG@PBDJ@?$CFs?3?5unable?5to?5fetch?5model?5pointe@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 305  : 		m_flWidth = 64.0f;	// default

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1796], 1115684864	; 42800000H

; 307  : 	else

	jmp	$L37416
$L37407:

; 309  : 		// lookup for the scroll texture
; 310  : 		for( int i = 0; i < bmodel->nummodelsurfaces; i++ )

	mov	DWORD PTR _i$37410[ebp], 0
	jmp	SHORT $L37411
$L37412:
	mov	edx, DWORD PTR _i$37410[ebp]
	add	edx, 1
	mov	DWORD PTR _i$37410[ebp], edx
$L37411:
	mov	eax, DWORD PTR _bmodel$[ebp]
	mov	ecx, DWORD PTR _i$37410[ebp]
	cmp	ecx, DWORD PTR [eax+116]
	jge	SHORT $L37413

; 312  : 			msurface_t *face = &bmodel->surfaces[bmodel->firstmodelsurface + i];

	mov	edx, DWORD PTR _bmodel$[ebp]
	mov	eax, DWORD PTR [edx+112]
	add	eax, DWORD PTR _i$37410[ebp]
	imul	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR _bmodel$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	add	edx, eax
	mov	DWORD PTR _face$37414[ebp], edx

; 313  : 			if( FBitSet( face->flags, SURF_CONVEYOR ))

	mov	eax, DWORD PTR _face$37414[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 64					; 00000040H
	test	ecx, ecx
	je	SHORT $L37415

; 315  : 				m_flWidth = face->texinfo->texture->width;

	mov	edx, DWORD PTR _face$37414[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR -36+[ebp], edx
	mov	DWORD PTR -36+[ebp+4], 0
	fild	QWORD PTR -36+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1796]

; 316  : 				break;

	jmp	SHORT $L37413
$L37415:

; 318  : 		}

	jmp	SHORT $L37412
$L37413:

; 319  : 
; 320  : 		if( m_flWidth <= 0.0 )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1796]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L37416

; 322  : 			ALERT( at_warning, "%s: unable to find scrolling texture\n", GetDebugName() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDebugName@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetDebugName
	push	eax
	push	OFFSET FLAT:??_C@_0CG@IHDD@?$CFs?3?5unable?5to?5find?5scrolling?5tex@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 323  : 			m_flWidth = 64.0f;	// default

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1796], 1115684864	; 42800000H
$L37416:

; 326  : 
; 327  : 	if( FBitSet( pev->spawnflags, SF_TRANSPORTER_SOLID ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 2
	test	edx, edx
	je	SHORT $L37418

; 329  : 		if( m_hParent )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37419

; 330  : 			m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 331  : 		else m_pUserData = WorldPhysic->CreateStaticBodyFromEntity( this );

	jmp	SHORT $L37420
$L37419:
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax
$L37420:

; 332  : 		SetBits( pev->flags, FL_CONVEYOR );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx

; 334  : 	else

	jmp	SHORT $L37421
$L37418:

; 336  : 		pev->solid = SOLID_NOT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 0

; 337  : 		pev->skin = 0; // don't want the engine thinking we've got special contents on this brush

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+272], 0
$L37421:

; 339  : 
; 340  : 	if( pev->speed == 0 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37422

; 341  : 		pev->speed = 100;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+504], 1120403456		; 42c80000H
$L37422:

; 342  : 
; 343  : 	m_flMaxSpeed = pev->speed;	// save initial speed

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+504]
	mov	DWORD PTR [edx+1792], eax

; 344  : 
; 345  : 	if( FBitSet( pev->spawnflags, SF_TRANSPORTER_STARTON ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 1
	test	eax, eax
	je	SHORT $L37423

; 346  : 		UpdateSpeed( m_flMaxSpeed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1792]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSpeed@CFuncTransporter@@QAEXM@Z	; CFuncTransporter::UpdateSpeed

; 347  : 	else UpdateSpeed( 0 );

	jmp	SHORT $L37424
$L37423:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSpeed@CFuncTransporter@@QAEXM@Z	; CFuncTransporter::UpdateSpeed
$L37424:

; 348  : 	SetNextThink( 0 );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 349  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncTransporter@@UAEXXZ ENDP			; CFuncTransporter::Spawn
_TEXT	ENDS
PUBLIC	??_C@_04GOCP@null?$AA@				; `string'
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
PUBLIC	?GetTargetname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetTargetname
;	COMDAT ??_C@_04GOCP@null?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_04GOCP@null?$AA@ DB 'null', 00H			; `string'
CONST	ENDS
;	COMDAT ?GetDebugName@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetDebugName@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetDebugName, COMDAT

; 293  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 294  : 		if( this == NULL || pev == NULL )

	cmp	DWORD PTR _this$[ebp], 0
	je	SHORT $L34863
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L34862
$L34863:

; 295  : 			return "null";

	mov	eax, OFFSET FLAT:??_C@_04GOCP@null?$AA@	; `string'
	jmp	SHORT $L34861
$L34862:

; 296  : 
; 297  : 		if( pev->targetname != NULL_STRING ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+460], 0
	je	SHORT $L34865

; 298  : 			return GetTargetname();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	jmp	SHORT $L34861
$L34865:

; 299  : 		return GetClassname();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
$L34861:

; 300  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDebugName@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetDebugName
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetTargetname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetTargetname, COMDAT

; 284  : 	const char*	GetTargetname() { return STRING( pev->targetname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTargetname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetTargetname
_TEXT	ENDS
;	COMDAT ?UpdateSpeed@CFuncTransporter@@QAEXM@Z
_TEXT	SEGMENT
_speed$ = 8
_this$ = -4
?UpdateSpeed@CFuncTransporter@@QAEXM@Z PROC NEAR	; CFuncTransporter::UpdateSpeed, COMDAT

; 352  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 353  : 	// set conveyor state
; 354  : 	m_iState = ( speed != 0 ) ? STATE_ON : STATE_OFF;

	fld	DWORD PTR _speed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39872
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39873
$L39872:
	mov	DWORD PTR -8+[ebp], 0
$L39873:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	mov	DWORD PTR [eax+1788], ecx

; 355  : 	pev->speed = speed;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _speed$[ebp]
	mov	DWORD PTR [eax+504], ecx

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateSpeed@CFuncTransporter@@QAEXM@Z ENDP		; CFuncTransporter::UpdateSpeed
_TEXT	ENDS
PUBLIC	?Use@CFuncTransporter@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncTransporter::Use
;	COMDAT ?Use@CFuncTransporter@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_value$ = 20
_this$ = -4
?Use@CFuncTransporter@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CFuncTransporter::Use, COMDAT

; 359  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 360  : 	if( IsLockedByMaster( pActivator ))

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z ; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L37436

; 361  : 		return;

	jmp	SHORT $L37435
$L37436:

; 362  : 
; 363  : 	if( ShouldToggle( useType ))

	mov	ecx, DWORD PTR _useType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z ; CBaseEntity::ShouldToggle
	test	eax, eax
	je	SHORT $L37441

; 365  : 		if( useType == USE_SET )

	cmp	DWORD PTR _useType$[ebp], 2
	jne	SHORT $L37438

; 367  : 			UpdateSpeed( value );

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSpeed@CFuncTransporter@@QAEXM@Z	; CFuncTransporter::UpdateSpeed

; 369  : 		else

	jmp	SHORT $L37441
$L37438:

; 371  : 			if( GetState() == STATE_ON )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	cmp	eax, 1
	jne	SHORT $L37440

; 372  : 				UpdateSpeed( 0 );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSpeed@CFuncTransporter@@QAEXM@Z	; CFuncTransporter::UpdateSpeed

; 373  : 			else UpdateSpeed( m_flMaxSpeed );

	jmp	SHORT $L37441
$L37440:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1792]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSpeed@CFuncTransporter@@QAEXM@Z	; CFuncTransporter::UpdateSpeed
$L37441:
$L37435:

; 376  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CFuncTransporter@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CFuncTransporter::Use
_TEXT	ENDS
PUBLIC	?Think@CFuncTransporter@@UAEXXZ			; CFuncTransporter::Think
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
;	COMDAT ?Think@CFuncTransporter@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Think@CFuncTransporter@@UAEXXZ PROC NEAR		; CFuncTransporter::Think, COMDAT

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 	if( pev->speed != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L37452

; 382  : 		pev->fuser1 += pev->speed * gpGlobals->frametime * (1.0f / m_flWidth); 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx+504]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR [edx+1796]
	fmulp	ST(1), ST(0)
	fadd	DWORD PTR [eax+596]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+596]
$L37448:

; 383  : 
; 384  : 		// don't exceed some limits to prevent precision loosing
; 385  : 		while( pev->fuser1 > m_flWidth )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+596]
	fcomp	DWORD PTR [ecx+1796]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37449

; 386  : 			pev->fuser1 -= m_flWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+596]
	fsub	DWORD PTR [ecx+1796]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+596]
	jmp	SHORT $L37448
$L37449:

; 387  : 		while( pev->fuser1 < -m_flWidth )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1796]
	fchs
	fcomp	DWORD PTR [edx+596]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37452

; 388  : 			pev->fuser1 += m_flWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+596]
	fadd	DWORD PTR [eax+1796]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+596]
	jmp	SHORT $L37449
$L37452:

; 390  : 
; 391  : 	// think every frame
; 392  : 	SetNextThink( gpGlobals->frametime );

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]

; 393  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CFuncTransporter@@UAEXXZ ENDP			; CFuncTransporter::Think
_TEXT	ENDS
;	COMDAT _$E53
_TEXT	SEGMENT
_$E53	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E52
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E53	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncIllusionary@@@@QAE@PBD@Z ; CEntityFactory<CFuncIllusionary>::CEntityFactory<CFuncIllusionary>
PUBLIC	??_C@_0BB@ECKI@func_illusionary?$AA@		; `string'
_BSS	SEGMENT
	ALIGN	4

_func_illusionary DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BB@ECKI@func_illusionary?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0BB@ECKI@func_illusionary?$AA@ DB 'func_illusionary', 00H ; `string'
CONST	ENDS
;	COMDAT _$E52
_TEXT	SEGMENT
_$E52	PROC NEAR					; COMDAT

; 405  : LINK_ENTITY_TO_CLASS( func_illusionary, CFuncIllusionary );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BB@ECKI@func_illusionary?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_illusionary
	call	??0?$CEntityFactory@VCFuncIllusionary@@@@QAE@PBD@Z ; CEntityFactory<CFuncIllusionary>::CEntityFactory<CFuncIllusionary>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E52	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CFuncIllusionary@@UAEXXZ			; CFuncIllusionary::Spawn
;	COMDAT ?Spawn@CFuncIllusionary@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CFuncIllusionary@@UAEXXZ PROC NEAR		; CFuncIllusionary::Spawn, COMDAT

; 408  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	pev->movetype = MOVETYPE_NONE;  

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 0

; 410  : 	pev->solid = SOLID_NOT; // always solid_not 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 0

; 411  : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 412  : 	
; 413  : 	// I'd rather eat the network bandwidth of this than figure out how to save/restore
; 414  : 	// these entities after they have been moved to the client, or respawn them ala Quake
; 415  : 	// Perhaps we can do this in deathmatch only.
; 416  : 	// MAKE_STATIC( edict() );
; 417  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncIllusionary@@UAEXXZ ENDP			; CFuncIllusionary::Spawn
_TEXT	ENDS
;	COMDAT _$E56
_TEXT	SEGMENT
_$E56	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E55
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E56	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncMonsterClip@@@@QAE@PBD@Z ; CEntityFactory<CFuncMonsterClip>::CEntityFactory<CFuncMonsterClip>
PUBLIC	??_C@_0BB@FHFO@func_monsterclip?$AA@		; `string'
_BSS	SEGMENT
_func_monsterclip DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BB@FHFO@func_monsterclip?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0BB@FHFO@func_monsterclip?$AA@ DB 'func_monsterclip', 00H ; `string'
CONST	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT
_$E55	PROC NEAR					; COMDAT

; 429  : LINK_ENTITY_TO_CLASS( func_monsterclip, CFuncMonsterClip );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BB@FHFO@func_monsterclip?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_monsterclip
	call	??0?$CEntityFactory@VCFuncMonsterClip@@@@QAE@PBD@Z ; CEntityFactory<CFuncMonsterClip>::CEntityFactory<CFuncMonsterClip>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E55	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CFuncMonsterClip@@UAEXXZ			; CFuncMonsterClip::Spawn
;	COMDAT ?Spawn@CFuncMonsterClip@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CFuncMonsterClip@@UAEXXZ PROC NEAR		; CFuncMonsterClip::Spawn, COMDAT

; 432  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 433  : 	pev->solid = SOLID_BSP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 4

; 434  : 	pev->movetype = MOVETYPE_PUSH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 7

; 435  : 	SetBits( pev->flags, FL_MONSTERCLIP );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	or	eax, 8388608				; 00800000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+420], eax

; 436  : 	SetBits( m_iFlags, MF_TRIGGER );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 437  : 	pev->effects |= EF_NODRAW;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx

; 438  : 
; 439  : 	// link into world
; 440  : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 441  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncMonsterClip@@UAEXXZ ENDP			; CFuncMonsterClip::Spawn
_TEXT	ENDS
;	COMDAT _$E60
_TEXT	SEGMENT
_$E60	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E59
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E60	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncRotating@@@@QAE@PBD@Z	; CEntityFactory<CFuncRotating>::CEntityFactory<CFuncRotating>
PUBLIC	??_C@_0O@HHKP@func_rotating?$AA@		; `string'
_BSS	SEGMENT
_func_rotating DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@HHKP@func_rotating?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0O@HHKP@func_rotating?$AA@ DB 'func_rotating', 00H ; `string'
CONST	ENDS
;	COMDAT _$E59
_TEXT	SEGMENT
_$E59	PROC NEAR					; COMDAT

; 492  : LINK_ENTITY_TO_CLASS( func_rotating, CFuncRotating );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0O@HHKP@func_rotating?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_rotating
	call	??0?$CEntityFactory@VCFuncRotating@@@@QAE@PBD@Z ; CEntityFactory<CFuncRotating>::CEntityFactory<CFuncRotating>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E59	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CFuncRotating@@UAEPAUdatamap_s@@XZ ; CFuncRotating::GetDataDescMap
;	COMDAT ?GetDataDescMap@CFuncRotating@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CFuncRotating@@UAEPAUdatamap_s@@XZ PROC NEAR ; CFuncRotating::GetDataDescMap, COMDAT

; 494  : BEGIN_DATADESC( CFuncRotating )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncRotating@@2Udatamap_s@@A ; CFuncRotating::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CFuncRotating@@UAEPAUdatamap_s@@XZ ENDP	; CFuncRotating::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CFuncRotating@@SAPAUdatamap_s@@XZ	; CFuncRotating::GetBaseMap
;	COMDAT ?GetBaseMap@CFuncRotating@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CFuncRotating@@SAPAUdatamap_s@@XZ PROC NEAR	; CFuncRotating::GetBaseMap, COMDAT

; 494  : BEGIN_DATADESC( CFuncRotating )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CFuncRotating@@SAPAUdatamap_s@@XZ ENDP	; CFuncRotating::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E63
_TEXT	SEGMENT
_$E63	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E62
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E63	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z ; DataMapInit
;	COMDAT _$E62
_TEXT	SEGMENT
_$E62	PROC NEAR					; COMDAT

; 494  : BEGIN_DATADESC( CFuncRotating )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CFuncRotating_DataDescInit@@3PAUdatamap_s@@A, eax ; CFuncRotating_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E62	ENDP
_TEXT	ENDS
PUBLIC	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
PUBLIC	?SpinUp@CFuncRotating@@QAEXXZ			; CFuncRotating::SpinUp
PUBLIC	?SpinDown@CFuncRotating@@QAEXXZ			; CFuncRotating::SpinDown
PUBLIC	?ReverseMove@CFuncRotating@@QAEXXZ		; CFuncRotating::ReverseMove
PUBLIC	?RotateFriction@CFuncRotating@@QAEXXZ		; CFuncRotating::RotateFriction
PUBLIC	?HurtTouch@CFuncRotating@@QAEXPAVCBaseEntity@@@Z ; CFuncRotating::HurtTouch
PUBLIC	?Rotate@CFuncRotating@@QAEXXZ			; CFuncRotating::Rotate
PUBLIC	??_C@_06BLKE@SpinUp?$AA@			; `string'
PUBLIC	??_C@_08OHJJ@SpinDown?$AA@			; `string'
PUBLIC	??_C@_09MJNG@HurtTouch?$AA@			; `string'
PUBLIC	??_C@_0P@MKBN@RotateFriction?$AA@		; `string'
PUBLIC	??_C@_0M@BGDO@ReverseMove?$AA@			; `string'
PUBLIC	??_C@_06GGLN@Rotate?$AA@			; `string'
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_06BLKE@SpinUp?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_06BLKE@SpinUp?$AA@ DB 'SpinUp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OHJJ@SpinDown?$AA@
CONST	SEGMENT
??_C@_08OHJJ@SpinDown?$AA@ DB 'SpinDown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MJNG@HurtTouch?$AA@
CONST	SEGMENT
??_C@_09MJNG@HurtTouch?$AA@ DB 'HurtTouch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MKBN@RotateFriction?$AA@
CONST	SEGMENT
??_C@_0P@MKBN@RotateFriction?$AA@ DB 'RotateFriction', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BGDO@ReverseMove?$AA@
CONST	SEGMENT
??_C@_0M@BGDO@ReverseMove?$AA@ DB 'ReverseMove', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GGLN@Rotate?$AA@
CONST	SEGMENT
??_C@_06GGLN@Rotate?$AA@ DB 'Rotate', 00H		; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z PROC NEAR ; DataMapInit, COMDAT

; 494  : BEGIN_DATADESC( CFuncRotating )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L37705
	mov	cl, BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0O@OFPB@CFuncRotating?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E66
	call	_atexit
	add	esp, 4
$L37705:
	call	?GetBaseMap@CFuncRotating@@SAPAUdatamap_s@@XZ ; CFuncRotating::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CFuncRotating@@2Udatamap_s@@A+12, eax

; 495  : 	DEFINE_FIELD( m_bStopAtStartPos, FIELD_FLOAT ),
; 496  : 	DEFINE_FIELD( m_flFanFriction, FIELD_FLOAT ),
; 497  : 	DEFINE_FIELD( m_flAttenuation, FIELD_FLOAT ),
; 498  : 	DEFINE_FIELD( m_flTargetSpeed, FIELD_FLOAT ),
; 499  : 	DEFINE_FIELD( m_flMaxSpeed, FIELD_FLOAT ),
; 500  : 	DEFINE_FIELD( m_angStart, FIELD_VECTOR ),
; 501  : 	DEFINE_FIELD( m_flVolume, FIELD_FLOAT ),
; 502  : 	DEFINE_KEYFIELD( m_sounds, FIELD_STRING, "sounds" ),
; 503  : 	DEFINE_FUNCTION( SpinUp ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L37733
	mov	al, BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S65@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_06BLKE@SpinUp?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+220, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+224, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+228, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+230, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+232, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+236, OFFSET FLAT:?SpinUp@CFuncRotating@@QAEXXZ ; CFuncRotating::SpinUp

; 504  : 	DEFINE_FUNCTION( SpinDown ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+240, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_08OHJJ@SpinDown?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+244, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+248, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+252, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+254, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+256, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+260, OFFSET FLAT:?SpinDown@CFuncRotating@@QAEXXZ ; CFuncRotating::SpinDown

; 505  : 	DEFINE_FUNCTION( HurtTouch ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+264, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_09MJNG@HurtTouch?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+268, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+272, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+276, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+278, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+280, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+284, OFFSET FLAT:?HurtTouch@CFuncRotating@@QAEXPAVCBaseEntity@@@Z ; CFuncRotating::HurtTouch

; 506  : 	DEFINE_FUNCTION( RotateFriction ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+288, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0P@MKBN@RotateFriction?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+292, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+296, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+300, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+302, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+304, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+308, OFFSET FLAT:?RotateFriction@CFuncRotating@@QAEXXZ ; CFuncRotating::RotateFriction

; 507  : 	DEFINE_FUNCTION( ReverseMove ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+312, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0M@BGDO@ReverseMove?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+316, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+320, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+324, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+326, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+328, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+332, OFFSET FLAT:?ReverseMove@CFuncRotating@@QAEXXZ ; CFuncRotating::ReverseMove

; 508  : 	DEFINE_FUNCTION( Rotate ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+336, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_06GGLN@Rotate?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+340, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+344, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+348, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+350, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+352, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+356, OFFSET FLAT:?Rotate@CFuncRotating@@QAEXXZ ; CFuncRotating::Rotate
$L37733:

; 509  : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L37752
	mov	DWORD PTR ?m_DataMap@CFuncRotating@@2Udatamap_s@@A+4, 14 ; 0000000eH
	mov	DWORD PTR ?m_DataMap@CFuncRotating@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L37753
$L37752:
	mov	DWORD PTR ?m_DataMap@CFuncRotating@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncRotating@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4PAUtypedescription_s@@A
$L37753:
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncRotating@@2Udatamap_s@@A ; CFuncRotating::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z ENDP	; DataMapInit
_TEXT	ENDS
PUBLIC	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
PUBLIC	??_C@_04NHIK@?$CFs?3?3?$AA@			; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_strcat:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
; File z:\xashxtsrc\common\datamap.h
CONST	SEGMENT
??_C@_04NHIK@?$CFs?3?3?$AA@ DB '%s::', 00H		; `string'
CONST	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT
_pszIdentifier$ = 8
_this$ = -4
_pBuf$ = -8
$T39906 = -12
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z PROC NEAR ; CDatadescGeneratedNameHolder::GenerateName, COMDAT

; 205  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		char *pBuf = new char[m_nLenBase + strlen(pszIdentifier) + 1];

	mov	eax, DWORD PTR _pszIdentifier$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax+1]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T39906[ebp], eax
	mov	ecx, DWORD PTR $T39906[ebp]
	mov	DWORD PTR _pBuf$[ebp], ecx

; 207  : 		sprintf( pBuf, "%s::", m_pszBase );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_04NHIK@?$CFs?3?3?$AA@	; `string'
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 208  : 		strcat( pBuf, pszIdentifier );

	mov	edx, DWORD PTR _pszIdentifier$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 209  : 		m_Names.AddToTail( pBuf );

	lea	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail

; 210  : 		return pBuf;

	mov	eax, DWORD PTR _pBuf$[ebp]

; 211  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ENDP ; CDatadescGeneratedNameHolder::GenerateName
_TEXT	ENDS
;	COMDAT _$E66
_TEXT	SEGMENT
_$E66	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncRotating@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E66	ENDP
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
PUBLIC	?KeyValue@CFuncRotating@@UAEXPAUKeyValueData_s@@@Z ; CFuncRotating::KeyValue
PUBLIC	??_C@_0M@PGKA@fanfriction?$AA@			; `string'
PUBLIC	??_C@_0M@MGPD@spawnorigin?$AA@			; `string'
PUBLIC	??_C@_06FLOP@volume?$AA@			; `string'
PUBLIC	__real@4@4005c800000000000000
PUBLIC	__real@4@4002a000000000000000
EXTRN	?Q_atof@@YAMPBD@Z:NEAR				; Q_atof
EXTRN	?Q_atov@@YA?AVVector@@PBD@Z:NEAR		; Q_atov
EXTRN	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseDelay::KeyValue
EXTRN	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsOrigin
;	COMDAT ??_C@_0M@PGKA@fanfriction?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0M@PGKA@fanfriction?$AA@ DB 'fanfriction', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MGPD@spawnorigin?$AA@
CONST	SEGMENT
??_C@_0M@MGPD@spawnorigin?$AA@ DB 'spawnorigin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FLOP@volume?$AA@
CONST	SEGMENT
??_C@_06FLOP@volume?$AA@ DB 'volume', 00H		; `string'
CONST	ENDS
;	COMDAT __real@4@4005c800000000000000
CONST	SEGMENT
__real@4@4005c800000000000000 DD 042c80000r	; 100
CONST	ENDS
;	COMDAT __real@4@4002a000000000000000
CONST	SEGMENT
__real@4@4002a000000000000000 DD 041200000r	; 10
CONST	ENDS
;	COMDAT ?KeyValue@CFuncRotating@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
_tmp$37764 = -16
$T39911 = -28
?KeyValue@CFuncRotating@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CFuncRotating::KeyValue, COMDAT

; 512  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 513  : 	if( FStrEq( pkvd->szKeyName, "fanfriction" ))

	push	OFFSET FLAT:??_C@_0M@PGKA@fanfriction?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37759

; 515  : 		m_flFanFriction = Q_atof( pkvd->szValue ) / 100.0f;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	fdiv	DWORD PTR __real@4@4005c800000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1796]

; 516  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 518  : 	else if( FStrEq( pkvd->szKeyName, "spawnorigin" ))

	jmp	$L37772
$L37759:
	push	OFFSET FLAT:??_C@_0M@MGPD@spawnorigin?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37762

; 520  : 		Vector tmp = Q_atov( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	lea	ecx, DWORD PTR $T39911[ebp]
	push	ecx
	call	?Q_atov@@YA?AVVector@@PBD@Z		; Q_atov
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _tmp$37764[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 521  : 		if( tmp != g_vecZero ) SetAbsOrigin( tmp );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR _tmp$37764[ebp]
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L37766
	lea	edx, DWORD PTR _tmp$37764[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin
$L37766:

; 523  : 	else if( FStrEq( pkvd->szKeyName, "sounds" ))

	jmp	$L37772
$L37762:
	push	OFFSET FLAT:??_C@_06HADE@sounds?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37768

; 525  : 		m_sounds = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1828], eax

; 526  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 528  : 	else if( FStrEq( pkvd->szKeyName, "volume" ))

	jmp	$L37772
$L37768:
	push	OFFSET FLAT:??_C@_06FLOP@volume?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	$L37770

; 530  : 		m_flVolume = bound( 0.0f, Q_atof( pkvd->szValue ) / 10.0f, 1.0f );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	fdiv	DWORD PTR __real@4@4002a000000000000000
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39914
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	fdiv	DWORD PTR __real@4@4002a000000000000000
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39912
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	fdiv	DWORD PTR __real@4@4002a000000000000000
	fstp	DWORD PTR -32+[ebp]
	jmp	SHORT $L39913
$L39912:
	mov	DWORD PTR -32+[ebp], 1065353216		; 3f800000H
$L39913:
	mov	edx, DWORD PTR -32+[ebp]
	mov	DWORD PTR -36+[ebp], edx
	jmp	SHORT $L39915
$L39914:
	mov	DWORD PTR -36+[ebp], 0
$L39915:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax+1812], ecx

; 531  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 533  : 	else

	jmp	SHORT $L37772
$L37770:

; 535  : 		CBaseDelay::KeyValue( pkvd );

	mov	eax, DWORD PTR _pkvd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z ; CBaseDelay::KeyValue
$L37772:

; 537  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CFuncRotating@@UAEXPAUKeyValueData_s@@@Z ENDP	; CFuncRotating::KeyValue
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	?Spawn@CFuncRotating@@UAEXXZ			; CFuncRotating::Spawn
PUBLIC	?SUB_CallUseToggle@CBaseEntity@@QAEXXZ		; CBaseEntity::SUB_CallUseToggle
PUBLIC	??_C@_0BC@FMAO@SUB_CallUseToggle?$AA@		; `string'
PUBLIC	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
PUBLIC	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet
EXTRN	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalOrigin
EXTRN	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAngles
EXTRN	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z:NEAR ; UTIL_SetOrigin
;	COMDAT ??_C@_0BC@FMAO@SUB_CallUseToggle?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0BC@FMAO@SUB_CallUseToggle?$AA@ DB 'SUB_CallUseToggle', 00H ; `string'
CONST	ENDS
;	COMDAT ?Spawn@CFuncRotating@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
$T39926 = -16
$T39927 = -28
$T39928 = -40
$T39929 = -52
?Spawn@CFuncRotating@@UAEXXZ PROC NEAR			; CFuncRotating::Spawn, COMDAT

; 540  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 541  : 	// maintain compatibility with previous maps
; 542  : 	if( m_flVolume == 0.0 ) m_flVolume = 1.0;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1812]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37777
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1812], 1065353216	; 3f800000H
$L37777:

; 543  : 
; 544  : 	// if the designer didn't set a sound attenuation, default to one.
; 545  : 	m_flAttenuation = ATTN_NORM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1800], 1061997773	; 3f4ccccdH

; 546  : 	
; 547  : 	if( FBitSet( pev->spawnflags, SF_ROTATING_SND_SMALL_RADIUS ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 128				; 00000080H
	test	edx, edx
	je	SHORT $L37779

; 549  : 		m_flAttenuation = ATTN_IDLE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1800], 1073741824	; 40000000H

; 551  : 	else if( FBitSet( pev->spawnflags, SF_ROTATING_SND_MEDIUM_RADIUS ))

	jmp	SHORT $L37785
$L37779:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $L37782

; 553  : 		m_flAttenuation = ATTN_STATIC;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1800], 1067450368	; 3fa00000H

; 555  : 	else if( FBitSet( pev->spawnflags, SF_ROTATING_SND_LARGE_RADIUS ))

	jmp	SHORT $L37785
$L37782:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 512				; 00000200H
	test	ecx, ecx
	je	SHORT $L37785

; 557  : 		m_flAttenuation = ATTN_NORM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1800], 1061997773	; 3f4ccccdH
$L37785:

; 559  : 
; 560  : 	// prevent divide by zero if level designer forgets friction!
; 561  : 	if( m_flFanFriction == 0 ) m_flFanFriction = 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1796]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37787
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1796], 1065353216	; 3f800000H
$L37787:

; 562  : 
; 563  : 	if( FBitSet( pev->spawnflags, SF_ROTATING_Z_AXIS ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 4
	test	ecx, ecx
	je	SHORT $L37788

; 565  : 		pev->movedir = Vector( 0, 0, 1 );

	push	1065353216				; 3f800000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T39926[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 567  : 	else if( FBitSet( pev->spawnflags, SF_ROTATING_X_AXIS ))

	jmp	SHORT $L37793
$L37788:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 8
	test	eax, eax
	je	SHORT $L37791

; 569  : 		pev->movedir = Vector( 1, 0, 0 );

	push	0
	push	0
	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR $T39927[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 571  : 	else

	jmp	SHORT $L37793
$L37791:

; 573  : 		pev->movedir = Vector( 0, 1, 0 ); // y-axis

	push	0
	push	1065353216				; 3f800000H
	push	0
	lea	ecx, DWORD PTR $T39928[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L37793:

; 575  : 
; 576  : 	// check for reverse rotation
; 577  : 	if( FBitSet( pev->spawnflags, SF_ROTATING_BACKWARDS ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 2
	test	eax, eax
	je	SHORT $L37795

; 579  : 		pev->movedir = pev->movedir * -1;

	push	-1082130432				; bf800000H
	lea	ecx, DWORD PTR $T39929[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L37795:

; 581  : 
; 582  : 	// some rotating objects like fake volumetric lights will not be solid.
; 583  : 	if( FBitSet( pev->spawnflags, SF_ROTATING_NOT_SOLID ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $L37797

; 585  : 		pev->solid = SOLID_NOT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 0

; 586  : 		pev->skin = CONTENTS_EMPTY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+272], -1

; 587  : 		pev->movetype = MOVETYPE_PUSH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 7

; 589  : 	else

	jmp	SHORT $L37798
$L37797:

; 591  : 		pev->solid = SOLID_BSP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 4

; 592  : 		pev->movetype = MOVETYPE_PUSH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 7
$L37798:

; 594  : 
; 595  : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 596  : 
; 597  : 	// did level designer forget to assign speed?
; 598  : 	m_flMaxSpeed = fabs( pev->speed );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1808]

; 599  : 	if( m_flMaxSpeed == 0 ) m_flMaxSpeed = 100;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1808]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37799
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1808], 1120403456	; 42c80000H
$L37799:

; 600  : 
; 601  : 	SetLocalAngles( m_vecTempAngles );	// all the child entities is set. Time to move hierarchy

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 602  : 	UTIL_SetOrigin( this, GetLocalOrigin( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 603  : 
; 604  : 	pev->speed = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+504], 0

; 605  : 	m_angStart = GetLocalAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1816				; 00000718H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 606  : 	m_iState = STATE_OFF;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 0

; 607  : 
; 608  : 	m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 609  : 
; 610  : 	// instant-use brush?
; 611  : 	if( FBitSet( pev->spawnflags, SF_ROTATING_INSTANT ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L37800

; 613  : 		SetThink( SUB_CallUseToggle );

	push	OFFSET FLAT:??_C@_0BC@FMAO@SUB_CallUseToggle?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_CallUseToggle@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_CallUseToggle
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 614  : 		SetNextThink( 0.2 ); // leave a magic delay for client to start up

	push	1045220557				; 3e4ccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]
$L37800:

; 616  : 
; 617  : 	// can this brush inflict pain?
; 618  : 	if( FBitSet( pev->spawnflags, SF_ROTATING_HURT ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $L37804

; 620  : 		SetTouch( HurtTouch );

	push	OFFSET FLAT:??_C@_09MJNG@HurtTouch?$AA@	; `string'
	push	OFFSET FLAT:?HurtTouch@CFuncRotating@@QAEXPAVCBaseEntity@@@Z ; CFuncRotating::HurtTouch
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet
$L37804:

; 622  : 	
; 623  : 	Precache( );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 624  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncRotating@@UAEXXZ ENDP			; CFuncRotating::Spawn
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T39932 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39932[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
;	COMDAT ?SUB_CallUseToggle@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SUB_CallUseToggle@CBaseEntity@@QAEXXZ PROC NEAR	; CBaseEntity::SUB_CallUseToggle, COMDAT

; 507  : 	void SUB_CallUseToggle( void ) { this->Use( this, this, USE_TOGGLE, 0 ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+276]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SUB_CallUseToggle@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::SUB_CallUseToggle
_TEXT	ENDS
PUBLIC	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z	; CBaseEntity::FunctionCheck
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::ThinkSet, COMDAT

; 560  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 		m_pfnThink = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1744], ecx

; 562  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnThink)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1744]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 563  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 564  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP	; CBaseEntity::ThinkSet
_TEXT	ENDS
PUBLIC	??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:NEAR ; UTIL_FunctionToName
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ DB 'F'
	DB	'UNCTION NOT IN TABLE!: %s:%s (%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT
_this$ = -4
_pFunction$ = 8
_name$ = 12
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z PROC NEAR	; CBaseEntity::FunctionCheck, COMDAT

; 554  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 		if (pFunction && !UTIL_FunctionToName( GetDataDescMap(), pFunction ) )

	cmp	DWORD PTR _pFunction$[ebp], 0
	je	SHORT $L35044
	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	test	eax, eax
	jne	SHORT $L35044

; 556  : 			ALERT( at_warning, "FUNCTION NOT IN TABLE!: %s:%s (%08lx)\n", GetClassname(), name, (unsigned long)pFunction );

	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L35044:

; 557  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ENDP		; CBaseEntity::FunctionCheck
_TEXT	ENDS
;	COMDAT ?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z PROC NEAR ; CBaseEntity::TouchSet, COMDAT

; 567  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 568  : 		m_pfnTouch = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1748], ecx

; 569  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnTouch)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1748]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 570  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 571  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ENDP ; CBaseEntity::TouchSet
_TEXT	ENDS
PUBLIC	__real@4@3ffbcccccd0000000000
PUBLIC	?GetNextMoveInterval@CFuncRotating@@QBEMXZ	; CFuncRotating::GetNextMoveInterval
;	COMDAT __real@4@3ffbcccccd0000000000
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
__real@4@3ffbcccccd0000000000 DD 03dcccccdr	; 0.1
CONST	ENDS
;	COMDAT ?GetNextMoveInterval@CFuncRotating@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetNextMoveInterval@CFuncRotating@@QBEMXZ PROC NEAR	; CFuncRotating::GetNextMoveInterval, COMDAT

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 	if( m_bStopAtStartPos )

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1792]
	test	ecx, ecx
	je	SHORT $L37811

; 630  : 		return gpGlobals->frametime;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx+4]
	jmp	SHORT $L37810
$L37811:

; 632  : 	return 0.1f;

	fld	DWORD PTR __real@4@3ffbcccccd0000000000
$L37810:

; 633  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextMoveInterval@CFuncRotating@@QBEMXZ ENDP		; CFuncRotating::GetNextMoveInterval
_TEXT	ENDS
PUBLIC	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z		; CBaseEntity::SetMoveDoneTime
PUBLIC	?Precache@CFuncRotating@@UAEXXZ			; CFuncRotating::Precache
PUBLIC	?FStringNull@@YAHH@Z				; FStringNull
PUBLIC	??_C@_0O@BABK@fans?1fan1?4wav?$AA@		; `string'
PUBLIC	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet
PUBLIC	??_C@_0O@PAHF@fans?1fan2?4wav?$AA@		; `string'
PUBLIC	??_C@_0O@FAFA@fans?1fan3?4wav?$AA@		; `string'
PUBLIC	??_C@_0O@DAKK@fans?1fan4?4wav?$AA@		; `string'
PUBLIC	??_C@_0O@JAIP@fans?1fan5?4wav?$AA@		; `string'
PUBLIC	??_C@_0BA@LNFJ@common?1null?4wav?$AA@		; `string'
EXTRN	?UTIL_PrecacheSound@@YAHPBD@Z:NEAR		; UTIL_PrecacheSound
EXTRN	?UTIL_PrecacheSound@@YAHH@Z:NEAR		; UTIL_PrecacheSound
EXTRN	?UTIL_LoadSoundPreset@@YAHH@Z:NEAR		; UTIL_LoadSoundPreset
EXTRN	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAvelocity
;	COMDAT ??_C@_0O@BABK@fans?1fan1?4wav?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0O@BABK@fans?1fan1?4wav?$AA@ DB 'fans/fan1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PAHF@fans?1fan2?4wav?$AA@
CONST	SEGMENT
??_C@_0O@PAHF@fans?1fan2?4wav?$AA@ DB 'fans/fan2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FAFA@fans?1fan3?4wav?$AA@
CONST	SEGMENT
??_C@_0O@FAFA@fans?1fan3?4wav?$AA@ DB 'fans/fan3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DAKK@fans?1fan4?4wav?$AA@
CONST	SEGMENT
??_C@_0O@DAKK@fans?1fan4?4wav?$AA@ DB 'fans/fan4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JAIP@fans?1fan5?4wav?$AA@
CONST	SEGMENT
??_C@_0O@JAIP@fans?1fan5?4wav?$AA@ DB 'fans/fan5.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LNFJ@common?1null?4wav?$AA@
CONST	SEGMENT
??_C@_0BA@LNFJ@common?1null?4wav?$AA@ DB 'common/null.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?Precache@CFuncRotating@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_m_sound$37818 = -8
?Precache@CFuncRotating@@UAEXXZ PROC NEAR		; CFuncRotating::Precache, COMDAT

; 636  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 637  : 	// set up fan sounds
; 638  : 	if( !FStringNull( pev->message ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L37816

; 640  : 		// if a path is set for a wave, use it
; 641  : 		pev->noise3 = UTIL_PrecacheSound( STRING( pev->message ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+500], eax

; 643  : 	else

	jmp	$L37820
$L37816:

; 645  : 		int m_sound = UTIL_LoadSoundPreset( m_sounds );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1828]
	push	ecx
	call	?UTIL_LoadSoundPreset@@YAHH@Z		; UTIL_LoadSoundPreset
	add	esp, 4
	mov	DWORD PTR _m_sound$37818[ebp], eax

; 649  : 		{

	mov	edx, DWORD PTR _m_sound$37818[ebp]
	mov	DWORD PTR -12+[ebp], edx
	cmp	DWORD PTR -12+[ebp], 5
	ja	$L37835
	mov	eax, DWORD PTR -12+[ebp]
	jmp	DWORD PTR $L39947[eax*4]
$L37823:

; 650  : 		case 1:
; 651  : 			pev->noise3 = UTIL_PrecacheSound( "fans/fan1.wav" );

	push	OFFSET FLAT:??_C@_0O@BABK@fans?1fan1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+500], eax

; 652  : 			break;

	jmp	$L37820
$L37825:

; 653  : 		case 2:
; 654  : 			pev->noise3 = UTIL_PrecacheSound( "fans/fan2.wav" );

	push	OFFSET FLAT:??_C@_0O@PAHF@fans?1fan2?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+500], eax

; 655  : 			break;

	jmp	$L37820
$L37827:

; 656  : 		case 3:
; 657  : 			pev->noise3 = UTIL_PrecacheSound( "fans/fan3.wav" );

	push	OFFSET FLAT:??_C@_0O@FAFA@fans?1fan3?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+500], eax

; 658  : 			break;

	jmp	SHORT $L37820
$L37829:

; 659  : 		case 4:
; 660  : 			pev->noise3 = UTIL_PrecacheSound( "fans/fan4.wav" );

	push	OFFSET FLAT:??_C@_0O@DAKK@fans?1fan4?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+500], eax

; 661  : 			break;

	jmp	SHORT $L37820
$L37831:

; 662  : 		case 5:
; 663  : 			pev->noise3 = UTIL_PrecacheSound( "fans/fan5.wav" );

	push	OFFSET FLAT:??_C@_0O@JAIP@fans?1fan5?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+500], eax

; 664  : 			break;

	jmp	SHORT $L37820
$L37833:

; 665  : 		case 0:
; 666  : 			pev->noise3 = UTIL_PrecacheSound( "common/null.wav" );

	push	OFFSET FLAT:??_C@_0BA@LNFJ@common?1null?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+500], eax

; 667  : 			break;

	jmp	SHORT $L37820
$L37835:

; 668  : 		default:
; 669  : 			pev->noise3 = UTIL_PrecacheSound( m_sound );

	mov	eax, DWORD PTR _m_sound$37818[ebp]
	push	eax
	call	?UTIL_PrecacheSound@@YAHH@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+500], eax
$L37820:

; 673  : 	
; 674  : 	if( GetLocalAvelocity() != g_vecZero && !pev->friction )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L37836
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+288]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37836

; 676  : 		// if fan was spinning, and we went through transition or save/restore,
; 677  : 		// make sure we restart the sound. 1.5 sec delay is magic number. KDB
; 678  : 		SetMoveDone( SpinUp );

	push	OFFSET FLAT:??_C@_06BLKE@SpinUp?$AA@	; `string'
	push	OFFSET FLAT:?SpinUp@CFuncRotating@@QAEXXZ ; CFuncRotating::SpinUp
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 679  : 		SetMoveDoneTime( 0.2 );

	push	1045220557				; 3e4ccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime
$L37836:

; 681  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L39947:
	DD	$L37833
	DD	$L37823
	DD	$L37825
	DD	$L37827
	DD	$L37829
	DD	$L37831
?Precache@CFuncRotating@@UAEXXZ ENDP			; CFuncRotating::Precache
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT
_iString$ = 8
?FStringNull@@YAHH@Z PROC NEAR				; FStringNull, COMDAT

; 201  : inline BOOL FStringNull(int iString)			{ return iString == iStringNull; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _iString$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStringNull@@YAHH@Z ENDP				; FStringNull
_TEXT	ENDS
;	COMDAT ?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::MoveDoneSet, COMDAT

; 588  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 589  : 		m_pfnMoveDone = func;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1760], ecx

; 590  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnMoveDone)), name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1760]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 591  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 592  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP ; CBaseEntity::MoveDoneSet
_TEXT	ENDS
PUBLIC	?GetLocalTime@CBaseEntity@@QBEMXZ		; CBaseEntity::GetLocalTime
;	COMDAT ?SetMoveDoneTime@CBaseEntity@@QAEXM@Z
_TEXT	SEGMENT
_flDelay$ = 8
_this$ = -4
?SetMoveDoneTime@CBaseEntity@@QAEXM@Z PROC NEAR		; CBaseEntity::SetMoveDoneTime, COMDAT

; 798  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 799  : 	if( flDelay >= 0 )

	fld	DWORD PTR _flDelay$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L35183

; 800  : 		m_flMoveDoneTime = GetLocalTime() + flDelay;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetLocalTime
	fadd	DWORD PTR _flDelay$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+44]

; 801  : 	else m_flMoveDoneTime = -1;

	jmp	SHORT $L35184
$L35183:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], -1082130432		; bf800000H
$L35184:

; 802  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMoveDoneTime@CBaseEntity@@QAEXM@Z ENDP		; CBaseEntity::SetMoveDoneTime
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetLocalTime@CBaseEntity@@QBEMXZ PROC NEAR		; CBaseEntity::GetLocalTime, COMDAT

; 788  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 789  : 	return pev->ltime; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+256]

; 790  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLocalTime@CBaseEntity@@QBEMXZ ENDP			; CBaseEntity::GetLocalTime
_TEXT	ENDS
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
EXTRN	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsVelocity
;	COMDAT ?HurtTouch@CFuncRotating@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T39958 = -32
$T39959 = -44
$T39960 = -56
$T39961 = -68
_pOther$ = 8
_this$ = -4
_pevOther$ = -8
_vecNewVelocity$ = -20
?HurtTouch@CFuncRotating@@QAEXPAVCBaseEntity@@@Z PROC NEAR ; CFuncRotating::HurtTouch, COMDAT

; 687  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 688  : 	entvars_t	*pevOther = pOther->pev;

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pevOther$[ebp], ecx

; 689  : 
; 690  : 	// we can't hurt this thing, so we're not concerned with it
; 691  : 	if( !pOther->pev->takedamage ) return;

	mov	edx, DWORD PTR _pOther$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37844
	jmp	$L37842
$L37844:

; 692  : 
; 693  : 	// calculate damage based on rotation speed
; 694  : 	pev->dmg = GetLocalAvelocity().Length() / 10;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fdiv	DWORD PTR __real@4@4002a000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+480]

; 695  : 
; 696  : 	pOther->TakeDamage( pev, pev, pev->dmg, DMG_CRUSH );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+480]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+96]

; 697  : 
; 698  : 	Vector vecNewVelocity = (pOther->GetAbsOrigin() - Center()).Normalize();

	lea	eax, DWORD PTR $T39960[ebp]
	push	eax
	lea	ecx, DWORD PTR $T39958[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+304]
	push	eax
	lea	ecx, DWORD PTR $T39959[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	push	eax
	lea	ecx, DWORD PTR _vecNewVelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 699  : 	pOther->SetAbsVelocity( vecNewVelocity * pev->dmg );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+480]
	push	ecx
	lea	edx, DWORD PTR $T39961[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecNewVelocity$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L37842:

; 700  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HurtTouch@CFuncRotating@@QAEXPAVCBaseEntity@@@Z ENDP	; CFuncRotating::HurtTouch
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
$T39964 = -16
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39964[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
EXTRN	_sqrt:NEAR
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
$T39969 = -20
___$ReturnUdt$ = 8
_this$ = -4
_flLen$ = -8
?Normalize@Vector@@QBE?AV1@XZ PROC NEAR			; Vector::Normalize, COMDAT

; 232  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 234  : 
; 235  : 		if( flLen )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L24894

; 237  : 			flLen = 1.0f / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 238  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39969[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L24892
$L24894:

; 240  : 
; 241  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L24892:

; 242  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
PUBLIC	__real@4@40058c00000000000000
PUBLIC	__real@4@4003f000000000000000
PUBLIC	__real@4@4006ff00000000000000
PUBLIC	?RampPitchVol@CFuncRotating@@QAEXXZ		; CFuncRotating::RampPitchVol
EXTRN	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z:NEAR	; EMIT_SOUND_DYN
;	COMDAT __real@4@40058c00000000000000
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
__real@4@40058c00000000000000 DD 0428c0000r	; 70
CONST	ENDS
;	COMDAT __real@4@4003f000000000000000
CONST	SEGMENT
__real@4@4003f000000000000000 DD 041f00000r	; 30
CONST	ENDS
;	COMDAT __real@4@4006ff00000000000000
CONST	SEGMENT
__real@4@4006ff00000000000000 DD 0437f0000r	; 255
CONST	ENDS
;	COMDAT ?RampPitchVol@CFuncRotating@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_fpct$ = -8
_fvol$ = -12
_fpitch$ = -16
_pitch$ = -20
?RampPitchVol@CFuncRotating@@QAEXXZ PROC NEAR		; CFuncRotating::RampPitchVol, COMDAT

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 711  : 	// calc volume and pitch as % of maximum vol and pitch.
; 712  : 	float fpct = fabs( GetLocalAvelocity().Length() ) / m_flMaxSpeed;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [eax+1808]
	fstp	DWORD PTR _fpct$[ebp]

; 713  : 	float fvol = bound( 0.0f, m_flVolume * fpct, 1.0f ); // slowdown volume ramps down to 0

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fpct$[ebp]
	fmul	DWORD PTR [ecx+1812]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39974
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fpct$[ebp]
	fmul	DWORD PTR [edx+1812]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39972
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fpct$[ebp]
	fmul	DWORD PTR [eax+1812]
	fstp	DWORD PTR -24+[ebp]
	jmp	SHORT $L39973
$L39972:
	mov	DWORD PTR -24+[ebp], 1065353216		; 3f800000H
$L39973:
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR -28+[ebp], ecx
	jmp	SHORT $L39975
$L39974:
	mov	DWORD PTR -28+[ebp], 0
$L39975:
	mov	edx, DWORD PTR -28+[ebp]
	mov	DWORD PTR _fvol$[ebp], edx

; 714  : 
; 715  : 	float fpitch = FANPITCHMIN + ( FANPITCHMAX - FANPITCHMIN ) * fpct;	

	fld	DWORD PTR __real@4@40058c00000000000000
	fmul	DWORD PTR _fpct$[ebp]
	fadd	DWORD PTR __real@4@4003f000000000000000
	fst	DWORD PTR _fpitch$[ebp]

; 716  : 	
; 717  : 	int pitch = bound( 0, fpitch, 255 );

	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39978
	fld	DWORD PTR _fpitch$[ebp]
	fcomp	DWORD PTR __real@4@4006ff00000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39976
	mov	eax, DWORD PTR _fpitch$[ebp]
	mov	DWORD PTR -32+[ebp], eax
	jmp	SHORT $L39977
$L39976:
	mov	DWORD PTR -32+[ebp], 1132396544		; 437f0000H
$L39977:
	mov	ecx, DWORD PTR -32+[ebp]
	mov	DWORD PTR -36+[ebp], ecx
	jmp	SHORT $L39979
$L39978:
	mov	DWORD PTR -36+[ebp], 0
$L39979:
	fld	DWORD PTR -36+[ebp]
	call	__ftol
	mov	DWORD PTR _pitch$[ebp], eax

; 718  : 
; 719  : 	if( pitch == PITCH_NORM )

	cmp	DWORD PTR _pitch$[ebp], 100		; 00000064H
	jne	SHORT $L37860

; 721  : 		pitch = PITCH_NORM - 1;

	mov	DWORD PTR _pitch$[ebp], 99		; 00000063H
$L37860:

; 723  : 
; 724  : 	// change the fan's vol and pitch
; 725  : 	EMIT_SOUND_DYN( edict(), CHAN_STATIC, STRING( pev->noise3 ), fvol, m_flAttenuation, SND_CHANGE_PITCH|SND_CHANGE_VOL, pitch );

	mov	edx, DWORD PTR _pitch$[ebp]
	push	edx
	push	192					; 000000c0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1800]
	push	ecx
	mov	edx, DWORD PTR _fvol$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+500]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 726  : 
; 727  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RampPitchVol@CFuncRotating@@QAEXXZ ENDP		; CFuncRotating::RampPitchVol
_TEXT	ENDS
PUBLIC	__real@4@4006b400000000000000
PUBLIC	__real@4@4007b400000000000000
PUBLIC	__real@4@4003c800000000000000
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	__real@8@4005b400000000000000
PUBLIC	__real@4@4003a000000000000000
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z		; STOP_SOUND
PUBLIC	?anglemod@@YAMM@Z				; anglemod
PUBLIC	?UpdateSpeed@CFuncRotating@@QAEXM@Z		; CFuncRotating::UpdateSpeed
EXTRN	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAvelocity
;	COMDAT __real@4@4006b400000000000000
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
__real@4@4006b400000000000000 DD 043340000r	; 180
CONST	ENDS
;	COMDAT __real@4@4007b400000000000000
CONST	SEGMENT
__real@4@4007b400000000000000 DD 043b40000r	; 360
CONST	ENDS
;	COMDAT __real@4@4003c800000000000000
CONST	SEGMENT
__real@4@4003c800000000000000 DD 041c80000r	; 25
CONST	ENDS
;	COMDAT __real@8@3fff8000000000000000
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT __real@8@4005b400000000000000
CONST	SEGMENT
__real@8@4005b400000000000000 DQ 04056800000000000r ; 90
CONST	ENDS
;	COMDAT __real@4@4003a000000000000000
CONST	SEGMENT
__real@4@4003a000000000000000 DD 041a00000r	; 20
CONST	ENDS
;	COMDAT ?UpdateSpeed@CFuncRotating@@QAEXM@Z
_TEXT	SEGMENT
$T39994 = -32
_flNewSpeed$ = 8
_this$ = -4
_flOldSpeed$ = -8
_checkAxis$37867 = -12
_angDelta$37871 = -16
_minSpeed$37878 = -20
?UpdateSpeed@CFuncRotating@@QAEXM@Z PROC NEAR		; CFuncRotating::UpdateSpeed, COMDAT

; 730  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 	float flOldSpeed = pev->speed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+504]
	mov	DWORD PTR _flOldSpeed$[ebp], edx

; 732  : 	pev->speed = bound( -m_flMaxSpeed, flNewSpeed, m_flMaxSpeed );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1808]
	fchs
	fcomp	DWORD PTR _flNewSpeed$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39990
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1808]
	fcomp	DWORD PTR _flNewSpeed$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39988
	mov	edx, DWORD PTR _flNewSpeed$[ebp]
	mov	DWORD PTR -36+[ebp], edx
	jmp	SHORT $L39989
$L39988:
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1808]
	fstp	DWORD PTR -36+[ebp]
$L39989:
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR -40+[ebp], ecx
	jmp	SHORT $L39991
$L39990:
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1808]
	fchs
	fstp	DWORD PTR -40+[ebp]
$L39991:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [ecx+504], edx

; 733  : 
; 734  : 	if( m_bStopAtStartPos )

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1792]
	test	ecx, ecx
	je	$L37877

; 736  : 		int checkAxis = 2;

	mov	DWORD PTR _checkAxis$37867[ebp], 2

; 737  : 
; 738  : 		// see if we got close to the starting orientation
; 739  : 		if( pev->movedir[0] != 0 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L37868

; 741  : 			checkAxis = 0;

	mov	DWORD PTR _checkAxis$37867[ebp], 0

; 743  : 		else if( pev->movedir[1] != 0 )

	jmp	SHORT $L37870
$L37868:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 68					; 00000044H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L37870

; 745  : 			checkAxis = 1;

	mov	DWORD PTR _checkAxis$37867[ebp], 1
$L37870:

; 747  : 
; 748  : 		float angDelta = anglemod( GetLocalAngles()[checkAxis] - m_angStart[checkAxis] );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	ecx, eax
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1816				; 00000718H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _checkAxis$37867[ebp]
	mov	edx, DWORD PTR _checkAxis$37867[ebp]
	fld	DWORD PTR [esi+ecx*4]
	fsub	DWORD PTR [eax+edx*4]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?anglemod@@YAMM@Z			; anglemod
	add	esp, 4
	fstp	DWORD PTR _angDelta$37871[ebp]

; 749  : 
; 750  : 		if( angDelta > 180.0f )

	fld	DWORD PTR _angDelta$37871[ebp]
	fcomp	DWORD PTR __real@4@4006b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37872

; 751  : 			angDelta -= 360.0f;

	fld	DWORD PTR _angDelta$37871[ebp]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _angDelta$37871[ebp]
$L37872:

; 752  : 
; 753  : 		if( flNewSpeed < 100 )

	fld	DWORD PTR _flNewSpeed$[ebp]
	fcomp	DWORD PTR __real@4@4005c800000000000000
	fnstsw	ax
	test	ah, 1
	je	$L37877

; 755  : 			if( flNewSpeed <= 25 && fabs( angDelta ) < 1.0f )

	fld	DWORD PTR _flNewSpeed$[ebp]
	fcomp	DWORD PTR __real@4@4003c800000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L37874
	fld	DWORD PTR _angDelta$37871[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37874

; 757  : 				m_flTargetSpeed = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1804], 0

; 758  : 				m_bStopAtStartPos = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1792], 0

; 759  : 				pev->speed = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+504], 0

; 760  : 
; 761  : 				SetLocalAngles( m_angStart );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1816				; 00000718H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 763  : 			else if( fabs( angDelta ) > 90.0f )

	jmp	$L37877
$L37874:
	fld	DWORD PTR _angDelta$37871[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@4005b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37876

; 765  : 				// keep rotating at same speed for now
; 766  : 				pev->speed = flOldSpeed;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _flOldSpeed$[ebp]
	mov	DWORD PTR [eax+504], ecx

; 768  : 			else

	jmp	SHORT $L37877
$L37876:

; 770  : 				float minSpeed =  fabs( angDelta );

	fld	DWORD PTR _angDelta$37871[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _minSpeed$37878[ebp]

; 771  : 				if( minSpeed < 20 ) minSpeed = 20;

	fld	DWORD PTR _minSpeed$37878[ebp]
	fcomp	DWORD PTR __real@4@4003a000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37879
	mov	DWORD PTR _minSpeed$37878[ebp], 1101004800 ; 41a00000H
$L37879:

; 772  : 	
; 773  : 				pev->speed = flOldSpeed > 0.0f ? minSpeed : -minSpeed;

	fld	DWORD PTR _flOldSpeed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39992
	mov	edx, DWORD PTR _minSpeed$37878[ebp]
	mov	DWORD PTR -44+[ebp], edx
	jmp	SHORT $L39993
$L39992:
	fld	DWORD PTR _minSpeed$37878[ebp]
	fchs
	fstp	DWORD PTR -44+[ebp]
$L39993:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR -44+[ebp]
	mov	DWORD PTR [ecx+504], edx
$L37877:

; 777  : 
; 778  : 	SetLocalAvelocity( pev->movedir * pev->speed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+504]
	push	edx
	lea	eax, DWORD PTR $T39994[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 779  : 
; 780  : 	if(( flOldSpeed == 0 ) && ( pev->speed != 0 ))

	fld	DWORD PTR _flOldSpeed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37881
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L37881

; 782  : 		// starting to move - emit the sound.
; 783  : 		EMIT_SOUND_DYN( edict(), CHAN_STATIC, STRING( pev->noise3 ), 0.01f, m_flAttenuation, 0, FANPITCHMIN );

	push	30					; 0000001eH
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1800]
	push	edx
	push	1008981770				; 3c23d70aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+500]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 784  : 		RampPitchVol();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RampPitchVol@CFuncRotating@@QAEXXZ	; CFuncRotating::RampPitchVol

; 786  : 	else if(( flOldSpeed != 0 ) && ( pev->speed == 0 ))

	jmp	SHORT $L37884
$L37881:
	fld	DWORD PTR _flOldSpeed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L37883
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37883

; 788  : 		// stopping - stop the sound.
; 789  : 		STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise3 ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+500]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH

; 790  : 		SetMoveDoneTime( -1 );

	push	-1082130432				; bf800000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 791  : 		m_iState = STATE_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 0

; 793  : 	else

	jmp	SHORT $L37884
$L37883:

; 795  : 		// changing speed - adjust the pitch and volume.
; 796  : 		RampPitchVol();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RampPitchVol@CFuncRotating@@QAEXXZ	; CFuncRotating::RampPitchVol
$L37884:

; 798  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateSpeed@CFuncRotating@@QAEXM@Z ENDP		; CFuncRotating::UpdateSpeed
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QBEPBMXZ PROC NEAR				; Vector::operator float const *, COMDAT

; 229  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
PUBLIC	__real@4@4006b60b610000000000
PUBLIC	__real@4@3ff7b400000000000000
;	COMDAT __real@4@4006b60b610000000000
; File z:\xashxtsrc\game_shared\mathlib.h
CONST	SEGMENT
__real@4@4006b60b610000000000 DD 043360b61r	; 182.044
CONST	ENDS
;	COMDAT __real@4@3ff7b400000000000000
CONST	SEGMENT
__real@4@3ff7b400000000000000 DD 03bb40000r	; 0.00549316
CONST	ENDS
;	COMDAT ?anglemod@@YAMM@Z
_TEXT	SEGMENT
_a$ = 8
?anglemod@@YAMM@Z PROC NEAR				; anglemod, COMDAT

; 81   : inline float anglemod( float a ) { return (360.0f / 65536) * ((int)(a * (65536 / 360.0f)) & 65535); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR _a$[ebp]
	fmul	DWORD PTR __real@4@4006b60b610000000000
	call	__ftol
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR -4+[ebp], eax
	fild	DWORD PTR -4+[ebp]
	fmul	DWORD PTR __real@4@3ff7b400000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?anglemod@@YAMM@Z ENDP					; anglemod
_TEXT	ENDS
;	COMDAT ?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z PROC NEAR		; STOP_SOUND, COMDAT

; 614  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 615  : 	EMIT_SOUND_DYN( entity, channel, sample, 0, 0, SND_STOP, PITCH_NORM );

	push	100					; 00000064H
	push	32					; 00000020H
	push	0
	push	0
	mov	eax, DWORD PTR _sample$[ebp]
	push	eax
	mov	ecx, DWORD PTR _channel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entity$[ebp]
	push	edx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 616  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z ENDP			; STOP_SOUND
_TEXT	ENDS
PUBLIC	__real@4@3ffccccccd0000000000
;	COMDAT __real@4@3ffccccccd0000000000
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
__real@4@3ffccccccd0000000000 DD 03e4ccccdr	; 0.2
CONST	ENDS
;	COMDAT ?SpinUp@CFuncRotating@@QAEXXZ
_TEXT	SEGMENT
_flNewSpeed$ = -8
_bSpinUpDone$ = -12
_this$ = -4
?SpinUp@CFuncRotating@@QAEXXZ PROC NEAR			; CFuncRotating::SpinUp, COMDAT

; 804  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 805  : 	// calculate our new speed.
; 806  : 	float flNewSpeed = fabs( pev->speed ) + 0.2f * m_flMaxSpeed * m_flFanFriction;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR __real@4@3ffccccccd0000000000
	fmul	DWORD PTR [edx+1808]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+1796]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _flNewSpeed$[ebp]

; 807  : 	bool bSpinUpDone = false;

	mov	BYTE PTR _bSpinUpDone$[ebp], 0

; 808  : 
; 809  : 	if( fabs( flNewSpeed ) >= fabs( m_flTargetSpeed ))

	fld	DWORD PTR _flNewSpeed$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	fstp	QWORD PTR -20+[ebp]
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1804]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR -20+[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L37891

; 811  : 		// Reached our target speed.
; 812  : 		flNewSpeed = m_flTargetSpeed;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1804]
	mov	DWORD PTR _flNewSpeed$[ebp], eax

; 813  : 		bSpinUpDone = !m_bStopAtStartPos;

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+1792]
	neg	edx
	sbb	edx, edx
	inc	edx
	mov	BYTE PTR _bSpinUpDone$[ebp], dl

; 815  : 	else if( m_flTargetSpeed < 0 )

	jmp	SHORT $L37893
$L37891:
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1804]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37893

; 817  : 		// spinning up in reverse - negate the speed.
; 818  : 		flNewSpeed *= -1;

	fld	DWORD PTR _flNewSpeed$[ebp]
	fmul	DWORD PTR __real@4@bfff8000000000000000
	fstp	DWORD PTR _flNewSpeed$[ebp]
$L37893:

; 820  : 
; 821  : 	m_iState = STATE_TURN_ON;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 2

; 822  : 
; 823  : 	// Apply the new speed, adjust sound pitch and volume.
; 824  : 	UpdateSpeed( flNewSpeed );

	mov	edx, DWORD PTR _flNewSpeed$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSpeed@CFuncRotating@@QAEXM@Z	; CFuncRotating::UpdateSpeed

; 825  : 
; 826  : 	// If we've met or exceeded target speed, stop spinning up.
; 827  : 	if( bSpinUpDone )

	mov	eax, DWORD PTR _bSpinUpDone$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L37894

; 829  : 		SetMoveDone( Rotate );

	push	OFFSET FLAT:??_C@_06GGLN@Rotate?$AA@	; `string'
	push	OFFSET FLAT:?Rotate@CFuncRotating@@QAEXXZ ; CFuncRotating::Rotate
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 830  : 		Rotate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Rotate@CFuncRotating@@QAEXXZ		; CFuncRotating::Rotate
$L37894:

; 832  : 
; 833  : 	SetMoveDoneTime( GetNextMoveInterval() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextMoveInterval@CFuncRotating@@QBEMXZ ; CFuncRotating::GetNextMoveInterval
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 834  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SpinUp@CFuncRotating@@QAEXXZ ENDP			; CFuncRotating::SpinUp
_TEXT	ENDS
PUBLIC	?SpinDown@CFuncRotating@@QAE_NM@Z		; CFuncRotating::SpinDown
;	COMDAT ?SpinDown@CFuncRotating@@QAE_NM@Z
_TEXT	SEGMENT
_flTargetSpeed$ = 8
_this$ = -4
_bSpinDownDone$ = -8
_flNewSpeed$ = -12
?SpinDown@CFuncRotating@@QAE_NM@Z PROC NEAR		; CFuncRotating::SpinDown, COMDAT

; 842  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 843  : 	// Bleed off a little speed due to friction.
; 844  : 	bool bSpinDownDone = false;

	mov	BYTE PTR _bSpinDownDone$[ebp], 0

; 845  : 	float flNewSpeed = fabs( pev->speed ) - 0.1f * m_flMaxSpeed * m_flFanFriction;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR __real@4@3ffbcccccd0000000000
	fmul	DWORD PTR [edx+1808]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+1796]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _flNewSpeed$[ebp]

; 846  : 
; 847  : 	if( flNewSpeed < 0 )

	fld	DWORD PTR _flNewSpeed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37903

; 849  : 		flNewSpeed = 0;

	mov	DWORD PTR _flNewSpeed$[ebp], 0
$L37903:

; 851  : 
; 852  : 	if( fabs( flNewSpeed ) <= fabs( flTargetSpeed ))

	fld	DWORD PTR _flNewSpeed$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	fstp	QWORD PTR -20+[ebp]
	add	esp, 8
	fld	DWORD PTR _flTargetSpeed$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR -20+[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L37904

; 854  : 		// Reached our target speed.
; 855  : 		flNewSpeed = flTargetSpeed;

	mov	ecx, DWORD PTR _flTargetSpeed$[ebp]
	mov	DWORD PTR _flNewSpeed$[ebp], ecx

; 856  : 		bSpinDownDone = !m_bStopAtStartPos;

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+1792]
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	BYTE PTR _bSpinDownDone$[ebp], al

; 858  : 	else if( pev->speed < 0 )

	jmp	SHORT $L37906
$L37904:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37906

; 860  : 		// spinning down in reverse - negate the speed.
; 861  : 		flNewSpeed *= -1;

	fld	DWORD PTR _flNewSpeed$[ebp]
	fmul	DWORD PTR __real@4@bfff8000000000000000
	fstp	DWORD PTR _flNewSpeed$[ebp]
$L37906:

; 863  : 
; 864  : 	m_iState = STATE_TURN_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 3

; 865  : 
; 866  : 	// Apply the new speed, adjust sound pitch and volume.
; 867  : 	UpdateSpeed( flNewSpeed );

	mov	ecx, DWORD PTR _flNewSpeed$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSpeed@CFuncRotating@@QAEXM@Z	; CFuncRotating::UpdateSpeed

; 868  : 
; 869  : 	// If we've met or exceeded target speed, stop spinning down.
; 870  : 	return bSpinDownDone;

	mov	al, BYTE PTR _bSpinDownDone$[ebp]

; 871  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SpinDown@CFuncRotating@@QAE_NM@Z ENDP			; CFuncRotating::SpinDown
_TEXT	ENDS
;	COMDAT ?SpinDown@CFuncRotating@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SpinDown@CFuncRotating@@QAEXXZ PROC NEAR		; CFuncRotating::SpinDown, COMDAT

; 877  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 	// If we've met or exceeded target speed, stop spinning down.
; 879  : 	if( SpinDown( m_flTargetSpeed ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1804]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SpinDown@CFuncRotating@@QAE_NM@Z	; CFuncRotating::SpinDown
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L37911

; 881  : 		if( m_iState != STATE_OFF )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1788], 0
	je	SHORT $L37912

; 883  : 			SetMoveDone( Rotate );

	push	OFFSET FLAT:??_C@_06GGLN@Rotate?$AA@	; `string'
	push	OFFSET FLAT:?Rotate@CFuncRotating@@QAEXXZ ; CFuncRotating::Rotate
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 884  : 			Rotate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Rotate@CFuncRotating@@QAEXXZ		; CFuncRotating::Rotate
$L37912:

; 887  : 	else

	jmp	SHORT $L37915
$L37911:

; 889  : 		SetMoveDoneTime( GetNextMoveInterval() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextMoveInterval@CFuncRotating@@QBEMXZ ; CFuncRotating::GetNextMoveInterval
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime
$L37915:

; 891  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SpinDown@CFuncRotating@@QAEXXZ ENDP			; CFuncRotating::SpinDown
_TEXT	ENDS
PUBLIC	?SetTargetSpeed@CFuncRotating@@QAEXM@Z		; CFuncRotating::SetTargetSpeed
;	COMDAT ?Rotate@CFuncRotating@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_checkAxis$37922 = -8
_angDelta$37926 = -12
_avel$37928 = -24
_avelpertick$37929 = -36
$T40029 = -48
?Rotate@CFuncRotating@@QAEXXZ PROC NEAR			; CFuncRotating::Rotate, COMDAT

; 894  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 895  : 	// NOTE: only full speed moving set state to "On"
; 896  : 	if( fabs( pev->speed ) == fabs( m_flMaxSpeed ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	fstp	QWORD PTR -56+[ebp]
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1808]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR -56+[ebp]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37920

; 897  : 		m_iState = STATE_ON;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 1
$L37920:

; 898  : 
; 899  : 	SetMoveDoneTime( 0.1f );

	push	1036831949				; 3dcccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 900  : 
; 901  : 	if( m_bStopAtStartPos )

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+1792]
	test	edx, edx
	je	$L37931

; 903  : 		SetMoveDoneTime( GetNextMoveInterval() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextMoveInterval@CFuncRotating@@QBEMXZ ; CFuncRotating::GetNextMoveInterval
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 904  : 
; 905  : 		int checkAxis = 2;

	mov	DWORD PTR _checkAxis$37922[ebp], 2

; 906  : 
; 907  : 		// see if we got close to the starting orientation
; 908  : 		if( pev->movedir[0] != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 68					; 00000044H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L37923

; 910  : 			checkAxis = 0;

	mov	DWORD PTR _checkAxis$37922[ebp], 0

; 912  : 		else if( pev->movedir[1] != 0 )

	jmp	SHORT $L37925
$L37923:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 68					; 00000044H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L37925

; 914  : 			checkAxis = 1;

	mov	DWORD PTR _checkAxis$37922[ebp], 1
$L37925:

; 916  : 
; 917  : 		float angDelta = anglemod( GetLocalAngles()[checkAxis] - m_angStart[checkAxis] );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	ecx, eax
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1816				; 00000718H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _checkAxis$37922[ebp]
	mov	ecx, DWORD PTR _checkAxis$37922[ebp]
	fld	DWORD PTR [esi+edx*4]
	fsub	DWORD PTR [eax+ecx*4]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?anglemod@@YAMM@Z			; anglemod
	add	esp, 4
	fstp	DWORD PTR _angDelta$37926[ebp]

; 918  : 		if( angDelta > 180.0f )

	fld	DWORD PTR _angDelta$37926[ebp]
	fcomp	DWORD PTR __real@4@4006b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37927

; 919  : 			angDelta -= 360.0f;

	fld	DWORD PTR _angDelta$37926[ebp]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _angDelta$37926[ebp]
$L37927:

; 920  : 
; 921  : 		Vector avel = GetLocalAvelocity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	push	eax
	lea	ecx, DWORD PTR _avel$37928[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 922  : 
; 923  : 		// delta per tick
; 924  : 		Vector avelpertick = avel * gpGlobals->frametime;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR $T40029[ebp]
	push	ecx
	lea	ecx, DWORD PTR _avel$37928[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _avelpertick$37929[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 925  : 
; 926  : 		if( fabs( angDelta ) < fabs( avelpertick[checkAxis] ))

	fld	DWORD PTR _angDelta$37926[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	fstp	QWORD PTR -64+[ebp]
	add	esp, 8
	lea	ecx, DWORD PTR _avelpertick$37929[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _checkAxis$37922[ebp]
	fld	DWORD PTR [eax+edx*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR -64+[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37931

; 928  : 			SetTargetSpeed( 0 );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetSpeed@CFuncRotating@@QAEXM@Z	; CFuncRotating::SetTargetSpeed

; 929  : 			SetLocalAngles( m_angStart );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1816				; 00000718H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 930  : 			m_bStopAtStartPos = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1792], 0
$L37931:

; 933  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Rotate@CFuncRotating@@QAEXXZ ENDP			; CFuncRotating::Rotate
_TEXT	ENDS
;	COMDAT ?RotateFriction@CFuncRotating@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RotateFriction@CFuncRotating@@QAEXXZ PROC NEAR		; CFuncRotating::RotateFriction, COMDAT

; 936  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 937  : 	// angular impulse support
; 938  : 	if( GetLocalAvelocity() != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L37936

; 940  : 		m_iState = STATE_ON;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 1

; 941  : 		SetMoveDoneTime( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 942  : 		RampPitchVol();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RampPitchVol@CFuncRotating@@QAEXXZ	; CFuncRotating::RampPitchVol

; 944  : 	else

	jmp	SHORT $L37937
$L37936:

; 946  : 		STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise3 ));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+500]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH

; 947  : 		SetMoveDoneTime( -1 );

	push	-1082130432				; bf800000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 948  : 		m_iState = STATE_OFF;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 0
$L37937:

; 950  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotateFriction@CFuncRotating@@QAEXXZ ENDP		; CFuncRotating::RotateFriction
_TEXT	ENDS
;	COMDAT ?ReverseMove@CFuncRotating@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ReverseMove@CFuncRotating@@QAEXXZ PROC NEAR		; CFuncRotating::ReverseMove, COMDAT

; 953  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 954  : 	if( SpinDown( 0 ))

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SpinDown@CFuncRotating@@QAE_NM@Z	; CFuncRotating::SpinDown
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L37942

; 956  : 		// we've reached zero - spin back up to the target speed.
; 957  : 		SetTargetSpeed( m_flTargetSpeed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1804]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetSpeed@CFuncRotating@@QAEXM@Z	; CFuncRotating::SetTargetSpeed

; 959  : 	else

	jmp	SHORT $L37943
$L37942:

; 961  : 		SetMoveDoneTime( GetNextMoveInterval() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextMoveInterval@CFuncRotating@@QBEMXZ ; CFuncRotating::GetNextMoveInterval
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime
$L37943:

; 963  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReverseMove@CFuncRotating@@QAEXXZ ENDP			; CFuncRotating::ReverseMove
_TEXT	ENDS
;	COMDAT ?SetTargetSpeed@CFuncRotating@@QAEXM@Z
_TEXT	SEGMENT
_flSpeed$ = 8
_this$ = -4
?SetTargetSpeed@CFuncRotating@@QAEXM@Z PROC NEAR	; CFuncRotating::SetTargetSpeed, COMDAT

; 966  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 967  : 	if( flSpeed == 0.0f && FBitSet( pev->spawnflags, SF_ROTATING_STOP_AT_START_POS ))

	fld	DWORD PTR _flSpeed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37948
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1024				; 00000400H
	test	edx, edx
	je	SHORT $L37948

; 968  : 		m_bStopAtStartPos = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1792], 1
$L37948:

; 969  : 
; 970  : 	// make sure the sign is correct - positive for forward rotation,
; 971  : 	// negative for reverse rotation.
; 972  : 	flSpeed = fabs( flSpeed );

	fld	DWORD PTR _flSpeed$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _flSpeed$[ebp]

; 973  : 
; 974  : 	if( pev->impulse )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+388], 0
	je	SHORT $L37949

; 976  : 		flSpeed *= -1;

	fld	DWORD PTR _flSpeed$[ebp]
	fmul	DWORD PTR __real@4@bfff8000000000000000
	fstp	DWORD PTR _flSpeed$[ebp]
$L37949:

; 978  : 
; 979  : 	m_flTargetSpeed = flSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flSpeed$[ebp]
	mov	DWORD PTR [eax+1804], ecx

; 980  : 	pev->friction = 0.0f; // clear impulse friction

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+288], 0

; 981  : 
; 982  : 	// If we don't accelerate, change to the new speed instantly.
; 983  : 	if( !FBitSet( pev->spawnflags, SF_ROTATING_ACCDCC ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L37950

; 985  : 		UpdateSpeed( m_flTargetSpeed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1804]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateSpeed@CFuncRotating@@QAEXM@Z	; CFuncRotating::UpdateSpeed

; 986  : 		SetMoveDone( Rotate );

	push	OFFSET FLAT:??_C@_06GGLN@Rotate?$AA@	; `string'
	push	OFFSET FLAT:?Rotate@CFuncRotating@@QAEXXZ ; CFuncRotating::Rotate
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 988  : 	else

	jmp	$L37967
$L37950:

; 990  : 		// Otherwise deal with acceleration/deceleration:
; 991  : 		if((( pev->speed > 0 ) && ( m_flTargetSpeed < 0 )) || (( pev->speed < 0 ) && ( m_flTargetSpeed > 0 )))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37956
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1804]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L37955
$L37956:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37954
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1804]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37954
$L37955:

; 993  : 			// check for reversing directions.
; 994  : 			SetMoveDone( ReverseMove );

	push	OFFSET FLAT:??_C@_0M@BGDO@ReverseMove?$AA@ ; `string'
	push	OFFSET FLAT:?ReverseMove@CFuncRotating@@QAEXXZ ; CFuncRotating::ReverseMove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 996  : 		else if( fabs( pev->speed ) < fabs( m_flTargetSpeed ))

	jmp	$L37967
$L37954:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	fstp	QWORD PTR -12+[ebp]
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1804]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR -12+[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37960

; 998  : 			// If we are below the new target speed, spin up to the target speed.
; 999  : 			SetMoveDone( SpinUp );

	push	OFFSET FLAT:??_C@_06BLKE@SpinUp?$AA@	; `string'
	push	OFFSET FLAT:?SpinUp@CFuncRotating@@QAEXXZ ; CFuncRotating::SpinUp
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 1001 : 		else if( fabs( pev->speed ) > fabs( m_flTargetSpeed ))

	jmp	SHORT $L37967
$L37960:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	fstp	QWORD PTR -20+[ebp]
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1804]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR -20+[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37964

; 1003 : 			// If we are above the new target speed, spin down to the target speed.
; 1004 : 			SetMoveDone( SpinDown );

	push	OFFSET FLAT:??_C@_08OHJJ@SpinDown?$AA@	; `string'
	push	OFFSET FLAT:?SpinDown@CFuncRotating@@QAEXXZ ; CFuncRotating::SpinDown
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 1006 : 		else

	jmp	SHORT $L37967
$L37964:

; 1008 : 			// we are already at the new target speed. Just keep rotating.
; 1009 : 			SetMoveDone( Rotate );

	push	OFFSET FLAT:??_C@_06GGLN@Rotate?$AA@	; `string'
	push	OFFSET FLAT:?Rotate@CFuncRotating@@QAEXXZ ; CFuncRotating::Rotate
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet
$L37967:

; 1012 : 
; 1013 : 	SetMoveDoneTime( GetNextMoveInterval() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextMoveInterval@CFuncRotating@@QBEMXZ ; CFuncRotating::GetNextMoveInterval
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 1014 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTargetSpeed@CFuncRotating@@QAEXM@Z ENDP		; CFuncRotating::SetTargetSpeed
_TEXT	ENDS
PUBLIC	??_C@_0BF@GEEH@momentary_rot_button?$AA@	; `string'
PUBLIC	??_C@_0BD@GGEE@momentary_rot_door?$AA@		; `string'
PUBLIC	?Use@CFuncRotating@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncRotating::Use
EXTRN	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z:NEAR	; FClassnameIs
;	COMDAT ??_C@_0BF@GEEH@momentary_rot_button?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0BF@GEEH@momentary_rot_button?$AA@ DB 'momentary_rot_button', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GGEE@momentary_rot_door?$AA@
CONST	SEGMENT
??_C@_0BD@GGEE@momentary_rot_door?$AA@ DB 'momentary_rot_door', 00H ; `string'
CONST	ENDS
;	COMDAT ?Use@CFuncRotating@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_pCaller$ = 12
_useType$ = 16
_value$ = 20
_this$ = -4
$T40048 = -16
?Use@CFuncRotating@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CFuncRotating::Use, COMDAT

; 1020 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1021 : 	if( IsLockedByMaster( pActivator ))

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z ; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L37977

; 1022 : 		return;

	jmp	$L37976
$L37977:

; 1023 : 
; 1024 : 	m_bStopAtStartPos = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1792], 0

; 1025 : 
; 1026 : 	if( useType == USE_SET )

	cmp	DWORD PTR _useType$[ebp], 2
	jne	$L37978

; 1028 : 		if( value != 0 ) 

	fld	DWORD PTR _value$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L37979

; 1030 : 			// never toggle direction from momentary entities
; 1031 : 			if( pCaller && !FClassnameIs( pCaller, "momentary_rot_button" ) && !FClassnameIs( pCaller, "momentary_rot_door" ))

	cmp	DWORD PTR _pCaller$[ebp], 0
	je	SHORT $L37980
	push	OFFSET FLAT:??_C@_0BF@GEEH@momentary_rot_button?$AA@ ; `string'
	mov	edx, DWORD PTR _pCaller$[ebp]
	push	edx
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	jne	SHORT $L37980
	push	OFFSET FLAT:??_C@_0BD@GGEE@momentary_rot_door?$AA@ ; `string'
	mov	eax, DWORD PTR _pCaller$[ebp]
	push	eax
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	jne	SHORT $L37980

; 1032 : 				pev->impulse = (value < 0) ? true : false;

	fld	DWORD PTR _value$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40038
	mov	BYTE PTR -20+[ebp], 1
	jmp	SHORT $L40039
$L40038:
	mov	BYTE PTR -20+[ebp], 0
$L40039:
	mov	ecx, DWORD PTR -20+[ebp]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+388], ecx
$L37980:

; 1033 : 			value = fabs( value );

	fld	DWORD PTR _value$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fst	DWORD PTR _value$[ebp]

; 1034 : 			SetTargetSpeed( bound( 0, value, 1 ) * m_flMaxSpeed );

	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40042
	fld	DWORD PTR _value$[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40040
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR -24+[ebp], ecx
	jmp	SHORT $L40041
$L40040:
	mov	DWORD PTR -24+[ebp], 1065353216		; 3f800000H
$L40041:
	mov	edx, DWORD PTR -24+[ebp]
	mov	DWORD PTR -28+[ebp], edx
	jmp	SHORT $L40043
$L40042:
	mov	DWORD PTR -28+[ebp], 0
$L40043:
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR -28+[ebp]
	fmul	DWORD PTR [eax+1808]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetSpeed@CFuncRotating@@QAEXM@Z	; CFuncRotating::SetTargetSpeed

; 1036 : 		else

	jmp	SHORT $L37983
$L37979:

; 1038 : 			SetTargetSpeed( 0 );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetSpeed@CFuncRotating@@QAEXM@Z	; CFuncRotating::SetTargetSpeed
$L37983:

; 1040 : 		return;

	jmp	$L37976
$L37978:

; 1042 : 
; 1043 : 	// a liitle easter egg
; 1044 : 	if( useType == USE_RESET )

	cmp	DWORD PTR _useType$[ebp], 4
	jne	$L37984

; 1046 : 		if( value == 0.0f )

	fld	DWORD PTR _value$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37985

; 1048 : 			if( m_iState == STATE_OFF )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1788], 0
	jne	SHORT $L37986

; 1049 : 				pev->impulse = !pev->impulse;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+388], 0
	sete	cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+388], ecx
$L37986:

; 1050 : 			return;

	jmp	$L37976
$L37985:

; 1052 : 
; 1053 : 		if( m_iState == STATE_OFF )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1788], 0
	jne	$L37987

; 1055 : 			// apply angular impulse (XashXT feature)
; 1056 : 			SetLocalAvelocity( pev->movedir * (bound( -1, value, 1 ) * m_flMaxSpeed ));

	fld	DWORD PTR _value$[ebp]
	fcomp	DWORD PTR __real@4@bfff8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40046
	fld	DWORD PTR _value$[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40044
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR -32+[ebp], edx
	jmp	SHORT $L40045
$L40044:
	mov	DWORD PTR -32+[ebp], 1065353216		; 3f800000H
$L40045:
	mov	eax, DWORD PTR -32+[ebp]
	mov	DWORD PTR -36+[ebp], eax
	jmp	SHORT $L40047
$L40046:
	mov	DWORD PTR -36+[ebp], -1082130432	; bf800000H
$L40047:
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR -36+[ebp]
	fmul	DWORD PTR [ecx+1808]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR $T40048[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 1057 : 			SetMoveDone( RotateFriction );

	push	OFFSET FLAT:??_C@_0P@MKBN@RotateFriction?$AA@ ; `string'
	push	OFFSET FLAT:?RotateFriction@CFuncRotating@@QAEXXZ ; CFuncRotating::RotateFriction
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 1058 : 			pev->friction = 1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+288], 1065353216		; 3f800000H

; 1059 : 			RotateFriction();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotateFriction@CFuncRotating@@QAEXXZ	; CFuncRotating::RotateFriction
$L37987:

; 1061 : 		return;

	jmp	SHORT $L37976
$L37984:

; 1063 : 
; 1064 : 	if( pev->speed != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L37991

; 1065 : 		SetTargetSpeed( 0 );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetSpeed@CFuncRotating@@QAEXM@Z	; CFuncRotating::SetTargetSpeed

; 1066 : 	else SetTargetSpeed( m_flMaxSpeed );

	jmp	SHORT $L37992
$L37991:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1808]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetSpeed@CFuncRotating@@QAEXM@Z	; CFuncRotating::SetTargetSpeed
$L37992:
$L37976:

; 1067 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CFuncRotating@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CFuncRotating::Use
_TEXT	ENDS
PUBLIC	__real@4@3ffe8000000000000000
PUBLIC	?Blocked@CFuncRotating@@UAEXPAVCBaseEntity@@@Z	; CFuncRotating::Blocked
EXTRN	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z:NEAR ; UTIL_FireTargets
;	COMDAT __real@4@3ffe8000000000000000
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
__real@4@3ffe8000000000000000 DD 03f000000r	; 0.5
CONST	ENDS
;	COMDAT ?Blocked@CFuncRotating@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
?Blocked@CFuncRotating@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CFuncRotating::Blocked, COMDAT

; 1071 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1072 : 	pOther->TakeDamage( pev, pev, pev->dmg, DMG_CRUSH );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+480]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+96]

; 1073 : 
; 1074 : 	if( gpGlobals->time < pev->dmgtime )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fcomp	DWORD PTR [ecx+484]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37997

; 1075 : 		return;

	jmp	SHORT $L37996
$L37997:

; 1076 : 
; 1077 : 	pev->dmgtime = gpGlobals->time + 0.5f;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@3ffe8000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+484]

; 1078 : 	UTIL_FireTargets( pev->target, this, this, USE_TOGGLE );

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+456]
	push	ecx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L37996:

; 1079 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CFuncRotating@@UAEXPAVCBaseEntity@@@Z ENDP	; CFuncRotating::Blocked
_TEXT	ENDS
;	COMDAT _$E69
_TEXT	SEGMENT
_$E69	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E68
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E69	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCPendulum@@@@QAE@PBD@Z	; CEntityFactory<CPendulum>::CEntityFactory<CPendulum>
PUBLIC	??_C@_0O@OIAN@func_pendulum?$AA@		; `string'
_BSS	SEGMENT
	ALIGN	4

_func_pendulum DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@OIAN@func_pendulum?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0O@OIAN@func_pendulum?$AA@ DB 'func_pendulum', 00H ; `string'
CONST	ENDS
;	COMDAT _$E68
_TEXT	SEGMENT
_$E68	PROC NEAR					; COMDAT

; 1114 : LINK_ENTITY_TO_CLASS( func_pendulum, CPendulum );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0O@OIAN@func_pendulum?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_pendulum
	call	??0?$CEntityFactory@VCPendulum@@@@QAE@PBD@Z ; CEntityFactory<CPendulum>::CEntityFactory<CPendulum>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E68	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CPendulum@@UAEPAUdatamap_s@@XZ	; CPendulum::GetDataDescMap
;	COMDAT ?GetDataDescMap@CPendulum@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CPendulum@@UAEPAUdatamap_s@@XZ PROC NEAR ; CPendulum::GetDataDescMap, COMDAT

; 1116 : BEGIN_DATADESC( CPendulum )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CPendulum@@2Udatamap_s@@A ; CPendulum::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CPendulum@@UAEPAUdatamap_s@@XZ ENDP	; CPendulum::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CPendulum@@SAPAUdatamap_s@@XZ	; CPendulum::GetBaseMap
;	COMDAT ?GetBaseMap@CPendulum@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CPendulum@@SAPAUdatamap_s@@XZ PROC NEAR	; CPendulum::GetBaseMap, COMDAT

; 1116 : BEGIN_DATADESC( CPendulum )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CPendulum@@SAPAUdatamap_s@@XZ ENDP		; CPendulum::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E72
_TEXT	SEGMENT
_$E72	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E71
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E72	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z	; DataMapInit
;	COMDAT _$E71
_TEXT	SEGMENT
_$E71	PROC NEAR					; COMDAT

; 1116 : BEGIN_DATADESC( CPendulum )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CPendulum_DataDescInit@@3PAUdatamap_s@@A, eax ; CPendulum_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E71	ENDP
_TEXT	ENDS
PUBLIC	?Swing@CPendulum@@QAEXXZ			; CPendulum::Swing
PUBLIC	?Stop@CPendulum@@QAEXXZ				; CPendulum::Stop
PUBLIC	?RopeTouch@CPendulum@@QAEXPAVCBaseEntity@@@Z	; CPendulum::RopeTouch
PUBLIC	??_C@_05KAHD@Swing?$AA@				; `string'
PUBLIC	??_C@_04DFLL@Stop?$AA@				; `string'
PUBLIC	??_C@_09LKMM@RopeTouch?$AA@			; `string'
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S74@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_05KAHD@Swing?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_05KAHD@Swing?$AA@ DB 'Swing', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DFLL@Stop?$AA@
CONST	SEGMENT
??_C@_04DFLL@Stop?$AA@ DB 'Stop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09LKMM@RopeTouch?$AA@
CONST	SEGMENT
??_C@_09LKMM@RopeTouch?$AA@ DB 'RopeTouch', 00H		; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z PROC NEAR ; DataMapInit, COMDAT

; 1116 : BEGIN_DATADESC( CPendulum )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S74@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L38124
	mov	cl, BYTE PTR _?$S74@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S74@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_09MBEG@CPendulum?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E75
	call	_atexit
	add	esp, 4
$L38124:
	call	?GetBaseMap@CPendulum@@SAPAUdatamap_s@@XZ ; CPendulum::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CPendulum@@2Udatamap_s@@A+12, eax

; 1117 : 	DEFINE_FIELD( m_accel, FIELD_FLOAT ),
; 1118 : 	DEFINE_KEYFIELD( m_distance, FIELD_FLOAT, "distance" ),
; 1119 : 	DEFINE_FIELD( m_time, FIELD_TIME ),
; 1120 : 	DEFINE_FIELD( m_damp, FIELD_FLOAT ),
; 1121 : 	DEFINE_FIELD( m_maxSpeed, FIELD_FLOAT ),
; 1122 : 	DEFINE_FIELD( m_dampSpeed, FIELD_FLOAT ),
; 1123 : 	DEFINE_FIELD( m_center, FIELD_VECTOR ),
; 1124 : 	DEFINE_FIELD( m_start, FIELD_VECTOR ),
; 1125 : 	DEFINE_FUNCTION( Swing ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S74@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L38153
	mov	al, BYTE PTR _?$S74@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S74@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_05KAHD@Swing?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+220, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+224, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+228, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+230, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+232, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+236, OFFSET FLAT:?Swing@CPendulum@@QAEXXZ ; CPendulum::Swing

; 1126 : 	DEFINE_FUNCTION( Stop ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+240, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_04DFLL@Stop?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+244, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+248, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+252, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+254, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+256, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+260, OFFSET FLAT:?Stop@CPendulum@@QAEXXZ ; CPendulum::Stop

; 1127 : 	DEFINE_FUNCTION( RopeTouch ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+264, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_09LKMM@RopeTouch?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+268, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+272, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+276, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+278, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+280, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+284, OFFSET FLAT:?RopeTouch@CPendulum@@QAEXPAVCBaseEntity@@@Z ; CPendulum::RopeTouch
$L38153:

; 1128 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L38163
	mov	DWORD PTR ?m_DataMap@CPendulum@@2Udatamap_s@@A+4, 11 ; 0000000bH
	mov	DWORD PTR ?m_DataMap@CPendulum@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L38164
$L38163:
	mov	DWORD PTR ?m_DataMap@CPendulum@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CPendulum@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4PAUtypedescription_s@@A
$L38164:
	mov	eax, OFFSET FLAT:?m_DataMap@CPendulum@@2Udatamap_s@@A ; CPendulum::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z ENDP	; DataMapInit
_TEXT	ENDS
;	COMDAT _$E75
_TEXT	SEGMENT
_$E75	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPendulum@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E75	ENDP
_TEXT	ENDS
PUBLIC	?KeyValue@CPendulum@@UAEXPAUKeyValueData_s@@@Z	; CPendulum::KeyValue
PUBLIC	__real@8@3ff583126e978d4fe000
PUBLIC	??_C@_04CGBF@damp?$AA@				; `string'
;	COMDAT ??_C@_04CGBF@damp?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_04CGBF@damp?$AA@ DB 'damp', 00H			; `string'
CONST	ENDS
;	COMDAT __real@8@3ff583126e978d4fe000
CONST	SEGMENT
__real@8@3ff583126e978d4fe000 DQ 03f50624dd2f1a9fcr ; 0.001
CONST	ENDS
;	COMDAT ?KeyValue@CPendulum@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CPendulum@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CPendulum::KeyValue, COMDAT

; 1131 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1132 : 	if( FStrEq( pkvd->szKeyName, "distance" ))

	push	OFFSET FLAT:??_C@_08GHDD@distance?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38170

; 1134 : 		m_distance = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1796]

; 1135 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1137 : 	else if( FStrEq( pkvd->szKeyName, "damp" ))

	jmp	SHORT $L38174
$L38170:
	push	OFFSET FLAT:??_C@_04CGBF@damp?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38172

; 1139 : 		m_damp = Q_atof( pkvd->szValue ) * 0.001;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	fmul	QWORD PTR __real@8@3ff583126e978d4fe000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1804]

; 1140 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1142 : 	else CBaseDelay::KeyValue( pkvd );

	jmp	SHORT $L38174
$L38172:
	mov	eax, DWORD PTR _pkvd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z ; CBaseDelay::KeyValue
$L38174:

; 1143 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CPendulum@@UAEXPAUKeyValueData_s@@@Z ENDP	; CPendulum::KeyValue
_TEXT	ENDS
PUBLIC	?Spawn@CPendulum@@UAEXXZ			; CPendulum::Spawn
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??_C@_0BO@GBDF@?$CFs?5?$FL?$CFi?$FN?5has?5invalid?5distance?6?$AA@ ; `string'
PUBLIC	??D@YA?AVVector@@MABV0@@Z			; operator*
PUBLIC	?entindex@CBaseEntity@@QAEHXZ			; CBaseEntity::entindex
EXTRN	?AxisDir@CBaseToggle@@SAXPAUentvars_s@@@Z:NEAR	; CBaseToggle::AxisDir
;	COMDAT ??_C@_0BO@GBDF@?$CFs?5?$FL?$CFi?$FN?5has?5invalid?5distance?6?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0BO@GBDF@?$CFs?5?$FL?$CFi?$FN?5has?5invalid?5distance?6?$AA@ DB '%s'
	DB	' [%i] has invalid distance', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?Spawn@CPendulum@@UAEXXZ
_TEXT	SEGMENT
$T40075 = -16
$T40076 = -28
_this$ = -4
?Spawn@CPendulum@@UAEXXZ PROC NEAR			; CPendulum::Spawn, COMDAT

; 1146 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1147 : 	// set the axis of rotation
; 1148 : 	CBaseToggle::AxisDir( pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?AxisDir@CBaseToggle@@SAXPAUentvars_s@@@Z ; CBaseToggle::AxisDir
	add	esp, 4

; 1149 : 
; 1150 : 	if( FBitSet( pev->spawnflags, SF_PENDULUM_PASSABLE ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 8
	test	ecx, ecx
	je	SHORT $L38179

; 1151 : 		pev->solid = SOLID_NOT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 0

; 1152 : 	else pev->solid = SOLID_BSP;

	jmp	SHORT $L38180
$L38179:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 4
$L38180:

; 1153 : 
; 1154 : 	pev->movetype = MOVETYPE_PUSH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 7

; 1155 : 
; 1156 : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 1157 : 
; 1158 : 	if( m_distance == 0 )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1796]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38181

; 1160 : 		ALERT( at_error, "%s [%i] has invalid distance\n", GetClassname(), entindex());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0BO@GBDF@?$CFs?5?$FL?$CFi?$FN?5has?5invalid?5distance?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 1161 : 		return;

	jmp	$L38178
$L38181:

; 1163 : 
; 1164 : 	if( pev->speed == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38183

; 1165 : 		pev->speed = 100;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+504], 1120403456		; 42c80000H
$L38183:

; 1166 : 
; 1167 : 	SetLocalAngles( m_vecTempAngles );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 1168 : 
; 1169 : 	// calculate constant acceleration from speed and distance
; 1170 : 	m_accel = (pev->speed * pev->speed) / ( 2 * fabs( m_distance ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+504]
	fmul	DWORD PTR [edx+504]
	fstp	QWORD PTR -36+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1796]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fadd	ST(0), ST(0)
	fdivr	QWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1792]

; 1171 : 	m_maxSpeed = pev->speed;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+504]
	mov	DWORD PTR [ecx+1808], edx

; 1172 : 	m_start = GetLocalAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1828				; 00000724H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1173 : 	m_center = GetLocalAngles() + ( m_distance * 0.5f ) * pev->movedir;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1796]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40075[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T40076[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1816				; 00000718H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1174 : 
; 1175 : 	m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 1176 : 
; 1177 : 	if( FBitSet( pev->spawnflags, SF_PENDULUM_START_ON ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L38186

; 1179 : 		SetThink( SUB_CallUseToggle );

	push	OFFSET FLAT:??_C@_0BC@FMAO@SUB_CallUseToggle?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_CallUseToggle@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_CallUseToggle
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1180 : 		SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]
$L38186:

; 1182 : 	pev->speed = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+504], 0

; 1183 : 
; 1184 : 	if( FBitSet( pev->spawnflags, SF_PENDULUM_SWING ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 2
	test	edx, edx
	je	SHORT $L38189

; 1186 : 		SetTouch ( RopeTouch );

	push	OFFSET FLAT:??_C@_09LKMM@RopeTouch?$AA@	; `string'
	push	OFFSET FLAT:?RopeTouch@CPendulum@@QAEXPAVCBaseEntity@@@Z ; CPendulum::RopeTouch
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet
$L38189:
$L38178:

; 1188 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CPendulum@@UAEXXZ ENDP				; CPendulum::Spawn
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
$T40081 = -16
___$ReturnUdt$ = 8
_this$ = -4
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40081[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT
$T40084 = -12
_fl$ = 12
_v$ = 16
___$ReturnUdt$ = 8
??D@YA?AVVector@@MABV0@@Z PROC NEAR			; operator*, COMDAT

; 288  : inline Vector operator* ( float fl, const Vector& v ) { return v * fl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40084[ebp]
	push	ecx
	mov	ecx, DWORD PTR _v$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??D@YA?AVVector@@MABV0@@Z ENDP				; operator*
_TEXT	ENDS
PUBLIC	?ENTINDEX@@YAHPAUedict_s@@@Z			; ENTINDEX
;	COMDAT ?entindex@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?entindex@CBaseEntity@@QAEHXZ PROC NEAR			; CBaseEntity::entindex, COMDAT

; 712  : 	int entindex( ) { return ENTINDEX( edict() ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?entindex@CBaseEntity@@QAEHXZ ENDP			; CBaseEntity::entindex
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT
_pEdict$ = 8
?ENTINDEX@@YAHPAUedict_s@@@Z PROC NEAR			; ENTINDEX, COMDAT

; 186  : inline int	  ENTINDEX(edict_t *pEdict)			{ return (*g_engfuncs.pfnIndexOfEdict)(pEdict); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+284
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENTINDEX@@YAHPAUedict_s@@@Z ENDP			; ENTINDEX
_TEXT	ENDS
PUBLIC	?Use@CPendulum@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CPendulum::Use
PUBLIC	??_C@_04BAK@NULL?$AA@				; `string'
EXTRN	?AxisDelta@CBaseToggle@@SAMHABVVector@@0@Z:NEAR	; CBaseToggle::AxisDelta
;	COMDAT ??_C@_04BAK@NULL?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_04BAK@NULL?$AA@ DB 'NULL', 00H			; `string'
CONST	ENDS
;	COMDAT ?Use@CPendulum@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
$T40091 = -20
_pActivator$ = 8
_this$ = -4
_delta$38203 = -8
?Use@CPendulum@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CPendulum::Use, COMDAT

; 1191 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1192 : 	if( IsLockedByMaster( pActivator ) || m_distance == 0 )

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z ; CBaseDelay::IsLockedByMaster
	test	eax, eax
	jne	SHORT $L38200
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1796]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38199
$L38200:

; 1193 : 		return;

	jmp	$L38198
$L38199:

; 1194 : 
; 1195 : 	if( pev->speed )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L38201

; 1197 : 		// pendulum is moving, stop it and auto-return if necessary
; 1198 : 		if( FBitSet( pev->spawnflags, SF_PENDULUM_AUTO_RETURN ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 16					; 00000010H
	test	eax, eax
	je	$L38202

; 1200 : 			float delta = CBaseToggle::AxisDelta( pev->spawnflags, GetLocalAngles(), m_start );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1828				; 00000724H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	push	ecx
	call	?AxisDelta@CBaseToggle@@SAMHABVVector@@0@Z ; CBaseToggle::AxisDelta
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _delta$38203[ebp]

; 1201 : 
; 1202 : 			SetLocalAvelocity( m_maxSpeed * pev->movedir );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1808]
	push	edx
	lea	eax, DWORD PTR $T40091[ebp]
	push	eax
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 1203 : 			SetNextThink( delta / m_maxSpeed );

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _delta$38203[ebp]
	fdiv	DWORD PTR [ecx+1808]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]

; 1204 : 			SetThink( Stop );

	push	OFFSET FLAT:??_C@_04DFLL@Stop?$AA@	; `string'
	push	OFFSET FLAT:?Stop@CPendulum@@QAEXXZ	; CPendulum::Stop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1206 : 		else

	jmp	SHORT $L38207
$L38202:

; 1208 : 			pev->speed = 0; // dead stop

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+504], 0

; 1209 : 			SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1210 : 			SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 1211 : 			m_iState = STATE_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 0
$L38207:

; 1214 : 	else

	jmp	SHORT $L38211
$L38201:

; 1216 : 		SetNextThink( 0.1f );		// start the pendulum moving

	push	1036831949				; 3dcccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 1217 : 		SetThink( Swing );

	push	OFFSET FLAT:??_C@_05KAHD@Swing?$AA@	; `string'
	push	OFFSET FLAT:?Swing@CPendulum@@QAEXXZ	; CPendulum::Swing
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1218 : 		m_time = gpGlobals->time;		// save time to calculate dt

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+1800], edx

; 1219 : 		m_dampSpeed = m_maxSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1808]
	mov	DWORD PTR [eax+1812], edx
$L38211:
$L38198:

; 1221 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CPendulum@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CPendulum::Use
_TEXT	ENDS
;	COMDAT ?Stop@CPendulum@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Stop@CPendulum@@QAEXXZ PROC NEAR			; CPendulum::Stop, COMDAT

; 1224 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1225 : 	SetLocalAngles( m_start );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1828				; 00000724H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 1226 : 	pev->speed = 0; // dead stop

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+504], 0

; 1227 : 	SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1228 : 	SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 1229 : 	m_iState = STATE_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 0

; 1230 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@CPendulum@@QAEXXZ ENDP				; CPendulum::Stop
_TEXT	ENDS
PUBLIC	?Blocked@CPendulum@@UAEXPAVCBaseEntity@@@Z	; CPendulum::Blocked
;	COMDAT ?Blocked@CPendulum@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
?Blocked@CPendulum@@UAEXPAVCBaseEntity@@@Z PROC NEAR	; CPendulum::Blocked, COMDAT

; 1233 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1234 : 	m_time = gpGlobals->time;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+1800], edx

; 1235 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CPendulum@@UAEXPAVCBaseEntity@@@Z ENDP		; CPendulum::Blocked
_TEXT	ENDS
PUBLIC	__real@8@4003f000000000000000
;	COMDAT __real@8@4003f000000000000000
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
__real@8@4003f000000000000000 DQ 0403e000000000000r ; 30
CONST	ENDS
;	COMDAT ?Swing@CPendulum@@QAEXXZ
_TEXT	SEGMENT
$T40102 = -24
_this$ = -4
_delta$ = -8
_dt$ = -12
?Swing@CPendulum@@QAEXXZ PROC NEAR			; CPendulum::Swing, COMDAT

; 1238 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1239 : 	float delta, dt;
; 1240 : 	
; 1241 : 	delta = CBaseToggle::AxisDelta( pev->spawnflags, GetLocalAngles(), m_center );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1816				; 00000718H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	push	eax
	call	?AxisDelta@CBaseToggle@@SAMHABVVector@@0@Z ; CBaseToggle::AxisDelta
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _delta$[ebp]

; 1242 : 
; 1243 : 	dt = gpGlobals->time - m_time;	// how much time has passed?

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx+1800]
	fstp	DWORD PTR _dt$[ebp]

; 1244 : 	m_time = gpGlobals->time;		// remember the last time called

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+1800], edx

; 1245 : 
; 1246 : 	// integrate velocity
; 1247 : 	if( delta > 0 && m_accel > 0 )

	fld	DWORD PTR _delta$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38230
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1792]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38230

; 1248 : 		pev->speed -= m_accel * dt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _dt$[ebp]
	fmul	DWORD PTR [eax+1792]
	fsubr	DWORD PTR [edx+504]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+504]

; 1249 : 	else pev->speed += m_accel * dt;

	jmp	SHORT $L38231
$L38230:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _dt$[ebp]
	fmul	DWORD PTR [edx+1792]
	fadd	DWORD PTR [ecx+504]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+504]
$L38231:

; 1250 : 
; 1251 : 	pev->speed = bound( -m_maxSpeed, pev->speed, m_maxSpeed );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1808]
	fchs
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40100
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1808]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40098
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+504]
	fstp	DWORD PTR -28+[ebp]
	jmp	SHORT $L40099
$L40098:
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1808]
	fstp	DWORD PTR -28+[ebp]
$L40099:
	mov	edx, DWORD PTR -28+[ebp]
	mov	DWORD PTR -32+[ebp], edx
	jmp	SHORT $L40101
$L40100:
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1808]
	fchs
	fstp	DWORD PTR -32+[ebp]
$L40101:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR -32+[ebp]
	mov	DWORD PTR [edx+504], eax

; 1252 : 
; 1253 : 	m_iState = STATE_ON;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 1

; 1254 : 
; 1255 : 	// scale the destdelta vector by the time spent traveling to get velocity
; 1256 : 	SetLocalAvelocity( pev->speed * pev->movedir );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	push	eax
	lea	ecx, DWORD PTR $T40102[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 1257 : 
; 1258 : 	// call this again
; 1259 : 	SetNextThink( 0.1f );

	push	1036831949				; 3dcccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]

; 1260 : 	SetMoveDoneTime( 0.1f );

	push	1036831949				; 3dcccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 1261 : 
; 1262 : 	if( m_damp )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1804]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L38240

; 1264 : 		m_dampSpeed -= m_damp * m_dampSpeed * dt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1804]
	fmul	DWORD PTR [eax+1812]
	fmul	DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fsubr	DWORD PTR [ecx+1812]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1812]

; 1265 : 
; 1266 : 		if( m_dampSpeed < 30.0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1812]
	fcomp	QWORD PTR __real@8@4003f000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38234

; 1268 : 			SetLocalAngles( m_center );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1816				; 00000718H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 1269 : 			pev->speed = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+504], 0

; 1270 : 			SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1271 : 			SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 1272 : 			m_iState = STATE_OFF;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 0

; 1274 : 		else if( pev->speed > m_dampSpeed )

	jmp	SHORT $L38240
$L38234:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+504]
	fcomp	DWORD PTR [ecx+1812]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38238

; 1276 : 			pev->speed = m_dampSpeed;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1812]
	mov	DWORD PTR [eax+504], edx

; 1278 : 		else if( pev->speed < -m_dampSpeed )

	jmp	SHORT $L38240
$L38238:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1812]
	fchs
	fcomp	DWORD PTR [ecx+504]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38240

; 1280 : 			pev->speed = -m_dampSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1812]
	fchs
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+504]
$L38240:

; 1283 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Swing@CPendulum@@QAEXXZ ENDP				; CPendulum::Swing
_TEXT	ENDS
PUBLIC	?Touch@CPendulum@@UAEXPAVCBaseEntity@@@Z	; CPendulum::Touch
PUBLIC	__real@8@3ff8a3d70a3d70a3d800
;	COMDAT __real@8@3ff8a3d70a3d70a3d800
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
__real@8@3ff8a3d70a3d70a3d800 DQ 03f847ae147ae147br ; 0.01
CONST	ENDS
;	COMDAT ?Touch@CPendulum@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T40107 = -32
$T40108 = -44
$T40109 = -56
_pOther$ = 8
_this$ = -4
_damage$ = -8
_vNewVel$ = -20
?Touch@CPendulum@@UAEXPAVCBaseEntity@@@Z PROC NEAR	; CPendulum::Touch, COMDAT

; 1286 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1287 : 	if( pev->dmg <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+480]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38245

; 1288 : 		return;

	jmp	$L38244
$L38245:

; 1289 : 
; 1290 : 	// we can't hurt this thing, so we're not concerned with it
; 1291 : 	if( !pOther->pev->takedamage )

	mov	edx, DWORD PTR _pOther$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38246

; 1292 : 		return;

	jmp	$L38244
$L38246:

; 1293 : 
; 1294 : 	// calculate damage based on rotation speed
; 1295 : 	float damage = pev->dmg * pev->speed * 0.01;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [edx+480]
	fmul	DWORD PTR [ecx+504]
	fmul	QWORD PTR __real@8@3ff8a3d70a3d70a3d800
	fstp	DWORD PTR _damage$[ebp]

; 1296 : 
; 1297 : 	if( damage < 0 ) damage = -damage;

	fld	DWORD PTR _damage$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38248
	fld	DWORD PTR _damage$[ebp]
	fchs
	fstp	DWORD PTR _damage$[ebp]
$L38248:

; 1298 : 
; 1299 : 	pOther->TakeDamage( pev, pev, damage, DMG_CRUSH );

	push	1
	mov	edx, DWORD PTR _damage$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+96]

; 1300 : 
; 1301 : 	Vector vNewVel = (pOther->GetAbsOrigin( ) - GetAbsOrigin( )).Normalize();

	lea	eax, DWORD PTR $T40108[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T40107[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	push	eax
	lea	ecx, DWORD PTR _vNewVel$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1302 : 	pOther->SetAbsVelocity( vNewVel * damage );

	mov	edx, DWORD PTR _damage$[ebp]
	push	edx
	lea	eax, DWORD PTR $T40109[ebp]
	push	eax
	lea	ecx, DWORD PTR _vNewVel$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L38244:

; 1303 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CPendulum@@UAEXPAVCBaseEntity@@@Z ENDP		; CPendulum::Touch
_TEXT	ENDS
PUBLIC	??_C@_0O@LOEB@Not?5a?5client?6?$AA@		; `string'
;	COMDAT ??_C@_0O@LOEB@Not?5a?5client?6?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0O@LOEB@Not?5a?5client?6?$AA@ DB 'Not a client', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?RopeTouch@CPendulum@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
?RopeTouch@CPendulum@@QAEXPAVCBaseEntity@@@Z PROC NEAR	; CPendulum::RopeTouch, COMDAT

; 1306 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1307 : 	if( !pOther->IsPlayer( ))

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L38257

; 1309 : 		// not a player!
; 1310 : 		ALERT( at_console, "Not a client\n" );

	push	OFFSET FLAT:??_C@_0O@LOEB@Not?5a?5client?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1311 : 		return;

	jmp	SHORT $L38256
$L38257:

; 1313 : 
; 1314 : 	if( pOther->edict() == pev->enemy )

	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+400]
	jne	SHORT $L38259

; 1316 : 		// this player already on the rope.
; 1317 : 		return;

	jmp	SHORT $L38256
$L38259:

; 1319 : 
; 1320 : 	pev->enemy = pOther->edict();

	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+400], eax

; 1321 : 	pOther->SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1322 : 	pOther->pev->movetype = MOVETYPE_NONE;

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 0
$L38256:

; 1323 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RopeTouch@CPendulum@@QAEXPAVCBaseEntity@@@Z ENDP	; CPendulum::RopeTouch
_TEXT	ENDS
;	COMDAT _$E78
_TEXT	SEGMENT
_$E78	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E77
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E78	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncClock@@@@QAE@PBD@Z	; CEntityFactory<CFuncClock>::CEntityFactory<CFuncClock>
PUBLIC	??_C@_0L@MNFC@func_clock?$AA@			; `string'
_BSS	SEGMENT
	ALIGN	4

_func_clock DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0L@MNFC@func_clock?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0L@MNFC@func_clock?$AA@ DB 'func_clock', 00H	; `string'
CONST	ENDS
;	COMDAT _$E77
_TEXT	SEGMENT
_$E77	PROC NEAR					; COMDAT

; 1351 : LINK_ENTITY_TO_CLASS( func_clock, CFuncClock );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0L@MNFC@func_clock?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_clock
	call	??0?$CEntityFactory@VCFuncClock@@@@QAE@PBD@Z ; CEntityFactory<CFuncClock>::CEntityFactory<CFuncClock>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E77	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CFuncClock@@UAEPAUdatamap_s@@XZ	; CFuncClock::GetDataDescMap
;	COMDAT ?GetDataDescMap@CFuncClock@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CFuncClock@@UAEPAUdatamap_s@@XZ PROC NEAR ; CFuncClock::GetDataDescMap, COMDAT

; 1353 : BEGIN_DATADESC( CFuncClock )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncClock@@2Udatamap_s@@A ; CFuncClock::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CFuncClock@@UAEPAUdatamap_s@@XZ ENDP	; CFuncClock::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CFuncClock@@SAPAUdatamap_s@@XZ	; CFuncClock::GetBaseMap
;	COMDAT ?GetBaseMap@CFuncClock@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CFuncClock@@SAPAUdatamap_s@@XZ PROC NEAR	; CFuncClock::GetBaseMap, COMDAT

; 1353 : BEGIN_DATADESC( CFuncClock )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CFuncClock@@SAPAUdatamap_s@@XZ ENDP		; CFuncClock::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E81
_TEXT	SEGMENT
_$E81	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E80
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E81	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z	; DataMapInit
;	COMDAT _$E80
_TEXT	SEGMENT
_$E80	PROC NEAR					; COMDAT

; 1353 : BEGIN_DATADESC( CFuncClock )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CFuncClock_DataDescInit@@3PAUdatamap_s@@A, eax ; CFuncClock_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E80	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S83@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z PROC NEAR ; DataMapInit, COMDAT

; 1353 : BEGIN_DATADESC( CFuncClock )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S83@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L38372
	mov	cl, BYTE PTR _?$S83@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S83@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0L@EECC@CFuncClock?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E84
	call	_atexit
	add	esp, 4
$L38372:
	call	?GetBaseMap@CFuncClock@@SAPAUdatamap_s@@XZ ; CFuncClock::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CFuncClock@@2Udatamap_s@@A+12, eax

; 1354 : 	DEFINE_FIELD( m_vecCurtime, FIELD_VECTOR ),
; 1355 : 	DEFINE_FIELD( m_vecFinaltime, FIELD_VECTOR ),
; 1356 : 	DEFINE_FIELD( m_flCurTime, FIELD_VECTOR ),
; 1357 : 	DEFINE_FIELD( m_iClockType, FIELD_INTEGER ),
; 1358 : 	DEFINE_FIELD( m_iHoursCount, FIELD_INTEGER ),
; 1359 : 	DEFINE_FIELD( m_fInit, FIELD_BOOLEAN ),
; 1360 : END_DATADESC()

	mov	edx, 1
	test	edx, edx
	je	SHORT $L38394
	mov	DWORD PTR ?m_DataMap@CFuncClock@@2Udatamap_s@@A+4, 6
	mov	DWORD PTR ?m_DataMap@CFuncClock@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L38395
$L38394:
	mov	DWORD PTR ?m_DataMap@CFuncClock@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncClock@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z@4PAUtypedescription_s@@A
$L38395:
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncClock@@2Udatamap_s@@A ; CFuncClock::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z ENDP	; DataMapInit
_TEXT	ENDS
;	COMDAT _$E84
_TEXT	SEGMENT
_$E84	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncClock@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E84	ENDP
_TEXT	ENDS
PUBLIC	?KeyValue@CFuncClock@@UAEXPAUKeyValueData_s@@@Z	; CFuncClock::KeyValue
PUBLIC	??_C@_04PIKN@type?$AA@				; `string'
PUBLIC	??_C@_07EEJG@curtime?$AA@			; `string'
PUBLIC	??_C@_05MNCH@event?$AA@				; `string'
PUBLIC	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
;	COMDAT ??_C@_04PIKN@type?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_04PIKN@type?$AA@ DB 'type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEJG@curtime?$AA@
CONST	SEGMENT
??_C@_07EEJG@curtime?$AA@ DB 'curtime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNCH@event?$AA@
CONST	SEGMENT
??_C@_05MNCH@event?$AA@ DB 'event', 00H			; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CFuncClock@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
$T40132 = -16
_pkvd$ = 8
_this$ = -4
?KeyValue@CFuncClock@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CFuncClock::KeyValue, COMDAT

; 1363 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1364 : 	if( FStrEq( pkvd->szKeyName, "type" ))

	push	OFFSET FLAT:??_C@_04PIKN@type?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38401

; 1367 : 		{

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -20+[ebp], eax
	cmp	DWORD PTR -20+[ebp], 1
	je	SHORT $L38407
	cmp	DWORD PTR -20+[ebp], 2
	je	SHORT $L38408
	jmp	SHORT $L38409
$L38407:

; 1368 : 		case 1:
; 1369 : 			m_iClockType = SECONDS_PER_HOUR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1820], 3600		; 00000e10H

; 1370 : 			break;

	jmp	SHORT $L38404
$L38408:

; 1371 : 		case 2:
; 1372 : 			m_iClockType = SECODNS_PER_DAY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1820], 43200		; 0000a8c0H

; 1373 : 			break;

	jmp	SHORT $L38404
$L38409:

; 1374 : 		default:
; 1375 : 			m_iClockType = SECONDS_PER_MINUTE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1820], 60		; 0000003cH
$L38404:

; 1378 : 		pkvd->fHandled = TRUE;

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 1380 : 	else if( FStrEq( pkvd->szKeyName, "curtime" ))

	jmp	$L38417
$L38401:
	push	OFFSET FLAT:??_C@_07EEJG@curtime?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38411

; 1382 : 		m_vecCurtime = Q_atov( pkvd->szValue );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR $T40132[ebp]
	push	eax
	call	?Q_atov@@YA?AVVector@@PBD@Z		; Q_atov
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1792				; 00000700H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1383 : 		pkvd->fHandled = TRUE;

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 1385 : 	else if( FStrEq( pkvd->szKeyName, "event" ))

	jmp	SHORT $L38417
$L38411:
	push	OFFSET FLAT:??_C@_05MNCH@event?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38415

; 1387 : 		pev->netname = ALLOC_STRING( pkvd->szValue );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+464], eax

; 1388 : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 1390 : 	else CBaseEntity::KeyValue( pkvd );

	jmp	SHORT $L38417
$L38415:
	mov	ecx, DWORD PTR _pkvd$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
$L38417:

; 1391 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CFuncClock@@UAEXPAUKeyValueData_s@@@Z ENDP	; CFuncClock::KeyValue
_TEXT	ENDS
PUBLIC	??_C@_06FOPF@parent?$AA@			; `string'
PUBLIC	??_C@_08IDGH@movewith?$AA@			; `string'
PUBLIC	??_C@_0M@FCIN@parentflags?$AA@			; `string'
PUBLIC	??_C@_05JCDO@style?$AA@				; `string'
PUBLIC	??_C@_0L@MCHI@reflection?$AA@			; `string'
PUBLIC	??_C@_0N@DCCA@vlight_cache?$AA@			; `string'
EXTRN	_atoi:NEAR
;	COMDAT ??_C@_06FOPF@parent?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_06FOPF@parent?$AA@ DB 'parent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT
??_C@_08IDGH@movewith?$AA@ DB 'movewith', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT
??_C@_0M@FCIN@parentflags?$AA@ DB 'parentflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT
??_C@_05JCDO@style?$AA@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT
??_C@_0L@MCHI@reflection?$AA@ DB 'reflection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT
??_C@_0N@DCCA@vlight_cache?$AA@ DB 'vlight_cache', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pkvd$ = 8
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseEntity::KeyValue, COMDAT

; 328  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 		// get support for spirit field too
; 330  : 		if( FStrEq( pkvd->szKeyName, "parent" ) || FStrEq( pkvd->szKeyName, "movewith" ))

	push	OFFSET FLAT:??_C@_06FOPF@parent?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L34875
	push	OFFSET FLAT:??_C@_08IDGH@movewith?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34874
$L34875:

; 332  : 			m_iParent = ALLOC_STRING(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 333  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 335  : 		else if( FStrEq( pkvd->szKeyName, "parentflags" ))

	jmp	$L34896
$L34874:
	push	OFFSET FLAT:??_C@_0M@FCIN@parentflags?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34879

; 337  : 			m_iParentFlags = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 338  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 340  : 		else if( FStrEq( pkvd->szKeyName, "style" ))

	jmp	$L34896
$L34879:
	push	OFFSET FLAT:??_C@_05JCDO@style?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34882

; 342  : 			m_iStyle = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 343  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 345  : 		else if( FStrEq( pkvd->szKeyName, "reflection" ))

	jmp	$L34896
$L34882:
	push	OFFSET FLAT:??_C@_0L@MCHI@reflection?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34885

; 348  : 			{

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L34891
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L34892
	jmp	SHORT $L34888
$L34891:

; 349  : 			case 1: pev->effects |= EF_NOREFLECT; break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
	jmp	SHORT $L34888
$L34892:

; 350  : 			case 2: pev->effects |= EF_REFLECTONLY; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L34888:

; 352  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 354  : 		else if( FStrEq(pkvd->szKeyName, "vlight_cache"))

	jmp	SHORT $L34896
$L34885:
	push	OFFSET FLAT:??_C@_0N@DCCA@vlight_cache?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34894

; 356  : 			pev->iuser3 = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+588], eax

; 357  : 			pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 359  : 		else pkvd->fHandled = FALSE;

	jmp	SHORT $L34896
$L34894:
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L34896:

; 360  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseEntity::KeyValue
_TEXT	ENDS
PUBLIC	__real@4@4002b000000000000000
PUBLIC	__real@4@4004ec00000000000000
PUBLIC	__real@4@4004f000000000000000
PUBLIC	__real@4@400ae100000000000000
PUBLIC	?Spawn@CFuncClock@@UAEXXZ			; CFuncClock::Spawn
;	COMDAT __real@4@4002b000000000000000
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
__real@4@4002b000000000000000 DD 041300000r	; 11
CONST	ENDS
;	COMDAT __real@4@4004ec00000000000000
CONST	SEGMENT
__real@4@4004ec00000000000000 DD 0426c0000r	; 59
CONST	ENDS
;	COMDAT __real@4@4004f000000000000000
CONST	SEGMENT
__real@4@4004f000000000000000 DD 042700000r	; 60
CONST	ENDS
;	COMDAT __real@4@400ae100000000000000
CONST	SEGMENT
__real@4@400ae100000000000000 DD 045610000r	; 3600
CONST	ENDS
;	COMDAT ?Spawn@CFuncClock@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CFuncClock@@UAEXXZ PROC NEAR			; CFuncClock::Spawn, COMDAT

; 1394 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1395 : 	CBaseToggle::AxisDir( pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?AxisDir@CBaseToggle@@SAXPAUentvars_s@@@Z ; CBaseToggle::AxisDir
	add	esp, 4

; 1396 : 
; 1397 : 	m_iState = STATE_ON;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 1

; 1398 : 	pev->solid = SOLID_NOT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 0

; 1399 : 
; 1400 : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 1401 : 	
; 1402 : 	if( m_iClockType == SECODNS_PER_DAY )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1820], 43200		; 0000a8c0H
	jne	$L38422

; 1404 : 		// normalize our time
; 1405 : 		if( m_vecCurtime.x > 11 ) m_vecCurtime.x = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1792]
	fcomp	DWORD PTR __real@4@4002b000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38423
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1792], 0
$L38423:

; 1406 : 		if( m_vecCurtime.y > 59 ) m_vecCurtime.y = 0;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1796]
	fcomp	DWORD PTR __real@4@4004ec00000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38424
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1796], 0
$L38424:

; 1407 : 		if( m_vecCurtime.z > 59 ) m_vecCurtime.z = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1800]
	fcomp	DWORD PTR __real@4@4004ec00000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38425
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1800], 0
$L38425:

; 1408 : 		
; 1409 : 		// member full hours
; 1410 : 		m_iHoursCount = m_vecCurtime.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1792]
	call	__ftol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1824], eax

; 1411 : 		
; 1412 : 		// calculate seconds
; 1413 : 		m_vecFinaltime.z = m_vecCurtime.z * ( SECONDS_PER_MINUTE / 60 );

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1800]
	fmul	DWORD PTR __real@4@3fff8000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1812]

; 1414 :                     m_vecFinaltime.y = m_vecCurtime.y * ( SECONDS_PER_HOUR / 60 ) + m_vecFinaltime.z;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1796]
	fmul	DWORD PTR __real@4@4004f000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+1812]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1808]

; 1415 :                     m_vecFinaltime.x = m_vecCurtime.x * ( SECODNS_PER_DAY / 12 ) + m_vecFinaltime.y;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1792]
	fmul	DWORD PTR __real@4@400ae100000000000000
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+1808]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1804]
$L38422:

; 1417 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncClock@@UAEXXZ ENDP				; CFuncClock::Spawn
_TEXT	ENDS
PUBLIC	?Activate@CFuncClock@@UAEXXZ			; CFuncClock::Activate
EXTRN	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z:NEAR ; UTIL_FindEntityInSphere
;	COMDAT ?Activate@CFuncClock@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pEntity$38432 = -8
_pClock$38437 = -12
?Activate@CFuncClock@@UAEXXZ PROC NEAR			; CFuncClock::Activate, COMDAT

; 1420 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 	if( m_fInit ) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1828], 0
	je	SHORT $L38430
	jmp	$L38429
$L38430:

; 1422 : 
; 1423 : 	if( m_iClockType == SECODNS_PER_DAY && m_vecCurtime != g_vecZero )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1820], 43200		; 0000a8c0H
	jne	$L38435
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1792				; 00000700H
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	$L38435

; 1425 : 		// try to find minutes and seconds entity
; 1426 : 		CBaseEntity *pEntity = NULL;

	mov	DWORD PTR _pEntity$38432[ebp], 0
$L38434:

; 1427 : 		while( pEntity = UTIL_FindEntityInSphere( pEntity, GetLocalOrigin(), pev->size.z ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+252]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	mov	edx, DWORD PTR _pEntity$38432[ebp]
	push	edx
	call	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z ; UTIL_FindEntityInSphere
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pEntity$38432[ebp], eax
	cmp	DWORD PTR _pEntity$38432[ebp], 0
	je	SHORT $L38435

; 1429 : 			if( FClassnameIs( pEntity, "func_clock" ))

	push	OFFSET FLAT:??_C@_0L@MNFC@func_clock?$AA@ ; `string'
	mov	eax, DWORD PTR _pEntity$38432[ebp]
	push	eax
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L38440

; 1431 : 				CFuncClock *pClock = (CFuncClock *)pEntity;

	mov	ecx, DWORD PTR _pEntity$38432[ebp]
	mov	DWORD PTR _pClock$38437[ebp], ecx

; 1434 : 				{

	mov	edx, DWORD PTR _pClock$38437[ebp]
	mov	eax, DWORD PTR [edx+1820]
	mov	DWORD PTR -16+[ebp], eax
	cmp	DWORD PTR -16+[ebp], 3600		; 00000e10H
	je	SHORT $L38444
	cmp	DWORD PTR -16+[ebp], 43200		; 0000a8c0H
	je	SHORT $L38443
	jmp	SHORT $L38445
$L38443:

; 1435 : 				case SECODNS_PER_DAY:
; 1436 : 					// NOTE: here we set time for himself through FindEntityInSphere
; 1437 : 					pClock->m_flCurTime = m_vecFinaltime.x;

	mov	ecx, DWORD PTR _pClock$38437[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1804]
	mov	DWORD PTR [ecx+1816], eax

; 1438 : 					break;

	jmp	SHORT $L38440
$L38444:

; 1439 : 				case SECONDS_PER_HOUR:
; 1440 : 					pClock->m_flCurTime = m_vecFinaltime.y;

	mov	ecx, DWORD PTR _pClock$38437[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1808]
	mov	DWORD PTR [ecx+1816], eax

; 1441 : 					break;

	jmp	SHORT $L38440
$L38445:

; 1442 : 				default:
; 1443 : 					pClock->m_flCurTime = m_vecFinaltime.z;

	mov	ecx, DWORD PTR _pClock$38437[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1812]
	mov	DWORD PTR [ecx+1816], eax
$L38440:

; 1447 : 		}

	jmp	$L38434
$L38435:

; 1449 : 
; 1450 : 	// clock start	
; 1451 : 	SetNextThink( 0 );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 1452 : 	m_fInit = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1828], 1
$L38429:

; 1453 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CFuncClock@@UAEXXZ ENDP			; CFuncClock::Activate
_TEXT	ENDS
PUBLIC	?Think@CFuncClock@@UAEXXZ			; CFuncClock::Think
EXTRN	_floor:NEAR
;	COMDAT ?Think@CFuncClock@@UAEXXZ
_TEXT	SEGMENT
$T40149 = -32
_this$ = -4
_seconds$ = -8
_ang$ = -12
_pos$ = -16
_hours$38455 = -20
?Think@CFuncClock@@UAEXXZ PROC NEAR			; CFuncClock::Think, COMDAT

; 1456 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1457 : 	float seconds, ang, pos;
; 1458 : 
; 1459 : 	seconds = gpGlobals->time + m_flCurTime;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx+1816]
	fstp	DWORD PTR _seconds$[ebp]

; 1460 : 	pos = seconds / m_iClockType;

	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx+1820]
	fdivr	DWORD PTR _seconds$[ebp]
	fst	DWORD PTR _pos$[ebp]

; 1461 : 	pos = pos - floor( pos );

	fstp	QWORD PTR -40+[ebp]
	fld	DWORD PTR _pos$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fsubr	QWORD PTR -40+[ebp]
	fstp	DWORD PTR _pos$[ebp]

; 1462 : 	ang = 360 * pos;

	fld	DWORD PTR __real@4@4007b400000000000000
	fmul	DWORD PTR _pos$[ebp]
	fstp	DWORD PTR _ang$[ebp]

; 1463 : 
; 1464 : 	SetLocalAngles( pev->movedir * ang );

	mov	eax, DWORD PTR _ang$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40149[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 1465 : 
; 1466 : 	if( m_iClockType == SECODNS_PER_DAY )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1820], 43200		; 0000a8c0H
	jne	$L38456

; 1468 : 		int hours = GetLocalAngles().Length() / 30;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fdiv	DWORD PTR __real@4@4003f000000000000000
	call	__ftol
	mov	DWORD PTR _hours$38455[ebp], eax

; 1469 : 		if( m_iHoursCount != hours )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1824]
	cmp	edx, DWORD PTR _hours$38455[ebp]
	je	SHORT $L38456

; 1471 : 			// member new hour
; 1472 : 			m_iHoursCount = hours;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _hours$38455[ebp]
	mov	DWORD PTR [eax+1824], ecx

; 1473 : 			if( hours == 0 ) hours = 12;	// merge for 0.00.00

	cmp	DWORD PTR _hours$38455[ebp], 0
	jne	SHORT $L38457
	mov	DWORD PTR _hours$38455[ebp], 12		; 0000000cH
$L38457:

; 1474 : 
; 1475 : 			// send hours info
; 1476 : 			UTIL_FireTargets( pev->netname, this, this, USE_SET, hours );

	fild	DWORD PTR _hours$38455[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+464]
	push	eax
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 1477 : 			UTIL_FireTargets( pev->netname, this, this, USE_ON );

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L38456:

; 1480 : 
; 1481 : 	RelinkEntity( FALSE );

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 1482 : 
; 1483 : 	// set clock resolution
; 1484 : 	SetNextThink( 1.0f );

	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 1485 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CFuncClock@@UAEXXZ ENDP				; CFuncClock::Think
_TEXT	ENDS
;	COMDAT _$E87
_TEXT	SEGMENT
_$E87	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E86
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E87	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncLight@@@@QAE@PBD@Z	; CEntityFactory<CFuncLight>::CEntityFactory<CFuncLight>
PUBLIC	??_C@_0L@KKKL@func_light?$AA@			; `string'
_BSS	SEGMENT
	ALIGN	4

_func_light DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0L@KKKL@func_light?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0L@KKKL@func_light?$AA@ DB 'func_light', 00H	; `string'
CONST	ENDS
;	COMDAT _$E86
_TEXT	SEGMENT
_$E86	PROC NEAR					; COMDAT

; 1508 : LINK_ENTITY_TO_CLASS( func_light, CFuncLight );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0L@KKKL@func_light?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_light
	call	??0?$CEntityFactory@VCFuncLight@@@@QAE@PBD@Z ; CEntityFactory<CFuncLight>::CEntityFactory<CFuncLight>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E86	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CFuncLight@@UAEPAUdatamap_s@@XZ	; CFuncLight::GetDataDescMap
;	COMDAT ?GetDataDescMap@CFuncLight@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CFuncLight@@UAEPAUdatamap_s@@XZ PROC NEAR ; CFuncLight::GetDataDescMap, COMDAT

; 1510 : BEGIN_DATADESC( CFuncLight )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncLight@@2Udatamap_s@@A ; CFuncLight::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CFuncLight@@UAEPAUdatamap_s@@XZ ENDP	; CFuncLight::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CFuncLight@@SAPAUdatamap_s@@XZ	; CFuncLight::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCBreakable@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CFuncLight@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CFuncLight@@SAPAUdatamap_s@@XZ PROC NEAR	; CFuncLight::GetBaseMap, COMDAT

; 1510 : BEGIN_DATADESC( CFuncLight )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBreakable@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CFuncLight@@SAPAUdatamap_s@@XZ ENDP		; CFuncLight::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E90
_TEXT	SEGMENT
_$E90	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E89
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E90	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z	; DataMapInit
;	COMDAT _$E89
_TEXT	SEGMENT
_$E89	PROC NEAR					; COMDAT

; 1510 : BEGIN_DATADESC( CFuncLight )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CFuncLight_DataDescInit@@3PAUdatamap_s@@A, eax ; CFuncLight_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E89	ENDP
_TEXT	ENDS
PUBLIC	?Flicker@CFuncLight@@QAEXXZ			; CFuncLight::Flicker
PUBLIC	??_C@_07MBCB@Flicker?$AA@			; `string'
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S92@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_07MBCB@Flicker?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_07MBCB@Flicker?$AA@ DB 'Flicker', 00H		; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z PROC NEAR ; DataMapInit, COMDAT

; 1510 : BEGIN_DATADESC( CFuncLight )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S92@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L38576
	mov	cl, BYTE PTR _?$S92@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S92@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0L@CDNL@CFuncLight?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E93
	call	_atexit
	add	esp, 4
$L38576:
	call	?GetBaseMap@CFuncLight@@SAPAUdatamap_s@@XZ ; CFuncLight::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CFuncLight@@2Udatamap_s@@A+12, eax

; 1511 : 	DEFINE_FIELD( m_iFlickerMode, FIELD_INTEGER ),
; 1512 : 	DEFINE_FIELD( m_flNextFlickerTime, FIELD_FLOAT ),
; 1513 : 	DEFINE_FIELD( m_vecLastDmgPoint, FIELD_POSITION_VECTOR ),
; 1514 : 	DEFINE_FUNCTION( Flicker ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S92@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	SHORT $L38589
	mov	al, BYTE PTR _?$S92@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S92@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_07MBCB@Flicker?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4PAUtypedescription_s@@A+100, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4PAUtypedescription_s@@A+104, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4PAUtypedescription_s@@A+108, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4PAUtypedescription_s@@A+110, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4PAUtypedescription_s@@A+112, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4PAUtypedescription_s@@A+116, OFFSET FLAT:?Flicker@CFuncLight@@QAEXXZ ; CFuncLight::Flicker
$L38589:

; 1515 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L38593
	mov	DWORD PTR ?m_DataMap@CFuncLight@@2Udatamap_s@@A+4, 4
	mov	DWORD PTR ?m_DataMap@CFuncLight@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L38594
$L38593:
	mov	DWORD PTR ?m_DataMap@CFuncLight@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncLight@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4PAUtypedescription_s@@A
$L38594:
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncLight@@2Udatamap_s@@A ; CFuncLight::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z ENDP	; DataMapInit
_TEXT	ENDS
;	COMDAT _$E93
_TEXT	SEGMENT
_$E93	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncLight@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E93	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CFuncLight@@UAEXXZ			; CFuncLight::Spawn
PUBLIC	??_C@_0DB@LGDD@?$CFs?5with?5name?5?$CFs?5has?5bad?5lightsty@ ; `string'
PUBLIC	??_C@_0CJ@CNNL@?$CFs?5?$FL?$CFi?$FN?5has?5bad?5lightstyle?5?$CFi?4?5D@ ; `string'
EXTRN	?Spawn@CBreakable@@UAEXXZ:NEAR			; CBreakable::Spawn
;	COMDAT ??_C@_0DB@LGDD@?$CFs?5with?5name?5?$CFs?5has?5bad?5lightsty@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0DB@LGDD@?$CFs?5with?5name?5?$CFs?5has?5bad?5lightsty@ DB '%s with '
	DB	'name %s has bad lightstyle %i. Disabled', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CNNL@?$CFs?5?$FL?$CFi?$FN?5has?5bad?5lightstyle?5?$CFi?4?5D@
CONST	SEGMENT
??_C@_0CJ@CNNL@?$CFs?5?$FL?$CFi?$FN?5has?5bad?5lightstyle?5?$CFi?4?5D@ DB '%'
	DB	's [%i] has bad lightstyle %i. Disabled', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?Spawn@CFuncLight@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CFuncLight@@UAEXXZ PROC NEAR			; CFuncLight::Spawn, COMDAT

; 1518 : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1519 : 	m_Material = matGlass;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1792], 0

; 1520 : 
; 1521 : 	CBreakable::Spawn();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Spawn@CBreakable@@UAEXXZ		; CBreakable::Spawn

; 1522 : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 1523 : 
; 1524 : 	// probably map compiler haven't func_light support
; 1525 : 	if( m_iStyle <= 0 || m_iStyle >= 256 )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+64], 0
	jle	SHORT $L38601
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+64], 256			; 00000100H
	jl	SHORT $L38600
$L38601:

; 1527 : 		if( GetTargetname()[0] )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $L38602

; 1528 : 			ALERT( at_error, "%s with name %s has bad lightstyle %i. Disabled\n", GetClassname(), GetTargetname(), m_iStyle );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0DB@LGDD@?$CFs?5with?5name?5?$CFs?5has?5bad?5lightsty@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H

; 1529 : 		else ALERT( at_error, "%s [%i] has bad lightstyle %i. Disabled\n", GetClassname(), entindex(), m_iStyle );

	jmp	SHORT $L38604
$L38602:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CJ@CNNL@?$CFs?5?$FL?$CFi?$FN?5has?5bad?5lightstyle?5?$CFi?4?5D@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L38604:

; 1530 : 		m_iState = STATE_DEAD; // lamp is dead

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 5
$L38600:

; 1532 : 	
; 1533 : 	if( FBitSet( pev->spawnflags, SF_LIGHT_START_ON ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1
	test	edx, edx
	je	SHORT $L38606

; 1534 : 		Use( this, this, USE_ON, 0 );

	push	0
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+276]

; 1535 : 	else Use( this, this, USE_OFF, 0 );

	jmp	SHORT $L38607
$L38606:
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+276]
$L38607:

; 1536 : 
; 1537 : 	if( pev->health <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38608

; 1538 : 		pev->takedamage = DAMAGE_NO;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+364], 0

; 1539 : 	else pev->takedamage = DAMAGE_YES;

	jmp	SHORT $L38609
$L38608:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+364], 1065353216		; 3f800000H
$L38609:

; 1540 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncLight@@UAEXXZ ENDP				; CFuncLight::Spawn
_TEXT	ENDS
PUBLIC	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z		; EHANDLE::operator=
PUBLIC	?Use@CFuncLight@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncLight::Use
PUBLIC	?Die@CFuncLight@@QAEXXZ				; CFuncLight::Die
PUBLIC	??_C@_0BK@CINK@mmamammmmammamamaaamammma?$AA@	; `string'
PUBLIC	??_C@_01FMCB@k?$AA@				; `string'
EXTRN	?IsLockedByMaster@CBaseDelay@@QAEHXZ:NEAR	; CBaseDelay::IsLockedByMaster
;	COMDAT ??_C@_0BK@CINK@mmamammmmammamamaaamammma?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0BK@CINK@mmamammmmammamamaaamammma?$AA@ DB 'mmamammmmammamamaaamamm'
	DB	'ma', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01FMCB@k?$AA@
CONST	SEGMENT
??_C@_01FMCB@k?$AA@ DB 'k', 00H				; `string'
CONST	ENDS
;	COMDAT ?Use@CFuncLight@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_this$ = -4
?Use@CFuncLight@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CFuncLight::Use, COMDAT

; 1543 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1544 : 	m_hActivator = pActivator;

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1545 : 	
; 1546 : 	if( IsLockedByMaster( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHXZ	; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L38617

; 1547 : 		return;

	jmp	$L38616
$L38617:

; 1548 : 
; 1549 : 	if( m_iState == STATE_DEAD )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1788], 5
	jne	SHORT $L38618

; 1550 : 		return; // lamp is broken

	jmp	$L38616
$L38618:

; 1551 : 
; 1552 : 	if( useType == USE_TOGGLE )

	cmp	DWORD PTR _useType$[ebp], 3
	jne	SHORT $L38621

; 1554 : 		if( m_iState == STATE_OFF )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1788], 0
	jne	SHORT $L38620

; 1555 : 			useType = USE_ON;

	mov	DWORD PTR _useType$[ebp], 1

; 1556 : 		else useType = USE_OFF;

	jmp	SHORT $L38621
$L38620:
	mov	DWORD PTR _useType$[ebp], 0
$L38621:

; 1558 : 
; 1559 : 	if( useType == USE_ON )

	cmp	DWORD PTR _useType$[ebp], 1
	jne	$L38622

; 1561 : 		if( m_flDelay )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1768]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38623

; 1563 : 			// make flickering delay
; 1564 : 			m_iState = STATE_TURN_ON;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 2

; 1565 : 			LIGHT_STYLE( m_iStyle, "mmamammmmammamamaaamammma" );

	push	OFFSET FLAT:??_C@_0BK@CINK@mmamammmmammamamaaamammma?$AA@ ; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8

; 1566 : 			pev->frame = 0; // light texture is on

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+304], 0

; 1567 : 			SetThink( Flicker );

	push	OFFSET FLAT:??_C@_07MBCB@Flicker?$AA@	; `string'
	push	OFFSET FLAT:?Flicker@CFuncLight@@QAEXXZ	; CFuncLight::Flicker
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1568 : 			SetNextThink( m_flDelay );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1768]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]

; 1570 : 		else

	jmp	SHORT $L38627
$L38623:

; 1572 : 			m_iState = STATE_ON;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 1

; 1573 : 			LIGHT_STYLE( m_iStyle, "k" );

	push	OFFSET FLAT:??_C@_01FMCB@k?$AA@		; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8

; 1574 : 			pev->frame = 0; // light texture is on

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+304], 0

; 1575 : 			UTIL_FireTargets( pev->target, this, this, USE_ON );

	push	0
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+456]
	push	ecx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L38627:

; 1578 : 	else if( useType == USE_OFF )

	jmp	SHORT $L38632
$L38622:
	cmp	DWORD PTR _useType$[ebp], 0
	jne	SHORT $L38630

; 1580 : 		LIGHT_STYLE( m_iStyle, "a" );

	push	OFFSET FLAT:??_C@_01FNLH@a?$AA@		; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8

; 1581 : 		UTIL_FireTargets( pev->target, this, this, USE_OFF );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+456]
	push	edx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 1582 : 		pev->frame = 1;// light texture is off

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+304], 1065353216		; 3f800000H

; 1583 : 		m_iState = STATE_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 0

; 1585 : 	else if( useType == USE_SET )

	jmp	SHORT $L38632
$L38630:
	cmp	DWORD PTR _useType$[ebp], 2
	jne	SHORT $L38632

; 1587 : 		// a script die (dramatic effect)
; 1588 : 		Die();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Die@CFuncLight@@QAEXXZ			; CFuncLight::Die
$L38632:
$L38616:

; 1590 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CFuncLight@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CFuncLight::Use
_TEXT	ENDS
EXTRN	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z:NEAR	; ENT
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z PROC NEAR	; EHANDLE::operator=, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 	if (pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L34280

; 72   : 		m_pent = ENT( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 73   : 		if (m_pent)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L34281

; 74   : 			m_serialnumber = m_pent->serialnumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$L34281:

; 76   : 	else

	jmp	SHORT $L34282
$L34280:

; 78   : 		m_pent = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 79   : 		m_serialnumber = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$L34282:

; 81   : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z ENDP		; EHANDLE::operator=
_TEXT	ENDS
PUBLIC	?TraceAttack@CFuncLight@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z ; CFuncLight::TraceAttack
PUBLIC	??_C@_03GODK@?$CL0?$HO?$AA@			; `string'
EXTRN	?TraceAttack@CBreakable@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBreakable::TraceAttack
EXTRN	?UTIL_Sparks@@YAXABVVector@@@Z:NEAR		; UTIL_Sparks
;	COMDAT ??_C@_03GODK@?$CL0?$HO?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_03GODK@?$CL0?$HO?$AA@ DB '+0~', 00H		; `string'
CONST	ENDS
;	COMDAT ?TraceAttack@CFuncLight@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
_TEXT	SEGMENT
$T40174 = -48
$T40175 = -60
$T40176 = -72
_pevAttacker$ = 8
_flDamage$ = 12
_vecDir$ = 16
_ptr$ = 28
_bitsDamageType$ = 32
_this$ = -4
_pTextureName$ = -8
_start$ = -20
_end$ = -32
_pHit$ = -36
?TraceAttack@CFuncLight@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z PROC NEAR ; CFuncLight::TraceAttack, COMDAT

; 1593 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1594 : 	if( pev->takedamage == DAMAGE_NO )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38641

; 1595 : 		return;

	jmp	$L38640
$L38641:

; 1596 : 
; 1597 : 	if( m_iState == STATE_DEAD )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1788], 5
	jne	SHORT $L38642

; 1598 : 		return;

	jmp	$L38640
$L38642:

; 1599 : 
; 1600 : 	const char *pTextureName = NULL;

	mov	DWORD PTR _pTextureName$[ebp], 0

; 1601 : 	Vector start = pevAttacker->origin + pevAttacker->view_ofs;

	mov	eax, DWORD PTR _pevAttacker$[ebp]
	add	eax, 372				; 00000174H
	push	eax
	lea	ecx, DWORD PTR $T40174[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	add	ecx, 8
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _start$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1602 : 	Vector end = start + vecDir * 1024;

	push	1149239296				; 44800000H
	lea	edx, DWORD PTR $T40175[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40176[ebp]
	push	eax
	lea	ecx, DWORD PTR _start$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _end$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1603 : 	edict_t *pHit = ptr->pHit;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _pHit$[ebp], edx

; 1604 : 
; 1605 : 	if( pHit )

	cmp	DWORD PTR _pHit$[ebp], 0
	je	SHORT $L38650

; 1606 : 		pTextureName = TRACE_TEXTURE( pHit, start, end );

	lea	ecx, DWORD PTR _end$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _start$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	eax, DWORD PTR _pHit$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+144
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTextureName$[ebp], eax
$L38650:

; 1607 : 
; 1608 : 	if( pTextureName != NULL && ( !Q_strncmp( pTextureName, "+0~", 3 ) || *pTextureName == '~' ))

	cmp	DWORD PTR _pTextureName$[ebp], 0
	je	SHORT $L38651
	push	3
	push	OFFSET FLAT:??_C@_03GODK@?$CL0?$HO?$AA@	; `string'
	mov	ecx, DWORD PTR _pTextureName$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L38652
	mov	edx, DWORD PTR _pTextureName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 126				; 0000007eH
	jne	SHORT $L38651
$L38652:

; 1610 : 		// take damage only at light texture
; 1611 : 		UTIL_Sparks( ptr->vecEndPos );

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	?UTIL_Sparks@@YAXABVVector@@@Z		; UTIL_Sparks
	add	esp, 4

; 1612 : 		m_vecLastDmgPoint = ptr->vecEndPos;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1820				; 0000071cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
$L38651:

; 1614 : 
; 1615 : 	CBreakable::TraceAttack( pevAttacker, flDamage, vecDir, ptr, bitsDamageType );

	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecDir$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR _flDamage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TraceAttack@CBreakable@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z ; CBreakable::TraceAttack
$L38640:

; 1616 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?TraceAttack@CFuncLight@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z ENDP ; CFuncLight::TraceAttack
_TEXT	ENDS
PUBLIC	__real@4@4000c000000000000000
PUBLIC	__real@4@3fff99999a0000000000
PUBLIC	?TakeDamage@CFuncLight@@UAEHPAUentvars_s@@0MH@Z	; CFuncLight::TakeDamage
EXTRN	?DamageSound@CBreakable@@QAEXXZ:NEAR		; CBreakable::DamageSound
;	COMDAT __real@4@4000c000000000000000
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
__real@4@4000c000000000000000 DD 040400000r	; 3
CONST	ENDS
;	COMDAT __real@4@3fff99999a0000000000
CONST	SEGMENT
__real@4@3fff99999a0000000000 DD 03f99999ar	; 1.2
CONST	ENDS
;	COMDAT ?TakeDamage@CFuncLight@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT
_flDamage$ = 16
_bitsDamageType$ = 20
_this$ = -4
?TakeDamage@CFuncLight@@UAEHPAUentvars_s@@0MH@Z PROC NEAR ; CFuncLight::TakeDamage, COMDAT

; 1619 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1620 : 	if( bitsDamageType & DMG_BLAST )

	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $L38662

; 1621 : 		flDamage *= 3.0f;

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR __real@4@4000c000000000000000
	fstp	DWORD PTR _flDamage$[ebp]

; 1622 : 	else if( bitsDamageType & DMG_CLUB )

	jmp	SHORT $L38670
$L38662:
	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	and	ecx, 128				; 00000080H
	test	ecx, ecx
	je	SHORT $L38664

; 1623 : 		flDamage *= 2.0f;

	fld	DWORD PTR _flDamage$[ebp]
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _flDamage$[ebp]

; 1624 : 	else if( bitsDamageType & DMG_SONIC )

	jmp	SHORT $L38670
$L38664:
	mov	edx, DWORD PTR _bitsDamageType$[ebp]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	SHORT $L38666

; 1625 : 		flDamage *= 1.2f;

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR __real@4@3fff99999a0000000000
	fstp	DWORD PTR _flDamage$[ebp]

; 1626 : 	else if( bitsDamageType & DMG_SHOCK )

	jmp	SHORT $L38670
$L38666:
	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $L38668

; 1627 : 		flDamage *= 10.0f;//!!!! over voltage

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR __real@4@4002a000000000000000
	fstp	DWORD PTR _flDamage$[ebp]

; 1628 : 	else if( bitsDamageType & DMG_BULLET )

	jmp	SHORT $L38670
$L38668:
	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L38670

; 1629 : 		flDamage *= 0.5f; // half damage at bullet

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fstp	DWORD PTR _flDamage$[ebp]
$L38670:

; 1630 : 
; 1631 : 	pev->health -= flDamage;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fsub	DWORD PTR _flDamage$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+352]

; 1632 : 
; 1633 : 	if( pev->health <= 0.0f )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38671

; 1635 : 		Die();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Die@CFuncLight@@QAEXXZ			; CFuncLight::Die

; 1636 : 		return 0;

	xor	eax, eax
	jmp	SHORT $L38661
$L38671:

; 1638 : 
; 1639 : 	CBreakable::DamageSound();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DamageSound@CBreakable@@QAEXXZ		; CBreakable::DamageSound

; 1640 : 
; 1641 : 	return 1;

	mov	eax, 1
$L38661:

; 1642 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TakeDamage@CFuncLight@@UAEHPAUentvars_s@@0MH@Z ENDP	; CFuncLight::TakeDamage
_TEXT	ENDS
PUBLIC	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z		; EMIT_SOUND
PUBLIC	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z		; MESSAGE_BEGIN
PUBLIC	??_C@_0BG@JCLM@debris?1bustglass1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BG@HCND@debris?1bustglass2?4wav?$AA@	; `string'
EXTRN	?DontThink@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::DontThink
;	COMDAT ??_C@_0BG@JCLM@debris?1bustglass1?4wav?$AA@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0BG@JCLM@debris?1bustglass1?4wav?$AA@ DB 'debris/bustglass1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCND@debris?1bustglass2?4wav?$AA@
CONST	SEGMENT
??_C@_0BG@HCND@debris?1bustglass2?4wav?$AA@ DB 'debris/bustglass2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?Die@CFuncLight@@QAEXXZ
_TEXT	SEGMENT
$T40188 = -28
$T40189 = -40
$T40190 = -52
_this$ = -4
_vecSpot$ = -16
?Die@CFuncLight@@QAEXXZ PROC NEAR			; CFuncLight::Die, COMDAT

; 1645 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1646 : 	// lamp is random choose die style
; 1647 : 	if( m_iState == STATE_OFF )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1788], 0
	jne	SHORT $L38676

; 1649 : 		pev->frame = 1; // light texture is off

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+304], 1065353216		; 3f800000H

; 1650 : 		LIGHT_STYLE( m_iStyle, "a" );

	push	OFFSET FLAT:??_C@_01FNLH@a?$AA@		; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8

; 1651 : 		DontThink();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DontThink@CBaseEntity@@QAEXXZ		; CBaseEntity::DontThink

; 1653 : 	else

	jmp	SHORT $L38677
$L38676:

; 1655 : 		m_iFlickerMode = RANDOM_LONG( 1, 2 );

	push	2
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1816], eax

; 1656 : 		SetThink( Flicker );

	push	OFFSET FLAT:??_C@_07MBCB@Flicker?$AA@	; `string'
	push	OFFSET FLAT:?Flicker@CFuncLight@@QAEXXZ	; CFuncLight::Flicker
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1657 : 		SetNextThink( 0.1f + RANDOM_LONG( 0.1f, 0.2f ));

	push	0
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR -56+[ebp], eax
	fild	DWORD PTR -56+[ebp]
	fadd	DWORD PTR __real@4@3ffbcccccd0000000000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]
$L38677:

; 1659 : 
; 1660 : 	m_iState = STATE_DEAD;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 5

; 1661 : 	pev->health = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+352], 0

; 1662 : 	pev->takedamage = DAMAGE_NO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+364], 0

; 1663 : 	UTIL_FireTargets( pev->target, this, this, USE_OFF );

	push	0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+456]
	push	eax
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 1666 : 	{

	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR -60+[ebp], eax
	cmp	DWORD PTR -60+[ebp], 0
	je	SHORT $L38684
	cmp	DWORD PTR -60+[ebp], 1
	je	SHORT $L38687
	jmp	SHORT $L38681
$L38684:

; 1667 : 	case 0:
; 1668 : 		EMIT_SOUND( edict(), CHAN_VOICE, "debris/bustglass1.wav", 0.7, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1060320051				; 3f333333H
	push	OFFSET FLAT:??_C@_0BG@JCLM@debris?1bustglass1?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1669 : 		break;

	jmp	SHORT $L38681
$L38687:

; 1670 : 	case 1:
; 1671 : 		EMIT_SOUND( edict(), CHAN_VOICE, "debris/bustglass2.wav", 0.8, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1061997773				; 3f4ccccdH
	push	OFFSET FLAT:??_C@_0BG@HCND@debris?1bustglass2?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L38681:

; 1674 : 
; 1675 : 	Vector vecSpot = GetAbsOrigin() + (pev->mins + pev->maxs) * 0.5f;

	push	1056964608				; 3f000000H
	lea	ecx, DWORD PTR $T40189[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 232				; 000000e8H
	push	eax
	lea	ecx, DWORD PTR $T40188[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 220				; 000000dcH
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40190[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecSpot$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1676 : 
; 1677 : 	MESSAGE_BEGIN( MSG_PVS, SVC_TEMPENTITY, vecSpot );

	push	0
	lea	ecx, DWORD PTR _vecSpot$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	push	23					; 00000017H
	push	4
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1678 : 		WRITE_BYTE( TE_BREAKMODEL );

	push	108					; 0000006cH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1679 : 		WRITE_COORD( vecSpot.x );

	mov	ecx, DWORD PTR _vecSpot$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1680 : 		WRITE_COORD( vecSpot.y );

	mov	edx, DWORD PTR _vecSpot$[ebp+4]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1681 : 		WRITE_COORD( vecSpot.z );

	mov	eax, DWORD PTR _vecSpot$[ebp+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1682 : 		WRITE_COORD( pev->size.x );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+244]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1683 : 		WRITE_COORD( pev->size.y );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+248]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1684 : 		WRITE_COORD( pev->size.z );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+252]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1685 : 		WRITE_COORD( 0 ); 

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1686 : 		WRITE_COORD( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1687 : 		WRITE_COORD( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1688 : 		WRITE_BYTE( 10 ); 

	push	10					; 0000000aH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1689 : 		WRITE_SHORT( m_idShard );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1800]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1690 : 		WRITE_BYTE( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1691 : 		WRITE_BYTE( 25 );

	push	25					; 00000019H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1692 : 		WRITE_BYTE( BREAK_GLASS );

	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1693 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 1694 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Die@CFuncLight@@QAEXXZ ENDP				; CFuncLight::Die
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_type$ = 12
_pOrigin$ = 16
_ed$ = 20
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z PROC NEAR	; MESSAGE_BEGIN, COMDAT

; 72   : inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin = NULL, edict_t *ed = NULL ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 73   : 	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ed);

	mov	eax, DWORD PTR _ed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+184
	add	esp, 16					; 00000010H

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z ENDP		; MESSAGE_BEGIN
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
_volume$ = 20
_attenuation$ = 24
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z PROC NEAR		; EMIT_SOUND, COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 610  : 	EMIT_SOUND_DYN( entity, channel, sample, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 611  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z ENDP		; EMIT_SOUND
_TEXT	ENDS
PUBLIC	__real@4@4001d000000000000000
PUBLIC	??_C@_0CC@ONJ@abcaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@	; `string'
PUBLIC	??_C@_0CC@BKKA@acaaabaaaaaaaaaaaaaaaaaaaaaaaaaa@ ; `string'
PUBLIC	??_C@_0CC@MFGL@aaafbaaaaaaaaaaaaaaaaaaaaaaaaaaa@ ; `string'
PUBLIC	??_C@_0CC@OOHK@aaaaaaaaaaaaagaaaaaaaaacaaaacaaa@ ; `string'
PUBLIC	??_C@_0BD@ONNB@buttons?1spark1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@NLO@buttons?1spark2?4wav?$AA@		; `string'
PUBLIC	??_C@_0BD@KNJL@buttons?1spark3?4wav?$AA@	; `string'
;	COMDAT ??_C@_0CC@ONJ@abcaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@
; File z:\xashxtsrc\server\bmodels.cpp
CONST	SEGMENT
??_C@_0CC@ONJ@abcaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@ DB 'abcaaaaaaaaaaaaaaaaaa'
	DB	'aaaaaaaaaaaa', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BKKA@acaaabaaaaaaaaaaaaaaaaaaaaaaaaaa@
CONST	SEGMENT
??_C@_0CC@BKKA@acaaabaaaaaaaaaaaaaaaaaaaaaaaaaa@ DB 'acaaabaaaaaaaaaaaaaa'
	DB	'aaaaaaaaaaaaa', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MFGL@aaafbaaaaaaaaaaaaaaaaaaaaaaaaaaa@
CONST	SEGMENT
??_C@_0CC@MFGL@aaafbaaaaaaaaaaaaaaaaaaaaaaaaaaa@ DB 'aaafbaaaaaaaaaaaaaaa'
	DB	'aaaaaaaaaaaaa', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OOHK@aaaaaaaaaaaaagaaaaaaaaacaaaacaaa@
CONST	SEGMENT
??_C@_0CC@OOHK@aaaaaaaaaaaaagaaaaaaaaacaaaacaaa@ DB 'aaaaaaaaaaaaagaaaaaa'
	DB	'aaacaaaacaaaa', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ONNB@buttons?1spark1?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@ONNB@buttons?1spark1?4wav?$AA@ DB 'buttons/spark1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NLO@buttons?1spark2?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@NLO@buttons?1spark2?4wav?$AA@ DB 'buttons/spark2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KNJL@buttons?1spark3?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@KNJL@buttons?1spark3?4wav?$AA@ DB 'buttons/spark3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4@4001d000000000000000
CONST	SEGMENT
__real@4@4001d000000000000000 DD 040d00000r	; 6.5
CONST	ENDS
;	COMDAT ?Flicker@CFuncLight@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Flicker@CFuncLight@@QAEXXZ PROC NEAR			; CFuncLight::Flicker, COMDAT

; 1697 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1698 : 	if( m_iState == STATE_TURN_ON )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1788], 2
	jne	SHORT $L38698

; 1700 : 		LIGHT_STYLE( m_iStyle, "k" );

	push	OFFSET FLAT:??_C@_01FMCB@k?$AA@		; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8

; 1701 : 		UTIL_FireTargets( pev->target, this, this, USE_ON );

	push	0
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+456]
	push	ecx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 1702 : 		m_iState = STATE_ON;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 1

; 1703 : 		DontThink();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DontThink@CBaseEntity@@QAEXXZ		; CBaseEntity::DontThink

; 1704 : 		return;

	jmp	$L38697
$L38698:

; 1706 : 
; 1707 : 	if( m_iFlickerMode == 1 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1816], 1
	jne	SHORT $L38699

; 1709 : 		pev->frame = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+304], 1065353216		; 3f800000H

; 1710 : 		LIGHT_STYLE( m_iStyle, "a" );

	push	OFFSET FLAT:??_C@_01FNLH@a?$AA@		; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8

; 1711 : 		SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1712 : 		return;

	jmp	$L38697
$L38699:

; 1714 : 
; 1715 : 	if( m_iFlickerMode == 2 )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1816], 2
	jne	$L38728

; 1718 : 		{

	push	3
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 3
	ja	SHORT $L38704
	mov	eax, DWORD PTR -8+[ebp]
	jmp	DWORD PTR $L40199[eax*4]
$L38707:

; 1719 : 		case 0:
; 1720 : 			LIGHT_STYLE( m_iStyle, "abcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" );

	push	OFFSET FLAT:??_C@_0CC@ONJ@abcaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8

; 1721 : 			break;

	jmp	SHORT $L38704
$L38709:

; 1722 : 		case 1:
; 1723 : 			LIGHT_STYLE( m_iStyle, "acaaabaaaaaaaaaaaaaaaaaaaaaaaaaaa" );

	push	OFFSET FLAT:??_C@_0CC@BKKA@acaaabaaaaaaaaaaaaaaaaaaaaaaaaaa@ ; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8

; 1724 : 			break;

	jmp	SHORT $L38704
$L38711:

; 1725 : 		case 2:
; 1726 : 			LIGHT_STYLE( m_iStyle, "aaafbaaaaaaaaaaaaaaaaaaaaaaaaaaaa" );

	push	OFFSET FLAT:??_C@_0CC@MFGL@aaafbaaaaaaaaaaaaaaaaaaaaaaaaaaa@ ; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8

; 1727 : 			break;

	jmp	SHORT $L38704
$L38713:

; 1728 : 		case 3:
; 1729 : 			LIGHT_STYLE( m_iStyle, "aaaaaaaaaaaaagaaaaaaaaacaaaacaaaa" );

	push	OFFSET FLAT:??_C@_0CC@OOHK@aaaaaaaaaaaaagaaaaaaaaacaaaacaaa@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+172
	add	esp, 8
$L38704:

; 1732 : 
; 1733 : 		m_flNextFlickerTime = RANDOM_FLOAT( 0.5f, 10.0f );

	push	1092616192				; 41200000H
	push	1056964608				; 3f000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1832]

; 1734 :                    	UTIL_Sparks( m_vecLastDmgPoint );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1820				; 0000071cH
	push	ecx
	call	?UTIL_Sparks@@YAXABVVector@@@Z		; UTIL_Sparks
	add	esp, 4

; 1737 : 		{

	push	2
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR -12+[ebp], eax
	cmp	DWORD PTR -12+[ebp], 0
	je	SHORT $L38719
	cmp	DWORD PTR -12+[ebp], 1
	je	SHORT $L38722
	cmp	DWORD PTR -12+[ebp], 2
	je	SHORT $L38725
	jmp	SHORT $L38716
$L38719:

; 1738 : 		case 0:
; 1739 : 			EMIT_SOUND( edict(), CHAN_VOICE, "buttons/spark1.wav", 0.4, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1053609165				; 3ecccccdH
	push	OFFSET FLAT:??_C@_0BD@ONNB@buttons?1spark1?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1740 : 			break;

	jmp	SHORT $L38716
$L38722:

; 1741 : 		case 1:
; 1742 : 			EMIT_SOUND( edict(), CHAN_VOICE, "buttons/spark2.wav", 0.3, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1050253722				; 3e99999aH
	push	OFFSET FLAT:??_C@_0BD@NLO@buttons?1spark2?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1743 : 			break;

	jmp	SHORT $L38716
$L38725:

; 1744 : 		case 2:
; 1745 : 			EMIT_SOUND( edict(), CHAN_VOICE, "buttons/spark3.wav", 0.35, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1051931443				; 3eb33333H
	push	OFFSET FLAT:??_C@_0BD@KNJL@buttons?1spark3?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L38716:

; 1748 : 
; 1749 : 		if( m_flNextFlickerTime > 6.5f )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1832]
	fcomp	DWORD PTR __real@4@4001d000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38728

; 1750 : 			m_iFlickerMode = 1; // stop sparking

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1816], 1
$L38728:

; 1752 : 
; 1753 : 	SetNextThink( m_flNextFlickerTime ); 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1832]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]
$L38697:

; 1754 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L40199:
	DD	$L38707
	DD	$L38709
	DD	$L38711
	DD	$L38713
?Flicker@CFuncLight@@QAEXXZ ENDP			; CFuncLight::Flicker
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncWall@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncWall>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncWall@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncWall>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncWall@@@@UAEIXZ ; CEntityFactory<CFuncWall>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncWall@@@@6B@		; CEntityFactory<CFuncWall>::`vftable'
PUBLIC	??0IEntityFactory@@QAE@XZ			; IEntityFactory::IEntityFactory
EXTRN	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ:NEAR ; EntityFactoryDictionary
;	COMDAT ??_7?$CEntityFactory@VCFuncWall@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncWall@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncWall@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncWall>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncWall@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncWall@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncWall@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncWall@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CFuncWall>::CEntityFactory<CFuncWall>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncWall@@@@6B@ ; CEntityFactory<CFuncWall>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncWall@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncWall>::CEntityFactory<CFuncWall>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncWall@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncWall@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncWall>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncWall@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncWall>::Create
_TEXT	ENDS
EXTRN	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_Remove
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncWall@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncWall@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncWall>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncWall@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncWall>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncWall@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncWall@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncWall>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1792				; 00000700H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncWall@@@@UAEIXZ ENDP ; CEntityFactory<CFuncWall>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncWallToggle@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncWallToggle>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncWallToggle@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncWallToggle>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncWallToggle@@@@UAEIXZ ; CEntityFactory<CFuncWallToggle>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncWallToggle@@@@6B@	; CEntityFactory<CFuncWallToggle>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncWallToggle@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncWallToggle@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncWallToggle@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncWallToggle>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncWallToggle@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncWallToggle@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncWallToggle@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncWallToggle@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncWallToggle>::CEntityFactory<CFuncWallToggle>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncWallToggle@@@@6B@ ; CEntityFactory<CFuncWallToggle>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncWallToggle@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncWallToggle>::CEntityFactory<CFuncWallToggle>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncWallToggle@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncWallToggle@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncWallToggle>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncWallToggle@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncWallToggle>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncWallToggle@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncWallToggle@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncWallToggle>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncWallToggle@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncWallToggle>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncWallToggle@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncWallToggle@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncWallToggle>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1792				; 00000700H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncWallToggle@@@@UAEIXZ ENDP ; CEntityFactory<CFuncWallToggle>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncConveyor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncConveyor>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncConveyor@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncConveyor>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncConveyor@@@@UAEIXZ ; CEntityFactory<CFuncConveyor>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncConveyor@@@@6B@	; CEntityFactory<CFuncConveyor>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncConveyor@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncConveyor@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncConveyor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncConveyor>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncConveyor@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncConveyor@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncConveyor@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncConveyor@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncConveyor>::CEntityFactory<CFuncConveyor>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncConveyor@@@@6B@ ; CEntityFactory<CFuncConveyor>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncConveyor@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncConveyor>::CEntityFactory<CFuncConveyor>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncConveyor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncConveyor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncConveyor>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncConveyor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncConveyor>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncConveyor@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncConveyor@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncConveyor>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncConveyor@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncConveyor>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncConveyor@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncConveyor@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncConveyor>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1796				; 00000704H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncConveyor@@@@UAEIXZ ENDP ; CEntityFactory<CFuncConveyor>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncTransporter@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTransporter>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncTransporter@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncTransporter>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncTransporter@@@@UAEIXZ ; CEntityFactory<CFuncTransporter>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncTransporter@@@@6B@	; CEntityFactory<CFuncTransporter>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncTransporter@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncTransporter@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncTransporter@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTransporter>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncTransporter@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncTransporter@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTransporter@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncTransporter@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncTransporter>::CEntityFactory<CFuncTransporter>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncTransporter@@@@6B@ ; CEntityFactory<CFuncTransporter>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncTransporter@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncTransporter>::CEntityFactory<CFuncTransporter>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncTransporter@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncTransporter@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncTransporter>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncTransporter@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncTransporter>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTransporter@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncTransporter@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncTransporter>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncTransporter@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncTransporter>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTransporter@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncTransporter@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncTransporter>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1800				; 00000708H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncTransporter@@@@UAEIXZ ENDP ; CEntityFactory<CFuncTransporter>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncIllusionary@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncIllusionary>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncIllusionary@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncIllusionary>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncIllusionary@@@@UAEIXZ ; CEntityFactory<CFuncIllusionary>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncIllusionary@@@@6B@	; CEntityFactory<CFuncIllusionary>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncIllusionary@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncIllusionary@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncIllusionary@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncIllusionary>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncIllusionary@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncIllusionary@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncIllusionary@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncIllusionary@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncIllusionary>::CEntityFactory<CFuncIllusionary>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncIllusionary@@@@6B@ ; CEntityFactory<CFuncIllusionary>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncIllusionary@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncIllusionary>::CEntityFactory<CFuncIllusionary>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncIllusionary@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncIllusionary@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncIllusionary>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncIllusionary@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncIllusionary>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncIllusionary@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncIllusionary@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncIllusionary>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncIllusionary@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncIllusionary>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncIllusionary@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncIllusionary@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncIllusionary>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1764				; 000006e4H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncIllusionary@@@@UAEIXZ ENDP ; CEntityFactory<CFuncIllusionary>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncMonsterClip@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncMonsterClip>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncMonsterClip@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncMonsterClip>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncMonsterClip@@@@UAEIXZ ; CEntityFactory<CFuncMonsterClip>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncMonsterClip@@@@6B@	; CEntityFactory<CFuncMonsterClip>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncMonsterClip@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncMonsterClip@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncMonsterClip@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncMonsterClip>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncMonsterClip@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncMonsterClip@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncMonsterClip@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncMonsterClip@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncMonsterClip>::CEntityFactory<CFuncMonsterClip>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncMonsterClip@@@@6B@ ; CEntityFactory<CFuncMonsterClip>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncMonsterClip@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncMonsterClip>::CEntityFactory<CFuncMonsterClip>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncMonsterClip@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncMonsterClip@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncMonsterClip>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncMonsterClip@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncMonsterClip>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncMonsterClip@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncMonsterClip@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncMonsterClip>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncMonsterClip@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncMonsterClip>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncMonsterClip@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncMonsterClip@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncMonsterClip>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1764				; 000006e4H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncMonsterClip@@@@UAEIXZ ENDP ; CEntityFactory<CFuncMonsterClip>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncRotating@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncRotating>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncRotating@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncRotating>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncRotating@@@@UAEIXZ ; CEntityFactory<CFuncRotating>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncRotating@@@@6B@	; CEntityFactory<CFuncRotating>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncRotating@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncRotating@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncRotating@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncRotating>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncRotating@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncRotating@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncRotating@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncRotating@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncRotating>::CEntityFactory<CFuncRotating>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncRotating@@@@6B@ ; CEntityFactory<CFuncRotating>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncRotating@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncRotating>::CEntityFactory<CFuncRotating>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncRotating@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncRotating@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncRotating>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncRotating@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncRotating>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncRotating@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncRotating@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncRotating>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncRotating@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncRotating>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncRotating@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncRotating@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncRotating>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1832				; 00000728H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncRotating@@@@UAEIXZ ENDP ; CEntityFactory<CFuncRotating>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCPendulum@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CPendulum>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCPendulum@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CPendulum>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCPendulum@@@@UAEIXZ ; CEntityFactory<CPendulum>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCPendulum@@@@6B@		; CEntityFactory<CPendulum>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCPendulum@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCPendulum@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCPendulum@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CPendulum>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCPendulum@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCPendulum@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCPendulum@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCPendulum@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CPendulum>::CEntityFactory<CPendulum>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCPendulum@@@@6B@ ; CEntityFactory<CPendulum>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCPendulum@@@@QAE@PBD@Z ENDP	; CEntityFactory<CPendulum>::CEntityFactory<CPendulum>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCPendulum@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCPendulum@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CPendulum>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCPendulum@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CPendulum>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCPendulum@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCPendulum@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CPendulum>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCPendulum@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CPendulum>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCPendulum@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCPendulum@@@@UAEIXZ PROC NEAR ; CEntityFactory<CPendulum>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1840				; 00000730H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCPendulum@@@@UAEIXZ ENDP ; CEntityFactory<CPendulum>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncClock@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncClock>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncClock@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncClock>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncClock@@@@UAEIXZ ; CEntityFactory<CFuncClock>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncClock@@@@6B@		; CEntityFactory<CFuncClock>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncClock@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncClock@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncClock@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncClock>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncClock@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncClock@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncClock@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncClock@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CFuncClock>::CEntityFactory<CFuncClock>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncClock@@@@6B@ ; CEntityFactory<CFuncClock>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncClock@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncClock>::CEntityFactory<CFuncClock>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncClock@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncClock@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncClock>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncClock@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncClock>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncClock@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncClock@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncClock>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncClock@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncClock>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncClock@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncClock@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncClock>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1832				; 00000728H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncClock@@@@UAEIXZ ENDP ; CEntityFactory<CFuncClock>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncLight@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncLight>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncLight@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncLight>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncLight@@@@UAEIXZ ; CEntityFactory<CFuncLight>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncLight@@@@6B@		; CEntityFactory<CFuncLight>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncLight@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncLight@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncLight@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncLight>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncLight@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncLight@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncLight@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncLight@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CFuncLight>::CEntityFactory<CFuncLight>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncLight@@@@6B@ ; CEntityFactory<CFuncLight>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncLight@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncLight>::CEntityFactory<CFuncLight>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncLight@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncLight@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncLight>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncLight@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncLight>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncLight@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncLight@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncLight>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncLight@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncLight>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncLight@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncLight@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncLight>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1836				; 0000072cH

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncLight@@@@UAEIXZ ENDP ; CEntityFactory<CFuncLight>::GetEntitySize
_TEXT	ENDS
PUBLIC	??_7IEntityFactory@@6B@				; IEntityFactory::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT
??_7IEntityFactory@@6B@ DD FLAT:__purecall		; IEntityFactory::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IEntityFactory@@QAE@XZ PROC NEAR			; IEntityFactory::IEntityFactory, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IEntityFactory@@6B@ ; IEntityFactory::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0IEntityFactory@@QAE@XZ ENDP				; IEntityFactory::IEntityFactory
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_this$ = -16
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
PUBLIC	??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
PUBLIC	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
PUBLIC	??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT
??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ DB '('
	DB	'Base() == NULL) || (&src < Base()) || (&src >= (Base() + Coun'
	DB	't()) )', 00H				; `string'
CONST	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L40306
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L40306
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L40306
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40306:

; 520  : 	return InsertBefore( m_Size, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseDelay@@2Udatamap_s@@A:BYTE	; CBaseDelay::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseDelay@@2Udatamap_s@@A ; CBaseDelay::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
EXTRN	?m_DataMap@CBreakable@@2Udatamap_s@@A:BYTE	; CBreakable::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBreakable@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBreakable@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBreakable@@2Udatamap_s@@A ; CBreakable::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBreakable@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	??0CFuncWall@@QAE@XZ				; CFuncWall::CFuncWall
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
PUBLIC	?SetClassname@CBaseEntity@@QAEXPBD@Z		; CBaseEntity::SetClassname
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
PUBLIC	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z		; CBaseEntity::operator new
PUBLIC	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z		; CBaseEntity::operator delete
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z
_TEXT	SEGMENT
_pev$ = -16
$T40313 = -20
$T40314 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L38918

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L38918:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L38920

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1792					; 00000700H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40314[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40314[ebp], 0
	je	SHORT $L40315
	mov	ecx, DWORD PTR $T40314[ebp]
	call	??0CFuncWall@@QAE@XZ			; CFuncWall::CFuncWall
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40316
$L40315:
	mov	DWORD PTR -28+[ebp], 0
$L40316:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40313[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40313[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L38920:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40314[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncWall@@PAV1@PBD@Z ENDP		; GetClassPtr
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC NEAR		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32448

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L32447
$L32448:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$L32447:

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4
_pszClassName$ = 8
?SetClassname@CBaseEntity@@QAEXPBD@Z PROC NEAR		; CBaseEntity::SetClassname, COMDAT

; 302  : 	void		SetClassname( const char *pszClassName ) { pev->classname = MAKE_STRING( pszClassName ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClassname@CBaseEntity@@QAEXPBD@Z ENDP		; CBaseEntity::SetClassname
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT
_stAllocateBlock$ = 8
_pev$ = 12
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator new, COMDAT

; 489  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 490  : 		return (void *)ALLOC_PRIVATE(ENT(pev), stAllocateBlock);

	mov	eax, DWORD PTR _stAllocateBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+252
	add	esp, 8

; 491  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z ENDP		; CBaseEntity::operator new
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 12
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator delete, COMDAT

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 497  : 		pev->flags |= FL_KILLME;

	mov	eax, DWORD PTR _pev$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+420], ecx

; 498  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z ENDP		; CBaseEntity::operator delete
_TEXT	ENDS
PUBLIC	??0CFuncWallToggle@@QAE@XZ			; CFuncWallToggle::CFuncWallToggle
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z
_TEXT	SEGMENT
_pev$ = -16
$T40336 = -20
$T40337 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z PROC NEAR ; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L38929

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L38929:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L38931

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1792					; 00000700H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40337[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40337[ebp], 0
	je	SHORT $L40338
	mov	ecx, DWORD PTR $T40337[ebp]
	call	??0CFuncWallToggle@@QAE@XZ		; CFuncWallToggle::CFuncWallToggle
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40339
$L40338:
	mov	DWORD PTR -28+[ebp], 0
$L40339:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40336[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40336[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L38931:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40337[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncWallToggle@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CFuncConveyor@@QAE@XZ			; CFuncConveyor::CFuncConveyor
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z
_TEXT	SEGMENT
_pev$ = -16
$T40349 = -20
$T40350 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L38940

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L38940:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L38942

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1796					; 00000704H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40350[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40350[ebp], 0
	je	SHORT $L40351
	mov	ecx, DWORD PTR $T40350[ebp]
	call	??0CFuncConveyor@@QAE@XZ		; CFuncConveyor::CFuncConveyor
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40352
$L40351:
	mov	DWORD PTR -28+[ebp], 0
$L40352:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40349[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40349[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L38942:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40350[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncConveyor@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CFuncTransporter@@QAE@XZ			; CFuncTransporter::CFuncTransporter
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z
_TEXT	SEGMENT
_pev$ = -16
$T40362 = -20
$T40363 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z PROC NEAR ; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L38951

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L38951:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L38953

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1800					; 00000708H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40363[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40363[ebp], 0
	je	SHORT $L40364
	mov	ecx, DWORD PTR $T40363[ebp]
	call	??0CFuncTransporter@@QAE@XZ		; CFuncTransporter::CFuncTransporter
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40365
$L40364:
	mov	DWORD PTR -28+[ebp], 0
$L40365:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40362[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40362[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L38953:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40363[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncTransporter@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CFuncIllusionary@@QAE@XZ			; CFuncIllusionary::CFuncIllusionary
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z
_TEXT	SEGMENT
_pev$ = -16
$T40375 = -20
$T40376 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z PROC NEAR ; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L38962

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L38962:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L38964

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1764					; 000006e4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40376[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40376[ebp], 0
	je	SHORT $L40377
	mov	ecx, DWORD PTR $T40376[ebp]
	call	??0CFuncIllusionary@@QAE@XZ		; CFuncIllusionary::CFuncIllusionary
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40378
$L40377:
	mov	DWORD PTR -28+[ebp], 0
$L40378:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40375[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40375[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L38964:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40376[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncIllusionary@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CFuncMonsterClip@@QAE@XZ			; CFuncMonsterClip::CFuncMonsterClip
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z
_TEXT	SEGMENT
_pev$ = -16
$T40388 = -20
$T40389 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z PROC NEAR ; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L38973

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L38973:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L38975

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1764					; 000006e4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40389[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40389[ebp], 0
	je	SHORT $L40390
	mov	ecx, DWORD PTR $T40389[ebp]
	call	??0CFuncMonsterClip@@QAE@XZ		; CFuncMonsterClip::CFuncMonsterClip
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40391
$L40390:
	mov	DWORD PTR -28+[ebp], 0
$L40391:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40388[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40388[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L38975:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40389[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncMonsterClip@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CFuncRotating@@QAE@XZ			; CFuncRotating::CFuncRotating
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z
_TEXT	SEGMENT
_pev$ = -16
$T40401 = -20
$T40402 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L38984

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L38984:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L38986

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1832					; 00000728H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40402[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40402[ebp], 0
	je	SHORT $L40403
	mov	ecx, DWORD PTR $T40402[ebp]
	call	??0CFuncRotating@@QAE@XZ		; CFuncRotating::CFuncRotating
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40404
$L40403:
	mov	DWORD PTR -28+[ebp], 0
$L40404:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40401[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40401[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L38986:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40402[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncRotating@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CPendulum@@QAE@XZ				; CPendulum::CPendulum
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z
_TEXT	SEGMENT
_pev$ = -16
$T40414 = -20
$T40415 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L38995

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L38995:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L38997

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1840					; 00000730H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40415[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40415[ebp], 0
	je	SHORT $L40416
	mov	ecx, DWORD PTR $T40415[ebp]
	call	??0CPendulum@@QAE@XZ			; CPendulum::CPendulum
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40417
$L40416:
	mov	DWORD PTR -28+[ebp], 0
$L40417:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40414[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40414[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L38997:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40415[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCPendulum@@PAV1@PBD@Z ENDP		; GetClassPtr
PUBLIC	??0CFuncClock@@QAE@XZ				; CFuncClock::CFuncClock
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z
_TEXT	SEGMENT
_pev$ = -16
$T40427 = -20
$T40428 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39006

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39006:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39008

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1832					; 00000728H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40428[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40428[ebp], 0
	je	SHORT $L40429
	mov	ecx, DWORD PTR $T40428[ebp]
	call	??0CFuncClock@@QAE@XZ			; CFuncClock::CFuncClock
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40430
$L40429:
	mov	DWORD PTR -28+[ebp], 0
$L40430:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40427[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40427[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39008:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40428[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncClock@@PAV1@PBD@Z ENDP		; GetClassPtr
PUBLIC	??0CFuncLight@@QAE@XZ				; CFuncLight::CFuncLight
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z
_TEXT	SEGMENT
_pev$ = -16
$T40440 = -20
$T40441 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39017

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39017:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39019

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1836					; 0000072cH
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40441[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40441[ebp], 0
	je	SHORT $L40442
	mov	ecx, DWORD PTR $T40441[ebp]
	call	??0CFuncLight@@QAE@XZ			; CFuncLight::CFuncLight
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40443
$L40442:
	mov	DWORD PTR -28+[ebp], 0
$L40443:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40440[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40440[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39019:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40441[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncLight@@PAV1@PBD@Z ENDP		; GetClassPtr
PUBLIC	?EarPosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EarPosition
PUBLIC	?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z	; CBaseEntity::BodyTarget
PUBLIC	?IsPointSized@CBaseEntity@@UBEHXZ		; CBaseEntity::IsPointSized
PUBLIC	?Illumination@CBaseEntity@@UAEHXZ		; CBaseEntity::Illumination
PUBLIC	?ObjectCaps@CFuncWall@@UAEHXZ			; CFuncWall::ObjectCaps
PUBLIC	??_7CFuncWall@@6B@				; CFuncWall::`vftable'
PUBLIC	?GetState@CBaseDelay@@UAE?AW4STATE@@XZ		; CBaseDelay::GetState
PUBLIC	??0CBaseDelay@@QAE@XZ				; CBaseDelay::CBaseDelay
PUBLIC	?Precache@CBaseEntity@@UAEXXZ			; CBaseEntity::Precache
PUBLIC	?Activate@CBaseEntity@@UAEXXZ			; CBaseEntity::Activate
PUBLIC	?OnChangeLevel@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeLevel
PUBLIC	?OnTeleport@CBaseEntity@@UAEXXZ			; CBaseEntity::OnTeleport
PUBLIC	?PortalSleep@CBaseEntity@@UAEXM@Z		; CBaseEntity::PortalSleep
PUBLIC	?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ; CBaseEntity::StartMessage
PUBLIC	?GetPosition@CBaseEntity@@UAEMXZ		; CBaseEntity::GetPosition
PUBLIC	?OnChangeParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeParent
PUBLIC	?OnClearParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnClearParent
PUBLIC	?OnRemove@CBaseEntity@@UAEXXZ			; CBaseEntity::OnRemove
PUBLIC	?Classify@CBaseEntity@@UAEHXZ			; CBaseEntity::Classify
PUBLIC	?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z	; CBaseEntity::DeathNotice
PUBLIC	?IsRigidBody@CBaseEntity@@UAEHXZ		; CBaseEntity::IsRigidBody
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z	; CBaseEntity::GetState
PUBLIC	?BloodColor@CBaseEntity@@UAEHXZ			; CBaseEntity::BloodColor
PUBLIC	?IsTriggered@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::IsTriggered
PUBLIC	?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ; CBaseEntity::MyMonsterPointer
PUBLIC	?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ; CBaseEntity::MySquadMonsterPointer
PUBLIC	?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ	; CBaseEntity::GetVehicleDriver
PUBLIC	?GetToggleState@CBaseEntity@@UAEHXZ		; CBaseEntity::GetToggleState
PUBLIC	?AddPoints@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPoints
PUBLIC	?AddPointsToTeam@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPointsToTeam
PUBLIC	?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::AddPlayerItem
PUBLIC	?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::RemovePlayerItem
PUBLIC	?GiveAmmo@CBaseEntity@@UAEHHPADH@Z		; CBaseEntity::GiveAmmo
PUBLIC	?GetDelay@CBaseEntity@@UAEMXZ			; CBaseEntity::GetDelay
PUBLIC	?IsMoving@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMoving
PUBLIC	?OverrideReset@CBaseEntity@@UAEXXZ		; CBaseEntity::OverrideReset
PUBLIC	?TransferReset@CBaseEntity@@UAEXXZ		; CBaseEntity::TransferReset
PUBLIC	?SetToggleState@CBaseEntity@@UAEXH@Z		; CBaseEntity::SetToggleState
PUBLIC	?StartSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StartSneaking
PUBLIC	?StopSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StopSneaking
PUBLIC	?OnControls@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::OnControls
PUBLIC	?IsSneaking@CBaseEntity@@UAEHXZ			; CBaseEntity::IsSneaking
PUBLIC	?IsAlive@CBaseEntity@@UAEHXZ			; CBaseEntity::IsAlive
PUBLIC	?IsBSPModel@CBaseEntity@@UAEHXZ			; CBaseEntity::IsBSPModel
PUBLIC	?IsCustomModel@CBaseEntity@@UAEHXZ		; CBaseEntity::IsCustomModel
PUBLIC	?ReflectGauss@CBaseEntity@@UAEHXZ		; CBaseEntity::ReflectGauss
PUBLIC	?HasTarget@CBaseEntity@@UAEHH@Z			; CBaseEntity::HasTarget
PUBLIC	?IsPlayer@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPlayer
PUBLIC	?IsNetClient@CBaseEntity@@UAEHXZ		; CBaseEntity::IsNetClient
PUBLIC	?IsMonster@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMonster
PUBLIC	?IsPushable@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPushable
PUBLIC	?IsProjectile@CBaseEntity@@UAEHXZ		; CBaseEntity::IsProjectile
PUBLIC	?IsFuncScreen@CBaseEntity@@UAEHXZ		; CBaseEntity::IsFuncScreen
PUBLIC	?IsPortal@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPortal
PUBLIC	?IsTank@CBaseEntity@@UAEHXZ			; CBaseEntity::IsTank
PUBLIC	?IsMover@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMover
PUBLIC	?IsBreakable@CBaseEntity@@UAEHXZ		; CBaseEntity::IsBreakable
PUBLIC	?TeamID@CBaseEntity@@UAEPBDXZ			; CBaseEntity::TeamID
PUBLIC	?Think@CBaseEntity@@UAEXXZ			; CBaseEntity::Think
PUBLIC	?Touch@CBaseEntity@@UAEXPAV1@@Z			; CBaseEntity::Touch
PUBLIC	?Blocked@CBaseEntity@@UAEXPAV1@@Z		; CBaseEntity::Blocked
PUBLIC	?MoveDone@CBaseEntity@@UAEXXZ			; CBaseEntity::MoveDone
PUBLIC	?Respawn@CBaseEntity@@UAEPAV1@XZ		; CBaseEntity::Respawn
PUBLIC	?UpdateOwner@CBaseEntity@@UAEXXZ		; CBaseEntity::UpdateOwner
PUBLIC	?FBecomeProne@CBaseEntity@@UAEHXZ		; CBaseEntity::FBecomeProne
PUBLIC	?Center@CBaseEntity@@UAE?AVVector@@XZ		; CBaseEntity::Center
PUBLIC	?EyePosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EyePosition
EXTRN	?FVisible@CBaseEntity@@UAEHPAV1@@Z:NEAR		; CBaseEntity::FVisible
EXTRN	?FVisible@CBaseEntity@@UAEHABVVector@@@Z:NEAR	; CBaseEntity::FVisible
EXTRN	?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z:NEAR	; CBaseEntity::ShouldCollide
EXTRN	?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseDelay::GetDataDescMap
EXTRN	?Save@CBaseEntity@@UAEHAAVCSave@@@Z:NEAR	; CBaseEntity::Save
EXTRN	?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z:NEAR	; CBaseEntity::Restore
EXTRN	?SetObjectCollisionBox@CBaseEntity@@UAEXXZ:NEAR	; CBaseEntity::SetObjectCollisionBox
EXTRN	?SetNextThink@CBaseEntity@@UAEXM@Z:NEAR		; CBaseEntity::SetNextThink
EXTRN	?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceAttack
EXTRN	?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseEntity::TakeDamage
EXTRN	?TakeHealth@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeHealth
EXTRN	?TakeArmor@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeArmor
EXTRN	?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z:NEAR	; CBaseEntity::Killed
EXTRN	?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceBleed
EXTRN	?DamageDecal@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::DamageDecal
EXTRN	?IsInWorld@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::IsInWorld
EXTRN	?GetNextTarget@CBaseEntity@@UAEPAV1@XZ:NEAR	; CBaseEntity::GetNextTarget
;	COMDAT ??_7CFuncWall@@6B@
CONST	SEGMENT
??_7CFuncWall@@6B@ DD FLAT:?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ ; CFuncWall::`vftable'
	DD	FLAT:?Spawn@CFuncWall@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncWall@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CFuncWall@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?TurnOn@CFuncWall@@UAEXXZ
	DD	FLAT:?TurnOff@CFuncWall@@UAEXXZ
CONST	ENDS
;	COMDAT ??0CFuncWall@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncWall@@QAE@XZ PROC NEAR				; CFuncWall::CFuncWall, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncWall@@6B@ ; CFuncWall::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncWall@@QAE@XZ ENDP				; CFuncWall::CFuncWall
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Precache, COMDAT

; 326  : 	virtual void	Precache( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Precache
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Activate@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Activate, COMDAT

; 365  : 	virtual void	Activate( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Activate
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeLevel@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeLevel, COMDAT

; 366  : 	virtual void	OnChangeLevel( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeLevel@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnChangeLevel
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnTeleport@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnTeleport, COMDAT

; 367  : 	virtual void	OnTeleport( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnTeleport@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnTeleport
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4
?PortalSleep@CBaseEntity@@UAEXM@Z PROC NEAR		; CBaseEntity::PortalSleep, COMDAT

; 368  : 	virtual void	PortalSleep( float seconds ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PortalSleep@CBaseEntity@@UAEXM@Z ENDP			; CBaseEntity::PortalSleep
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CBaseEntity::StartMessage, COMDAT

; 369  :           virtual void	StartMessage( CBasePlayer *pPlayer ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ENDP	; CBaseEntity::StartMessage
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetPosition@CBaseEntity@@UAEMXZ PROC NEAR		; CBaseEntity::GetPosition, COMDAT

; 370  : 	virtual float	GetPosition( void ) { return 0.0f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPosition@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetPosition
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeParent, COMDAT

; 371  : 	virtual void	OnChangeParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CBaseEntity@@UAEXXZ ENDP		; CBaseEntity::OnChangeParent
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnClearParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnClearParent, COMDAT

; 372  : 	virtual void	OnClearParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnClearParent
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnRemove@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::OnRemove, COMDAT

; 373  : 	virtual void	OnRemove( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnRemove@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnRemove
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::Classify, COMDAT

; 385  : 	virtual int Classify ( void ) { return CLASS_NONE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Classify
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z PROC NEAR ; CBaseEntity::DeathNotice, COMDAT

; 386  : 	virtual void DeathNotice ( entvars_t *pevChild ) { } // monster maker children use this to tell the monster maker that they have died.

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z ENDP	; CBaseEntity::DeathNotice
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsRigidBody@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsRigidBody, COMDAT

; 387  : 	virtual BOOL IsRigidBody( void ) { return (m_iActorType == ACTOR_DYNAMIC); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	mov	eax, ecx
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsRigidBody@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsRigidBody
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z PROC NEAR	; CBaseEntity::GetState, COMDAT

; 401  : 	virtual STATE GetState ( CBaseEntity* pEnt ) { return GetState(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z ENDP	; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::BloodColor, COMDAT

; 408  : 	virtual int	BloodColor( void ) { return DONT_BLEED; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::BloodColor
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::IsTriggered, COMDAT

; 410  : 	virtual BOOL	IsTriggered( CBaseEntity *pActivator ) {return TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::IsTriggered
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ PROC NEAR ; CBaseEntity::MyMonsterPointer, COMDAT

; 411  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ENDP ; CBaseEntity::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ PROC NEAR ; CBaseEntity::MySquadMonsterPointer, COMDAT

; 412  : 	virtual CSquadMonster *MySquadMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ENDP ; CBaseEntity::MySquadMonsterPointer
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ PROC NEAR	; CBaseEntity::GetVehicleDriver, COMDAT

; 413  : 	virtual CBaseEntity *GetVehicleDriver( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ ENDP		; CBaseEntity::GetVehicleDriver
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::GetToggleState, COMDAT

; 414  : 	virtual int	GetToggleState( void ) { return TS_AT_TOP; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseEntity@@UAEHXZ ENDP		; CBaseEntity::GetToggleState
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPoints@CBaseEntity@@UAEXHH@Z PROC NEAR		; CBaseEntity::AddPoints, COMDAT

; 415  : 	virtual void	AddPoints( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPoints@CBaseEntity@@UAEXHH@Z ENDP			; CBaseEntity::AddPoints
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z PROC NEAR	; CBaseEntity::AddPointsToTeam, COMDAT

; 416  : 	virtual void	AddPointsToTeam( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z ENDP		; CBaseEntity::AddPointsToTeam
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::AddPlayerItem, COMDAT

; 417  : 	virtual BOOL	AddPlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::AddPlayerItem
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::RemovePlayerItem, COMDAT

; 418  : 	virtual BOOL	RemovePlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::RemovePlayerItem
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT
_this$ = -4
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z PROC NEAR		; CBaseEntity::GiveAmmo, COMDAT

; 419  : 	virtual int 	GiveAmmo( int iAmount, char *szName, int iMax ) { return -1; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z ENDP			; CBaseEntity::GiveAmmo
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseEntity@@UAEMXZ PROC NEAR			; CBaseEntity::GetDelay, COMDAT

; 420  : 	virtual float	GetDelay( void ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetDelay
_TEXT	ENDS
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMoving, COMDAT

; 421  : 	virtual int	IsMoving( void ) { return GetAbsVelocity() != g_vecZero; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMoving
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OverrideReset, COMDAT

; 422  : 	virtual void	OverrideReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OverrideReset
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TransferReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::TransferReset, COMDAT

; 423  : 	virtual void	TransferReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransferReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::TransferReset
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?SetToggleState@CBaseEntity@@UAEXH@Z PROC NEAR		; CBaseEntity::SetToggleState, COMDAT

; 426  : 	virtual void	SetToggleState( int state ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetToggleState@CBaseEntity@@UAEXH@Z ENDP		; CBaseEntity::SetToggleState
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StartSneaking, COMDAT

; 427  : 	virtual void	StartSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StartSneaking
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StopSneaking, COMDAT

; 428  : 	virtual void	StopSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StopSneaking
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?OnControls@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::OnControls, COMDAT

; 429  : 	virtual BOOL	OnControls( CBaseEntity *pTest ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnControls@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::OnControls
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSneaking@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsSneaking, COMDAT

; 430  : 	virtual BOOL	IsSneaking( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSneaking@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsSneaking
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsAlive, COMDAT

; 431  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	jne	SHORT $L40524
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40524
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40525
$L40524:
	mov	DWORD PTR -8+[ebp], 0
$L40525:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsAlive
_TEXT	ENDS
EXTRN	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z:NEAR	; UTIL_GetModelType
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBSPModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBSPModel, COMDAT

; 432  : 	virtual BOOL	IsBSPModel( void ) { return UTIL_GetModelType( pev->modelindex ) == mod_brush; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBSPModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBSPModel
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsCustomModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsCustomModel, COMDAT

; 433  : 	virtual BOOL	IsCustomModel( void ) { return pev->solid == SOLID_CUSTOM; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+268], 5
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCustomModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsCustomModel
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ReflectGauss@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ReflectGauss, COMDAT

; 434  : 	virtual BOOL	ReflectGauss( void ) { return (( IsBSPModel() || IsCustomModel()) && !pev->takedamage ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	test	eax, eax
	jne	SHORT $L40532
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+208]
	test	eax, eax
	je	SHORT $L40533
$L40532:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40533
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40534
$L40533:
	mov	DWORD PTR -8+[ebp], 0
$L40534:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReflectGauss@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ReflectGauss
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_targetname$ = 8
?HasTarget@CBaseEntity@@UAEHH@Z PROC NEAR		; CBaseEntity::HasTarget, COMDAT

; 435  : 	virtual BOOL	HasTarget( string_t targetname ) { return FStrEq(STRING(targetname), STRING(pev->targetname) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _targetname$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasTarget@CBaseEntity@@UAEHH@Z ENDP			; CBaseEntity::HasTarget
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPlayer@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPlayer, COMDAT

; 437  : 	virtual BOOL	IsPlayer( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPlayer
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsNetClient@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsNetClient, COMDAT

; 438  : 	virtual BOOL	IsNetClient( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetClient@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsNetClient
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMonster@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsMonster, COMDAT

; 439  : 	virtual BOOL	IsMonster( void ) { return (pev->flags & FL_MONSTER ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+420]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMonster@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMonster
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPushable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsPushable, COMDAT

; 440  : 	virtual BOOL	IsPushable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPushable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPushable
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsProjectile@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsProjectile, COMDAT

; 441  : 	virtual BOOL	IsProjectile( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsProjectile@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsProjectile
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsFuncScreen@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsFuncScreen, COMDAT

; 442  : 	virtual BOOL	IsFuncScreen( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFuncScreen@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsFuncScreen
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPortal@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPortal, COMDAT

; 443  : 	virtual BOOL	IsPortal( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPortal@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPortal
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTank@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsTank, COMDAT

; 444  : 	virtual BOOL	IsTank( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTank@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsTank
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMover@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMover, COMDAT

; 445  : 	virtual BOOL	IsMover( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMover
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBreakable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBreakable, COMDAT

; 446  : 	virtual BOOL	IsBreakable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBreakable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBreakable
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?TeamID@CBaseEntity@@UAEPBDXZ PROC NEAR			; CBaseEntity::TeamID, COMDAT

; 447  : 	virtual const char	*TeamID( void ) { return ""; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TeamID@CBaseEntity@@UAEPBDXZ ENDP			; CBaseEntity::TeamID
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Think@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Think, COMDAT

; 458  : 	virtual void Think( void ) { if (m_pfnThink) (this->*m_pfnThink)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1744], 0
	je	SHORT $L35006
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1744]
$L35006:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Think
_TEXT	ENDS
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Touch@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Touch, COMDAT

; 466  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 		if( m_pfnTouch )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1748], 0
	je	SHORT $L35012

; 468  : 			(this->*m_pfnTouch)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1748]
$L35012:

; 469  : 
; 470  : 		// forward the blocked event to our parent, if any.
; 471  : 		if( m_hParent != NULL && !m_isChaining )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35013
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1628]
	test	ecx, ecx
	jne	SHORT $L35013

; 472  : 			m_hParent->Touch( pOther );

	mov	edx, DWORD PTR _pOther$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+280]
$L35013:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Touch
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator->, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Blocked@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Blocked, COMDAT

; 476  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 		if( m_pfnBlocked )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1756], 0
	je	SHORT $L35016

; 478  : 			(this->*m_pfnBlocked)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1756]
$L35016:

; 479  : 
; 480  : 		// forward the blocked event to our parent, if any.
; 481  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35017

; 482  : 			m_hParent->Blocked( pOther );

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+284]
$L35017:

; 483  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Blocked
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MoveDone@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::MoveDone, COMDAT

; 485  : 	virtual void MoveDone( void ) { if( m_pfnMoveDone )(this->*m_pfnMoveDone)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1760], 0
	je	SHORT $L35020
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1760]
$L35020:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveDone@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::MoveDone
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?Respawn@CBaseEntity@@UAEPAV1@XZ PROC NEAR		; CBaseEntity::Respawn, COMDAT

; 513  : 	virtual CBaseEntity *Respawn( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Respawn@CBaseEntity@@UAEPAV1@XZ ENDP			; CBaseEntity::Respawn
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?UpdateOwner@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::UpdateOwner, COMDAT

; 705  : 	virtual	void UpdateOwner( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateOwner@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::UpdateOwner
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FBecomeProne@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::FBecomeProne, COMDAT

; 709  : 	virtual BOOL FBecomeProne( void ) {return FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FBecomeProne@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::FBecomeProne
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40577 = -16
$T40578 = -28
?Center@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR		; CBaseEntity::Center, COMDAT

; 714  : 	virtual Vector Center( ) { return (pev->absmax + pev->absmin) * 0.5; }; // center point of entity

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T40578[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	push	edx
	lea	eax, DWORD PTR $T40577[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 208				; 000000d0H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Center@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::Center
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40581 = -16
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EyePosition, COMDAT

; 715  : 	virtual Vector EyePosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of eyes

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T40581[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EyePosition
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40584 = -16
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EarPosition, COMDAT

; 716  : 	virtual Vector EarPosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of ears

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T40584[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EarPosition
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40587 = -16
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseEntity::BodyTarget, COMDAT

; 717  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ); };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T40587[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseEntity::BodyTarget
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPointSized@CBaseEntity@@UBEHXZ PROC NEAR		; CBaseEntity::IsPointSized, COMDAT

; 718  : 	virtual BOOL IsPointSized() const { return (pev->size == g_vecZero) ? true : false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	setne	al
	and	eax, 255				; 000000ffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPointSized@CBaseEntity@@UBEHXZ ENDP			; CBaseEntity::IsPointSized
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Illumination@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::Illumination, COMDAT

; 720  : 	virtual int Illumination( ) { return GETENTITYILLUM( ENT( pev ) ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+60
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Illumination@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Illumination
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseDelay::GetState, COMDAT

; 881  : 	virtual STATE GetState( void ) { return m_iState; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1788]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ ENDP		; CBaseDelay::GetState
_TEXT	ENDS
PUBLIC	?ObjectCaps@CBaseEntity@@UAEHXZ			; CBaseEntity::ObjectCaps
;	COMDAT ?ObjectCaps@CFuncWall@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CFuncWall@@UAEHXZ PROC NEAR			; CFuncWall::ObjectCaps, COMDAT

; 33   : 	virtual int ObjectCaps( void ) { return CBaseEntity :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CFuncWall@@UAEHXZ ENDP			; CFuncWall::ObjectCaps
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ObjectCaps, COMDAT

; 364  : 	virtual int	ObjectCaps( void ) { return FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 2
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ObjectCaps
_TEXT	ENDS
PUBLIC	??_7CFuncWallToggle@@6B@			; CFuncWallToggle::`vftable'
;	COMDAT ??_7CFuncWallToggle@@6B@
CONST	SEGMENT
??_7CFuncWallToggle@@6B@ DD FLAT:?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ ; CFuncWallToggle::`vftable'
	DD	FLAT:?Spawn@CFuncWallToggle@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncWall@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CFuncWall@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?TurnOn@CFuncWallToggle@@UAEXXZ
	DD	FLAT:?TurnOff@CFuncWallToggle@@UAEXXZ
CONST	ENDS
;	COMDAT ??0CFuncWallToggle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncWallToggle@@QAE@XZ PROC NEAR			; CFuncWallToggle::CFuncWallToggle, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CFuncWall@@QAE@XZ			; CFuncWall::CFuncWall
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncWallToggle@@6B@ ; CFuncWallToggle::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncWallToggle@@QAE@XZ ENDP				; CFuncWallToggle::CFuncWallToggle
_TEXT	ENDS
PUBLIC	?ObjectCaps@CFuncConveyor@@UAEHXZ		; CFuncConveyor::ObjectCaps
PUBLIC	??_7CFuncConveyor@@6B@				; CFuncConveyor::`vftable'
;	COMDAT ??_7CFuncConveyor@@6B@
CONST	SEGMENT
??_7CFuncConveyor@@6B@ DD FLAT:?GetDataDescMap@CFuncConveyor@@UAEPAUdatamap_s@@XZ ; CFuncConveyor::`vftable'
	DD	FLAT:?Spawn@CFuncConveyor@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncConveyor@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CFuncConveyor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CFuncConveyor@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncConveyor@@QAE@XZ PROC NEAR			; CFuncConveyor::CFuncConveyor, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncConveyor@@6B@ ; CFuncConveyor::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncConveyor@@QAE@XZ ENDP				; CFuncConveyor::CFuncConveyor
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncConveyor@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CFuncConveyor@@UAEHXZ PROC NEAR		; CFuncConveyor::ObjectCaps, COMDAT

; 154  : 	virtual int ObjectCaps( void ) { return (BaseClass::ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | FCAP_SET_MOVEDIR; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	al, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CFuncConveyor@@UAEHXZ ENDP			; CFuncConveyor::ObjectCaps
_TEXT	ENDS
PUBLIC	?ObjectCaps@CFuncTransporter@@UAEHXZ		; CFuncTransporter::ObjectCaps
PUBLIC	??_7CFuncTransporter@@6B@			; CFuncTransporter::`vftable'
;	COMDAT ??_7CFuncTransporter@@6B@
CONST	SEGMENT
??_7CFuncTransporter@@6B@ DD FLAT:?GetDataDescMap@CFuncTransporter@@UAEPAUdatamap_s@@XZ ; CFuncTransporter::`vftable'
	DD	FLAT:?Spawn@CFuncTransporter@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncTransporter@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CFuncTransporter@@UAEXXZ
	DD	FLAT:?Use@CFuncTransporter@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CFuncTransporter@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncTransporter@@QAE@XZ PROC NEAR			; CFuncTransporter::CFuncTransporter, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncTransporter@@6B@ ; CFuncTransporter::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncTransporter@@QAE@XZ ENDP			; CFuncTransporter::CFuncTransporter
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncTransporter@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CFuncTransporter@@UAEHXZ PROC NEAR		; CFuncTransporter::ObjectCaps, COMDAT

; 269  : 	virtual int ObjectCaps( void ) { return (BaseClass::ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | FCAP_SET_MOVEDIR; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	al, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CFuncTransporter@@UAEHXZ ENDP		; CFuncTransporter::ObjectCaps
_TEXT	ENDS
PUBLIC	??0CBaseEntity@@QAE@XZ				; CBaseEntity::CBaseEntity
PUBLIC	?ObjectCaps@CFuncIllusionary@@UAEHXZ		; CFuncIllusionary::ObjectCaps
PUBLIC	??_7CFuncIllusionary@@6B@			; CFuncIllusionary::`vftable'
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@XZ		; CBaseEntity::GetState
PUBLIC	?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z	; CBaseEntity::Use
EXTRN	?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseEntity::GetDataDescMap
;	COMDAT ??_7CFuncIllusionary@@6B@
CONST	SEGMENT
??_7CFuncIllusionary@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CFuncIllusionary::`vftable'
	DD	FLAT:?Spawn@CFuncIllusionary@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncIllusionary@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CFuncIllusionary@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncIllusionary@@QAE@XZ PROC NEAR			; CFuncIllusionary::CFuncIllusionary, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncIllusionary@@6B@ ; CFuncIllusionary::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncIllusionary@@QAE@XZ ENDP			; CFuncIllusionary::CFuncIllusionary
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseEntity::GetState, COMDAT

; 398  : 	virtual STATE GetState ( void ) { return STATE_OFF; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ ENDP		; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
_pActivator$ = 8
_pCaller$ = 12
_useType$ = 16
_value$ = 20
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z PROC NEAR	; CBaseEntity::Use, COMDAT

; 461  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 		if (m_pfnUse) (this->*m_pfnUse)( pActivator, pCaller, useType, value );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1752], 0
	je	SHORT $L35009
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCaller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1752]
$L35009:

; 463  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z ENDP	; CBaseEntity::Use
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncIllusionary@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CFuncIllusionary@@UAEHXZ PROC NEAR		; CFuncIllusionary::ObjectCaps, COMDAT

; 401  : 	virtual int ObjectCaps( void ) { return BaseClass :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CFuncIllusionary@@UAEHXZ ENDP		; CFuncIllusionary::ObjectCaps
_TEXT	ENDS
PUBLIC	?ObjectCaps@CFuncMonsterClip@@UAEHXZ		; CFuncMonsterClip::ObjectCaps
PUBLIC	??_7CFuncMonsterClip@@6B@			; CFuncMonsterClip::`vftable'
;	COMDAT ??_7CFuncMonsterClip@@6B@
CONST	SEGMENT
??_7CFuncMonsterClip@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CFuncMonsterClip::`vftable'
	DD	FLAT:?Spawn@CFuncMonsterClip@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncMonsterClip@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CFuncMonsterClip@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncMonsterClip@@QAE@XZ PROC NEAR			; CFuncMonsterClip::CFuncMonsterClip, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncMonsterClip@@6B@ ; CFuncMonsterClip::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncMonsterClip@@QAE@XZ ENDP			; CFuncMonsterClip::CFuncMonsterClip
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncMonsterClip@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CFuncMonsterClip@@UAEHXZ PROC NEAR		; CFuncMonsterClip::ObjectCaps, COMDAT

; 425  : 	virtual int ObjectCaps( void ) { return BaseClass :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CFuncMonsterClip@@UAEHXZ ENDP		; CFuncMonsterClip::ObjectCaps
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??1CBaseDelay@@QAE@XZ				; CBaseDelay::~CBaseDelay
PUBLIC	?ObjectCaps@CFuncRotating@@UAEHXZ		; CFuncRotating::ObjectCaps
PUBLIC	??_7CFuncRotating@@6B@				; CFuncRotating::`vftable'
;	COMDAT ??_7CFuncRotating@@6B@
CONST	SEGMENT
??_7CFuncRotating@@6B@ DD FLAT:?GetDataDescMap@CFuncRotating@@UAEPAUdatamap_s@@XZ ; CFuncRotating::`vftable'
	DD	FLAT:?Spawn@CFuncRotating@@UAEXXZ
	DD	FLAT:?Precache@CFuncRotating@@UAEXXZ
	DD	FLAT:?KeyValue@CFuncRotating@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncRotating@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CFuncRotating@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CFuncRotating@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CFuncRotating@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CFuncRotating@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CFuncRotating@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CFuncRotating@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CFuncRotating@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CFuncRotating@@QAE@XZ PROC NEAR			; CFuncRotating::CFuncRotating, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CFuncRotating@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1816				; 00000718H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncRotating@@6B@ ; CFuncRotating::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CFuncRotating@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseDelay@@QAE@XZ			; CBaseDelay::~CBaseDelay
	ret	0
__ehhandler$??0CFuncRotating@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CFuncRotating@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CFuncRotating@@QAE@XZ ENDP				; CFuncRotating::CFuncRotating
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncRotating@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CFuncRotating@@UAEHXZ PROC NEAR		; CFuncRotating::ObjectCaps, COMDAT

; 468  : 	virtual int ObjectCaps( void ) { return (CBaseEntity :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | FCAP_HOLD_ANGLES; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	ah, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CFuncRotating@@UAEHXZ ENDP			; CFuncRotating::ObjectCaps
_TEXT	ENDS
PUBLIC	?ObjectCaps@CPendulum@@UAEHXZ			; CPendulum::ObjectCaps
PUBLIC	??_7CPendulum@@6B@				; CPendulum::`vftable'
;	COMDAT ??_7CPendulum@@6B@
CONST	SEGMENT
??_7CPendulum@@6B@ DD FLAT:?GetDataDescMap@CPendulum@@UAEPAUdatamap_s@@XZ ; CPendulum::`vftable'
	DD	FLAT:?Spawn@CPendulum@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CPendulum@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CPendulum@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CPendulum@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CPendulum@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?Blocked@CPendulum@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CPendulum@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CPendulum@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CPendulum@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CPendulum@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CPendulum@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CPendulum@@QAE@XZ PROC NEAR				; CPendulum::CPendulum, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CPendulum@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1816				; 00000718H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1828				; 00000724H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CPendulum@@6B@ ; CPendulum::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CPendulum@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseDelay@@QAE@XZ			; CBaseDelay::~CBaseDelay
	ret	0
__ehhandler$??0CPendulum@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CPendulum@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CPendulum@@QAE@XZ ENDP				; CPendulum::CPendulum
;	COMDAT ?ObjectCaps@CPendulum@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CPendulum@@UAEHXZ PROC NEAR			; CPendulum::ObjectCaps, COMDAT

; 1097 : 	virtual int ObjectCaps( void ) { return (BaseClass :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | FCAP_HOLD_ANGLES; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	ah, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CPendulum@@UAEHXZ ENDP			; CPendulum::ObjectCaps
_TEXT	ENDS
PUBLIC	?ObjectCaps@CFuncClock@@UAEHXZ			; CFuncClock::ObjectCaps
PUBLIC	??_7CFuncClock@@6B@				; CFuncClock::`vftable'
;	COMDAT ??_7CFuncClock@@6B@
CONST	SEGMENT
??_7CFuncClock@@6B@ DD FLAT:?GetDataDescMap@CFuncClock@@UAEPAUdatamap_s@@XZ ; CFuncClock::`vftable'
	DD	FLAT:?Spawn@CFuncClock@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CFuncClock@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncClock@@UAEHXZ
	DD	FLAT:?Activate@CFuncClock@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CFuncClock@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CFuncClock@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CFuncClock@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CFuncClock@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CFuncClock@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CFuncClock@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CFuncClock@@QAE@XZ PROC NEAR				; CFuncClock::CFuncClock, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CFuncClock@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1792				; 00000700H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncClock@@6B@ ; CFuncClock::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CFuncClock@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseDelay@@QAE@XZ			; CBaseDelay::~CBaseDelay
	ret	0
__ehhandler$??0CFuncClock@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CFuncClock@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CFuncClock@@QAE@XZ ENDP				; CFuncClock::CFuncClock
;	COMDAT ?ObjectCaps@CFuncClock@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CFuncClock@@UAEHXZ PROC NEAR		; CFuncClock::ObjectCaps, COMDAT

; 1339 : 	virtual int ObjectCaps( void ) { return BaseClass :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CFuncClock@@UAEHXZ ENDP			; CFuncClock::ObjectCaps
_TEXT	ENDS
PUBLIC	?ObjectCaps@CBreakable@@UAEHXZ			; CBreakable::ObjectCaps
PUBLIC	??0CBreakable@@QAE@XZ				; CBreakable::CBreakable
PUBLIC	??1CBreakable@@QAE@XZ				; CBreakable::~CBreakable
PUBLIC	??_7CFuncLight@@6B@				; CFuncLight::`vftable'
EXTRN	?KeyValue@CBreakable@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBreakable::KeyValue
EXTRN	?IsBreakable@CBreakable@@UAEHXZ:NEAR		; CBreakable::IsBreakable
EXTRN	?DamageDecal@CBreakable@@UAEHH@Z:NEAR		; CBreakable::DamageDecal
EXTRN	?Precache@CBreakable@@UAEXXZ:NEAR		; CBreakable::Precache
;	COMDAT ??_7CFuncLight@@6B@
CONST	SEGMENT
??_7CFuncLight@@6B@ DD FLAT:?GetDataDescMap@CFuncLight@@UAEPAUdatamap_s@@XZ ; CFuncLight::`vftable'
	DD	FLAT:?Spawn@CFuncLight@@UAEXXZ
	DD	FLAT:?Precache@CBreakable@@UAEXXZ
	DD	FLAT:?KeyValue@CBreakable@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBreakable@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CFuncLight@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CFuncLight@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBreakable@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBreakable@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CFuncLight@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CFuncLight@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CFuncLight@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CFuncLight@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CFuncLight@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CFuncLight@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CFuncLight@@QAE@XZ PROC NEAR				; CFuncLight::CFuncLight, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CFuncLight@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBreakable@@QAE@XZ			; CBreakable::CBreakable
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1820				; 0000071cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncLight@@6B@ ; CFuncLight::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CFuncLight@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBreakable@@QAE@XZ			; CBreakable::~CBreakable
	ret	0
__ehhandler$??0CFuncLight@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CFuncLight@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CFuncLight@@QAE@XZ ENDP				; CFuncLight::CFuncLight
;	COMDAT ?ObjectCaps@CBreakable@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBreakable@@UAEHXZ PROC NEAR		; CBreakable::ObjectCaps, COMDAT

; 57   : 	virtual int ObjectCaps( void ) { return (CBaseEntity :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBreakable@@UAEHXZ ENDP			; CBreakable::ObjectCaps
_TEXT	ENDS
PUBLIC	??_7CBaseDelay@@6B@				; CBaseDelay::`vftable'
PUBLIC	?Spawn@CBaseEntity@@UAEXXZ			; CBaseEntity::Spawn
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT
??_7CBaseDelay@@6B@ DD FLAT:?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ ; CBaseDelay::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseDelay@@6B@ ; CBaseDelay::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::CBaseDelay
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Spawn, COMDAT

; 325  : 	virtual void	Spawn( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Spawn
_TEXT	ENDS
PUBLIC	??1CBaseEntity@@QAE@XZ				; CBaseEntity::~CBaseEntity
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::~CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseEntity@@QAE@XZ			; CBaseEntity::~CBaseEntity
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::~CBaseDelay
_TEXT	ENDS
PUBLIC	??_7CBaseEntity@@6B@				; CBaseEntity::`vftable'
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	??0CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::CMeshDesc
EXTRN	??1CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::~CMeshDesc
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT
??_7CBaseEntity@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CBaseEntity::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseEntity@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseEntity@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseEntity@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseEntity@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseEntity@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??0CMeshDesc@@QAE@XZ			; CMeshDesc::CMeshDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1632				; 00000660H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseEntity@@6B@ ; CBaseEntity::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseEntity@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	ret	0
__ehhandler$??0CBaseEntity@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseEntity@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::CBaseEntity
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::~CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::~CBaseEntity
_TEXT	ENDS
PUBLIC	??_7CBreakable@@6B@				; CBreakable::`vftable'
EXTRN	?Use@CBreakable@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z:NEAR ; CBreakable::Use
EXTRN	?TakeDamage@CBreakable@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBreakable::TakeDamage
EXTRN	?GetDataDescMap@CBreakable@@UAEPAUdatamap_s@@XZ:NEAR ; CBreakable::GetDataDescMap
;	COMDAT ??_7CBreakable@@6B@
CONST	SEGMENT
??_7CBreakable@@6B@ DD FLAT:?GetDataDescMap@CBreakable@@UAEPAUdatamap_s@@XZ ; CBreakable::`vftable'
	DD	FLAT:?Spawn@CBreakable@@UAEXXZ
	DD	FLAT:?Precache@CBreakable@@UAEXXZ
	DD	FLAT:?KeyValue@CBreakable@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBreakable@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBreakable@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBreakable@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBreakable@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBreakable@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBreakable@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CBreakable@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBreakable@@QAE@XZ PROC NEAR				; CBreakable::CBreakable, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBreakable@@6B@ ; CBreakable::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBreakable@@QAE@XZ ENDP				; CBreakable::CBreakable
_TEXT	ENDS
;	COMDAT ??1CBreakable@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBreakable@@QAE@XZ PROC NEAR				; CBreakable::~CBreakable, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseDelay@@QAE@XZ			; CBaseDelay::~CBaseDelay
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBreakable@@QAE@XZ ENDP				; CBreakable::~CBreakable
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
PUBLIC	?CopyConstruct@@YAXPAPADABQAD@Z			; CopyConstruct
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ DB '('
	DB	'elem == Count()) || IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L40703
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L40703
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L40703
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40703:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L40704
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40704
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40704:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAPADABQAD@Z		; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC NEAR		; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L40709
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40709:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L39087

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L39087:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PADH@@QAE@XZ PROC NEAR			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
_TEXT	ENDS
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC NEAR		; CUtlMemory<char *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40714
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40714:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40715
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40715:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC NEAR		; CUtlMemory<char *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40718
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40718:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC NEAR	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40725
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L40725
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40726
$L40725:
	mov	DWORD PTR -8+[ebp], 0
$L40726:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAPAD@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L39120:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L39121

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAD@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L39120
$L39121:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ		; CUtlMemory<char *,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@PADH@@QAEXH@Z		; CUtlMemory<char *,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L39130

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@PADH@@QAEXH@Z	; CUtlMemory<char *,int>::Grow
$L39130:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
_TEXT	ENDS
PUBLIC	??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
EXTRN	_memmove:NEAR
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ DB 'I'
	DB	'sValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 )', 00H ; `string'
CONST	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40733
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L40733
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L40733
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40733:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L39139
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L39139

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L39139:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
_src$ = 12
$T40736 = -4
?CopyConstruct@@YAXPAPADABQAD@Z PROC NEAR		; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T40736[ebp], eax
	cmp	DWORD PTR $T40736[ebp], 0
	je	SHORT $L40737
	mov	ecx, DWORD PTR $T40736[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T40736[ebp]
	mov	DWORD PTR -8+[ebp], ecx
	jmp	SHORT $L40738
$L40737:
	mov	DWORD PTR -8+[ebp], 0
$L40738:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyConstruct@@YAXPAPADABQAD@Z ENDP			; CopyConstruct
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC NEAR	; CUtlMemory<char *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40743
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L40743
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40744
$L40743:
	mov	DWORD PTR -8+[ebp], 0
$L40744:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC NEAR		; CUtlMemory<char *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39153

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L39154

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L39154:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L39153:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR	; CUtlMemory<char *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ PROC NEAR	; CUtlMemory<char *,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ ENDP		; CUtlMemory<char *,int>::NumAllocated
_TEXT	ENDS
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@PADH@@QAEXH@Z PROC NEAR		; CUtlMemory<char *,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L40753
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40753:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L39168

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L40754
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40754:

; 567  : 		return;

	jmp	$L39165
$L39168:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	4
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L39188

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L39180
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L39180

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L39188
$L39180:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L39184

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L40755
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40755:

; 589  : 				return;

	jmp	$L39165
$L39184:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L39188

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L39184
$L39188:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L39191

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L40756
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40756:

; 603  : 	else

	jmp	SHORT $L40757
$L39191:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L40757
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40757:
$L39165:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@PADH@@QAEXH@Z ENDP			; CUtlMemory<char *,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L28985

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L28990
$L28985:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L28987

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L28987:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L28990

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L28987
$L28990:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR ; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
EXTRN	_memset:NEAR
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAD@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAD@Z ENDP				; Destruct
_TEXT	ENDS
END
