	TITLE	Z:\XashXTSRC\server\saverestore.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NALA@globalname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NOHF@origin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09PKPB@oldorigin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08OPKC@velocity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@JPNN@basevelocity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07NHCF@movedir?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06MFB@angles?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09PGOE@avelocity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PCAN@punchangle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07LGAN@v_angle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08OG@fixangle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IEHC@idealpitch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@NG@pitch_speed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JEON@ideal_yaw?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LOEC@yaw_speed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LLJL@modelindex?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LHJL@model?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09EPPK@viewmodel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@JDFN@weaponmodel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NGM@absmin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06OODK@absmax?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HNCE@mins?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PAMH@maxs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LLHI@size?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MGHL@ltime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09KHHA@nextthink?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FPMI@solid?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MDCC@movetype?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OFAC@skin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04NIOK@body?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BOHH@effects?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07CAPN@gravity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08LIGO@friction?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@IPMA@light_level?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MIEC@frame?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05IMHO@scale?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MNMF@sequence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CAKH@animtime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09EAGC@framerate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GCHJ@controller?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IFOB@blending?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MGOP@rendermode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09FILE@renderamt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GPPJ@rendercolor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08HAHO@renderfx?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06HECL@health?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05GEB@frags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@JJOE@takedamage?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08PMDH@deadflag?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08PACB@view_ofs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06LPKL@button?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07ENEF@impulse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05CMEM@chain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@ILBD@dmg_inflictor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05NNBK@enemy?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06BFHC@aiment?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LOEC@owner?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@JBFP@groundentity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@CANC@spawnflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KGBM@flags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MMPG@colormap?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04CJJD@team?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@JHPC@max_health?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@PHMK@teleport_time?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LMBH@armortype?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@BJIA@armorvalue?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@FCEP@waterlevel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HKJM@watertype?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07JLIF@netname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07NPGL@message?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EKLD@dmg_take?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CDPA@dmg_save?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03KLED@dmg?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07FIJI@dmgtime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DOHE@noise?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06ODDJ@noise1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06BMIA@noise2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06LGBH@noise3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PHJK@speed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@CILC@air_finished?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@PFJE@pain_finished?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@EEEM@radsuit_finished?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KEPL@vuser1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FLEC@vuser2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06PBNF@vuser3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KEDA@vuser4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06LLJI@iuser1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06EECB@iuser2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06OOLG@iuser3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06LLFD@iuser4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06POPJ@fuser1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06BEA@fuser2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KLNH@fuser3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06PODC@fuser4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@IKIF@No?5token?5table?5array?5in?5TokenHas@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DH@JDGM@CSaveRestoreBuffer?5?3?3?5TokenHash?$CI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@JDBL@CSaveRestoreBuffer?5?3?3?5TokenHash?$CI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07HFGP@?$CFs?9?$DO?$CFs?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JBAA@?$CFf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DILL@?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IEAL@?$CI?$CFf?5?$CFf?5?$CFf?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FCOA@?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@ECB@Invalid?5function?5pointer?5in?5clas@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@DPBM@Bad?5field?5in?5entity?$CB?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@CMHE@Can?8t?5save?5more?5than?5?$CFd?5entities@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@JAEO@Bad?5field?5type?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@FDNF@CSave?5?3?3?5BufferHeader?$CI?$CJ?5size?5par@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@HNMI@Save?1Restore?5overflow?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@KJIP@z?3?2xashxtsrc?2server?2saverestore?4@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCIE@i?5?$DN?$DN?5sizeof?$CIint?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@INLF@pheader?$CB?$DNNULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@OONN@m_pdata?5?$CB?$DNNULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@JJGF@Restore?5overflow?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??BufferReadBytes@CRestore@@AAEXPADH@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@CRestore@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSaveRestoreBuffer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSaveRestoreBuffer@@QAE@PAUsaverestore_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSaveRestoreBuffer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityIndex@CSaveRestoreBuffer@@QAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityIndex@CSaveRestoreBuffer@@QAEHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityIndex@CSaveRestoreBuffer@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityFlagsSet@CSaveRestoreBuffer@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BufferRewind@CSaveRestoreBuffer@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HashString@CSaveRestoreBuffer@@IAEIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteData@CSave@@QAEXPBDH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteShort@CSave@@QAEXPBDPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteInt@CSave@@QAEXPBDPBHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteFloat@CSave@@QAEXPBDPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteTime@CSave@@QAEXPBDPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteString@CSave@@QAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteString@CSave@@QAEXPBDPBHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteVector@CSave@@QAEXPBDABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteVector@CSave@@QAEXPBDPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WritePositionVector@CSave@@QAEXPBDABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WritePositionVector@CSave@@QAEXPBDPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteFunction@CSave@@QAEXPAUdatamap_s@@PBDPBHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntvarsKeyvalue@@YAXPAUentvars_s@@PAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteEntVars@CSave@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoWriteAll@CSave@@QAEHPBXPAUdatamap_s@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteFields@CSave@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BufferString@CSave@@AAEXPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataEmpty@CSave@@AAEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BufferField@CSave@@AAEXPBDH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BufferHeader@CSave@@AAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BufferData@CSave@@AAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadField@CRestore@@QAEHPBXPAUdatamap_s@@PAUtypedescription_s@@HHHPADPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadEntVars@CRestore@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoReadAll@CRestore@@QAEHPAXPAUdatamap_s@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadShort@CRestore@@QAEFXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadInt@CRestore@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadNamedInt@CRestore@@QAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadNamedString@CRestore@@QAEPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BufferPointer@CRestore@@AAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BufferReadBytes@CRestore@@AAEXPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadFunction@CRestore@@QAEHPAUdatamap_s@@PAPAXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BufferSkipBytes@CRestore@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?gEntvarsDescription@@3PAUtypedescription_s@@A	; gEntvarsDescription
PUBLIC	??_C@_0L@NALA@globalname?$AA@			; `string'
PUBLIC	??_C@_06NOHF@origin?$AA@			; `string'
PUBLIC	??_C@_09PKPB@oldorigin?$AA@			; `string'
PUBLIC	??_C@_08OPKC@velocity?$AA@			; `string'
PUBLIC	??_C@_0N@JPNN@basevelocity?$AA@			; `string'
PUBLIC	??_C@_07NHCF@movedir?$AA@			; `string'
PUBLIC	??_C@_06MFB@angles?$AA@				; `string'
PUBLIC	??_C@_09PGOE@avelocity?$AA@			; `string'
PUBLIC	??_C@_0L@PCAN@punchangle?$AA@			; `string'
PUBLIC	??_C@_07LGAN@v_angle?$AA@			; `string'
PUBLIC	??_C@_08OG@fixangle?$AA@			; `string'
PUBLIC	??_C@_0L@IEHC@idealpitch?$AA@			; `string'
PUBLIC	??_C@_0M@NG@pitch_speed?$AA@			; `string'
PUBLIC	??_C@_09JEON@ideal_yaw?$AA@			; `string'
PUBLIC	??_C@_09LOEC@yaw_speed?$AA@			; `string'
PUBLIC	??_C@_0L@LLJL@modelindex?$AA@			; `string'
PUBLIC	??_C@_05LHJL@model?$AA@				; `string'
PUBLIC	??_C@_09EPPK@viewmodel?$AA@			; `string'
PUBLIC	??_C@_0M@JDFN@weaponmodel?$AA@			; `string'
PUBLIC	??_C@_06NGM@absmin?$AA@				; `string'
PUBLIC	??_C@_06OODK@absmax?$AA@			; `string'
PUBLIC	??_C@_04HNCE@mins?$AA@				; `string'
PUBLIC	??_C@_04PAMH@maxs?$AA@				; `string'
PUBLIC	??_C@_04LLHI@size?$AA@				; `string'
PUBLIC	??_C@_05MGHL@ltime?$AA@				; `string'
PUBLIC	??_C@_09KHHA@nextthink?$AA@			; `string'
PUBLIC	??_C@_05FPMI@solid?$AA@				; `string'
PUBLIC	??_C@_08MDCC@movetype?$AA@			; `string'
PUBLIC	??_C@_04OFAC@skin?$AA@				; `string'
PUBLIC	??_C@_04NIOK@body?$AA@				; `string'
PUBLIC	??_C@_07BOHH@effects?$AA@			; `string'
PUBLIC	??_C@_07CAPN@gravity?$AA@			; `string'
PUBLIC	??_C@_08LIGO@friction?$AA@			; `string'
PUBLIC	??_C@_0M@IPMA@light_level?$AA@			; `string'
PUBLIC	??_C@_05MIEC@frame?$AA@				; `string'
PUBLIC	??_C@_05IMHO@scale?$AA@				; `string'
PUBLIC	??_C@_08MNMF@sequence?$AA@			; `string'
PUBLIC	??_C@_08CAKH@animtime?$AA@			; `string'
PUBLIC	??_C@_09EAGC@framerate?$AA@			; `string'
PUBLIC	??_C@_0L@GCHJ@controller?$AA@			; `string'
PUBLIC	??_C@_08IFOB@blending?$AA@			; `string'
PUBLIC	??_C@_0L@MGOP@rendermode?$AA@			; `string'
PUBLIC	??_C@_09FILE@renderamt?$AA@			; `string'
PUBLIC	??_C@_0M@GPPJ@rendercolor?$AA@			; `string'
PUBLIC	??_C@_08HAHO@renderfx?$AA@			; `string'
PUBLIC	??_C@_06HECL@health?$AA@			; `string'
PUBLIC	??_C@_05GEB@frags?$AA@				; `string'
PUBLIC	??_C@_0L@JJOE@takedamage?$AA@			; `string'
PUBLIC	??_C@_08PMDH@deadflag?$AA@			; `string'
PUBLIC	??_C@_08PACB@view_ofs?$AA@			; `string'
PUBLIC	??_C@_06LPKL@button?$AA@			; `string'
PUBLIC	??_C@_07ENEF@impulse?$AA@			; `string'
PUBLIC	??_C@_05CMEM@chain?$AA@				; `string'
PUBLIC	??_C@_0O@ILBD@dmg_inflictor?$AA@		; `string'
PUBLIC	??_C@_05NNBK@enemy?$AA@				; `string'
PUBLIC	??_C@_06BFHC@aiment?$AA@			; `string'
PUBLIC	??_C@_05LOEC@owner?$AA@				; `string'
PUBLIC	??_C@_0N@JBFP@groundentity?$AA@			; `string'
PUBLIC	??_C@_0L@CANC@spawnflags?$AA@			; `string'
PUBLIC	??_C@_05KGBM@flags?$AA@				; `string'
PUBLIC	??_C@_08MMPG@colormap?$AA@			; `string'
PUBLIC	??_C@_04CJJD@team?$AA@				; `string'
PUBLIC	??_C@_0L@JHPC@max_health?$AA@			; `string'
PUBLIC	??_C@_0O@PHMK@teleport_time?$AA@		; `string'
PUBLIC	??_C@_09LMBH@armortype?$AA@			; `string'
PUBLIC	??_C@_0L@BJIA@armorvalue?$AA@			; `string'
PUBLIC	??_C@_0L@FCEP@waterlevel?$AA@			; `string'
PUBLIC	??_C@_09HKJM@watertype?$AA@			; `string'
PUBLIC	??_C@_07JLIF@netname?$AA@			; `string'
PUBLIC	??_C@_07NPGL@message?$AA@			; `string'
PUBLIC	??_C@_08EKLD@dmg_take?$AA@			; `string'
PUBLIC	??_C@_08CDPA@dmg_save?$AA@			; `string'
PUBLIC	??_C@_03KLED@dmg?$AA@				; `string'
PUBLIC	??_C@_07FIJI@dmgtime?$AA@			; `string'
PUBLIC	??_C@_05DOHE@noise?$AA@				; `string'
PUBLIC	??_C@_06ODDJ@noise1?$AA@			; `string'
PUBLIC	??_C@_06BMIA@noise2?$AA@			; `string'
PUBLIC	??_C@_06LGBH@noise3?$AA@			; `string'
PUBLIC	??_C@_05PHJK@speed?$AA@				; `string'
PUBLIC	??_C@_0N@CILC@air_finished?$AA@			; `string'
PUBLIC	??_C@_0O@PFJE@pain_finished?$AA@		; `string'
PUBLIC	??_C@_0BB@EEEM@radsuit_finished?$AA@		; `string'
PUBLIC	??_C@_06KEPL@vuser1?$AA@			; `string'
PUBLIC	??_C@_06FLEC@vuser2?$AA@			; `string'
PUBLIC	??_C@_06PBNF@vuser3?$AA@			; `string'
PUBLIC	??_C@_06KEDA@vuser4?$AA@			; `string'
PUBLIC	??_C@_06LLJI@iuser1?$AA@			; `string'
PUBLIC	??_C@_06EECB@iuser2?$AA@			; `string'
PUBLIC	??_C@_06OOLG@iuser3?$AA@			; `string'
PUBLIC	??_C@_06LLFD@iuser4?$AA@			; `string'
PUBLIC	??_C@_06POPJ@fuser1?$AA@			; `string'
PUBLIC	??_C@_06BEA@fuser2?$AA@				; `string'
PUBLIC	??_C@_06KLNH@fuser3?$AA@			; `string'
PUBLIC	??_C@_06PODC@fuser4?$AA@			; `string'
PUBLIC	??_C@_09JDJH@classname?$AA@			; `string'
PUBLIC	??_C@_0L@PMO@targetname?$AA@			; `string'
PUBLIC	??_C@_06CCPD@target?$AA@			; `string'
_BSS	SEGMENT
_?tokensparsed@?1??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA DD 01H DUP (?)
_?beentheredonethat@?5??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
?gEntvarsDescription@@3PAUtypedescription_s@@A DD 01H	; gEntvarsDescription
	DD	FLAT:??_C@_09JDJH@classname?$AA@
	DD	00H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_09JDJH@classname?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0L@NALA@globalname?$AA@
	DD	04H
	DW	01H
	DW	07H
	DD	FLAT:??_C@_0L@NALA@globalname?$AA@
	DD	00H
	DD	08H
	DD	FLAT:??_C@_06NOHF@origin?$AA@
	DD	08H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06NOHF@origin?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_09PKPB@oldorigin?$AA@
	DD	014H
	DW	01H
	DW	07H
	DD	FLAT:??_C@_09PKPB@oldorigin?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_08OPKC@velocity?$AA@
	DD	020H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08OPKC@velocity?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0N@JPNN@basevelocity?$AA@
	DD	02cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0N@JPNN@basevelocity?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_07NHCF@movedir?$AA@
	DD	044H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07NHCF@movedir?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_06MFB@angles?$AA@
	DD	050H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06MFB@angles?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_09PGOE@avelocity?$AA@
	DD	05cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_09PGOE@avelocity?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0L@PCAN@punchangle?$AA@
	DD	068H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@PCAN@punchangle?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_07LGAN@v_angle?$AA@
	DD	074H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07LGAN@v_angle?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_08OG@fixangle?$AA@
	DD	0a0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08OG@fixangle?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@IEHC@idealpitch?$AA@
	DD	0a4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@IEHC@idealpitch?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0M@NG@pitch_speed?$AA@
	DD	0a8H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@NG@pitch_speed?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_09JEON@ideal_yaw?$AA@
	DD	0acH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_09JEON@ideal_yaw?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_09LOEC@yaw_speed?$AA@
	DD	0b0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_09LOEC@yaw_speed?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0L@LLJL@modelindex?$AA@
	DD	0b4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@LLJL@modelindex?$AA@
	DD	00H
	DD	010H
	DD	FLAT:??_C@_05LHJL@model?$AA@
	DD	0b8H
	DW	01H
	DW	07H
	DD	FLAT:??_C@_05LHJL@model?$AA@
	DD	00H
	DD	010H
	DD	FLAT:??_C@_09EPPK@viewmodel?$AA@
	DD	0bcH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_09EPPK@viewmodel?$AA@
	DD	00H
	DD	010H
	DD	FLAT:??_C@_0M@JDFN@weaponmodel?$AA@
	DD	0c0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@JDFN@weaponmodel?$AA@
	DD	00H
	DD	08H
	DD	FLAT:??_C@_06NGM@absmin?$AA@
	DD	0c4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06NGM@absmin?$AA@
	DD	00H
	DD	08H
	DD	FLAT:??_C@_06OODK@absmax?$AA@
	DD	0d0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06OODK@absmax?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_04HNCE@mins?$AA@
	DD	0dcH
	DW	01H
	DW	07H
	DD	FLAT:??_C@_04HNCE@mins?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_04PAMH@maxs?$AA@
	DD	0e8H
	DW	01H
	DW	07H
	DD	FLAT:??_C@_04PAMH@maxs?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_04LLHI@size?$AA@
	DD	0f4H
	DW	01H
	DW	07H
	DD	FLAT:??_C@_04LLHI@size?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_05MGHL@ltime?$AA@
	DD	0100H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_05MGHL@ltime?$AA@
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_09KHHA@nextthink?$AA@
	DD	0104H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_09KHHA@nextthink?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_05FPMI@solid?$AA@
	DD	010cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_05FPMI@solid?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08MDCC@movetype?$AA@
	DD	0108H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08MDCC@movetype?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_04OFAC@skin?$AA@
	DD	0110H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_04OFAC@skin?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_04NIOK@body?$AA@
	DD	0114H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_04NIOK@body?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_07BOHH@effects?$AA@
	DD	0118H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07BOHH@effects?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_07CAPN@gravity?$AA@
	DD	011cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07CAPN@gravity?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_08LIGO@friction?$AA@
	DD	0120H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08LIGO@friction?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0M@IPMA@light_level?$AA@
	DD	0124H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@IPMA@light_level?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_05MIEC@frame?$AA@
	DD	0130H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_05MIEC@frame?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_05IMHO@scale?$AA@
	DD	0144H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_05IMHO@scale?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08MNMF@sequence?$AA@
	DD	0128H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08MNMF@sequence?$AA@
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_08CAKH@animtime?$AA@
	DD	0134H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08CAKH@animtime?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_09EAGC@framerate?$AA@
	DD	0138H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_09EAGC@framerate?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0L@GCHJ@controller?$AA@
	DD	013cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@GCHJ@controller?$AA@
	DD	00H
	DD	0dH
	DD	FLAT:??_C@_08IFOB@blending?$AA@
	DD	0140H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08IFOB@blending?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0L@MGOP@rendermode?$AA@
	DD	0148H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@MGOP@rendermode?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_09FILE@renderamt?$AA@
	DD	014cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_09FILE@renderamt?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0M@GPPJ@rendercolor?$AA@
	DD	0150H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@GPPJ@rendercolor?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08HAHO@renderfx?$AA@
	DD	015cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08HAHO@renderfx?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_06HECL@health?$AA@
	DD	0160H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06HECL@health?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_05GEB@frags?$AA@
	DD	0164H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_05GEB@frags?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@JJOE@takedamage?$AA@
	DD	016cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@JJOE@takedamage?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_08PMDH@deadflag?$AA@
	DD	0170H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08PMDH@deadflag?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_08PACB@view_ofs?$AA@
	DD	0174H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08PACB@view_ofs?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_06LPKL@button?$AA@
	DD	0180H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06LPKL@button?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_07ENEF@impulse?$AA@
	DD	0184H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07ENEF@impulse?$AA@
	DD	00H
	DD	06H
	DD	FLAT:??_C@_05CMEM@chain?$AA@
	DD	0188H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_05CMEM@chain?$AA@
	DD	00H
	DD	06H
	DD	FLAT:??_C@_0O@ILBD@dmg_inflictor?$AA@
	DD	018cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0O@ILBD@dmg_inflictor?$AA@
	DD	00H
	DD	06H
	DD	FLAT:??_C@_05NNBK@enemy?$AA@
	DD	0190H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_05NNBK@enemy?$AA@
	DD	00H
	DD	06H
	DD	FLAT:??_C@_06BFHC@aiment?$AA@
	DD	0194H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06BFHC@aiment?$AA@
	DD	00H
	DD	06H
	DD	FLAT:??_C@_05LOEC@owner?$AA@
	DD	0198H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_05LOEC@owner?$AA@
	DD	00H
	DD	06H
	DD	FLAT:??_C@_0N@JBFP@groundentity?$AA@
	DD	019cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0N@JBFP@groundentity?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0L@CANC@spawnflags?$AA@
	DD	01a0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@CANC@spawnflags?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_05KGBM@flags?$AA@
	DD	01a4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_05KGBM@flags?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08MMPG@colormap?$AA@
	DD	01a8H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08MMPG@colormap?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_04CJJD@team?$AA@
	DD	01acH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_04CJJD@team?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@JHPC@max_health?$AA@
	DD	01b0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@JHPC@max_health?$AA@
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0O@PHMK@teleport_time?$AA@
	DD	01b4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0O@PHMK@teleport_time?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_09LMBH@armortype?$AA@
	DD	01b8H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_09LMBH@armortype?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@BJIA@armorvalue?$AA@
	DD	01bcH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@BJIA@armorvalue?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0L@FCEP@waterlevel?$AA@
	DD	01c0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@FCEP@waterlevel?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_09HKJM@watertype?$AA@
	DD	01c4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_09HKJM@watertype?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_06CCPD@target?$AA@
	DD	01c8H
	DW	01H
	DW	07H
	DD	FLAT:??_C@_06CCPD@target?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0L@PMO@targetname?$AA@
	DD	01ccH
	DW	01H
	DW	07H
	DD	FLAT:??_C@_0L@PMO@targetname?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_07JLIF@netname?$AA@
	DD	01d0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07JLIF@netname?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_07NPGL@message?$AA@
	DD	01d4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07NPGL@message?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_08EKLD@dmg_take?$AA@
	DD	01d8H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08EKLD@dmg_take?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_08CDPA@dmg_save?$AA@
	DD	01dcH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08CDPA@dmg_save?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_03KLED@dmg?$AA@
	DD	01e0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_03KLED@dmg?$AA@
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_07FIJI@dmgtime?$AA@
	DD	01e4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07FIJI@dmgtime?$AA@
	DD	00H
	DD	011H
	DD	FLAT:??_C@_05DOHE@noise?$AA@
	DD	01e8H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_05DOHE@noise?$AA@
	DD	00H
	DD	011H
	DD	FLAT:??_C@_06ODDJ@noise1?$AA@
	DD	01ecH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06ODDJ@noise1?$AA@
	DD	00H
	DD	011H
	DD	FLAT:??_C@_06BMIA@noise2?$AA@
	DD	01f0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06BMIA@noise2?$AA@
	DD	00H
	DD	011H
	DD	FLAT:??_C@_06LGBH@noise3?$AA@
	DD	01f4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06LGBH@noise3?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_05PHJK@speed?$AA@
	DD	01f8H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_05PHJK@speed?$AA@
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0N@CILC@air_finished?$AA@
	DD	01fcH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0N@CILC@air_finished?$AA@
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0O@PFJE@pain_finished?$AA@
	DD	0200H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0O@PFJE@pain_finished?$AA@
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BB@EEEM@radsuit_finished?$AA@
	DD	0204H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0BB@EEEM@radsuit_finished?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_06KEPL@vuser1?$AA@
	DD	0264H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06KEPL@vuser1?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_06FLEC@vuser2?$AA@
	DD	0270H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06FLEC@vuser2?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_06PBNF@vuser3?$AA@
	DD	027cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06PBNF@vuser3?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_06KEDA@vuser4?$AA@
	DD	0288H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06KEDA@vuser4?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_06LLJI@iuser1?$AA@
	DD	0244H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06LLJI@iuser1?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_06EECB@iuser2?$AA@
	DD	0248H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06EECB@iuser2?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_06OOLG@iuser3?$AA@
	DD	024cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06OOLG@iuser3?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_06LLFD@iuser4?$AA@
	DD	0250H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06LLFD@iuser4?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_06POPJ@fuser1?$AA@
	DD	0254H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06POPJ@fuser1?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_06BEA@fuser2?$AA@
	DD	0258H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06BEA@fuser2?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_06KLNH@fuser3?$AA@
	DD	025cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06KLNH@fuser3?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_06PODC@fuser4?$AA@
	DD	0260H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06PODC@fuser4?$AA@
	DD	00H
_gSizes	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	0cH
	DD	0cH
	DD	04H
	DD	04H
	DD	04H
	DD	01H
	DD	02H
	DD	01H
	DD	04H
	DD	04H
	DD	04H
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT
??_C@_09JDJH@classname?$AA@ DB 'classname', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT
??_C@_0L@PMO@targetname?$AA@ DB 'targetname', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT
??_C@_06CCPD@target?$AA@ DB 'target', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NALA@globalname?$AA@
CONST	SEGMENT
??_C@_0L@NALA@globalname?$AA@ DB 'globalname', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOHF@origin?$AA@
CONST	SEGMENT
??_C@_06NOHF@origin?$AA@ DB 'origin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKPB@oldorigin?$AA@
CONST	SEGMENT
??_C@_09PKPB@oldorigin?$AA@ DB 'oldorigin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OPKC@velocity?$AA@
CONST	SEGMENT
??_C@_08OPKC@velocity?$AA@ DB 'velocity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JPNN@basevelocity?$AA@
CONST	SEGMENT
??_C@_0N@JPNN@basevelocity?$AA@ DB 'basevelocity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NHCF@movedir?$AA@
CONST	SEGMENT
??_C@_07NHCF@movedir?$AA@ DB 'movedir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MFB@angles?$AA@
CONST	SEGMENT
??_C@_06MFB@angles?$AA@ DB 'angles', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PGOE@avelocity?$AA@
CONST	SEGMENT
??_C@_09PGOE@avelocity?$AA@ DB 'avelocity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PCAN@punchangle?$AA@
CONST	SEGMENT
??_C@_0L@PCAN@punchangle?$AA@ DB 'punchangle', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LGAN@v_angle?$AA@
CONST	SEGMENT
??_C@_07LGAN@v_angle?$AA@ DB 'v_angle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OG@fixangle?$AA@
CONST	SEGMENT
??_C@_08OG@fixangle?$AA@ DB 'fixangle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IEHC@idealpitch?$AA@
CONST	SEGMENT
??_C@_0L@IEHC@idealpitch?$AA@ DB 'idealpitch', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NG@pitch_speed?$AA@
CONST	SEGMENT
??_C@_0M@NG@pitch_speed?$AA@ DB 'pitch_speed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JEON@ideal_yaw?$AA@
CONST	SEGMENT
??_C@_09JEON@ideal_yaw?$AA@ DB 'ideal_yaw', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LOEC@yaw_speed?$AA@
CONST	SEGMENT
??_C@_09LOEC@yaw_speed?$AA@ DB 'yaw_speed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LLJL@modelindex?$AA@
CONST	SEGMENT
??_C@_0L@LLJL@modelindex?$AA@ DB 'modelindex', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LHJL@model?$AA@
CONST	SEGMENT
??_C@_05LHJL@model?$AA@ DB 'model', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09EPPK@viewmodel?$AA@
CONST	SEGMENT
??_C@_09EPPK@viewmodel?$AA@ DB 'viewmodel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JDFN@weaponmodel?$AA@
CONST	SEGMENT
??_C@_0M@JDFN@weaponmodel?$AA@ DB 'weaponmodel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NGM@absmin?$AA@
CONST	SEGMENT
??_C@_06NGM@absmin?$AA@ DB 'absmin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OODK@absmax?$AA@
CONST	SEGMENT
??_C@_06OODK@absmax?$AA@ DB 'absmax', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HNCE@mins?$AA@
CONST	SEGMENT
??_C@_04HNCE@mins?$AA@ DB 'mins', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PAMH@maxs?$AA@
CONST	SEGMENT
??_C@_04PAMH@maxs?$AA@ DB 'maxs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLHI@size?$AA@
CONST	SEGMENT
??_C@_04LLHI@size?$AA@ DB 'size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGHL@ltime?$AA@
CONST	SEGMENT
??_C@_05MGHL@ltime?$AA@ DB 'ltime', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09KHHA@nextthink?$AA@
CONST	SEGMENT
??_C@_09KHHA@nextthink?$AA@ DB 'nextthink', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FPMI@solid?$AA@
CONST	SEGMENT
??_C@_05FPMI@solid?$AA@ DB 'solid', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MDCC@movetype?$AA@
CONST	SEGMENT
??_C@_08MDCC@movetype?$AA@ DB 'movetype', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OFAC@skin?$AA@
CONST	SEGMENT
??_C@_04OFAC@skin?$AA@ DB 'skin', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NIOK@body?$AA@
CONST	SEGMENT
??_C@_04NIOK@body?$AA@ DB 'body', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07BOHH@effects?$AA@
CONST	SEGMENT
??_C@_07BOHH@effects?$AA@ DB 'effects', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CAPN@gravity?$AA@
CONST	SEGMENT
??_C@_07CAPN@gravity?$AA@ DB 'gravity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LIGO@friction?$AA@
CONST	SEGMENT
??_C@_08LIGO@friction?$AA@ DB 'friction', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IPMA@light_level?$AA@
CONST	SEGMENT
??_C@_0M@IPMA@light_level?$AA@ DB 'light_level', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIEC@frame?$AA@
CONST	SEGMENT
??_C@_05MIEC@frame?$AA@ DB 'frame', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IMHO@scale?$AA@
CONST	SEGMENT
??_C@_05IMHO@scale?$AA@ DB 'scale', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MNMF@sequence?$AA@
CONST	SEGMENT
??_C@_08MNMF@sequence?$AA@ DB 'sequence', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CAKH@animtime?$AA@
CONST	SEGMENT
??_C@_08CAKH@animtime?$AA@ DB 'animtime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EAGC@framerate?$AA@
CONST	SEGMENT
??_C@_09EAGC@framerate?$AA@ DB 'framerate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GCHJ@controller?$AA@
CONST	SEGMENT
??_C@_0L@GCHJ@controller?$AA@ DB 'controller', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IFOB@blending?$AA@
CONST	SEGMENT
??_C@_08IFOB@blending?$AA@ DB 'blending', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MGOP@rendermode?$AA@
CONST	SEGMENT
??_C@_0L@MGOP@rendermode?$AA@ DB 'rendermode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FILE@renderamt?$AA@
CONST	SEGMENT
??_C@_09FILE@renderamt?$AA@ DB 'renderamt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPPJ@rendercolor?$AA@
CONST	SEGMENT
??_C@_0M@GPPJ@rendercolor?$AA@ DB 'rendercolor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HAHO@renderfx?$AA@
CONST	SEGMENT
??_C@_08HAHO@renderfx?$AA@ DB 'renderfx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HECL@health?$AA@
CONST	SEGMENT
??_C@_06HECL@health?$AA@ DB 'health', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GEB@frags?$AA@
CONST	SEGMENT
??_C@_05GEB@frags?$AA@ DB 'frags', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JJOE@takedamage?$AA@
CONST	SEGMENT
??_C@_0L@JJOE@takedamage?$AA@ DB 'takedamage', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PMDH@deadflag?$AA@
CONST	SEGMENT
??_C@_08PMDH@deadflag?$AA@ DB 'deadflag', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PACB@view_ofs?$AA@
CONST	SEGMENT
??_C@_08PACB@view_ofs?$AA@ DB 'view_ofs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LPKL@button?$AA@
CONST	SEGMENT
??_C@_06LPKL@button?$AA@ DB 'button', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07ENEF@impulse?$AA@
CONST	SEGMENT
??_C@_07ENEF@impulse?$AA@ DB 'impulse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMEM@chain?$AA@
CONST	SEGMENT
??_C@_05CMEM@chain?$AA@ DB 'chain', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ILBD@dmg_inflictor?$AA@
CONST	SEGMENT
??_C@_0O@ILBD@dmg_inflictor?$AA@ DB 'dmg_inflictor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05NNBK@enemy?$AA@
CONST	SEGMENT
??_C@_05NNBK@enemy?$AA@ DB 'enemy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06BFHC@aiment?$AA@
CONST	SEGMENT
??_C@_06BFHC@aiment?$AA@ DB 'aiment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LOEC@owner?$AA@
CONST	SEGMENT
??_C@_05LOEC@owner?$AA@ DB 'owner', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JBFP@groundentity?$AA@
CONST	SEGMENT
??_C@_0N@JBFP@groundentity?$AA@ DB 'groundentity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CANC@spawnflags?$AA@
CONST	SEGMENT
??_C@_0L@CANC@spawnflags?$AA@ DB 'spawnflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KGBM@flags?$AA@
CONST	SEGMENT
??_C@_05KGBM@flags?$AA@ DB 'flags', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MMPG@colormap?$AA@
CONST	SEGMENT
??_C@_08MMPG@colormap?$AA@ DB 'colormap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CJJD@team?$AA@
CONST	SEGMENT
??_C@_04CJJD@team?$AA@ DB 'team', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JHPC@max_health?$AA@
CONST	SEGMENT
??_C@_0L@JHPC@max_health?$AA@ DB 'max_health', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PHMK@teleport_time?$AA@
CONST	SEGMENT
??_C@_0O@PHMK@teleport_time?$AA@ DB 'teleport_time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LMBH@armortype?$AA@
CONST	SEGMENT
??_C@_09LMBH@armortype?$AA@ DB 'armortype', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BJIA@armorvalue?$AA@
CONST	SEGMENT
??_C@_0L@BJIA@armorvalue?$AA@ DB 'armorvalue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FCEP@waterlevel?$AA@
CONST	SEGMENT
??_C@_0L@FCEP@waterlevel?$AA@ DB 'waterlevel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HKJM@watertype?$AA@
CONST	SEGMENT
??_C@_09HKJM@watertype?$AA@ DB 'watertype', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JLIF@netname?$AA@
CONST	SEGMENT
??_C@_07JLIF@netname?$AA@ DB 'netname', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NPGL@message?$AA@
CONST	SEGMENT
??_C@_07NPGL@message?$AA@ DB 'message', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EKLD@dmg_take?$AA@
CONST	SEGMENT
??_C@_08EKLD@dmg_take?$AA@ DB 'dmg_take', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CDPA@dmg_save?$AA@
CONST	SEGMENT
??_C@_08CDPA@dmg_save?$AA@ DB 'dmg_save', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KLED@dmg?$AA@
CONST	SEGMENT
??_C@_03KLED@dmg?$AA@ DB 'dmg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FIJI@dmgtime?$AA@
CONST	SEGMENT
??_C@_07FIJI@dmgtime?$AA@ DB 'dmgtime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DOHE@noise?$AA@
CONST	SEGMENT
??_C@_05DOHE@noise?$AA@ DB 'noise', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06ODDJ@noise1?$AA@
CONST	SEGMENT
??_C@_06ODDJ@noise1?$AA@ DB 'noise1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BMIA@noise2?$AA@
CONST	SEGMENT
??_C@_06BMIA@noise2?$AA@ DB 'noise2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LGBH@noise3?$AA@
CONST	SEGMENT
??_C@_06LGBH@noise3?$AA@ DB 'noise3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PHJK@speed?$AA@
CONST	SEGMENT
??_C@_05PHJK@speed?$AA@ DB 'speed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CILC@air_finished?$AA@
CONST	SEGMENT
??_C@_0N@CILC@air_finished?$AA@ DB 'air_finished', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PFJE@pain_finished?$AA@
CONST	SEGMENT
??_C@_0O@PFJE@pain_finished?$AA@ DB 'pain_finished', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EEEM@radsuit_finished?$AA@
CONST	SEGMENT
??_C@_0BB@EEEM@radsuit_finished?$AA@ DB 'radsuit_finished', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06KEPL@vuser1?$AA@
CONST	SEGMENT
??_C@_06KEPL@vuser1?$AA@ DB 'vuser1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FLEC@vuser2?$AA@
CONST	SEGMENT
??_C@_06FLEC@vuser2?$AA@ DB 'vuser2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PBNF@vuser3?$AA@
CONST	SEGMENT
??_C@_06PBNF@vuser3?$AA@ DB 'vuser3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KEDA@vuser4?$AA@
CONST	SEGMENT
??_C@_06KEDA@vuser4?$AA@ DB 'vuser4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LLJI@iuser1?$AA@
CONST	SEGMENT
??_C@_06LLJI@iuser1?$AA@ DB 'iuser1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EECB@iuser2?$AA@
CONST	SEGMENT
??_C@_06EECB@iuser2?$AA@ DB 'iuser2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OOLG@iuser3?$AA@
CONST	SEGMENT
??_C@_06OOLG@iuser3?$AA@ DB 'iuser3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LLFD@iuser4?$AA@
CONST	SEGMENT
??_C@_06LLFD@iuser4?$AA@ DB 'iuser4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06POPJ@fuser1?$AA@
CONST	SEGMENT
??_C@_06POPJ@fuser1?$AA@ DB 'fuser1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BEA@fuser2?$AA@
CONST	SEGMENT
??_C@_06BEA@fuser2?$AA@ DB 'fuser2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KLNH@fuser3?$AA@
CONST	SEGMENT
??_C@_06KLNH@fuser3?$AA@ DB 'fuser3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PODC@fuser4?$AA@
CONST	SEGMENT
??_C@_06PODC@fuser4?$AA@ DB 'fuser4', 00H		; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0CSaveRestoreBuffer@@QAE@XZ			; CSaveRestoreBuffer::CSaveRestoreBuffer
;	COMDAT ??0CSaveRestoreBuffer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CSaveRestoreBuffer@@QAE@XZ PROC NEAR			; CSaveRestoreBuffer::CSaveRestoreBuffer, COMDAT

; 184  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 185  : 	m_pdata = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 186  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CSaveRestoreBuffer@@QAE@XZ ENDP			; CSaveRestoreBuffer::CSaveRestoreBuffer
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
PUBLIC	??0CSaveRestoreBuffer@@QAE@PAUsaverestore_s@@@Z	; CSaveRestoreBuffer::CSaveRestoreBuffer
;	COMDAT ??0CSaveRestoreBuffer@@QAE@PAUsaverestore_s@@@Z
_TEXT	SEGMENT
_pdata$ = 8
_this$ = -4
??0CSaveRestoreBuffer@@QAE@PAUsaverestore_s@@@Z PROC NEAR ; CSaveRestoreBuffer::CSaveRestoreBuffer, COMDAT

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 190  : 	m_pdata = pdata;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pdata$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 191  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CSaveRestoreBuffer@@QAE@PAUsaverestore_s@@@Z ENDP	; CSaveRestoreBuffer::CSaveRestoreBuffer
_TEXT	ENDS
PUBLIC	??1CSaveRestoreBuffer@@QAE@XZ			; CSaveRestoreBuffer::~CSaveRestoreBuffer
;	COMDAT ??1CSaveRestoreBuffer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CSaveRestoreBuffer@@QAE@XZ PROC NEAR			; CSaveRestoreBuffer::~CSaveRestoreBuffer, COMDAT

; 194  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 195  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CSaveRestoreBuffer@@QAE@XZ ENDP			; CSaveRestoreBuffer::~CSaveRestoreBuffer
_TEXT	ENDS
PUBLIC	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUentvars_s@@@Z ; CSaveRestoreBuffer::EntityIndex
PUBLIC	?EntityIndex@CSaveRestoreBuffer@@QAEHPAVCBaseEntity@@@Z ; CSaveRestoreBuffer::EntityIndex
;	COMDAT ?EntityIndex@CSaveRestoreBuffer@@QAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?EntityIndex@CSaveRestoreBuffer@@QAEHPAVCBaseEntity@@@Z PROC NEAR ; CSaveRestoreBuffer::EntityIndex, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 199  : 	if ( pEntity == NULL )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L36521

; 200  : 		return -1;

	or	eax, -1
	jmp	SHORT $L36520
$L36521:

; 201  : 	return EntityIndex( pEntity->pev );

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUentvars_s@@@Z ; CSaveRestoreBuffer::EntityIndex
$L36520:

; 202  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EntityIndex@CSaveRestoreBuffer@@QAEHPAVCBaseEntity@@@Z ENDP ; CSaveRestoreBuffer::EntityIndex
_TEXT	ENDS
PUBLIC	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z ; CSaveRestoreBuffer::EntityIndex
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
;	COMDAT ?EntityIndex@CSaveRestoreBuffer@@QAEHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pevLookup$ = 8
_this$ = -4
?EntityIndex@CSaveRestoreBuffer@@QAEHPAUentvars_s@@@Z PROC NEAR ; CSaveRestoreBuffer::EntityIndex, COMDAT

; 205  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 	if ( pevLookup == NULL )

	cmp	DWORD PTR _pevLookup$[ebp], 0
	jne	SHORT $L36526

; 207  : 		return -1;

	or	eax, -1
	jmp	SHORT $L36525
$L36526:

; 208  : 	return EntityIndex( ENT( pevLookup ) );

	mov	eax, DWORD PTR _pevLookup$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z ; CSaveRestoreBuffer::EntityIndex
$L36525:

; 209  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EntityIndex@CSaveRestoreBuffer@@QAEHPAUentvars_s@@@Z ENDP ; CSaveRestoreBuffer::EntityIndex
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	?EntityIndex@CSaveRestoreBuffer@@QAEHH@Z	; CSaveRestoreBuffer::EntityIndex
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?EntityIndex@CSaveRestoreBuffer@@QAEHH@Z
_TEXT	SEGMENT
_eoLookup$ = 8
_this$ = -4
?EntityIndex@CSaveRestoreBuffer@@QAEHH@Z PROC NEAR	; CSaveRestoreBuffer::EntityIndex, COMDAT

; 212  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 	return EntityIndex( ENT( eoLookup ) );

	mov	eax, DWORD PTR _eoLookup$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z ; CSaveRestoreBuffer::EntityIndex

; 214  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EntityIndex@CSaveRestoreBuffer@@QAEHH@Z ENDP		; CSaveRestoreBuffer::EntityIndex
_TEXT	ENDS
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
;	COMDAT ?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z
_TEXT	SEGMENT
_pentLookup$ = 8
_this$ = -4
_i$ = -8
_pTable$ = -12
?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z PROC NEAR ; CSaveRestoreBuffer::EntityIndex, COMDAT

; 217  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 218  : 	if ( !m_pdata || pentLookup == NULL )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $L36536
	cmp	DWORD PTR _pentLookup$[ebp], 0
	jne	SHORT $L36535
$L36536:

; 219  : 		return -1;

	or	eax, -1
	jmp	SHORT $L36534
$L36535:

; 222  : 	ENTITYTABLE *pTable;
; 223  : 
; 224  : 	for ( i = 0; i < m_pdata->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L36539
$L36540:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L36539:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	SHORT $L36541

; 226  : 		pTable = m_pdata->pTable + i;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR [eax+40]
	add	edx, ecx
	mov	DWORD PTR _pTable$[ebp], edx

; 227  : 		if ( pTable->pent == pentLookup )

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _pentLookup$[ebp]
	jne	SHORT $L36542

; 228  : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $L36534
$L36542:

; 229  : 	}

	jmp	SHORT $L36540
$L36541:

; 230  : 	return -1;

	or	eax, -1
$L36534:

; 231  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z ENDP ; CSaveRestoreBuffer::EntityIndex
_TEXT	ENDS
PUBLIC	?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ; CSaveRestoreBuffer::EntityFromIndex
;	COMDAT ?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z
_TEXT	SEGMENT
_entityIndex$ = 8
_this$ = -4
_i$ = -8
_pTable$ = -12
?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z PROC NEAR ; CSaveRestoreBuffer::EntityFromIndex, COMDAT

; 234  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 235  : 	if ( !m_pdata || entityIndex < 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $L36548
	cmp	DWORD PTR _entityIndex$[ebp], 0
	jge	SHORT $L36547
$L36548:

; 236  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L36546
$L36547:

; 239  : 	ENTITYTABLE *pTable;
; 240  : 
; 241  : 	for ( i = 0; i < m_pdata->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L36551
$L36552:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L36551:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	SHORT $L36553

; 243  : 		pTable = m_pdata->pTable + i;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR [eax+40]
	add	edx, ecx
	mov	DWORD PTR _pTable$[ebp], edx

; 244  : 		if ( pTable->id == entityIndex )

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _entityIndex$[ebp]
	jne	SHORT $L36554

; 245  : 			return pTable->pent;

	mov	edx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $L36546
$L36554:

; 246  : 	}

	jmp	SHORT $L36552
$L36553:

; 247  : 	return NULL;

	xor	eax, eax
$L36546:

; 248  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ENDP ; CSaveRestoreBuffer::EntityFromIndex
_TEXT	ENDS
PUBLIC	?EntityFlagsSet@CSaveRestoreBuffer@@QAEHHH@Z	; CSaveRestoreBuffer::EntityFlagsSet
;	COMDAT ?EntityFlagsSet@CSaveRestoreBuffer@@QAEHHH@Z
_TEXT	SEGMENT
_entityIndex$ = 8
_flags$ = 12
_this$ = -4
?EntityFlagsSet@CSaveRestoreBuffer@@QAEHHH@Z PROC NEAR	; CSaveRestoreBuffer::EntityFlagsSet, COMDAT

; 251  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 	if ( !m_pdata || entityIndex < 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $L36561
	cmp	DWORD PTR _entityIndex$[ebp], 0
	jge	SHORT $L36560
$L36561:

; 253  : 		return 0;

	xor	eax, eax
	jmp	SHORT $L36559
$L36560:

; 254  : 	if ( entityIndex > m_pdata->tableCount )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _entityIndex$[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jle	SHORT $L36562

; 255  : 		return 0;

	xor	eax, eax
	jmp	SHORT $L36559
$L36562:

; 256  : 
; 257  : 	m_pdata->pTable[ entityIndex ].flags |= flags;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _entityIndex$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [ecx+eax+16]
	or	edx, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR _entityIndex$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR [ecx+40]
	mov	DWORD PTR [ecx+eax+16], edx

; 258  : 
; 259  : 	return m_pdata->pTable[ entityIndex ].flags;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _entityIndex$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [edx+ecx+16]
$L36559:

; 260  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?EntityFlagsSet@CSaveRestoreBuffer@@QAEHHH@Z ENDP	; CSaveRestoreBuffer::EntityFlagsSet
_TEXT	ENDS
PUBLIC	?BufferRewind@CSaveRestoreBuffer@@IAEXH@Z	; CSaveRestoreBuffer::BufferRewind
;	COMDAT ?BufferRewind@CSaveRestoreBuffer@@IAEXH@Z
_TEXT	SEGMENT
_size$ = 8
_this$ = -4
?BufferRewind@CSaveRestoreBuffer@@IAEXH@Z PROC NEAR	; CSaveRestoreBuffer::BufferRewind, COMDAT

; 263  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 264  : 	if ( !m_pdata )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $L36567

; 265  : 		return;

	jmp	SHORT $L36566
$L36567:

; 266  : 
; 267  : 	if ( m_pdata->size < size )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	SHORT $L36568

; 268  : 		size = m_pdata->size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _size$[ebp], eax
$L36568:

; 269  : 
; 270  : 	m_pdata->pCurrentData -= size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+4], eax

; 271  : 	m_pdata->size -= size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+8], edx
$L36566:

; 272  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?BufferRewind@CSaveRestoreBuffer@@IAEXH@Z ENDP		; CSaveRestoreBuffer::BufferRewind
_TEXT	ENDS
PUBLIC	?HashString@CSaveRestoreBuffer@@IAEIPBD@Z	; CSaveRestoreBuffer::HashString
EXTRN	__rotr:NEAR
;	COMDAT ?HashString@CSaveRestoreBuffer@@IAEIPBD@Z
_TEXT	SEGMENT
_pszToken$ = 8
_this$ = -4
_hash$ = -8
?HashString@CSaveRestoreBuffer@@IAEIPBD@Z PROC NEAR	; CSaveRestoreBuffer::HashString, COMDAT

; 297  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 298  : 	unsigned int	hash = 0;

	mov	DWORD PTR _hash$[ebp], 0
$L36575:

; 299  : 
; 300  : 	while ( *pszToken )

	mov	eax, DWORD PTR _pszToken$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L36576

; 301  : 		hash = _rotr( hash, 4 ) ^ *pszToken++;

	push	4
	mov	edx, DWORD PTR _hash$[ebp]
	push	edx
	call	__rotr
	add	esp, 8
	mov	ecx, DWORD PTR _pszToken$[ebp]
	movsx	edx, BYTE PTR [ecx]
	xor	eax, edx
	mov	DWORD PTR _hash$[ebp], eax
	mov	eax, DWORD PTR _pszToken$[ebp]
	add	eax, 1
	mov	DWORD PTR _pszToken$[ebp], eax
	jmp	SHORT $L36575
$L36576:

; 302  : 
; 303  : 	return hash;

	mov	eax, DWORD PTR _hash$[ebp]

; 304  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HashString@CSaveRestoreBuffer@@IAEIPBD@Z ENDP		; CSaveRestoreBuffer::HashString
_TEXT	ENDS
PUBLIC	?TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z	; CSaveRestoreBuffer::TokenHash
PUBLIC	??_C@_0CF@IKIF@No?5token?5table?5array?5in?5TokenHas@ ; `string'
PUBLIC	??_C@_0DH@JDGM@CSaveRestoreBuffer?5?3?3?5TokenHash?$CI@ ; `string'
PUBLIC	??_C@_0DG@JDBL@CSaveRestoreBuffer?5?3?3?5TokenHash?$CI@ ; `string'
EXTRN	_strcmp:NEAR
;	COMDAT ??_C@_0CF@IKIF@No?5token?5table?5array?5in?5TokenHas@
; File z:\xashxtsrc\server\saverestore.cpp
CONST	SEGMENT
??_C@_0CF@IKIF@No?5token?5table?5array?5in?5TokenHas@ DB 'No token table '
	DB	'array in TokenHash()!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@JDGM@CSaveRestoreBuffer?5?3?3?5TokenHash?$CI@
CONST	SEGMENT
??_C@_0DH@JDGM@CSaveRestoreBuffer?5?3?3?5TokenHash?$CI@ DB 'CSaveRestoreB'
	DB	'uffer :: TokenHash() is getting too full!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JDBL@CSaveRestoreBuffer?5?3?3?5TokenHash?$CI@
CONST	SEGMENT
??_C@_0DG@JDBL@CSaveRestoreBuffer?5?3?3?5TokenHash?$CI@ DB 'CSaveRestoreB'
	DB	'uffer :: TokenHash() is COMPLETELY FULL!', 00H ; `string'
CONST	ENDS
;	COMDAT ?TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z
_TEXT	SEGMENT
_pszToken$ = 8
_this$ = -4
_hash$ = -8
_i$ = -12
_index$36597 = -16
?TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z PROC NEAR	; CSaveRestoreBuffer::TokenHash, COMDAT

; 307  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 308  : 	unsigned short	hash = (unsigned short)(HashString( pszToken ) % (unsigned)m_pdata->tokenCount );

	mov	eax, DWORD PTR _pszToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HashString@CSaveRestoreBuffer@@IAEIPBD@Z ; CSaveRestoreBuffer::HashString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	xor	edx, edx
	div	DWORD PTR [ecx+20]
	mov	WORD PTR _hash$[ebp], dx

; 309  : 	
; 310  : #if _DEBUG
; 311  : 	static int tokensparsed = 0;
; 312  : 	tokensparsed++;

	mov	edx, DWORD PTR _?tokensparsed@?1??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA
	add	edx, 1
	mov	DWORD PTR _?tokensparsed@?1??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA, edx

; 313  : 	if ( !m_pdata->tokenCount || !m_pdata->pTokens )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $L36587
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $L36586
$L36587:

; 314  : 		ALERT( at_error, "No token table array in TokenHash()!" );

	push	OFFSET FLAT:??_C@_0CF@IKIF@No?5token?5table?5array?5in?5TokenHas@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L36586:

; 315  : #endif
; 316  : 
; 317  : 	for ( int i=0; i<m_pdata->tokenCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L36590
$L36591:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L36590:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jge	$L36592

; 319  : #if _DEBUG
; 320  : 		static qboolean beentheredonethat = FALSE;
; 321  : 		if ( i > 50 && !beentheredonethat )

	cmp	DWORD PTR _i$[ebp], 50			; 00000032H
	jle	SHORT $L36595
	cmp	DWORD PTR _?beentheredonethat@?5??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA, 0
	jne	SHORT $L36595

; 323  : 			beentheredonethat = TRUE;

	mov	DWORD PTR _?beentheredonethat@?5??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA, 1

; 324  : 			ALERT( at_error, "CSaveRestoreBuffer :: TokenHash() is getting too full!" );

	push	OFFSET FLAT:??_C@_0DH@JDGM@CSaveRestoreBuffer?5?3?3?5TokenHash?$CI@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L36595:

; 326  : #endif
; 327  : 
; 328  : 		int	index = hash + i;

	mov	edx, DWORD PTR _hash$[ebp]
	and	edx, 65535				; 0000ffffH
	add	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _index$36597[ebp], edx

; 329  : 		if ( index >= m_pdata->tokenCount )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _index$36597[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jl	SHORT $L36598

; 330  : 			index -= m_pdata->tokenCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _index$36597[ebp]
	sub	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _index$36597[ebp], edx
$L36598:

; 331  : 
; 332  : 		if ( !m_pdata->pTokens[index] || strcmp( pszToken, m_pdata->pTokens[index] ) == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _index$36597[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $L36600
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _index$36597[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _pszToken$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L36599
$L36600:

; 334  : 			m_pdata->pTokens[index] = (char *)pszToken;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _index$36597[ebp]
	mov	edx, DWORD PTR _pszToken$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 335  : 			return index;

	mov	ax, WORD PTR _index$36597[ebp]
	jmp	SHORT $L36580
$L36599:

; 337  : 	}

	jmp	$L36591
$L36592:

; 338  : 		
; 339  : 	// Token hash table full!!! 
; 340  : 	// [Consider doing overflow table(s) after the main table & limiting linear hash table search]
; 341  : 	ALERT( at_error, "CSaveRestoreBuffer :: TokenHash() is COMPLETELY FULL!" );

	push	OFFSET FLAT:??_C@_0DG@JDBL@CSaveRestoreBuffer?5?3?3?5TokenHash?$CI@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 342  : 	return 0;

	xor	ax, ax
$L36580:

; 343  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z ENDP		; CSaveRestoreBuffer::TokenHash
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	?Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z ; CSave::Log
PUBLIC	??_C@_07HFGP@?$CFs?9?$DO?$CFs?5?$AA@		; `string'
PUBLIC	??_C@_02MECO@?$CFd?$AA@				; `string'
PUBLIC	??_C@_02JBAA@?$CFf?$AA@				; `string'
PUBLIC	??_C@_02DILL@?$CFs?$AA@				; `string'
PUBLIC	??_C@_0L@IEAL@?$CI?$CFf?5?$CFf?5?$CFf?$CJ?$AA@	; `string'
PUBLIC	??_C@_01FCOA@?5?$AA@				; `string'
PUBLIC	??_C@_01BJG@?6?$AA@				; `string'
EXTRN	?Q_strncat@@YAIPADPBDI@Z:NEAR			; Q_strncat
EXTRN	?Q_strncpy@@YAIPADPBDI@Z:NEAR			; Q_strncpy
EXTRN	?Q_snprintf@@YAHPADIPBDZZ:NEAR			; Q_snprintf
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:NEAR ; UTIL_FunctionToName
EXTRN	__fltused:NEAR
_BSS	SEGMENT
_?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA DB 0400H DUP (?)
_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA DB 0100H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_07HFGP@?$CFs?9?$DO?$CFs?5?$AA@
; File z:\xashxtsrc\server\saverestore.cpp
CONST	SEGMENT
??_C@_07HFGP@?$CFs?9?$DO?$CFs?5?$AA@ DB '%s->%s ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
CONST	SEGMENT
??_C@_02MECO@?$CFd?$AA@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JBAA@?$CFf?$AA@
CONST	SEGMENT
??_C@_02JBAA@?$CFf?$AA@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DILL@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DILL@?$CFs?$AA@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IEAL@?$CI?$CFf?5?$CFf?5?$CFf?$CJ?$AA@
CONST	SEGMENT
??_C@_0L@IEAL@?$CI?$CFf?5?$CFf?5?$CFf?$CJ?$AA@ DB '(%f %f %f)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01FCOA@?5?$AA@
CONST	SEGMENT
??_C@_01FCOA@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT
??_C@_01BJG@?6?$AA@ DB 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z
_TEXT	SEGMENT
_pMap$ = 8
_pName$ = 12
_pFieldName$ = 16
_fieldType$ = 20
_value$ = 24
_count$ = 28
_this$ = -4
_iCount$ = -8
_pValue$36626 = -12
_nValue$36628 = -16
_pValue$36631 = -20
_flValue$36633 = -24
_pValue$36636 = -28
_bValue$36638 = -32
_pValue$36641 = -36
_nValue$36643 = -40
_pValue$36645 = -44
_sValue$36647 = -48
_pValue$36651 = -52
_vecValue$36653 = -64
_pValue$36657 = -68
_chValue$36659 = -72
_pValue$36661 = -76
_funcName$36663 = -80
?Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z PROC NEAR ; CSave::Log, COMDAT

; 346  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 347  : 	// Check to see if we are logging.
; 348  : 	static char szBuf[1024];
; 349  : 	static char szTempBuf[256];
; 350  : 
; 351  : 	// Save the name.
; 352  : 	Q_snprintf( szBuf, sizeof( szBuf ), "%s->%s ", pName, pFieldName );

	mov	eax, DWORD PTR _pFieldName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_07HFGP@?$CFs?9?$DO?$CFs?5?$AA@ ; `string'
	push	1024					; 00000400H
	push	OFFSET FLAT:_?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 20					; 00000014H

; 353  : 
; 354  : 	for ( int iCount = 0; iCount < count; iCount++ )

	mov	DWORD PTR _iCount$[ebp], 0
	jmp	SHORT $L36618
$L36619:
	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$[ebp], edx
$L36618:
	mov	eax, DWORD PTR _iCount$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$L36620

; 357  : 		{

	mov	ecx, DWORD PTR _fieldType$[ebp]
	mov	DWORD PTR -84+[ebp], ecx
	cmp	DWORD PTR -84+[ebp], 17			; 00000011H
	ja	$L36665
	mov	eax, DWORD PTR -84+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L37696[eax]
	jmp	DWORD PTR $L37697[edx*4]
$L36625:

; 360  : 				short *pValue = ( short* )( value );

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$36626[ebp], ecx

; 361  : 				short nValue = pValue[iCount];

	mov	edx, DWORD PTR _iCount$[ebp]
	mov	eax, DWORD PTR _pValue$36626[ebp]
	mov	cx, WORD PTR [eax+edx*2]
	mov	WORD PTR _nValue$36628[ebp], cx

; 362  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%d", nValue );

	movsx	edx, WORD PTR _nValue$36628[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 363  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET FLAT:_?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 364  : 				break;

	jmp	$L36622
$L36630:

; 369  : 				float *pValue = ( float* )( value );

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$36631[ebp], eax

; 370  : 				float flValue = pValue[iCount];

	mov	ecx, DWORD PTR _iCount$[ebp]
	mov	edx, DWORD PTR _pValue$36631[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _flValue$36633[ebp], eax

; 371  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%f", flValue );

	fld	DWORD PTR _flValue$36633[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_02JBAA@?$CFf?$AA@	; `string'
	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 20					; 00000014H

; 372  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET FLAT:_?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 373  : 				break;

	jmp	$L36622
$L36635:

; 377  : 				bool *pValue = ( bool* )( value );

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$36636[ebp], ecx

; 378  : 				bool bValue = pValue[iCount];

	mov	edx, DWORD PTR _pValue$36636[ebp]
	add	edx, DWORD PTR _iCount$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _bValue$36638[ebp], al

; 379  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%d", ( int )( bValue ) );

	mov	ecx, DWORD PTR _bValue$36638[ebp]
	and	ecx, 255				; 000000ffH
	push	ecx
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 380  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET FLAT:_?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 381  : 				break;

	jmp	$L36622
$L36640:

; 385  : 				int *pValue = ( int* )( value );

	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$36641[ebp], edx

; 386  : 				int nValue = pValue[iCount];

	mov	eax, DWORD PTR _iCount$[ebp]
	mov	ecx, DWORD PTR _pValue$36641[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _nValue$36643[ebp], edx

; 387  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%d", nValue );

	mov	eax, DWORD PTR _nValue$36643[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 388  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET FLAT:_?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 389  : 				break;

	jmp	$L36622
$L36644:

; 395  : 				string_t *pValue = ( string_t* )( value );

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$36645[ebp], ecx

; 396  : 				string_t sValue = pValue[iCount];

	mov	edx, DWORD PTR _iCount$[ebp]
	mov	eax, DWORD PTR _pValue$36645[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _sValue$36647[ebp], ecx

; 397  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%s", ( char* )STRING( sValue ) );

	mov	edx, DWORD PTR _sValue$36647[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_02DILL@?$CFs?$AA@	; `string'
	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 398  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET FLAT:_?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 399  : 				break;					

	jmp	$L36622
$L36650:

; 404  : 				Vector *pValue = ( Vector* )( value );

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$36651[ebp], eax

; 405  : 				Vector vecValue = pValue[iCount];

	mov	ecx, DWORD PTR _iCount$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _pValue$36651[ebp]
	add	edx, ecx
	push	edx
	lea	ecx, DWORD PTR _vecValue$36653[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 406  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "(%f %f %f)", vecValue.x, vecValue.y, vecValue.z );

	fld	DWORD PTR _vecValue$36653[ebp+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _vecValue$36653[ebp+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _vecValue$36653[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0L@IEAL@?$CI?$CFf?5?$CFf?5?$CFf?$CJ?$AA@ ; `string'
	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 36					; 00000024H

; 407  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET FLAT:_?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 408  : 				break;

	jmp	$L36622
$L36655:

; 412  : 				if( count != 1 ) break;

	cmp	DWORD PTR _count$[ebp], 1
	je	SHORT $L36656
	jmp	$L36622
$L36656:

; 413  : 				char *pValue = ( char* )( value );

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$36657[ebp], eax

; 414  : 				char chValue = pValue[iCount];

	mov	ecx, DWORD PTR _pValue$36657[ebp]
	add	ecx, DWORD PTR _iCount$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _chValue$36659[ebp], dl

; 415  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%d", chValue );

	movsx	eax, BYTE PTR _chValue$36659[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 416  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET FLAT:_?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 417  : 				break;

	jmp	SHORT $L36622
$L36660:

; 421  : 				const int *pValue = (int *)value;

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$36661[ebp], ecx

; 422  : 				const char *funcName = UTIL_FunctionToName( pMap, (void *)( *pValue ));

	mov	edx, DWORD PTR _pValue$36661[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pMap$[ebp]
	push	ecx
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	mov	DWORD PTR _funcName$36663[ebp], eax

; 423  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%s", funcName );

	mov	edx, DWORD PTR _funcName$36663[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_02DILL@?$CFs?$AA@	; `string'
	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 424  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET FLAT:_?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L36665:
$L36622:

; 430  : 
; 431  : 		// Add space data.
; 432  : 		if ( ( iCount + 1 ) != count )

	mov	eax, DWORD PTR _iCount$[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR _count$[ebp]
	je	SHORT $L36666

; 434  : 			Q_strncpy( szTempBuf, " ", sizeof( szTempBuf ) );

	push	256					; 00000100H
	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 435  : 			Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET FLAT:_?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 437  : 		else

	jmp	SHORT $L36668
$L36666:

; 439  : 			Q_strncpy( szTempBuf, "\n", sizeof( szTempBuf ) );

	push	256					; 00000100H
	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 440  : 			Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET FLAT:_?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET FLAT:_?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L36668:

; 442  : 	}

	jmp	$L36619
$L36620:

; 443  : 
; 444  : 	ALERT( at_console, szBuf );

	push	OFFSET FLAT:_?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 445  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L37697:
	DD	$L36630
	DD	$L36644
	DD	$L36650
	DD	$L36640
	DD	$L36660
	DD	$L36635
	DD	$L36625
	DD	$L36655
	DD	$L36665
$L37696:
	DB	0
	DB	1
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	2
	DB	2
	DB	8
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	0
	DB	1
	DB	1
?Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z ENDP ; CSave::Log
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	?WriteData@CSave@@QAEXPBDH0@Z			; CSave::WriteData
PUBLIC	?BufferField@CSave@@AAEXPBDH0@Z			; CSave::BufferField
;	COMDAT ?WriteData@CSave@@QAEXPBDH0@Z
_TEXT	SEGMENT
_pname$ = 8
_size$ = 12
_pdata$ = 16
_this$ = -4
?WriteData@CSave@@QAEXPBDH0@Z PROC NEAR			; CSave::WriteData, COMDAT

; 448  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 449  : 	BufferField( pname, size, pdata );

	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferField@CSave@@AAEXPBDH0@Z		; CSave::BufferField

; 450  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteData@CSave@@QAEXPBDH0@Z ENDP			; CSave::WriteData
_TEXT	ENDS
PUBLIC	?WriteShort@CSave@@QAEXPBDPBFH@Z		; CSave::WriteShort
;	COMDAT ?WriteShort@CSave@@QAEXPBDPBFH@Z
_TEXT	SEGMENT
_pname$ = 8
_data$ = 12
_count$ = 16
_this$ = -4
?WriteShort@CSave@@QAEXPBDPBFH@Z PROC NEAR		; CSave::WriteShort, COMDAT

; 453  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 454  : 	BufferField( pname, sizeof(short) * count, (const char *)data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferField@CSave@@AAEXPBDH0@Z		; CSave::BufferField

; 455  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteShort@CSave@@QAEXPBDPBFH@Z ENDP			; CSave::WriteShort
_TEXT	ENDS
PUBLIC	?WriteInt@CSave@@QAEXPBDPBHH@Z			; CSave::WriteInt
;	COMDAT ?WriteInt@CSave@@QAEXPBDPBHH@Z
_TEXT	SEGMENT
_pname$ = 8
_data$ = 12
_count$ = 16
_this$ = -4
?WriteInt@CSave@@QAEXPBDPBHH@Z PROC NEAR		; CSave::WriteInt, COMDAT

; 458  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 459  : 	BufferField( pname, sizeof(int) * count, (const char *)data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferField@CSave@@AAEXPBDH0@Z		; CSave::BufferField

; 460  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteInt@CSave@@QAEXPBDPBHH@Z ENDP			; CSave::WriteInt
_TEXT	ENDS
PUBLIC	?WriteFloat@CSave@@QAEXPBDPBMH@Z		; CSave::WriteFloat
;	COMDAT ?WriteFloat@CSave@@QAEXPBDPBMH@Z
_TEXT	SEGMENT
_pname$ = 8
_data$ = 12
_count$ = 16
_this$ = -4
?WriteFloat@CSave@@QAEXPBDPBMH@Z PROC NEAR		; CSave::WriteFloat, COMDAT

; 463  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 464  : 	BufferField( pname, sizeof(float) * count, (const char *)data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferField@CSave@@AAEXPBDH0@Z		; CSave::BufferField

; 465  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteFloat@CSave@@QAEXPBDPBMH@Z ENDP			; CSave::WriteFloat
_TEXT	ENDS
PUBLIC	?WriteTime@CSave@@QAEXPBDPBMH@Z			; CSave::WriteTime
PUBLIC	?BufferData@CSave@@AAEXPBDH@Z			; CSave::BufferData
PUBLIC	?BufferHeader@CSave@@AAEXPBDH@Z			; CSave::BufferHeader
;	COMDAT ?WriteTime@CSave@@QAEXPBDPBMH@Z
_TEXT	SEGMENT
_pname$ = 8
_data$ = 12
_count$ = 16
_this$ = -4
_i$ = -8
_tmp$ = -20
_input$ = -32
_tmp$36713 = -36
?WriteTime@CSave@@QAEXPBDPBMH@Z PROC NEAR		; CSave::WriteTime, COMDAT

; 468  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 469  : 	int i;
; 470  : 	Vector tmp, input;

	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _input$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 471  : 
; 472  : 	BufferHeader( pname, sizeof(float) * count );

	mov	eax, DWORD PTR _count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferHeader@CSave@@AAEXPBDH@Z		; CSave::BufferHeader

; 473  : 	for ( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L36710
$L36711:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L36710:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	SHORT $L36712

; 475  : 		float tmp = data[0];

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _tmp$36713[ebp], edx

; 476  : 
; 477  : 		// Always encode time as a delta from the current time so it can be re-based if loaded in a new level
; 478  : 		// Times of 0 are never written to the file, so they will be restored as 0, not a relative time
; 479  : 		if ( m_pdata )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $L36714

; 480  : 			tmp -= m_pdata->time;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	fld	DWORD PTR _tmp$36713[ebp]
	fsub	DWORD PTR [edx+1360]
	fstp	DWORD PTR _tmp$36713[ebp]
$L36714:

; 481  : 
; 482  : 		BufferData( (const char *)&tmp, sizeof(float) );

	push	4
	lea	eax, DWORD PTR _tmp$36713[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 483  : 		data ++;

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 4
	mov	DWORD PTR _data$[ebp], ecx

; 484  : 	}

	jmp	SHORT $L36711
$L36712:

; 485  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteTime@CSave@@QAEXPBDPBMH@Z ENDP			; CSave::WriteTime
_TEXT	ENDS
PUBLIC	?WriteString@CSave@@QAEXPBD0@Z			; CSave::WriteString
EXTRN	_strlen:NEAR
;	COMDAT ?WriteString@CSave@@QAEXPBD0@Z
_TEXT	SEGMENT
_pname$ = 8
_pdata$ = 12
_this$ = -4
?WriteString@CSave@@QAEXPBD0@Z PROC NEAR		; CSave::WriteString, COMDAT

; 488  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 489  : #ifdef TOKENIZE
; 490  : 	short	token = (short)TokenHash( pdata );
; 491  : 	WriteShort( pname, &token, 1 );
; 492  : #else
; 493  : 	BufferField( pname, strlen(pdata) + 1, pdata );

	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdata$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferField@CSave@@AAEXPBDH0@Z		; CSave::BufferField

; 494  : #endif
; 495  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?WriteString@CSave@@QAEXPBD0@Z ENDP			; CSave::WriteString
_TEXT	ENDS
PUBLIC	?WriteString@CSave@@QAEXPBDPBHH@Z		; CSave::WriteString
;	COMDAT ?WriteString@CSave@@QAEXPBDPBHH@Z
_TEXT	SEGMENT
_pname$ = 8
_stringId$ = 12
_count$ = 16
_this$ = -4
_i$ = -8
_size$ = -12
_pString$36736 = -16
?WriteString@CSave@@QAEXPBDPBHH@Z PROC NEAR		; CSave::WriteString, COMDAT

; 498  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 499  : 	int i, size;
; 500  : 
; 501  : #ifdef TOKENIZE
; 502  : 	short	token = (short)TokenHash( STRING( *stringId ) );
; 503  : 	WriteShort( pname, &token, 1 );
; 504  : #else
; 505  : 	size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 506  : 	for ( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L36730
$L36731:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L36730:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jge	SHORT $L36732

; 507  : 		size += strlen( STRING( stringId[i] ) ) + 1;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _stringId$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _size$[ebp]
	lea	eax, DWORD PTR [edx+eax+1]
	mov	DWORD PTR _size$[ebp], eax
	jmp	SHORT $L36731
$L36732:

; 508  : 
; 509  : 	BufferHeader( pname, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferHeader@CSave@@AAEXPBDH@Z		; CSave::BufferHeader

; 510  : 	for ( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L36733
$L36734:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L36733:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jge	SHORT $L36735

; 512  : 		const char *pString = STRING(stringId[i]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _stringId$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _pString$36736[ebp], eax

; 513  : 		BufferData( pString, strlen(pString)+1 );

	mov	edx, DWORD PTR _pString$36736[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	eax, DWORD PTR _pString$36736[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 514  : 	}

	jmp	SHORT $L36734
$L36735:

; 515  : #endif
; 516  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteString@CSave@@QAEXPBDPBHH@Z ENDP			; CSave::WriteString
_TEXT	ENDS
PUBLIC	?WriteVector@CSave@@QAEXPBDABVVector@@@Z	; CSave::WriteVector
PUBLIC	?WriteVector@CSave@@QAEXPBDPBMH@Z		; CSave::WriteVector
;	COMDAT ?WriteVector@CSave@@QAEXPBDABVVector@@@Z
_TEXT	SEGMENT
_pname$ = 8
_value$ = 12
_this$ = -4
?WriteVector@CSave@@QAEXPBDABVVector@@@Z PROC NEAR	; CSave::WriteVector, COMDAT

; 519  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 520  : 	WriteVector( pname, &value.x, 1 );

	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteVector@CSave@@QAEXPBDPBMH@Z	; CSave::WriteVector

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?WriteVector@CSave@@QAEXPBDABVVector@@@Z ENDP		; CSave::WriteVector
_TEXT	ENDS
;	COMDAT ?WriteVector@CSave@@QAEXPBDPBMH@Z
_TEXT	SEGMENT
_pname$ = 8
_value$ = 12
_count$ = 16
_this$ = -4
?WriteVector@CSave@@QAEXPBDPBMH@Z PROC NEAR		; CSave::WriteVector, COMDAT

; 524  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 525  : 	BufferHeader( pname, sizeof(float) * 3 * count );

	mov	eax, DWORD PTR _count$[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferHeader@CSave@@AAEXPBDH@Z		; CSave::BufferHeader

; 526  : 	BufferData( (const char *)value, sizeof(float) * 3 * count );

	mov	edx, DWORD PTR _count$[ebp]
	imul	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 527  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteVector@CSave@@QAEXPBDPBMH@Z ENDP			; CSave::WriteVector
_TEXT	ENDS
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	?WritePositionVector@CSave@@QAEXPBDABVVector@@@Z ; CSave::WritePositionVector
;	COMDAT ?WritePositionVector@CSave@@QAEXPBDABVVector@@@Z
_TEXT	SEGMENT
$T37721 = -28
_pname$ = 8
_value$ = 12
_this$ = -4
_tmp$36757 = -16
?WritePositionVector@CSave@@QAEXPBDABVVector@@@Z PROC NEAR ; CSave::WritePositionVector, COMDAT

; 530  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 531  : 	if ( m_pdata && m_pdata->fUseLandmark )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $L36756
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	DWORD PTR [edx+1324], 0
	je	SHORT $L36756

; 533  : 		Vector tmp = value - m_pdata->vecLandmarkOffset;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1348				; 00000544H
	push	ecx
	lea	edx, DWORD PTR $T37721[ebp]
	push	edx
	mov	ecx, DWORD PTR _value$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _tmp$36757[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 534  : 		WriteVector( pname, tmp );

	lea	eax, DWORD PTR _tmp$36757[ebp]
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteVector@CSave@@QAEXPBDABVVector@@@Z ; CSave::WriteVector
$L36756:

; 536  : 
; 537  : 	WriteVector( pname, value );

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _pname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteVector@CSave@@QAEXPBDABVVector@@@Z ; CSave::WriteVector

; 538  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?WritePositionVector@CSave@@QAEXPBDABVVector@@@Z ENDP	; CSave::WritePositionVector
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T37724 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T37724[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	?WritePositionVector@CSave@@QAEXPBDPBMH@Z	; CSave::WritePositionVector
;	COMDAT ?WritePositionVector@CSave@@QAEXPBDPBMH@Z
_TEXT	SEGMENT
$T37729 = -56
_pname$ = 8
_value$ = 12
_count$ = 16
_this$ = -4
_i$ = -8
_tmp$ = -20
_input$ = -32
_tmp$36772 = -44
?WritePositionVector@CSave@@QAEXPBDPBMH@Z PROC NEAR	; CSave::WritePositionVector, COMDAT

; 541  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 542  : 	int i;
; 543  : 	Vector tmp, input;

	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _input$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 544  : 
; 545  : 	BufferHeader( pname, sizeof(float) * 3 * count );

	mov	eax, DWORD PTR _count$[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferHeader@CSave@@AAEXPBDH@Z		; CSave::BufferHeader

; 546  : 	for ( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L36769
$L36770:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L36769:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	SHORT $L36771

; 548  : 		Vector tmp( value[0], value[1], value[2] );

	mov	ecx, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _tmp$36772[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 549  : 
; 550  : 		if ( m_pdata && m_pdata->fUseLandmark )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $L36773
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	DWORD PTR [eax+1324], 0
	je	SHORT $L36773

; 551  : 			tmp = tmp - m_pdata->vecLandmarkOffset;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1348				; 00000544H
	push	edx
	lea	eax, DWORD PTR $T37729[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmp$36772[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tmp$36772[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _tmp$36772[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _tmp$36772[ebp+8], eax
$L36773:

; 552  : 
; 553  : 		BufferData( (const char *)&tmp.x, sizeof(float) * 3 );

	push	12					; 0000000cH
	lea	ecx, DWORD PTR _tmp$36772[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 554  : 		value += 3;

	mov	edx, DWORD PTR _value$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _value$[ebp], edx

; 555  : 	}

	jmp	$L36770
$L36771:

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WritePositionVector@CSave@@QAEXPBDPBMH@Z ENDP		; CSave::WritePositionVector
_TEXT	ENDS
PUBLIC	?WriteFunction@CSave@@QAEXPAUdatamap_s@@PBDPBHH@Z ; CSave::WriteFunction
PUBLIC	??_C@_0CH@ECB@Invalid?5function?5pointer?5in?5clas@ ; `string'
;	COMDAT ??_C@_0CH@ECB@Invalid?5function?5pointer?5in?5clas@
; File z:\xashxtsrc\server\saverestore.cpp
CONST	SEGMENT
??_C@_0CH@ECB@Invalid?5function?5pointer?5in?5clas@ DB 'Invalid function '
	DB	'pointer in class %s!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?WriteFunction@CSave@@QAEXPAUdatamap_s@@PBDPBHH@Z
_TEXT	SEGMENT
_pRootMap$ = 8
_pname$ = 12
_data$ = 16
_this$ = -4
_functionName$ = -8
?WriteFunction@CSave@@QAEXPAUdatamap_s@@PBDPBHH@Z PROC NEAR ; CSave::WriteFunction, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 560  : 	const char *functionName = UTIL_FunctionToName( pRootMap, (void *)(*data) );

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pRootMap$[ebp]
	push	edx
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	mov	DWORD PTR _functionName$[ebp], eax

; 561  : 
; 562  : 	if ( functionName )

	cmp	DWORD PTR _functionName$[ebp], 0
	je	SHORT $L36786

; 563  : 		BufferField( pname, strlen(functionName) + 1, functionName );

	mov	eax, DWORD PTR _functionName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _functionName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferField@CSave@@AAEXPBDH0@Z		; CSave::BufferField

; 564  : 	else

	jmp	SHORT $L36787
$L36786:

; 565  : 		ALERT( at_error, "Invalid function pointer in class %s!\n", pRootMap->dataClassName );

	mov	eax, DWORD PTR _pRootMap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET FLAT:??_C@_0CH@ECB@Invalid?5function?5pointer?5in?5clas@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L36787:

; 566  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?WriteFunction@CSave@@QAEXPAUdatamap_s@@PBDPBHH@Z ENDP	; CSave::WriteFunction
_TEXT	ENDS
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z	; CBaseEntity::Instance
PUBLIC	?EntvarsKeyvalue@@YAXPAUentvars_s@@PAUKeyValueData_s@@@Z ; EntvarsKeyvalue
PUBLIC	??_C@_0BH@DPBM@Bad?5field?5in?5entity?$CB?$CB?6?$AA@ ; `string'
EXTRN	?UTIL_StringToVector@@YAXPAMPBD@Z:NEAR		; UTIL_StringToVector
EXTRN	_atof:NEAR
EXTRN	_atoi:NEAR
EXTRN	?UTIL_SetMovedir@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_SetMovedir
EXTRN	?Q_strnicmp@@YAHPBD0H@Z:NEAR			; Q_strnicmp
EXTRN	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsOrigin
EXTRN	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsAngles
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
;	COMDAT ??_C@_0BH@DPBM@Bad?5field?5in?5entity?$CB?$CB?6?$AA@
; File z:\xashxtsrc\server\saverestore.cpp
CONST	SEGMENT
??_C@_0BH@DPBM@Bad?5field?5in?5entity?$CB?$CB?6?$AA@ DB 'Bad field in ent'
	DB	'ity!!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?EntvarsKeyvalue@@YAXPAUentvars_s@@PAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
_pkvd$ = 12
_pField$ = -4
_i$ = -8
_pEntity$36818 = -12
_pEntity$36822 = -16
?EntvarsKeyvalue@@YAXPAUentvars_s@@PAUKeyValueData_s@@@Z PROC NEAR ; EntvarsKeyvalue, COMDAT

; 569  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 570  : 	TYPEDESCRIPTION *pField;
; 571  : 
; 572  : 	for ( int i = 0; i < ENTVARS_COUNT; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L36795
$L36796:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L36795:
	cmp	DWORD PTR _i$[ebp], 97			; 00000061H
	jae	$L36797

; 574  : 		pField = &gEntvarsDescription[i];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, OFFSET FLAT:?gEntvarsDescription@@3PAUtypedescription_s@@A ; gEntvarsDescription
	mov	DWORD PTR _pField$[ebp], ecx

; 575  : 
; 576  : 		if ( !Q_stricmp( pField->fieldName, pkvd->szKeyName ) )

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pField$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$L36798

; 579  : 			{

	mov	eax, DWORD PTR _pField$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR -20+[ebp], ecx
	cmp	DWORD PTR -20+[ebp], 17			; 00000011H
	ja	$L36815
	mov	eax, DWORD PTR -20+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L37734[eax]
	jmp	DWORD PTR $L37735[edx*4]
$L36803:

; 580  : 			case FIELD_MODELNAME:
; 581  : 			case FIELD_SOUNDNAME:
; 582  : 			case FIELD_STRING:
; 583  : 				(*(int *)((char *)pev + pField->fieldOffset)) = ALLOC_STRING( pkvd->szValue );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _pField$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 584  : 				break;

	jmp	SHORT $L36800
$L36806:

; 585  : 
; 586  : 			case FIELD_TIME:
; 587  : 			case FIELD_FLOAT:
; 588  : 				(*(float *)((char *)pev + pField->fieldOffset)) = atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atof
	add	esp, 4
	fst	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _pField$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _pev$[ebp]
	fstp	DWORD PTR [eax+edx]

; 589  : 				break;

	jmp	SHORT $L36800
$L36809:

; 590  : 
; 591  : 			case FIELD_INTEGER:
; 592  : 				(*(int *)((char *)pev + pField->fieldOffset)) = atoi( pkvd->szValue );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _pField$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 593  : 				break;

	jmp	SHORT $L36800
$L36812:

; 594  : 
; 595  : 			case FIELD_POSITION_VECTOR:
; 596  : 			case FIELD_VECTOR:
; 597  : 				UTIL_StringToVector( (float *)((char *)pev + pField->fieldOffset), pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _pField$[ebp]
	mov	edx, DWORD PTR _pev$[ebp]
	add	edx, DWORD PTR [ecx+8]
	push	edx
	call	?UTIL_StringToVector@@YAXPAMPBD@Z	; UTIL_StringToVector
	add	esp, 8

; 598  : 				break;

	jmp	SHORT $L36800
$L36815:

; 599  : 			case FIELD_EVARS:
; 600  : 			case FIELD_CLASSPTR:
; 601  : 			case FIELD_EDICT:
; 602  : 			case FIELD_ENTITY:
; 603  : 			case FIELD_POINTER:
; 604  : 			default:	ALERT( at_error, "Bad field in entity!!\n" );

	push	OFFSET FLAT:??_C@_0BH@DPBM@Bad?5field?5in?5entity?$CB?$CB?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L36800:

; 607  : 
; 608  : 			// g-cont. HACKHACK to set origin and angles properly
; 609  : 			if( FStrEq( pField->fieldName, "origin" ))

	push	OFFSET FLAT:??_C@_06NOHF@origin?$AA@	; `string'
	mov	eax, DWORD PTR _pField$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L36817

; 611  : 				CBaseEntity *pEntity = CBaseEntity::Instance( pev );

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$36818[ebp], eax

; 612  : 				if( pEntity ) pEntity->SetAbsOrigin( pev->origin );

	cmp	DWORD PTR _pEntity$36818[ebp], 0
	je	SHORT $L36819
	mov	eax, DWORD PTR _pev$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pEntity$36818[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin
$L36819:

; 614  : 			else if( FStrEq( pField->fieldName, "angles" ))

	jmp	$L36823
$L36817:
	push	OFFSET FLAT:??_C@_06MFB@angles?$AA@	; `string'
	mov	ecx, DWORD PTR _pField$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	$L36823

; 616  : 				CBaseEntity *pEntity = CBaseEntity::Instance( pev );

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$36822[ebp], eax

; 617  : 				if( pEntity )

	cmp	DWORD PTR _pEntity$36822[ebp], 0
	je	$L36823

; 619  : 					if( pEntity->ObjectCaps() & FCAP_SET_MOVEDIR )

	mov	ecx, DWORD PTR _pEntity$36822[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$36822[ebp]
	call	DWORD PTR [edx+24]
	and	eax, 1
	test	eax, eax
	je	SHORT $L36824

; 621  : 						UTIL_SetMovedir( pEntity );

	mov	eax, DWORD PTR _pEntity$36822[ebp]
	push	eax
	call	?UTIL_SetMovedir@@YAXPAVCBaseEntity@@@Z	; UTIL_SetMovedir
	add	esp, 4

; 623  : 					else if( pEntity->ObjectCaps() & FCAP_HOLD_ANGLES )

	jmp	SHORT $L36826
$L36824:
	mov	ecx, DWORD PTR _pEntity$36822[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$36822[ebp]
	call	DWORD PTR [edx+24]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $L36826

; 625  : 						pEntity->m_vecTempAngles = pev->angles;

	mov	eax, DWORD PTR _pev$[ebp]
	add	eax, 80					; 00000050H
	mov	ecx, DWORD PTR _pEntity$36822[ebp]
	add	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 626  : 						pev->angles = g_vecZero;

	mov	ecx, DWORD PTR _pev$[ebp]
	add	ecx, 80					; 00000050H
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [ecx+8], edx
$L36826:

; 628  : 					pEntity->SetAbsAngles( pev->angles );

	mov	eax, DWORD PTR _pev$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _pEntity$36822[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 629  : 					pEntity->m_fSetAngles = TRUE;

	mov	ecx, DWORD PTR _pEntity$36822[ebp]
	mov	DWORD PTR [ecx+72], 1
$L36823:

; 632  : 
; 633  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 634  : 			return;

	jmp	SHORT $L36792
$L36798:

; 636  : 	}

	jmp	$L36796
$L36797:
$L36792:

; 637  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L37735:
	DD	$L36806
	DD	$L36803
	DD	$L36812
	DD	$L36809
	DD	$L36815
$L37734:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	2
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	1
	DB	1
?EntvarsKeyvalue@@YAXPAUentvars_s@@PAUKeyValueData_s@@@Z ENDP ; EntvarsKeyvalue
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z PROC NEAR ; CBaseEntity::Instance, COMDAT

; 533  : 	static CBaseEntity *Instance( entvars_t *pev ) { return Instance( ENT( pev ) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
PUBLIC	?WriteEntVars@CSave@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z ; CSave::WriteEntVars
PUBLIC	?WriteFields@CSave@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ; CSave::WriteFields
;	COMDAT ?WriteEntVars@CSave@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z
_TEXT	SEGMENT
_pname$ = 8
_pMap$ = 12
_pev$ = 16
_this$ = -4
?WriteEntVars@CSave@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z PROC NEAR ; CSave::WriteEntVars, COMDAT

; 640  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 	return WriteFields( pname, pev, pMap, gEntvarsDescription, ENTVARS_COUNT );

	push	97					; 00000061H
	push	OFFSET FLAT:?gEntvarsDescription@@3PAUtypedescription_s@@A ; gEntvarsDescription
	mov	eax, DWORD PTR _pMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteFields@CSave@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ; CSave::WriteFields

; 642  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteEntVars@CSave@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z ENDP ; CSave::WriteEntVars
_TEXT	ENDS
PUBLIC	?DoWriteAll@CSave@@QAEHPBXPAUdatamap_s@@1@Z	; CSave::DoWriteAll
;	COMDAT ?DoWriteAll@CSave@@QAEHPBXPAUdatamap_s@@1@Z
_TEXT	SEGMENT
_pLeafObject$ = 8
_pLeafMap$ = 12
_pCurMap$ = 16
_this$ = -4
_status$36840 = -8
?DoWriteAll@CSave@@QAEHPBXPAUdatamap_s@@1@Z PROC NEAR	; CSave::DoWriteAll, COMDAT

; 649  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 650  : 	// save base classes first
; 651  : 	if ( pCurMap->baseMap )

	mov	eax, DWORD PTR _pCurMap$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L36841

; 653  : 		int status = DoWriteAll( pLeafObject, pLeafMap, pCurMap->baseMap );

	mov	ecx, DWORD PTR _pCurMap$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pLeafMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLeafObject$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoWriteAll@CSave@@QAEHPBXPAUdatamap_s@@1@Z ; CSave::DoWriteAll
	mov	DWORD PTR _status$36840[ebp], eax

; 654  : 		if( !status )

	cmp	DWORD PTR _status$36840[ebp], 0
	jne	SHORT $L36841

; 655  : 			return status;

	mov	eax, DWORD PTR _status$36840[ebp]
	jmp	SHORT $L36838
$L36841:

; 657  : 
; 658  : 	return WriteFields( pCurMap->dataClassName, pLeafObject, pLeafMap, pCurMap->dataDesc, pCurMap->dataNumFields );

	mov	edx, DWORD PTR _pCurMap$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pCurMap$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pLeafMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLeafObject$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCurMap$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteFields@CSave@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ; CSave::WriteFields
$L36838:

; 659  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DoWriteAll@CSave@@QAEHPBXPAUdatamap_s@@1@Z ENDP	; CSave::DoWriteAll
_TEXT	ENDS
PUBLIC	??_C@_0DB@CMHE@Can?8t?5save?5more?5than?5?$CFd?5entities@ ; `string'
PUBLIC	??_C@_0BA@JAEO@Bad?5field?5type?6?$AA@		; `string'
PUBLIC	??BEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator CBaseEntity *
PUBLIC	?DataEmpty@CSave@@AAEHPBDH@Z			; CSave::DataEmpty
;	COMDAT ??_C@_0DB@CMHE@Can?8t?5save?5more?5than?5?$CFd?5entities@
; File z:\xashxtsrc\server\saverestore.cpp
CONST	SEGMENT
??_C@_0DB@CMHE@Can?8t?5save?5more?5than?5?$CFd?5entities@ DB 'Can''t save'
	DB	' more than %d entities in an array!!!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JAEO@Bad?5field?5type?6?$AA@
CONST	SEGMENT
??_C@_0BA@JAEO@Bad?5field?5type?6?$AA@ DB 'Bad field type', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?WriteFields@CSave@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z
_TEXT	SEGMENT
_pOutputData$36866 = -288
_pname$ = 8
_pBaseData$ = 12
_pMap$ = 16
_pFields$ = 20
_fieldCount$ = 24
_this$ = -4
_i$ = -8
_j$ = -12
_actualCount$ = -16
_emptyCount$ = -20
_entityArray$ = -276
_pTest$ = -280
_pOutputData$36859 = -284
?WriteFields@CSave@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z PROC NEAR ; CSave::WriteFields, COMDAT

; 662  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 663  : 	int i, j, actualCount, emptyCount;
; 664  : 	int entityArray[MAX_ENTITYARRAY];
; 665  : 	TYPEDESCRIPTION *pTest;
; 666  : 
; 667  : 	// Precalculate the number of empty fields
; 668  : 	emptyCount = 0;

	mov	DWORD PTR _emptyCount$[ebp], 0

; 669  : 	for ( i = 0; i < fieldCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L36856
$L36857:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L36856:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _fieldCount$[ebp]
	jge	SHORT $L36858

; 671  : 		void *pOutputData;
; 672  : 		pOutputData = ((char *)pBaseData + pFields[i].fieldOffset );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pFields$[ebp]
	mov	ecx, DWORD PTR _pBaseData$[ebp]
	add	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _pOutputData$36859[ebp], ecx

; 673  : 		if ( DataEmpty( (const char *)pOutputData, pFields[i].fieldSize * gSizes[pFields[i].fieldType] ) )

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pFields$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+edx+12]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pFields$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	imul	ecx, DWORD PTR _gSizes[edx*4]
	push	ecx
	mov	eax, DWORD PTR _pOutputData$36859[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DataEmpty@CSave@@AAEHPBDH@Z		; CSave::DataEmpty
	test	eax, eax
	je	SHORT $L36862

; 674  : 			emptyCount++;

	mov	ecx, DWORD PTR _emptyCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _emptyCount$[ebp], ecx
$L36862:

; 675  : 	}

	jmp	SHORT $L36857
$L36858:

; 676  : 
; 677  : 	// Empty fields will not be written, write out the actual number of fields to be written
; 678  : 	actualCount = fieldCount - emptyCount;

	mov	edx, DWORD PTR _fieldCount$[ebp]
	sub	edx, DWORD PTR _emptyCount$[ebp]
	mov	DWORD PTR _actualCount$[ebp], edx

; 679  : 	WriteInt( pname, &actualCount, 1 );

	push	1
	lea	eax, DWORD PTR _actualCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteInt@CSave@@QAEXPBDPBHH@Z		; CSave::WriteInt

; 680  : 
; 681  : 	for ( i = 0; i < fieldCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L36863
$L36864:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L36863:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _fieldCount$[ebp]
	jge	$L36865

; 683  : 		void *pOutputData;
; 684  : 		pTest = &pFields[ i ];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pFields$[ebp]
	add	edx, ecx
	mov	DWORD PTR _pTest$[ebp], edx

; 685  : 		pOutputData = ((char *)pBaseData + pTest->fieldOffset );

	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR _pBaseData$[ebp]
	add	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pOutputData$36866[ebp], ecx

; 686  : 
; 687  : 		// UNDONE: Must we do this twice?
; 688  : 		if ( DataEmpty( (const char *)pOutputData, pTest->fieldSize * gSizes[pTest->fieldType] ) )

	mov	edx, DWORD PTR _pTest$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+12]
	mov	ecx, DWORD PTR _pTest$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	eax, DWORD PTR _gSizes[edx*4]
	push	eax
	mov	eax, DWORD PTR _pOutputData$36866[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DataEmpty@CSave@@AAEHPBDH@Z		; CSave::DataEmpty
	test	eax, eax
	je	SHORT $L36869

; 689  : 			continue;

	jmp	SHORT $L36864
$L36869:

; 695  : 		{

	mov	ecx, DWORD PTR _pTest$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR -292+[ebp], edx
	cmp	DWORD PTR -292+[ebp], 17		; 00000011H
	ja	$L36917
	mov	eax, DWORD PTR -292+[ebp]
	jmp	DWORD PTR $L37750[eax*4]
$L36874:

; 696  : 		case FIELD_FLOAT:
; 697  : 			WriteFloat( pTest->fieldName, (float *)pOutputData, pTest->fieldSize );

	mov	ecx, DWORD PTR _pTest$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pOutputData$36866[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTest$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteFloat@CSave@@QAEXPBDPBMH@Z	; CSave::WriteFloat

; 698  : 			break;

	jmp	$L36871
$L36876:

; 699  : 		case FIELD_TIME:
; 700  : 			WriteTime( pTest->fieldName, (float *)pOutputData, pTest->fieldSize );

	mov	eax, DWORD PTR _pTest$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _pOutputData$36866[ebp]
	push	edx
	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteTime@CSave@@QAEXPBDPBMH@Z		; CSave::WriteTime

; 701  : 			break;

	jmp	$L36871
$L36878:

; 702  : 		case FIELD_MODELNAME:
; 703  : 		case FIELD_SOUNDNAME:
; 704  : 		case FIELD_STRING:
; 705  : 			WriteString( pTest->fieldName, (int *)pOutputData, pTest->fieldSize );

	mov	edx, DWORD PTR _pTest$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _pOutputData$36866[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteString@CSave@@QAEXPBDPBHH@Z	; CSave::WriteString

; 706  : 			break;

	jmp	$L36871
$L36880:

; 707  : 		case FIELD_CLASSPTR:
; 708  : 		case FIELD_EVARS:
; 709  : 		case FIELD_EDICT:
; 710  : 		case FIELD_ENTITY:
; 711  : 		case FIELD_EHANDLE:
; 712  : 			if ( pTest->fieldSize > MAX_ENTITYARRAY )

	mov	ecx, DWORD PTR _pTest$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+12]
	cmp	edx, 64					; 00000040H
	jle	SHORT $L36881

; 713  : 				ALERT( at_error, "Can't save more than %d entities in an array!!!\n", MAX_ENTITYARRAY );

	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_0DB@CMHE@Can?8t?5save?5more?5than?5?$CFd?5entities@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L36881:

; 714  : 			for ( j = 0; j < pTest->fieldSize; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L36883
$L36884:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L36883:
	mov	ecx, DWORD PTR _pTest$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+12]
	cmp	DWORD PTR _j$[ebp], edx
	jge	$L36885

; 717  : 				{

	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR -296+[ebp], ecx
	mov	edx, DWORD PTR -296+[ebp]
	sub	edx, 2
	mov	DWORD PTR -296+[ebp], edx
	cmp	DWORD PTR -296+[ebp], 4
	ja	$L36887
	mov	eax, DWORD PTR -296+[ebp]
	jmp	DWORD PTR $L37751[eax*4]
$L36890:

; 718  : 					case FIELD_EVARS:
; 719  : 						entityArray[j] = EntityIndex( ((entvars_t **)pOutputData)[j] );

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pOutputData$36866[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUentvars_s@@@Z ; CSaveRestoreBuffer::EntityIndex
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _entityArray$[ebp+ecx*4], eax

; 720  : 					break;

	jmp	$L36887
$L36892:

; 721  : 					case FIELD_CLASSPTR:
; 722  : 						entityArray[j] = EntityIndex( ((CBaseEntity **)pOutputData)[j] );

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _pOutputData$36866[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAVCBaseEntity@@@Z ; CSaveRestoreBuffer::EntityIndex
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _entityArray$[ebp+edx*4], eax

; 723  : 					break;

	jmp	SHORT $L36887
$L36894:

; 724  : 					case FIELD_EDICT:
; 725  : 						entityArray[j] = EntityIndex( ((edict_t **)pOutputData)[j] );

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pOutputData$36866[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z ; CSaveRestoreBuffer::EntityIndex
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _entityArray$[ebp+ecx*4], eax

; 726  : 					break;

	jmp	SHORT $L36887
$L36896:

; 727  : 					case FIELD_ENTITY:
; 728  : 						entityArray[j] = EntityIndex( ((EOFFSET *)pOutputData)[j] );

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _pOutputData$36866[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHH@Z ; CSaveRestoreBuffer::EntityIndex
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _entityArray$[ebp+edx*4], eax

; 729  : 					break;

	jmp	SHORT $L36887
$L36898:

; 730  : 					case FIELD_EHANDLE:
; 731  : 						entityArray[j] = EntityIndex( (CBaseEntity *)(((EHANDLE *)pOutputData)[j]) );

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pOutputData$36866[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8]
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAVCBaseEntity@@@Z ; CSaveRestoreBuffer::EntityIndex
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _entityArray$[ebp+edx*4], eax
$L36887:

; 734  : 			}

	jmp	$L36884
$L36885:

; 735  : 			WriteInt( pTest->fieldName, entityArray, pTest->fieldSize );

	mov	eax, DWORD PTR _pTest$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+12]
	push	ecx
	lea	edx, DWORD PTR _entityArray$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteInt@CSave@@QAEXPBDPBHH@Z		; CSave::WriteInt

; 736  : 			break;

	jmp	$L36871
$L36901:

; 737  : 		case FIELD_POSITION_VECTOR:
; 738  : 			WritePositionVector( pTest->fieldName, (float *)pOutputData, pTest->fieldSize );

	mov	edx, DWORD PTR _pTest$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _pOutputData$36866[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WritePositionVector@CSave@@QAEXPBDPBMH@Z ; CSave::WritePositionVector

; 739  : 			break;

	jmp	$L36871
$L36903:

; 740  : 		case FIELD_VECTOR:
; 741  : 			WriteVector( pTest->fieldName, (float *)pOutputData, pTest->fieldSize );

	mov	ecx, DWORD PTR _pTest$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pOutputData$36866[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTest$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteVector@CSave@@QAEXPBDPBMH@Z	; CSave::WriteVector

; 742  : 			break;

	jmp	$L36871
$L36905:

; 743  : 		case FIELD_BOOLEAN:
; 744  : 		case FIELD_INTEGER:
; 745  : 			WriteInt( pTest->fieldName, (int *)pOutputData, pTest->fieldSize );

	mov	eax, DWORD PTR _pTest$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _pOutputData$36866[ebp]
	push	edx
	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteInt@CSave@@QAEXPBDPBHH@Z		; CSave::WriteInt

; 746  : 			break;

	jmp	$L36871
$L36907:

; 747  : 		case FIELD_SHORT:
; 748  : 			WriteData( pTest->fieldName, 2 * pTest->fieldSize, ((char *)pOutputData) );

	mov	edx, DWORD PTR _pOutputData$36866[ebp]
	push	edx
	mov	eax, DWORD PTR _pTest$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+12]
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteData@CSave@@QAEXPBDH0@Z		; CSave::WriteData

; 749  : 			break;

	jmp	$L36871
$L36909:

; 750  : 		case FIELD_CHARACTER:
; 751  : 			WriteData( pTest->fieldName, pTest->fieldSize, ((char *)pOutputData) );

	mov	ecx, DWORD PTR _pOutputData$36866[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTest$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _pTest$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteData@CSave@@QAEXPBDH0@Z		; CSave::WriteData

; 752  : 			break;

	jmp	SHORT $L36871
$L36911:

; 753  : 		// For now, just write the address out, we're not going to change memory while doing this yet!
; 754  : 		case FIELD_POINTER:
; 755  : 			WriteInt( pTest->fieldName, (int *)(char *)pOutputData, pTest->fieldSize );

	mov	eax, DWORD PTR _pTest$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _pOutputData$36866[ebp]
	push	edx
	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteInt@CSave@@QAEXPBDPBHH@Z		; CSave::WriteInt

; 756  : 			break;

	jmp	SHORT $L36871
$L36914:

; 757  : 		case FIELD_FUNCTION:
; 758  : 			WriteFunction( pMap, pTest->fieldName, (int *)(char *)pOutputData, pTest->fieldSize );

	mov	edx, DWORD PTR _pTest$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _pOutputData$36866[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pMap$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteFunction@CSave@@QAEXPAUdatamap_s@@PBDPBHH@Z ; CSave::WriteFunction

; 759  : 			break;

	jmp	SHORT $L36871
$L36917:

; 760  : 		default:
; 761  : 			ALERT( at_error, "Bad field type\n" );

	push	OFFSET FLAT:??_C@_0BA@JAEO@Bad?5field?5type?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L36871:

; 764  : 	}

	jmp	$L36864
$L36865:

; 765  : 
; 766  : 	return 1;

	mov	eax, 1

; 767  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L37750:
	DD	$L36874
	DD	$L36878
	DD	$L36880
	DD	$L36880
	DD	$L36880
	DD	$L36880
	DD	$L36880
	DD	$L36903
	DD	$L36901
	DD	$L36911
	DD	$L36905
	DD	$L36914
	DD	$L36905
	DD	$L36907
	DD	$L36909
	DD	$L36876
	DD	$L36878
	DD	$L36878
$L37751:
	DD	$L36896
	DD	$L36892
	DD	$L36898
	DD	$L36890
	DD	$L36894
?WriteFields@CSave@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ENDP ; CSave::WriteFields
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator CBaseEntity *, COMDAT

; 64   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator CBaseEntity *
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
PUBLIC	?BufferString@CSave@@AAEXPADH@Z			; CSave::BufferString
;	COMDAT ?BufferString@CSave@@AAEXPADH@Z
_TEXT	SEGMENT
_pdata$ = 8
_len$ = 12
_this$ = -4
_c$ = -8
?BufferString@CSave@@AAEXPADH@Z PROC NEAR		; CSave::BufferString, COMDAT

; 770  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 771  : 	char c = 0;

	mov	BYTE PTR _c$[ebp], 0

; 772  : 
; 773  : 	BufferData( pdata, len );		// Write the string

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdata$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 774  : 	BufferData( &c, 1 );			// Write a null terminator

	push	1
	lea	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 775  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BufferString@CSave@@AAEXPADH@Z ENDP			; CSave::BufferString
_TEXT	ENDS
;	COMDAT ?DataEmpty@CSave@@AAEHPBDH@Z
_TEXT	SEGMENT
_pdata$ = 8
_size$ = 12
_this$ = -4
_i$ = -8
?DataEmpty@CSave@@AAEHPBDH@Z PROC NEAR			; CSave::DataEmpty, COMDAT

; 778  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 779  : 	for ( int i = 0; i < size; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L36931
$L36932:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L36931:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _size$[ebp]
	jge	SHORT $L36933

; 781  : 		if ( pdata[i] )

	mov	edx, DWORD PTR _pdata$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L36934

; 782  : 			return 0;

	xor	eax, eax
	jmp	SHORT $L36929
$L36934:

; 783  : 	}

	jmp	SHORT $L36932
$L36933:

; 784  : 	return 1;

	mov	eax, 1
$L36929:

; 785  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?DataEmpty@CSave@@AAEHPBDH@Z ENDP			; CSave::DataEmpty
_TEXT	ENDS
;	COMDAT ?BufferField@CSave@@AAEXPBDH0@Z
_TEXT	SEGMENT
_pname$ = 8
_size$ = 12
_pdata$ = 16
_this$ = -4
?BufferField@CSave@@AAEXPBDH0@Z PROC NEAR		; CSave::BufferField, COMDAT

; 788  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 789  : 	BufferHeader( pname, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferHeader@CSave@@AAEXPBDH@Z		; CSave::BufferHeader

; 790  : 	BufferData( pdata, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 791  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?BufferField@CSave@@AAEXPBDH0@Z ENDP			; CSave::BufferField
_TEXT	ENDS
PUBLIC	??_C@_0DI@FDNF@CSave?5?3?3?5BufferHeader?$CI?$CJ?5size?5par@ ; `string'
;	COMDAT ??_C@_0DI@FDNF@CSave?5?3?3?5BufferHeader?$CI?$CJ?5size?5par@
; File z:\xashxtsrc\server\saverestore.cpp
CONST	SEGMENT
??_C@_0DI@FDNF@CSave?5?3?3?5BufferHeader?$CI?$CJ?5size?5par@ DB 'CSave ::'
	DB	' BufferHeader() size parameter exceeds ''short''!', 00H ; `string'
CONST	ENDS
;	COMDAT ?BufferHeader@CSave@@AAEXPBDH@Z
_TEXT	SEGMENT
_pname$ = 8
_size$ = 12
_this$ = -4
_hashvalue$ = -8
?BufferHeader@CSave@@AAEXPBDH@Z PROC NEAR		; CSave::BufferHeader, COMDAT

; 794  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 795  : 	short	hashvalue = TokenHash( pname );

	mov	eax, DWORD PTR _pname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z ; CSaveRestoreBuffer::TokenHash
	mov	WORD PTR _hashvalue$[ebp], ax

; 796  : 	if ( size > 1<<(sizeof(short)*8) )

	cmp	DWORD PTR _size$[ebp], 65536		; 00010000H
	jbe	SHORT $L36948

; 797  : 		ALERT( at_error, "CSave :: BufferHeader() size parameter exceeds 'short'!" );

	push	OFFSET FLAT:??_C@_0DI@FDNF@CSave?5?3?3?5BufferHeader?$CI?$CJ?5size?5par@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L36948:

; 798  : 	BufferData( (const char *)&size, sizeof(short) );

	push	2
	lea	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 799  : 	BufferData( (const char *)&hashvalue, sizeof(short) );

	push	2
	lea	edx, DWORD PTR _hashvalue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 800  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BufferHeader@CSave@@AAEXPBDH@Z ENDP			; CSave::BufferHeader
_TEXT	ENDS
PUBLIC	??_C@_0BH@HNMI@Save?1Restore?5overflow?$CB?$AA@	; `string'
EXTRN	_memcpy:NEAR
;	COMDAT ??_C@_0BH@HNMI@Save?1Restore?5overflow?$CB?$AA@
; File z:\xashxtsrc\server\saverestore.cpp
CONST	SEGMENT
??_C@_0BH@HNMI@Save?1Restore?5overflow?$CB?$AA@ DB 'Save/Restore overflow'
	DB	'!', 00H					; `string'
CONST	ENDS
;	COMDAT ?BufferData@CSave@@AAEXPBDH@Z
_TEXT	SEGMENT
_pdata$ = 8
_size$ = 12
_this$ = -4
?BufferData@CSave@@AAEXPBDH@Z PROC NEAR			; CSave::BufferData, COMDAT

; 803  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 804  : 	if ( !m_pdata )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $L36959

; 805  : 		return;

	jmp	SHORT $L36958
$L36959:

; 806  : 
; 807  : 	if ( m_pdata->size + size > m_pdata->bufferSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+12]
	jle	SHORT $L36960

; 809  : 		ALERT( at_error, "Save/Restore overflow!" );

	push	OFFSET FLAT:??_C@_0BH@HNMI@Save?1Restore?5overflow?$CB?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 810  : 		m_pdata->size = m_pdata->bufferSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], ecx

; 811  : 		return;

	jmp	SHORT $L36958
$L36960:

; 813  : 
; 814  : 	memcpy( m_pdata->pCurrentData, pdata, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 815  : 	m_pdata->pCurrentData += size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+4], eax

; 816  : 	m_pdata->size += size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+8], edx
$L36958:

; 817  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BufferData@CSave@@AAEXPBDH@Z ENDP			; CSave::BufferData
_TEXT	ENDS
PUBLIC	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z		; EHANDLE::operator=
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
PUBLIC	?FStringNull@@YAHH@Z				; FStringNull
PUBLIC	?ReadField@CRestore@@QAEHPBXPAUdatamap_s@@PAUtypedescription_s@@HHHPADPAX@Z ; CRestore::ReadField
PUBLIC	?ReadFunction@CRestore@@QAEHPAUdatamap_s@@PAPAXPBD@Z ; CRestore::ReadFunction
EXTRN	_stricmp:NEAR
;	COMDAT ?ReadField@CRestore@@QAEHPBXPAUdatamap_s@@PAUtypedescription_s@@HHHPADPAX@Z
_TEXT	SEGMENT
_pBaseData$ = 8
_pMap$ = 12
_pFields$ = 16
_fieldCount$ = 20
_startField$ = 24
_pName$ = 32
_pData$ = 36
_this$ = -4
_i$ = -8
_j$ = -12
_stringCount$ = -16
_fieldNumber$ = -20
_entityIndex$ = -24
_pTest$ = -28
_time$ = -32
_timeData$ = -36
_position$ = -48
_pent$ = -52
_pString$ = -56
_pOutputData$36996 = -60
_pInputData$36998 = -64
_string$37022 = -68
$T37768 = -80
?ReadField@CRestore@@QAEHPBXPAUdatamap_s@@PAUtypedescription_s@@HHHPADPAX@Z PROC NEAR ; CRestore::ReadField, COMDAT

; 827  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 828  : 	int i, j, stringCount, fieldNumber, entityIndex;
; 829  : 	TYPEDESCRIPTION *pTest;
; 830  : 	float	time, timeData;
; 831  : 	Vector	position;

	lea	ecx, DWORD PTR _position$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 832  : 	edict_t	*pent;
; 833  : 	char	*pString;
; 834  : 
; 835  : 	time = 0;

	mov	DWORD PTR _time$[ebp], 0

; 836  : 	position = Vector(0,0,0);

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR $T37768[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _position$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _position$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _position$[ebp+8], eax

; 837  : 
; 838  : 	if ( m_pdata )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $L36986

; 840  : 		time = m_pdata->time;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+1360]
	mov	DWORD PTR _time$[ebp], ecx

; 841  : 		if ( m_pdata->fUseLandmark )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	DWORD PTR [eax+1324], 0
	je	SHORT $L36986

; 842  : 			position = m_pdata->vecLandmarkOffset;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1348				; 00000544H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _position$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _position$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _position$[ebp+8], edx
$L36986:

; 844  : 
; 845  : 	for ( i = 0; i < fieldCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L36987
$L36988:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L36987:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _fieldCount$[ebp]
	jge	$L36989

; 847  : 		fieldNumber = (i+startField)%fieldCount;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _startField$[ebp]
	cdq
	idiv	DWORD PTR _fieldCount$[ebp]
	mov	DWORD PTR _fieldNumber$[ebp], edx

; 848  : 		pTest = &pFields[ fieldNumber ];

	mov	edx, DWORD PTR _fieldNumber$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pFields$[ebp]
	add	eax, edx
	mov	DWORD PTR _pTest$[ebp], eax

; 849  : 		if ( !stricmp( pTest->fieldName, pName ) )

	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$L36990

; 851  : 			if ( !m_global || !(pTest->flags & FTYPEDESC_GLOBAL) )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $L36992
	mov	edx, DWORD PTR _pTest$[ebp]
	movsx	eax, WORD PTR [edx+14]
	and	eax, 1
	test	eax, eax
	jne	$L36995
$L36992:

; 853  : 				for ( j = 0; j < pTest->fieldSize; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L36993
$L36994:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L36993:
	mov	edx, DWORD PTR _pTest$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+12]
	cmp	DWORD PTR _j$[ebp], eax
	jge	$L36995

; 855  : 					void *pOutputData = ((char *)pBaseData + pTest->fieldOffset + (j*gSizes[pTest->fieldType]) );

	mov	ecx, DWORD PTR _pTest$[ebp]
	mov	edx, DWORD PTR _pBaseData$[ebp]
	add	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _gSizes[ecx*4]
	add	edx, eax
	mov	DWORD PTR _pOutputData$36996[ebp], edx

; 856  : 					void *pInputData = (char *)pData + j * gSizes[pTest->fieldType];

	mov	ecx, DWORD PTR _pTest$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _gSizes[edx*4]
	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, eax
	mov	DWORD PTR _pInputData$36998[ebp], ecx

; 859  : 					{

	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR -84+[ebp], eax
	cmp	DWORD PTR -84+[ebp], 17			; 00000011H
	ja	$L37089
	mov	ecx, DWORD PTR -84+[ebp]
	jmp	DWORD PTR $L37769[ecx*4]
$L37004:

; 860  : 					case FIELD_TIME:
; 861  : 						timeData = *(float *)pInputData;

	mov	edx, DWORD PTR _pInputData$36998[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _timeData$[ebp], eax

; 862  : 						// Re-base time variables
; 863  : 						timeData += time;

	fld	DWORD PTR _timeData$[ebp]
	fadd	DWORD PTR _time$[ebp]
	fstp	DWORD PTR _timeData$[ebp]

; 864  : 						*((float *)pOutputData) = timeData;

	mov	ecx, DWORD PTR _pOutputData$36996[ebp]
	mov	edx, DWORD PTR _timeData$[ebp]
	mov	DWORD PTR [ecx], edx

; 865  : 						break;

	jmp	$L37001
$L37007:

; 866  : 					case FIELD_FLOAT:
; 867  : 						*((float *)pOutputData) = *(float *)pInputData;

	mov	eax, DWORD PTR _pOutputData$36996[ebp]
	mov	ecx, DWORD PTR _pInputData$36998[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 868  : 						break;

	jmp	$L37001
$L37010:

; 869  : 					case FIELD_MODELNAME:
; 870  : 					case FIELD_SOUNDNAME:
; 871  : 					case FIELD_STRING:
; 872  : 						// Skip over j strings
; 873  : 						pString = (char *)pData;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _pString$[ebp], eax

; 874  : 						for ( stringCount = 0; stringCount < j; stringCount++ )

	mov	DWORD PTR _stringCount$[ebp], 0
	jmp	SHORT $L37012
$L37013:
	mov	ecx, DWORD PTR _stringCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _stringCount$[ebp], ecx
$L37012:
	mov	edx, DWORD PTR _stringCount$[ebp]
	cmp	edx, DWORD PTR _j$[ebp]
	jge	SHORT $L37014
$L37016:

; 876  : 							while (*pString)

	mov	eax, DWORD PTR _pString$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L37017

; 877  : 								pString++;

	mov	edx, DWORD PTR _pString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pString$[ebp], edx
	jmp	SHORT $L37016
$L37017:

; 878  : 							pString++;

	mov	eax, DWORD PTR _pString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pString$[ebp], eax

; 879  : 						}

	jmp	SHORT $L37013
$L37014:

; 880  : 						pInputData = pString;

	mov	ecx, DWORD PTR _pString$[ebp]
	mov	DWORD PTR _pInputData$36998[ebp], ecx

; 881  : 						if ( strlen( (char *)pInputData ) == 0 )

	mov	edx, DWORD PTR _pInputData$36998[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $L37019

; 882  : 							*((int *)pOutputData) = 0;

	mov	eax, DWORD PTR _pOutputData$36996[ebp]
	mov	DWORD PTR [eax], 0

; 883  : 						else

	jmp	SHORT $L37029
$L37019:

; 885  : 							int string;
; 886  : 
; 887  : 							string = ALLOC_STRING( (char *)pInputData );

	mov	ecx, DWORD PTR _pInputData$36998[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	DWORD PTR _string$37022[ebp], eax

; 888  : 							
; 889  : 							*((int *)pOutputData) = string;

	mov	edx, DWORD PTR _pOutputData$36996[ebp]
	mov	eax, DWORD PTR _string$37022[ebp]
	mov	DWORD PTR [edx], eax

; 890  : 
; 891  : 							if ( !FStringNull( string ) && m_precache )

	mov	ecx, DWORD PTR _string$37022[ebp]
	push	ecx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L37029
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $L37029

; 893  : 								if ( pTest->fieldType == FIELD_MODELNAME )

	mov	eax, DWORD PTR _pTest$[ebp]
	cmp	DWORD PTR [eax], 16			; 00000010H
	jne	SHORT $L37026

; 894  : 									PRECACHE_MODEL( (char *)STRING( string ) );

	mov	ecx, DWORD PTR _string$37022[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4

; 895  : 								else if ( pTest->fieldType == FIELD_SOUNDNAME )

	jmp	SHORT $L37029
$L37026:
	mov	edx, DWORD PTR _pTest$[ebp]
	cmp	DWORD PTR [edx], 17			; 00000011H
	jne	SHORT $L37029

; 896  : 									PRECACHE_SOUND( (char *)STRING( string ) );

	mov	eax, DWORD PTR _string$37022[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4
$L37029:

; 899  : 						break;

	jmp	$L37001
$L37031:

; 900  : 					case FIELD_EVARS:
; 901  : 						entityIndex = *( int *)pInputData;

	mov	ecx, DWORD PTR _pInputData$36998[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _entityIndex$[ebp], edx

; 902  : 						pent = EntityFromIndex( entityIndex );

	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ; CSaveRestoreBuffer::EntityFromIndex
	mov	DWORD PTR _pent$[ebp], eax

; 903  : 						if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L37033

; 904  : 							*((entvars_t **)pOutputData) = VARS(pent);

	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	edx, DWORD PTR _pOutputData$36996[ebp]
	mov	DWORD PTR [edx], eax

; 905  : 						else

	jmp	SHORT $L37035
$L37033:

; 906  : 							*((entvars_t **)pOutputData) = NULL;

	mov	eax, DWORD PTR _pOutputData$36996[ebp]
	mov	DWORD PTR [eax], 0
$L37035:

; 907  : 						break;

	jmp	$L37001
$L37037:

; 908  : 					case FIELD_CLASSPTR:
; 909  : 						entityIndex = *( int *)pInputData;

	mov	ecx, DWORD PTR _pInputData$36998[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _entityIndex$[ebp], edx

; 910  : 						pent = EntityFromIndex( entityIndex );

	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ; CSaveRestoreBuffer::EntityFromIndex
	mov	DWORD PTR _pent$[ebp], eax

; 911  : 						if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L37039

; 912  : 							*((CBaseEntity **)pOutputData) = CBaseEntity::Instance(pent);

	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	edx, DWORD PTR _pOutputData$36996[ebp]
	mov	DWORD PTR [edx], eax

; 913  : 						else

	jmp	SHORT $L37041
$L37039:

; 914  : 							*((CBaseEntity **)pOutputData) = NULL;

	mov	eax, DWORD PTR _pOutputData$36996[ebp]
	mov	DWORD PTR [eax], 0
$L37041:

; 915  : 						break;

	jmp	$L37001
$L37043:

; 916  : 					case FIELD_EDICT:
; 917  : 						entityIndex = *( int *)pInputData;

	mov	ecx, DWORD PTR _pInputData$36998[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _entityIndex$[ebp], edx

; 918  : 						pent = EntityFromIndex( entityIndex );

	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ; CSaveRestoreBuffer::EntityFromIndex
	mov	DWORD PTR _pent$[ebp], eax

; 919  : 						*((edict_t **)pOutputData) = pent;

	mov	ecx, DWORD PTR _pOutputData$36996[ebp]
	mov	edx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [ecx], edx

; 920  : 						break;

	jmp	$L37001
$L37046:

; 921  : 					case FIELD_EHANDLE:
; 922  : 						// Input and Output sizes are different!
; 923  : 						pOutputData = (char *)pOutputData + j*(sizeof(EHANDLE) - gSizes[pTest->fieldType]);

	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, 8
	sub	edx, DWORD PTR _gSizes[ecx*4]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, edx
	mov	ecx, DWORD PTR _pOutputData$36996[ebp]
	add	ecx, eax
	mov	DWORD PTR _pOutputData$36996[ebp], ecx

; 924  : 						entityIndex = *( int *)pInputData;

	mov	edx, DWORD PTR _pInputData$36998[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _entityIndex$[ebp], eax

; 925  : 						pent = EntityFromIndex( entityIndex );

	mov	ecx, DWORD PTR _entityIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ; CSaveRestoreBuffer::EntityFromIndex
	mov	DWORD PTR _pent$[ebp], eax

; 926  : 						if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L37050

; 927  : 							*((EHANDLE *)pOutputData) = CBaseEntity::Instance(pent);

	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pOutputData$36996[ebp]
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 928  : 						else

	jmp	SHORT $L37052
$L37050:

; 929  : 							*((EHANDLE *)pOutputData) = NULL;

	push	0
	mov	ecx, DWORD PTR _pOutputData$36996[ebp]
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=
$L37052:

; 930  : 						break;

	jmp	$L37001
$L37054:

; 931  : 					case FIELD_ENTITY:
; 932  : 						entityIndex = *( int *)pInputData;

	mov	eax, DWORD PTR _pInputData$36998[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _entityIndex$[ebp], ecx

; 933  : 						pent = EntityFromIndex( entityIndex );

	mov	edx, DWORD PTR _entityIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ; CSaveRestoreBuffer::EntityFromIndex
	mov	DWORD PTR _pent$[ebp], eax

; 934  : 						if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L37056

; 935  : 							*((EOFFSET *)pOutputData) = OFFSET(pent);

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4
	mov	ecx, DWORD PTR _pOutputData$36996[ebp]
	mov	DWORD PTR [ecx], eax

; 936  : 						else

	jmp	SHORT $L37058
$L37056:

; 937  : 							*((EOFFSET *)pOutputData) = 0;

	mov	edx, DWORD PTR _pOutputData$36996[ebp]
	mov	DWORD PTR [edx], 0
$L37058:

; 938  : 						break;

	jmp	$L37001
$L37060:

; 939  : 					case FIELD_VECTOR:
; 940  : 						((float *)pOutputData)[0] = ((float *)pInputData)[0];

	mov	eax, DWORD PTR _pOutputData$36996[ebp]
	mov	ecx, DWORD PTR _pInputData$36998[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 941  : 						((float *)pOutputData)[1] = ((float *)pInputData)[1];

	mov	eax, DWORD PTR _pOutputData$36996[ebp]
	mov	ecx, DWORD PTR _pInputData$36998[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 942  : 						((float *)pOutputData)[2] = ((float *)pInputData)[2];

	mov	eax, DWORD PTR _pOutputData$36996[ebp]
	mov	ecx, DWORD PTR _pInputData$36998[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 943  : 						break;

	jmp	$L37001
$L37067:

; 944  : 					case FIELD_POSITION_VECTOR:
; 945  : 						((float *)pOutputData)[0] = ((float *)pInputData)[0] + position.x;

	mov	eax, DWORD PTR _pInputData$36998[ebp]
	fld	DWORD PTR _position$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOutputData$36996[ebp]
	fstp	DWORD PTR [ecx]

; 946  : 						((float *)pOutputData)[1] = ((float *)pInputData)[1] + position.y;

	mov	edx, DWORD PTR _pInputData$36998[ebp]
	fld	DWORD PTR _position$[ebp+4]
	fadd	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _pOutputData$36996[ebp]
	fstp	DWORD PTR [eax+4]

; 947  : 						((float *)pOutputData)[2] = ((float *)pInputData)[2] + position.z;

	mov	ecx, DWORD PTR _pInputData$36998[ebp]
	fld	DWORD PTR _position$[ebp+8]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _pOutputData$36996[ebp]
	fstp	DWORD PTR [edx+8]

; 948  : 						break;

	jmp	SHORT $L37001
$L37074:

; 949  : 					case FIELD_BOOLEAN:
; 950  : 					case FIELD_INTEGER:
; 951  : 						*((int *)pOutputData) = *( int *)pInputData;

	mov	eax, DWORD PTR _pOutputData$36996[ebp]
	mov	ecx, DWORD PTR _pInputData$36998[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 952  : 						break;

	jmp	SHORT $L37001
$L37077:

; 953  : 					case FIELD_SHORT:
; 954  : 						*((short *)pOutputData) = *( short *)pInputData;

	mov	eax, DWORD PTR _pOutputData$36996[ebp]
	mov	ecx, DWORD PTR _pInputData$36998[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx

; 955  : 						break;

	jmp	SHORT $L37001
$L37080:

; 956  : 					case FIELD_CHARACTER:
; 957  : 						*((char *)pOutputData) = *( char *)pInputData;

	mov	eax, DWORD PTR _pOutputData$36996[ebp]
	mov	ecx, DWORD PTR _pInputData$36998[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 958  : 						break;

	jmp	SHORT $L37001
$L37083:

; 959  : 					case FIELD_POINTER:
; 960  : 						*((int *)pOutputData) = *( int *)pInputData;

	mov	eax, DWORD PTR _pOutputData$36996[ebp]
	mov	ecx, DWORD PTR _pInputData$36998[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 961  : 						break;

	jmp	SHORT $L37001
$L37086:

; 962  : 					case FIELD_FUNCTION:
; 963  : 						ReadFunction( pMap, (void **)pOutputData, (const char *)pInputData );

	mov	eax, DWORD PTR _pInputData$36998[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOutputData$36996[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMap$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadFunction@CRestore@@QAEHPAUdatamap_s@@PAPAXPBD@Z ; CRestore::ReadFunction

; 964  : 						break;

	jmp	SHORT $L37001
$L37089:

; 965  : 					default:
; 966  : 						ALERT( at_error, "Bad field type\n" );

	push	OFFSET FLAT:??_C@_0BA@JAEO@Bad?5field?5type?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L37001:

; 968  : 				}

	jmp	$L36994
$L36995:

; 970  : 			return fieldNumber;

	mov	eax, DWORD PTR _fieldNumber$[ebp]
	jmp	SHORT $L36972
$L36990:

; 972  : 	}

	jmp	$L36988
$L36989:

; 973  : 
; 974  : 	return -1;

	or	eax, -1
$L36972:

; 975  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$L37769:
	DD	$L37007
	DD	$L37010
	DD	$L37054
	DD	$L37037
	DD	$L37046
	DD	$L37031
	DD	$L37043
	DD	$L37060
	DD	$L37067
	DD	$L37083
	DD	$L37074
	DD	$L37086
	DD	$L37074
	DD	$L37077
	DD	$L37080
	DD	$L37004
	DD	$L37010
	DD	$L37010
?ReadField@CRestore@@QAEHPBXPAUdatamap_s@@PAUtypedescription_s@@HHHPADPAX@Z ENDP ; CRestore::ReadField
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC NEAR		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32448

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L32447
$L32448:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$L32447:

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT
_iString$ = 8
?FStringNull@@YAHH@Z PROC NEAR				; FStringNull, COMDAT

; 201  : inline BOOL FStringNull(int iString)			{ return iString == iStringNull; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _iString$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStringNull@@YAHH@Z ENDP				; FStringNull
_TEXT	ENDS
EXTRN	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z:NEAR	; ENT
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z PROC NEAR	; EHANDLE::operator=, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 	if (pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L34280

; 72   : 		m_pent = ENT( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 73   : 		if (m_pent)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L34281

; 74   : 			m_serialnumber = m_pent->serialnumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$L34281:

; 76   : 	else

	jmp	SHORT $L34282
$L34280:

; 78   : 		m_pent = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 79   : 		m_serialnumber = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$L34282:

; 81   : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z ENDP		; EHANDLE::operator=
_TEXT	ENDS
PUBLIC	?ReadEntVars@CRestore@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z ; CRestore::ReadEntVars
PUBLIC	?ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ; CRestore::ReadFields
;	COMDAT ?ReadEntVars@CRestore@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z
_TEXT	SEGMENT
_pname$ = 8
_pMap$ = 12
_pev$ = 16
_this$ = -4
?ReadEntVars@CRestore@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z PROC NEAR ; CRestore::ReadEntVars, COMDAT

; 978  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 979  : 	return ReadFields( pname, pev, pMap, gEntvarsDescription, ENTVARS_COUNT );

	push	97					; 00000061H
	push	OFFSET FLAT:?gEntvarsDescription@@3PAUtypedescription_s@@A ; gEntvarsDescription
	mov	eax, DWORD PTR _pMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ; CRestore::ReadFields

; 980  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ReadEntVars@CRestore@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z ENDP ; CRestore::ReadEntVars
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z@4FA ; `CRestore::ReadFields'::`2'::__LINE__Var
PUBLIC	??_C@_0CE@KJIP@z?3?2xashxtsrc?2server?2saverestore?4@ ; `string'
PUBLIC	??_C@_0BB@FCIE@i?5?$DN?$DN?5sizeof?$CIint?$CJ?$AA@ ; `string'
PUBLIC	?ReadInt@CRestore@@QAEHXZ			; CRestore::ReadInt
PUBLIC	?ReadShort@CRestore@@QAEFXZ			; CRestore::ReadShort
PUBLIC	?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z	; CRestore::BufferReadHeader
EXTRN	?DBG_AssertFunction@@YAXHPBD0H0@Z:NEAR		; DBG_AssertFunction
EXTRN	_memset:NEAR
;	COMDAT ?__LINE__Var@?1??ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z@4FA
; File z:\xashxtsrc\server\saverestore.cpp
_DATA	SEGMENT
?__LINE__Var@?1??ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z@4FA DW 03d7H ; `CRestore::ReadFields'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CE@KJIP@z?3?2xashxtsrc?2server?2saverestore?4@
CONST	SEGMENT
??_C@_0CE@KJIP@z?3?2xashxtsrc?2server?2saverestore?4@ DB 'z:\xashxtsrc\se'
	DB	'rver\saverestore.cpp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCIE@i?5?$DN?$DN?5sizeof?$CIint?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@FCIE@i?5?$DN?$DN?5sizeof?$CIint?$CJ?$AA@ DB 'i == sizeof(int)', 00H ; `string'
CONST	ENDS
;	COMDAT ?ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z
_TEXT	SEGMENT
_pname$ = 8
_pBaseData$ = 12
_pMap$ = 16
_pFields$ = 20
_fieldCount$ = 24
_this$ = -4
_i$ = -8
_token$ = -12
_lastField$ = -16
_fileCount$ = -20
_header$ = -28
?ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z PROC NEAR ; CRestore::ReadFields, COMDAT

; 983  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 984  : 	unsigned short	i, token;
; 985  : 	int		lastField, fileCount;
; 986  : 	HEADER	header;
; 987  : 
; 988  : 	i = ReadShort();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadShort@CRestore@@QAEFXZ		; CRestore::ReadShort
	mov	WORD PTR _i$[ebp], ax

; 989  : 	ASSERT( i == sizeof(int) );			// First entry should be an int

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z@4FA ; `CRestore::ReadFields'::`2'::__LINE__Var
	add	eax, 6
	push	eax
	push	OFFSET FLAT:??_C@_0CE@KJIP@z?3?2xashxtsrc?2server?2saverestore?4@ ; `string'
	push	OFFSET FLAT:??_C@_0BB@FCIE@i?5?$DN?$DN?5sizeof?$CIint?$CJ?$AA@ ; `string'
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	xor	edx, edx
	cmp	ecx, 4
	sete	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 990  : 
; 991  : 	token = ReadShort();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadShort@CRestore@@QAEFXZ		; CRestore::ReadShort
	mov	WORD PTR _token$[ebp], ax

; 992  : 
; 993  : 	// Check the struct name
; 994  : 	if ( token != TokenHash(pname) )			// Field Set marker

	mov	esi, DWORD PTR _token$[ebp]
	and	esi, 65535				; 0000ffffH
	mov	eax, DWORD PTR _pname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z ; CSaveRestoreBuffer::TokenHash
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L37113

; 996  : //		ALERT( at_error, "Expected %s found %s!\n", pname, BufferPointer() );
; 997  : 		BufferRewind( 2*sizeof(short) );

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferRewind@CSaveRestoreBuffer@@IAEXH@Z ; CSaveRestoreBuffer::BufferRewind

; 998  : 		return 0;

	xor	eax, eax
	jmp	$L37103
$L37113:

; 1000 : 
; 1001 : 	// Skip over the struct name
; 1002 : 	fileCount = ReadInt();						// Read field count

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadInt@CRestore@@QAEHXZ		; CRestore::ReadInt
	mov	DWORD PTR _fileCount$[ebp], eax

; 1003 : 
; 1004 : 	lastField = 0;								// Make searches faster, most data is read/written in the same order

	mov	DWORD PTR _lastField$[ebp], 0

; 1005 : 
; 1006 : 	// Clear out base data
; 1007 : 	for ( i = 0; i < fieldCount; i++ )

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L37115
$L37116:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$L37115:
	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 65535				; 0000ffffH
	cmp	edx, DWORD PTR _fieldCount$[ebp]
	jge	SHORT $L37117

; 1009 : 		// Don't clear global fields
; 1010 : 		if ( !m_global || !(pFields[i].flags & FTYPEDESC_GLOBAL) )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $L37119
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pFields$[ebp]
	movsx	eax, WORD PTR [edx+ecx+14]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L37118
$L37119:

; 1011 : 			memset( ((char *)pBaseData + pFields[i].fieldOffset), 0, pFields[i].fieldSize * gSizes[pFields[i].fieldType] );

	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pFields$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+ecx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pFields$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	imul	eax, DWORD PTR _gSizes[ecx*4]
	push	eax
	push	0
	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 65535				; 0000ffffH
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pFields$[ebp]
	mov	ecx, DWORD PTR _pBaseData$[ebp]
	add	ecx, DWORD PTR [eax+edx+8]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$L37118:

; 1012 : 	}

	jmp	$L37116
$L37117:

; 1013 : 
; 1014 : 	for ( i = 0; i < fileCount; i++ )

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L37121
$L37122:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$L37121:
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	cmp	eax, DWORD PTR _fileCount$[ebp]
	jge	SHORT $L37123

; 1016 : 		BufferReadHeader( &header );

	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z ; CRestore::BufferReadHeader

; 1017 : 		lastField = ReadField( pBaseData, pMap, pFields, fieldCount, lastField, header.size, m_pdata->pTokens[header.token], header.pData );

	mov	edx, DWORD PTR _header$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _header$[ebp+2]
	and	edx, 65535				; 0000ffffH
	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _header$[ebp]
	and	edx, 65535				; 0000ffffH
	push	edx
	mov	eax, DWORD PTR _lastField$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fieldCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFields$[ebp]
	push	edx
	mov	eax, DWORD PTR _pMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBaseData$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadField@CRestore@@QAEHPBXPAUdatamap_s@@PAUtypedescription_s@@HHHPADPAX@Z ; CRestore::ReadField
	mov	DWORD PTR _lastField$[ebp], eax

; 1018 : 		lastField++;

	mov	edx, DWORD PTR _lastField$[ebp]
	add	edx, 1
	mov	DWORD PTR _lastField$[ebp], edx

; 1019 : 	}

	jmp	SHORT $L37122
$L37123:

; 1020 : 	
; 1021 : 	return 1;

	mov	eax, 1
$L37103:

; 1022 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ENDP ; CRestore::ReadFields
_TEXT	ENDS
PUBLIC	?DoReadAll@CRestore@@QAEHPAXPAUdatamap_s@@1@Z	; CRestore::DoReadAll
;	COMDAT ?DoReadAll@CRestore@@QAEHPAXPAUdatamap_s@@1@Z
_TEXT	SEGMENT
_pLeafObject$ = 8
_pLeafMap$ = 12
_pCurMap$ = 16
_this$ = -4
_status$37131 = -8
?DoReadAll@CRestore@@QAEHPAXPAUdatamap_s@@1@Z PROC NEAR	; CRestore::DoReadAll, COMDAT

; 1029 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1030 : 	// restore base classes first
; 1031 : 	if ( pCurMap->baseMap )

	mov	eax, DWORD PTR _pCurMap$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L37132

; 1033 : 		int status = DoReadAll( pLeafObject, pLeafMap, pCurMap->baseMap );

	mov	ecx, DWORD PTR _pCurMap$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pLeafMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLeafObject$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoReadAll@CRestore@@QAEHPAXPAUdatamap_s@@1@Z ; CRestore::DoReadAll
	mov	DWORD PTR _status$37131[ebp], eax

; 1034 : 		if ( !status )

	cmp	DWORD PTR _status$37131[ebp], 0
	jne	SHORT $L37132

; 1035 : 			return status;

	mov	eax, DWORD PTR _status$37131[ebp]
	jmp	SHORT $L37129
$L37132:

; 1037 : 
; 1038 : 	return ReadFields( pCurMap->dataClassName, pLeafObject, pLeafMap, pCurMap->dataDesc, pCurMap->dataNumFields );

	mov	edx, DWORD PTR _pCurMap$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pCurMap$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pLeafMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLeafObject$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCurMap$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ; CRestore::ReadFields
$L37129:

; 1039 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DoReadAll@CRestore@@QAEHPAXPAUdatamap_s@@1@Z ENDP	; CRestore::DoReadAll
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z@4FA ; `CRestore::BufferReadHeader'::`2'::__LINE__Var
PUBLIC	??_C@_0O@INLF@pheader?$CB?$DNNULL?$AA@		; `string'
PUBLIC	?BufferPointer@CRestore@@AAEPADXZ		; CRestore::BufferPointer
PUBLIC	?BufferSkipBytes@CRestore@@AAEXH@Z		; CRestore::BufferSkipBytes
;	COMDAT ?__LINE__Var@?1??BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z@4FA
; File z:\xashxtsrc\server\saverestore.cpp
_DATA	SEGMENT
?__LINE__Var@?1??BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z@4FA DW 0412H ; `CRestore::BufferReadHeader'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0O@INLF@pheader?$CB?$DNNULL?$AA@
CONST	SEGMENT
??_C@_0O@INLF@pheader?$CB?$DNNULL?$AA@ DB 'pheader!=NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z
_TEXT	SEGMENT
_pheader$ = 8
_this$ = -4
?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z PROC NEAR	; CRestore::BufferReadHeader, COMDAT

; 1042 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1043 : 	ASSERT( pheader!=NULL );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z@4FA ; `CRestore::BufferReadHeader'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CE@KJIP@z?3?2xashxtsrc?2server?2saverestore?4@ ; `string'
	push	OFFSET FLAT:??_C@_0O@INLF@pheader?$CB?$DNNULL?$AA@ ; `string'
	xor	ecx, ecx
	cmp	DWORD PTR _pheader$[ebp], 0
	setne	cl
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1044 : 	pheader->size = ReadShort();				// Read field size

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadShort@CRestore@@QAEFXZ		; CRestore::ReadShort
	mov	edx, DWORD PTR _pheader$[ebp]
	mov	WORD PTR [edx], ax

; 1045 : 	pheader->token = ReadShort();				// Read field name token

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadShort@CRestore@@QAEFXZ		; CRestore::ReadShort
	mov	ecx, DWORD PTR _pheader$[ebp]
	mov	WORD PTR [ecx+2], ax

; 1046 : 	pheader->pData = BufferPointer();			// Field Data is next

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferPointer@CRestore@@AAEPADXZ	; CRestore::BufferPointer
	mov	edx, DWORD PTR _pheader$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1047 : 	BufferSkipBytes( pheader->size );			// Advance to next field

	mov	eax, DWORD PTR _pheader$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferSkipBytes@CRestore@@AAEXH@Z	; CRestore::BufferSkipBytes

; 1048 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z ENDP	; CRestore::BufferReadHeader
_TEXT	ENDS
PUBLIC	?BufferReadBytes@CRestore@@AAEXPADH@Z		; CRestore::BufferReadBytes
;	COMDAT ?ReadShort@CRestore@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4
_tmp$ = -8
?ReadShort@CRestore@@QAEFXZ PROC NEAR			; CRestore::ReadShort, COMDAT

; 1051 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1052 : 	short tmp = 0;

	mov	WORD PTR _tmp$[ebp], 0

; 1053 : 
; 1054 : 	BufferReadBytes( (char *)&tmp, sizeof(short) );

	push	2
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferReadBytes@CRestore@@AAEXPADH@Z	; CRestore::BufferReadBytes

; 1055 : 
; 1056 : 	return tmp;

	mov	ax, WORD PTR _tmp$[ebp]

; 1057 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadShort@CRestore@@QAEFXZ ENDP			; CRestore::ReadShort
_TEXT	ENDS
;	COMDAT ?ReadInt@CRestore@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_tmp$ = -8
?ReadInt@CRestore@@QAEHXZ PROC NEAR			; CRestore::ReadInt, COMDAT

; 1060 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1061 : 	int tmp = 0;

	mov	DWORD PTR _tmp$[ebp], 0

; 1062 : 
; 1063 : 	BufferReadBytes( (char *)&tmp, sizeof(int) );

	push	4
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferReadBytes@CRestore@@AAEXPADH@Z	; CRestore::BufferReadBytes

; 1064 : 
; 1065 : 	return tmp;

	mov	eax, DWORD PTR _tmp$[ebp]

; 1066 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadInt@CRestore@@QAEHXZ ENDP				; CRestore::ReadInt
_TEXT	ENDS
PUBLIC	?ReadNamedInt@CRestore@@QAEHPBD@Z		; CRestore::ReadNamedInt
;	COMDAT ?ReadNamedInt@CRestore@@QAEHPBD@Z
_TEXT	SEGMENT
_this$ = -4
_header$ = -12
?ReadNamedInt@CRestore@@QAEHPBD@Z PROC NEAR		; CRestore::ReadNamedInt, COMDAT

; 1069 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1070 : 	HEADER header;
; 1071 : 
; 1072 : 	BufferReadHeader( &header );

	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z ; CRestore::BufferReadHeader

; 1073 : 	return ((int *)header.pData)[0];

	mov	ecx, DWORD PTR _header$[ebp+4]
	mov	eax, DWORD PTR [ecx]

; 1074 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ReadNamedInt@CRestore@@QAEHPBD@Z ENDP			; CRestore::ReadNamedInt
_TEXT	ENDS
PUBLIC	?ReadNamedString@CRestore@@QAEPADPBD@Z		; CRestore::ReadNamedString
;	COMDAT ?ReadNamedString@CRestore@@QAEPADPBD@Z
_TEXT	SEGMENT
_this$ = -4
_header$ = -12
?ReadNamedString@CRestore@@QAEPADPBD@Z PROC NEAR	; CRestore::ReadNamedString, COMDAT

; 1077 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1078 : 	HEADER header;
; 1079 : 
; 1080 : 	BufferReadHeader( &header );

	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z ; CRestore::BufferReadHeader

; 1081 : #ifdef TOKENIZE
; 1082 : 	return (char *)(m_pdata->pTokens[*(short *)header.pData]);
; 1083 : #else
; 1084 : 	return (char *)header.pData;

	mov	eax, DWORD PTR _header$[ebp+4]

; 1085 : #endif
; 1086 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ReadNamedString@CRestore@@QAEPADPBD@Z ENDP		; CRestore::ReadNamedString
_TEXT	ENDS
;	COMDAT ?BufferPointer@CRestore@@AAEPADXZ
_TEXT	SEGMENT
_this$ = -4
?BufferPointer@CRestore@@AAEPADXZ PROC NEAR		; CRestore::BufferPointer, COMDAT

; 1089 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1090 : 	if ( !m_pdata )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $L37169

; 1091 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L37168
$L37169:

; 1092 : 
; 1093 : 	return m_pdata->pCurrentData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+4]
$L37168:

; 1094 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BufferPointer@CRestore@@AAEPADXZ ENDP			; CRestore::BufferPointer
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??BufferReadBytes@CRestore@@AAEXPADH@Z@4FA ; `CRestore::BufferReadBytes'::`2'::__LINE__Var
PUBLIC	??_C@_0P@OONN@m_pdata?5?$CB?$DNNULL?$AA@	; `string'
PUBLIC	??_C@_0BC@JJGF@Restore?5overflow?$CB?$AA@	; `string'
PUBLIC	?Empty@CRestore@@QAEHXZ				; CRestore::Empty
;	COMDAT ?__LINE__Var@?1??BufferReadBytes@CRestore@@AAEXPADH@Z@4FA
; File z:\xashxtsrc\server\saverestore.cpp
_DATA	SEGMENT
?__LINE__Var@?1??BufferReadBytes@CRestore@@AAEXPADH@Z@4FA DW 0449H ; `CRestore::BufferReadBytes'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0P@OONN@m_pdata?5?$CB?$DNNULL?$AA@
CONST	SEGMENT
??_C@_0P@OONN@m_pdata?5?$CB?$DNNULL?$AA@ DB 'm_pdata !=NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JJGF@Restore?5overflow?$CB?$AA@
CONST	SEGMENT
??_C@_0BC@JJGF@Restore?5overflow?$CB?$AA@ DB 'Restore overflow!', 00H ; `string'
CONST	ENDS
;	COMDAT ?BufferReadBytes@CRestore@@AAEXPADH@Z
_TEXT	SEGMENT
_pOutput$ = 8
_size$ = 12
_this$ = -4
?BufferReadBytes@CRestore@@AAEXPADH@Z PROC NEAR		; CRestore::BufferReadBytes, COMDAT

; 1097 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1098 : 	ASSERT( m_pdata !=NULL );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??BufferReadBytes@CRestore@@AAEXPADH@Z@4FA ; `CRestore::BufferReadBytes'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0CE@KJIP@z?3?2xashxtsrc?2server?2saverestore?4@ ; `string'
	push	OFFSET FLAT:??_C@_0P@OONN@m_pdata?5?$CB?$DNNULL?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+24], 0
	setne	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1099 : 
; 1100 : 	if ( !m_pdata || Empty() )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $L37178
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Empty@CRestore@@QAEHXZ			; CRestore::Empty
	test	eax, eax
	je	SHORT $L37177
$L37178:

; 1101 : 		return;

	jmp	$L37174
$L37177:

; 1102 : 
; 1103 : 	if ( (m_pdata->size + size) > m_pdata->bufferSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+12]
	jle	SHORT $L37179

; 1105 : 		ALERT( at_error, "Restore overflow!" );

	push	OFFSET FLAT:??_C@_0BC@JJGF@Restore?5overflow?$CB?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1106 : 		m_pdata->size = m_pdata->bufferSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], ecx

; 1107 : 		return;

	jmp	SHORT $L37174
$L37179:

; 1109 : 
; 1110 : 	if ( pOutput )

	cmp	DWORD PTR _pOutput$[ebp], 0
	je	SHORT $L37181

; 1111 : 		memcpy( pOutput, m_pdata->pCurrentData, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pOutput$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$L37181:

; 1112 : 	m_pdata->pCurrentData += size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+4], eax

; 1113 : 	m_pdata->size += size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+8], edx
$L37174:

; 1114 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BufferReadBytes@CRestore@@AAEXPADH@Z ENDP		; CRestore::BufferReadBytes
_TEXT	ENDS
;	COMDAT ?Empty@CRestore@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Empty@CRestore@@QAEHXZ PROC NEAR			; CRestore::Empty, COMDAT

; 102  : 	int	Empty( void ) { return (m_pdata == NULL) || ((m_pdata->pCurrentData-m_pdata->pBaseData)>=m_pdata->bufferSize); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $L37800
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [edx+4]
	sub	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	edx, DWORD PTR [ecx+12]
	jge	SHORT $L37800
	mov	DWORD PTR -8+[ebp], 0
	jmp	SHORT $L37801
$L37800:
	mov	DWORD PTR -8+[ebp], 1
$L37801:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Empty@CRestore@@QAEHXZ ENDP				; CRestore::Empty
_TEXT	ENDS
EXTRN	?UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z:NEAR ; UTIL_FunctionFromName
;	COMDAT ?ReadFunction@CRestore@@QAEHPAUdatamap_s@@PAPAXPBD@Z
_TEXT	SEGMENT
_pMap$ = 8
_pValue$ = 12
_pszFunctionName$ = 16
_this$ = -4
?ReadFunction@CRestore@@QAEHPAUdatamap_s@@PAPAXPBD@Z PROC NEAR ; CRestore::ReadFunction, COMDAT

; 1117 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1118 : 	if ( strlen( (char *)pszFunctionName ) == 0 )

	mov	eax, DWORD PTR _pszFunctionName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $L37189

; 1119 : 		*pValue = NULL;

	mov	ecx, DWORD PTR _pValue$[ebp]
	mov	DWORD PTR [ecx], 0

; 1120 : 	else

	jmp	SHORT $L37190
$L37189:

; 1121 : 		*pValue = UTIL_FunctionFromName( pMap, pszFunctionName );

	mov	edx, DWORD PTR _pszFunctionName$[ebp]
	push	edx
	mov	eax, DWORD PTR _pMap$[ebp]
	push	eax
	call	?UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z ; UTIL_FunctionFromName
	add	esp, 8
	mov	ecx, DWORD PTR _pValue$[ebp]
	mov	DWORD PTR [ecx], eax
$L37190:

; 1122 : 
; 1123 : 	return 0;

	xor	eax, eax

; 1124 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ReadFunction@CRestore@@QAEHPAUdatamap_s@@PAPAXPBD@Z ENDP ; CRestore::ReadFunction
_TEXT	ENDS
;	COMDAT ?BufferSkipBytes@CRestore@@AAEXH@Z
_TEXT	SEGMENT
_bytes$ = 8
_this$ = -4
?BufferSkipBytes@CRestore@@AAEXH@Z PROC NEAR		; CRestore::BufferSkipBytes, COMDAT

; 1127 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1128 : 	BufferReadBytes( NULL, bytes );

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferReadBytes@CRestore@@AAEXPADH@Z	; CRestore::BufferReadBytes

; 1129 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?BufferSkipBytes@CRestore@@AAEXH@Z ENDP			; CRestore::BufferSkipBytes
_TEXT	ENDS
END
