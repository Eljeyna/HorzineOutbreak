	TITLE	Z:\XashXTSRC\server\monsters\hgrunt.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGEN@AnimateUntilDead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@HADJ@monster_human_grunt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07CODL@CHGrunt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@CJNC@m_flNextGrenadeCheck?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@PCHG@m_flNextPainTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@HKBG@m_vecTossVelocity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MOEP@m_fThrowGrenade?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OMBA@m_fStanding?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@GBGO@m_fFirstEncounter?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@DGDH@m_cClipSize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@EFEH@m_voicePitch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@EHHL@m_iSentence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07HNAE@HG_GREN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MHEE@HG_ALERT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@POLO@HG_MONSTER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MLCH@HG_COVER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDKG@HG_THROW?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09EDAH@HG_CHARGE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08NLBG@HG_TAUNT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@OKKG@monster_alien_grunt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@HELP@monster_gargantua?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@PHLB@weapon_shotgun?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@JNOE@weapon_9mmAR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@OEBJ@ammo_ARgrenades?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MGGI@HG_CHECK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IJFI@HG_QUEST?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07ENJK@HG_IDLE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CJCK@HG_CLEAR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HMJB@HG_ANSWER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@BCPF@hgrunt?1gr_reload1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@BCAJ@weapons?1glauncher?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@CKJG@hgrunt?1gr_mgun1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MKPJ@hgrunt?1gr_mgun2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@MGAA@weapons?1sbarrel1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@KNIA@models?1hgrunt?4mdl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@BMMK@hgrunt?1gr_die1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@PMKF@hgrunt?1gr_die2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@FMIA@hgrunt?1gr_die3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@EAHL@hgrunt?1gr_pain1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@KABE@hgrunt?1gr_pain2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@DB@hgrunt?1gr_pain3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GAML@hgrunt?1gr_pain4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MAOO@hgrunt?1gr_pain5?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@CPHF@zombie?1claw_miss2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GKKK@models?1shell?4mdl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@MEKG@models?1shotgunshell?4mdl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DLCP@Grunt?5Fail?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@BHFD@Grunt?5Combat?5Fail?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@EPDH@GruntVictoryDance?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IHGK@GruntEstablishLineOfFire?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLPF@GruntFoundEnemy?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@PJGE@Combat?5Face?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@GENL@SignalSuppress?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GBOH@Suppress?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@PAMC@GruntWaitInCover?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09GDCL@TakeCover?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GJPF@GrenadeCover?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@EODM@TossGrenadeCover?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@NPHI@GruntTakeCoverFromBestSound?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@BOKD@GruntHideReload?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@IMFC@Grunt?5Sweep?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@KIOH@Range?5Attack1A?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@FHFO@Range?5Attack1B?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@KCHH@RangeAttack2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05NJLA@Repel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@FFIL@Repel?5Attack?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NBOH@Repel?5Land?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@IMKA@standing_mp5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@NMOD@crouching_mp5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@DCBE@standing_shotgun?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@DIAD@crouching_shotgun?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GDEM@throwgrenade?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@POID@launchgrenade?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@FOLO@?$CFs?5has?5no?5sequence?5for?5act?3?$CFd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@MECP@z?3?2xashxtsrc?2server?2monsters?2hgr@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@OOBL@pSound?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FJCJ@HG_MONST?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GetSchedule@CHGrunt@@UAEPAUSchedule_t@@XZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@LFFA@monster_grunt_repel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FHOL@sprites?1rope?4spr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@JAIB@deadstomach?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08BKGO@deadside?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@HFON@deadsitting?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04JLAH@pose?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@DOBH@monster_hgrunt_dead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@FEKK@Dead?5hgrunt?5with?5bad?5pose?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?entindex@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPointEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseToggle@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseToggle@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasWeapon@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddWeapon@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stop@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScheduleChange@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanPlaySentence@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TaskComplete@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetYawSpeed@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CoverRadius@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckAmmo@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HearingSensitivity@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrescheduleThink@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AlertSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IdleSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PainSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopFollowing@CBaseMonster@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Forget@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MySquadLeader@CSquadMonster@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InSquad@CSquadMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLeader@CSquadMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CSquadMonster@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFlags@CBeam@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetColor@CBeam@@QAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E40
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CHGrunt@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CHGrunt@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E42
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E43
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E46
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpeakSentence@CHGrunt@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IRelationship@CHGrunt@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GibMonster@CHGrunt@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ISoundMask@CHGrunt@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FOkToSpeak@CHGrunt@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?JustSpoke@CHGrunt@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrescheduleThink@CHGrunt@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FCanCheckAttacks@CHGrunt@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckMeleeAttack1@CHGrunt@@UAEHMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckRangeAttack1@CHGrunt@@UAEHMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckRangeAttack2@CHGrunt@@UAEHMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceAttack@CHGrunt@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TakeDamage@CHGrunt@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetYawSpeed@CHGrunt@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IdleSound@CHGrunt@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckAmmo@CHGrunt@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CHGrunt@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Kick@CHGrunt@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGunPosition@CHGrunt@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shoot@CHGrunt@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shotgun@CHGrunt@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HandleAnimEvent@CHGrunt@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CHGrunt@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CHGrunt@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartTask@CHGrunt@@UAEXPAUTask_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RunTask@CHGrunt@@UAEXPAUTask_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PainSound@CHGrunt@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathSound@CHGrunt@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScheduleFromName@CHGrunt@@UAEPAUSchedule_t@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActivity@CHGrunt@@UAEXW4Activity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSchedule@CHGrunt@@UAEPAUSchedule_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetScheduleOfType@CHGrunt@@UAEPAUSchedule_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CHGruntRepel@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CHGruntRepel@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CHGruntRepel@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CDeadHGrunt@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CDeadHGrunt@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E51
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E52
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CDeadHGrunt@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCHGrunt@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCHGrunt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCHGrunt@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCHGrunt@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCHGruntRepel@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCHGruntRepel@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCHGruntRepel@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCHGruntRepel@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCDeadHGrunt@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCDeadHGrunt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCDeadHGrunt@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCDeadHGrunt@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCSquadMonster@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHGrunt@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHGruntRepel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDeadHGrunt@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSquadMonster@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSquadMonster@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseMonster@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseMonster@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseToggle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseToggle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WayPoint_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CHGruntRepel@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseAnimating@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCHGruntRepel@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHGrunt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCHGrunt@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseMonster@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSquadMonster@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseToggle@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CDeadHGrunt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCDeadHGrunt@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?slGruntVictoryDance@@3PAUSchedule_t@@A		; slGruntVictoryDance
PUBLIC	??_C@_0BC@EPDH@GruntVictoryDance?$AA@		; `string'
PUBLIC	?tlGruntEstablishLineOfFire@@3PAUTask_t@@A	; tlGruntEstablishLineOfFire
PUBLIC	?slGruntEstablishLineOfFire@@3PAUSchedule_t@@A	; slGruntEstablishLineOfFire
PUBLIC	??_C@_0BJ@IHGK@GruntEstablishLineOfFire?$AA@	; `string'
PUBLIC	?tlGruntFoundEnemy@@3PAUTask_t@@A		; tlGruntFoundEnemy
PUBLIC	?slGruntFoundEnemy@@3PAUSchedule_t@@A		; slGruntFoundEnemy
PUBLIC	??_C@_0BA@PLPF@GruntFoundEnemy?$AA@		; `string'
PUBLIC	?tlGruntCombatFace1@@3PAUTask_t@@A		; tlGruntCombatFace1
PUBLIC	?slGruntCombatFace@@3PAUSchedule_t@@A		; slGruntCombatFace
PUBLIC	??_C@_0M@PJGE@Combat?5Face?$AA@			; `string'
PUBLIC	?tlGruntSignalSuppress@@3PAUTask_t@@A		; tlGruntSignalSuppress
PUBLIC	?slGruntSignalSuppress@@3PAUSchedule_t@@A	; slGruntSignalSuppress
PUBLIC	??_C@_0P@GENL@SignalSuppress?$AA@		; `string'
PUBLIC	?tlGruntSuppress@@3PAUTask_t@@A			; tlGruntSuppress
PUBLIC	?slGruntSuppress@@3PAUSchedule_t@@A		; slGruntSuppress
PUBLIC	??_C@_08GBOH@Suppress?$AA@			; `string'
PUBLIC	?tlGruntWaitInCover@@3PAUTask_t@@A		; tlGruntWaitInCover
PUBLIC	?slGruntWaitInCover@@3PAUSchedule_t@@A		; slGruntWaitInCover
PUBLIC	??_C@_0BB@PAMC@GruntWaitInCover?$AA@		; `string'
PUBLIC	?tlGruntTakeCover1@@3PAUTask_t@@A		; tlGruntTakeCover1
PUBLIC	?slGruntTakeCover@@3PAUSchedule_t@@A		; slGruntTakeCover
PUBLIC	??_C@_09GDCL@TakeCover?$AA@			; `string'
PUBLIC	?tlGruntGrenadeCover1@@3PAUTask_t@@A		; tlGruntGrenadeCover1
PUBLIC	?slGruntGrenadeCover@@3PAUSchedule_t@@A		; slGruntGrenadeCover
PUBLIC	??_C@_0N@GJPF@GrenadeCover?$AA@			; `string'
PUBLIC	?tlGruntTossGrenadeCover1@@3PAUTask_t@@A	; tlGruntTossGrenadeCover1
PUBLIC	?slGruntTossGrenadeCover@@3PAUSchedule_t@@A	; slGruntTossGrenadeCover
PUBLIC	??_C@_0BB@EODM@TossGrenadeCover?$AA@		; `string'
PUBLIC	?tlGruntTakeCoverFromBestSound@@3PAUTask_t@@A	; tlGruntTakeCoverFromBestSound
PUBLIC	?slGruntTakeCoverFromBestSound@@3PAUSchedule_t@@A ; slGruntTakeCoverFromBestSound
PUBLIC	??_C@_0BM@NPHI@GruntTakeCoverFromBestSound?$AA@	; `string'
PUBLIC	?tlGruntHideReload@@3PAUTask_t@@A		; tlGruntHideReload
PUBLIC	?slGruntHideReload@@3PAUSchedule_t@@A		; slGruntHideReload
PUBLIC	??_C@_0BA@BOKD@GruntHideReload?$AA@		; `string'
PUBLIC	?tlGruntSweep@@3PAUTask_t@@A			; tlGruntSweep
PUBLIC	?slGruntSweep@@3PAUSchedule_t@@A		; slGruntSweep
PUBLIC	??_C@_0M@IMFC@Grunt?5Sweep?$AA@			; `string'
PUBLIC	?tlGruntRangeAttack1A@@3PAUTask_t@@A		; tlGruntRangeAttack1A
PUBLIC	?slGruntRangeAttack1A@@3PAUSchedule_t@@A	; slGruntRangeAttack1A
PUBLIC	??_C@_0P@KIOH@Range?5Attack1A?$AA@		; `string'
PUBLIC	?tlGruntRangeAttack1B@@3PAUTask_t@@A		; tlGruntRangeAttack1B
PUBLIC	?slGruntRangeAttack1B@@3PAUSchedule_t@@A	; slGruntRangeAttack1B
PUBLIC	??_C@_0P@FHFO@Range?5Attack1B?$AA@		; `string'
PUBLIC	?tlGruntRangeAttack2@@3PAUTask_t@@A		; tlGruntRangeAttack2
PUBLIC	?slGruntRangeAttack2@@3PAUSchedule_t@@A		; slGruntRangeAttack2
PUBLIC	??_C@_0N@KCHH@RangeAttack2?$AA@			; `string'
PUBLIC	?tlGruntRepel@@3PAUTask_t@@A			; tlGruntRepel
PUBLIC	?slGruntRepel@@3PAUSchedule_t@@A		; slGruntRepel
PUBLIC	??_C@_05NJLA@Repel?$AA@				; `string'
PUBLIC	?tlGruntRepelAttack@@3PAUTask_t@@A		; tlGruntRepelAttack
PUBLIC	?slGruntRepelAttack@@3PAUSchedule_t@@A		; slGruntRepelAttack
PUBLIC	??_C@_0N@FFIL@Repel?5Attack?$AA@		; `string'
PUBLIC	?tlGruntRepelLand@@3PAUTask_t@@A		; tlGruntRepelLand
PUBLIC	?slGruntRepelLand@@3PAUSchedule_t@@A		; slGruntRepelLand
PUBLIC	??_C@_0L@NBOH@Repel?5Land?$AA@			; `string'
PUBLIC	?g_fGruntQuestion@@3HA				; g_fGruntQuestion
PUBLIC	?m_scheduleList@CHGrunt@@2PAPAUSchedule_t@@A	; CHGrunt::m_scheduleList
PUBLIC	?m_DataMap@CHGrunt@@2Udatamap_s@@A		; CHGrunt::m_DataMap
PUBLIC	?pGruntSentences@CHGrunt@@2PAPBDA		; CHGrunt::pGruntSentences
PUBLIC	?m_szPoses@CDeadHGrunt@@2PAPADA			; CDeadHGrunt::m_szPoses
PUBLIC	??_C@_0M@JAIB@deadstomach?$AA@			; `string'
PUBLIC	??_C@_08BKGO@deadside?$AA@			; `string'
PUBLIC	??_C@_0M@HFON@deadsitting?$AA@			; `string'
PUBLIC	??_C@_07CODL@CHGrunt?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CHGrunt_DataDescInit@@3PAUdatamap_s@@A ; CHGrunt_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0BF@CJNC@m_flNextGrenadeCheck?$AA@	; `string'
PUBLIC	??_C@_0BB@PCHG@m_flNextPainTime?$AA@		; `string'
PUBLIC	??_C@_0BC@HKBG@m_vecTossVelocity?$AA@		; `string'
PUBLIC	??_C@_0BA@MOEP@m_fThrowGrenade?$AA@		; `string'
PUBLIC	??_C@_0M@OMBA@m_fStanding?$AA@			; `string'
PUBLIC	??_C@_0BC@GBGO@m_fFirstEncounter?$AA@		; `string'
PUBLIC	??_C@_0M@DGDH@m_cClipSize?$AA@			; `string'
PUBLIC	??_C@_0N@EFEH@m_voicePitch?$AA@			; `string'
PUBLIC	??_C@_0M@EHHL@m_iSentence?$AA@			; `string'
PUBLIC	??_C@_07HNAE@HG_GREN?$AA@			; `string'
PUBLIC	??_C@_08MHEE@HG_ALERT?$AA@			; `string'
PUBLIC	??_C@_0L@POLO@HG_MONSTER?$AA@			; `string'
PUBLIC	??_C@_08MLCH@HG_COVER?$AA@			; `string'
PUBLIC	??_C@_08IDKG@HG_THROW?$AA@			; `string'
PUBLIC	??_C@_09EDAH@HG_CHARGE?$AA@			; `string'
PUBLIC	??_C@_08NLBG@HG_TAUNT?$AA@			; `string'
PUBLIC	?HGRUNT_SENTENCE_TYPES@@3W4__unnamed@@A		; HGRUNT_SENTENCE_TYPES
PUBLIC	?tlGruntFail@@3PAUTask_t@@A			; tlGruntFail
PUBLIC	?slGruntFail@@3PAUSchedule_t@@A			; slGruntFail
PUBLIC	??_C@_0L@DLCP@Grunt?5Fail?$AA@			; `string'
PUBLIC	?tlGruntCombatFail@@3PAUTask_t@@A		; tlGruntCombatFail
PUBLIC	?slGruntCombatFail@@3PAUSchedule_t@@A		; slGruntCombatFail
PUBLIC	??_C@_0BC@BHFD@Grunt?5Combat?5Fail?$AA@		; `string'
PUBLIC	?tlGruntVictoryDance@@3PAUTask_t@@A		; tlGruntVictoryDance
_BSS	SEGMENT
?g_fGruntQuestion@@3HA DD 01H DUP (?)			; g_fGruntQuestion
?g_DataMapHolder@CHGrunt_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CHGrunt_DataDescInit::g_DataMapHolder
?HGRUNT_SENTENCE_TYPES@@3W4__unnamed@@A DD 01H DUP (?)	; HGRUNT_SENTENCE_TYPES
_BSS	ENDS
CRT$XCU	SEGMENT
_$S41	DD	FLAT:_$E40
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CHGrunt@@2Udatamap_s@@A DD 00H		; CHGrunt::m_DataMap
	DD	00H
	DD	FLAT:??_C@_07CODL@CHGrunt?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S44	DD	FLAT:_$E43
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BF@CJNC@m_flNextGrenadeCheck?$AA@
	DD	0994H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BB@PCHG@m_flNextPainTime?$AA@
	DD	0998H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0BC@HKBG@m_vecTossVelocity?$AA@
	DD	09a0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_0BA@MOEP@m_fThrowGrenade?$AA@
	DD	09acH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_0M@OMBA@m_fStanding?$AA@
	DD	09b0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_0BC@GBGO@m_fFirstEncounter?$AA@
	DD	09b4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0M@DGDH@m_cClipSize?$AA@
	DD	09b8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0N@EFEH@m_voicePitch?$AA@
	DD	09bcH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0M@EHHL@m_iSentence?$AA@
	DD	09c8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
?pGruntSentences@CHGrunt@@2PAPBDA DD FLAT:??_C@_07HNAE@HG_GREN?$AA@ ; CHGrunt::pGruntSentences
	DD	FLAT:??_C@_08MHEE@HG_ALERT?$AA@
	DD	FLAT:??_C@_0L@POLO@HG_MONSTER?$AA@
	DD	FLAT:??_C@_08MLCH@HG_COVER?$AA@
	DD	FLAT:??_C@_08IDKG@HG_THROW?$AA@
	DD	FLAT:??_C@_09EDAH@HG_CHARGE?$AA@
	DD	FLAT:??_C@_08NLBG@HG_TAUNT?$AA@
	ORG $+4
?tlGruntFail@@3PAUTask_t@@A DD 054H			; tlGruntFail
	DD	000000000r			; 0
	DD	039H
	DD	03f800000r			; 1
	DD	01H
	DD	040000000r			; 2
	DD	03H
	DD	000000000r			; 0
?slGruntFail@@3PAUSchedule_t@@A DD FLAT:?tlGruntFail@@3PAUTask_t@@A ; slGruntFail
	DD	04H
	DD	03c00H
	DD	00H
	DD	FLAT:??_C@_0L@DLCP@Grunt?5Fail?$AA@
	ORG $+4
?tlGruntCombatFail@@3PAUTask_t@@A DD 054H		; tlGruntCombatFail
	DD	000000000r			; 0
	DD	039H
	DD	03f800000r			; 1
	DD	02H
	DD	040000000r			; 2
	DD	03H
	DD	000000000r			; 0
?slGruntCombatFail@@3PAUSchedule_t@@A DD FLAT:?tlGruntCombatFail@@3PAUTask_t@@A ; slGruntCombatFail
	DD	04H
	DD	01400H
	DD	00H
	DD	FLAT:??_C@_0BC@BHFD@Grunt?5Combat?5Fail?$AA@
	ORG $+4
?tlGruntVictoryDance@@3PAUTask_t@@A DD 054H		; tlGruntVictoryDance
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	01H
	DD	03fc00000r			; 1.5
	DD	0aH
	DD	000000000r			; 0
	DD	013H
	DD	000000000r			; 0
	DD	059H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	03dH
	DD	042820000r			; 65
?slGruntVictoryDance@@3PAUSchedule_t@@A DD FLAT:?tlGruntVictoryDance@@3PAUTask_t@@A ; slGruntVictoryDance
	DD	08H
	DD	010300H
	DD	00H
	DD	FLAT:??_C@_0BC@EPDH@GruntVictoryDance?$AA@
	ORG $+4
?tlGruntEstablishLineOfFire@@3PAUTask_t@@A DD 03bH	; tlGruntEstablishLineOfFire
	DD	042540000r			; 53
	DD	08H
	DD	000000000r			; 0
	DD	05cH
	DD	000000000r			; 0
	DD	012H
	DD	000000000r			; 0
	DD	059H
	DD	000000000r			; 0
?slGruntEstablishLineOfFire@@3PAUSchedule_t@@A DD FLAT:?tlGruntEstablishLineOfFire@@3PAUTask_t@@A ; slGruntEstablishLineOfFire
	DD	05H
	DD	0133c00H
	DD	020H
	DD	FLAT:??_C@_0BJ@IHGK@GruntEstablishLineOfFire?$AA@
	ORG $+4
?tlGruntFoundEnemy@@3PAUTask_t@@A DD 054H		; tlGruntFoundEnemy
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	03eH
	DD	041a80000r			; 21
?slGruntFoundEnemy@@3PAUSchedule_t@@A DD FLAT:?tlGruntFoundEnemy@@3PAUTask_t@@A ; slGruntFoundEnemy
	DD	03H
	DD	020000H
	DD	020H
	DD	FLAT:??_C@_0BA@PLPF@GruntFoundEnemy?$AA@
	ORG $+4
?tlGruntCombatFace1@@3PAUTask_t@@A DD 054H		; tlGruntCombatFace1
	DD	000000000r			; 0
	DD	039H
	DD	03f800000r			; 1
	DD	01eH
	DD	000000000r			; 0
	DD	01H
	DD	03fc00000r			; 1.5
	DD	03aH
	DD	042380000r			; 46
?slGruntCombatFace@@3PAUSchedule_t@@A DD FLAT:?tlGruntCombatFace1@@3PAUTask_t@@A ; slGruntCombatFace
	DD	05H
	DD	0111400H
	DD	00H
	DD	FLAT:??_C@_0M@PJGE@Combat?5Face?$AA@
	ORG $+4
?tlGruntSignalSuppress@@3PAUTask_t@@A DD 054H		; tlGruntSignalSuppress
	DD	000000000r			; 0
	DD	01cH
	DD	000000000r			; 0
	DD	03eH
	DD	041b00000r			; 22
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
?slGruntSignalSuppress@@3PAUSchedule_t@@A DD FLAT:?tlGruntSignalSuppress@@3PAUTask_t@@A ; slGruntSignalSuppress
	DD	012H
	DD	010120301H
	DD	020H
	DD	FLAT:??_C@_0P@GENL@SignalSuppress?$AA@
	ORG $+4
?tlGruntSuppress@@3PAUTask_t@@A DD 054H			; tlGruntSuppress
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
?slGruntSuppress@@3PAUSchedule_t@@A DD FLAT:?tlGruntSuppress@@3PAUTask_t@@A ; slGruntSuppress
	DD	010H
	DD	010120301H
	DD	020H
	DD	FLAT:??_C@_08GBOH@Suppress?$AA@
	ORG $+4
?tlGruntWaitInCover@@3PAUTask_t@@A DD 054H		; tlGruntWaitInCover
	DD	000000000r			; 0
	DD	039H
	DD	03f800000r			; 1
	DD	02H
	DD	03f800000r			; 1
?slGruntWaitInCover@@3PAUSchedule_t@@A DD FLAT:?tlGruntWaitInCover@@3PAUTask_t@@A ; slGruntWaitInCover
	DD	03H
	DD	033c00H
	DD	020H
	DD	FLAT:??_C@_0BB@PAMC@GruntWaitInCover?$AA@
	ORG $+4
?tlGruntTakeCover1@@3PAUTask_t@@A DD 054H		; tlGruntTakeCover1
	DD	000000000r			; 0
	DD	03bH
	DD	042500000r			; 52
	DD	01H
	DD	03e4ccccdr			; 0.2
	DD	045H
	DD	000000000r			; 0
	DD	05cH
	DD	000000000r			; 0
	DD	012H
	DD	000000000r			; 0
	DD	059H
	DD	000000000r			; 0
	DD	057H
	DD	040000000r			; 2
	DD	03aH
	DD	0424c0000r			; 51
?slGruntTakeCover@@3PAUSchedule_t@@A DD FLAT:?tlGruntTakeCover1@@3PAUTask_t@@A ; slGruntTakeCover
	DD	09H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_09GDCL@TakeCover?$AA@
	ORG $+4
?tlGruntGrenadeCover1@@3PAUTask_t@@A DD 054H		; tlGruntGrenadeCover1
	DD	000000000r			; 0
	DD	045H
	DD	042c60000r			; 99
	DD	049H
	DD	043c00000r			; 384
	DD	03dH
	DD	042700000r			; 60
	DD	015H
	DD	000000000r			; 0
	DD	012H
	DD	000000000r			; 0
	DD	059H
	DD	000000000r			; 0
	DD	03aH
	DD	0424c0000r			; 51
?slGruntGrenadeCover@@3PAUSchedule_t@@A DD FLAT:?tlGruntGrenadeCover1@@3PAUTask_t@@A ; slGruntGrenadeCover
	DD	08H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0N@GJPF@GrenadeCover?$AA@
	ORG $+4
?tlGruntTossGrenadeCover1@@3PAUTask_t@@A DD 01eH	; tlGruntTossGrenadeCover1
	DD	000000000r			; 0
	DD	023H
	DD	000000000r			; 0
	DD	03aH
	DD	041900000r			; 18
?slGruntTossGrenadeCover@@3PAUSchedule_t@@A DD FLAT:?tlGruntTossGrenadeCover1@@3PAUTask_t@@A ; slGruntTossGrenadeCover
	DD	03H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BB@EODM@TossGrenadeCover?$AA@
	ORG $+4
?tlGruntTakeCoverFromBestSound@@3PAUTask_t@@A DD 03bH	; tlGruntTakeCoverFromBestSound
	DD	041a80000r			; 21
	DD	054H
	DD	000000000r			; 0
	DD	044H
	DD	000000000r			; 0
	DD	012H
	DD	000000000r			; 0
	DD	059H
	DD	000000000r			; 0
	DD	057H
	DD	040000000r			; 2
	DD	055H
	DD	043330000r			; 179
?slGruntTakeCoverFromBestSound@@3PAUSchedule_t@@A DD FLAT:?tlGruntTakeCoverFromBestSound@@3PAUTask_t@@A ; slGruntTakeCoverFromBestSound
	DD	07H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BM@NPHI@GruntTakeCoverFromBestSound?$AA@
	ORG $+4
?tlGruntHideReload@@3PAUTask_t@@A DD 054H		; tlGruntHideReload
	DD	000000000r			; 0
	DD	03bH
	DD	041f00000r			; 30
	DD	045H
	DD	000000000r			; 0
	DD	012H
	DD	000000000r			; 0
	DD	059H
	DD	000000000r			; 0
	DD	057H
	DD	040000000r			; 2
	DD	01eH
	DD	000000000r			; 0
	DD	03dH
	DD	042000000r			; 32
?slGruntHideReload@@3PAUSchedule_t@@A DD FLAT:?tlGruntHideReload@@3PAUTask_t@@A ; slGruntHideReload
	DD	08H
	DD	020200H
	DD	020H
	DD	FLAT:??_C@_0BA@BOKD@GruntHideReload?$AA@
	ORG $+4
?tlGruntSweep@@3PAUTask_t@@A DD 055H			; tlGruntSweep
	DD	043330000r			; 179
	DD	01H
	DD	03f800000r			; 1
	DD	055H
	DD	043330000r			; 179
	DD	01H
	DD	03f800000r			; 1
?slGruntSweep@@3PAUSchedule_t@@A DD FLAT:?tlGruntSweep@@3PAUTask_t@@A ; slGruntSweep
	DD	04H
	DD	031700H
	DD	026H
	DD	FLAT:??_C@_0M@IMFC@Grunt?5Sweep?$AA@
	ORG $+4
?tlGruntRangeAttack1A@@3PAUTask_t@@A DD 054H		; tlGruntRangeAttack1A
	DD	000000000r			; 0
	DD	03eH
	DD	041880000r			; 17
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
?slGruntRangeAttack1A@@3PAUSchedule_t@@A DD FLAT:?tlGruntRangeAttack1A@@3PAUTask_t@@A ; slGruntRangeAttack1A
	DD	0dH
	DD	010130221H
	DD	020H
	DD	FLAT:??_C@_0P@KIOH@Range?5Attack1A?$AA@
	ORG $+4
?tlGruntRangeAttack1B@@3PAUTask_t@@A DD 054H		; tlGruntRangeAttack1B
	DD	000000000r			; 0
	DD	03eH
	DD	0423c0000r			; 47
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	05dH
	DD	000000000r			; 0
	DD	022H
	DD	000000000r			; 0
?slGruntRangeAttack1B@@3PAUSchedule_t@@A DD FLAT:?tlGruntRangeAttack1B@@3PAUTask_t@@A ; slGruntRangeAttack1B
	DD	0dH
	DD	010130221H
	DD	020H
	DD	FLAT:??_C@_0P@FHFO@Range?5Attack1B?$AA@
	ORG $+4
?tlGruntRangeAttack2@@3PAUTask_t@@A DD 054H		; tlGruntRangeAttack2
	DD	000000000r			; 0
	DD	05bH
	DD	000000000r			; 0
	DD	03dH
	DD	041e80000r			; 29
	DD	03aH
	DD	0424c0000r			; 51
?slGruntRangeAttack2@@3PAUSchedule_t@@A DD FLAT:?tlGruntRangeAttack2@@3PAUTask_t@@A ; slGruntRangeAttack2
	DD	04H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0N@KCHH@RangeAttack2?$AA@
	ORG $+4
?tlGruntRepel@@3PAUTask_t@@A DD 054H			; tlGruntRepel
	DD	000000000r			; 0
	DD	01cH
	DD	000000000r			; 0
	DD	03dH
	DD	0424c0000r			; 51
?slGruntRepel@@3PAUSchedule_t@@A DD FLAT:?tlGruntRepel@@3PAUTask_t@@A ; slGruntRepel
	DD	03H
	DD	030310H
	DD	025H
	DD	FLAT:??_C@_05NJLA@Repel?$AA@
	ORG $+4
?tlGruntRepelAttack@@3PAUTask_t@@A DD 054H		; tlGruntRepelAttack
	DD	000000000r			; 0
	DD	01eH
	DD	000000000r			; 0
	DD	03dH
	DD	040a00000r			; 5
?slGruntRepelAttack@@3PAUSchedule_t@@A DD FLAT:?tlGruntRepelAttack@@3PAUTask_t@@A ; slGruntRepelAttack
	DD	03H
	DD	020H
	DD	00H
	DD	FLAT:??_C@_0N@FFIL@Repel?5Attack?$AA@
	ORG $+4
?tlGruntRepelLand@@3PAUTask_t@@A DD 054H		; tlGruntRepelLand
	DD	000000000r			; 0
	DD	03dH
	DD	041200000r			; 10
	DD	0fH
	DD	000000000r			; 0
	DD	012H
	DD	000000000r			; 0
	DD	059H
	DD	000000000r			; 0
	DD	017H
	DD	000000000r			; 0
?slGruntRepelLand@@3PAUSchedule_t@@A DD FLAT:?tlGruntRepelLand@@3PAUTask_t@@A ; slGruntRepelLand
	DD	06H
	DD	030310H
	DD	025H
	DD	FLAT:??_C@_0L@NBOH@Repel?5Land?$AA@
?m_scheduleList@CHGrunt@@2PAPAUSchedule_t@@A DD FLAT:?slGruntFail@@3PAUSchedule_t@@A ; CHGrunt::m_scheduleList
	DD	FLAT:?slGruntCombatFail@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntVictoryDance@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntEstablishLineOfFire@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntFoundEnemy@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntCombatFace@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntSignalSuppress@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntSuppress@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntWaitInCover@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntTakeCover@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntGrenadeCover@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntTossGrenadeCover@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntTakeCoverFromBestSound@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntHideReload@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntSweep@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntRangeAttack1A@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntRangeAttack1B@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntRangeAttack2@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntRepel@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntRepelAttack@@3PAUSchedule_t@@A
	DD	FLAT:?slGruntRepelLand@@3PAUSchedule_t@@A
_DATA	ENDS
CRT$XCU	SEGMENT
_$S49	DD	FLAT:_$E48
CRT$XCU	ENDS
_DATA	SEGMENT
?m_szPoses@CDeadHGrunt@@2PAPADA DD FLAT:??_C@_0M@JAIB@deadstomach?$AA@ ; CDeadHGrunt::m_szPoses
	DD	FLAT:??_C@_08BKGO@deadside?$AA@
	DD	FLAT:??_C@_0M@HFON@deadsitting?$AA@
_DATA	ENDS
CRT$XCU	SEGMENT
_$S53	DD	FLAT:_$E52
CRT$XCU	ENDS
;	COMDAT ??_C@_07CODL@CHGrunt?$AA@
CONST	SEGMENT
??_C@_07CODL@CHGrunt?$AA@ DB 'CHGrunt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CJNC@m_flNextGrenadeCheck?$AA@
CONST	SEGMENT
??_C@_0BF@CJNC@m_flNextGrenadeCheck?$AA@ DB 'm_flNextGrenadeCheck', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PCHG@m_flNextPainTime?$AA@
CONST	SEGMENT
??_C@_0BB@PCHG@m_flNextPainTime?$AA@ DB 'm_flNextPainTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HKBG@m_vecTossVelocity?$AA@
CONST	SEGMENT
??_C@_0BC@HKBG@m_vecTossVelocity?$AA@ DB 'm_vecTossVelocity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MOEP@m_fThrowGrenade?$AA@
CONST	SEGMENT
??_C@_0BA@MOEP@m_fThrowGrenade?$AA@ DB 'm_fThrowGrenade', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OMBA@m_fStanding?$AA@
CONST	SEGMENT
??_C@_0M@OMBA@m_fStanding?$AA@ DB 'm_fStanding', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GBGO@m_fFirstEncounter?$AA@
CONST	SEGMENT
??_C@_0BC@GBGO@m_fFirstEncounter?$AA@ DB 'm_fFirstEncounter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DGDH@m_cClipSize?$AA@
CONST	SEGMENT
??_C@_0M@DGDH@m_cClipSize?$AA@ DB 'm_cClipSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EFEH@m_voicePitch?$AA@
CONST	SEGMENT
??_C@_0N@EFEH@m_voicePitch?$AA@ DB 'm_voicePitch', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EHHL@m_iSentence?$AA@
CONST	SEGMENT
??_C@_0M@EHHL@m_iSentence?$AA@ DB 'm_iSentence', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HNAE@HG_GREN?$AA@
CONST	SEGMENT
??_C@_07HNAE@HG_GREN?$AA@ DB 'HG_GREN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MHEE@HG_ALERT?$AA@
CONST	SEGMENT
??_C@_08MHEE@HG_ALERT?$AA@ DB 'HG_ALERT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@POLO@HG_MONSTER?$AA@
CONST	SEGMENT
??_C@_0L@POLO@HG_MONSTER?$AA@ DB 'HG_MONSTER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLCH@HG_COVER?$AA@
CONST	SEGMENT
??_C@_08MLCH@HG_COVER?$AA@ DB 'HG_COVER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDKG@HG_THROW?$AA@
CONST	SEGMENT
??_C@_08IDKG@HG_THROW?$AA@ DB 'HG_THROW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EDAH@HG_CHARGE?$AA@
CONST	SEGMENT
??_C@_09EDAH@HG_CHARGE?$AA@ DB 'HG_CHARGE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLBG@HG_TAUNT?$AA@
CONST	SEGMENT
??_C@_08NLBG@HG_TAUNT?$AA@ DB 'HG_TAUNT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DLCP@Grunt?5Fail?$AA@
CONST	SEGMENT
??_C@_0L@DLCP@Grunt?5Fail?$AA@ DB 'Grunt Fail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BHFD@Grunt?5Combat?5Fail?$AA@
CONST	SEGMENT
??_C@_0BC@BHFD@Grunt?5Combat?5Fail?$AA@ DB 'Grunt Combat Fail', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EPDH@GruntVictoryDance?$AA@
CONST	SEGMENT
??_C@_0BC@EPDH@GruntVictoryDance?$AA@ DB 'GruntVictoryDance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IHGK@GruntEstablishLineOfFire?$AA@
CONST	SEGMENT
??_C@_0BJ@IHGK@GruntEstablishLineOfFire?$AA@ DB 'GruntEstablishLineOfFire'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLPF@GruntFoundEnemy?$AA@
CONST	SEGMENT
??_C@_0BA@PLPF@GruntFoundEnemy?$AA@ DB 'GruntFoundEnemy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PJGE@Combat?5Face?$AA@
CONST	SEGMENT
??_C@_0M@PJGE@Combat?5Face?$AA@ DB 'Combat Face', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GENL@SignalSuppress?$AA@
CONST	SEGMENT
??_C@_0P@GENL@SignalSuppress?$AA@ DB 'SignalSuppress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GBOH@Suppress?$AA@
CONST	SEGMENT
??_C@_08GBOH@Suppress?$AA@ DB 'Suppress', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PAMC@GruntWaitInCover?$AA@
CONST	SEGMENT
??_C@_0BB@PAMC@GruntWaitInCover?$AA@ DB 'GruntWaitInCover', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GDCL@TakeCover?$AA@
CONST	SEGMENT
??_C@_09GDCL@TakeCover?$AA@ DB 'TakeCover', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GJPF@GrenadeCover?$AA@
CONST	SEGMENT
??_C@_0N@GJPF@GrenadeCover?$AA@ DB 'GrenadeCover', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EODM@TossGrenadeCover?$AA@
CONST	SEGMENT
??_C@_0BB@EODM@TossGrenadeCover?$AA@ DB 'TossGrenadeCover', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NPHI@GruntTakeCoverFromBestSound?$AA@
CONST	SEGMENT
??_C@_0BM@NPHI@GruntTakeCoverFromBestSound?$AA@ DB 'GruntTakeCoverFromBes'
	DB	'tSound', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BOKD@GruntHideReload?$AA@
CONST	SEGMENT
??_C@_0BA@BOKD@GruntHideReload?$AA@ DB 'GruntHideReload', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IMFC@Grunt?5Sweep?$AA@
CONST	SEGMENT
??_C@_0M@IMFC@Grunt?5Sweep?$AA@ DB 'Grunt Sweep', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KIOH@Range?5Attack1A?$AA@
CONST	SEGMENT
??_C@_0P@KIOH@Range?5Attack1A?$AA@ DB 'Range Attack1A', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FHFO@Range?5Attack1B?$AA@
CONST	SEGMENT
??_C@_0P@FHFO@Range?5Attack1B?$AA@ DB 'Range Attack1B', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KCHH@RangeAttack2?$AA@
CONST	SEGMENT
??_C@_0N@KCHH@RangeAttack2?$AA@ DB 'RangeAttack2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NJLA@Repel?$AA@
CONST	SEGMENT
??_C@_05NJLA@Repel?$AA@ DB 'Repel', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FFIL@Repel?5Attack?$AA@
CONST	SEGMENT
??_C@_0N@FFIL@Repel?5Attack?$AA@ DB 'Repel Attack', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NBOH@Repel?5Land?$AA@
CONST	SEGMENT
??_C@_0L@NBOH@Repel?5Land?$AA@ DB 'Repel Land', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JAIB@deadstomach?$AA@
CONST	SEGMENT
??_C@_0M@JAIB@deadstomach?$AA@ DB 'deadstomach', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BKGO@deadside?$AA@
CONST	SEGMENT
??_C@_08BKGO@deadside?$AA@ DB 'deadside', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HFON@deadsitting?$AA@
CONST	SEGMENT
??_C@_0M@HFON@deadsitting?$AA@ DB 'deadsitting', 00H	; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
;	COMDAT _$E40
_TEXT	SEGMENT
_$E40	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E39
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E40	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCHGrunt@@@@QAE@PBD@Z	; CEntityFactory<CHGrunt>::CEntityFactory<CHGrunt>
PUBLIC	??_C@_0BE@HADJ@monster_human_grunt?$AA@		; `string'
_BSS	SEGMENT
_monster_human_grunt DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BE@HADJ@monster_human_grunt?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_0BE@HADJ@monster_human_grunt?$AA@ DB 'monster_human_grunt', 00H ; `string'
CONST	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT
_$E39	PROC NEAR					; COMDAT

; 187  : LINK_ENTITY_TO_CLASS( monster_human_grunt, CHGrunt );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BE@HADJ@monster_human_grunt?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_monster_human_grunt
	call	??0?$CEntityFactory@VCHGrunt@@@@QAE@PBD@Z ; CEntityFactory<CHGrunt>::CEntityFactory<CHGrunt>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E39	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CHGrunt@@UAEPAUdatamap_s@@XZ	; CHGrunt::GetDataDescMap
;	COMDAT ?GetDataDescMap@CHGrunt@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CHGrunt@@UAEPAUdatamap_s@@XZ PROC NEAR	; CHGrunt::GetDataDescMap, COMDAT

; 189  : BEGIN_DATADESC( CHGrunt )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CHGrunt@@2Udatamap_s@@A ; CHGrunt::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CHGrunt@@UAEPAUdatamap_s@@XZ ENDP	; CHGrunt::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CHGrunt@@SAPAUdatamap_s@@XZ		; CHGrunt::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCSquadMonster@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CHGrunt@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CHGrunt@@SAPAUdatamap_s@@XZ PROC NEAR	; CHGrunt::GetBaseMap, COMDAT

; 189  : BEGIN_DATADESC( CHGrunt )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCSquadMonster@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CHGrunt@@SAPAUdatamap_s@@XZ ENDP		; CHGrunt::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E43
_TEXT	SEGMENT
_$E43	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E42
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E43	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z	; DataMapInit
;	COMDAT _$E42
_TEXT	SEGMENT
_$E42	PROC NEAR					; COMDAT

; 189  : BEGIN_DATADESC( CHGrunt )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CHGrunt_DataDescInit@@3PAUdatamap_s@@A, eax ; CHGrunt_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E42	ENDP
_TEXT	ENDS
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S45@?1??DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z PROC NEAR	; DataMapInit, COMDAT

; 189  : BEGIN_DATADESC( CHGrunt )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S45@?1??DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L38398
	mov	cl, BYTE PTR _?$S45@?1??DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S45@?1??DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_07CODL@CHGrunt?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E46
	call	_atexit
	add	esp, 4
$L38398:
	call	?GetBaseMap@CHGrunt@@SAPAUdatamap_s@@XZ	; CHGrunt::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CHGrunt@@2Udatamap_s@@A+12, eax

; 190  : 	DEFINE_FIELD( m_flNextGrenadeCheck, FIELD_TIME ),
; 191  : 	DEFINE_FIELD( m_flNextPainTime, FIELD_TIME ),
; 192  : //	DEFINE_FIELD( m_flLastEnemySightTime, FIELD_TIME ), // don't save, go to zero
; 193  : 	DEFINE_FIELD( m_vecTossVelocity, FIELD_VECTOR ),
; 194  : 	DEFINE_FIELD( m_fThrowGrenade, FIELD_BOOLEAN ),
; 195  : 	DEFINE_FIELD( m_fStanding, FIELD_BOOLEAN ),
; 196  : 	DEFINE_FIELD( m_fFirstEncounter, FIELD_BOOLEAN ),
; 197  : 	DEFINE_FIELD( m_cClipSize, FIELD_INTEGER ),
; 198  : 	DEFINE_FIELD( m_voicePitch, FIELD_INTEGER ),
; 199  : 	DEFINE_FIELD( m_iSentence, FIELD_INTEGER ),
; 200  : END_DATADESC()

	mov	edx, 1
	test	edx, edx
	je	SHORT $L38429
	mov	DWORD PTR ?m_DataMap@CHGrunt@@2Udatamap_s@@A+4, 9
	mov	DWORD PTR ?m_DataMap@CHGrunt@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L38430
$L38429:
	mov	DWORD PTR ?m_DataMap@CHGrunt@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CHGrunt@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z@4PAUtypedescription_s@@A
$L38430:
	mov	eax, OFFSET FLAT:?m_DataMap@CHGrunt@@2Udatamap_s@@A ; CHGrunt::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z ENDP	; DataMapInit
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
EXTRN	_strlen:NEAR
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_pszBase$ = 8
_this$ = -4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC NEAR	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E46
_TEXT	SEGMENT
_$E46	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCHGrunt@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E46	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File z:\xashxtsrc\common\datamap.h
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
$T40163 = -24
__$EHRec$ = -12
_this$ = -16
_i$ = -20
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC NEAR	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L30233
$L30234:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L30233:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L30235

; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T40163[ebp], edx
	mov	eax, DWORD PTR $T40163[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 		}

	jmp	SHORT $L30234
$L30235:

; 202  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	ret	0
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
PUBLIC	?SpeakSentence@CHGrunt@@QAEXXZ			; CHGrunt::SpeakSentence
PUBLIC	?FOkToSpeak@CHGrunt@@QAEHXZ			; CHGrunt::FOkToSpeak
PUBLIC	?JustSpoke@CHGrunt@@QAEXXZ			; CHGrunt::JustSpoke
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
EXTRN	__fltused:NEAR
EXTRN	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z:NEAR ; SENTENCEG_PlayRndSz
;	COMDAT ?SpeakSentence@CHGrunt@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SpeakSentence@CHGrunt@@QAEXXZ PROC NEAR		; CHGrunt::SpeakSentence, COMDAT

; 238  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 	if ( m_iSentence == HGRUNT_SENT_NONE )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2504], -1
	jne	SHORT $L38453

; 241  : 		// no sentence cued up.
; 242  : 		return; 

	jmp	SHORT $L38452
$L38453:

; 244  : 
; 245  : 	if (FOkToSpeak())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CHGrunt@@QAEHXZ		; CHGrunt::FOkToSpeak
	test	eax, eax
	je	SHORT $L38454

; 247  : 		SENTENCEG_PlayRndSz( ENT(pev), pGruntSentences[ m_iSentence ], HGRUNT_SENTENCE_VOLUME, GRUNT_ATTN, 0, m_voicePitch);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2492]
	push	edx
	push	0
	push	1061997773				; 3f4ccccdH
	push	1051931443				; 3eb33333H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2504]
	mov	edx, DWORD PTR ?pGruntSentences@CHGrunt@@2PAPBDA[ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H

; 248  : 		JustSpoke();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JustSpoke@CHGrunt@@QAEXXZ		; CHGrunt::JustSpoke
$L38454:
$L38452:

; 250  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SpeakSentence@CHGrunt@@QAEXXZ ENDP			; CHGrunt::SpeakSentence
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	?IRelationship@CHGrunt@@UAEHPAVCBaseEntity@@@Z	; CHGrunt::IRelationship
PUBLIC	??_C@_0BE@OKKG@monster_alien_grunt?$AA@		; `string'
PUBLIC	??_C@_0BC@HELP@monster_gargantua?$AA@		; `string'
PUBLIC	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z		; FClassnameIs
EXTRN	?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::IRelationship
;	COMDAT ??_C@_0BE@OKKG@monster_alien_grunt?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_0BE@OKKG@monster_alien_grunt?$AA@ DB 'monster_alien_grunt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HELP@monster_gargantua?$AA@
CONST	SEGMENT
??_C@_0BC@HELP@monster_gargantua?$AA@ DB 'monster_gargantua', 00H ; `string'
CONST	ENDS
;	COMDAT ?IRelationship@CHGrunt@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pTarget$ = 8
_this$ = -4
?IRelationship@CHGrunt@@UAEHPAVCBaseEntity@@@Z PROC NEAR ; CHGrunt::IRelationship, COMDAT

; 257  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 258  : 	//LRC- only hate alien grunts if my behaviour hasn't been overridden
; 259  : 	if (!m_iClass && FClassnameIs( pTarget->pev, "monster_alien_grunt" ) || ( FClassnameIs( pTarget->pev,  "monster_gargantua" ) ) )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2388], 0
	jne	SHORT $L38463
	push	OFFSET FLAT:??_C@_0BE@OKKG@monster_alien_grunt?$AA@ ; `string'
	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	jne	SHORT $L38462
$L38463:
	push	OFFSET FLAT:??_C@_0BC@HELP@monster_gargantua?$AA@ ; `string'
	mov	eax, DWORD PTR _pTarget$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L38461
$L38462:

; 261  : 		return R_NM;

	mov	eax, 3
	jmp	SHORT $L38460
$L38461:

; 263  : 
; 264  : 	return CSquadMonster::IRelationship( pTarget );

	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z ; CBaseMonster::IRelationship
$L38460:

; 265  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IRelationship@CHGrunt@@UAEHPAVCBaseEntity@@@Z ENDP	; CHGrunt::IRelationship
_TEXT	ENDS
PUBLIC	?FNullEnt@@YAHPAUentvars_s@@@Z			; FNullEnt
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT
_pev$ = 8
_szClassname$ = 12
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z PROC NEAR		; FClassnameIs, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 295  : 	if( FNullEnt( pev )) return FALSE;

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L32584
	xor	eax, eax
	jmp	SHORT $L32583
$L32584:

; 296  : 	return FStrEq( STRING( pev->classname ), szClassname );

	mov	ecx, DWORD PTR _szClassname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pev$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
$L32583:

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z ENDP		; FClassnameIs
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?FNullEnt@@YAHPAUentvars_s@@@Z PROC NEAR		; FNullEnt, COMDAT

; 196  : inline BOOL FNullEnt(entvars_t* pev)				{ return pev == NULL || FNullEnt(OFFSET(pev)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pev$[ebp], 0
	je	SHORT $L40186
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40186
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L40187
$L40186:
	mov	DWORD PTR -4+[ebp], 1
$L40187:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAUentvars_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad pev in OFFSET()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?OFFSET@@YAHPAUentvars_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L32458

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32458:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32452

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32452:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	?GibMonster@CHGrunt@@UAEXXZ			; CHGrunt::GibMonster
PUBLIC	??_C@_0P@PHLB@weapon_shotgun?$AA@		; `string'
PUBLIC	??_C@_0N@JNOE@weapon_9mmAR?$AA@			; `string'
PUBLIC	??_C@_0BA@OEBJ@ammo_ARgrenades?$AA@		; `string'
PUBLIC	?HasWeapon@CBaseMonster@@QAEHH@Z		; CBaseMonster::HasWeapon
EXTRN	?GibMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::GibMonster
EXTRN	?DropItem@CBaseMonster@@QAEPAVCBaseEntity@@PADABVVector@@1@Z:NEAR ; CBaseMonster::DropItem
EXTRN	?GetAttachment@CBaseAnimating@@QAEXHAAVVector@@0@Z:NEAR ; CBaseAnimating::GetAttachment
EXTRN	?GetBodygroup@CBaseAnimating@@QAEHH@Z:NEAR	; CBaseAnimating::GetBodygroup
EXTRN	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalVelocity
EXTRN	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAvelocity
;	COMDAT ??_C@_0P@PHLB@weapon_shotgun?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_0P@PHLB@weapon_shotgun?$AA@ DB 'weapon_shotgun', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JNOE@weapon_9mmAR?$AA@
CONST	SEGMENT
??_C@_0N@JNOE@weapon_9mmAR?$AA@ DB 'weapon_9mmAR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OEBJ@ammo_ARgrenades?$AA@
CONST	SEGMENT
??_C@_0BA@OEBJ@ammo_ARgrenades?$AA@ DB 'ammo_ARgrenades', 00H ; `string'
CONST	ENDS
;	COMDAT ?GibMonster@CHGrunt@@UAEXXZ
_TEXT	SEGMENT
$T40198 = -44
$T40199 = -56
$T40200 = -68
$T40201 = -80
_this$ = -4
_vecGunPos$ = -16
_vecGunAngles$ = -28
_pGun$38473 = -32
?GibMonster@CHGrunt@@UAEXXZ PROC NEAR			; CHGrunt::GibMonster, COMDAT

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 272  : 	Vector	vecGunPos;

	lea	ecx, DWORD PTR _vecGunPos$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 273  : 	Vector	vecGunAngles;

	lea	ecx, DWORD PTR _vecGunAngles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 274  : 
; 275  : 	if ( GetBodygroup( 2 ) != 2 && !( pev->spawnflags & SF_MONSTER_NO_WPN_DROP ))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBodygroup@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::GetBodygroup
	cmp	eax, 2
	je	$L38483
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1024				; 00000400H
	test	edx, edx
	jne	$L38483

; 277  : 		// throw a gun if the grunt has one
; 278  : 		GetAttachment( 0, vecGunPos, vecGunAngles );

	lea	eax, DWORD PTR _vecGunAngles$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecGunPos$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAttachment@CBaseAnimating@@QAEXHAAVVector@@0@Z ; CBaseAnimating::GetAttachment

; 279  : 		
; 280  : 		CBaseEntity *pGun;
; 281  : 		if( HasWeapon( HGRUNT_SHOTGUN ))

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L38474

; 283  : 			pGun = DropItem( "weapon_shotgun", vecGunPos, vecGunAngles );

	lea	edx, DWORD PTR _vecGunAngles$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecGunPos$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0P@PHLB@weapon_shotgun?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropItem@CBaseMonster@@QAEPAVCBaseEntity@@PADABVVector@@1@Z ; CBaseMonster::DropItem
	mov	DWORD PTR _pGun$38473[ebp], eax

; 285  : 		else

	jmp	SHORT $L38476
$L38474:

; 287  : 			pGun = DropItem( "weapon_9mmAR", vecGunPos, vecGunAngles );

	lea	ecx, DWORD PTR _vecGunAngles$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecGunPos$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0N@JNOE@weapon_9mmAR?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropItem@CBaseMonster@@QAEPAVCBaseEntity@@PADABVVector@@1@Z ; CBaseMonster::DropItem
	mov	DWORD PTR _pGun$38473[ebp], eax
$L38476:

; 289  : 		if ( pGun )

	cmp	DWORD PTR _pGun$38473[ebp], 0
	je	SHORT $L38478

; 291  : 			pGun->SetLocalVelocity( Vector( RANDOM_FLOAT( -100, 100 ), RANDOM_FLOAT( -100, 100 ), RANDOM_FLOAT( 200, 300 )));

	push	1133903872				; 43960000H
	push	1128792064				; 43480000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	1120403456				; 42c80000H
	push	-1027080192				; c2c80000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	1120403456				; 42c80000H
	push	-1027080192				; c2c80000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40198[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _pGun$38473[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 292  : 			pGun->SetLocalAvelocity( Vector( 0, RANDOM_FLOAT( 200, 400 ), 0 ));

	push	0
	push	1137180672				; 43c80000H
	push	1128792064				; 43480000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	0
	lea	ecx, DWORD PTR $T40199[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _pGun$38473[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity
$L38478:

; 294  : 	
; 295  : 		if( HasWeapon( HGRUNT_GRENADELAUNCHER ))

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	$L38483

; 297  : 			pGun = DropItem( "ammo_ARgrenades", vecGunPos, vecGunAngles );

	lea	eax, DWORD PTR _vecGunAngles$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecGunPos$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BA@OEBJ@ammo_ARgrenades?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropItem@CBaseMonster@@QAEPAVCBaseEntity@@PADABVVector@@1@Z ; CBaseMonster::DropItem
	mov	DWORD PTR _pGun$38473[ebp], eax

; 298  : 			if ( pGun )

	cmp	DWORD PTR _pGun$38473[ebp], 0
	je	SHORT $L38483

; 300  : 				pGun->SetLocalVelocity( Vector( RANDOM_FLOAT( -100, 100 ), RANDOM_FLOAT( -100, 100 ), RANDOM_FLOAT( 200, 300 )));

	push	1133903872				; 43960000H
	push	1128792064				; 43480000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	1120403456				; 42c80000H
	push	-1027080192				; c2c80000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	1120403456				; 42c80000H
	push	-1027080192				; c2c80000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40200[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _pGun$38473[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 301  : 				pGun->SetLocalAvelocity( Vector( 0, RANDOM_FLOAT( 200, 400 ), 0 ));

	push	0
	push	1137180672				; 43c80000H
	push	1128792064				; 43480000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	0
	lea	ecx, DWORD PTR $T40201[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _pGun$38473[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity
$L38483:

; 305  : 
; 306  : 	CBaseMonster :: GibMonster();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GibMonster@CBaseMonster@@UAEXXZ	; CBaseMonster::GibMonster

; 307  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GibMonster@CHGrunt@@UAEXXZ ENDP			; CHGrunt::GibMonster
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ?HasWeapon@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_weaponnum$ = 8
?HasWeapon@CBaseMonster@@QAEHH@Z PROC NEAR		; CBaseMonster::HasWeapon, COMDAT

; 142  : 	BOOL		HasWeapon( int weaponnum ) { return FBitSet( m_iWeapons[weaponnum >> 3], BIT( weaponnum & 7 )); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _weaponnum$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+eax+2348]
	mov	eax, edx
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	and	eax, edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasWeapon@CBaseMonster@@QAEHH@Z ENDP			; CBaseMonster::HasWeapon
_TEXT	ENDS
PUBLIC	?ISoundMask@CHGrunt@@UAEHXZ			; CHGrunt::ISoundMask
;	COMDAT ?ISoundMask@CHGrunt@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ISoundMask@CHGrunt@@UAEHXZ PROC NEAR			; CHGrunt::ISoundMask, COMDAT

; 315  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 	return	bits_SOUND_WORLD	|
; 317  : 			bits_SOUND_COMBAT	|
; 318  : 			bits_SOUND_PLAYER	|
; 319  : 			bits_SOUND_DANGER;

	mov	eax, 39					; 00000027H

; 320  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ISoundMask@CHGrunt@@UAEHXZ ENDP			; CHGrunt::ISoundMask
_TEXT	ENDS
EXTRN	?g_talkWaitTime@CTalkMonster@@2MA:DWORD		; CTalkMonster::g_talkWaitTime
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
;	COMDAT ?FOkToSpeak@CHGrunt@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FOkToSpeak@CHGrunt@@QAEHXZ PROC NEAR			; CHGrunt::FOkToSpeak, COMDAT

; 326  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 327  : // if someone else is talking, don't speak
; 328  : 	if (gpGlobals->time <= CTalkMonster::g_talkWaitTime)

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR ?g_talkWaitTime@CTalkMonster@@2MA ; CTalkMonster::g_talkWaitTime
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38494

; 329  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L38493
$L38494:

; 330  : 
; 331  : 	if ( pev->spawnflags & SF_MONSTER_GAG )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 2
	test	eax, eax
	je	SHORT $L38496

; 333  : 		if ( m_MonsterState != MONSTERSTATE_COMBAT )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2080], 2
	je	SHORT $L38496

; 335  : 			// no talking outside of combat if gagged.
; 336  : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L38493
$L38496:

; 339  : 
; 340  : 	// if player is not in pvs, don't speak
; 341  : //	if (FNullEnt(FIND_CLIENT_IN_PVS(edict())))
; 342  : //		return FALSE;
; 343  : 	
; 344  : 	return TRUE;

	mov	eax, 1
$L38493:

; 345  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FOkToSpeak@CHGrunt@@QAEHXZ ENDP			; CHGrunt::FOkToSpeak
_TEXT	ENDS
;	COMDAT ?JustSpoke@CHGrunt@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?JustSpoke@CHGrunt@@QAEXXZ PROC NEAR			; CHGrunt::JustSpoke, COMDAT

; 350  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 351  : 	CTalkMonster::g_talkWaitTime = gpGlobals->time + RANDOM_FLOAT(1.5, 2.0);

	push	1073741824				; 40000000H
	push	1069547520				; 3fc00000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR ?g_talkWaitTime@CTalkMonster@@2MA ; CTalkMonster::g_talkWaitTime

; 352  : 	m_iSentence = HGRUNT_SENT_NONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2504], -1

; 353  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?JustSpoke@CHGrunt@@QAEXXZ ENDP				; CHGrunt::JustSpoke
_TEXT	ENDS
PUBLIC	?HasConditions@CBaseMonster@@QAEHH@Z		; CBaseMonster::HasConditions
PUBLIC	__real@4@4001a000000000000000
PUBLIC	?PrescheduleThink@CHGrunt@@UAEXXZ		; CHGrunt::PrescheduleThink
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ	; CSquadMonster::MySquadLeader
PUBLIC	?InSquad@CSquadMonster@@QAEHXZ			; CSquadMonster::InSquad
;	COMDAT __real@4@4001a000000000000000
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
__real@4@4001a000000000000000 DD 040a00000r	; 5
CONST	ENDS
;	COMDAT ?PrescheduleThink@CHGrunt@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PrescheduleThink@CHGrunt@@UAEXXZ PROC NEAR		; CHGrunt::PrescheduleThink, COMDAT

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 361  : 	if ( InSquad() && m_hEnemy != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	je	SHORT $L38508
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L38508

; 363  : 		if ( HasConditions ( bits_COND_SEE_ENEMY ) )

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L38506

; 365  : 			// update the squad's last enemy sighting time.
; 366  : 			MySquadLeader()->m_flLastEnemySightTime = gpGlobals->time;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+2440], edx

; 368  : 		else

	jmp	SHORT $L38508
$L38506:

; 370  : 			if ( gpGlobals->time - MySquadLeader()->m_flLastEnemySightTime > 5 )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [eax+2440]
	fcomp	DWORD PTR __real@4@4001a000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38508

; 372  : 				// been a while since we've seen the enemy
; 373  : 				MySquadLeader()->m_fEnemyEluded = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	DWORD PTR [eax+2444], 1
$L38508:

; 377  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrescheduleThink@CHGrunt@@UAEXXZ ENDP			; CHGrunt::PrescheduleThink
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34284

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34284

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34282
$L34284:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34282:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT
_iConditions$ = 8
_this$ = -4
?HasConditions@CBaseMonster@@QAEHH@Z PROC NEAR		; CBaseMonster::HasConditions, COMDAT

; 258  : 		inline BOOL HasConditions( int iConditions ) { if ( m_afConditions & iConditions ) return TRUE; return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1956]
	and	ecx, DWORD PTR _iConditions$[ebp]
	test	ecx, ecx
	je	SHORT $L36130
	mov	eax, 1
	jmp	SHORT $L36129
$L36130:
	xor	eax, eax
$L36129:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasConditions@CBaseMonster@@QAEHH@Z ENDP		; CBaseMonster::HasConditions
_TEXT	ENDS
PUBLIC	??BEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator CBaseEntity *
;	COMDAT ?MySquadLeader@CSquadMonster@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
_pSquadLeader$ = -8
?MySquadLeader@CSquadMonster@@QAEPAV1@XZ PROC NEAR	; CSquadMonster::MySquadLeader, COMDAT

; 80   : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		CSquadMonster *pSquadLeader = (CSquadMonster *)((CBaseEntity *)m_hSquadLeader); 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2396				; 0000095cH
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pSquadLeader$[ebp], eax

; 82   : 		if (pSquadLeader != NULL)

	cmp	DWORD PTR _pSquadLeader$[ebp], 0
	je	SHORT $L36697

; 83   : 			return pSquadLeader;

	mov	eax, DWORD PTR _pSquadLeader$[ebp]
	jmp	SHORT $L36693
$L36697:

; 84   : 		return this;

	mov	eax, DWORD PTR _this$[ebp]
$L36693:

; 85   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ENDP		; CSquadMonster::MySquadLeader
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator CBaseEntity *, COMDAT

; 64   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator CBaseEntity *
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28300

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28299
$L28300:

; 104  : 	return NULL;

	xor	eax, eax
$L28299:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?InSquad@CSquadMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?InSquad@CSquadMonster@@QAEHXZ PROC NEAR		; CSquadMonster::InSquad, COMDAT

; 93   : 	int InSquad ( void ) { return m_hSquadLeader != NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2396				; 0000095cH
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InSquad@CSquadMonster@@QAEHXZ ENDP			; CSquadMonster::InSquad
_TEXT	ENDS
PUBLIC	?FCanCheckAttacks@CHGrunt@@UAEHXZ		; CHGrunt::FCanCheckAttacks
;	COMDAT ?FCanCheckAttacks@CHGrunt@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FCanCheckAttacks@CHGrunt@@UAEHXZ PROC NEAR		; CHGrunt::FCanCheckAttacks, COMDAT

; 392  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 393  : 	if ( !HasConditions( bits_COND_ENEMY_TOOFAR ) )

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	jne	SHORT $L38513

; 395  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L38514
$L38513:

; 399  : 		return FALSE;

	xor	eax, eax
$L38514:

; 401  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FCanCheckAttacks@CHGrunt@@UAEHXZ ENDP			; CHGrunt::FCanCheckAttacks
_TEXT	ENDS
PUBLIC	__real@4@40058000000000000000
PUBLIC	__real@8@3ffeb333333333333000
PUBLIC	?CheckMeleeAttack1@CHGrunt@@UAEHMM@Z		; CHGrunt::CheckMeleeAttack1
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
;	COMDAT __real@4@40058000000000000000
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
__real@4@40058000000000000000 DD 042800000r	; 64
CONST	ENDS
;	COMDAT __real@8@3ffeb333333333333000
CONST	SEGMENT
__real@8@3ffeb333333333333000 DQ 03fe6666666666666r ; 0.7
CONST	ENDS
;	COMDAT ?CheckMeleeAttack1@CHGrunt@@UAEHMM@Z
_TEXT	SEGMENT
_flDot$ = 8
_flDist$ = 12
_this$ = -4
_pEnemy$ = -8
?CheckMeleeAttack1@CHGrunt@@UAEHMM@Z PROC NEAR		; CHGrunt::CheckMeleeAttack1, COMDAT

; 408  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	CBaseMonster *pEnemy;
; 410  : 
; 411  : 	if ( m_hEnemy != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L38522

; 413  : 		pEnemy = m_hEnemy->MyMonsterPointer();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -12+[ebp], eax
	mov	eax, DWORD PTR -12+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -12+[ebp]
	call	DWORD PTR [edx+124]
	mov	DWORD PTR _pEnemy$[ebp], eax

; 414  : 
; 415  : 		if ( !pEnemy )

	cmp	DWORD PTR _pEnemy$[ebp], 0
	jne	SHORT $L38522

; 417  : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L38519
$L38522:

; 422  : 		 pEnemy->Classify() != CLASS_ALIEN_BIOWEAPON &&
; 423  : 		 pEnemy->Classify() != CLASS_PLAYER_BIOWEAPON )

	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR __real@4@40058000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38523
	fld	DWORD PTR _flDot$[ebp]
	fcomp	QWORD PTR __real@8@3ffeb333333333333000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L38523
	mov	eax, DWORD PTR _pEnemy$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEnemy$[ebp]
	call	DWORD PTR [edx+68]
	cmp	eax, 13					; 0000000dH
	je	SHORT $L38523
	mov	eax, DWORD PTR _pEnemy$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEnemy$[ebp]
	call	DWORD PTR [edx+68]
	cmp	eax, 12					; 0000000cH
	je	SHORT $L38523

; 425  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L38519
$L38523:

; 427  : 	return FALSE;

	xor	eax, eax
$L38519:

; 428  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CheckMeleeAttack1@CHGrunt@@UAEHMM@Z ENDP		; CHGrunt::CheckMeleeAttack1
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator->, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	__real@4@400a8000000000000000
PUBLIC	__real@8@3ffe8000000000000000
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	?CheckRangeAttack1@CHGrunt@@UAEHMM@Z		; CHGrunt::CheckRangeAttack1
PUBLIC	??0gametrace_s@@QAE@XZ				; gametrace_s::gametrace_s
EXTRN	?NoFriendlyFire@CSquadMonster@@QAEHXZ:NEAR	; CSquadMonster::NoFriendlyFire
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
;	COMDAT __real@4@400a8000000000000000
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
__real@4@400a8000000000000000 DD 045000000r	; 2048
CONST	ENDS
;	COMDAT __real@8@3ffe8000000000000000
CONST	SEGMENT
__real@8@3ffe8000000000000000 DQ 03fe0000000000000r ; 0.5
CONST	ENDS
;	COMDAT __real@8@3fff8000000000000000
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT ?CheckRangeAttack1@CHGrunt@@UAEHMM@Z
_TEXT	SEGMENT
$T40244 = -84
$T40245 = -96
_flDot$ = 8
_flDist$ = 12
_this$ = -4
_tr$38530 = -60
_vecSrc$38532 = -72
?CheckRangeAttack1@CHGrunt@@UAEHMM@Z PROC NEAR		; CHGrunt::CheckRangeAttack1, COMDAT

; 439  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 440  : 	if ( !HasConditions( bits_COND_ENEMY_OCCLUDED ) && flDist <= 2048 && flDot >= 0.5 && NoFriendlyFire() )

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	jne	$L38535
	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR __real@4@400a8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L38535
	fld	DWORD PTR _flDot$[ebp]
	fcomp	QWORD PTR __real@8@3ffe8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	$L38535
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NoFriendlyFire@CSquadMonster@@QAEHXZ	; CSquadMonster::NoFriendlyFire
	test	eax, eax
	je	$L38535

; 442  : 		TraceResult	tr;

	lea	ecx, DWORD PTR _tr$38530[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 443  : 
; 444  : 		if ( !m_hEnemy->IsPlayer() && flDist <= 64 )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -100+[ebp], eax
	mov	eax, DWORD PTR -100+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -100+[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L38531
	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR __real@4@40058000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38531

; 446  : 			// kick nonclients, but don't shoot at them.
; 447  : 			return FALSE;

	xor	eax, eax
	jmp	$L38528
$L38531:

; 449  : 
; 450  : 		Vector vecSrc = GetGunPosition();

	lea	eax, DWORD PTR $T40244[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+588]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$38532[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 451  : 
; 452  : 		// verify that a bullet fired from the gun will hit the enemy before the world.
; 453  : 		UTIL_TraceLine( vecSrc, m_hEnemy->BodyTarget(vecSrc), ignore_monsters, ignore_glass, ENT(pev), &tr);

	lea	eax, DWORD PTR _tr$38530[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	push	1
	lea	eax, DWORD PTR _vecSrc$38532[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40245[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -104+[ebp], eax
	mov	edx, DWORD PTR -104+[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR -104+[ebp]
	call	DWORD PTR [eax+316]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$38532[ebp]
	push	ecx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 24					; 00000018H

; 454  : 
; 455  : 		if ( tr.flFraction == 1.0 )

	fld	DWORD PTR _tr$38530[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38535

; 457  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L38528
$L38535:

; 460  : 
; 461  : 	return FALSE;

	xor	eax, eax
$L38528:

; 462  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CheckRangeAttack1@CHGrunt@@UAEHMM@Z ENDP		; CHGrunt::CheckRangeAttack1
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0gametrace_s@@QAE@XZ PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0gametrace_s@@QAE@XZ ENDP				; gametrace_s::gametrace_s
_TEXT	ENDS
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	?Length2D@Vector@@QBEMXZ			; Vector::Length2D
PUBLIC	__real@4@00000000000000000000
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	__real@4@40078000000000000000
PUBLIC	__real@8@3ffd9999999999999800
PUBLIC	??D@YA?AVVector@@MABV0@@Z			; operator*
PUBLIC	?CheckRangeAttack2@CHGrunt@@UAEHMM@Z		; CHGrunt::CheckRangeAttack2
EXTRN	?gSkillData@@3Uskilldata_t@@A:BYTE		; gSkillData
EXTRN	?VecCheckToss@@YA?AVVector@@PAUentvars_s@@ABV1@V1@M@Z:NEAR ; VecCheckToss
EXTRN	?VecCheckThrow@@YA?AVVector@@PAUentvars_s@@ABV1@V1@MM@Z:NEAR ; VecCheckThrow
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	?SquadMemberInRange@CSquadMonster@@QAEHABVVector@@M@Z:NEAR ; CSquadMonster::SquadMemberInRange
;	COMDAT __real@4@00000000000000000000
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT __real@4@3fff8000000000000000
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT __real@4@40078000000000000000
CONST	SEGMENT
__real@4@40078000000000000000 DD 043800000r	; 256
CONST	ENDS
;	COMDAT __real@8@3ffd9999999999999800
CONST	SEGMENT
__real@8@3ffd9999999999999800 DQ 03fd3333333333333r ; 0.3
CONST	ENDS
;	COMDAT ?CheckRangeAttack2@CHGrunt@@UAEHMM@Z
_TEXT	SEGMENT
$T40258 = -52
$T40259 = -64
$T40260 = -76
$T40261 = -88
$T40262 = -100
$T40263 = -112
$T40264 = -124
$T40265 = -136
$T40267 = -152
$T40268 = -164
$T40270 = -180
$T40271 = -192
_this$ = -4
_vecTarget$ = -16
_vecToss$38565 = -28
_vecToss$38572 = -40
?CheckRangeAttack2@CHGrunt@@UAEHMM@Z PROC NEAR		; CHGrunt::CheckRangeAttack2, COMDAT

; 469  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 470  : 	if( !HasWeapon( HGRUNT_HANDGRENADE ) && !HasWeapon( HGRUNT_GRENADELAUNCHER ))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	jne	SHORT $L38543
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	jne	SHORT $L38543

; 472  : 		return FALSE;

	xor	eax, eax
	jmp	$L38542
$L38543:

; 474  : 	
; 475  : 	// if the grunt isn't moving, it's ok to check.
; 476  : 	if ( m_flGroundSpeed != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1796]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38544

; 478  : 		m_fThrowGrenade = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2476], 0

; 479  : 		return m_fThrowGrenade;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2476]
	jmp	$L38542
$L38544:

; 481  : 
; 482  : 	// assume things haven't changed too much since last time
; 483  : 	if (gpGlobals->time < m_flNextGrenadeCheck )

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx+2452]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38545

; 485  : 		return m_fThrowGrenade;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2476]
	jmp	$L38542
$L38545:

; 487  : 
; 488  : 	if ( !FBitSet ( m_hEnemy->pev->flags, FL_ONGROUND ) && m_hEnemy->pev->waterlevel == 0 && m_vecEnemyLKP.z > pev->absmax.z  )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 512				; 00000200H
	test	ecx, ecx
	jne	SHORT $L38546
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	edx, DWORD PTR [eax+4]
	cmp	DWORD PTR [edx+448], 0
	jne	SHORT $L38546
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+2296]
	fcomp	DWORD PTR [ecx+216]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38546

; 490  : 		//!!!BUGBUG - we should make this check movetype and make sure it isn't FLY? Players who jump a lot are unlikely to 
; 491  : 		// be grenaded.
; 492  : 		// don't throw grenades at anything that isn't on the ground!
; 493  : 		m_fThrowGrenade = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2476], 0

; 494  : 		return m_fThrowGrenade;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+2476]
	jmp	$L38542
$L38546:

; 496  : 	
; 497  : 	Vector vecTarget;

	lea	ecx, DWORD PTR _vecTarget$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 498  : 
; 499  : 	if( HasWeapon( HGRUNT_HANDGRENADE ))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	$L38548

; 501  : 		// find feet
; 502  : 		if (RANDOM_LONG(0,1))

	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	je	SHORT $L38549

; 504  : 			// magically know where they are
; 505  : 			vecTarget = Vector( m_hEnemy->GetAbsOrigin().x, m_hEnemy->GetAbsOrigin().y, m_hEnemy->pev->absmin.z );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+204]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	ecx, DWORD PTR $T40258[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecTarget$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecTarget$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecTarget$[ebp+8], eax

; 507  : 		else

	jmp	SHORT $L38551
$L38549:

; 509  : 			// toss it to where you last saw them
; 510  : 			vecTarget = m_vecEnemyLKP;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _vecTarget$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _vecTarget$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _vecTarget$[ebp+8], ecx
$L38551:

; 516  : 	else

	jmp	$L38556
$L38548:

; 518  : 		// find target
; 519  : 		// vecTarget = m_hEnemy->BodyTarget( GetAbsOrigin() );
; 520  : 		vecTarget = m_vecEnemyLKP + (m_hEnemy->BodyTarget( GetAbsOrigin() ) - m_hEnemy->GetAbsOrigin());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T40260[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T40259[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -196+[ebp], eax
	mov	ecx, DWORD PTR -196+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -196+[ebp]
	call	DWORD PTR [edx+316]
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	eax, DWORD PTR $T40261[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecTarget$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecTarget$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecTarget$[ebp+8], eax

; 521  : 		// estimate position
; 522  : 		if (HasConditions( bits_COND_SEE_ENEMY))

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L38556

; 523  : 			vecTarget = vecTarget + ((vecTarget - GetAbsOrigin()).Length() / gSkillData.hgruntGrenadeSpeed) * m_hEnemy->GetAbsVelocity();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T40262[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecTarget$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fdiv	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+92
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR $T40263[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T40264[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecTarget$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecTarget$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecTarget$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecTarget$[ebp+8], eax
$L38556:

; 525  : 
; 526  : 	// are any of my squad members near the intended grenade impact area?
; 527  : 	if ( InSquad() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	je	SHORT $L38561

; 529  : 		if (SquadMemberInRange( vecTarget, 256 ))

	push	1132462080				; 43800000H
	lea	ecx, DWORD PTR _vecTarget$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SquadMemberInRange@CSquadMonster@@QAEHABVVector@@M@Z ; CSquadMonster::SquadMemberInRange
	test	eax, eax
	je	SHORT $L38561

; 531  : 			// crap, I might blow my own guy up. Don't throw a grenade and don't check again for a while.
; 532  : 			m_flNextGrenadeCheck = gpGlobals->time + 1; // one full second.

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+2452]

; 533  : 			m_fThrowGrenade = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2476], 0
$L38561:

; 536  : 	
; 537  : 	if ( ( vecTarget - GetAbsOrigin() ).Length2D() <= 256 )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T40265[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecTarget$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length2D@Vector@@QBEMXZ		; Vector::Length2D
	fcomp	DWORD PTR __real@4@40078000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38563

; 539  : 		// crap, I don't want to blow myself up
; 540  : 		m_flNextGrenadeCheck = gpGlobals->time + 1; // one full second.

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2452]

; 541  : 		m_fThrowGrenade = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2476], 0

; 542  : 		return m_fThrowGrenade;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+2476]
	jmp	$L38542
$L38563:

; 544  : 
; 545  : 		
; 546  : 	if( HasWeapon( HGRUNT_HANDGRENADE ))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	$L38564

; 548  : 		Vector vecToss = VecCheckToss( pev, GetGunPosition(), vecTarget, 0.5 );

	push	1056964608				; 3f000000H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecTarget$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	eax, DWORD PTR $T40267[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+588]
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T40268[ebp]
	push	edx
	call	?VecCheckToss@@YA?AVVector@@PAUentvars_s@@ABV1@V1@M@Z ; VecCheckToss
	add	esp, 28					; 0000001cH
	push	eax
	lea	ecx, DWORD PTR _vecToss$38565[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 549  : 
; 550  : 		if ( vecToss != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR _vecToss$38565[ebp]
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L38569

; 552  : 			m_vecTossVelocity = vecToss;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2464				; 000009a0H
	mov	ecx, DWORD PTR _vecToss$38565[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecToss$38565[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecToss$38565[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 553  : 
; 554  : 			// throw a hand grenade
; 555  : 			m_fThrowGrenade = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2476], 1

; 556  : 			// don't check again for a while.
; 557  : 			m_flNextGrenadeCheck = gpGlobals->time; // 1/3 second.

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+2452], edx

; 559  : 		else

	jmp	SHORT $L38570
$L38569:

; 561  : 			// don't throw
; 562  : 			m_fThrowGrenade = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2476], 0

; 563  : 			// don't check again for a while.
; 564  : 			m_flNextGrenadeCheck = gpGlobals->time + 1; // one full second.

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+2452]
$L38570:

; 567  : 	else

	jmp	$L38577
$L38564:

; 569  : 		Vector vecToss = VecCheckThrow( pev, GetGunPosition(), vecTarget, gSkillData.hgruntGrenadeSpeed, 0.5 );

	push	1056964608				; 3f000000H
	mov	eax, DWORD PTR ?gSkillData@@3Uskilldata_t@@A+92
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecTarget$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	eax, DWORD PTR $T40270[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+588]
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T40271[ebp]
	push	edx
	call	?VecCheckThrow@@YA?AVVector@@PAUentvars_s@@ABV1@V1@MM@Z ; VecCheckThrow
	add	esp, 32					; 00000020H
	push	eax
	lea	ecx, DWORD PTR _vecToss$38572[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 570  : 
; 571  : 		if ( vecToss != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR _vecToss$38572[ebp]
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L38576

; 573  : 			m_vecTossVelocity = vecToss;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2464				; 000009a0H
	mov	ecx, DWORD PTR _vecToss$38572[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecToss$38572[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecToss$38572[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 574  : 
; 575  : 			// throw a hand grenade
; 576  : 			m_fThrowGrenade = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2476], 1

; 577  : 			// don't check again for a while.
; 578  : 			m_flNextGrenadeCheck = gpGlobals->time + 0.3; // 1/3 second.

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffd9999999999999800
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2452]

; 580  : 		else

	jmp	SHORT $L38577
$L38576:

; 582  : 			// don't throw
; 583  : 			m_fThrowGrenade = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2476], 0

; 584  : 			// don't check again for a while.
; 585  : 			m_flNextGrenadeCheck = gpGlobals->time + 1; // one full second.

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2452]
$L38577:

; 588  : 
; 589  : 	
; 590  : 
; 591  : 	return m_fThrowGrenade;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2476]
$L38542:

; 592  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CheckRangeAttack2@CHGrunt@@UAEHMM@Z ENDP		; CHGrunt::CheckRangeAttack2
_TEXT	ENDS
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40284
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40284
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40284
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40285
$L40284:
	mov	DWORD PTR -8+[ebp], 0
$L40285:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40288 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40288[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40291 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40291[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
EXTRN	_sqrt:NEAR
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length2D@Vector@@QBEMXZ PROC NEAR			; Vector::Length2D, COMDAT

; 282  : 	inline float Length2D(void) const { return sqrt(x*x + y*y); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length2D@Vector@@QBEMXZ ENDP				; Vector::Length2D
_TEXT	ENDS
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT
_fl$ = 12
_v$ = 16
___$ReturnUdt$ = 8
$T40298 = -12
??D@YA?AVVector@@MABV0@@Z PROC NEAR			; operator*, COMDAT

; 288  : inline Vector operator* ( float fl, const Vector& v ) { return v * fl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40298[ebp]
	push	ecx
	mov	ecx, DWORD PTR _v$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??D@YA?AVVector@@MABV0@@Z ENDP				; operator*
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40301 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40301[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
PUBLIC	__real@4@4003a000000000000000
PUBLIC	?TraceAttack@CHGrunt@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z ; CHGrunt::TraceAttack
EXTRN	?UTIL_Ricochet@@YAXABVVector@@M@Z:NEAR		; UTIL_Ricochet
EXTRN	?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseMonster::TraceAttack
;	COMDAT __real@4@4003a000000000000000
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
__real@4@4003a000000000000000 DD 041a00000r	; 20
CONST	ENDS
;	COMDAT ?TraceAttack@CHGrunt@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
_TEXT	SEGMENT
_pevAttacker$ = 8
_flDamage$ = 12
_vecDir$ = 16
_ptr$ = 28
_bitsDamageType$ = 32
_this$ = -4
?TraceAttack@CHGrunt@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z PROC NEAR ; CHGrunt::TraceAttack, COMDAT

; 599  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 600  : 	// check for helmet shot
; 601  : 	if (ptr->iHitgroup == 11)

	mov	eax, DWORD PTR _ptr$[ebp]
	cmp	DWORD PTR [eax+52], 11			; 0000000bH
	jne	SHORT $L38586

; 603  : 		// make sure we're wearing one
; 604  : 		if (GetBodygroup( 1 ) == HEAD_GRUNT && (bitsDamageType & (DMG_BULLET | DMG_SLASH | DMG_BLAST | DMG_CLUB)))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBodygroup@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::GetBodygroup
	test	eax, eax
	jne	SHORT $L38588
	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	and	ecx, 198				; 000000c6H
	test	ecx, ecx
	je	SHORT $L38588

; 606  : 			// absorb damage
; 607  : 			flDamage -= 20;

	fld	DWORD PTR _flDamage$[ebp]
	fsub	DWORD PTR __real@4@4003a000000000000000
	fstp	DWORD PTR _flDamage$[ebp]

; 608  : 			if (flDamage <= 0)

	fld	DWORD PTR _flDamage$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38588

; 610  : 				UTIL_Ricochet( ptr->vecEndPos, 1.0 );

	push	1065353216				; 3f800000H
	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	?UTIL_Ricochet@@YAXABVVector@@M@Z	; UTIL_Ricochet
	add	esp, 8

; 611  : 				flDamage = 0.01;

	mov	DWORD PTR _flDamage$[ebp], 1008981770	; 3c23d70aH
$L38588:

; 614  : 		// it's head shot anyways
; 615  : 		ptr->iHitgroup = HITGROUP_HEAD;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax+52], 1
$L38586:

; 617  : 	CSquadMonster::TraceAttack( pevAttacker, flDamage, vecDir, ptr, bitsDamageType );

	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecDir$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _flDamage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pevAttacker$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z ; CBaseMonster::TraceAttack

; 618  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?TraceAttack@CHGrunt@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z ENDP ; CHGrunt::TraceAttack
_TEXT	ENDS
PUBLIC	?Forget@CBaseMonster@@QAEXH@Z			; CBaseMonster::Forget
PUBLIC	?TakeDamage@CHGrunt@@UAEHPAUentvars_s@@0MH@Z	; CHGrunt::TakeDamage
EXTRN	?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseMonster::TakeDamage
;	COMDAT ?TakeDamage@CHGrunt@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT
_pevInflictor$ = 8
_pevAttacker$ = 12
_flDamage$ = 16
_bitsDamageType$ = 20
_this$ = -4
?TakeDamage@CHGrunt@@UAEHPAUentvars_s@@0MH@Z PROC NEAR	; CHGrunt::TakeDamage, COMDAT

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 	Forget( bits_MEMORY_INCOVER );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Forget@CBaseMonster@@QAEXH@Z		; CBaseMonster::Forget

; 629  : 
; 630  : 	return CSquadMonster :: TakeDamage ( pevInflictor, pevAttacker, flDamage, bitsDamageType );

	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flDamage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pevAttacker$[ebp]
	push	edx
	mov	eax, DWORD PTR _pevInflictor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z ; CBaseMonster::TakeDamage

; 631  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TakeDamage@CHGrunt@@UAEHPAUentvars_s@@0MH@Z ENDP	; CHGrunt::TakeDamage
_TEXT	ENDS
;	COMDAT ?Forget@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_iMemory$ = 8
_this$ = -4
?Forget@CBaseMonster@@QAEXH@Z PROC NEAR			; CBaseMonster::Forget, COMDAT

; 342  : 	inline void	Forget( int iMemory ) { m_afMemory &= ~iMemory; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _iMemory$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2280]
	and	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2280], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Forget@CBaseMonster@@QAEXH@Z ENDP			; CBaseMonster::Forget
_TEXT	ENDS
PUBLIC	?SetYawSpeed@CHGrunt@@UAEXXZ			; CHGrunt::SetYawSpeed
;	COMDAT ?SetYawSpeed@CHGrunt@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_ys$ = -8
?SetYawSpeed@CHGrunt@@UAEXXZ PROC NEAR			; CHGrunt::SetYawSpeed, COMDAT

; 638  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 	{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2068]
	mov	DWORD PTR -12+[ebp], ecx
	mov	edx, DWORD PTR -12+[ebp]
	sub	edx, 1
	mov	DWORD PTR -12+[ebp], edx
	cmp	DWORD PTR -12+[ebp], 50			; 00000032H
	ja	SHORT $L38615
	mov	ecx, DWORD PTR -12+[ebp]
	xor	eax, eax
	mov	al, BYTE PTR $L40313[ecx]
	jmp	DWORD PTR $L40314[eax*4]
$L38606:

; 643  : 	case ACT_IDLE:	
; 644  : 		ys = 150;		

	mov	DWORD PTR _ys$[ebp], 150		; 00000096H

; 645  : 		break;

	jmp	SHORT $L38603
$L38607:

; 646  : 	case ACT_RUN:	
; 647  : 		ys = 150;	

	mov	DWORD PTR _ys$[ebp], 150		; 00000096H

; 648  : 		break;

	jmp	SHORT $L38603
$L38608:

; 649  : 	case ACT_WALK:	
; 650  : 		ys = 180;		

	mov	DWORD PTR _ys$[ebp], 180		; 000000b4H

; 651  : 		break;

	jmp	SHORT $L38603
$L38609:

; 652  : 	case ACT_RANGE_ATTACK1:	
; 653  : 		ys = 120;	

	mov	DWORD PTR _ys$[ebp], 120		; 00000078H

; 654  : 		break;

	jmp	SHORT $L38603
$L38610:

; 655  : 	case ACT_RANGE_ATTACK2:	
; 656  : 		ys = 120;	

	mov	DWORD PTR _ys$[ebp], 120		; 00000078H

; 657  : 		break;

	jmp	SHORT $L38603
$L38611:

; 658  : 	case ACT_MELEE_ATTACK1:	
; 659  : 		ys = 120;	

	mov	DWORD PTR _ys$[ebp], 120		; 00000078H

; 660  : 		break;

	jmp	SHORT $L38603
$L38612:

; 661  : 	case ACT_MELEE_ATTACK2:	
; 662  : 		ys = 120;	

	mov	DWORD PTR _ys$[ebp], 120		; 00000078H

; 663  : 		break;

	jmp	SHORT $L38603
$L38613:

; 664  : 	case ACT_TURN_LEFT:
; 665  : 	case ACT_TURN_RIGHT:	
; 666  : 		ys = 180;

	mov	DWORD PTR _ys$[ebp], 180		; 000000b4H

; 667  : 		break;

	jmp	SHORT $L38603
$L38614:

; 668  : 	case ACT_GLIDE:
; 669  : 	case ACT_FLY:
; 670  : 		ys = 30;

	mov	DWORD PTR _ys$[ebp], 30			; 0000001eH

; 671  : 		break;

	jmp	SHORT $L38603
$L38615:

; 672  : 	default:
; 673  : 		ys = 90;

	mov	DWORD PTR _ys$[ebp], 90			; 0000005aH
$L38603:

; 676  : 
; 677  : 	pev->yaw_speed = ys;

	fild	DWORD PTR _ys$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+176]

; 678  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L40314:
	DD	$L38606
	DD	$L38608
	DD	$L38607
	DD	$L38614
	DD	$L38613
	DD	$L38609
	DD	$L38610
	DD	$L38611
	DD	$L38612
	DD	$L38615
$L40313:
	DB	0
	DB	9
	DB	1
	DB	2
	DB	3
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	4
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
?SetYawSpeed@CHGrunt@@UAEXXZ ENDP			; CHGrunt::SetYawSpeed
_TEXT	ENDS
PUBLIC	?IdleSound@CHGrunt@@UAEXXZ			; CHGrunt::IdleSound
PUBLIC	??_C@_08MGGI@HG_CHECK?$AA@			; `string'
PUBLIC	??_C@_08IJFI@HG_QUEST?$AA@			; `string'
PUBLIC	??_C@_07ENJK@HG_IDLE?$AA@			; `string'
PUBLIC	??_C@_08CJCK@HG_CLEAR?$AA@			; `string'
PUBLIC	??_C@_09HMJB@HG_ANSWER?$AA@			; `string'
;	COMDAT ??_C@_08MGGI@HG_CHECK?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_08MGGI@HG_CHECK?$AA@ DB 'HG_CHECK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IJFI@HG_QUEST?$AA@
CONST	SEGMENT
??_C@_08IJFI@HG_QUEST?$AA@ DB 'HG_QUEST', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07ENJK@HG_IDLE?$AA@
CONST	SEGMENT
??_C@_07ENJK@HG_IDLE?$AA@ DB 'HG_IDLE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CJCK@HG_CLEAR?$AA@
CONST	SEGMENT
??_C@_08CJCK@HG_CLEAR?$AA@ DB 'HG_CLEAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HMJB@HG_ANSWER?$AA@
CONST	SEGMENT
??_C@_09HMJB@HG_ANSWER?$AA@ DB 'HG_ANSWER', 00H		; `string'
CONST	ENDS
;	COMDAT ?IdleSound@CHGrunt@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?IdleSound@CHGrunt@@UAEXXZ PROC NEAR			; CHGrunt::IdleSound, COMDAT

; 681  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 682  : 	if (FOkToSpeak() && (g_fGruntQuestion || RANDOM_LONG(0,1)))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CHGrunt@@QAEHXZ		; CHGrunt::FOkToSpeak
	test	eax, eax
	je	$L38620
	cmp	DWORD PTR ?g_fGruntQuestion@@3HA, 0	; g_fGruntQuestion
	jne	SHORT $L38621
	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	je	$L38620
$L38621:

; 684  : 		if (!g_fGruntQuestion)

	cmp	DWORD PTR ?g_fGruntQuestion@@3HA, 0	; g_fGruntQuestion
	jne	$L38622

; 688  : 			{

	push	2
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 0
	je	SHORT $L38627
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L38631
	cmp	DWORD PTR -8+[ebp], 2
	je	$L38635
	jmp	$L38624
$L38627:

; 689  : 			case 0: // check in
; 690  : 				SENTENCEG_PlayRndSz(ENT(pev), "HG_CHECK", HGRUNT_SENTENCE_VOLUME, ATTN_NORM, 0, m_voicePitch);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2492]
	push	ecx
	push	0
	push	1061997773				; 3f4ccccdH
	push	1051931443				; 3eb33333H
	push	OFFSET FLAT:??_C@_08MGGI@HG_CHECK?$AA@	; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H

; 691  : 				g_fGruntQuestion = 1;

	mov	DWORD PTR ?g_fGruntQuestion@@3HA, 1	; g_fGruntQuestion

; 692  : 				break;

	jmp	SHORT $L38624
$L38631:

; 693  : 			case 1: // question
; 694  : 				SENTENCEG_PlayRndSz(ENT(pev), "HG_QUEST", HGRUNT_SENTENCE_VOLUME, ATTN_NORM, 0, m_voicePitch);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2492]
	push	edx
	push	0
	push	1061997773				; 3f4ccccdH
	push	1051931443				; 3eb33333H
	push	OFFSET FLAT:??_C@_08IJFI@HG_QUEST?$AA@	; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H

; 695  : 				g_fGruntQuestion = 2;

	mov	DWORD PTR ?g_fGruntQuestion@@3HA, 2	; g_fGruntQuestion

; 696  : 				break;

	jmp	SHORT $L38624
$L38635:

; 697  : 			case 2: // statement
; 698  : 				SENTENCEG_PlayRndSz(ENT(pev), "HG_IDLE", HGRUNT_SENTENCE_VOLUME, ATTN_NORM, 0, m_voicePitch);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2492]
	push	eax
	push	0
	push	1061997773				; 3f4ccccdH
	push	1051931443				; 3eb33333H
	push	OFFSET FLAT:??_C@_07ENJK@HG_IDLE?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H
$L38624:

; 702  : 		else

	jmp	$L38639
$L38622:

; 705  : 			{

	mov	eax, DWORD PTR ?g_fGruntQuestion@@3HA	; g_fGruntQuestion
	mov	DWORD PTR -12+[ebp], eax
	cmp	DWORD PTR -12+[ebp], 1
	je	SHORT $L38644
	cmp	DWORD PTR -12+[ebp], 2
	je	SHORT $L38648
	jmp	SHORT $L38641
$L38644:

; 706  : 			case 1: // check in
; 707  : 				SENTENCEG_PlayRndSz(ENT(pev), "HG_CLEAR", HGRUNT_SENTENCE_VOLUME, ATTN_NORM, 0, m_voicePitch);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2492]
	push	edx
	push	0
	push	1061997773				; 3f4ccccdH
	push	1051931443				; 3eb33333H
	push	OFFSET FLAT:??_C@_08CJCK@HG_CLEAR?$AA@	; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H

; 708  : 				break;

	jmp	SHORT $L38641
$L38648:

; 709  : 			case 2: // question 
; 710  : 				SENTENCEG_PlayRndSz(ENT(pev), "HG_ANSWER", HGRUNT_SENTENCE_VOLUME, ATTN_NORM, 0, m_voicePitch);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2492]
	push	eax
	push	0
	push	1061997773				; 3f4ccccdH
	push	1051931443				; 3eb33333H
	push	OFFSET FLAT:??_C@_09HMJB@HG_ANSWER?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H
$L38641:

; 713  : 			g_fGruntQuestion = 0;

	mov	DWORD PTR ?g_fGruntQuestion@@3HA, 0	; g_fGruntQuestion
$L38639:

; 715  : 		JustSpoke();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JustSpoke@CHGrunt@@QAEXXZ		; CHGrunt::JustSpoke
$L38620:

; 717  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IdleSound@CHGrunt@@UAEXXZ ENDP				; CHGrunt::IdleSound
_TEXT	ENDS
PUBLIC	?SetConditions@CBaseMonster@@QAEXH@Z		; CBaseMonster::SetConditions
PUBLIC	?CheckAmmo@CHGrunt@@UAEXXZ			; CHGrunt::CheckAmmo
;	COMDAT ?CheckAmmo@CHGrunt@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CheckAmmo@CHGrunt@@UAEXXZ PROC NEAR			; CHGrunt::CheckAmmo, COMDAT

; 724  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 725  : 	if ( m_cAmmoLoaded <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2300], 0
	jg	SHORT $L38656

; 727  : 		SetConditions(bits_COND_NO_AMMO_LOADED);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
$L38656:

; 729  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckAmmo@CHGrunt@@UAEXXZ ENDP				; CHGrunt::CheckAmmo
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_iConditions$ = 8
_this$ = -4
?SetConditions@CBaseMonster@@QAEXH@Z PROC NEAR		; CBaseMonster::SetConditions, COMDAT

; 256  : 		inline void	SetConditions( int iConditions ) { m_afConditions |= iConditions; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1956]
	or	ecx, DWORD PTR _iConditions$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1956], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetConditions@CBaseMonster@@QAEXH@Z ENDP		; CBaseMonster::SetConditions
_TEXT	ENDS
PUBLIC	?Classify@CHGrunt@@UAEHXZ			; CHGrunt::Classify
;	COMDAT ?Classify@CHGrunt@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CHGrunt@@UAEHXZ PROC NEAR			; CHGrunt::Classify, COMDAT

; 736  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 737  : 	return m_iClass ? m_iClass : CLASS_HUMAN_MILITARY;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2388], 0
	je	SHORT $L40323
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2388]
	mov	DWORD PTR -8+[ebp], edx
	jmp	SHORT $L40324
$L40323:
	mov	DWORD PTR -8+[ebp], 4
$L40324:
	mov	eax, DWORD PTR -8+[ebp]

; 738  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CHGrunt@@UAEHXZ ENDP				; CHGrunt::Classify
_TEXT	ENDS
PUBLIC	?Kick@CHGrunt@@QAEPAVCBaseEntity@@XZ		; CHGrunt::Kick
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
EXTRN	?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceHull
EXTRN	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsAngles
EXTRN	?UTIL_MakeVectors@@YAXABVVector@@@Z:NEAR	; UTIL_MakeVectors
;	COMDAT ?Kick@CHGrunt@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
$T40327 = -100
$T40328 = -112
_this$ = -4
_tr$ = -60
_vecStart$ = -72
_vecEnd$ = -84
_pEntity$38671 = -88
?Kick@CHGrunt@@QAEPAVCBaseEntity@@XZ PROC NEAR		; CHGrunt::Kick, COMDAT

; 743  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 744  : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 745  : 
; 746  : 	UTIL_MakeVectors( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 747  : 	Vector vecStart = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 748  : 	vecStart.z += pev->size.z * 0.5;

	fld	DWORD PTR _vecStart$[ebp+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+252]
	fmul	QWORD PTR __real@8@3ffe8000000000000000
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _vecStart$[ebp+8]

; 749  : 	Vector vecEnd = vecStart + (gpGlobals->v_forward * 70);

	push	1116471296				; 428c0000H
	lea	edx, DWORD PTR $T40327[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40328[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 750  : 
; 751  : 	UTIL_TraceHull( vecStart, vecEnd, dont_ignore_monsters, head_hull, ENT(pev), &tr );

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	3
	push	0
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecStart$[ebp]
	push	edx
	call	?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceHull
	add	esp, 24					; 00000018H

; 752  : 	
; 753  : 	if ( tr.pHit )

	cmp	DWORD PTR _tr$[ebp+48], 0
	je	SHORT $L38670

; 755  : 		CBaseEntity *pEntity = CBaseEntity::Instance( tr.pHit );

	mov	eax, DWORD PTR _tr$[ebp+48]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$38671[ebp], eax

; 756  : 		return pEntity;

	mov	eax, DWORD PTR _pEntity$38671[ebp]
	jmp	SHORT $L38664
$L38670:

; 758  : 
; 759  : 	return NULL;

	xor	eax, eax
$L38664:

; 760  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Kick@CHGrunt@@QAEPAVCBaseEntity@@XZ ENDP		; CHGrunt::Kick
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35050

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35050:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
PUBLIC	?GetGunPosition@CHGrunt@@UAE?AVVector@@XZ	; CHGrunt::GetGunPosition
;	COMDAT ?GetGunPosition@CHGrunt@@UAE?AVVector@@XZ
_TEXT	SEGMENT
$T40335 = -16
$T40336 = -28
$T40337 = -40
$T40338 = -52
___$ReturnUdt$ = 8
_this$ = -4
?GetGunPosition@CHGrunt@@UAE?AVVector@@XZ PROC NEAR	; CHGrunt::GetGunPosition, COMDAT

; 766  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 767  : 	if (m_fStanding )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2480], 0
	je	SHORT $L38676

; 769  : 		return GetAbsOrigin() + Vector( 0, 0, 60 );

	push	1114636288				; 42700000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T40335[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T40336[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L38679
$L38676:

; 773  : 		return GetAbsOrigin() + Vector( 0, 0, 48 );

	push	1111490560				; 42400000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T40337[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	edx, DWORD PTR $T40338[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L38679:

; 775  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetGunPosition@CHGrunt@@UAE?AVVector@@XZ ENDP		; CHGrunt::GetGunPosition
_TEXT	ENDS
PUBLIC	?Shoot@CHGrunt@@QAEXXZ				; CHGrunt::Shoot
EXTRN	?ShootAtEnemy@CBaseMonster@@QAE?AVVector@@ABV2@@Z:NEAR ; CBaseMonster::ShootAtEnemy
EXTRN	?SetBlending@CBaseAnimating@@QAEMHM@Z:NEAR	; CBaseAnimating::SetBlending
EXTRN	?EjectBrass@@YAXABVVector@@0MHH@Z:NEAR		; EjectBrass
EXTRN	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z:NEAR	; UTIL_VecToAngles
EXTRN	?FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z:NEAR ; CBaseEntity::FireBullets
;	COMDAT ?Shoot@CHGrunt@@QAEXXZ
_TEXT	SEGMENT
$T40341 = -64
$T40342 = -76
$T40343 = -88
$T40344 = -100
$T40345 = -112
$T40346 = -124
$T40347 = -136
$T40348 = -148
$T40349 = -160
$T40351 = -176
$T40354 = -196
_this$ = -4
_vecShootOrigin$ = -16
_vecShootDir$ = -28
_vecShellVelocity$ = -40
_angDir$ = -52
?Shoot@CHGrunt@@QAEXXZ PROC NEAR			; CHGrunt::Shoot, COMDAT

; 781  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 782  : 	if (m_hEnemy == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $L38686

; 784  : 		return;

	jmp	$L38685
$L38686:

; 786  : 
; 787  : 	Vector vecShootOrigin = GetGunPosition();

	lea	eax, DWORD PTR $T40341[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+588]
	push	eax
	lea	ecx, DWORD PTR _vecShootOrigin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 788  : 	Vector vecShootDir = ShootAtEnemy( vecShootOrigin );

	lea	eax, DWORD PTR _vecShootOrigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40342[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShootAtEnemy@CBaseMonster@@QAE?AVVector@@ABV2@@Z ; CBaseMonster::ShootAtEnemy
	push	eax
	lea	ecx, DWORD PTR _vecShootDir$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 789  : 
; 790  : 	UTIL_MakeVectors ( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 791  : 
; 792  : 	Vector	vecShellVelocity = gpGlobals->v_right * RANDOM_FLOAT(40,90) + gpGlobals->v_up * RANDOM_FLOAT(75,200) + gpGlobals->v_forward * RANDOM_FLOAT(-40, 40);

	push	1109393408				; 42200000H
	push	-1038090240				; c2200000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR $T40346[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40347[ebp]
	push	eax
	push	1128792064				; 43480000H
	push	1117126656				; 42960000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40344[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 52					; 00000034H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T40345[ebp]
	push	edx
	push	1119092736				; 42b40000H
	push	1109393408				; 42200000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T40343[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecShellVelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 793  : 	EjectBrass ( vecShootOrigin - vecShootDir * 24, vecShellVelocity, GetAbsAngles().y, m_iBrassShell, TE_BOUNCE_SHELL); 

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2496]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	eax, DWORD PTR [eax+4]
	push	eax
	lea	ecx, DWORD PTR _vecShellVelocity$[ebp]
	push	ecx
	push	1103101952				; 41c00000H
	lea	edx, DWORD PTR $T40348[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecShootDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40349[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecShootOrigin$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	call	?EjectBrass@@YAXABVVector@@0MHH@Z	; EjectBrass
	add	esp, 20					; 00000014H

; 794  : 	FireBullets(1, vecShootOrigin, vecShootDir, VECTOR_CONE_10DEGREES, 2048, BULLET_MONSTER_MP5 ); // shoot +-5 degrees

	push	0
	push	0
	push	4
	push	7
	push	1157627904				; 45000000H
	push	1035108593				; 3db280f1H
	push	1035108593				; 3db280f1H
	push	1035108593				; 3db280f1H
	lea	ecx, DWORD PTR $T40351[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecShootDir$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecShootOrigin$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z ; CBaseEntity::FireBullets

; 795  : 
; 796  : 	pev->effects |= EF_MUZZLEFLASH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	al, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax

; 797  : 	
; 798  : 	m_cAmmoLoaded--;// take away a bullet!

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2300]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2300], ecx

; 799  : 
; 800  : 	Vector angDir = UTIL_VecToAngles( vecShootDir );

	lea	eax, DWORD PTR _vecShootDir$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40354[ebp]
	push	ecx
	call	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z	; UTIL_VecToAngles
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _angDir$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 801  : 	SetBlending( 0, -angDir.x );

	fld	DWORD PTR _angDir$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBlending@CBaseAnimating@@QAEMHM@Z	; CBaseAnimating::SetBlending
	fstp	ST(0)
$L38685:

; 802  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Shoot@CHGrunt@@QAEXXZ ENDP				; CHGrunt::Shoot
_TEXT	ENDS
PUBLIC	?Shotgun@CHGrunt@@QAEXXZ			; CHGrunt::Shotgun
EXTRN	__ftol:NEAR
;	COMDAT ?Shotgun@CHGrunt@@QAEXXZ
_TEXT	SEGMENT
$T40357 = -64
$T40358 = -76
$T40359 = -88
$T40360 = -100
$T40361 = -112
$T40362 = -124
$T40363 = -136
$T40364 = -148
$T40365 = -160
$T40367 = -176
$T40370 = -196
_this$ = -4
_vecShootOrigin$ = -16
_vecShootDir$ = -28
_vecShellVelocity$ = -40
_angDir$ = -52
?Shotgun@CHGrunt@@QAEXXZ PROC NEAR			; CHGrunt::Shotgun, COMDAT

; 808  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 809  : 	if (m_hEnemy == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $L38709

; 811  : 		return;

	jmp	$L38708
$L38709:

; 813  : 
; 814  : 	Vector vecShootOrigin = GetGunPosition();

	lea	eax, DWORD PTR $T40357[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+588]
	push	eax
	lea	ecx, DWORD PTR _vecShootOrigin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 815  : 	Vector vecShootDir = ShootAtEnemy( vecShootOrigin );

	lea	eax, DWORD PTR _vecShootOrigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40358[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShootAtEnemy@CBaseMonster@@QAE?AVVector@@ABV2@@Z ; CBaseMonster::ShootAtEnemy
	push	eax
	lea	ecx, DWORD PTR _vecShootDir$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 816  : 
; 817  : 	UTIL_MakeVectors ( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 818  : 
; 819  : 	Vector	vecShellVelocity = gpGlobals->v_right * RANDOM_FLOAT(40,90) + gpGlobals->v_up * RANDOM_FLOAT(75,200) + gpGlobals->v_forward * RANDOM_FLOAT(-40, 40);

	push	1109393408				; 42200000H
	push	-1038090240				; c2200000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR $T40362[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40363[ebp]
	push	eax
	push	1128792064				; 43480000H
	push	1117126656				; 42960000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40360[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 52					; 00000034H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T40361[ebp]
	push	edx
	push	1119092736				; 42b40000H
	push	1109393408				; 42200000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T40359[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecShellVelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 820  : 	EjectBrass ( vecShootOrigin - vecShootDir * 24, vecShellVelocity, GetAbsAngles().y, m_iShotgunShell, TE_BOUNCE_SHOTSHELL); 

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2500]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	eax, DWORD PTR [eax+4]
	push	eax
	lea	ecx, DWORD PTR _vecShellVelocity$[ebp]
	push	ecx
	push	1103101952				; 41c00000H
	lea	edx, DWORD PTR $T40364[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecShootDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40365[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecShootOrigin$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	call	?EjectBrass@@YAXABVVector@@0MHH@Z	; EjectBrass
	add	esp, 20					; 00000014H

; 821  : 	FireBullets(gSkillData.hgruntShotgunPellets, vecShootOrigin, vecShootDir, VECTOR_CONE_15DEGREES, 2048, BULLET_PLAYER_BUCKSHOT, 0 ); // shoot +-7.5 degrees

	push	0
	push	0
	push	0
	push	4
	push	1157627904				; 45000000H
	push	1040558504				; 3e05a9a8H
	push	1040558504				; 3e05a9a8H
	push	1040558504				; 3e05a9a8H
	lea	ecx, DWORD PTR $T40367[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecShootDir$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecShootOrigin$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	fld	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+88
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z ; CBaseEntity::FireBullets

; 822  : 
; 823  : 	pev->effects |= EF_MUZZLEFLASH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	al, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax

; 824  : 	
; 825  : 	m_cAmmoLoaded--;// take away a bullet!

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2300]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2300], ecx

; 826  : 
; 827  : 	Vector angDir = UTIL_VecToAngles( vecShootDir );

	lea	eax, DWORD PTR _vecShootDir$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40370[ebp]
	push	ecx
	call	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z	; UTIL_VecToAngles
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _angDir$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 828  : 	SetBlending( 0, -angDir.x );

	fld	DWORD PTR _angDir$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBlending@CBaseAnimating@@QAEMHM@Z	; CBaseAnimating::SetBlending
	fstp	ST(0)
$L38708:

; 829  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Shotgun@CHGrunt@@QAEXXZ ENDP				; CHGrunt::Shotgun
_TEXT	ENDS
PUBLIC	?ClearConditions@CBaseMonster@@QAEXH@Z		; CBaseMonster::ClearConditions
PUBLIC	?HandleAnimEvent@CHGrunt@@UAEXPAUMonsterEvent_t@@@Z ; CHGrunt::HandleAnimEvent
PUBLIC	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z		; EMIT_SOUND
PUBLIC	__real@4@4001c000000000000000
PUBLIC	??_C@_0BG@BCPF@hgrunt?1gr_reload1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BG@BCAJ@weapons?1glauncher?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@CKJG@hgrunt?1gr_mgun1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@MKPJ@hgrunt?1gr_mgun2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@MGAA@weapons?1sbarrel1?4wav?$AA@	; `string'
EXTRN	?InsertSound@CSoundEnt@@SAXHABVVector@@HM@Z:NEAR ; CSoundEnt::InsertSound
EXTRN	?ShootTimed@CGrenade@@SAPAV1@PAUentvars_s@@VVector@@1M@Z:NEAR ; CGrenade::ShootTimed
EXTRN	?ShootContact@CGrenade@@SAPAV1@PAUentvars_s@@VVector@@1@Z:NEAR ; CGrenade::ShootContact
EXTRN	?g_iSkillLevel@@3HA:DWORD			; g_iSkillLevel
EXTRN	?SetBodygroup@CBaseAnimating@@QAEXHH@Z:NEAR	; CBaseAnimating::SetBodygroup
EXTRN	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsVelocity
EXTRN	?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z:NEAR ; CBaseMonster::HandleAnimEvent
;	COMDAT ??_C@_0BG@BCPF@hgrunt?1gr_reload1?4wav?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_0BG@BCPF@hgrunt?1gr_reload1?4wav?$AA@ DB 'hgrunt/gr_reload1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BCAJ@weapons?1glauncher?4wav?$AA@
CONST	SEGMENT
??_C@_0BG@BCAJ@weapons?1glauncher?4wav?$AA@ DB 'weapons/glauncher.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CKJG@hgrunt?1gr_mgun1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@CKJG@hgrunt?1gr_mgun1?4wav?$AA@ DB 'hgrunt/gr_mgun1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MKPJ@hgrunt?1gr_mgun2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@MKPJ@hgrunt?1gr_mgun2?4wav?$AA@ DB 'hgrunt/gr_mgun2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MGAA@weapons?1sbarrel1?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@MGAA@weapons?1sbarrel1?4wav?$AA@ DB 'weapons/sbarrel1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4@4001c000000000000000
CONST	SEGMENT
__real@4@4001c000000000000000 DD 040c00000r	; 6
CONST	ENDS
;	COMDAT ?HandleAnimEvent@CHGrunt@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT
$T40374 = -68
$T40377 = -88
$T40380 = -108
$T40383 = -128
$T40384 = -140
$T40385 = -152
$T40386 = -164
$T40387 = -176
$T40388 = -188
$T40389 = -200
$T40390 = -212
$T40391 = -224
$T40392 = -236
_pEvent$ = 8
_this$ = -4
_vecShootDir$ = -16
_vecShootOrigin$ = -28
_vecGunPos$38740 = -40
_vecGunAngles$38741 = -52
_pHurt$38783 = -56
?HandleAnimEvent@CHGrunt@@UAEXPAUMonsterEvent_t@@@Z PROC NEAR ; CHGrunt::HandleAnimEvent, COMDAT

; 836  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 837  : 	Vector	vecShootDir;

	lea	ecx, DWORD PTR _vecShootDir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 838  : 	Vector	vecShootOrigin;

	lea	ecx, DWORD PTR _vecShootOrigin$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 841  : 	{

	mov	eax, DWORD PTR _pEvent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR -240+[ebp], ecx
	mov	edx, DWORD PTR -240+[ebp]
	sub	edx, 2
	mov	DWORD PTR -240+[ebp], edx
	cmp	DWORD PTR -240+[ebp], 9
	ja	$L38790
	mov	eax, DWORD PTR -240+[ebp]
	jmp	DWORD PTR $L40395[eax*4]
$L38738:

; 844  : 
; 845  : 			if( pev->spawnflags & SF_MONSTER_NO_WPN_DROP )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $L38739

; 846  : 				break; //LRC

	jmp	$L38735
$L38739:

; 847  : 
; 848  : 			Vector	vecGunPos;

	lea	ecx, DWORD PTR _vecGunPos$38740[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 849  : 			Vector	vecGunAngles;

	lea	ecx, DWORD PTR _vecGunAngles$38741[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 850  : 
; 851  : 			GetAttachment( 0, vecGunPos, vecGunAngles );

	lea	ecx, DWORD PTR _vecGunAngles$38741[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecGunPos$38740[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAttachment@CBaseAnimating@@QAEXHAAVVector@@0@Z ; CBaseAnimating::GetAttachment

; 852  : 
; 853  : 			// switch to body group with no gun.
; 854  : 			SetBodygroup( GUN_GROUP, GUN_NONE );

	push	2
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBodygroup@CBaseAnimating@@QAEXHH@Z	; CBaseAnimating::SetBodygroup

; 855  : 
; 856  : 			// now spawn a gun.
; 857  : 			if (HasWeapon( HGRUNT_SHOTGUN ))

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L38742

; 859  : 				 DropItem( "weapon_shotgun", vecGunPos, vecGunAngles );

	lea	eax, DWORD PTR _vecGunAngles$38741[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecGunPos$38740[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0P@PHLB@weapon_shotgun?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropItem@CBaseMonster@@QAEPAVCBaseEntity@@PADABVVector@@1@Z ; CBaseMonster::DropItem

; 861  : 			else

	jmp	SHORT $L38743
$L38742:

; 863  : 				 DropItem( "weapon_9mmAR", vecGunPos, vecGunAngles );

	lea	edx, DWORD PTR _vecGunAngles$38741[ebp]
	push	edx
	lea	eax, DWORD PTR _vecGunPos$38740[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0N@JNOE@weapon_9mmAR?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropItem@CBaseMonster@@QAEPAVCBaseEntity@@PADABVVector@@1@Z ; CBaseMonster::DropItem
$L38743:

; 865  : 			if (HasWeapon( HGRUNT_GRENADELAUNCHER ))

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L38744

; 867  : 				DropItem( "ammo_ARgrenades", BodyTarget( GetAbsOrigin() ), vecGunAngles );

	lea	ecx, DWORD PTR _vecGunAngles$38741[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T40374[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+316]
	push	eax
	push	OFFSET FLAT:??_C@_0BA@OEBJ@ammo_ARgrenades?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropItem@CBaseMonster@@QAEPAVCBaseEntity@@PADABVVector@@1@Z ; CBaseMonster::DropItem
$L38744:

; 871  : 			break;

	jmp	$L38735
$L38746:

; 872  : 
; 873  : 		case HGRUNT_AE_RELOAD:
; 874  : 			EMIT_SOUND( ENT(pev), CHAN_WEAPON, "hgrunt/gr_reload1.wav", 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BG@BCPF@hgrunt?1gr_reload1?4wav?$AA@ ; `string'
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 875  : 			m_cAmmoLoaded = m_cClipSize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2488]
	mov	DWORD PTR [edx+2300], ecx

; 876  : 			ClearConditions(bits_COND_NO_AMMO_LOADED);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::ClearConditions

; 877  : 			break;

	jmp	$L38735
$L38749:

; 881  : 			UTIL_MakeVectors( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 882  : 			// CGrenade::ShootTimed( pev, GetAbsOrigin() + gpGlobals->v_forward * 34 + Vector (0, 0, 32), m_vecTossVelocity, 3.5 );
; 883  : 			CGrenade::ShootTimed( pev, GetGunPosition(), m_vecTossVelocity, 3.5 );

	push	1080033280				; 40600000H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2464				; 000009a0H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	eax, DWORD PTR $T40377[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+588]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ShootTimed@CGrenade@@SAPAV1@PAUentvars_s@@VVector@@1M@Z ; CGrenade::ShootTimed
	add	esp, 32					; 00000020H

; 884  : 
; 885  : 			m_fThrowGrenade = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2476], 0

; 886  : 			m_flNextGrenadeCheck = gpGlobals->time + 6;// wait six seconds before even looking again to see if a grenade can be thrown.

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@4001c000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2452]

; 889  : 		break;

	jmp	$L38735
$L38753:

; 893  : 			EMIT_SOUND(ENT(pev), CHAN_WEAPON, "weapons/glauncher.wav", 0.8, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1061997773				; 3f4ccccdH
	push	OFFSET FLAT:??_C@_0BG@BCAJ@weapons?1glauncher?4wav?$AA@ ; `string'
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 894  : 			CGrenade::ShootContact( pev, GetGunPosition(), m_vecTossVelocity );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2464				; 000009a0H
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	push	ecx
	mov	ecx, edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	eax, DWORD PTR $T40380[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+588]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ShootContact@CGrenade@@SAPAV1@PAUentvars_s@@VVector@@1@Z ; CGrenade::ShootContact
	add	esp, 28					; 0000001cH

; 895  : 			m_fThrowGrenade = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2476], 0

; 896  : 			if (g_iSkillLevel == SKILL_HARD)

	cmp	DWORD PTR ?g_iSkillLevel@@3HA, 3	; g_iSkillLevel
	jne	SHORT $L38759

; 897  : 				m_flNextGrenadeCheck = gpGlobals->time + RANDOM_FLOAT( 2, 5 );// wait a random amount of time before shooting again

	push	1084227584				; 40a00000H
	push	1073741824				; 40000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2452]

; 898  : 			else

	jmp	SHORT $L38760
$L38759:

; 899  : 				m_flNextGrenadeCheck = gpGlobals->time + 6;// wait six seconds before even looking again to see if a grenade can be thrown.

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	DWORD PTR __real@4@4001c000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+2452]
$L38760:

; 901  : 		break;

	jmp	$L38735
$L38761:

; 905  : 			UTIL_MakeVectors( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 906  : 			CGrenade::ShootTimed( pev, GetAbsOrigin() + gpGlobals->v_forward * 17 - gpGlobals->v_right * 27 + gpGlobals->v_up * 6, g_vecZero, 3 );

	push	1077936128				; 40400000H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	push	1086324736				; 40c00000H
	lea	ecx, DWORD PTR $T40387[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 52					; 00000034H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T40388[ebp]
	push	edx
	push	1104674816				; 41d80000H
	lea	eax, DWORD PTR $T40385[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T40386[ebp]
	push	ecx
	push	1099431936				; 41880000H
	lea	edx, DWORD PTR $T40383[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40384[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ShootTimed@CGrenade@@SAPAV1@PAUentvars_s@@VVector@@1M@Z ; CGrenade::ShootTimed
	add	esp, 32					; 00000020H

; 908  : 		break;

	jmp	$L38735
$L38770:

; 912  : 			if ( HasWeapon( HGRUNT_9MMAR ))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L38771

; 914  : 				Shoot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Shoot@CHGrunt@@QAEXXZ			; CHGrunt::Shoot

; 915  : 
; 916  : 				// the first round of the three round burst plays the sound and puts a sound in the world sound list.
; 917  : 				if ( RANDOM_LONG(0,1) )

	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	je	SHORT $L38772

; 919  : 					EMIT_SOUND( ENT(pev), CHAN_WEAPON, "hgrunt/gr_mgun1.wav", 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@CKJG@hgrunt?1gr_mgun1?4wav?$AA@ ; `string'
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 921  : 				else

	jmp	SHORT $L38775
$L38772:

; 923  : 					EMIT_SOUND( ENT(pev), CHAN_WEAPON, "hgrunt/gr_mgun2.wav", 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@MKPJ@hgrunt?1gr_mgun2?4wav?$AA@ ; `string'
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L38775:

; 926  : 			else

	jmp	SHORT $L38778
$L38771:

; 928  : 				Shotgun( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Shotgun@CHGrunt@@QAEXXZ		; CHGrunt::Shotgun

; 929  : 
; 930  : 				EMIT_SOUND(ENT(pev), CHAN_WEAPON, "weapons/sbarrel1.wav", 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BF@MGAA@weapons?1sbarrel1?4wav?$AA@ ; `string'
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L38778:

; 932  : 		
; 933  : 			CSoundEnt::InsertSound ( bits_SOUND_COMBAT, GetAbsOrigin(), 384, 0.3 );

	push	1050253722				; 3e99999aH
	push	384					; 00000180H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	push	1
	call	?InsertSound@CSoundEnt@@SAXHABVVector@@HM@Z ; CSoundEnt::InsertSound
	add	esp, 16					; 00000010H

; 935  : 		break;

	jmp	$L38735
$L38781:

; 936  : 
; 937  : 		case HGRUNT_AE_BURST2:
; 938  : 		case HGRUNT_AE_BURST3:
; 939  : 			Shoot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Shoot@CHGrunt@@QAEXXZ			; CHGrunt::Shoot

; 940  : 			break;

	jmp	$L38735
$L38782:

; 944  : 			CBaseEntity *pHurt = Kick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Kick@CHGrunt@@QAEPAVCBaseEntity@@XZ	; CHGrunt::Kick
	mov	DWORD PTR _pHurt$38783[ebp], eax

; 945  : 
; 946  : 			if ( pHurt )

	cmp	DWORD PTR _pHurt$38783[ebp], 0
	je	$L38784

; 948  : 				// SOUND HERE!
; 949  : 				UTIL_MakeVectors( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 950  : 				pHurt->pev->punchangle.x = 15;

	mov	eax, DWORD PTR _pHurt$38783[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+104], 1097859072		; 41700000H

; 951  : 				pHurt->SetAbsVelocity( pHurt->GetAbsVelocity() + gpGlobals->v_forward * 100 + gpGlobals->v_up * 50 );

	push	1112014848				; 42480000H
	lea	edx, DWORD PTR $T40391[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 52					; 00000034H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40392[ebp]
	push	eax
	push	1120403456				; 42c80000H
	lea	ecx, DWORD PTR $T40389[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T40390[ebp]
	push	edx
	mov	ecx, DWORD PTR _pHurt$38783[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _pHurt$38783[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 952  : 				pHurt->TakeDamage( pev, pev, gSkillData.hgruntDmgKick, DMG_CLUB );

	push	128					; 00000080H
	mov	eax, DWORD PTR ?gSkillData@@3Uskilldata_t@@A+84
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pHurt$38783[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pHurt$38783[ebp]
	call	DWORD PTR [eax+96]
$L38784:

; 955  : 		break;

	jmp	SHORT $L38735
$L38789:

; 959  : 			if ( FOkToSpeak() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CHGrunt@@QAEHXZ		; CHGrunt::FOkToSpeak
	test	eax, eax
	je	SHORT $L38790

; 961  : 				SENTENCEG_PlayRndSz(ENT(pev), "HG_ALERT", HGRUNT_SENTENCE_VOLUME, GRUNT_ATTN, 0, m_voicePitch);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2492]
	push	edx
	push	0
	push	1061997773				; 3f4ccccdH
	push	1051931443				; 3eb33333H
	push	OFFSET FLAT:??_C@_08MHEE@HG_ALERT?$AA@	; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H

; 962  : 				 JustSpoke();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JustSpoke@CHGrunt@@QAEXXZ		; CHGrunt::JustSpoke
$L38790:

; 966  : 
; 967  : 		default:
; 968  : 			CSquadMonster::HandleAnimEvent( pEvent );

	mov	edx, DWORD PTR _pEvent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z ; CBaseMonster::HandleAnimEvent
$L38735:

; 971  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L40395:
	DD	$L38746
	DD	$L38782
	DD	$L38770
	DD	$L38781
	DD	$L38781
	DD	$L38749
	DD	$L38753
	DD	$L38761
	DD	$L38789
	DD	$L38738
?HandleAnimEvent@CHGrunt@@UAEXPAUMonsterEvent_t@@@Z ENDP ; CHGrunt::HandleAnimEvent
_TEXT	ENDS
EXTRN	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z:NEAR	; EMIT_SOUND_DYN
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
_volume$ = 20
_attenuation$ = 24
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z PROC NEAR		; EMIT_SOUND, COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 610  : 	EMIT_SOUND_DYN( entity, channel, sample, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 611  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z ENDP		; EMIT_SOUND
_TEXT	ENDS
;	COMDAT ?ClearConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_iConditions$ = 8
_this$ = -4
?ClearConditions@CBaseMonster@@QAEXH@Z PROC NEAR	; CBaseMonster::ClearConditions, COMDAT

; 257  : 		inline void	ClearConditions( int iConditions ) { m_afConditions &= ~iConditions; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _iConditions$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1956]
	and	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1956], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearConditions@CBaseMonster@@QAEXH@Z ENDP		; CBaseMonster::ClearConditions
_TEXT	ENDS
PUBLIC	?Spawn@CHGrunt@@UAEXXZ				; CHGrunt::Spawn
PUBLIC	?AddWeapon@CBaseMonster@@QAEXH@Z		; CBaseMonster::AddWeapon
PUBLIC	??_C@_0BC@KNIA@models?1hgrunt?4mdl?$AA@		; `string'
EXTRN	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z:NEAR ; UTIL_SetSize
;	COMDAT ??_C@_0BC@KNIA@models?1hgrunt?4mdl?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_0BC@KNIA@models?1hgrunt?4mdl?$AA@ DB 'models/hgrunt.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ?Spawn@CHGrunt@@UAEXXZ
_TEXT	SEGMENT
$T40402 = -16
$T40403 = -28
$T40404 = -40
_this$ = -4
?Spawn@CHGrunt@@UAEXXZ PROC NEAR			; CHGrunt::Spawn, COMDAT

; 977  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 978  : 	Precache( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 979  : 
; 980  : 	if (pev->model)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+184], 0
	je	SHORT $L38797

; 981  : 		SET_MODEL(ENT(pev), STRING(pev->model)); //LRC

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+184]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 982  : 	else

	jmp	SHORT $L38798
$L38797:

; 983  : 		SET_MODEL(ENT(pev), "models/hgrunt.mdl");

	push	OFFSET FLAT:??_C@_0BC@KNIA@models?1hgrunt?4mdl?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8
$L38798:

; 984  : 	UTIL_SetSize(pev, VEC_HUMAN_HULL_MIN, VEC_HUMAN_HULL_MAX);

	push	1116733440				; 42900000H
	push	1098907648				; 41800000H
	push	1098907648				; 41800000H
	lea	ecx, DWORD PTR $T40402[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	push	0
	push	-1048576000				; c1800000H
	push	-1048576000				; c1800000H
	lea	ecx, DWORD PTR $T40403[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 985  : 
; 986  : 	pev->solid			= SOLID_SLIDEBOX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 3

; 987  : 	pev->movetype		= MOVETYPE_STEP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+264], 4

; 988  : 	m_bloodColor		= BLOOD_COLOR_RED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2328], 247		; 000000f7H

; 989  : 	pev->effects		= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], 0

; 990  : 	if (!pev->health) pev->health	= gSkillData.hgruntHealth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38803
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR ?gSkillData@@3Uskilldata_t@@A+80
	mov	DWORD PTR [eax+352], ecx
$L38803:

; 991  : 	m_flFieldOfView		= 0.2;// indicates the width of this monster's forward view cone ( as a dotproduct result )

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2056], 1045220557	; 3e4ccccdH

; 992  : 	m_MonsterState		= MONSTERSTATE_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2080], 0

; 993  : 	m_flNextGrenadeCheck = gpGlobals->time + 1;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+2452]

; 994  : 	m_flNextPainTime	= gpGlobals->time;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+2456], edx

; 995  : 	m_iSentence			= HGRUNT_SENT_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2504], -1

; 996  : 
; 997  : 	m_afCapability		= bits_CAP_SQUAD | bits_CAP_TURN_HEAD | bits_CAP_DOORS_GROUP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2304], 1864		; 00000748H

; 998  : 
; 999  : 	m_fEnemyEluded		= FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2444], 0

; 1000 : 	m_fFirstEncounter	= TRUE;// this is true when the grunt spawns, because he hasn't encountered an enemy yet.

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2484], 1

; 1001 : 
; 1002 : 	m_HackedGunPos = Vector ( 0, 0, 55 );

	push	1113325568				; 425c0000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T40404[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2364				; 0000093cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1003 : 
; 1004 : 	if (!m_bHaveWeapons)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2376], 0
	jne	SHORT $L38805

; 1006 : 		// initialize to original values
; 1007 : 		AddWeapon( HGRUNT_9MMAR );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWeapon@CBaseMonster@@QAEXH@Z	; CBaseMonster::AddWeapon

; 1008 : 		AddWeapon( HGRUNT_HANDGRENADE );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWeapon@CBaseMonster@@QAEXH@Z	; CBaseMonster::AddWeapon
$L38805:

; 1013 : 
; 1014 : 	if (HasWeapon( HGRUNT_SHOTGUN ))

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L38806

; 1016 : 		SetBodygroup( GUN_GROUP, GUN_SHOTGUN );

	push	1
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBodygroup@CBaseAnimating@@QAEXHH@Z	; CBaseAnimating::SetBodygroup

; 1017 : 		m_cClipSize		= 8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2488], 8

; 1019 : 	else

	jmp	SHORT $L38807
$L38806:

; 1021 : 		m_cClipSize		= GRUNT_CLIP_SIZE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2488], 36		; 00000024H
$L38807:

; 1023 : 	m_cAmmoLoaded		= m_cClipSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2488]
	mov	DWORD PTR [ecx+2300], eax

; 1024 : 
; 1025 : 	if (RANDOM_LONG( 0, 99 ) < 80)

	push	99					; 00000063H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	cmp	eax, 80					; 00000050H
	jge	SHORT $L38808

; 1026 : 		pev->skin = 0;	// light skin

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+272], 0

; 1027 : 	else

	jmp	SHORT $L38809
$L38808:

; 1028 : 		pev->skin = 1;	// dark skin

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+272], 1
$L38809:

; 1029 : 
; 1030 : 	if ( HasWeapon( HGRUNT_SHOTGUN ))

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L38810

; 1032 : 		SetBodygroup( HEAD_GROUP, HEAD_SHOTGUN);

	push	2
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBodygroup@CBaseAnimating@@QAEXHH@Z	; CBaseAnimating::SetBodygroup

; 1034 : 	else if ( HasWeapon( HGRUNT_GRENADELAUNCHER ))

	jmp	SHORT $L38812
$L38810:
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L38812

; 1036 : 		SetBodygroup( HEAD_GROUP, HEAD_M203 );

	push	3
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBodygroup@CBaseAnimating@@QAEXHH@Z	; CBaseAnimating::SetBodygroup

; 1037 : 		pev->skin = 1; // alway dark skin

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+272], 1
$L38812:

; 1039 : 
; 1040 : 	CTalkMonster::g_talkWaitTime = 0;

	mov	DWORD PTR ?g_talkWaitTime@CTalkMonster@@2MA, 0

; 1041 : 
; 1042 : 	MonsterInit();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+368]

; 1043 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CHGrunt@@UAEXXZ ENDP				; CHGrunt::Spawn
_TEXT	ENDS
;	COMDAT ?AddWeapon@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4
_weaponnum$ = 8
?AddWeapon@CBaseMonster@@QAEXH@Z PROC NEAR		; CBaseMonster::AddWeapon, COMDAT

; 143  : 	void		AddWeapon( int weaponnum ) { SetBits( m_iWeapons[weaponnum >> 3], BIT( weaponnum & 7 )); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _weaponnum$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+eax+2348]
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	or	edx, eax
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	sar	ecx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+2348], dl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddWeapon@CBaseMonster@@QAEXH@Z ENDP			; CBaseMonster::AddWeapon
_TEXT	ENDS
PUBLIC	?Precache@CHGrunt@@UAEXXZ			; CHGrunt::Precache
PUBLIC	??_C@_0BD@BMMK@hgrunt?1gr_die1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@PMKF@hgrunt?1gr_die2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@FMIA@hgrunt?1gr_die3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@EAHL@hgrunt?1gr_pain1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@KABE@hgrunt?1gr_pain2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@DB@hgrunt?1gr_pain3?4wav?$AA@		; `string'
PUBLIC	??_C@_0BE@GAML@hgrunt?1gr_pain4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@MAOO@hgrunt?1gr_pain5?4wav?$AA@	; `string'
PUBLIC	??_C@_0BG@CPHF@zombie?1claw_miss2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BB@GKKK@models?1shell?4mdl?$AA@		; `string'
PUBLIC	??_C@_0BI@MEKG@models?1shotgunshell?4mdl?$AA@	; `string'
;	COMDAT ??_C@_0BD@BMMK@hgrunt?1gr_die1?4wav?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_0BD@BMMK@hgrunt?1gr_die1?4wav?$AA@ DB 'hgrunt/gr_die1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PMKF@hgrunt?1gr_die2?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@PMKF@hgrunt?1gr_die2?4wav?$AA@ DB 'hgrunt/gr_die2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FMIA@hgrunt?1gr_die3?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@FMIA@hgrunt?1gr_die3?4wav?$AA@ DB 'hgrunt/gr_die3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EAHL@hgrunt?1gr_pain1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@EAHL@hgrunt?1gr_pain1?4wav?$AA@ DB 'hgrunt/gr_pain1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KABE@hgrunt?1gr_pain2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@KABE@hgrunt?1gr_pain2?4wav?$AA@ DB 'hgrunt/gr_pain2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DB@hgrunt?1gr_pain3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@DB@hgrunt?1gr_pain3?4wav?$AA@ DB 'hgrunt/gr_pain3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GAML@hgrunt?1gr_pain4?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@GAML@hgrunt?1gr_pain4?4wav?$AA@ DB 'hgrunt/gr_pain4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MAOO@hgrunt?1gr_pain5?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@MAOO@hgrunt?1gr_pain5?4wav?$AA@ DB 'hgrunt/gr_pain5.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CPHF@zombie?1claw_miss2?4wav?$AA@
CONST	SEGMENT
??_C@_0BG@CPHF@zombie?1claw_miss2?4wav?$AA@ DB 'zombie/claw_miss2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GKKK@models?1shell?4mdl?$AA@
CONST	SEGMENT
??_C@_0BB@GKKK@models?1shell?4mdl?$AA@ DB 'models/shell.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MEKG@models?1shotgunshell?4mdl?$AA@
CONST	SEGMENT
??_C@_0BI@MEKG@models?1shotgunshell?4mdl?$AA@ DB 'models/shotgunshell.mdl'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?Precache@CHGrunt@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CHGrunt@@UAEXXZ PROC NEAR			; CHGrunt::Precache, COMDAT

; 1049 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1050 : 	if (pev->model)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+184], 0
	je	SHORT $L38816

; 1051 : 		PRECACHE_MODEL((char*)STRING(pev->model)); //LRC

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+184]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4

; 1052 : 	else

	jmp	SHORT $L38818
$L38816:

; 1053 : 		PRECACHE_MODEL("models/hgrunt.mdl");

	push	OFFSET FLAT:??_C@_0BC@KNIA@models?1hgrunt?4mdl?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
$L38818:

; 1054 : 
; 1055 : 	PRECACHE_SOUND( "hgrunt/gr_mgun1.wav" );

	push	OFFSET FLAT:??_C@_0BE@CKJG@hgrunt?1gr_mgun1?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1056 : 	PRECACHE_SOUND( "hgrunt/gr_mgun2.wav" );

	push	OFFSET FLAT:??_C@_0BE@MKPJ@hgrunt?1gr_mgun2?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1057 : 	
; 1058 : 	PRECACHE_SOUND( "hgrunt/gr_die1.wav" );

	push	OFFSET FLAT:??_C@_0BD@BMMK@hgrunt?1gr_die1?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1059 : 	PRECACHE_SOUND( "hgrunt/gr_die2.wav" );

	push	OFFSET FLAT:??_C@_0BD@PMKF@hgrunt?1gr_die2?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1060 : 	PRECACHE_SOUND( "hgrunt/gr_die3.wav" );

	push	OFFSET FLAT:??_C@_0BD@FMIA@hgrunt?1gr_die3?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1061 : 
; 1062 : 	PRECACHE_SOUND( "hgrunt/gr_pain1.wav" );

	push	OFFSET FLAT:??_C@_0BE@EAHL@hgrunt?1gr_pain1?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1063 : 	PRECACHE_SOUND( "hgrunt/gr_pain2.wav" );

	push	OFFSET FLAT:??_C@_0BE@KABE@hgrunt?1gr_pain2?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1064 : 	PRECACHE_SOUND( "hgrunt/gr_pain3.wav" );

	push	OFFSET FLAT:??_C@_0BE@DB@hgrunt?1gr_pain3?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1065 : 	PRECACHE_SOUND( "hgrunt/gr_pain4.wav" );

	push	OFFSET FLAT:??_C@_0BE@GAML@hgrunt?1gr_pain4?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1066 : 	PRECACHE_SOUND( "hgrunt/gr_pain5.wav" );

	push	OFFSET FLAT:??_C@_0BE@MAOO@hgrunt?1gr_pain5?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1067 : 
; 1068 : 	PRECACHE_SOUND( "hgrunt/gr_reload1.wav" );

	push	OFFSET FLAT:??_C@_0BG@BCPF@hgrunt?1gr_reload1?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1069 : 
; 1070 : 	PRECACHE_SOUND( "weapons/glauncher.wav" );

	push	OFFSET FLAT:??_C@_0BG@BCAJ@weapons?1glauncher?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1071 : 
; 1072 : 	PRECACHE_SOUND( "weapons/sbarrel1.wav" );

	push	OFFSET FLAT:??_C@_0BF@MGAA@weapons?1sbarrel1?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1073 : 
; 1074 : 	PRECACHE_SOUND("zombie/claw_miss2.wav");// because we use the basemonster SWIPE animation event

	push	OFFSET FLAT:??_C@_0BG@CPHF@zombie?1claw_miss2?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 1075 : 
; 1076 : 	// get voice pitch
; 1077 : 	if (RANDOM_LONG(0,1))

	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	je	SHORT $L38828

; 1078 : 		m_voicePitch = 109 + RANDOM_LONG(0,7);

	push	7
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 109				; 0000006dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2492], eax

; 1079 : 	else

	jmp	SHORT $L38829
$L38828:

; 1080 : 		m_voicePitch = 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2492], 100		; 00000064H
$L38829:

; 1081 : 
; 1082 : 	m_iBrassShell = PRECACHE_MODEL ("models/shell.mdl");// brass shell

	push	OFFSET FLAT:??_C@_0BB@GKKK@models?1shell?4mdl?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2496], eax

; 1083 : 	m_iShotgunShell = PRECACHE_MODEL ("models/shotgunshell.mdl");

	push	OFFSET FLAT:??_C@_0BI@MEKG@models?1shotgunshell?4mdl?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2500], eax

; 1084 : }	

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CHGrunt@@UAEXXZ ENDP				; CHGrunt::Precache
_TEXT	ENDS
PUBLIC	?StartTask@CHGrunt@@UAEXPAUTask_t@@@Z		; CHGrunt::StartTask
PUBLIC	?TaskComplete@CBaseMonster@@QAEXXZ		; CBaseMonster::TaskComplete
EXTRN	?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z:NEAR	; CBaseMonster::StartTask
;	COMDAT ?StartTask@CHGrunt@@UAEXPAUTask_t@@@Z
_TEXT	SEGMENT
_pTask$ = 8
_this$ = -4
?StartTask@CHGrunt@@UAEXPAUTask_t@@@Z PROC NEAR		; CHGrunt::StartTask, COMDAT

; 1090 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1091 : 	m_iTaskStatus = TASKSTATUS_RUNNING;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2088], 1

; 1094 : 	{

	mov	ecx, DWORD PTR _pTask$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR -8+[ebp], edx
	mov	eax, DWORD PTR -8+[ebp]
	sub	eax, 18					; 00000012H
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 75			; 0000004bH
	ja	$L38848
	mov	edx, DWORD PTR -8+[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR $L40411[edx]
	jmp	DWORD PTR $L40412[ecx*4]
$L38840:

; 1095 : 	case TASK_GRUNT_CHECK_FIRE:
; 1096 : 		if ( !NoFriendlyFire() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NoFriendlyFire@CSquadMonster@@QAEHXZ	; CSquadMonster::NoFriendlyFire
	test	eax, eax
	jne	SHORT $L38841

; 1098 : 			SetConditions( bits_COND_GRUNT_NOFIRE );

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
$L38841:

; 1100 : 		TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 1101 : 		break;

	jmp	SHORT $L38837
$L38842:

; 1102 : 
; 1103 : 	case TASK_GRUNT_SPEAK_SENTENCE:
; 1104 : 		SpeakSentence();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SpeakSentence@CHGrunt@@QAEXXZ		; CHGrunt::SpeakSentence

; 1105 : 		TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 1106 : 		break;

	jmp	SHORT $L38837
$L38843:

; 1107 : 	
; 1108 : 	case TASK_WALK_PATH:
; 1109 : 	case TASK_RUN_PATH:
; 1110 : 		// grunt no longer assumes he is covered if he moves
; 1111 : 		Forget( bits_MEMORY_INCOVER );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Forget@CBaseMonster@@QAEXH@Z		; CBaseMonster::Forget

; 1112 : 		CSquadMonster ::StartTask( pTask );

	mov	eax, DWORD PTR _pTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z ; CBaseMonster::StartTask

; 1113 : 		break;

	jmp	SHORT $L38837
$L38844:

; 1114 : 
; 1115 : 	case TASK_RELOAD:
; 1116 : 		m_IdealActivity = ACT_RELOAD;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2072], 32		; 00000020H

; 1117 : 		break;

	jmp	SHORT $L38837
$L38845:

; 1118 : 
; 1119 : 	case TASK_GRUNT_FACE_TOSS_DIR:
; 1120 : 		break;

	jmp	SHORT $L38837
$L38846:

; 1121 : 
; 1122 : 	case TASK_FACE_IDEAL:
; 1123 : 	case TASK_FACE_ENEMY:
; 1124 : 		CSquadMonster :: StartTask( pTask );

	mov	edx, DWORD PTR _pTask$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z ; CBaseMonster::StartTask

; 1125 : 		if (pev->movetype == MOVETYPE_FLY)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+264], 5
	jne	SHORT $L38847

; 1127 : 			m_IdealActivity = ACT_GLIDE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2072], 51		; 00000033H
$L38847:

; 1129 : 		break;

	jmp	SHORT $L38837
$L38848:

; 1130 : 
; 1131 : 	default: 
; 1132 : 		CSquadMonster :: StartTask( pTask );

	mov	eax, DWORD PTR _pTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z ; CBaseMonster::StartTask
$L38837:

; 1135 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L40412:
	DD	$L38843
	DD	$L38846
	DD	$L38844
	DD	$L38845
	DD	$L38842
	DD	$L38840
	DD	$L38848
$L40411:
	DB	0
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	4
	DB	5
?StartTask@CHGrunt@@UAEXPAUTask_t@@@Z ENDP		; CHGrunt::StartTask
_TEXT	ENDS
;	COMDAT ?TaskComplete@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TaskComplete@CBaseMonster@@QAEXXZ PROC NEAR		; CBaseMonster::TaskComplete, COMDAT

; 226  : 		inline void TaskComplete( void ) { if ( !HasConditions(bits_COND_TASK_FAILED) ) m_iTaskStatus = TASKSTATUS_COMPLETE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1073741824				; 40000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	jne	SHORT $L36107
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2088], 4
$L36107:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TaskComplete@CBaseMonster@@QAEXXZ ENDP			; CBaseMonster::TaskComplete
_TEXT	ENDS
PUBLIC	?RunTask@CHGrunt@@UAEXPAUTask_t@@@Z		; CHGrunt::RunTask
EXTRN	?MakeIdealYaw@CBaseMonster@@QAEXVVector@@@Z:NEAR ; CBaseMonster::MakeIdealYaw
EXTRN	?FacingIdeal@CBaseMonster@@QAEHXZ:NEAR		; CBaseMonster::FacingIdeal
EXTRN	?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z:NEAR	; CBaseMonster::RunTask
;	COMDAT ?RunTask@CHGrunt@@UAEXPAUTask_t@@@Z
_TEXT	SEGMENT
$T40418 = -20
$T40419 = -32
_pTask$ = 8
_this$ = -4
?RunTask@CHGrunt@@UAEXPAUTask_t@@@Z PROC NEAR		; CHGrunt::RunTask, COMDAT

; 1141 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 	{

	mov	eax, DWORD PTR _pTask$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR -36+[ebp], ecx
	cmp	DWORD PTR -36+[ebp], 91			; 0000005bH
	je	SHORT $L38857
	jmp	SHORT $L38862
$L38857:

; 1146 : 			// project a point along the toss vector and turn to face that point.
; 1147 : 			MakeIdealYaw( GetAbsOrigin() + m_vecTossVelocity * 64 );

	push	1115684864				; 42800000H
	lea	edx, DWORD PTR $T40418[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2464				; 000009a0H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40419[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeIdealYaw@CBaseMonster@@QAEXVVector@@@Z ; CBaseMonster::MakeIdealYaw

; 1148 : 			ChangeYaw( pev->yaw_speed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+176]
	call	__ftol
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+356]
	fstp	ST(0)

; 1149 : 
; 1150 : 			if ( FacingIdeal() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FacingIdeal@CBaseMonster@@QAEHXZ	; CBaseMonster::FacingIdeal
	test	eax, eax
	je	SHORT $L38861

; 1152 : 				m_iTaskStatus = TASKSTATUS_COMPLETE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2088], 4
$L38861:

; 1154 : 			break;

	jmp	SHORT $L38854
$L38862:

; 1158 : 			CSquadMonster :: RunTask( pTask );

	mov	ecx, DWORD PTR _pTask$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z ; CBaseMonster::RunTask
$L38854:

; 1162 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RunTask@CHGrunt@@UAEXPAUTask_t@@@Z ENDP		; CHGrunt::RunTask
_TEXT	ENDS
PUBLIC	?PainSound@CHGrunt@@UAEXXZ			; CHGrunt::PainSound
;	COMDAT ?PainSound@CHGrunt@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PainSound@CHGrunt@@UAEXXZ PROC NEAR			; CHGrunt::PainSound, COMDAT

; 1168 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1169 : 	if ( gpGlobals->time > m_flNextPainTime )

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx+2456]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L38867

; 1184 : 		{

	push	6
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 4
	ja	$L38869
	mov	edx, DWORD PTR -8+[ebp]
	jmp	DWORD PTR $L40422[edx*4]
$L38872:

; 1185 : 		case 0:	
; 1186 : 			EMIT_SOUND( ENT(pev), CHAN_VOICE, "hgrunt/gr_pain3.wav", 1, ATTN_NORM );	

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@DB@hgrunt?1gr_pain3?4wav?$AA@ ; `string'
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1187 : 			break;

	jmp	$L38869
$L38874:

; 1188 : 		case 1:
; 1189 : 			EMIT_SOUND( ENT(pev), CHAN_VOICE, "hgrunt/gr_pain4.wav", 1, ATTN_NORM );	

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@GAML@hgrunt?1gr_pain4?4wav?$AA@ ; `string'
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1190 : 			break;

	jmp	SHORT $L38869
$L38876:

; 1191 : 		case 2:
; 1192 : 			EMIT_SOUND( ENT(pev), CHAN_VOICE, "hgrunt/gr_pain5.wav", 1, ATTN_NORM );	

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@MAOO@hgrunt?1gr_pain5?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1193 : 			break;

	jmp	SHORT $L38869
$L38878:

; 1194 : 		case 3:
; 1195 : 			EMIT_SOUND( ENT(pev), CHAN_VOICE, "hgrunt/gr_pain1.wav", 1, ATTN_NORM );	

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@EAHL@hgrunt?1gr_pain1?4wav?$AA@ ; `string'
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1196 : 			break;

	jmp	SHORT $L38869
$L38880:

; 1197 : 		case 4:
; 1198 : 			EMIT_SOUND( ENT(pev), CHAN_VOICE, "hgrunt/gr_pain2.wav", 1, ATTN_NORM );	

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@KABE@hgrunt?1gr_pain2?4wav?$AA@ ; `string'
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L38869:

; 1201 : 
; 1202 : 		m_flNextPainTime = gpGlobals->time + 1;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+2456]
$L38867:

; 1204 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L40422:
	DD	$L38872
	DD	$L38874
	DD	$L38876
	DD	$L38878
	DD	$L38880
?PainSound@CHGrunt@@UAEXXZ ENDP				; CHGrunt::PainSound
_TEXT	ENDS
PUBLIC	?DeathSound@CHGrunt@@UAEXXZ			; CHGrunt::DeathSound
;	COMDAT ?DeathSound@CHGrunt@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DeathSound@CHGrunt@@UAEXXZ PROC NEAR			; CHGrunt::DeathSound, COMDAT

; 1210 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1212 : 	{

	push	2
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 0
	je	SHORT $L38890
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L38892
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L38894
	jmp	SHORT $L38887
$L38890:

; 1213 : 	case 0:	
; 1214 : 		EMIT_SOUND( ENT(pev), CHAN_VOICE, "hgrunt/gr_die1.wav", 1, ATTN_IDLE );	

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BD@BMMK@hgrunt?1gr_die1?4wav?$AA@ ; `string'
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1215 : 		break;

	jmp	SHORT $L38887
$L38892:

; 1216 : 	case 1:
; 1217 : 		EMIT_SOUND( ENT(pev), CHAN_VOICE, "hgrunt/gr_die2.wav", 1, ATTN_IDLE );	

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BD@PMKF@hgrunt?1gr_die2?4wav?$AA@ ; `string'
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1218 : 		break;

	jmp	SHORT $L38887
$L38894:

; 1219 : 	case 2:
; 1220 : 		EMIT_SOUND( ENT(pev), CHAN_VOICE, "hgrunt/gr_die3.wav", 1, ATTN_IDLE );	

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BD@FMIA@hgrunt?1gr_die3?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L38887:

; 1223 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DeathSound@CHGrunt@@UAEXXZ ENDP			; CHGrunt::DeathSound
_TEXT	ENDS
PUBLIC	?ScheduleFromName@CHGrunt@@UAEPAUSchedule_t@@PBD@Z ; CHGrunt::ScheduleFromName
EXTRN	?ScheduleInList@CBaseMonster@@QAEPAUSchedule_t@@PBDPAPAU2@H@Z:NEAR ; CBaseMonster::ScheduleInList
EXTRN	?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z:NEAR ; CBaseMonster::ScheduleFromName
;	COMDAT ?ScheduleFromName@CHGrunt@@UAEPAUSchedule_t@@PBD@Z
_TEXT	SEGMENT
_pName$ = 8
_this$ = -4
_pSchedule$ = -8
?ScheduleFromName@CHGrunt@@UAEPAUSchedule_t@@PBD@Z PROC NEAR ; CHGrunt::ScheduleFromName, COMDAT

; 1866 : IMPLEMENT_CUSTOM_SCHEDULES( CHGrunt, CSquadMonster );

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	21					; 00000015H
	push	OFFSET FLAT:?m_scheduleList@CHGrunt@@2PAPAUSchedule_t@@A ; CHGrunt::m_scheduleList
	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScheduleInList@CBaseMonster@@QAEPAUSchedule_t@@PBDPAPAU2@H@Z ; CBaseMonster::ScheduleInList
	mov	DWORD PTR _pSchedule$[ebp], eax
	cmp	DWORD PTR _pSchedule$[ebp], 0
	jne	SHORT $L39105
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z ; CBaseMonster::ScheduleFromName
	jmp	SHORT $L39103
$L39105:
	mov	eax, DWORD PTR _pSchedule$[ebp]
$L39103:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ScheduleFromName@CHGrunt@@UAEPAUSchedule_t@@PBD@Z ENDP	; CHGrunt::ScheduleFromName
_TEXT	ENDS
PUBLIC	??_C@_0N@IMKA@standing_mp5?$AA@			; `string'
PUBLIC	??_C@_0O@NMOD@crouching_mp5?$AA@		; `string'
PUBLIC	??_C@_0BB@DCBE@standing_shotgun?$AA@		; `string'
PUBLIC	??_C@_0BC@DIAD@crouching_shotgun?$AA@		; `string'
PUBLIC	??_C@_0N@GDEM@throwgrenade?$AA@			; `string'
PUBLIC	??_C@_0O@POID@launchgrenade?$AA@		; `string'
PUBLIC	??_C@_0BP@FOLO@?$CFs?5has?5no?5sequence?5for?5act?3?$CFd?6?$AA@ ; `string'
PUBLIC	?SetActivity@CHGrunt@@UAEXW4Activity@@@Z	; CHGrunt::SetActivity
EXTRN	?LookupActivity@CBaseAnimating@@QAEHH@Z:NEAR	; CBaseAnimating::LookupActivity
EXTRN	?LookupSequence@CBaseAnimating@@QAEHPBD@Z:NEAR	; CBaseAnimating::LookupSequence
EXTRN	?ResetSequenceInfo@CBaseAnimating@@QAEXXZ:NEAR	; CBaseAnimating::ResetSequenceInfo
;	COMDAT ??_C@_0N@IMKA@standing_mp5?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_0N@IMKA@standing_mp5?$AA@ DB 'standing_mp5', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NMOD@crouching_mp5?$AA@
CONST	SEGMENT
??_C@_0O@NMOD@crouching_mp5?$AA@ DB 'crouching_mp5', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DCBE@standing_shotgun?$AA@
CONST	SEGMENT
??_C@_0BB@DCBE@standing_shotgun?$AA@ DB 'standing_shotgun', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DIAD@crouching_shotgun?$AA@
CONST	SEGMENT
??_C@_0BC@DIAD@crouching_shotgun?$AA@ DB 'crouching_shotgun', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GDEM@throwgrenade?$AA@
CONST	SEGMENT
??_C@_0N@GDEM@throwgrenade?$AA@ DB 'throwgrenade', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@POID@launchgrenade?$AA@
CONST	SEGMENT
??_C@_0O@POID@launchgrenade?$AA@ DB 'launchgrenade', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FOLO@?$CFs?5has?5no?5sequence?5for?5act?3?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BP@FOLO@?$CFs?5has?5no?5sequence?5for?5act?3?$CFd?6?$AA@ DB '%s ha'
	DB	's no sequence for act:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?SetActivity@CHGrunt@@UAEXW4Activity@@@Z
_TEXT	SEGMENT
_NewActivity$ = 8
_this$ = -4
_iSequence$ = -8
_pmodel$ = -12
?SetActivity@CHGrunt@@UAEXW4Activity@@@Z PROC NEAR	; CHGrunt::SetActivity, COMDAT

; 1872 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1873 : 	int	iSequence = ACTIVITY_NOT_AVAILABLE;

	mov	DWORD PTR _iSequence$[ebp], -1

; 1874 : 	void *pmodel = GET_MODEL_PTR( ENT(pev) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+296
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax

; 1877 : 	{

	mov	edx, DWORD PTR _NewActivity$[ebp]
	mov	DWORD PTR -16+[ebp], edx
	mov	eax, DWORD PTR -16+[ebp]
	sub	eax, 1
	mov	DWORD PTR -16+[ebp], eax
	cmp	DWORD PTR -16+[ebp], 28			; 0000001cH
	ja	$L39140
	mov	edx, DWORD PTR -16+[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR $L40429[edx]
	jmp	DWORD PTR $L40430[ecx*4]
$L39116:

; 1878 : 	case ACT_RANGE_ATTACK1:
; 1879 : 		// grunt is either shooting standing or shooting crouched
; 1880 : 		if (HasWeapon( HGRUNT_9MMAR ))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L39117

; 1882 : 			if ( m_fStanding )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2480], 0
	je	SHORT $L39118

; 1884 : 				// get aimable sequence
; 1885 : 				iSequence = LookupSequence( "standing_mp5" );

	push	OFFSET FLAT:??_C@_0N@IMKA@standing_mp5?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupSequence@CBaseAnimating@@QAEHPBD@Z ; CBaseAnimating::LookupSequence
	mov	DWORD PTR _iSequence$[ebp], eax

; 1887 : 			else

	jmp	SHORT $L39120
$L39118:

; 1889 : 				// get crouching shoot
; 1890 : 				iSequence = LookupSequence( "crouching_mp5" );

	push	OFFSET FLAT:??_C@_0O@NMOD@crouching_mp5?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupSequence@CBaseAnimating@@QAEHPBD@Z ; CBaseAnimating::LookupSequence
	mov	DWORD PTR _iSequence$[ebp], eax
$L39120:

; 1893 : 		else

	jmp	SHORT $L39125
$L39117:

; 1895 : 			if ( m_fStanding )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2480], 0
	je	SHORT $L39123

; 1897 : 				// get aimable sequence
; 1898 : 				iSequence = LookupSequence( "standing_shotgun" );

	push	OFFSET FLAT:??_C@_0BB@DCBE@standing_shotgun?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupSequence@CBaseAnimating@@QAEHPBD@Z ; CBaseAnimating::LookupSequence
	mov	DWORD PTR _iSequence$[ebp], eax

; 1900 : 			else

	jmp	SHORT $L39125
$L39123:

; 1902 : 				// get crouching shoot
; 1903 : 				iSequence = LookupSequence( "crouching_shotgun" );

	push	OFFSET FLAT:??_C@_0BC@DIAD@crouching_shotgun?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupSequence@CBaseAnimating@@QAEHPBD@Z ; CBaseAnimating::LookupSequence
	mov	DWORD PTR _iSequence$[ebp], eax
$L39125:

; 1906 : 		break;

	jmp	$L39113
$L39127:

; 1907 : 	case ACT_RANGE_ATTACK2:
; 1908 : 		// grunt is going to a secondary long range attack. This may be a thrown 
; 1909 : 		// grenade or fired grenade, we must determine which and pick proper sequence
; 1910 : 		if ( HasWeapon( HGRUNT_HANDGRENADE ))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L39128

; 1912 : 			// get toss anim
; 1913 : 			iSequence = LookupSequence( "throwgrenade" );

	push	OFFSET FLAT:??_C@_0N@GDEM@throwgrenade?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupSequence@CBaseAnimating@@QAEHPBD@Z ; CBaseAnimating::LookupSequence
	mov	DWORD PTR _iSequence$[ebp], eax

; 1915 : 		else

	jmp	SHORT $L39130
$L39128:

; 1917 : 			// get launch anim
; 1918 : 			iSequence = LookupSequence( "launchgrenade" );

	push	OFFSET FLAT:??_C@_0O@POID@launchgrenade?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupSequence@CBaseAnimating@@QAEHPBD@Z ; CBaseAnimating::LookupSequence
	mov	DWORD PTR _iSequence$[ebp], eax
$L39130:

; 1920 : 		break;

	jmp	$L39113
$L39132:

; 1921 : 	case ACT_RUN:
; 1922 : 		if ( pev->health <= HGRUNT_LIMP_HEALTH )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@4003a000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39133

; 1924 : 			// limp!
; 1925 : 			iSequence = LookupActivity ( ACT_RUN_HURT );

	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	DWORD PTR _iSequence$[ebp], eax

; 1927 : 		else

	jmp	SHORT $L39134
$L39133:

; 1929 : 			iSequence = LookupActivity ( NewActivity );

	mov	ecx, DWORD PTR _NewActivity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	DWORD PTR _iSequence$[ebp], eax
$L39134:

; 1931 : 		break;

	jmp	SHORT $L39113
$L39135:

; 1932 : 	case ACT_WALK:
; 1933 : 		if ( pev->health <= HGRUNT_LIMP_HEALTH )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@4003a000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39136

; 1935 : 			// limp!
; 1936 : 			iSequence = LookupActivity ( ACT_WALK_HURT );

	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	DWORD PTR _iSequence$[ebp], eax

; 1938 : 		else

	jmp	SHORT $L39137
$L39136:

; 1940 : 			iSequence = LookupActivity ( NewActivity );

	mov	ecx, DWORD PTR _NewActivity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	DWORD PTR _iSequence$[ebp], eax
$L39137:

; 1942 : 		break;

	jmp	SHORT $L39113
$L39138:

; 1943 : 	case ACT_IDLE:
; 1944 : 		if ( m_MonsterState == MONSTERSTATE_COMBAT )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2080], 2
	jne	SHORT $L39139

; 1946 : 			NewActivity = ACT_IDLE_ANGRY;

	mov	DWORD PTR _NewActivity$[ebp], 47	; 0000002fH
$L39139:

; 1948 : 		iSequence = LookupActivity ( NewActivity );

	mov	eax, DWORD PTR _NewActivity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	DWORD PTR _iSequence$[ebp], eax

; 1949 : 		break;

	jmp	SHORT $L39113
$L39140:

; 1950 : 	default:
; 1951 : 		iSequence = LookupActivity ( NewActivity );

	mov	ecx, DWORD PTR _NewActivity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	DWORD PTR _iSequence$[ebp], eax
$L39113:

; 1954 : 	
; 1955 : 	m_Activity = NewActivity; // Go ahead and set this so it doesn't keep trying when the anim is not present

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _NewActivity$[ebp]
	mov	DWORD PTR [edx+2068], eax

; 1956 : 
; 1957 : 	// Set to the desired anim, or default anim if the desired is not present
; 1958 : 	if ( iSequence > ACTIVITY_NOT_AVAILABLE )

	cmp	DWORD PTR _iSequence$[ebp], -1
	jle	SHORT $L39141

; 1960 : 		if ( pev->sequence != iSequence || !m_fSequenceLoops )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+296]
	cmp	eax, DWORD PTR _iSequence$[ebp]
	jne	SHORT $L39143
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1808], 0
	jne	SHORT $L39142
$L39143:

; 1962 : 			pev->frame = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+304], 0
$L39142:

; 1964 : 
; 1965 : 		pev->sequence		= iSequence;	// Set to the reset anim (if it's there)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _iSequence$[ebp]
	mov	DWORD PTR [edx+296], eax

; 1966 : 		ResetSequenceInfo( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetSequenceInfo@CBaseAnimating@@QAEXXZ ; CBaseAnimating::ResetSequenceInfo

; 1967 : 		SetYawSpeed();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+500]

; 1969 : 	else

	jmp	SHORT $L39144
$L39141:

; 1971 : 		// Not available try to get default anim
; 1972 : 		ALERT ( at_console, "%s has no sequence for act:%d\n", STRING(pev->classname), NewActivity );

	mov	eax, DWORD PTR _NewActivity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BP@FOLO@?$CFs?5has?5no?5sequence?5for?5act?3?$CFd?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 1973 : 		pev->sequence		= 0;	// Set to the reset anim (if it's there)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+296], 0
$L39144:

; 1975 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L40430:
	DD	$L39138
	DD	$L39135
	DD	$L39132
	DD	$L39116
	DD	$L39127
	DD	$L39140
$L40429:
	DB	0
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
?SetActivity@CHGrunt@@UAEXW4Activity@@@Z ENDP		; CHGrunt::SetActivity
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GetSchedule@CHGrunt@@UAEPAUSchedule_t@@XZ@4FA ; `CHGrunt::GetSchedule'::`2'::__LINE__Var
PUBLIC	??_C@_0CI@MECP@z?3?2xashxtsrc?2server?2monsters?2hgr@ ; `string'
PUBLIC	??_C@_0P@OOBL@pSound?5?$CB?$DN?5NULL?$AA@	; `string'
PUBLIC	??_C@_08FJCJ@HG_MONST?$AA@			; `string'
PUBLIC	?GetSchedule@CHGrunt@@UAEPAUSchedule_t@@XZ	; CHGrunt::GetSchedule
PUBLIC	?IsLeader@CSquadMonster@@QAEHXZ			; CSquadMonster::IsLeader
EXTRN	?DBG_AssertFunction@@YAXHPBD0H0@Z:NEAR		; DBG_AssertFunction
EXTRN	?OccupySlot@CSquadMonster@@QAEHH@Z:NEAR		; CSquadMonster::OccupySlot
EXTRN	?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ:NEAR ; CBaseMonster::GetSchedule
;	COMDAT ?__LINE__Var@?1??GetSchedule@CHGrunt@@UAEPAUSchedule_t@@XZ@4FA
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
_DATA	SEGMENT
?__LINE__Var@?1??GetSchedule@CHGrunt@@UAEPAUSchedule_t@@XZ@4FA DW 07bdH ; `CHGrunt::GetSchedule'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CI@MECP@z?3?2xashxtsrc?2server?2monsters?2hgr@
CONST	SEGMENT
??_C@_0CI@MECP@z?3?2xashxtsrc?2server?2monsters?2hgr@ DB 'z:\xashxtsrc\se'
	DB	'rver\monsters\hgrunt.cpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OOBL@pSound?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0P@OOBL@pSound?5?$CB?$DN?5NULL?$AA@ DB 'pSound != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJCJ@HG_MONST?$AA@
CONST	SEGMENT
??_C@_08FJCJ@HG_MONST?$AA@ DB 'HG_MONST', 00H		; `string'
CONST	ENDS
;	COMDAT ?GetSchedule@CHGrunt@@UAEPAUSchedule_t@@XZ
_TEXT	SEGMENT
_this$ = -4
_pSound$39156 = -8
_iPercent$39190 = -12
?GetSchedule@CHGrunt@@UAEPAUSchedule_t@@XZ PROC NEAR	; CHGrunt::GetSchedule, COMDAT

; 1981 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1982 : 
; 1983 : 	// clear old sentence
; 1984 : 	m_iSentence = HGRUNT_SENT_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2504], -1

; 1985 : 
; 1986 : 	// flying? If PRONE, barnacle has me. IF not, it's assumed I am rapelling. 
; 1987 : 	if ( pev->movetype == MOVETYPE_FLY && m_MonsterState != MONSTERSTATE_PRONE )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 5
	jne	SHORT $L39154
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2080], 5
	je	SHORT $L39154

; 1989 : 		if (pev->flags & FL_ONGROUND)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $L39151

; 1991 : 			// just landed
; 1992 : 			pev->movetype = MOVETYPE_STEP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+264], 4

; 1993 : 			return GetScheduleOfType ( SCHED_GRUNT_REPEL_LAND );

	push	50					; 00000032H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39151:

; 1997 : 			// repel down a rope, 
; 1998 : 			if ( m_MonsterState == MONSTERSTATE_COMBAT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2080], 2
	jne	SHORT $L39153

; 1999 : 				return GetScheduleOfType ( SCHED_GRUNT_REPEL_ATTACK );

	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39153:

; 2001 : 				return GetScheduleOfType ( SCHED_GRUNT_REPEL );

	push	48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39154:

; 2004 : 
; 2005 : 	// grunts place HIGH priority on running away from danger sounds.
; 2006 : 	if ( HasConditions(bits_COND_HEAR_SOUND) )

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	$L39161

; 2008 : 		CSound *pSound;
; 2009 : 		pSound = PBestSound();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+544]
	mov	DWORD PTR _pSound$39156[ebp], eax

; 2010 : 
; 2011 : 		ASSERT( pSound != NULL );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??GetSchedule@CHGrunt@@UAEPAUSchedule_t@@XZ@4FA ; `CHGrunt::GetSchedule'::`2'::__LINE__Var
	add	eax, 30					; 0000001eH
	push	eax
	push	OFFSET FLAT:??_C@_0CI@MECP@z?3?2xashxtsrc?2server?2monsters?2hgr@ ; `string'
	push	OFFSET FLAT:??_C@_0P@OOBL@pSound?5?$CB?$DN?5NULL?$AA@ ; `string'
	xor	ecx, ecx
	cmp	DWORD PTR _pSound$39156[ebp], 0
	setne	cl
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 2012 : 		if ( pSound)

	cmp	DWORD PTR _pSound$39156[ebp], 0
	je	SHORT $L39161

; 2014 : 			if (pSound->m_iType & bits_SOUND_DANGER)

	mov	edx, DWORD PTR _pSound$39156[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $L39161

; 2016 : 				// dangerous sound nearby!
; 2017 : 				
; 2018 : 				//!!!KELLY - currently, this is the grunt's signal that a grenade has landed nearby,
; 2019 : 				// and the grunt should find cover from the blast
; 2020 : 				// good place for "SHIT!" or some other colorful verbal indicator of dismay.
; 2021 : 				// It's not safe to play a verbal order here "Scatter", etc cause 
; 2022 : 				// this may only affect a single individual in a squad. 
; 2023 : 				
; 2024 : 				if (FOkToSpeak())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CHGrunt@@QAEHXZ		; CHGrunt::FOkToSpeak
	test	eax, eax
	je	SHORT $L39162

; 2026 : 					SENTENCEG_PlayRndSz( ENT(pev), "HG_GREN", HGRUNT_SENTENCE_VOLUME, GRUNT_ATTN, 0, m_voicePitch);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2492]
	push	edx
	push	0
	push	1061997773				; 3f4ccccdH
	push	1051931443				; 3eb33333H
	push	OFFSET FLAT:??_C@_07HNAE@HG_GREN?$AA@	; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H

; 2027 : 					JustSpoke();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JustSpoke@CHGrunt@@QAEXXZ		; CHGrunt::JustSpoke
$L39162:

; 2029 : 				return GetScheduleOfType( SCHED_TAKE_COVER_FROM_BEST_SOUND );

	push	19					; 00000013H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+448]
	jmp	$L39149
$L39161:

; 2040 : 	{

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2080]
	mov	DWORD PTR -16+[ebp], edx
	cmp	DWORD PTR -16+[ebp], 2
	je	SHORT $L39169
	jmp	$L39166
$L39169:

; 2043 : // dead enemy
; 2044 : 			if ( HasConditions( bits_COND_ENEMY_DEAD ) )

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L39170

; 2046 : 				// call base class, all code to handle dead enemies is centralized there.
; 2047 : 				return CBaseMonster :: GetSchedule();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ ; CBaseMonster::GetSchedule
	jmp	$L39149
$L39170:

; 2049 : 
; 2050 : // new enemy
; 2051 : 			if ( HasConditions(bits_COND_NEW_ENEMY) )

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	$L39171

; 2053 : 				if ( InSquad() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	je	$L39185

; 2055 : 					MySquadLeader()->m_fEnemyEluded = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	DWORD PTR [eax+2444], 0

; 2056 : 
; 2057 : 					if ( !IsLeader() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLeader@CSquadMonster@@QAEHXZ		; CSquadMonster::IsLeader
	test	eax, eax
	jne	SHORT $L39173

; 2059 : 						return GetScheduleOfType ( SCHED_TAKE_COVER_FROM_ENEMY );

	push	18					; 00000012H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39173:

; 2063 : 						//!!!KELLY - the leader of a squad of grunts has just seen the player or a 
; 2064 : 						// monster and has made it the squad's enemy. You
; 2065 : 						// can check pev->flags for FL_CLIENT to determine whether this is the player
; 2066 : 						// or a monster. He's going to immediately start
; 2067 : 						// firing, though. If you'd like, we can make an alternate "first sight" 
; 2068 : 						// schedule where the leader plays a handsign anim
; 2069 : 						// that gives us enough time to hear a short sentence or spoken command
; 2070 : 						// before he starts pluggin away.
; 2071 : 						if (FOkToSpeak())// && RANDOM_LONG(0,1))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CHGrunt@@QAEHXZ		; CHGrunt::FOkToSpeak
	test	eax, eax
	je	$L39175

; 2073 : 							if ((m_hEnemy != NULL) && m_hEnemy->IsPlayer())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39176
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -20+[ebp], eax
	mov	eax, DWORD PTR -20+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -20+[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L39176

; 2074 : 								// player
; 2075 : 								SENTENCEG_PlayRndSz( ENT(pev), "HG_ALERT", HGRUNT_SENTENCE_VOLUME, GRUNT_ATTN, 0, m_voicePitch);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2492]
	push	ecx
	push	0
	push	1061997773				; 3f4ccccdH
	push	1051931443				; 3eb33333H
	push	OFFSET FLAT:??_C@_08MHEE@HG_ALERT?$AA@	; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H

; 2076 : 							else if ((m_hEnemy != NULL) &&

	jmp	$L39180
$L39176:

; 2077 : 									(m_hEnemy->Classify() != CLASS_PLAYER_ALLY) && 
; 2078 : 									(m_hEnemy->Classify() != CLASS_HUMAN_PASSIVE) && 
; 2079 : 									(m_hEnemy->Classify() != CLASS_MACHINE))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	$L39180
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -24+[ebp], eax
	mov	ecx, DWORD PTR -24+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -24+[ebp]
	call	DWORD PTR [edx+68]
	cmp	eax, 11					; 0000000bH
	je	SHORT $L39180
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -28+[ebp], eax
	mov	eax, DWORD PTR -28+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -28+[ebp]
	call	DWORD PTR [edx+68]
	cmp	eax, 3
	je	SHORT $L39180
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -32+[ebp], eax
	mov	eax, DWORD PTR -32+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -32+[ebp]
	call	DWORD PTR [edx+68]
	cmp	eax, 1
	je	SHORT $L39180

; 2080 : 								// monster
; 2081 : 								SENTENCEG_PlayRndSz( ENT(pev), "HG_MONST", HGRUNT_SENTENCE_VOLUME, GRUNT_ATTN, 0, m_voicePitch);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2492]
	push	ecx
	push	0
	push	1061997773				; 3f4ccccdH
	push	1051931443				; 3eb33333H
	push	OFFSET FLAT:??_C@_08FJCJ@HG_MONST?$AA@	; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H
$L39180:

; 2082 : 
; 2083 : 							JustSpoke();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JustSpoke@CHGrunt@@QAEXXZ		; CHGrunt::JustSpoke
$L39175:

; 2085 : 						
; 2086 : 						if ( HasConditions ( bits_COND_CAN_RANGE_ATTACK1 ) )

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L39184

; 2088 : 							return GetScheduleOfType ( SCHED_GRUNT_SUPPRESS );

	push	43					; 0000002bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39184:

; 2092 : 							return GetScheduleOfType ( SCHED_GRUNT_ESTABLISH_LINE_OF_FIRE );

	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39185:

; 2097 : // no ammo
; 2098 : 			else if ( HasConditions ( bits_COND_NO_AMMO_LOADED ) )

	jmp	$L39215
$L39171:
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L39187

; 2100 : 				//!!!KELLY - this individual just realized he's out of bullet ammo. 
; 2101 : 				// He's going to try to find cover to run to and reload, but rarely, if 
; 2102 : 				// none is available, he'll drop and reload in the open here. 
; 2103 : 				return GetScheduleOfType ( SCHED_GRUNT_COVER_AND_RELOAD );

	push	45					; 0000002dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39187:

; 2105 : 			
; 2106 : // damaged just a little
; 2107 : 			else if ( HasConditions( bits_COND_LIGHT_DAMAGE ) )

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L39189

; 2109 : 				// if hurt:
; 2110 : 				// 90% chance of taking cover
; 2111 : 				// 10% chance of flinch.
; 2112 : 				int iPercent = RANDOM_LONG(0,99);

	push	99					; 00000063H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR _iPercent$39190[ebp], eax

; 2113 : 
; 2114 : 				if ( iPercent <= 90 && m_hEnemy != NULL )

	cmp	DWORD PTR _iPercent$39190[ebp], 90	; 0000005aH
	jg	SHORT $L39191
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39191

; 2116 : 					// only try to take cover if we actually have an enemy!
; 2117 : 
; 2118 : 					//!!!KELLY - this grunt was hit and is going to run to cover.
; 2119 : 					if (FOkToSpeak()) // && RANDOM_LONG(0,1))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CHGrunt@@QAEHXZ		; CHGrunt::FOkToSpeak
	test	eax, eax
	je	SHORT $L39192

; 2121 : 						//SENTENCEG_PlayRndSz( ENT(pev), "HG_COVER", HGRUNT_SENTENCE_VOLUME, GRUNT_ATTN, 0, m_voicePitch);
; 2122 : 						m_iSentence = HGRUNT_SENT_COVER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2504], 3
$L39192:

; 2125 : 					return GetScheduleOfType( SCHED_TAKE_COVER_FROM_ENEMY );

	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39191:

; 2129 : 					return GetScheduleOfType( SCHED_SMALL_FLINCH );

	push	17					; 00000011H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39189:

; 2132 : // can kick
; 2133 : 			else if ( HasConditions ( bits_COND_CAN_MELEE_ATTACK1 ) )

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L39195

; 2135 : 				return GetScheduleOfType ( SCHED_MELEE_ATTACK1 );

	push	22					; 00000016H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39195:

; 2137 : // can grenade launch
; 2138 : 
; 2139 : 			else if ( HasWeapon( HGRUNT_GRENADELAUNCHER ) && HasConditions ( bits_COND_CAN_RANGE_ATTACK2 ) && OccupySlot( bits_SLOTS_HGRUNT_GRENADE ) )

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L39197
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L39197
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OccupySlot@CSquadMonster@@QAEHH@Z	; CSquadMonster::OccupySlot
	test	eax, eax
	je	SHORT $L39197

; 2141 : 				// shoot a grenade if you can
; 2142 : 				return GetScheduleOfType( SCHED_RANGE_ATTACK2 );

	push	25					; 00000019H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39197:

; 2144 : // can shoot
; 2145 : 			else if ( HasConditions ( bits_COND_CAN_RANGE_ATTACK1 ) )

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	$L39199

; 2147 : 				if ( InSquad() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	je	SHORT $L39201

; 2149 : 					// if the enemy has eluded the squad and a squad member has just located the enemy
; 2150 : 					// and the enemy does not see the squad member, issue a call to the squad to waste a 
; 2151 : 					// little time and give the player a chance to turn.
; 2152 : 					if ( MySquadLeader()->m_fEnemyEluded && !HasConditions ( bits_COND_ENEMY_FACING_ME ) )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	cmp	DWORD PTR [eax+2444], 0
	je	SHORT $L39201
	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	jne	SHORT $L39201

; 2154 : 						MySquadLeader()->m_fEnemyEluded = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	DWORD PTR [eax+2444], 0

; 2155 : 						return GetScheduleOfType ( SCHED_GRUNT_FOUND_ENEMY );

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39201:

; 2158 : 
; 2159 : 				if ( OccupySlot ( bits_SLOTS_HGRUNT_ENGAGE ) )

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OccupySlot@CSquadMonster@@QAEHH@Z	; CSquadMonster::OccupySlot
	test	eax, eax
	je	SHORT $L39202

; 2161 : 					// try to take an available ENGAGE slot
; 2162 : 					return GetScheduleOfType( SCHED_RANGE_ATTACK1 );

	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39202:

; 2164 : 				else if ( HasConditions ( bits_COND_CAN_RANGE_ATTACK2 ) && OccupySlot( bits_SLOTS_HGRUNT_GRENADE ) )

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L39204
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OccupySlot@CSquadMonster@@QAEHH@Z	; CSquadMonster::OccupySlot
	test	eax, eax
	je	SHORT $L39204

; 2166 : 					// throw a grenade if can and no engage slots are available
; 2167 : 					return GetScheduleOfType( SCHED_RANGE_ATTACK2 );

	push	25					; 00000019H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39204:

; 2171 : 					// hide!
; 2172 : 					return GetScheduleOfType( SCHED_TAKE_COVER_FROM_ENEMY );

	push	18					; 00000012H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39199:

; 2175 : // can't see enemy
; 2176 : 			else if ( HasConditions( bits_COND_ENEMY_OCCLUDED ) )

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	$L39215

; 2178 : 				if ( HasConditions( bits_COND_CAN_RANGE_ATTACK2 ) && OccupySlot( bits_SLOTS_HGRUNT_GRENADE ) )

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L39208
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OccupySlot@CSquadMonster@@QAEHH@Z	; CSquadMonster::OccupySlot
	test	eax, eax
	je	SHORT $L39208

; 2180 : 					//!!!KELLY - this grunt is about to throw or fire a grenade at the player. Great place for "fire in the hole"  "frag out" etc
; 2181 : 					if (FOkToSpeak())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CHGrunt@@QAEHXZ		; CHGrunt::FOkToSpeak
	test	eax, eax
	je	SHORT $L39209

; 2183 : 						SENTENCEG_PlayRndSz( ENT(pev), "HG_THROW", HGRUNT_SENTENCE_VOLUME, GRUNT_ATTN, 0, m_voicePitch);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2492]
	push	ecx
	push	0
	push	1061997773				; 3f4ccccdH
	push	1051931443				; 3eb33333H
	push	OFFSET FLAT:??_C@_08IDKG@HG_THROW?$AA@	; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H

; 2184 : 						JustSpoke();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JustSpoke@CHGrunt@@QAEXXZ		; CHGrunt::JustSpoke
$L39209:

; 2186 : 					return GetScheduleOfType( SCHED_RANGE_ATTACK2 );

	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39208:

; 2188 : 				else if ( OccupySlot( bits_SLOTS_HGRUNT_ENGAGE ) )

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OccupySlot@CSquadMonster@@QAEHH@Z	; CSquadMonster::OccupySlot
	test	eax, eax
	je	SHORT $L39213

; 2190 : 					//!!!KELLY - grunt cannot see the enemy and has just decided to 
; 2191 : 					// charge the enemy's position. 
; 2192 : 					if (FOkToSpeak())// && RANDOM_LONG(0,1))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CHGrunt@@QAEHXZ		; CHGrunt::FOkToSpeak
	test	eax, eax
	je	SHORT $L39214

; 2194 : 						//SENTENCEG_PlayRndSz( ENT(pev), "HG_CHARGE", HGRUNT_SENTENCE_VOLUME, GRUNT_ATTN, 0, m_voicePitch);
; 2195 : 						m_iSentence = HGRUNT_SENT_CHARGE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2504], 5
$L39214:

; 2198 : 
; 2199 : 					return GetScheduleOfType( SCHED_GRUNT_ESTABLISH_LINE_OF_FIRE );

	push	44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39149
$L39213:

; 2203 : 					//!!!KELLY - grunt is going to stay put for a couple seconds to see if
; 2204 : 					// the enemy wanders back out into the open, or approaches the
; 2205 : 					// grunt's covered position. Good place for a taunt, I guess?
; 2206 : 					if (FOkToSpeak() && RANDOM_LONG(0,1))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CHGrunt@@QAEHXZ		; CHGrunt::FOkToSpeak
	test	eax, eax
	je	SHORT $L39216
	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	je	SHORT $L39216

; 2208 : 						SENTENCEG_PlayRndSz( ENT(pev), "HG_TAUNT", HGRUNT_SENTENCE_VOLUME, GRUNT_ATTN, 0, m_voicePitch);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2492]
	push	ecx
	push	0
	push	1061997773				; 3f4ccccdH
	push	1051931443				; 3eb33333H
	push	OFFSET FLAT:??_C@_08NLBG@HG_TAUNT?$AA@	; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H

; 2209 : 						JustSpoke();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JustSpoke@CHGrunt@@QAEXXZ		; CHGrunt::JustSpoke
$L39216:

; 2211 : 					return GetScheduleOfType( SCHED_STANDOFF );

	push	28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	SHORT $L39149
$L39215:

; 2214 : 			
; 2215 : 			if ( HasConditions( bits_COND_SEE_ENEMY ) && !HasConditions ( bits_COND_CAN_RANGE_ATTACK1 ) )

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L39219
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	jne	SHORT $L39219

; 2217 : 				return GetScheduleOfType ( SCHED_GRUNT_ESTABLISH_LINE_OF_FIRE );

	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	SHORT $L39149
$L39219:
$L39166:

; 2221 : 	
; 2222 : 	// no special cases here, call the base class
; 2223 : 	return CSquadMonster :: GetSchedule();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ ; CBaseMonster::GetSchedule
$L39149:

; 2224 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSchedule@CHGrunt@@UAEPAUSchedule_t@@XZ ENDP		; CHGrunt::GetSchedule
_TEXT	ENDS
;	COMDAT ?IsLeader@CSquadMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsLeader@CSquadMonster@@QAEHXZ PROC NEAR		; CSquadMonster::IsLeader, COMDAT

; 94   : 	int IsLeader ( void ) { return m_hSquadLeader == this; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2396				; 0000095cH
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	xor	ecx, ecx
	cmp	eax, DWORD PTR _this$[ebp]
	sete	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLeader@CSquadMonster@@QAEHXZ ENDP			; CSquadMonster::IsLeader
_TEXT	ENDS
PUBLIC	?GetScheduleOfType@CHGrunt@@UAEPAUSchedule_t@@H@Z ; CHGrunt::GetScheduleOfType
PUBLIC	__real@4@c0068000000000000000
PUBLIC	__real@4@40048000000000000000
EXTRN	?GetScheduleOfType@CSquadMonster@@UAEPAUSchedule_t@@H@Z:NEAR ; CSquadMonster::GetScheduleOfType
;	COMDAT __real@4@c0068000000000000000
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
__real@4@c0068000000000000000 DD 0c3000000r	; -128
CONST	ENDS
;	COMDAT __real@4@40048000000000000000
CONST	SEGMENT
__real@4@40048000000000000000 DD 042000000r	; 32
CONST	ENDS
;	COMDAT ?GetScheduleOfType@CHGrunt@@UAEPAUSchedule_t@@H@Z
_TEXT	SEGMENT
_Type$ = 8
_this$ = -4
_vecVelocity$39262 = -16
_vecVelocity$39265 = -28
?GetScheduleOfType@CHGrunt@@UAEPAUSchedule_t@@H@Z PROC NEAR ; CHGrunt::GetScheduleOfType, COMDAT

; 2229 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2231 : 	{

	mov	eax, DWORD PTR _Type$[ebp]
	mov	DWORD PTR -32+[ebp], eax
	mov	ecx, DWORD PTR -32+[ebp]
	sub	ecx, 10					; 0000000aH
	mov	DWORD PTR -32+[ebp], ecx
	cmp	DWORD PTR -32+[ebp], 43			; 0000002bH
	ja	$L39268
	mov	eax, DWORD PTR -32+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L40441[eax]
	jmp	DWORD PTR $L40442[edx*4]
$L39228:

; 2234 : 			if ( InSquad() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	je	$L39229

; 2236 : 				if ( g_iSkillLevel == SKILL_HARD && HasConditions( bits_COND_CAN_RANGE_ATTACK2 ) && OccupySlot( bits_SLOTS_HGRUNT_GRENADE ) )

	cmp	DWORD PTR ?g_iSkillLevel@@3HA, 3	; g_iSkillLevel
	jne	SHORT $L39230
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L39230
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OccupySlot@CSquadMonster@@QAEHH@Z	; CSquadMonster::OccupySlot
	test	eax, eax
	je	SHORT $L39230

; 2238 : 					if (FOkToSpeak())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CHGrunt@@QAEHXZ		; CHGrunt::FOkToSpeak
	test	eax, eax
	je	SHORT $L39231

; 2240 : 						SENTENCEG_PlayRndSz( ENT(pev), "HG_THROW", HGRUNT_SENTENCE_VOLUME, GRUNT_ATTN, 0, m_voicePitch);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2492]
	push	edx
	push	0
	push	1061997773				; 3f4ccccdH
	push	1051931443				; 3eb33333H
	push	OFFSET FLAT:??_C@_08IDKG@HG_THROW?$AA@	; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H

; 2241 : 						JustSpoke();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JustSpoke@CHGrunt@@QAEXXZ		; CHGrunt::JustSpoke
$L39231:

; 2243 : 					return slGruntTossGrenadeCover;

	mov	eax, OFFSET FLAT:?slGruntTossGrenadeCover@@3PAUSchedule_t@@A ; slGruntTossGrenadeCover
	jmp	$L39225
$L39230:

; 2247 : 					return &slGruntTakeCover[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntTakeCover@@3PAUSchedule_t@@A ; slGruntTakeCover
	jmp	$L39225
$L39229:

; 2252 : 				if ( RANDOM_LONG(0,1) )

	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	je	SHORT $L39236

; 2254 : 					return &slGruntTakeCover[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntTakeCover@@3PAUSchedule_t@@A ; slGruntTakeCover
	jmp	$L39225
$L39236:

; 2258 : 					return &slGruntGrenadeCover[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntGrenadeCover@@3PAUSchedule_t@@A ; slGruntGrenadeCover
	jmp	$L39225
$L39237:

; 2264 : 			return &slGruntTakeCoverFromBestSound[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntTakeCoverFromBestSound@@3PAUSchedule_t@@A ; slGruntTakeCoverFromBestSound
	jmp	$L39225
$L39239:

; 2268 : 			if ( HasConditions( bits_COND_CAN_RANGE_ATTACK1 ) && OccupySlot( bits_SLOTS_HGRUNT_ENGAGE ) )

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L39240
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OccupySlot@CSquadMonster@@QAEHH@Z	; CSquadMonster::OccupySlot
	test	eax, eax
	je	SHORT $L39240

; 2270 : 				return GetScheduleOfType( SCHED_RANGE_ATTACK1 );

	push	24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+448]
	jmp	$L39225
$L39240:

; 2272 : 
; 2273 : 			return GetScheduleOfType ( SCHED_FAIL );

	push	41					; 00000029H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39225
$L39241:

; 2278 : 			// human grunt is unable to move to a position that allows him to attack the enemy.
; 2279 : 			return GetScheduleOfType ( SCHED_TAKE_COVER_FROM_ENEMY );

	push	18					; 00000012H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+448]
	jmp	$L39225
$L39242:

; 2284 : 			return &slGruntEstablishLineOfFire[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntEstablishLineOfFire@@3PAUSchedule_t@@A ; slGruntEstablishLineOfFire
	jmp	$L39225
$L39243:

; 2289 : 			// randomly stand or crouch
; 2290 : 			if (RANDOM_LONG(0,9) == 0)

	push	9
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	jne	SHORT $L39244

; 2291 : 				m_fStanding = RANDOM_LONG(0,1);

	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2480], eax
$L39244:

; 2292 : 		 
; 2293 : 			if (m_fStanding)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2480], 0
	je	SHORT $L39245

; 2294 : 				return &slGruntRangeAttack1B[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntRangeAttack1B@@3PAUSchedule_t@@A ; slGruntRangeAttack1B
	jmp	$L39225
$L39245:

; 2296 : 				return &slGruntRangeAttack1A[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntRangeAttack1A@@3PAUSchedule_t@@A ; slGruntRangeAttack1A
	jmp	$L39225
$L39246:

; 2300 : 			return &slGruntRangeAttack2[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntRangeAttack2@@3PAUSchedule_t@@A ; slGruntRangeAttack2
	jmp	$L39225
$L39248:

; 2304 : 			return &slGruntCombatFace[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntCombatFace@@3PAUSchedule_t@@A ; slGruntCombatFace
	jmp	$L39225
$L39249:

; 2308 : 			return &slGruntWaitInCover[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntWaitInCover@@3PAUSchedule_t@@A ; slGruntWaitInCover
	jmp	$L39225
$L39250:

; 2312 : 			return &slGruntSweep[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntSweep@@3PAUSchedule_t@@A ; slGruntSweep
	jmp	$L39225
$L39251:

; 2316 : 			return &slGruntHideReload[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntHideReload@@3PAUSchedule_t@@A ; slGruntHideReload
	jmp	$L39225
$L39252:

; 2320 : 			return &slGruntFoundEnemy[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntFoundEnemy@@3PAUSchedule_t@@A ; slGruntFoundEnemy
	jmp	$L39225
$L39253:

; 2324 : 			if ( InSquad() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	je	SHORT $L39255

; 2326 : 				if ( !IsLeader() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLeader@CSquadMonster@@QAEHXZ		; CSquadMonster::IsLeader
	test	eax, eax
	jne	SHORT $L39255

; 2328 : 					return &slGruntFail[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntFail@@3PAUSchedule_t@@A ; slGruntFail
	jmp	$L39225
$L39255:

; 2331 : 
; 2332 : 			return &slGruntVictoryDance[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntVictoryDance@@3PAUSchedule_t@@A ; slGruntVictoryDance
	jmp	$L39225
$L39256:

; 2336 : 			if ( m_hEnemy->IsPlayer() && m_fFirstEncounter )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -36+[ebp], eax
	mov	eax, DWORD PTR -36+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -36+[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L39257
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2484], 0
	je	SHORT $L39257

; 2338 : 				m_fFirstEncounter = FALSE;// after first encounter, leader won't issue handsigns anymore when he has a new enemy

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2484], 0

; 2339 : 				return &slGruntSignalSuppress[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntSignalSuppress@@3PAUSchedule_t@@A ; slGruntSignalSuppress
	jmp	$L39225
$L39257:

; 2343 : 				return &slGruntSuppress[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntSuppress@@3PAUSchedule_t@@A ; slGruntSuppress
	jmp	$L39225
$L39258:

; 2348 : 			if ( m_hEnemy != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39260

; 2350 : 				// grunt has an enemy, so pick a different default fail schedule most likely to help recover.
; 2351 : 				return &slGruntCombatFail[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntCombatFail@@3PAUSchedule_t@@A ; slGruntCombatFail
	jmp	$L39225
$L39260:

; 2353 : 
; 2354 : 			return &slGruntFail[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntFail@@3PAUSchedule_t@@A ; slGruntFail
	jmp	$L39225
$L39261:

; 2358 : 			Vector vecVelocity = GetAbsVelocity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vecVelocity$39262[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2359 : 			if (vecVelocity.z > -128)

	fld	DWORD PTR _vecVelocity$39262[ebp+8]
	fcomp	DWORD PTR __real@4@c0068000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39263

; 2361 : 				vecVelocity.z -= 32;

	fld	DWORD PTR _vecVelocity$39262[ebp+8]
	fsub	DWORD PTR __real@4@40048000000000000000
	fstp	DWORD PTR _vecVelocity$39262[ebp+8]

; 2362 : 				SetAbsVelocity( vecVelocity );

	lea	edx, DWORD PTR _vecVelocity$39262[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L39263:

; 2364 : 			return &slGruntRepel[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntRepel@@3PAUSchedule_t@@A ; slGruntRepel
	jmp	SHORT $L39225
$L39264:

; 2368 : 			Vector vecVelocity = GetAbsVelocity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vecVelocity$39265[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2369 : 			if (vecVelocity.z > -128)

	fld	DWORD PTR _vecVelocity$39265[ebp+8]
	fcomp	DWORD PTR __real@4@c0068000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39266

; 2371 : 				vecVelocity.z -= 32;

	fld	DWORD PTR _vecVelocity$39265[ebp+8]
	fsub	DWORD PTR __real@4@40048000000000000000
	fstp	DWORD PTR _vecVelocity$39265[ebp+8]

; 2372 : 				SetAbsVelocity( vecVelocity );

	lea	eax, DWORD PTR _vecVelocity$39265[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L39266:

; 2374 : 			return &slGruntRepelAttack[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntRepelAttack@@3PAUSchedule_t@@A ; slGruntRepelAttack
	jmp	SHORT $L39225
$L39267:

; 2378 : 			return &slGruntRepelLand[ 0 ];

	mov	eax, OFFSET FLAT:?slGruntRepelLand@@3PAUSchedule_t@@A ; slGruntRepelLand
	jmp	SHORT $L39225
$L39268:

; 2382 : 			return CSquadMonster :: GetScheduleOfType ( Type );

	mov	ecx, DWORD PTR _Type$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetScheduleOfType@CSquadMonster@@UAEPAUSchedule_t@@H@Z ; CSquadMonster::GetScheduleOfType
$L39225:

; 2385 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L40442:
	DD	$L39248
	DD	$L39253
	DD	$L39228
	DD	$L39237
	DD	$L39243
	DD	$L39246
	DD	$L39258
	DD	$L39256
	DD	$L39242
	DD	$L39251
	DD	$L39250
	DD	$L39252
	DD	$L39261
	DD	$L39264
	DD	$L39267
	DD	$L39249
	DD	$L39239
	DD	$L39241
	DD	$L39268
$L40441:
	DB	0
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	1
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	2
	DB	3
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	4
	DB	5
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	6
	DB	18					; 00000012H
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
?GetScheduleOfType@CHGrunt@@UAEPAUSchedule_t@@H@Z ENDP	; CHGrunt::GetScheduleOfType
_TEXT	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT
_$E48	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E47
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E48	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCHGruntRepel@@@@QAE@PBD@Z	; CEntityFactory<CHGruntRepel>::CEntityFactory<CHGruntRepel>
PUBLIC	??_C@_0BE@LFFA@monster_grunt_repel?$AA@		; `string'
_BSS	SEGMENT
	ALIGN	4

_monster_grunt_repel DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BE@LFFA@monster_grunt_repel?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_0BE@LFFA@monster_grunt_repel?$AA@ DB 'monster_grunt_repel', 00H ; `string'
CONST	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT
_$E47	PROC NEAR					; COMDAT

; 2403 : LINK_ENTITY_TO_CLASS( monster_grunt_repel, CHGruntRepel );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BE@LFFA@monster_grunt_repel?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_monster_grunt_repel
	call	??0?$CEntityFactory@VCHGruntRepel@@@@QAE@PBD@Z ; CEntityFactory<CHGruntRepel>::CEntityFactory<CHGruntRepel>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E47	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CHGruntRepel@@UAEXXZ			; CHGruntRepel::Spawn
;	COMDAT ?Spawn@CHGruntRepel@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CHGruntRepel@@UAEXXZ PROC NEAR			; CHGruntRepel::Spawn, COMDAT

; 2406 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2407 : 	Precache( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 2408 : 	pev->solid = SOLID_NOT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 0

; 2409 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CHGruntRepel@@UAEXXZ ENDP			; CHGruntRepel::Spawn
_TEXT	ENDS
PUBLIC	?Precache@CHGruntRepel@@UAEXXZ			; CHGruntRepel::Precache
PUBLIC	??_C@_0BB@FHOL@sprites?1rope?4spr?$AA@		; `string'
EXTRN	?UTIL_PrecacheOther@@YAXPBD@Z:NEAR		; UTIL_PrecacheOther
;	COMDAT ??_C@_0BB@FHOL@sprites?1rope?4spr?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_0BB@FHOL@sprites?1rope?4spr?$AA@ DB 'sprites/rope.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ?Precache@CHGruntRepel@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CHGruntRepel@@UAEXXZ PROC NEAR		; CHGruntRepel::Precache, COMDAT

; 2412 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2413 : 	UTIL_PrecacheOther( "monster_human_grunt" );

	push	OFFSET FLAT:??_C@_0BE@HADJ@monster_human_grunt?$AA@ ; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 2414 : 	m_iSpriteTexture = PRECACHE_MODEL( "sprites/rope.spr" );

	push	OFFSET FLAT:??_C@_0BB@FHOL@sprites?1rope?4spr?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2396], eax

; 2415 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CHGruntRepel@@UAEXXZ ENDP			; CHGruntRepel::Precache
_TEXT	ENDS
PUBLIC	?SetFlags@CBeam@@QAEXH@Z			; CBeam::SetFlags
PUBLIC	?entindex@CBaseEntity@@QAEHXZ			; CBaseEntity::entindex
PUBLIC	?SetColor@CBeam@@QAEXHHH@Z			; CBeam::SetColor
PUBLIC	??_C@_0L@KHDH@SUB_Remove?$AA@			; `string'
PUBLIC	?Use@CHGruntRepel@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CHGruntRepel::Use
PUBLIC	__real@8@c00b8000000000000000
PUBLIC	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
EXTRN	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z:NEAR ; CBaseEntity::Create
EXTRN	?PointEntInit@CBeam@@QAEXABVVector@@H@Z:NEAR	; CBeam::PointEntInit
EXTRN	?BeamCreate@CBeam@@SAPAV1@PBDH@Z:NEAR		; CBeam::BeamCreate
EXTRN	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_Remove
EXTRN	?SUB_Remove@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::SUB_Remove
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_0L@KHDH@SUB_Remove?$AA@ DB 'SUB_Remove', 00H	; `string'
CONST	ENDS
;	COMDAT __real@8@c00b8000000000000000
CONST	SEGMENT
__real@8@c00b8000000000000000 DQ 0c0b0000000000000r ; -4096
CONST	ENDS
;	COMDAT ?Use@CHGruntRepel@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
_tr$ = -60
_pEntity$ = -64
_pGrunt$ = -68
_pBeam$ = -72
$T40453 = -84
$T40454 = -96
$T40455 = -108
$T40456 = -120
$T40457 = -132
?Use@CHGruntRepel@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CHGruntRepel::Use, COMDAT

; 2418 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2419 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 2420 : 	UTIL_TraceLine( GetAbsOrigin(), GetAbsOrigin() + Vector( 0, 0, -4096.0), dont_ignore_monsters, ENT(pev), &tr);

	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	0
	push	-981467136				; c5800000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T40453[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T40454[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 2421 : 	/*
; 2422 : 	if ( tr.pHit && Instance( tr.pHit )->pev->solid != SOLID_BSP) 
; 2423 : 		return NULL;
; 2424 : 	*/
; 2425 : 
; 2426 : 	CBaseEntity *pEntity = Create( "monster_human_grunt", GetAbsOrigin(), GetAbsAngles() );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	push	OFFSET FLAT:??_C@_0BE@HADJ@monster_human_grunt?$AA@ ; `string'
	call	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z ; CBaseEntity::Create
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pEntity$[ebp], eax

; 2427 : 	CBaseMonster *pGrunt = pEntity->MyMonsterPointer( );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+124]
	mov	DWORD PTR _pGrunt$[ebp], eax

; 2428 : 	pGrunt->pev->movetype = MOVETYPE_FLY;

	mov	eax, DWORD PTR _pGrunt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 5

; 2429 : 	pGrunt->SetAbsVelocity( Vector( 0, 0, RANDOM_FLOAT( -196, -128 ) ));

	push	-1023410176				; c3000000H
	push	-1018953728				; c3440000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	0
	push	0
	lea	ecx, DWORD PTR $T40455[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _pGrunt$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 2430 : 	pGrunt->SetActivity( ACT_GLIDE );

	push	51					; 00000033H
	mov	edx, DWORD PTR _pGrunt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pGrunt$[ebp]
	call	DWORD PTR [eax+484]

; 2431 : 	// UNDONE: position?
; 2432 : 	pGrunt->m_vecLastPosition = tr.vecEndPos;

	mov	ecx, DWORD PTR _pGrunt$[ebp]
	add	ecx, 2264				; 000008d8H
	mov	edx, DWORD PTR _tr$[ebp+20]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _tr$[ebp+24]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _tr$[ebp+28]
	mov	DWORD PTR [ecx+8], edx

; 2433 : 
; 2434 : 	CBeam *pBeam = CBeam::BeamCreate( "sprites/rope.spr", 10 );

	push	10					; 0000000aH
	push	OFFSET FLAT:??_C@_0BB@FHOL@sprites?1rope?4spr?$AA@ ; `string'
	call	?BeamCreate@CBeam@@SAPAV1@PBDH@Z	; CBeam::BeamCreate
	add	esp, 8
	mov	DWORD PTR _pBeam$[ebp], eax

; 2435 : 	pBeam->PointEntInit( GetAbsOrigin() + Vector( 0, 0, 112 ), pGrunt->entindex() );

	mov	ecx, DWORD PTR _pGrunt$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	push	eax
	push	1121976320				; 42e00000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T40456[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T40457[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _pBeam$[ebp]
	call	?PointEntInit@CBeam@@QAEXABVVector@@H@Z	; CBeam::PointEntInit

; 2436 : 	pBeam->SetFlags( BEAM_FSOLID );

	push	32					; 00000020H
	mov	ecx, DWORD PTR _pBeam$[ebp]
	call	?SetFlags@CBeam@@QAEXH@Z		; CBeam::SetFlags

; 2437 : 	pBeam->SetColor( 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	mov	ecx, DWORD PTR _pBeam$[ebp]
	call	?SetColor@CBeam@@QAEXHHH@Z		; CBeam::SetColor

; 2438 : 	pBeam->SetThink( SUB_Remove );

	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove
	mov	ecx, DWORD PTR _pBeam$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 2439 : 	pBeam->pev->nextthink = gpGlobals->time + -4096.0 * tr.flFraction / pGrunt->GetAbsVelocity().z + 0.5;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fstp	QWORD PTR -140+[ebp]
	fld	DWORD PTR _tr$[ebp+16]
	fmul	QWORD PTR __real@8@c00b8000000000000000
	fstp	QWORD PTR -148+[ebp]
	mov	ecx, DWORD PTR _pGrunt$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	fld	DWORD PTR [eax+8]
	fdivr	QWORD PTR -148+[ebp]
	fadd	QWORD PTR -140+[ebp]
	fadd	QWORD PTR __real@8@3ffe8000000000000000
	fst	DWORD PTR -152+[ebp]
	mov	edx, DWORD PTR _pBeam$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+260]

; 2440 : 
; 2441 : 	UTIL_Remove( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 2442 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CHGruntRepel@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CHGruntRepel::Use
_TEXT	ENDS
PUBLIC	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z	; CBaseEntity::FunctionCheck
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::ThinkSet, COMDAT

; 560  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 		m_pfnThink = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1744], ecx

; 562  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnThink)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1744]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 563  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 564  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP	; CBaseEntity::ThinkSet
_TEXT	ENDS
PUBLIC	??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:NEAR ; UTIL_FunctionToName
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ DB 'F'
	DB	'UNCTION NOT IN TABLE!: %s:%s (%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT
_this$ = -4
_pFunction$ = 8
_name$ = 12
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z PROC NEAR	; CBaseEntity::FunctionCheck, COMDAT

; 554  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 		if (pFunction && !UTIL_FunctionToName( GetDataDescMap(), pFunction ) )

	cmp	DWORD PTR _pFunction$[ebp], 0
	je	SHORT $L35063
	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	test	eax, eax
	jne	SHORT $L35063

; 556  : 			ALERT( at_warning, "FUNCTION NOT IN TABLE!: %s:%s (%08lx)\n", GetClassname(), name, (unsigned long)pFunction );

	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L35063:

; 557  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ENDP		; CBaseEntity::FunctionCheck
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
PUBLIC	?ENTINDEX@@YAHPAUedict_s@@@Z			; ENTINDEX
;	COMDAT ?entindex@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?entindex@CBaseEntity@@QAEHXZ PROC NEAR			; CBaseEntity::entindex, COMDAT

; 712  : 	int entindex( ) { return ENTINDEX( edict() ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?entindex@CBaseEntity@@QAEHXZ ENDP			; CBaseEntity::entindex
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT
_pEdict$ = 8
?ENTINDEX@@YAHPAUedict_s@@@Z PROC NEAR			; ENTINDEX, COMDAT

; 186  : inline int	  ENTINDEX(edict_t *pEdict)			{ return (*g_engfuncs.pfnIndexOfEdict)(pEdict); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+284
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENTINDEX@@YAHPAUedict_s@@@Z ENDP			; ENTINDEX
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
;	COMDAT ?SetFlags@CBeam@@QAEXH@Z
_TEXT	SEGMENT
_flags$ = 8
_this$ = -4
?SetFlags@CBeam@@QAEXH@Z PROC NEAR			; CBeam::SetFlags, COMDAT

; 135  : 	inline void SetFlags( int flags ) { pev->rendermode = (pev->rendermode & 0x0F) | (flags&0xF0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+328]
	and	edx, 15					; 0000000fH
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 240				; 000000f0H
	or	edx, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+328], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlags@CBeam@@QAEXH@Z ENDP				; CBeam::SetFlags
_TEXT	ENDS
;	COMDAT ?SetColor@CBeam@@QAEXHHH@Z
_TEXT	SEGMENT
_r$ = 8
_g$ = 12
_b$ = 16
_this$ = -4
?SetColor@CBeam@@QAEXHHH@Z PROC NEAR			; CBeam::SetColor, COMDAT

; 147  : 	inline void SetColor( int r, int g, int b ) { pev->rendercolor.x = r; pev->rendercolor.y = g; pev->rendercolor.z = b; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fild	DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+336]
	fild	DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+340]
	fild	DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+344]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetColor@CBeam@@QAEXHHH@Z ENDP				; CBeam::SetColor
_TEXT	ENDS
PUBLIC	?KeyValue@CDeadHGrunt@@UAEXPAUKeyValueData_s@@@Z ; CDeadHGrunt::KeyValue
PUBLIC	??_C@_04JLAH@pose?$AA@				; `string'
EXTRN	_atoi:NEAR
EXTRN	?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseMonster::KeyValue
;	COMDAT ??_C@_04JLAH@pose?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_04JLAH@pose?$AA@ DB 'pose', 00H			; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CDeadHGrunt@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CDeadHGrunt@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CDeadHGrunt::KeyValue, COMDAT

; 2465 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2466 : 	if (FStrEq(pkvd->szKeyName, "pose"))

	push	OFFSET FLAT:??_C@_04JLAH@pose?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39381

; 2468 : 		m_iPose = atoi(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2396], eax

; 2469 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 2471 : 	else 

	jmp	SHORT $L39383
$L39381:

; 2472 : 		CBaseMonster::KeyValue( pkvd );

	mov	eax, DWORD PTR _pkvd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z ; CBaseMonster::KeyValue
$L39383:

; 2473 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CDeadHGrunt@@UAEXPAUKeyValueData_s@@@Z ENDP	; CDeadHGrunt::KeyValue
_TEXT	ENDS
;	COMDAT _$E52
_TEXT	SEGMENT
_$E52	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E51
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E52	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCDeadHGrunt@@@@QAE@PBD@Z	; CEntityFactory<CDeadHGrunt>::CEntityFactory<CDeadHGrunt>
PUBLIC	??_C@_0BE@DOBH@monster_hgrunt_dead?$AA@		; `string'
_BSS	SEGMENT
_monster_hgrunt_dead DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BE@DOBH@monster_hgrunt_dead?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_0BE@DOBH@monster_hgrunt_dead?$AA@ DB 'monster_hgrunt_dead', 00H ; `string'
CONST	ENDS
;	COMDAT _$E51
_TEXT	SEGMENT
_$E51	PROC NEAR					; COMDAT

; 2475 : LINK_ENTITY_TO_CLASS( monster_hgrunt_dead, CDeadHGrunt );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BE@DOBH@monster_hgrunt_dead?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_monster_hgrunt_dead
	call	??0?$CEntityFactory@VCDeadHGrunt@@@@QAE@PBD@Z ; CEntityFactory<CDeadHGrunt>::CEntityFactory<CDeadHGrunt>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E51	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CDeadHGrunt@@UAEXXZ			; CDeadHGrunt::Spawn
PUBLIC	??_C@_0BL@FEKK@Dead?5hgrunt?5with?5bad?5pose?6?$AA@ ; `string'
;	COMDAT ??_C@_0BL@FEKK@Dead?5hgrunt?5with?5bad?5pose?6?$AA@
; File z:\xashxtsrc\server\monsters\hgrunt.cpp
CONST	SEGMENT
??_C@_0BL@FEKK@Dead?5hgrunt?5with?5bad?5pose?6?$AA@ DB 'Dead hgrunt with '
	DB	'bad pose', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?Spawn@CDeadHGrunt@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CDeadHGrunt@@UAEXXZ PROC NEAR			; CDeadHGrunt::Spawn, COMDAT

; 2481 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2482 : 	PRECACHE_MODEL("models/hgrunt.mdl");

	push	OFFSET FLAT:??_C@_0BC@KNIA@models?1hgrunt?4mdl?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4

; 2483 : 	SET_MODEL(ENT(pev), "models/hgrunt.mdl");

	push	OFFSET FLAT:??_C@_0BC@KNIA@models?1hgrunt?4mdl?$AA@ ; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 2484 : 
; 2485 : 	pev->effects		= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+280], 0

; 2486 : 	pev->yaw_speed		= 8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+176], 1090519040		; 41000000H

; 2487 : 	pev->sequence		= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+296], 0

; 2488 : 	m_bloodColor		= BLOOD_COLOR_RED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2328], 247		; 000000f7H

; 2489 : 
; 2490 : 	pev->sequence = LookupSequence( m_szPoses[m_iPose] );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2396]
	mov	edx, DWORD PTR ?m_szPoses@CDeadHGrunt@@2PAPADA[ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupSequence@CBaseAnimating@@QAEHPBD@Z ; CBaseAnimating::LookupSequence
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+296], eax

; 2491 : 
; 2492 : 	if (pev->sequence == -1)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+296], -1
	jne	SHORT $L39414

; 2494 : 		ALERT ( at_console, "Dead hgrunt with bad pose\n" );

	push	OFFSET FLAT:??_C@_0BL@FEKK@Dead?5hgrunt?5with?5bad?5pose?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L39414:

; 2496 : 
; 2497 : 	// Corpses have less health
; 2498 : 	pev->health			= 8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+352], 1090519040		; 41000000H

; 2502 : 	{

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+276]
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 3
	ja	$L39417
	mov	ecx, DWORD PTR -8+[ebp]
	jmp	DWORD PTR $L40484[ecx*4]
$L39420:

; 2503 : 	case 0: // Grunt with Gun
; 2504 : 		pev->body = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+276], 0

; 2505 : 		pev->skin = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+272], 0

; 2506 : 		SetBodygroup( HEAD_GROUP, HEAD_GRUNT );

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBodygroup@CBaseAnimating@@QAEXHH@Z	; CBaseAnimating::SetBodygroup

; 2507 : 		SetBodygroup( GUN_GROUP, GUN_MP5 );

	push	0
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBodygroup@CBaseAnimating@@QAEXHH@Z	; CBaseAnimating::SetBodygroup

; 2508 : 		break;

	jmp	$L39417
$L39421:

; 2509 : 	case 1: // Commander with Gun
; 2510 : 		pev->body = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+276], 0

; 2511 : 		pev->skin = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+272], 0

; 2512 : 		SetBodygroup( HEAD_GROUP, HEAD_COMMANDER );

	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBodygroup@CBaseAnimating@@QAEXHH@Z	; CBaseAnimating::SetBodygroup

; 2513 : 		SetBodygroup( GUN_GROUP, GUN_MP5 );

	push	0
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBodygroup@CBaseAnimating@@QAEXHH@Z	; CBaseAnimating::SetBodygroup

; 2514 : 		break;

	jmp	SHORT $L39417
$L39422:

; 2515 : 	case 2: // Grunt no Gun
; 2516 : 		pev->body = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+276], 0

; 2517 : 		pev->skin = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+272], 0

; 2518 : 		SetBodygroup( HEAD_GROUP, HEAD_GRUNT );

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBodygroup@CBaseAnimating@@QAEXHH@Z	; CBaseAnimating::SetBodygroup

; 2519 : 		SetBodygroup( GUN_GROUP, GUN_NONE );

	push	2
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBodygroup@CBaseAnimating@@QAEXHH@Z	; CBaseAnimating::SetBodygroup

; 2520 : 		break;

	jmp	SHORT $L39417
$L39423:

; 2521 : 	case 3: // Commander no Gun
; 2522 : 		pev->body = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+276], 0

; 2523 : 		pev->skin = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+272], 0

; 2524 : 		SetBodygroup( HEAD_GROUP, HEAD_COMMANDER );

	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBodygroup@CBaseAnimating@@QAEXHH@Z	; CBaseAnimating::SetBodygroup

; 2525 : 		SetBodygroup( GUN_GROUP, GUN_NONE );

	push	2
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBodygroup@CBaseAnimating@@QAEXHH@Z	; CBaseAnimating::SetBodygroup
$L39417:

; 2528 : 
; 2529 : 	MonsterInitDead();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+372]

; 2530 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L40484:
	DD	$L39420
	DD	$L39421
	DD	$L39422
	DD	$L39423
?Spawn@CDeadHGrunt@@UAEXXZ ENDP				; CDeadHGrunt::Spawn
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCHGrunt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CHGrunt>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCHGrunt@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CHGrunt>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCHGrunt@@@@UAEIXZ ; CEntityFactory<CHGrunt>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCHGrunt@@@@6B@		; CEntityFactory<CHGrunt>::`vftable'
PUBLIC	??0IEntityFactory@@QAE@XZ			; IEntityFactory::IEntityFactory
EXTRN	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ:NEAR ; EntityFactoryDictionary
;	COMDAT ??_7?$CEntityFactory@VCHGrunt@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCHGrunt@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCHGrunt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CHGrunt>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCHGrunt@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCHGrunt@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCHGrunt@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCHGrunt@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CHGrunt>::CEntityFactory<CHGrunt>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCHGrunt@@@@6B@ ; CEntityFactory<CHGrunt>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCHGrunt@@@@QAE@PBD@Z ENDP		; CEntityFactory<CHGrunt>::CEntityFactory<CHGrunt>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z		; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCHGrunt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCHGrunt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CHGrunt>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z	; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCHGrunt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CHGrunt>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCHGrunt@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCHGrunt@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CHGrunt>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCHGrunt@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CHGrunt>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCHGrunt@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCHGrunt@@@@UAEIXZ PROC NEAR ; CEntityFactory<CHGrunt>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 2508				; 000009ccH

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCHGrunt@@@@UAEIXZ ENDP	; CEntityFactory<CHGrunt>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCHGruntRepel@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CHGruntRepel>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCHGruntRepel@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CHGruntRepel>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCHGruntRepel@@@@UAEIXZ ; CEntityFactory<CHGruntRepel>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCHGruntRepel@@@@6B@	; CEntityFactory<CHGruntRepel>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCHGruntRepel@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCHGruntRepel@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCHGruntRepel@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CHGruntRepel>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCHGruntRepel@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCHGruntRepel@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCHGruntRepel@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCHGruntRepel@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CHGruntRepel>::CEntityFactory<CHGruntRepel>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCHGruntRepel@@@@6B@ ; CEntityFactory<CHGruntRepel>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCHGruntRepel@@@@QAE@PBD@Z ENDP	; CEntityFactory<CHGruntRepel>::CEntityFactory<CHGruntRepel>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCHGruntRepel@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCHGruntRepel@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CHGruntRepel>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCHGruntRepel@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CHGruntRepel>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCHGruntRepel@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCHGruntRepel@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CHGruntRepel>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCHGruntRepel@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CHGruntRepel>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCHGruntRepel@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCHGruntRepel@@@@UAEIXZ PROC NEAR ; CEntityFactory<CHGruntRepel>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 2400				; 00000960H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCHGruntRepel@@@@UAEIXZ ENDP ; CEntityFactory<CHGruntRepel>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCDeadHGrunt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CDeadHGrunt>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCDeadHGrunt@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CDeadHGrunt>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCDeadHGrunt@@@@UAEIXZ ; CEntityFactory<CDeadHGrunt>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCDeadHGrunt@@@@6B@	; CEntityFactory<CDeadHGrunt>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCDeadHGrunt@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCDeadHGrunt@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCDeadHGrunt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CDeadHGrunt>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCDeadHGrunt@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCDeadHGrunt@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCDeadHGrunt@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCDeadHGrunt@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CDeadHGrunt>::CEntityFactory<CDeadHGrunt>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCDeadHGrunt@@@@6B@ ; CEntityFactory<CDeadHGrunt>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCDeadHGrunt@@@@QAE@PBD@Z ENDP	; CEntityFactory<CDeadHGrunt>::CEntityFactory<CDeadHGrunt>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCDeadHGrunt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCDeadHGrunt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CDeadHGrunt>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCDeadHGrunt@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CDeadHGrunt>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCDeadHGrunt@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCDeadHGrunt@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CDeadHGrunt>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCDeadHGrunt@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CDeadHGrunt>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCDeadHGrunt@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCDeadHGrunt@@@@UAEIXZ PROC NEAR ; CEntityFactory<CDeadHGrunt>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 2400				; 00000960H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCDeadHGrunt@@@@UAEIXZ ENDP ; CEntityFactory<CDeadHGrunt>::GetEntitySize
_TEXT	ENDS
PUBLIC	??_7IEntityFactory@@6B@				; IEntityFactory::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT
??_7IEntityFactory@@6B@ DD FLAT:__purecall		; IEntityFactory::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IEntityFactory@@QAE@XZ PROC NEAR			; IEntityFactory::IEntityFactory, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IEntityFactory@@6B@ ; IEntityFactory::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0IEntityFactory@@QAE@XZ ENDP				; IEntityFactory::IEntityFactory
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_this$ = -16
__$EHRec$ = -12
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
EXTRN	?m_DataMap@CSquadMonster@@2Udatamap_s@@A:BYTE	; CSquadMonster::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCSquadMonster@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCSquadMonster@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CSquadMonster@@2Udatamap_s@@A ; CSquadMonster::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCSquadMonster@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	??0CHGrunt@@QAE@XZ				; CHGrunt::CHGrunt
PUBLIC	?SetClassname@CBaseEntity@@QAEXPBD@Z		; CBaseEntity::SetClassname
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
PUBLIC	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z		; CBaseEntity::operator new
PUBLIC	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z		; CBaseEntity::operator delete
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T40537 = -20
$T40538 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39500

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39500:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39502

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2508					; 000009ccH
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40538[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40538[ebp], 0
	je	SHORT $L40539
	mov	ecx, DWORD PTR $T40538[ebp]
	call	??0CHGrunt@@QAE@XZ			; CHGrunt::CHGrunt
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40540
$L40539:
	mov	DWORD PTR -28+[ebp], 0
$L40540:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40537[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40537[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39502:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40538[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCHGrunt@@PAV1@PBD@Z ENDP		; GetClassPtr
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC NEAR		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32467

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L32466
$L32467:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$L32466:

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4
_pszClassName$ = 8
?SetClassname@CBaseEntity@@QAEXPBD@Z PROC NEAR		; CBaseEntity::SetClassname, COMDAT

; 302  : 	void		SetClassname( const char *pszClassName ) { pev->classname = MAKE_STRING( pszClassName ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClassname@CBaseEntity@@QAEXPBD@Z ENDP		; CBaseEntity::SetClassname
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT
_stAllocateBlock$ = 8
_pev$ = 12
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator new, COMDAT

; 489  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 490  : 		return (void *)ALLOC_PRIVATE(ENT(pev), stAllocateBlock);

	mov	eax, DWORD PTR _stAllocateBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+252
	add	esp, 8

; 491  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z ENDP		; CBaseEntity::operator new
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 12
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator delete, COMDAT

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 497  : 		pev->flags |= FL_KILLME;

	mov	eax, DWORD PTR _pev$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+420], ecx

; 498  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z ENDP		; CBaseEntity::operator delete
_TEXT	ENDS
PUBLIC	??0CHGruntRepel@@QAE@XZ				; CHGruntRepel::CHGruntRepel
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T40558 = -20
$T40559 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39511

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39511:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39513

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2400					; 00000960H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40559[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40559[ebp], 0
	je	SHORT $L40560
	mov	ecx, DWORD PTR $T40559[ebp]
	call	??0CHGruntRepel@@QAE@XZ			; CHGruntRepel::CHGruntRepel
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40561
$L40560:
	mov	DWORD PTR -28+[ebp], 0
$L40561:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40558[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40558[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39513:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40559[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCHGruntRepel@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CDeadHGrunt@@QAE@XZ				; CDeadHGrunt::CDeadHGrunt
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T40571 = -20
$T40572 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39522

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39522:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39524

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2400					; 00000960H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40572[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40572[ebp], 0
	je	SHORT $L40573
	mov	ecx, DWORD PTR $T40572[ebp]
	call	??0CDeadHGrunt@@QAE@XZ			; CDeadHGrunt::CDeadHGrunt
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40574
$L40573:
	mov	DWORD PTR -28+[ebp], 0
$L40574:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40571[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40571[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39524:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40572[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCDeadHGrunt@@PAV1@PBD@Z ENDP		; GetClassPtr
PUBLIC	?UpdateOwner@CBaseEntity@@UAEXXZ		; CBaseEntity::UpdateOwner
PUBLIC	?Center@CBaseEntity@@UAE?AVVector@@XZ		; CBaseEntity::Center
PUBLIC	?EyePosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EyePosition
PUBLIC	?EarPosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EarPosition
PUBLIC	?IsPointSized@CBaseEntity@@UBEHXZ		; CBaseEntity::IsPointSized
PUBLIC	?Illumination@CBaseEntity@@UAEHXZ		; CBaseEntity::Illumination
PUBLIC	?CoverRadius@CBaseMonster@@UAEMXZ		; CBaseMonster::CoverRadius
PUBLIC	?HearingSensitivity@CBaseMonster@@UAEMXZ	; CBaseMonster::HearingSensitivity
PUBLIC	?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z	; CBaseMonster::BodyTarget
PUBLIC	?IsMoving@CBaseMonster@@UAEHXZ			; CBaseMonster::IsMoving
PUBLIC	?AlertSound@CBaseMonster@@UAEXXZ		; CBaseMonster::AlertSound
PUBLIC	?StopFollowing@CBaseMonster@@UAEXH@Z		; CBaseMonster::StopFollowing
PUBLIC	??_7CHGrunt@@6B@				; CHGrunt::`vftable'
PUBLIC	?GetToggleState@CBaseToggle@@UAEHXZ		; CBaseToggle::GetToggleState
PUBLIC	?GetDelay@CBaseToggle@@UAEMXZ			; CBaseToggle::GetDelay
PUBLIC	?ObjectCaps@CBaseEntity@@UAEHXZ			; CBaseEntity::ObjectCaps
PUBLIC	?Activate@CBaseEntity@@UAEXXZ			; CBaseEntity::Activate
PUBLIC	?OnChangeLevel@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeLevel
PUBLIC	?OnTeleport@CBaseEntity@@UAEXXZ			; CBaseEntity::OnTeleport
PUBLIC	?PortalSleep@CBaseEntity@@UAEXM@Z		; CBaseEntity::PortalSleep
PUBLIC	?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ; CBaseEntity::StartMessage
PUBLIC	?GetPosition@CBaseEntity@@UAEMXZ		; CBaseEntity::GetPosition
PUBLIC	?OnChangeParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeParent
PUBLIC	?OnClearParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnClearParent
PUBLIC	?OnRemove@CBaseEntity@@UAEXXZ			; CBaseEntity::OnRemove
PUBLIC	?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z	; CBaseEntity::DeathNotice
PUBLIC	?IsRigidBody@CBaseEntity@@UAEHXZ		; CBaseEntity::IsRigidBody
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z	; CBaseEntity::GetState
PUBLIC	?IsTriggered@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::IsTriggered
PUBLIC	?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ	; CBaseEntity::GetVehicleDriver
PUBLIC	?AddPoints@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPoints
PUBLIC	?AddPointsToTeam@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPointsToTeam
PUBLIC	?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::AddPlayerItem
PUBLIC	?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::RemovePlayerItem
PUBLIC	?GiveAmmo@CBaseEntity@@UAEHHPADH@Z		; CBaseEntity::GiveAmmo
PUBLIC	?OverrideReset@CBaseEntity@@UAEXXZ		; CBaseEntity::OverrideReset
PUBLIC	?TransferReset@CBaseEntity@@UAEXXZ		; CBaseEntity::TransferReset
PUBLIC	?SetToggleState@CBaseEntity@@UAEXH@Z		; CBaseEntity::SetToggleState
PUBLIC	?StartSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StartSneaking
PUBLIC	?MySquadMonsterPointer@CSquadMonster@@UAEPAV1@XZ ; CSquadMonster::MySquadMonsterPointer
PUBLIC	?StopSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StopSneaking
PUBLIC	?OnControls@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::OnControls
PUBLIC	?IsSneaking@CBaseEntity@@UAEHXZ			; CBaseEntity::IsSneaking
PUBLIC	?IsBSPModel@CBaseEntity@@UAEHXZ			; CBaseEntity::IsBSPModel
PUBLIC	?IsCustomModel@CBaseEntity@@UAEHXZ		; CBaseEntity::IsCustomModel
PUBLIC	?ReflectGauss@CBaseEntity@@UAEHXZ		; CBaseEntity::ReflectGauss
PUBLIC	?HasTarget@CBaseEntity@@UAEHH@Z			; CBaseEntity::HasTarget
PUBLIC	??0CSquadMonster@@QAE@XZ			; CSquadMonster::CSquadMonster
PUBLIC	?IsPlayer@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPlayer
PUBLIC	?IsNetClient@CBaseEntity@@UAEHXZ		; CBaseEntity::IsNetClient
PUBLIC	?IsMonster@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMonster
PUBLIC	??1CSquadMonster@@QAE@XZ			; CSquadMonster::~CSquadMonster
PUBLIC	?IsPushable@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPushable
PUBLIC	?IsProjectile@CBaseEntity@@UAEHXZ		; CBaseEntity::IsProjectile
PUBLIC	?BloodColor@CBaseMonster@@UAEHXZ		; CBaseMonster::BloodColor
PUBLIC	?IsFuncScreen@CBaseEntity@@UAEHXZ		; CBaseEntity::IsFuncScreen
PUBLIC	?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ	; CBaseMonster::MyMonsterPointer
PUBLIC	?IsPortal@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPortal
PUBLIC	?IsTank@CBaseEntity@@UAEHXZ			; CBaseEntity::IsTank
PUBLIC	?IsMover@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMover
PUBLIC	?IsBreakable@CBaseEntity@@UAEHXZ		; CBaseEntity::IsBreakable
PUBLIC	?IsAlive@CBaseMonster@@UAEHXZ			; CBaseMonster::IsAlive
PUBLIC	?TeamID@CBaseEntity@@UAEPBDXZ			; CBaseEntity::TeamID
PUBLIC	?Think@CBaseEntity@@UAEXXZ			; CBaseEntity::Think
PUBLIC	?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z	; CBaseEntity::Use
PUBLIC	?Touch@CBaseEntity@@UAEXPAV1@@Z			; CBaseEntity::Touch
PUBLIC	?Blocked@CBaseEntity@@UAEXPAV1@@Z		; CBaseEntity::Blocked
PUBLIC	?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ ; CBaseMonster::GetStoppedActivity
PUBLIC	?Stop@CBaseMonster@@UAEXXZ			; CBaseMonster::Stop
PUBLIC	?Respawn@CBaseEntity@@UAEPAV1@XZ		; CBaseEntity::Respawn
PUBLIC	?CanPlaySentence@CBaseMonster@@UAEHH@Z		; CBaseMonster::CanPlaySentence
EXTRN	?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z:NEAR ; CBaseMonster::FTriangulate
EXTRN	?FVisible@CBaseEntity@@UAEHPAV1@@Z:NEAR		; CBaseEntity::FVisible
EXTRN	?FVisible@CBaseEntity@@UAEHABVVector@@@Z:NEAR	; CBaseEntity::FVisible
EXTRN	?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z:NEAR ; CBaseMonster::BuildNearestRoute
EXTRN	?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z:NEAR	; CBaseEntity::ShouldCollide
EXTRN	?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z:NEAR ; CBaseMonster::FindCover
EXTRN	?IgnoreConditions@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::IgnoreConditions
EXTRN	?FValidateHintType@CBaseMonster@@UAEHF@Z:NEAR	; CBaseMonster::FValidateHintType
EXTRN	?FCanActiveIdle@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::FCanActiveIdle
EXTRN	?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ:NEAR	; CBaseMonster::PBestSound
EXTRN	?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ:NEAR	; CBaseMonster::PBestScent
EXTRN	?FBecomeProne@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::FBecomeProne
EXTRN	?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z:NEAR ; CBaseMonster::BarnacleVictimBitten
EXTRN	?BarnacleVictimReleased@CBaseMonster@@UAEXXZ:NEAR ; CBaseMonster::BarnacleVictimReleased
EXTRN	?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ:NEAR ; CBaseMonster::GetDeathActivity
EXTRN	?DamageDecal@CBaseMonster@@UAEHH@Z:NEAR		; CBaseMonster::DamageDecal
EXTRN	?HasHumanGibs@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::HasHumanGibs
EXTRN	?HasAlienGibs@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::HasAlienGibs
EXTRN	?FadeMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::FadeMonster
EXTRN	?TakeHealth@CBaseMonster@@UAEHMH@Z:NEAR		; CBaseMonster::TakeHealth
EXTRN	?StepSound@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::StepSound
EXTRN	?GetState@CBaseToggle@@UAE?AW4STATE@@XZ:NEAR	; CBaseToggle::GetState
EXTRN	?MoveDone@CBaseToggle@@UAEXXZ:NEAR		; CBaseToggle::MoveDone
EXTRN	?Save@CBaseEntity@@UAEHAAVCSave@@@Z:NEAR	; CBaseEntity::Save
EXTRN	?SetObjectCollisionBox@CBaseEntity@@UAEXXZ:NEAR	; CBaseEntity::SetObjectCollisionBox
EXTRN	?SetNextThink@CBaseEntity@@UAEXM@Z:NEAR		; CBaseEntity::SetNextThink
EXTRN	?CheckEnemy@CSquadMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CSquadMonster::CheckEnemy
EXTRN	?TakeArmor@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeArmor
EXTRN	?StartMonster@CSquadMonster@@UAEXXZ:NEAR	; CSquadMonster::StartMonster
EXTRN	?ScheduleChange@CSquadMonster@@UAEXXZ:NEAR	; CSquadMonster::ScheduleChange
EXTRN	?Killed@CSquadMonster@@UAEXPAUentvars_s@@H@Z:NEAR ; CSquadMonster::Killed
EXTRN	?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceBleed
EXTRN	?FValidateCover@CSquadMonster@@UAEHABVVector@@@Z:NEAR ; CSquadMonster::FValidateCover
EXTRN	?GetIdealState@CSquadMonster@@UAE?AW4MONSTERSTATE@@XZ:NEAR ; CSquadMonster::GetIdealState
EXTRN	?IsInWorld@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::IsInWorld
EXTRN	?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z:NEAR	; CBaseMonster::Restore
EXTRN	?Look@CBaseMonster@@UAEXH@Z:NEAR		; CBaseMonster::Look
EXTRN	?RunAI@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::RunAI
EXTRN	?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::ShouldFadeOnDeath
EXTRN	?GetNextTarget@CBaseEntity@@UAEPAV1@XZ:NEAR	; CBaseEntity::GetNextTarget
EXTRN	?ChangeYaw@CBaseMonster@@UAEMH@Z:NEAR		; CBaseMonster::ChangeYaw
EXTRN	?MonsterThink@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::MonsterThink
EXTRN	?MonsterInit@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::MonsterInit
EXTRN	?MonsterInitDead@CBaseMonster@@UAEXXZ:NEAR	; CBaseMonster::MonsterInitDead
EXTRN	?BecomeDead@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::BecomeDead
EXTRN	?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ:NEAR ; CBaseMonster::BestVisibleEnemy
EXTRN	?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::FInViewCone
EXTRN	?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z:NEAR ; CBaseMonster::FInViewCone
EXTRN	?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z:NEAR ; CBaseMonster::CheckLocalMove
EXTRN	?Move@CBaseMonster@@UAEXM@Z:NEAR		; CBaseMonster::Move
EXTRN	?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z:NEAR ; CBaseMonster::MoveExecute
EXTRN	?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z:NEAR	; CBaseMonster::ShouldAdvanceRoute
EXTRN	?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckMeleeAttack2
EXTRN	?CanPlaySequence@CBaseMonster@@UAEHHH@Z:NEAR	; CBaseMonster::CanPlaySequence
EXTRN	?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z:NEAR	; CBaseMonster::PlaySentence
EXTRN	?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::PlayScriptedSentence
EXTRN	?SentenceStop@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::SentenceStop
EXTRN	?ReportAIState@CBaseMonster@@UAEXXZ:NEAR	; CBaseMonster::ReportAIState
;	COMDAT ??_7CHGrunt@@6B@
CONST	SEGMENT
??_7CHGrunt@@6B@ DD FLAT:?GetDataDescMap@CHGrunt@@UAEPAUdatamap_s@@XZ ; CHGrunt::`vftable'
	DD	FLAT:?Spawn@CHGrunt@@UAEXXZ
	DD	FLAT:?Precache@CHGrunt@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CHGrunt@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CHGrunt@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CHGrunt@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseMonster@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CSquadMonster@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseMonster@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CSquadMonster@@UAEPAV1@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseMonster@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseMonster@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CHGrunt@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CHGrunt@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CSquadMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CHGrunt@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CHGrunt@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CHGrunt@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CHGrunt@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CHGrunt@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CHGrunt@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CHGrunt@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CHGrunt@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CSquadMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CSquadMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CHGrunt@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CSquadMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CHGrunt@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CSquadMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CHGrunt@@UAEHXZ
	DD	FLAT:?CheckAmmo@CHGrunt@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CHGrunt@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CHGrunt@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CHGrunt@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CHGrunt@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CHGrunt@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CHGrunt@@UAEXXZ
	DD	FLAT:?PainSound@CHGrunt@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CHGrunt@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CHGrunt@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CHGrunt@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CHGrunt@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CHGrunt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CHGrunt@@QAE@XZ PROC NEAR				; CHGrunt::CHGrunt, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CHGrunt@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CSquadMonster@@QAE@XZ		; CSquadMonster::CSquadMonster
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2464				; 000009a0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CHGrunt@@6B@ ; CHGrunt::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CHGrunt@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CSquadMonster@@QAE@XZ		; CSquadMonster::~CSquadMonster
	ret	0
__ehhandler$??0CHGrunt@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CHGrunt@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CHGrunt@@QAE@XZ ENDP					; CHGrunt::CHGrunt
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ObjectCaps, COMDAT

; 364  : 	virtual int	ObjectCaps( void ) { return FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 2
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ObjectCaps
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Activate@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Activate, COMDAT

; 365  : 	virtual void	Activate( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Activate
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeLevel@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeLevel, COMDAT

; 366  : 	virtual void	OnChangeLevel( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeLevel@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnChangeLevel
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnTeleport@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnTeleport, COMDAT

; 367  : 	virtual void	OnTeleport( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnTeleport@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnTeleport
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4
?PortalSleep@CBaseEntity@@UAEXM@Z PROC NEAR		; CBaseEntity::PortalSleep, COMDAT

; 368  : 	virtual void	PortalSleep( float seconds ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PortalSleep@CBaseEntity@@UAEXM@Z ENDP			; CBaseEntity::PortalSleep
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CBaseEntity::StartMessage, COMDAT

; 369  :           virtual void	StartMessage( CBasePlayer *pPlayer ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ENDP	; CBaseEntity::StartMessage
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetPosition@CBaseEntity@@UAEMXZ PROC NEAR		; CBaseEntity::GetPosition, COMDAT

; 370  : 	virtual float	GetPosition( void ) { return 0.0f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPosition@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetPosition
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeParent, COMDAT

; 371  : 	virtual void	OnChangeParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CBaseEntity@@UAEXXZ ENDP		; CBaseEntity::OnChangeParent
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnClearParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnClearParent, COMDAT

; 372  : 	virtual void	OnClearParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnClearParent
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnRemove@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::OnRemove, COMDAT

; 373  : 	virtual void	OnRemove( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnRemove@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnRemove
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z PROC NEAR ; CBaseEntity::DeathNotice, COMDAT

; 386  : 	virtual void DeathNotice ( entvars_t *pevChild ) { } // monster maker children use this to tell the monster maker that they have died.

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z ENDP	; CBaseEntity::DeathNotice
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsRigidBody@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsRigidBody, COMDAT

; 387  : 	virtual BOOL IsRigidBody( void ) { return (m_iActorType == ACTOR_DYNAMIC); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	mov	eax, ecx
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsRigidBody@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsRigidBody
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z PROC NEAR	; CBaseEntity::GetState, COMDAT

; 401  : 	virtual STATE GetState ( CBaseEntity* pEnt ) { return GetState(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z ENDP	; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::IsTriggered, COMDAT

; 410  : 	virtual BOOL	IsTriggered( CBaseEntity *pActivator ) {return TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::IsTriggered
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ PROC NEAR	; CBaseEntity::GetVehicleDriver, COMDAT

; 413  : 	virtual CBaseEntity *GetVehicleDriver( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ ENDP		; CBaseEntity::GetVehicleDriver
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPoints@CBaseEntity@@UAEXHH@Z PROC NEAR		; CBaseEntity::AddPoints, COMDAT

; 415  : 	virtual void	AddPoints( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPoints@CBaseEntity@@UAEXHH@Z ENDP			; CBaseEntity::AddPoints
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z PROC NEAR	; CBaseEntity::AddPointsToTeam, COMDAT

; 416  : 	virtual void	AddPointsToTeam( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z ENDP		; CBaseEntity::AddPointsToTeam
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::AddPlayerItem, COMDAT

; 417  : 	virtual BOOL	AddPlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::AddPlayerItem
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::RemovePlayerItem, COMDAT

; 418  : 	virtual BOOL	RemovePlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::RemovePlayerItem
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT
_this$ = -4
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z PROC NEAR		; CBaseEntity::GiveAmmo, COMDAT

; 419  : 	virtual int 	GiveAmmo( int iAmount, char *szName, int iMax ) { return -1; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z ENDP			; CBaseEntity::GiveAmmo
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OverrideReset, COMDAT

; 422  : 	virtual void	OverrideReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OverrideReset
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TransferReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::TransferReset, COMDAT

; 423  : 	virtual void	TransferReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransferReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::TransferReset
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?SetToggleState@CBaseEntity@@UAEXH@Z PROC NEAR		; CBaseEntity::SetToggleState, COMDAT

; 426  : 	virtual void	SetToggleState( int state ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetToggleState@CBaseEntity@@UAEXH@Z ENDP		; CBaseEntity::SetToggleState
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StartSneaking, COMDAT

; 427  : 	virtual void	StartSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StartSneaking
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StopSneaking, COMDAT

; 428  : 	virtual void	StopSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StopSneaking
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?OnControls@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::OnControls, COMDAT

; 429  : 	virtual BOOL	OnControls( CBaseEntity *pTest ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnControls@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::OnControls
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSneaking@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsSneaking, COMDAT

; 430  : 	virtual BOOL	IsSneaking( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSneaking@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsSneaking
_TEXT	ENDS
EXTRN	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z:NEAR	; UTIL_GetModelType
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBSPModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBSPModel, COMDAT

; 432  : 	virtual BOOL	IsBSPModel( void ) { return UTIL_GetModelType( pev->modelindex ) == mod_brush; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBSPModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBSPModel
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsCustomModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsCustomModel, COMDAT

; 433  : 	virtual BOOL	IsCustomModel( void ) { return pev->solid == SOLID_CUSTOM; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+268], 5
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCustomModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsCustomModel
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ReflectGauss@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ReflectGauss, COMDAT

; 434  : 	virtual BOOL	ReflectGauss( void ) { return (( IsBSPModel() || IsCustomModel()) && !pev->takedamage ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	test	eax, eax
	jne	SHORT $L40651
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+208]
	test	eax, eax
	je	SHORT $L40652
$L40651:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40652
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40653
$L40652:
	mov	DWORD PTR -8+[ebp], 0
$L40653:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReflectGauss@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ReflectGauss
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_targetname$ = 8
?HasTarget@CBaseEntity@@UAEHH@Z PROC NEAR		; CBaseEntity::HasTarget, COMDAT

; 435  : 	virtual BOOL	HasTarget( string_t targetname ) { return FStrEq(STRING(targetname), STRING(pev->targetname) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _targetname$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasTarget@CBaseEntity@@UAEHH@Z ENDP			; CBaseEntity::HasTarget
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPlayer@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPlayer, COMDAT

; 437  : 	virtual BOOL	IsPlayer( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPlayer
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsNetClient@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsNetClient, COMDAT

; 438  : 	virtual BOOL	IsNetClient( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetClient@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsNetClient
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMonster@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsMonster, COMDAT

; 439  : 	virtual BOOL	IsMonster( void ) { return (pev->flags & FL_MONSTER ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+420]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMonster@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMonster
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPushable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsPushable, COMDAT

; 440  : 	virtual BOOL	IsPushable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPushable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPushable
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsProjectile@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsProjectile, COMDAT

; 441  : 	virtual BOOL	IsProjectile( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsProjectile@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsProjectile
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsFuncScreen@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsFuncScreen, COMDAT

; 442  : 	virtual BOOL	IsFuncScreen( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFuncScreen@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsFuncScreen
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPortal@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPortal, COMDAT

; 443  : 	virtual BOOL	IsPortal( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPortal@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPortal
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTank@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsTank, COMDAT

; 444  : 	virtual BOOL	IsTank( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTank@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsTank
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMover@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMover, COMDAT

; 445  : 	virtual BOOL	IsMover( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMover
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBreakable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBreakable, COMDAT

; 446  : 	virtual BOOL	IsBreakable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBreakable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBreakable
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?TeamID@CBaseEntity@@UAEPBDXZ PROC NEAR			; CBaseEntity::TeamID, COMDAT

; 447  : 	virtual const char	*TeamID( void ) { return ""; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TeamID@CBaseEntity@@UAEPBDXZ ENDP			; CBaseEntity::TeamID
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Think@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Think, COMDAT

; 458  : 	virtual void Think( void ) { if (m_pfnThink) (this->*m_pfnThink)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1744], 0
	je	SHORT $L35025
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1744]
$L35025:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Think
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
_pActivator$ = 8
_pCaller$ = 12
_useType$ = 16
_value$ = 20
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z PROC NEAR	; CBaseEntity::Use, COMDAT

; 461  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 		if (m_pfnUse) (this->*m_pfnUse)( pActivator, pCaller, useType, value );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1752], 0
	je	SHORT $L35028
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCaller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1752]
$L35028:

; 463  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z ENDP	; CBaseEntity::Use
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Touch@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Touch, COMDAT

; 466  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 		if( m_pfnTouch )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1748], 0
	je	SHORT $L35031

; 468  : 			(this->*m_pfnTouch)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1748]
$L35031:

; 469  : 
; 470  : 		// forward the blocked event to our parent, if any.
; 471  : 		if( m_hParent != NULL && !m_isChaining )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35032
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1628]
	test	ecx, ecx
	jne	SHORT $L35032

; 472  : 			m_hParent->Touch( pOther );

	mov	edx, DWORD PTR _pOther$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+280]
$L35032:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Touch
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Blocked@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Blocked, COMDAT

; 476  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 		if( m_pfnBlocked )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1756], 0
	je	SHORT $L35035

; 478  : 			(this->*m_pfnBlocked)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1756]
$L35035:

; 479  : 
; 480  : 		// forward the blocked event to our parent, if any.
; 481  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35036

; 482  : 			m_hParent->Blocked( pOther );

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+284]
$L35036:

; 483  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Blocked
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?Respawn@CBaseEntity@@UAEPAV1@XZ PROC NEAR		; CBaseEntity::Respawn, COMDAT

; 513  : 	virtual CBaseEntity *Respawn( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Respawn@CBaseEntity@@UAEPAV1@XZ ENDP			; CBaseEntity::Respawn
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?UpdateOwner@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::UpdateOwner, COMDAT

; 705  : 	virtual	void UpdateOwner( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateOwner@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::UpdateOwner
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40692 = -16
$T40693 = -28
?Center@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR		; CBaseEntity::Center, COMDAT

; 714  : 	virtual Vector Center( ) { return (pev->absmax + pev->absmin) * 0.5; }; // center point of entity

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T40693[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	push	edx
	lea	eax, DWORD PTR $T40692[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 208				; 000000d0H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Center@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::Center
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40696 = -16
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EyePosition, COMDAT

; 715  : 	virtual Vector EyePosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of eyes

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T40696[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EyePosition
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40699 = -16
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EarPosition, COMDAT

; 716  : 	virtual Vector EarPosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of ears

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T40699[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EarPosition
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPointSized@CBaseEntity@@UBEHXZ PROC NEAR		; CBaseEntity::IsPointSized, COMDAT

; 718  : 	virtual BOOL IsPointSized() const { return (pev->size == g_vecZero) ? true : false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	setne	al
	and	eax, 255				; 000000ffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPointSized@CBaseEntity@@UBEHXZ ENDP			; CBaseEntity::IsPointSized
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Illumination@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::Illumination, COMDAT

; 720  : 	virtual int Illumination( ) { return GETENTITYILLUM( ENT( pev ) ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+60
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Illumination@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Illumination
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseToggle@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseToggle@@UAEHXZ PROC NEAR		; CBaseToggle::GetToggleState, COMDAT

; 978  : 	virtual int GetToggleState( void ) { return m_toggle_state; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1816]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseToggle@@UAEHXZ ENDP		; CBaseToggle::GetToggleState
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseToggle@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseToggle@@UAEMXZ PROC NEAR			; CBaseToggle::GetDelay, COMDAT

; 979  : 	virtual float GetDelay( void ) { return m_flWait; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1764]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseToggle@@UAEMXZ ENDP			; CBaseToggle::GetDelay
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::BloodColor, COMDAT

; 132  : 	virtual int	 BloodColor( void ) { return m_bloodColor; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+2328]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::BloodColor
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ PROC NEAR	; CBaseMonster::MyMonsterPointer, COMDAT

; 134  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return this; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ ENDP		; CBaseMonster::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseMonster@@UAEHXZ PROC NEAR			; CBaseMonster::IsAlive, COMDAT

; 139  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag != DEAD_DEAD); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+368], 2
	setne	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::IsAlive
_TEXT	ENDS
;	COMDAT ?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ PROC NEAR ; CBaseMonster::GetStoppedActivity, COMDAT

; 175  : 		virtual Activity GetStoppedActivity( void ) { return ACT_IDLE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ ENDP ; CBaseMonster::GetStoppedActivity
_TEXT	ENDS
;	COMDAT ?Stop@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Stop@CBaseMonster@@UAEXXZ PROC NEAR			; CBaseMonster::Stop, COMDAT

; 176  : 		virtual void Stop( void ) { m_IdealActivity = GetStoppedActivity(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2072], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@CBaseMonster@@UAEXXZ ENDP				; CBaseMonster::Stop
_TEXT	ENDS
;	COMDAT ?CanPlaySentence@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
?CanPlaySentence@CBaseMonster@@UAEHH@Z PROC NEAR	; CBaseMonster::CanPlaySentence, COMDAT

; 206  : 		virtual int CanPlaySentence( BOOL fDisregardState ) { return IsAlive(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CanPlaySentence@CBaseMonster@@UAEHH@Z ENDP		; CBaseMonster::CanPlaySentence
_TEXT	ENDS
PUBLIC	__real@4@4008c400000000000000
;	COMDAT __real@4@4008c400000000000000
; File z:\xashxtsrc\server\monsters\basemonster.h
CONST	SEGMENT
__real@4@4008c400000000000000 DD 044440000r	; 784
CONST	ENDS
;	COMDAT ?CoverRadius@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?CoverRadius@CBaseMonster@@UAEMXZ PROC NEAR		; CBaseMonster::CoverRadius, COMDAT

; 250  : 		virtual float CoverRadius( void ) { return 784; } // Default cover radius

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@4008c400000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CoverRadius@CBaseMonster@@UAEMXZ ENDP			; CBaseMonster::CoverRadius
_TEXT	ENDS
;	COMDAT ?HearingSensitivity@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?HearingSensitivity@CBaseMonster@@UAEMXZ PROC NEAR	; CBaseMonster::HearingSensitivity, COMDAT

; 278  : 		virtual float HearingSensitivity( void ) { return 1.0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@3fff8000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HearingSensitivity@CBaseMonster@@UAEMXZ ENDP		; CBaseMonster::HearingSensitivity
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40728 = -16
$T40729 = -28
$T40730 = -40
$T40731 = -52
$T40732 = -64
?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseMonster::BodyTarget, COMDAT

; 318  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ) * 0.75 + EyePosition() * 0.25; };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1048576000				; 3e800000H
	lea	eax, DWORD PTR $T40731[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40730[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+308]
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T40732[ebp]
	push	ecx
	push	1061158912				; 3f400000H
	lea	edx, DWORD PTR $T40729[ebp]
	push	edx
	lea	eax, DWORD PTR $T40728[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseMonster::BodyTarget
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::IsMoving, COMDAT

; 328  : 	virtual int		IsMoving( void ) { return m_movementGoal != MOVEGOAL_NONE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+2228], 0
	setne	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::IsMoving
_TEXT	ENDS
;	COMDAT ?AlertSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?AlertSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::AlertSound, COMDAT

; 334  : 	virtual void AlertSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AlertSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::AlertSound
_TEXT	ENDS
;	COMDAT ?StopFollowing@CBaseMonster@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?StopFollowing@CBaseMonster@@UAEXH@Z PROC NEAR		; CBaseMonster::StopFollowing, COMDAT

; 339  : 	virtual void StopFollowing( BOOL clearSchedule ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StopFollowing@CBaseMonster@@UAEXH@Z ENDP		; CBaseMonster::StopFollowing
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CSquadMonster@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?MySquadMonsterPointer@CSquadMonster@@UAEPAV1@XZ PROC NEAR ; CSquadMonster::MySquadMonsterPointer, COMDAT

; 109  : 	virtual CSquadMonster *MySquadMonsterPointer( void ) { return this; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadMonsterPointer@CSquadMonster@@UAEPAV1@XZ ENDP	; CSquadMonster::MySquadMonsterPointer
_TEXT	ENDS
PUBLIC	?SetYawSpeed@CBaseMonster@@UAEXXZ		; CBaseMonster::SetYawSpeed
PUBLIC	?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z	; CBaseMonster::FValidateCover
PUBLIC	?CheckAmmo@CBaseMonster@@UAEXXZ			; CBaseMonster::CheckAmmo
PUBLIC	?PrescheduleThink@CBaseMonster@@UAEXXZ		; CBaseMonster::PrescheduleThink
PUBLIC	?DeathSound@CBaseMonster@@UAEXXZ		; CBaseMonster::DeathSound
PUBLIC	?IdleSound@CBaseMonster@@UAEXXZ			; CBaseMonster::IdleSound
PUBLIC	?PainSound@CBaseMonster@@UAEXXZ			; CBaseMonster::PainSound
PUBLIC	??0CBaseMonster@@QAE@XZ				; CBaseMonster::CBaseMonster
PUBLIC	??_7CHGruntRepel@@6B@				; CHGruntRepel::`vftable'
PUBLIC	?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ; CBaseEntity::MySquadMonsterPointer
PUBLIC	?Classify@CBaseMonster@@UAEHXZ			; CBaseMonster::Classify
PUBLIC	?ScheduleChange@CBaseMonster@@UAEXXZ		; CBaseMonster::ScheduleChange
EXTRN	?FCanCheckAttacks@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::FCanCheckAttacks
EXTRN	?ISoundMask@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::ISoundMask
EXTRN	?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z:NEAR ; CBaseMonster::Killed
EXTRN	?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ:NEAR ; CBaseMonster::GetGunPosition
EXTRN	?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseMonster::GetDataDescMap
EXTRN	?StartMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::StartMonster
EXTRN	?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckRangeAttack1
EXTRN	?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckRangeAttack2
EXTRN	?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckMeleeAttack1
EXTRN	?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z:NEAR ; CBaseMonster::GetScheduleOfType
EXTRN	?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ:NEAR ; CBaseMonster::GetIdealState
EXTRN	?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z:NEAR ; CBaseMonster::SetActivity
EXTRN	?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::CheckEnemy
;	COMDAT ??_7CHGruntRepel@@6B@
CONST	SEGMENT
??_7CHGruntRepel@@6B@ DD FLAT:?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ ; CHGruntRepel::`vftable'
	DD	FLAT:?Spawn@CHGruntRepel@@UAEXXZ
	DD	FLAT:?Precache@CHGruntRepel@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseMonster@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseMonster@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseMonster@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseMonster@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CHGruntRepel@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseMonster@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CBaseMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CBaseMonster@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CBaseMonster@@UAEHXZ
	DD	FLAT:?CheckAmmo@CBaseMonster@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CBaseMonster@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?PainSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
CONST	ENDS
;	COMDAT ??0CHGruntRepel@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CHGruntRepel@@QAE@XZ PROC NEAR			; CHGruntRepel::CHGruntRepel, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseMonster@@QAE@XZ			; CBaseMonster::CBaseMonster
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CHGruntRepel@@6B@ ; CHGruntRepel::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CHGruntRepel@@QAE@XZ ENDP				; CHGruntRepel::CHGruntRepel
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ PROC NEAR ; CBaseEntity::MySquadMonsterPointer, COMDAT

; 412  : 	virtual CSquadMonster *MySquadMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ENDP ; CBaseEntity::MySquadMonsterPointer
_TEXT	ENDS
;	COMDAT ?Classify@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::Classify, COMDAT

; 130  : 	virtual int	Classify( void ) { return m_iClass ? m_iClass : CLASS_NONE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2388], 0
	je	SHORT $L40748
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2388]
	mov	DWORD PTR -8+[ebp], edx
	jmp	SHORT $L40749
$L40748:
	mov	DWORD PTR -8+[ebp], 0
$L40749:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::Classify
_TEXT	ENDS
;	COMDAT ?ScheduleChange@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ScheduleChange@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::ScheduleChange, COMDAT

; 203  : 		virtual void ScheduleChange( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ScheduleChange@CBaseMonster@@UAEXXZ ENDP		; CBaseMonster::ScheduleChange
_TEXT	ENDS
;	COMDAT ?SetYawSpeed@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SetYawSpeed@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::SetYawSpeed, COMDAT

; 241  : 		virtual void SetYawSpeed ( void ) { return; };// allows different yaw_speeds for each activity

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetYawSpeed@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::SetYawSpeed
_TEXT	ENDS
;	COMDAT ?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4
?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z PROC NEAR ; CBaseMonster::FValidateCover, COMDAT

; 249  : 		virtual BOOL FValidateCover ( const Vector &vecCoverLocation ) { return TRUE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z ENDP	; CBaseMonster::FValidateCover
_TEXT	ENDS
;	COMDAT ?CheckAmmo@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CheckAmmo@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::CheckAmmo, COMDAT

; 253  : 		virtual void CheckAmmo( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckAmmo@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::CheckAmmo
_TEXT	ENDS
;	COMDAT ?PrescheduleThink@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PrescheduleThink@CBaseMonster@@UAEXXZ PROC NEAR	; CBaseMonster::PrescheduleThink, COMDAT

; 298  : 		virtual void PrescheduleThink( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrescheduleThink@CBaseMonster@@UAEXXZ ENDP		; CBaseMonster::PrescheduleThink
_TEXT	ENDS
;	COMDAT ?DeathSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DeathSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::DeathSound, COMDAT

; 333  : 	virtual void DeathSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DeathSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::DeathSound
_TEXT	ENDS
;	COMDAT ?IdleSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?IdleSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::IdleSound, COMDAT

; 335  : 	virtual void IdleSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IdleSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::IdleSound
_TEXT	ENDS
;	COMDAT ?PainSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PainSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::PainSound, COMDAT

; 336  : 	virtual void PainSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PainSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::PainSound
_TEXT	ENDS
PUBLIC	?Classify@CDeadHGrunt@@UAEHXZ			; CDeadHGrunt::Classify
PUBLIC	??_7CDeadHGrunt@@6B@				; CDeadHGrunt::`vftable'
PUBLIC	?Precache@CBaseEntity@@UAEXXZ			; CBaseEntity::Precache
;	COMDAT ??_7CDeadHGrunt@@6B@
CONST	SEGMENT
??_7CDeadHGrunt@@6B@ DD FLAT:?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ ; CDeadHGrunt::`vftable'
	DD	FLAT:?Spawn@CDeadHGrunt@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CDeadHGrunt@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CDeadHGrunt@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseMonster@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseMonster@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseMonster@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseMonster@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CBaseMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CBaseMonster@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CBaseMonster@@UAEHXZ
	DD	FLAT:?CheckAmmo@CBaseMonster@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CBaseMonster@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?PainSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
CONST	ENDS
;	COMDAT ??0CDeadHGrunt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CDeadHGrunt@@QAE@XZ PROC NEAR			; CDeadHGrunt::CDeadHGrunt, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseMonster@@QAE@XZ			; CBaseMonster::CBaseMonster
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CDeadHGrunt@@6B@ ; CDeadHGrunt::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CDeadHGrunt@@QAE@XZ ENDP				; CDeadHGrunt::CDeadHGrunt
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Precache, COMDAT

; 326  : 	virtual void	Precache( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Precache
_TEXT	ENDS
;	COMDAT ?Classify@CDeadHGrunt@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CDeadHGrunt@@UAEHXZ PROC NEAR			; CDeadHGrunt::Classify, COMDAT

; 2454 : 	int Classify ( void ) { return CLASS_HUMAN_MILITARY; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CDeadHGrunt@@UAEHXZ ENDP			; CDeadHGrunt::Classify
_TEXT	ENDS
PUBLIC	?Spawn@CBaseEntity@@UAEXXZ			; CBaseEntity::Spawn
PUBLIC	??_7CSquadMonster@@6B@				; CSquadMonster::`vftable'
EXTRN	?GetDataDescMap@CSquadMonster@@UAEPAUdatamap_s@@XZ:NEAR ; CSquadMonster::GetDataDescMap
;	COMDAT ??_7CSquadMonster@@6B@
CONST	SEGMENT
??_7CSquadMonster@@6B@ DD FLAT:?GetDataDescMap@CSquadMonster@@UAEPAUdatamap_s@@XZ ; CSquadMonster::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseMonster@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseMonster@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CSquadMonster@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseMonster@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CSquadMonster@@UAEPAV1@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseMonster@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseMonster@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CSquadMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CSquadMonster@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CSquadMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CSquadMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CSquadMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CBaseMonster@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CSquadMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CBaseMonster@@UAEHXZ
	DD	FLAT:?CheckAmmo@CBaseMonster@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CBaseMonster@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?PainSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
CONST	ENDS
;	COMDAT ??0CSquadMonster@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CSquadMonster@@QAE@XZ PROC NEAR			; CSquadMonster::CSquadMonster, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseMonster@@QAE@XZ			; CBaseMonster::CBaseMonster
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CSquadMonster@@6B@ ; CSquadMonster::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CSquadMonster@@QAE@XZ ENDP				; CSquadMonster::CSquadMonster
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Spawn, COMDAT

; 325  : 	virtual void	Spawn( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Spawn
_TEXT	ENDS
PUBLIC	??1CBaseMonster@@QAE@XZ				; CBaseMonster::~CBaseMonster
;	COMDAT ??1CSquadMonster@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CSquadMonster@@QAE@XZ PROC NEAR			; CSquadMonster::~CSquadMonster, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseMonster@@QAE@XZ			; CBaseMonster::~CBaseMonster
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CSquadMonster@@QAE@XZ ENDP				; CSquadMonster::~CSquadMonster
_TEXT	ENDS
PUBLIC	??0WayPoint_t@@QAE@XZ				; WayPoint_t::WayPoint_t
PUBLIC	??_7CBaseMonster@@6B@				; CBaseMonster::`vftable'
PUBLIC	??0CBaseToggle@@QAE@XZ				; CBaseToggle::CBaseToggle
PUBLIC	??1CBaseToggle@@QAE@XZ				; CBaseToggle::~CBaseToggle
;	COMDAT ??_7CBaseMonster@@6B@
CONST	SEGMENT
??_7CBaseMonster@@6B@ DD FLAT:?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ ; CBaseMonster::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseMonster@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseMonster@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseMonster@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseMonster@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseMonster@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CBaseMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CBaseMonster@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CBaseMonster@@UAEHXZ
	DD	FLAT:?CheckAmmo@CBaseMonster@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CBaseMonster@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?PainSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseMonster@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseMonster@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseMonster@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseMonster@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseMonster@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseMonster@@QAE@XZ PROC NEAR			; CBaseMonster::CBaseMonster, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseMonster@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseToggle@@QAE@XZ			; CBaseToggle::CBaseToggle
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2008				; 000007d8H
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0WayPoint_t@@QAE@XZ	; WayPoint_t::WayPoint_t
	push	8
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2100				; 00000834H
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2240				; 000008c0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2264				; 000008d8H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2364				; 0000093cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET FLAT:??_7CBaseMonster@@6B@ ; CBaseMonster::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseMonster@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseToggle@@QAE@XZ			; CBaseToggle::~CBaseToggle
	ret	0
__ehhandler$??0CBaseMonster@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseMonster@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseMonster@@QAE@XZ ENDP				; CBaseMonster::CBaseMonster
;	COMDAT ??1CBaseMonster@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseMonster@@QAE@XZ PROC NEAR			; CBaseMonster::~CBaseMonster, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseToggle@@QAE@XZ			; CBaseToggle::~CBaseToggle
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseMonster@@QAE@XZ ENDP				; CBaseMonster::~CBaseMonster
_TEXT	ENDS
PUBLIC	?FBecomeProne@CBaseEntity@@UAEHXZ		; CBaseEntity::FBecomeProne
PUBLIC	?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z	; CBaseEntity::BodyTarget
PUBLIC	?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z ; CBaseAnimating::HandleAnimEvent
PUBLIC	??0CBaseAnimating@@QAE@XZ			; CBaseAnimating::CBaseAnimating
PUBLIC	??1CBaseAnimating@@QAE@XZ			; CBaseAnimating::~CBaseAnimating
PUBLIC	??_7CBaseToggle@@6B@				; CBaseToggle::`vftable'
PUBLIC	?Classify@CBaseEntity@@UAEHXZ			; CBaseEntity::Classify
PUBLIC	?BloodColor@CBaseEntity@@UAEHXZ			; CBaseEntity::BloodColor
PUBLIC	?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ; CBaseEntity::MyMonsterPointer
PUBLIC	?IsMoving@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMoving
PUBLIC	?IsAlive@CBaseEntity@@UAEHXZ			; CBaseEntity::IsAlive
EXTRN	?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseToggle::KeyValue
EXTRN	?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z:NEAR	; CBaseToggle::Restore
EXTRN	?GetDataDescMap@CBaseToggle@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseToggle::GetDataDescMap
EXTRN	?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceAttack
EXTRN	?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseEntity::TakeDamage
EXTRN	?TakeHealth@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeHealth
EXTRN	?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z:NEAR	; CBaseEntity::Killed
EXTRN	?DamageDecal@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::DamageDecal
;	COMDAT ??_7CBaseToggle@@6B@
CONST	SEGMENT
??_7CBaseToggle@@6B@ DD FLAT:?GetDataDescMap@CBaseToggle@@UAEPAUdatamap_s@@XZ ; CBaseToggle::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseToggle@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseToggle@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseToggle@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseToggle@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseToggle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseToggle@@QAE@XZ PROC NEAR			; CBaseToggle::CBaseToggle, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseToggle@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseAnimating@@QAE@XZ		; CBaseAnimating::CBaseAnimating
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1864				; 00000748H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1912				; 00000778H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1924				; 00000784H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1936				; 00000790H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseToggle@@6B@ ; CBaseToggle::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseToggle@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseAnimating@@QAE@XZ		; CBaseAnimating::~CBaseAnimating
	ret	0
__ehhandler$??0CBaseToggle@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseToggle@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseToggle@@QAE@XZ ENDP				; CBaseToggle::CBaseToggle
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::Classify, COMDAT

; 385  : 	virtual int Classify ( void ) { return CLASS_NONE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Classify
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::BloodColor, COMDAT

; 408  : 	virtual int	BloodColor( void ) { return DONT_BLEED; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::BloodColor
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ PROC NEAR ; CBaseEntity::MyMonsterPointer, COMDAT

; 411  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ENDP ; CBaseEntity::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMoving, COMDAT

; 421  : 	virtual int	IsMoving( void ) { return GetAbsVelocity() != g_vecZero; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMoving
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsAlive, COMDAT

; 431  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	jne	SHORT $L40812
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40812
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40813
$L40812:
	mov	DWORD PTR -8+[ebp], 0
$L40813:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsAlive
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FBecomeProne@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::FBecomeProne, COMDAT

; 709  : 	virtual BOOL FBecomeProne( void ) {return FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FBecomeProne@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::FBecomeProne
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40818 = -16
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseEntity::BodyTarget, COMDAT

; 717  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ); };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T40818[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseEntity::BodyTarget
_TEXT	ENDS
;	COMDAT ?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT
_this$ = -4
?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z PROC NEAR ; CBaseAnimating::HandleAnimEvent, COMDAT

; 909  : 	virtual void HandleAnimEvent( MonsterEvent_t *pEvent ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z ENDP ; CBaseAnimating::HandleAnimEvent
_TEXT	ENDS
;	COMDAT ??1CBaseToggle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseToggle@@QAE@XZ PROC NEAR			; CBaseToggle::~CBaseToggle, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseAnimating@@QAE@XZ		; CBaseAnimating::~CBaseAnimating
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseToggle@@QAE@XZ ENDP				; CBaseToggle::~CBaseToggle
_TEXT	ENDS
;	COMDAT ??0WayPoint_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0WayPoint_t@@QAE@XZ PROC NEAR				; WayPoint_t::WayPoint_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0WayPoint_t@@QAE@XZ ENDP				; WayPoint_t::WayPoint_t
_TEXT	ENDS
PUBLIC	?GetState@CBaseDelay@@UAE?AW4STATE@@XZ		; CBaseDelay::GetState
PUBLIC	??0CBaseDelay@@QAE@XZ				; CBaseDelay::CBaseDelay
PUBLIC	??_7CBaseAnimating@@6B@				; CBaseAnimating::`vftable'
PUBLIC	?GetToggleState@CBaseEntity@@UAEHXZ		; CBaseEntity::GetToggleState
PUBLIC	?GetDelay@CBaseEntity@@UAEMXZ			; CBaseEntity::GetDelay
PUBLIC	?MoveDone@CBaseEntity@@UAEXXZ			; CBaseEntity::MoveDone
EXTRN	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseDelay::KeyValue
EXTRN	?GetDataDescMap@CBaseAnimating@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseAnimating::GetDataDescMap
EXTRN	?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z:NEAR	; CBaseEntity::Restore
;	COMDAT ??_7CBaseAnimating@@6B@
CONST	SEGMENT
??_7CBaseAnimating@@6B@ DD FLAT:?GetDataDescMap@CBaseAnimating@@UAEPAUdatamap_s@@XZ ; CBaseAnimating::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
CONST	ENDS
;	COMDAT ??0CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseAnimating@@QAE@XZ PROC NEAR			; CBaseAnimating::CBaseAnimating, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseAnimating@@6B@ ; CBaseAnimating::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseAnimating@@QAE@XZ ENDP				; CBaseAnimating::CBaseAnimating
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::GetToggleState, COMDAT

; 414  : 	virtual int	GetToggleState( void ) { return TS_AT_TOP; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseEntity@@UAEHXZ ENDP		; CBaseEntity::GetToggleState
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseEntity@@UAEMXZ PROC NEAR			; CBaseEntity::GetDelay, COMDAT

; 420  : 	virtual float	GetDelay( void ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetDelay
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MoveDone@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::MoveDone, COMDAT

; 485  : 	virtual void MoveDone( void ) { if( m_pfnMoveDone )(this->*m_pfnMoveDone)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1760], 0
	je	SHORT $L35039
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1760]
$L35039:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveDone@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::MoveDone
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseDelay::GetState, COMDAT

; 881  : 	virtual STATE GetState( void ) { return m_iState; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1788]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ ENDP		; CBaseDelay::GetState
_TEXT	ENDS
PUBLIC	??1CBaseDelay@@QAE@XZ				; CBaseDelay::~CBaseDelay
;	COMDAT ??1CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseAnimating@@QAE@XZ PROC NEAR			; CBaseAnimating::~CBaseAnimating, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseDelay@@QAE@XZ			; CBaseDelay::~CBaseDelay
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseAnimating@@QAE@XZ ENDP				; CBaseAnimating::~CBaseAnimating
_TEXT	ENDS
PUBLIC	??0CBaseEntity@@QAE@XZ				; CBaseEntity::CBaseEntity
PUBLIC	??_7CBaseDelay@@6B@				; CBaseDelay::`vftable'
EXTRN	?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseDelay::GetDataDescMap
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT
??_7CBaseDelay@@6B@ DD FLAT:?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ ; CBaseDelay::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseDelay@@6B@ ; CBaseDelay::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::CBaseDelay
_TEXT	ENDS
PUBLIC	??1CBaseEntity@@QAE@XZ				; CBaseEntity::~CBaseEntity
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::~CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseEntity@@QAE@XZ			; CBaseEntity::~CBaseEntity
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::~CBaseDelay
_TEXT	ENDS
PUBLIC	??_7CBaseEntity@@6B@				; CBaseEntity::`vftable'
PUBLIC	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@XZ		; CBaseEntity::GetState
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	??0CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::CMeshDesc
EXTRN	??1CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::~CMeshDesc
EXTRN	?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseEntity::GetDataDescMap
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT
??_7CBaseEntity@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CBaseEntity::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseEntity@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseEntity@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseEntity@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseEntity@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseEntity@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??0CMeshDesc@@QAE@XZ			; CMeshDesc::CMeshDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1632				; 00000660H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseEntity@@6B@ ; CBaseEntity::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseEntity@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	ret	0
__ehhandler$??0CBaseEntity@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseEntity@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::CBaseEntity
PUBLIC	??_C@_06FOPF@parent?$AA@			; `string'
PUBLIC	??_C@_08IDGH@movewith?$AA@			; `string'
PUBLIC	??_C@_0M@FCIN@parentflags?$AA@			; `string'
PUBLIC	??_C@_05JCDO@style?$AA@				; `string'
PUBLIC	??_C@_0L@MCHI@reflection?$AA@			; `string'
PUBLIC	??_C@_0N@DCCA@vlight_cache?$AA@			; `string'
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
;	COMDAT ??_C@_06FOPF@parent?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_06FOPF@parent?$AA@ DB 'parent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT
??_C@_08IDGH@movewith?$AA@ DB 'movewith', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT
??_C@_0M@FCIN@parentflags?$AA@ DB 'parentflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT
??_C@_05JCDO@style?$AA@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT
??_C@_0L@MCHI@reflection?$AA@ DB 'reflection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT
??_C@_0N@DCCA@vlight_cache?$AA@ DB 'vlight_cache', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pkvd$ = 8
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseEntity::KeyValue, COMDAT

; 328  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 		// get support for spirit field too
; 330  : 		if( FStrEq( pkvd->szKeyName, "parent" ) || FStrEq( pkvd->szKeyName, "movewith" ))

	push	OFFSET FLAT:??_C@_06FOPF@parent?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L34894
	push	OFFSET FLAT:??_C@_08IDGH@movewith?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34893
$L34894:

; 332  : 			m_iParent = ALLOC_STRING(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 333  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 335  : 		else if( FStrEq( pkvd->szKeyName, "parentflags" ))

	jmp	$L34915
$L34893:
	push	OFFSET FLAT:??_C@_0M@FCIN@parentflags?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34898

; 337  : 			m_iParentFlags = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 338  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 340  : 		else if( FStrEq( pkvd->szKeyName, "style" ))

	jmp	$L34915
$L34898:
	push	OFFSET FLAT:??_C@_05JCDO@style?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34901

; 342  : 			m_iStyle = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 343  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 345  : 		else if( FStrEq( pkvd->szKeyName, "reflection" ))

	jmp	$L34915
$L34901:
	push	OFFSET FLAT:??_C@_0L@MCHI@reflection?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34904

; 348  : 			{

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L34910
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L34911
	jmp	SHORT $L34907
$L34910:

; 349  : 			case 1: pev->effects |= EF_NOREFLECT; break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
	jmp	SHORT $L34907
$L34911:

; 350  : 			case 2: pev->effects |= EF_REFLECTONLY; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L34907:

; 352  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 354  : 		else if( FStrEq(pkvd->szKeyName, "vlight_cache"))

	jmp	SHORT $L34915
$L34904:
	push	OFFSET FLAT:??_C@_0N@DCCA@vlight_cache?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34913

; 356  : 			pev->iuser3 = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+588], eax

; 357  : 			pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 359  : 		else pkvd->fHandled = FALSE;

	jmp	SHORT $L34915
$L34913:
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L34915:

; 360  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseEntity::KeyValue
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseEntity::GetState, COMDAT

; 398  : 	virtual STATE GetState ( void ) { return STATE_OFF; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ ENDP		; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::~CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::~CBaseEntity
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
EXTRN	_malloc:NEAR
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC NEAR		; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L40870
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40870:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L39592

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L39592:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PADH@@QAE@XZ PROC NEAR			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC NEAR		; CUtlMemory<char *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40875
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40875:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40876
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40876:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC NEAR		; CUtlMemory<char *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40879
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40879:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC NEAR	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?Destruct@@YAXPAPAD@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L39625:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L39626

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAD@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L39625
$L39626:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC NEAR	; CUtlMemory<char *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40888
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L40888
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40889
$L40888:
	mov	DWORD PTR -8+[ebp], 0
$L40889:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC NEAR		; CUtlMemory<char *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39658

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L39659

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L39659:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L39658:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR	; CUtlMemory<char *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR ; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
EXTRN	_memset:NEAR
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAD@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAD@Z ENDP				; Destruct
_TEXT	ENDS
END
