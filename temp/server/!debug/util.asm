	TITLE	Z:\XashXTSRC\server\util.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGEN@AnimateUntilDead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09OKKL@Half?9Life?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@PKKM@z?3?2xashxtsrc?2server?2util?4cpp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@POAI@FindFactory?$CI?5pClassName?5?$CJ?5?$DN?$DN?5NUL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??InstallFactory@CEntityFactoryDictionary@@UAEXPAVIEntityFactory@@PBD@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CN@ONH@Attempted?5to?5create?5unknown?5enti@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@MOGE@Attempted?5to?5destroy?5unknown?5ent@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@PHFE@?5?$CFs?3?5?$CFd?5bytes?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@MELN@Entity?5Factory?5not?5installed?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HHKO@?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@GJLL@sizeof?$CIpMap?9?$DOdataDesc?$FLi?$FN?4func?$CJ?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@EHFG@Failed?5to?5find?5function?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DJ@HFNF@entvars_t?5pContainingEntity?5is?5N@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@DIHB@DAMN?$CB?5?5Even?5the?5engine?5couldn?8t?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@IFKE@ASSERT?5FAILED?3?6?5?$CFs?5?6?$CI?$CFs?$EA?$CFd?$CJ?6?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@NII@ASSERT?5FAILED?3?6?5?$CFs?5?6?$CI?$CFs?$EA?$CFd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LNFJ@common?1null?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@HEE@buttons?1button1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@OHCL@buttons?1button2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@EHAO@buttons?1button3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@CHPE@buttons?1button4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@IHNB@buttons?1button5?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GHLO@buttons?1button6?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MHJL@buttons?1button7?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@KGEL@buttons?1button8?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGO@buttons?1button9?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IGAC@buttons?1button10?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@CGCH@buttons?1button11?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EOKP@buttons?1latchlocked1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@LEDH@buttons?1latchunlocked1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HKMK@buttons?1lightswitch2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@BHHD@buttons?1lever1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@PHBM@buttons?1lever2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@FHDJ@buttons?1lever3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@DHMD@buttons?1lever4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@JHOG@buttons?1lever5?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06EGA@USE_ON?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07IAOC@USE_OFF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KHMF@USE_TOGGLE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07LOMG@USE_SET?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NHHJ@USE_RESET?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@JJEM@USE_REMOVE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@BPKL@UNKNOWN?5USE_TYPE?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02HAKO@ON?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CMJG@OFF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07NPIG@TURN?5ON?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CGDJ@TURN?5OFF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NCDP@IN?5USE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04ONLI@DEAD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@FIJK@UNKNOWN?5STATE?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@PCB@Unknown?5state?5?8?$CFs?8?5specified?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08ELHM@DAMAGE?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MDIH@Generic?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KJJ@Crush?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07LABF@Bullet?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FDFC@Slash?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PPGG@Burn?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07DPFD@Freeze?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MPGH@Fall?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06BJKH@Blast?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FEDP@Club?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06DMCO@Shock?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06PIEK@Sonic?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@HKFE@Energy?5Beam?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GDEN@Never?5Gib?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@KFMM@Always?5Gib?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06OIEJ@Drown?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@EBHB@Paralyze?5Gas?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IHMH@Nerve?5Gas?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07LLKI@Poison?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DINM@Radiation?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@BJOK@Drown?5Recover?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EKCB@Acid?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PHFJ@Slow?5Burn?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@ENAO@Slow?5Freeze?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07FCKH@Mortar?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GFG@Nuclear?5Explode?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05CLBC@EMPTY?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DEEH@SOLID?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EJIN@WATER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LBMA@SLIME?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04IEEF@LAVA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03IEGK@SKY?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06IJPP@LADDER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08JNJG@FLYFIELD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@NOJI@GRAVITY_FLYFIELD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03OHFM@FOG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JOMD@SPECIAL?51?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09GBHK@SPECIAL?52?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MLON@SPECIAL?53?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@LABL@NO?5CONTENTS?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JMKL@GLOBAL?5ON?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GPHK@GLOBAL?5OFF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@CCPL@GLOBAL?5DEAD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FJBO@?$CKlocus?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@MKOH@Missing?5?8?$CJ?8?5in?5master?5?$CC?$CFs?$CC?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@OIPF@Missing?5?8?$CJ?8?5in?5targetname?3?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@CLIA@Firing?3?5?$CI?$CFs?$CJ?5with?5?$CFs?5and?5value?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@DNOL@violence_hblood?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@FEK@violence_ablood?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@ONNB@buttons?1spark1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@NLO@buttons?1spark2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@KNJL@buttons?1spark3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@MNGB@buttons?1spark4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNEE@buttons?1spark5?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@INCL@buttons?1spark6?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@LCCD@NULL?5Ent?5in?5UTIL_PrecacheOther?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@HEKC@UTIL_PrecacheSound?3?5sound?5not?5sp@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CIGF@sound?1?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03JAAL@wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03FMPB@mp3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@LGPK@sound?5?$CC?$CFs?$CC?5not?5found?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@KEDF@invalid?5name?5?$CC?$CFs?$CC?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GNNL@media?1?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FDHG@?$CK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04DCMN@?$CFs?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@PCK@Warning?3?5video?5?$CI?$CFs?$CJ?5not?5found?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DILL@?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@CNK@UTIL_SetView?3?5pActivator?5?$DN?$DN?5NULL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@DCOA@UTIL_SetView?3?5pActivator?5not?5a?5p@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@FNKF@UTIL_GetModelBounds?3?5NULL?5model?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@PMFB@UTIL_SetSize?3?5?$CFs?5backwards?5mins?1@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@IDJO@pEntity?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CN@GCC@Entity?5?$CFi?5SOLID_BSP?5with?5a?5non?5b@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@CEPA@player?1pl_wade3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@EEAK@player?1pl_wade4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LNMM@?$CFs?1bin?1?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@NFHJ@?$CFs?5loaded?5succesfully?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@JPEA@?$CGm_LessFunc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MKKF@IsValid?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EA@LGGP@m_Elements?4IsValidIterator?$CI?5m_La@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@IMPD@m_Elements?4IsValidIterator?$CI?5it?5?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@LCOD@CUtlRBTree?5overflow?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@EPOF@m_Elements?4IsValidIterator?$CI?5m_La@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PMK@m_Root?5?$DN?$DN?5InvalidIndex?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@BLFE@m_FirstFree?5?$DN?$DN?5InvalidIndex?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OBAD@m_NumElements?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@HIOD@i?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector2D@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector2D@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyToArray@Vector@@QBEXPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Make2D@Vector@@QBE?AVVector2D@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVmatrix3x4@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOrigin@matrix4x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CaselessStringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CaselessStringLessThanIgnoreSlashes@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?INDEXENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMoveDir@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMonsterPointer@CBaseEntity@@SAPAVCBaseMonster@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeNonSolid@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RestoreSolid@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eoffset@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?entindex@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPointEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E33
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CEntityFactoryDictionary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CEntityFactoryDictionary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEntityFactoryDictionary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindFactory@CEntityFactoryDictionary@@EAEPAVIEntityFactory@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InstallFactory@CEntityFactoryDictionary@@UAEXPAVIEntityFactory@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@CEntityFactoryDictionary@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCannonicalName@CEntityFactoryDictionary@@UAEPBDPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@CEntityFactoryDictionary@@UAEXPBDPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReportEntitySizes@CEntityFactoryDictionary@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DumpEntityNames_f@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DumpEntitySizes_f@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DumpStrings_f@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Msg@@YAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VecBModelOrigin@@YA?AVVector@@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_SetGroupTrace@@YAXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_UnsetGroupTrace@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UTIL_GroupTrace@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UTIL_GroupTrace@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DBG_AssertFunction@@YAXHPBD0H0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ButtonSound@@YAPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringForUseType@@YAPBDW4USE_TYPE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringForState@@YAPBDW4STATE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStateForString@@YA?AW4STATE@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrintStringForDamage@@YAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetContentsString@@YAPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringForGlobalState@@YAPBDW4GLOBALESTATE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_GetNextBestWeapon@@YAHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_AngleMod@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_AngleDiff@@YAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_MoveToOrigin@@YAXPAUedict_s@@ABVVector@@MH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_Teleport@@YAXPAVCBaseEntity@@AAUTeleportListEntry_t@@PBVVector@@22@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ParentToWorldSpace@@YAXPAVCBaseEntity@@AAVVector@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_EntitiesInBox@@YAHPAPAVCBaseEntity@@HABVVector@@1H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_MonstersInSphere@@YAHPAPAVCBaseEntity@@HABVVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_FindEntityByTarget@@YAPAVCBaseEntity@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_FindEntityByMonsterTarget@@YAPAVCBaseEntity@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_FindEntityGeneric@@YAPAVCBaseEntity@@PBDABVVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_MakeVectors@@YAXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_MakeAimVectors@@YAXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_MakeInvVectors@@YAXABVVector@@PAUglobalvars_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FixedUnsigned16@@YAGMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FixedSigned16@@YAFMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ScreenShake@@YAXABVVector@@MMMM_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ScreenShakeAll@@YAXABVVector@@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ScreenFadeBuild@@YAXAAUScreenFade@@ABVVector@@MMHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ScreenFadeWrite@@YAXABUScreenFade@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ScreenFadeAll@@YAXABVVector@@MMHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ScreenFade@@YAXPAVCBaseEntity@@ABVVector@@MMHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_HudMessage@@YAXPAVCBaseEntity@@ABUhudtextparms_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_HudMessageAll@@YAXABUhudtextparms_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ClientPrintAll@@YAXHPBD0000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClientPrint@@YAXPAUentvars_s@@HPBD1111@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_SayText@@YAXPBDPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_SayTextAll@@YAXPBDPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_dtos1@@YAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_dtos2@@YAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_dtos3@@YAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_dtos4@@YAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ShowMessage@@YAXPBDPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ShowMessageAll@@YAXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_TraceModel@@YAXABVVector@@0HPAUedict_s@@PAUgametrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_TraceEntity@@YAXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_GetGlobalTrace@@YA?AUgametrace_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_CopyTraceToGlobal@@YAXPAUgametrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_CopyTraceToGlobal@@YAXPAUtrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ConvertTrace@@YAXPAUgametrace_s@@PAUtrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_VecToYaw@@YAMABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_SetAngles@@YAXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ParticleEffect@@YAXABVVector@@0KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_Approach@@YAMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ApproachAngle@@YAMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_AngleDistance@@YAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_SplineFraction@@YAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_VarArgs@@YAPADPADZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_GetAimVector@@YA?AVVector@@PAUedict_s@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_IsMasterTriggered@@YAHHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ShouldShowBlood@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_PointContents@@YAHABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_BloodStream@@YAXABVVector@@0HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_BloodDrips@@YAXABVVector@@0HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_RandomBloodVector@@YA?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_BloodDecalTrace@@YAXPAUgametrace_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_BloodStudioDecalTrace@@YAXPAUgametrace_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_DecalTrace@@YAXPAUgametrace_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_StudioDecalTrace@@YAXPAUgametrace_s@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_RestoreStudioDecal@@YAXABVVector@@0HHPBDHPAUmodelstate_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_PlayerDecalTrace@@YAXPAUgametrace_s@@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_GunshotDecalTrace@@YAXPAUgametrace_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_Sparks@@YAXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_DoSpark@@YAXPAUentvars_s@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_Ricochet@@YAXABVVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_TeamsMatch@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_IsFacing@@YAHPAUentvars_s@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_StringToVector@@YAXPAMPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_StringToIntArray@@YAXPAHHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_ClampVectorToBox@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_WaterLevel@@YAMABVVector@@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_Bubbles@@YAXVVector@@0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_BubbleTrail@@YAXVVector@@0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_SetMovedir@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_Remove@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_IsValidEntity@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_PrecacheOther@@YAXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_PrecacheSound@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_PrecacheSound@@YAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_PrecacheMovie@@YAGHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_PrecacheMovie@@YAGPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_LogPrintf@@YAXPADZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_DotPoints@@YAMABVVector@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_StripToken@@YAXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_SetView@@YAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_SetView@@YAXPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_SetView@@YAXPAVCBaseEntity@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_FindClientInPVS@@YAPAVCBaseEntity@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_GetSpriteType@@YA?AW4angletype_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UITL_ExternalBmodel@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_GetModelBounds@@YAXHAAVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_SetSize@@YAXPAVCBaseEntity@@ABVVector@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_CanRotate@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_CanRotateBModel@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_AllowHitboxTrace@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_RecursiveWalkNodes@@YAXPAUareaclip_t@@PAUareanode_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_AreaNode@@YAXVVector@@0HP6AXPAVCBaseEntity@@@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0areaclip_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_HullForBsp@@YAPAUhull_s@@PAVCBaseEntity@@ABVVector@@1AAV3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_HullPointContents@@YAHPAUhull_s@@HABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_MoveBounds@@YAXABVVector@@000AAV1@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_CombineTraces@@YA?AUtrace_s@@PAU1@0PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0trace_s@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0plane_s@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_WaterMove@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_LoadSoundPreset@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Sys_LoadLibrary@@YA_NPBDPAPAUHINSTANCE__@@PBUdllfunc_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Sys_GetProcAddress@@YAPAXPAUHINSTANCE__@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Sys_FreeLibrary@@YAXPAPAUHINSTANCE__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlDict@PAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetElementName@?$CUtlDict@PAVIEntityFactory@@G@@QAEPADG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlDict@PAVIEntityFactory@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Insert@?$CUtlDict@PAVIEntityFactory@@G@@QAEGPBDABQAVIEntityFactory@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Find@?$CUtlDict@PAVIEntityFactory@@G@@QBEGPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?First@?$CUtlDict@PAVIEntityFactory@@G@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Next@?$CUtlDict@PAVIEntityFactory@@G@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@HHP6A_NABQBD0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Key@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEAAPBDG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlMap@PBDPAVIEntityFactory@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLessFunc@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXP6A_NABQBD0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Insert@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEGABQBDABQAVIEntityFactory@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Find@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGABQBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FirstInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@P6A_NABQBD0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlDict@PAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlDict@PAVIEntityFactory@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEAAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLessFunc@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Insert@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEGABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Find@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FirstInorder@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextInorder@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7CKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NABUNode_t@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlDict@PAVIEntityFactory@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertAt@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEGG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindInsertionPosition@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@AAGAA_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEAAU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEPAU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@ABU01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxAfter@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NGABVIterator_t@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewNode@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinkToParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEABU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?First@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Next@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@ABV21@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEGABVIterator_t@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NABVIterator_t@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Root@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertRebalance@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRoot@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRed@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Color@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBE?AW4NodeColor_t@1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotateLeft@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotateRight@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?s_Sentinel@?1??Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z@4U3@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7IEntityFactoryDictionary@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CEntityFactoryDictionary@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?g_groupmask@@3HA				; g_groupmask
PUBLIC	?g_groupop@@3HA					; g_groupop
_BSS	SEGMENT
?g_groupmask@@3HA DD 01H DUP (?)			; g_groupmask
?g_groupop@@3HA DD 01H DUP (?)				; g_groupop
_BSS	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0CEntityFactoryDictionary@@QAE@XZ		; CEntityFactoryDictionary::CEntityFactoryDictionary
PUBLIC	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?s_EntityFactory@?1??EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ@4VCEntityFactoryDictionary@@A DB 020H DUP (?)
_?$S32@?1??EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ
_TEXT	SEGMENT
?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ PROC NEAR ; EntityFactoryDictionary, COMDAT

; 62   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 63   : 	static CEntityFactoryDictionary s_EntityFactory;

	xor	eax, eax
	mov	al, BYTE PTR _?$S32@?1??EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L40432
	mov	cl, BYTE PTR _?$S32@?1??EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ@4EA
	or	cl, 1
	mov	BYTE PTR _?$S32@?1??EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ@4EA, cl
	mov	ecx, OFFSET FLAT:_?s_EntityFactory@?1??EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ@4VCEntityFactoryDictionary@@A
	call	??0CEntityFactoryDictionary@@QAE@XZ	; CEntityFactoryDictionary::CEntityFactoryDictionary
	push	OFFSET FLAT:_$E33
	call	_atexit
	add	esp, 4
$L40432:

; 64   : 	return &s_EntityFactory;

	mov	eax, OFFSET FLAT:_?s_EntityFactory@?1??EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ@4VCEntityFactoryDictionary@@A

; 65   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ENDP ; EntityFactoryDictionary
_TEXT	ENDS
PUBLIC	??1CEntityFactoryDictionary@@QAE@XZ		; CEntityFactoryDictionary::~CEntityFactoryDictionary
;	COMDAT _$E33
_TEXT	SEGMENT
_$E33	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?s_EntityFactory@?1??EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ@4VCEntityFactoryDictionary@@A
	call	??1CEntityFactoryDictionary@@QAE@XZ	; CEntityFactoryDictionary::~CEntityFactoryDictionary
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E33	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ	; CUtlDict<IEntityFactory *,unsigned short>::~CUtlDict<IEntityFactory *,unsigned short>
;	COMDAT ??1CEntityFactoryDictionary@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CEntityFactoryDictionary@@QAE@XZ PROC NEAR		; CEntityFactoryDictionary::~CEntityFactoryDictionary, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ ; CUtlDict<IEntityFactory *,unsigned short>::~CUtlDict<IEntityFactory *,unsigned short>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CEntityFactoryDictionary@@QAE@XZ ENDP		; CEntityFactoryDictionary::~CEntityFactoryDictionary
_TEXT	ENDS
PUBLIC	?InstallFactory@CEntityFactoryDictionary@@UAEXPAVIEntityFactory@@PBD@Z ; CEntityFactoryDictionary::InstallFactory
PUBLIC	?Create@CEntityFactoryDictionary@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactoryDictionary::Create
PUBLIC	?Destroy@CEntityFactoryDictionary@@UAEXPBDPAVCBaseEntity@@@Z ; CEntityFactoryDictionary::Destroy
PUBLIC	?GetCannonicalName@CEntityFactoryDictionary@@UAEPBDPBD@Z ; CEntityFactoryDictionary::GetCannonicalName
PUBLIC	?FindFactory@CEntityFactoryDictionary@@EAEPAVIEntityFactory@@PBD@Z ; CEntityFactoryDictionary::FindFactory
PUBLIC	??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z	; CUtlDict<IEntityFactory *,unsigned short>::CUtlDict<IEntityFactory *,unsigned short>
PUBLIC	??_7CEntityFactoryDictionary@@6B@		; CEntityFactoryDictionary::`vftable'
PUBLIC	??0IEntityFactoryDictionary@@QAE@XZ		; IEntityFactoryDictionary::IEntityFactoryDictionary
;	COMDAT ??_7CEntityFactoryDictionary@@6B@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_7CEntityFactoryDictionary@@6B@ DD FLAT:?InstallFactory@CEntityFactoryDictionary@@UAEXPAVIEntityFactory@@PBD@Z ; CEntityFactoryDictionary::`vftable'
	DD	FLAT:?Create@CEntityFactoryDictionary@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
	DD	FLAT:?Destroy@CEntityFactoryDictionary@@UAEXPBDPAVCBaseEntity@@@Z
	DD	FLAT:?FindFactory@CEntityFactoryDictionary@@EAEPAVIEntityFactory@@PBD@Z
	DD	FLAT:?GetCannonicalName@CEntityFactoryDictionary@@UAEPBDPBD@Z
CONST	ENDS
;	COMDAT ??0CEntityFactoryDictionary@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CEntityFactoryDictionary@@QAE@XZ PROC NEAR		; CEntityFactoryDictionary::CEntityFactoryDictionary, COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactoryDictionary@@QAE@XZ	; IEntityFactoryDictionary::IEntityFactoryDictionary
	push	128					; 00000080H
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z ; CUtlDict<IEntityFactory *,unsigned short>::CUtlDict<IEntityFactory *,unsigned short>
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CEntityFactoryDictionary@@6B@ ; CEntityFactoryDictionary::`vftable'

; 72   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CEntityFactoryDictionary@@QAE@XZ ENDP		; CEntityFactoryDictionary::CEntityFactoryDictionary
_TEXT	ENDS
PUBLIC	??_7IEntityFactoryDictionary@@6B@		; IEntityFactoryDictionary::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IEntityFactoryDictionary@@6B@
CONST	SEGMENT
??_7IEntityFactoryDictionary@@6B@ DD FLAT:__purecall	; IEntityFactoryDictionary::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0IEntityFactoryDictionary@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IEntityFactoryDictionary@@QAE@XZ PROC NEAR		; IEntityFactoryDictionary::IEntityFactoryDictionary, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IEntityFactoryDictionary@@6B@ ; IEntityFactoryDictionary::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0IEntityFactoryDictionary@@QAE@XZ ENDP		; IEntityFactoryDictionary::IEntityFactoryDictionary
_TEXT	ENDS
PUBLIC	??A?$CUtlDict@PAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z ; CUtlDict<IEntityFactory *,unsigned short>::operator[]
PUBLIC	?InvalidIndex@?$CUtlDict@PAVIEntityFactory@@G@@SAGXZ ; CUtlDict<IEntityFactory *,unsigned short>::InvalidIndex
PUBLIC	?Find@?$CUtlDict@PAVIEntityFactory@@G@@QBEGPBD@Z ; CUtlDict<IEntityFactory *,unsigned short>::Find
;	COMDAT ?FindFactory@CEntityFactoryDictionary@@EAEPAVIEntityFactory@@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
_nIndex$ = -8
?FindFactory@CEntityFactoryDictionary@@EAEPAVIEntityFactory@@PBD@Z PROC NEAR ; CEntityFactoryDictionary::FindFactory, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 	unsigned short nIndex = m_Factories.Find( pClassName );

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Find@?$CUtlDict@PAVIEntityFactory@@G@@QBEGPBD@Z ; CUtlDict<IEntityFactory *,unsigned short>::Find
	mov	WORD PTR _nIndex$[ebp], ax

; 80   : 	if ( nIndex == m_Factories.InvalidIndex() )

	mov	esi, DWORD PTR _nIndex$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlDict@PAVIEntityFactory@@G@@SAGXZ ; CUtlDict<IEntityFactory *,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L40447

; 81   : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L40445
$L40447:

; 82   : 	return m_Factories[nIndex];

	mov	cx, WORD PTR _nIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlDict@PAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z ; CUtlDict<IEntityFactory *,unsigned short>::operator[]
	mov	eax, DWORD PTR [eax]
$L40445:

; 83   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FindFactory@CEntityFactoryDictionary@@EAEPAVIEntityFactory@@PBD@Z ENDP ; CEntityFactoryDictionary::FindFactory
_TEXT	ENDS
PUBLIC	?Insert@?$CUtlDict@PAVIEntityFactory@@G@@QAEGPBDABQAVIEntityFactory@@@Z ; CUtlDict<IEntityFactory *,unsigned short>::Insert
PUBLIC	?__LINE__Var@?1??InstallFactory@CEntityFactoryDictionary@@UAEXPAVIEntityFactory@@PBD@Z@4FA ; `CEntityFactoryDictionary::InstallFactory'::`2'::__LINE__Var
PUBLIC	??_C@_0BN@PKKM@z?3?2xashxtsrc?2server?2util?4cpp?$AA@ ; `string'
PUBLIC	??_C@_0CC@POAI@FindFactory?$CI?5pClassName?5?$CJ?5?$DN?$DN?5NUL@ ; `string'
EXTRN	__assert:NEAR
;	COMDAT ?__LINE__Var@?1??InstallFactory@CEntityFactoryDictionary@@UAEXPAVIEntityFactory@@PBD@Z@4FA
; File z:\xashxtsrc\server\util.cpp
_DATA	SEGMENT
?__LINE__Var@?1??InstallFactory@CEntityFactoryDictionary@@UAEXPAVIEntityFactory@@PBD@Z@4FA DW 05aH ; `CEntityFactoryDictionary::InstallFactory'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BN@PKKM@z?3?2xashxtsrc?2server?2util?4cpp?$AA@
CONST	SEGMENT
??_C@_0BN@PKKM@z?3?2xashxtsrc?2server?2util?4cpp?$AA@ DB 'z:\xashxtsrc\se'
	DB	'rver\util.cpp', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@POAI@FindFactory?$CI?5pClassName?5?$CJ?5?$DN?$DN?5NUL@
CONST	SEGMENT
??_C@_0CC@POAI@FindFactory?$CI?5pClassName?5?$CJ?5?$DN?$DN?5NUL@ DB 'Find'
	DB	'Factory( pClassName ) == NULL', 00H		; `string'
CONST	ENDS
;	COMDAT ?InstallFactory@CEntityFactoryDictionary@@UAEXPAVIEntityFactory@@PBD@Z
_TEXT	SEGMENT
_pFactory$ = 8
_pClassName$ = 12
_this$ = -4
?InstallFactory@CEntityFactoryDictionary@@UAEXPAVIEntityFactory@@PBD@Z PROC NEAR ; CEntityFactoryDictionary::InstallFactory, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	assert( FindFactory( pClassName ) == NULL );

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+12]
	test	eax, eax
	je	SHORT $L43603
	movsx	eax, WORD PTR ?__LINE__Var@?1??InstallFactory@CEntityFactoryDictionary@@UAEXPAVIEntityFactory@@PBD@Z@4FA ; `CEntityFactoryDictionary::InstallFactory'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0BN@PKKM@z?3?2xashxtsrc?2server?2util?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CC@POAI@FindFactory?$CI?5pClassName?5?$CJ?5?$DN?$DN?5NUL@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L43603:

; 92   : 	m_Factories.Insert( pClassName, pFactory );

	lea	edx, DWORD PTR _pFactory$[ebp]
	push	edx
	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Insert@?$CUtlDict@PAVIEntityFactory@@G@@QAEGPBDABQAVIEntityFactory@@@Z ; CUtlDict<IEntityFactory *,unsigned short>::Insert

; 93   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InstallFactory@CEntityFactoryDictionary@@UAEXPAVIEntityFactory@@PBD@Z ENDP ; CEntityFactoryDictionary::InstallFactory
_TEXT	ENDS
PUBLIC	??_C@_0CN@ONH@Attempted?5to?5create?5unknown?5enti@ ; `string'
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
;	COMDAT ??_C@_0CN@ONH@Attempted?5to?5create?5unknown?5enti@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0CN@ONH@Attempted?5to?5create?5unknown?5enti@ DB 'Attempted to crea'
	DB	'te unknown entity type %s!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?Create@CEntityFactoryDictionary@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pFactory$ = -8
?Create@CEntityFactoryDictionary@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactoryDictionary::Create, COMDAT

; 100  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 	IEntityFactory *pFactory = FindFactory( pClassName );

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+12]
	mov	DWORD PTR _pFactory$[ebp], eax

; 102  : 
; 103  : 	if( !pFactory )

	cmp	DWORD PTR _pFactory$[ebp], 0
	jne	SHORT $L40463

; 105  : 		ALERT( at_warning, "Attempted to create unknown entity type %s!\n", pClassName );

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CN@ONH@Attempted?5to?5create?5unknown?5enti@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 106  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L40461
$L40463:

; 108  : 
; 109  : 	return pFactory->Create( pClassName, pev );

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pClassName$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFactory$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pFactory$[ebp]
	call	DWORD PTR [edx]
$L40461:

; 110  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@CEntityFactoryDictionary@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactoryDictionary::Create
_TEXT	ENDS
PUBLIC	?GetElementName@?$CUtlDict@PAVIEntityFactory@@G@@QAEPADG@Z ; CUtlDict<IEntityFactory *,unsigned short>::GetElementName
;	COMDAT ?GetCannonicalName@CEntityFactoryDictionary@@UAEPBDPBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
?GetCannonicalName@CEntityFactoryDictionary@@UAEPBDPBD@Z PROC NEAR ; CEntityFactoryDictionary::GetCannonicalName, COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 	return m_Factories.GetElementName( m_Factories.Find( pClassName ) );

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Find@?$CUtlDict@PAVIEntityFactory@@G@@QBEGPBD@Z ; CUtlDict<IEntityFactory *,unsigned short>::Find
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetElementName@?$CUtlDict@PAVIEntityFactory@@G@@QAEPADG@Z ; CUtlDict<IEntityFactory *,unsigned short>::GetElementName

; 118  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetCannonicalName@CEntityFactoryDictionary@@UAEPBDPBD@Z ENDP ; CEntityFactoryDictionary::GetCannonicalName
_TEXT	ENDS
PUBLIC	??_C@_0CO@MOGE@Attempted?5to?5destroy?5unknown?5ent@ ; `string'
;	COMDAT ??_C@_0CO@MOGE@Attempted?5to?5destroy?5unknown?5ent@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0CO@MOGE@Attempted?5to?5destroy?5unknown?5ent@ DB 'Attempted to des'
	DB	'troy unknown entity type %s!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?Destroy@CEntityFactoryDictionary@@UAEXPBDPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pEntity$ = 12
_this$ = -4
_pFactory$ = -8
?Destroy@CEntityFactoryDictionary@@UAEXPBDPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactoryDictionary::Destroy, COMDAT

; 124  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	IEntityFactory *pFactory = FindFactory( pClassName );

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+12]
	mov	DWORD PTR _pFactory$[ebp], eax

; 126  : 
; 127  : 	if( !pFactory )

	cmp	DWORD PTR _pFactory$[ebp], 0
	jne	SHORT $L40475

; 129  : 		ALERT( at_warning, "Attempted to destroy unknown entity type %s!\n", pClassName );

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CO@MOGE@Attempted?5to?5destroy?5unknown?5ent@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 130  : 		return;

	jmp	SHORT $L40473
$L40475:

; 132  : 
; 133  : 	pFactory->Destroy( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFactory$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pFactory$[ebp]
	call	DWORD PTR [eax+4]
$L40473:

; 134  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Destroy@CEntityFactoryDictionary@@UAEXPBDPAVCBaseEntity@@@Z ENDP ; CEntityFactoryDictionary::Destroy
_TEXT	ENDS
PUBLIC	?ReportEntitySizes@CEntityFactoryDictionary@@QAEXXZ ; CEntityFactoryDictionary::ReportEntitySizes
PUBLIC	?First@?$CUtlDict@PAVIEntityFactory@@G@@QBEGXZ	; CUtlDict<IEntityFactory *,unsigned short>::First
PUBLIC	?Next@?$CUtlDict@PAVIEntityFactory@@G@@QBEGG@Z	; CUtlDict<IEntityFactory *,unsigned short>::Next
PUBLIC	??_C@_0P@PHFE@?5?$CFs?3?5?$CFd?5bytes?6?$AA@	; `string'
;	COMDAT ??_C@_0P@PHFE@?5?$CFs?3?5?$CFd?5bytes?6?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0P@PHFE@?5?$CFs?3?5?$CFd?5bytes?6?$AA@ DB ' %s: %d bytes', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?ReportEntitySizes@CEntityFactoryDictionary@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?ReportEntitySizes@CEntityFactoryDictionary@@QAEXXZ PROC NEAR ; CEntityFactoryDictionary::ReportEntitySizes, COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 	for( int i = m_Factories.First(); i != m_Factories.InvalidIndex(); i = m_Factories.Next( i ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?First@?$CUtlDict@PAVIEntityFactory@@G@@QBEGXZ ; CUtlDict<IEntityFactory *,unsigned short>::First
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L40481
$L40482:
	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Next@?$CUtlDict@PAVIEntityFactory@@G@@QBEGG@Z ; CUtlDict<IEntityFactory *,unsigned short>::Next
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _i$[ebp], eax
$L40481:
	call	?InvalidIndex@?$CUtlDict@PAVIEntityFactory@@G@@SAGXZ ; CUtlDict<IEntityFactory *,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	DWORD PTR _i$[ebp], eax
	je	SHORT $L40483

; 143  : 		ALERT( at_console, " %s: %d bytes\n", m_Factories.GetElementName( i ), m_Factories[i]->GetEntitySize());

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlDict@PAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z ; CUtlDict<IEntityFactory *,unsigned short>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR -12+[ebp], edx
	mov	eax, DWORD PTR -12+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -12+[ebp]
	call	DWORD PTR [edx+8]
	push	eax
	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetElementName@?$CUtlDict@PAVIEntityFactory@@G@@QAEPADG@Z ; CUtlDict<IEntityFactory *,unsigned short>::GetElementName
	push	eax
	push	OFFSET FLAT:??_C@_0P@PHFE@?5?$CFs?3?5?$CFd?5bytes?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 144  : 	}

	jmp	SHORT $L40482
$L40483:

; 145  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReportEntitySizes@CEntityFactoryDictionary@@QAEXXZ ENDP ; CEntityFactoryDictionary::ReportEntitySizes
_TEXT	ENDS
PUBLIC	??_C@_0BP@MELN@Entity?5Factory?5not?5installed?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_03HHKO@?$CFs?6?$AA@			; `string'
PUBLIC	?DumpEntityNames_f@@YAXXZ			; DumpEntityNames_f
;	COMDAT ??_C@_0BP@MELN@Entity?5Factory?5not?5installed?$CB?6?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0BP@MELN@Entity?5Factory?5not?5installed?$CB?6?$AA@ DB 'Entity Fact'
	DB	'ory not installed!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HHKO@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03HHKO@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?DumpEntityNames_f@@YAXXZ
_TEXT	SEGMENT
_dict$ = -4
_i$ = -8
?DumpEntityNames_f@@YAXXZ PROC NEAR			; DumpEntityNames_f, COMDAT

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 149  : 	CEntityFactoryDictionary *dict = (CEntityFactoryDictionary *)EntityFactoryDictionary();

	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR _dict$[ebp], eax

; 150  : 
; 151  : 	if( !dict )

	cmp	DWORD PTR _dict$[ebp], 0
	jne	SHORT $L40490

; 153  : 		ALERT( at_error, "Entity Factory not installed!\n" );

	push	OFFSET FLAT:??_C@_0BP@MELN@Entity?5Factory?5not?5installed?$CB?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 154  : 		return;

	jmp	SHORT $L40487
$L40490:

; 156  : 
; 157  : 	for( int i = dict->m_Factories.First(); i != dict->m_Factories.InvalidIndex(); i = dict->m_Factories.Next( i ))

	mov	ecx, DWORD PTR _dict$[ebp]
	add	ecx, 4
	call	?First@?$CUtlDict@PAVIEntityFactory@@G@@QBEGXZ ; CUtlDict<IEntityFactory *,unsigned short>::First
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L40493
$L40494:
	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dict$[ebp]
	add	ecx, 4
	call	?Next@?$CUtlDict@PAVIEntityFactory@@G@@QBEGG@Z ; CUtlDict<IEntityFactory *,unsigned short>::Next
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _i$[ebp], eax
$L40493:
	call	?InvalidIndex@?$CUtlDict@PAVIEntityFactory@@G@@SAGXZ ; CUtlDict<IEntityFactory *,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	DWORD PTR _i$[ebp], eax
	je	SHORT $L40495

; 159  : 		ALERT( at_console, "%s\n", dict->m_Factories.GetElementName( i ));

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _dict$[ebp]
	add	ecx, 4
	call	?GetElementName@?$CUtlDict@PAVIEntityFactory@@G@@QAEPADG@Z ; CUtlDict<IEntityFactory *,unsigned short>::GetElementName
	push	eax
	push	OFFSET FLAT:??_C@_03HHKO@?$CFs?6?$AA@	; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 160  : 	}

	jmp	SHORT $L40494
$L40495:
$L40487:

; 161  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DumpEntityNames_f@@YAXXZ ENDP				; DumpEntityNames_f
_TEXT	ENDS
PUBLIC	?DumpEntitySizes_f@@YAXXZ			; DumpEntitySizes_f
;	COMDAT ?DumpEntitySizes_f@@YAXXZ
_TEXT	SEGMENT
?DumpEntitySizes_f@@YAXXZ PROC NEAR			; DumpEntitySizes_f, COMDAT

; 164  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 165  : 	((CEntityFactoryDictionary*)EntityFactoryDictionary())->ReportEntitySizes();

	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	ecx, eax
	call	?ReportEntitySizes@CEntityFactoryDictionary@@QAEXXZ ; CEntityFactoryDictionary::ReportEntitySizes

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DumpEntitySizes_f@@YAXXZ ENDP				; DumpEntitySizes_f
_TEXT	ENDS
PUBLIC	?DumpStrings_f@@YAXXZ				; DumpStrings_f
EXTRN	?Dump@CStringPool@@QAEXXZ:NEAR			; CStringPool::Dump
EXTRN	?g_GameStringPool@@3VCStringPool@@A:BYTE	; g_GameStringPool
;	COMDAT ?DumpStrings_f@@YAXXZ
_TEXT	SEGMENT
?DumpStrings_f@@YAXXZ PROC NEAR				; DumpStrings_f, COMDAT

; 169  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 170  : 	g_GameStringPool.Dump();

	mov	ecx, OFFSET FLAT:?g_GameStringPool@@3VCStringPool@@A
	call	?Dump@CStringPool@@QAEXXZ		; CStringPool::Dump

; 171  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DumpStrings_f@@YAXXZ ENDP				; DumpStrings_f
_TEXT	ENDS
PUBLIC	?DBG_AssertFunction@@YAXHPBD0H0@Z		; DBG_AssertFunction
PUBLIC	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z	; UTIL_FunctionToName
PUBLIC	?__LINE__Var@?1??UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z@4FA ; `UTIL_FunctionToName'::`2'::__LINE__Var
PUBLIC	??_C@_0DB@GJLL@sizeof?$CIpMap?9?$DOdataDesc?$FLi?$FN?4func?$CJ?5?$DN@ ; `string'
;	COMDAT ?__LINE__Var@?1??UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z@4FA
; File z:\xashxtsrc\server\util.cpp
_DATA	SEGMENT
?__LINE__Var@?1??UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z@4FA DW 0b7H ; `UTIL_FunctionToName'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DB@GJLL@sizeof?$CIpMap?9?$DOdataDesc?$FLi?$FN?4func?$CJ?5?$DN@
CONST	SEGMENT
??_C@_0DB@GJLL@sizeof?$CIpMap?9?$DOdataDesc?$FLi?$FN?4func?$CJ?5?$DN@ DB 's'
	DB	'izeof(pMap->dataDesc[i].func) == sizeof(void *)', 00H ; `string'
CONST	ENDS
;	COMDAT ?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z
_TEXT	SEGMENT
_pMap$ = 8
_function$ = 12
_i$40512 = -4
_pTest$40520 = -8
?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z PROC NEAR ; UTIL_FunctionToName, COMDAT

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
$L40510:

; 184  : 	while( pMap )

	cmp	DWORD PTR _pMap$[ebp], 0
	je	$L40511

; 186  : 		for( int i = 0; i < pMap->dataNumFields; i++ )

	mov	DWORD PTR _i$40512[ebp], 0
	jmp	SHORT $L40513
$L40514:
	mov	eax, DWORD PTR _i$40512[ebp]
	add	eax, 1
	mov	DWORD PTR _i$40512[ebp], eax
$L40513:
	mov	ecx, DWORD PTR _pMap$[ebp]
	mov	edx, DWORD PTR _i$40512[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $L40515

; 188  : 			if( pMap->dataDesc[i].flags & FTYPEDESC_FUNCTIONTABLE )

	mov	eax, DWORD PTR _i$40512[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _pMap$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, WORD PTR [edx+eax+14]
	and	eax, 8
	test	eax, eax
	je	SHORT $L40522

; 190  : 				ASSERT( sizeof(pMap->dataDesc[i].func) == sizeof(void *));

	push	0
	movsx	ecx, WORD PTR ?__LINE__Var@?1??UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z@4FA ; `UTIL_FunctionToName'::`2'::__LINE__Var
	add	ecx, 7
	push	ecx
	push	OFFSET FLAT:??_C@_0BN@PKKM@z?3?2xashxtsrc?2server?2util?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0DB@GJLL@sizeof?$CIpMap?9?$DOdataDesc?$FLi?$FN?4func?$CJ?5?$DN@ ; `string'
	push	1
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 191  : 				void *pTest = EXTRACT_VOID_FUNCTIONPTR( pMap->dataDesc[i].func );

	mov	edx, DWORD PTR _i$40512[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pMap$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx+20]
	mov	DWORD PTR _pTest$40520[ebp], edx

; 192  : 				if( pTest == function )

	mov	eax, DWORD PTR _pTest$40520[ebp]
	cmp	eax, DWORD PTR _function$[ebp]
	jne	SHORT $L40522

; 193  : 					return pMap->dataDesc[i].fieldName;

	mov	ecx, DWORD PTR _i$40512[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pMap$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $L40508
$L40522:

; 195  : 		}

	jmp	SHORT $L40514
$L40515:

; 196  : 
; 197  : 		pMap = pMap->baseMap;

	mov	ecx, DWORD PTR _pMap$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _pMap$[ebp], edx

; 198  : 	}

	jmp	$L40510
$L40511:

; 199  : 	return NULL;

	xor	eax, eax
$L40508:

; 200  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ENDP	; UTIL_FunctionToName
_TEXT	ENDS
PUBLIC	?UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z ; UTIL_FunctionFromName
PUBLIC	?__LINE__Var@?1??UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z@4FA ; `UTIL_FunctionFromName'::`2'::__LINE__Var
PUBLIC	??_C@_0BM@EHFG@Failed?5to?5find?5function?5?$CFs?6?$AA@ ; `string'
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
;	COMDAT ?__LINE__Var@?1??UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z@4FA
; File z:\xashxtsrc\server\util.cpp
_DATA	SEGMENT
?__LINE__Var@?1??UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z@4FA DW 0d0H ; `UTIL_FunctionFromName'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BM@EHFG@Failed?5to?5find?5function?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BM@EHFG@Failed?5to?5find?5function?5?$CFs?6?$AA@ DB 'Failed to fin'
	DB	'd function %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z
_TEXT	SEGMENT
_pMap$ = 8
_pName$ = 12
_i$40530 = -4
?UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z PROC NEAR ; UTIL_FunctionFromName, COMDAT

; 208  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
$L40528:

; 209  : 	while( pMap )

	cmp	DWORD PTR _pMap$[ebp], 0
	je	$L40529

; 211  : 		for( int i = 0; i < pMap->dataNumFields; i++ )

	mov	DWORD PTR _i$40530[ebp], 0
	jmp	SHORT $L40531
$L40532:
	mov	eax, DWORD PTR _i$40530[ebp]
	add	eax, 1
	mov	DWORD PTR _i$40530[ebp], eax
$L40531:
	mov	ecx, DWORD PTR _pMap$[ebp]
	mov	edx, DWORD PTR _i$40530[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $L40533

; 213  : 			ASSERT( sizeof(pMap->dataDesc[i].func) == sizeof(void *));

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z@4FA ; `UTIL_FunctionFromName'::`2'::__LINE__Var
	add	eax, 5
	push	eax
	push	OFFSET FLAT:??_C@_0BN@PKKM@z?3?2xashxtsrc?2server?2util?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0DB@GJLL@sizeof?$CIpMap?9?$DOdataDesc?$FLi?$FN?4func?$CJ?5?$DN@ ; `string'
	push	1
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 214  : 
; 215  : 			if( pMap->dataDesc[i].flags & FTYPEDESC_FUNCTIONTABLE )

	mov	ecx, DWORD PTR _i$40530[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pMap$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, WORD PTR [eax+ecx+14]
	and	ecx, 8
	test	ecx, ecx
	je	SHORT $L40537

; 217  : 				if( FStrEq( pName, pMap->dataDesc[i].fieldName ))

	mov	edx, DWORD PTR _i$40530[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pMap$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx+4]
	push	edx
	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L40537

; 219  : 					return EXTRACT_VOID_FUNCTIONPTR( pMap->dataDesc[i].func );

	mov	ecx, DWORD PTR _i$40530[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _pMap$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx+20]
	jmp	SHORT $L40526
$L40537:

; 222  : 		}

	jmp	SHORT $L40532
$L40533:

; 223  : 		pMap = pMap->baseMap;

	mov	ecx, DWORD PTR _pMap$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _pMap$[ebp], edx

; 224  : 	}

	jmp	$L40528
$L40529:

; 225  : 
; 226  : 	ALERT( at_error, "Failed to find function %s\n", pName );

	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BM@EHFG@Failed?5to?5find?5function?5?$CFs?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 227  : 
; 228  : 	return NULL;

	xor	eax, eax
$L40526:

; 229  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z ENDP	; UTIL_FunctionFromName
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
PUBLIC	?Msg@@YAXPBDZZ					; Msg
EXTRN	?Q_vsnprintf@@YAHPADIPBD0@Z:NEAR		; Q_vsnprintf
_BSS	SEGMENT
	ALIGN	4

_?value@?1??Msg@@YAXPBDZZ@4PADA DB 0400H DUP (?)
_BSS	ENDS
;	COMDAT ?Msg@@YAXPBDZZ
_TEXT	SEGMENT
_szText$ = 8
_szCommand$ = -4
?Msg@@YAXPBDZZ PROC NEAR				; Msg, COMDAT

; 232  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 233  : 	va_list szCommand;
; 234  : 	static char value[1024];
; 235  : 
; 236  : 	va_start( szCommand, szText );

	lea	eax, DWORD PTR _szText$[ebp+4]
	mov	DWORD PTR _szCommand$[ebp], eax

; 237  : 	Q_vsnprintf( value, sizeof( value ), szText, szCommand );

	mov	ecx, DWORD PTR _szCommand$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szText$[ebp]
	push	edx
	push	1024					; 00000400H
	push	OFFSET FLAT:_?value@?1??Msg@@YAXPBDZZ@4PADA
	call	?Q_vsnprintf@@YAHPADIPBD0@Z		; Q_vsnprintf
	add	esp, 16					; 00000010H

; 238  : 	va_end( szCommand ); 

	mov	DWORD PTR _szCommand$[ebp], 0

; 239  :  
; 240  : 	g_engfuncs.pfnAlertMessage( at_console, value );

	push	OFFSET FLAT:_?value@?1??Msg@@YAXPBDZZ@4PADA
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 241  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Msg@@YAXPBDZZ ENDP					; Msg
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
PUBLIC	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z		; ENT
;	COMDAT ?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z PROC NEAR	; ENT, COMDAT

; 244  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 245  : 	if( pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L40554

; 246  : 		return ENT( pEntity->pev );

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	jmp	SHORT $L40553
$L40554:

; 247  : 	return NULL;

	xor	eax, eax
$L40553:

; 248  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z	; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	?FNullEnt@@YAHPBUedict_s@@@Z			; FNullEnt
PUBLIC	?FNullEnt@@YAHPAVCBaseEntity@@@Z		; FNullEnt
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
;	COMDAT ?FNullEnt@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_ent$ = 8
?FNullEnt@@YAHPAVCBaseEntity@@@Z PROC NEAR		; FNullEnt, COMDAT

; 251  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 252  : 	return (ent == NULL) || FNullEnt( ent->edict( ));

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $L43632
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L43632
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L43633
$L43632:
	mov	DWORD PTR -4+[ebp], 1
$L43633:
	mov	eax, DWORD PTR -4+[ebp]

; 253  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAVCBaseEntity@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?FNullEnt@@YAHPBUedict_s@@@Z PROC NEAR			; FNullEnt, COMDAT

; 195  : inline BOOL FNullEnt(const edict_t* pent)	{ return pent == NULL || FNullEnt(OFFSET(pent)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L43636
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L43636
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L43637
$L43636:
	mov	DWORD PTR -4+[ebp], 1
$L43637:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPBUedict_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
PUBLIC	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z		; FClassnameIs
;	COMDAT ?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z
_TEXT	SEGMENT
_pEnt$ = 8
_szClassname$ = 12
?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z PROC NEAR	; FClassnameIs, COMDAT

; 256  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 257  : 	return FStrEq( pEnt->GetClassname(), szClassname );

	mov	eax, DWORD PTR _szClassname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8

; 258  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z ENDP		; FClassnameIs
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	?VecBModelOrigin@@YA?AVVector@@PAUentvars_s@@@Z	; VecBModelOrigin
EXTRN	__fltused:NEAR
;	COMDAT ?VecBModelOrigin@@YA?AVVector@@PAUentvars_s@@@Z
_TEXT	SEGMENT
_pevBModel$ = 12
___$ReturnUdt$ = 8
$T43650 = -12
$T43651 = -24
?VecBModelOrigin@@YA?AVVector@@PAUentvars_s@@@Z PROC NEAR ; VecBModelOrigin, COMDAT

; 264  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 265  : 	return pevBModel->absmin + ( pevBModel->size * 0.5f );

	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T43650[ebp]
	push	eax
	mov	ecx, DWORD PTR _pevBModel$[ebp]
	add	ecx, 244				; 000000f4H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T43651[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pevBModel$[ebp]
	add	ecx, 196				; 000000c4H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 266  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VecBModelOrigin@@YA?AVVector@@PAUentvars_s@@@Z ENDP	; VecBModelOrigin
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T43657 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T43657[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T43662 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T43662[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
PUBLIC	?UTIL_SetGroupTrace@@YAXHH@Z			; UTIL_SetGroupTrace
;	COMDAT ?UTIL_SetGroupTrace@@YAXHH@Z
_TEXT	SEGMENT
_groupmask$ = 8
_op$ = 12
?UTIL_SetGroupTrace@@YAXHH@Z PROC NEAR			; UTIL_SetGroupTrace, COMDAT

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 274  : 	g_groupmask		= groupmask;

	mov	eax, DWORD PTR _groupmask$[ebp]
	mov	DWORD PTR ?g_groupmask@@3HA, eax	; g_groupmask

; 275  : 	g_groupop		= op;

	mov	ecx, DWORD PTR _op$[ebp]
	mov	DWORD PTR ?g_groupop@@3HA, ecx		; g_groupop

; 276  : 
; 277  : 	ENGINE_SETGROUPMASK( g_groupmask, g_groupop );

	mov	edx, DWORD PTR ?g_groupop@@3HA		; g_groupop
	push	edx
	mov	eax, DWORD PTR ?g_groupmask@@3HA	; g_groupmask
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+540
	add	esp, 8

; 278  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_SetGroupTrace@@YAXHH@Z ENDP			; UTIL_SetGroupTrace
_TEXT	ENDS
PUBLIC	?UTIL_UnsetGroupTrace@@YAXXZ			; UTIL_UnsetGroupTrace
;	COMDAT ?UTIL_UnsetGroupTrace@@YAXXZ
_TEXT	SEGMENT
?UTIL_UnsetGroupTrace@@YAXXZ PROC NEAR			; UTIL_UnsetGroupTrace, COMDAT

; 281  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 282  : 	g_groupmask		= 0;

	mov	DWORD PTR ?g_groupmask@@3HA, 0		; g_groupmask

; 283  : 	g_groupop		= 0;

	mov	DWORD PTR ?g_groupop@@3HA, 0		; g_groupop

; 284  : 
; 285  : 	ENGINE_SETGROUPMASK( 0, 0 );

	push	0
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+540
	add	esp, 8

; 286  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_UnsetGroupTrace@@YAXXZ ENDP			; UTIL_UnsetGroupTrace
_TEXT	ENDS
PUBLIC	??0UTIL_GroupTrace@@QAE@HH@Z			; UTIL_GroupTrace::UTIL_GroupTrace
;	COMDAT ??0UTIL_GroupTrace@@QAE@HH@Z
_TEXT	SEGMENT
_groupmask$ = 8
_op$ = 12
_this$ = -4
??0UTIL_GroupTrace@@QAE@HH@Z PROC NEAR			; UTIL_GroupTrace::UTIL_GroupTrace, COMDAT

; 290  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 291  : 	m_oldgroupmask	= g_groupmask;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?g_groupmask@@3HA	; g_groupmask
	mov	DWORD PTR [eax], ecx

; 292  : 	m_oldgroupop	= g_groupop;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?g_groupop@@3HA		; g_groupop
	mov	DWORD PTR [edx+4], eax

; 293  : 
; 294  : 	g_groupmask		= groupmask;

	mov	ecx, DWORD PTR _groupmask$[ebp]
	mov	DWORD PTR ?g_groupmask@@3HA, ecx	; g_groupmask

; 295  : 	g_groupop		= op;

	mov	edx, DWORD PTR _op$[ebp]
	mov	DWORD PTR ?g_groupop@@3HA, edx		; g_groupop

; 296  : 
; 297  : 	ENGINE_SETGROUPMASK( g_groupmask, g_groupop );

	mov	eax, DWORD PTR ?g_groupop@@3HA		; g_groupop
	push	eax
	mov	ecx, DWORD PTR ?g_groupmask@@3HA	; g_groupmask
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+540
	add	esp, 8

; 298  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0UTIL_GroupTrace@@QAE@HH@Z ENDP			; UTIL_GroupTrace::UTIL_GroupTrace
_TEXT	ENDS
PUBLIC	??1UTIL_GroupTrace@@QAE@XZ			; UTIL_GroupTrace::~UTIL_GroupTrace
;	COMDAT ??1UTIL_GroupTrace@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1UTIL_GroupTrace@@QAE@XZ PROC NEAR			; UTIL_GroupTrace::~UTIL_GroupTrace, COMDAT

; 301  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 302  : 	g_groupmask		=	m_oldgroupmask;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR ?g_groupmask@@3HA, ecx	; g_groupmask

; 303  : 	g_groupop		=	m_oldgroupop;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR ?g_groupop@@3HA, eax		; g_groupop

; 304  : 
; 305  : 	ENGINE_SETGROUPMASK( g_groupmask, g_groupop );

	mov	ecx, DWORD PTR ?g_groupop@@3HA		; g_groupop
	push	ecx
	mov	edx, DWORD PTR ?g_groupmask@@3HA	; g_groupmask
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+540
	add	esp, 8

; 306  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1UTIL_GroupTrace@@QAE@XZ ENDP				; UTIL_GroupTrace::~UTIL_GroupTrace
_TEXT	ENDS
PUBLIC	??_C@_0DJ@HFNF@entvars_t?5pContainingEntity?5is?5N@ ; `string'
PUBLIC	??_C@_0DC@DIHB@DAMN?$CB?5?5Even?5the?5engine?5couldn?8t?5@ ; `string'
;	COMDAT ??_C@_0DJ@HFNF@entvars_t?5pContainingEntity?5is?5N@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0DJ@HFNF@entvars_t?5pContainingEntity?5is?5N@ DB 'entvars_t pContai'
	DB	'ningEntity is NULL, calling into engine', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DIHB@DAMN?$CB?5?5Even?5the?5engine?5couldn?8t?5@
CONST	SEGMENT
??_C@_0DC@DIHB@DAMN?$CB?5?5Even?5the?5engine?5couldn?8t?5@ DB 'DAMN!  Eve'
	DB	'n the engine couldn''t FindEntityByVars!', 00H ; `string'
CONST	ENDS
;	COMDAT ?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
_pent$ = -4
?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR ; DBG_EntOfVars, COMDAT

; 310  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 311  : 	if (pev->pContainingEntity != NULL)

	mov	eax, DWORD PTR _pev$[ebp]
	cmp	DWORD PTR [eax+520], 0
	je	SHORT $L40587

; 312  : 		return pev->pContainingEntity;

	mov	ecx, DWORD PTR _pev$[ebp]
	mov	eax, DWORD PTR [ecx+520]
	jmp	SHORT $L40586
$L40587:

; 313  : 	ALERT(at_console, "entvars_t pContainingEntity is NULL, calling into engine");

	push	OFFSET FLAT:??_C@_0DJ@HFNF@entvars_t?5pContainingEntity?5is?5N@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 314  : 	edict_t* pent = (*g_engfuncs.pfnFindEntityByVars)((entvars_t*)pev);

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+292
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax

; 315  : 	if (pent == NULL)

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L40591

; 316  : 		ALERT(at_console, "DAMN!  Even the engine couldn't FindEntityByVars!");

	push	OFFSET FLAT:??_C@_0DC@DIHB@DAMN?$CB?5?5Even?5the?5engine?5couldn?8t?5@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L40591:

; 317  : 	((entvars_t *)pev)->pContainingEntity = pent;

	mov	eax, DWORD PTR _pev$[ebp]
	mov	ecx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [eax+520], ecx

; 318  : 	return pent;

	mov	eax, DWORD PTR _pent$[ebp]
$L40586:

; 319  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP	; DBG_EntOfVars
_TEXT	ENDS
PUBLIC	??_C@_0BP@IFKE@ASSERT?5FAILED?3?6?5?$CFs?5?6?$CI?$CFs?$EA?$CFd?$CJ?6?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BM@NII@ASSERT?5FAILED?3?6?5?$CFs?5?6?$CI?$CFs?$EA?$CFd?$CJ?$AA@ ; `string'
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_0BP@IFKE@ASSERT?5FAILED?3?6?5?$CFs?5?6?$CI?$CFs?$EA?$CFd?$CJ?6?$CFs?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0BP@IFKE@ASSERT?5FAILED?3?6?5?$CFs?5?6?$CI?$CFs?$EA?$CFd?$CJ?6?$CFs?$AA@ DB 'A'
	DB	'SSERT FAILED:', 0aH, ' %s ', 0aH, '(%s@%d)', 0aH, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NII@ASSERT?5FAILED?3?6?5?$CFs?5?6?$CI?$CFs?$EA?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BM@NII@ASSERT?5FAILED?3?6?5?$CFs?5?6?$CI?$CFs?$EA?$CFd?$CJ?$AA@ DB 'A'
	DB	'SSERT FAILED:', 0aH, ' %s ', 0aH, '(%s@%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ?DBG_AssertFunction@@YAXHPBD0H0@Z
_TEXT	SEGMENT
_fExpr$ = 8
_szExpr$ = 12
_szFile$ = 16
_szLine$ = 20
_szMessage$ = 24
_szOut$ = -512
?DBG_AssertFunction@@YAXHPBD0H0@Z PROC NEAR		; DBG_AssertFunction, COMDAT

; 331  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 576				; 00000240H
	push	ebx
	push	esi
	push	edi

; 332  : 	if (fExpr)

	cmp	DWORD PTR _fExpr$[ebp], 0
	je	SHORT $L40601

; 333  : 		return;

	jmp	SHORT $L40600
$L40601:

; 335  : 	if (szMessage != NULL)

	cmp	DWORD PTR _szMessage$[ebp], 0
	je	SHORT $L40603

; 336  : 		sprintf(szOut, "ASSERT FAILED:\n %s \n(%s@%d)\n%s", szExpr, szFile, szLine, szMessage);

	mov	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _szExpr$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BP@IFKE@ASSERT?5FAILED?3?6?5?$CFs?5?6?$CI?$CFs?$EA?$CFd?$CJ?6?$CFs?$AA@ ; `string'
	lea	ecx, DWORD PTR _szOut$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 24					; 00000018H

; 337  : 	else

	jmp	SHORT $L40605
$L40603:

; 338  : 		sprintf(szOut, "ASSERT FAILED:\n %s \n(%s@%d)", szExpr, szFile, szLine);

	mov	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _szFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szExpr$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BM@NII@ASSERT?5FAILED?3?6?5?$CFs?5?6?$CI?$CFs?$EA?$CFd?$CJ?$AA@ ; `string'
	lea	edx, DWORD PTR _szOut$[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H
$L40605:

; 339  : 	ALERT(at_console, szOut);

	lea	eax, DWORD PTR _szOut$[ebp]
	push	eax
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L40600:

; 340  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DBG_AssertFunction@@YAXHPBD0H0@Z ENDP			; DBG_AssertFunction
_TEXT	ENDS
PUBLIC	?UTIL_PrecacheSound@@YAHH@Z			; UTIL_PrecacheSound
PUBLIC	?UTIL_LoadSoundPreset@@YAHH@Z			; UTIL_LoadSoundPreset
PUBLIC	??_C@_0BA@LNFJ@common?1null?4wav?$AA@		; `string'
PUBLIC	??_C@_0BE@HEE@buttons?1button1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@OHCL@buttons?1button2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@EHAO@buttons?1button3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@CHPE@buttons?1button4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@IHNB@buttons?1button5?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@GHLO@buttons?1button6?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@MHJL@buttons?1button7?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@KGEL@buttons?1button8?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@GGO@buttons?1button9?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@IGAC@buttons?1button10?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@CGCH@buttons?1button11?4wav?$AA@	; `string'
PUBLIC	??_C@_0BJ@EOKP@buttons?1latchlocked1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BL@LEDH@buttons?1latchunlocked1?4wav?$AA@ ; `string'
PUBLIC	??_C@_0BJ@HKMK@buttons?1lightswitch2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@BHHD@buttons?1lever1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@PHBM@buttons?1lever2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@FHDJ@buttons?1lever3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@DHMD@buttons?1lever4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@JHOG@buttons?1lever5?4wav?$AA@	; `string'
PUBLIC	?UTIL_ButtonSound@@YAPBDH@Z			; UTIL_ButtonSound
;	COMDAT ??_C@_0BA@LNFJ@common?1null?4wav?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0BA@LNFJ@common?1null?4wav?$AA@ DB 'common/null.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HEE@buttons?1button1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@HEE@buttons?1button1?4wav?$AA@ DB 'buttons/button1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OHCL@buttons?1button2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@OHCL@buttons?1button2?4wav?$AA@ DB 'buttons/button2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EHAO@buttons?1button3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@EHAO@buttons?1button3?4wav?$AA@ DB 'buttons/button3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CHPE@buttons?1button4?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@CHPE@buttons?1button4?4wav?$AA@ DB 'buttons/button4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IHNB@buttons?1button5?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@IHNB@buttons?1button5?4wav?$AA@ DB 'buttons/button5.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GHLO@buttons?1button6?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@GHLO@buttons?1button6?4wav?$AA@ DB 'buttons/button6.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MHJL@buttons?1button7?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@MHJL@buttons?1button7?4wav?$AA@ DB 'buttons/button7.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KGEL@buttons?1button8?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@KGEL@buttons?1button8?4wav?$AA@ DB 'buttons/button8.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGO@buttons?1button9?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@GGO@buttons?1button9?4wav?$AA@ DB 'buttons/button9.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IGAC@buttons?1button10?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@IGAC@buttons?1button10?4wav?$AA@ DB 'buttons/button10.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CGCH@buttons?1button11?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@CGCH@buttons?1button11?4wav?$AA@ DB 'buttons/button11.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EOKP@buttons?1latchlocked1?4wav?$AA@
CONST	SEGMENT
??_C@_0BJ@EOKP@buttons?1latchlocked1?4wav?$AA@ DB 'buttons/latchlocked1.w'
	DB	'av', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LEDH@buttons?1latchunlocked1?4wav?$AA@
CONST	SEGMENT
??_C@_0BL@LEDH@buttons?1latchunlocked1?4wav?$AA@ DB 'buttons/latchunlocke'
	DB	'd1.wav', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HKMK@buttons?1lightswitch2?4wav?$AA@
CONST	SEGMENT
??_C@_0BJ@HKMK@buttons?1lightswitch2?4wav?$AA@ DB 'buttons/lightswitch2.w'
	DB	'av', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BHHD@buttons?1lever1?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@BHHD@buttons?1lever1?4wav?$AA@ DB 'buttons/lever1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PHBM@buttons?1lever2?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@PHBM@buttons?1lever2?4wav?$AA@ DB 'buttons/lever2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FHDJ@buttons?1lever3?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@FHDJ@buttons?1lever3?4wav?$AA@ DB 'buttons/lever3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DHMD@buttons?1lever4?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@DHMD@buttons?1lever4?4wav?$AA@ DB 'buttons/lever4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JHOG@buttons?1lever5?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@JHOG@buttons?1lever5?4wav?$AA@ DB 'buttons/lever5.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?UTIL_ButtonSound@@YAPBDH@Z
_TEXT	SEGMENT
_sound$ = 8
_pszSound$ = -4
_m_iSoundString$ = -8
?UTIL_ButtonSound@@YAPBDH@Z PROC NEAR			; UTIL_ButtonSound, COMDAT

; 347  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 348  : 	const char *pszSound;
; 349  : 
; 350  : 	int m_iSoundString = UTIL_LoadSoundPreset( sound );

	mov	eax, DWORD PTR _sound$[ebp]
	push	eax
	call	?UTIL_LoadSoundPreset@@YAHH@Z		; UTIL_LoadSoundPreset
	add	esp, 4
	mov	DWORD PTR _m_iSoundString$[ebp], eax

; 353  : 	{

	mov	ecx, DWORD PTR _m_iSoundString$[ebp]
	mov	DWORD PTR -12+[ebp], ecx
	cmp	DWORD PTR -12+[ebp], 25			; 00000019H
	ja	$L40656
	mov	edx, DWORD PTR -12+[ebp]
	jmp	DWORD PTR $L43677[edx*4]
$L40616:

; 354  : 	case 0: pszSound = "common/null.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BA@LNFJ@common?1null?4wav?$AA@ ; `string'
	jmp	$L40613
$L40618:

; 355  : 	case 1: pszSound = "buttons/button1.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BE@HEE@buttons?1button1?4wav?$AA@ ; `string'
	jmp	$L40613
$L40620:

; 356  : 	case 2: pszSound = "buttons/button2.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BE@OHCL@buttons?1button2?4wav?$AA@ ; `string'
	jmp	$L40613
$L40622:

; 357  : 	case 3: pszSound = "buttons/button3.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BE@EHAO@buttons?1button3?4wav?$AA@ ; `string'
	jmp	$L40613
$L40624:

; 358  : 	case 4: pszSound = "buttons/button4.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BE@CHPE@buttons?1button4?4wav?$AA@ ; `string'
	jmp	$L40613
$L40626:

; 359  : 	case 5: pszSound = "buttons/button5.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BE@IHNB@buttons?1button5?4wav?$AA@ ; `string'
	jmp	$L40613
$L40628:

; 360  : 	case 6: pszSound = "buttons/button6.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BE@GHLO@buttons?1button6?4wav?$AA@ ; `string'
	jmp	$L40613
$L40630:

; 361  : 	case 7: pszSound = "buttons/button7.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BE@MHJL@buttons?1button7?4wav?$AA@ ; `string'
	jmp	$L40613
$L40632:

; 362  : 	case 8: pszSound = "buttons/button8.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BE@KGEL@buttons?1button8?4wav?$AA@ ; `string'
	jmp	SHORT $L40613
$L40634:

; 363  : 	case 9: pszSound = "buttons/button9.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BE@GGO@buttons?1button9?4wav?$AA@ ; `string'
	jmp	SHORT $L40613
$L40636:

; 364  : 	case 10: pszSound = "buttons/button10.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BF@IGAC@buttons?1button10?4wav?$AA@ ; `string'
	jmp	SHORT $L40613
$L40638:

; 365  : 	case 11: pszSound = "buttons/button11.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BF@CGCH@buttons?1button11?4wav?$AA@ ; `string'
	jmp	SHORT $L40613
$L40640:

; 366  : 	case 12: pszSound = "buttons/latchlocked1.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BJ@EOKP@buttons?1latchlocked1?4wav?$AA@ ; `string'
	jmp	SHORT $L40613
$L40642:

; 367  : 	case 13: pszSound = "buttons/latchunlocked1.wav";	break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BL@LEDH@buttons?1latchunlocked1?4wav?$AA@ ; `string'
	jmp	SHORT $L40613
$L40644:

; 368  : 	case 14: pszSound = "buttons/lightswitch2.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BJ@HKMK@buttons?1lightswitch2?4wav?$AA@ ; `string'
	jmp	SHORT $L40613
$L40646:

; 369  : 
; 370  : // next 6 slots reserved for any additional sliding button sounds we may add
; 371  : 	
; 372  : 	case 21: pszSound = "buttons/lever1.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BD@BHHD@buttons?1lever1?4wav?$AA@ ; `string'
	jmp	SHORT $L40613
$L40648:

; 373  : 	case 22: pszSound = "buttons/lever2.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BD@PHBM@buttons?1lever2?4wav?$AA@ ; `string'
	jmp	SHORT $L40613
$L40650:

; 374  : 	case 23: pszSound = "buttons/lever3.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BD@FHDJ@buttons?1lever3?4wav?$AA@ ; `string'
	jmp	SHORT $L40613
$L40652:

; 375  : 	case 24: pszSound = "buttons/lever4.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BD@DHMD@buttons?1lever4?4wav?$AA@ ; `string'
	jmp	SHORT $L40613
$L40654:

; 376  : 	case 25: pszSound = "buttons/lever5.wav"; break;

	mov	DWORD PTR _pszSound$[ebp], OFFSET FLAT:??_C@_0BD@JHOG@buttons?1lever5?4wav?$AA@ ; `string'
	jmp	SHORT $L40613
$L40656:

; 377  : 	default: pszSound = STRING( UTIL_PrecacheSound( m_iSoundString )); break;

	mov	eax, DWORD PTR _m_iSoundString$[ebp]
	push	eax
	call	?UTIL_PrecacheSound@@YAHH@Z		; UTIL_PrecacheSound
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _pszSound$[ebp], eax
$L40613:

; 379  : 
; 380  : 	return pszSound;

	mov	eax, DWORD PTR _pszSound$[ebp]

; 381  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L43677:
	DD	$L40616
	DD	$L40618
	DD	$L40620
	DD	$L40622
	DD	$L40624
	DD	$L40626
	DD	$L40628
	DD	$L40630
	DD	$L40632
	DD	$L40634
	DD	$L40636
	DD	$L40638
	DD	$L40640
	DD	$L40642
	DD	$L40644
	DD	$L40656
	DD	$L40656
	DD	$L40656
	DD	$L40656
	DD	$L40656
	DD	$L40656
	DD	$L40646
	DD	$L40648
	DD	$L40650
	DD	$L40652
	DD	$L40654
?UTIL_ButtonSound@@YAPBDH@Z ENDP			; UTIL_ButtonSound
_TEXT	ENDS
PUBLIC	??_C@_06EGA@USE_ON?$AA@				; `string'
PUBLIC	??_C@_07IAOC@USE_OFF?$AA@			; `string'
PUBLIC	??_C@_0L@KHMF@USE_TOGGLE?$AA@			; `string'
PUBLIC	??_C@_07LOMG@USE_SET?$AA@			; `string'
PUBLIC	??_C@_09NHHJ@USE_RESET?$AA@			; `string'
PUBLIC	??_C@_0L@JJEM@USE_REMOVE?$AA@			; `string'
PUBLIC	??_C@_0BC@BPKL@UNKNOWN?5USE_TYPE?$CB?$AA@	; `string'
PUBLIC	?GetStringForUseType@@YAPBDW4USE_TYPE@@@Z	; GetStringForUseType
;	COMDAT ??_C@_06EGA@USE_ON?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_06EGA@USE_ON?$AA@ DB 'USE_ON', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IAOC@USE_OFF?$AA@
CONST	SEGMENT
??_C@_07IAOC@USE_OFF?$AA@ DB 'USE_OFF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHMF@USE_TOGGLE?$AA@
CONST	SEGMENT
??_C@_0L@KHMF@USE_TOGGLE?$AA@ DB 'USE_TOGGLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LOMG@USE_SET?$AA@
CONST	SEGMENT
??_C@_07LOMG@USE_SET?$AA@ DB 'USE_SET', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NHHJ@USE_RESET?$AA@
CONST	SEGMENT
??_C@_09NHHJ@USE_RESET?$AA@ DB 'USE_RESET', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JJEM@USE_REMOVE?$AA@
CONST	SEGMENT
??_C@_0L@JJEM@USE_REMOVE?$AA@ DB 'USE_REMOVE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BPKL@UNKNOWN?5USE_TYPE?$CB?$AA@
CONST	SEGMENT
??_C@_0BC@BPKL@UNKNOWN?5USE_TYPE?$CB?$AA@ DB 'UNKNOWN USE_TYPE!', 00H ; `string'
CONST	ENDS
;	COMDAT ?GetStringForUseType@@YAPBDW4USE_TYPE@@@Z
_TEXT	SEGMENT
_useType$ = 8
?GetStringForUseType@@YAPBDW4USE_TYPE@@@Z PROC NEAR	; GetStringForUseType, COMDAT

; 384  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 386  : 	{

	mov	eax, DWORD PTR _useType$[ebp]
	mov	DWORD PTR -4+[ebp], eax
	cmp	DWORD PTR -4+[ebp], 5
	ja	SHORT $L40676
	mov	ecx, DWORD PTR -4+[ebp]
	jmp	DWORD PTR $L43680[ecx*4]
$L40664:

; 387  : 	case USE_ON: return "USE_ON";

	mov	eax, OFFSET FLAT:??_C@_06EGA@USE_ON?$AA@ ; `string'
	jmp	SHORT $L40661
$L40666:

; 388  : 	case USE_OFF: return "USE_OFF";

	mov	eax, OFFSET FLAT:??_C@_07IAOC@USE_OFF?$AA@ ; `string'
	jmp	SHORT $L40661
$L40668:

; 389  : 	case USE_TOGGLE: return "USE_TOGGLE";

	mov	eax, OFFSET FLAT:??_C@_0L@KHMF@USE_TOGGLE?$AA@ ; `string'
	jmp	SHORT $L40661
$L40670:

; 390  : 	case USE_SET: return "USE_SET";

	mov	eax, OFFSET FLAT:??_C@_07LOMG@USE_SET?$AA@ ; `string'
	jmp	SHORT $L40661
$L40672:

; 391  : 	case USE_RESET: return "USE_RESET";

	mov	eax, OFFSET FLAT:??_C@_09NHHJ@USE_RESET?$AA@ ; `string'
	jmp	SHORT $L40661
$L40674:

; 392  : 	case USE_REMOVE: return "USE_REMOVE";

	mov	eax, OFFSET FLAT:??_C@_0L@JJEM@USE_REMOVE?$AA@ ; `string'
	jmp	SHORT $L40661
$L40676:

; 393  : 	default: return "UNKNOWN USE_TYPE!";

	mov	eax, OFFSET FLAT:??_C@_0BC@BPKL@UNKNOWN?5USE_TYPE?$CB?$AA@ ; `string'
$L40661:

; 395  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L43680:
	DD	$L40666
	DD	$L40664
	DD	$L40670
	DD	$L40668
	DD	$L40672
	DD	$L40674
?GetStringForUseType@@YAPBDW4USE_TYPE@@@Z ENDP		; GetStringForUseType
_TEXT	ENDS
PUBLIC	??_C@_02HAKO@ON?$AA@				; `string'
PUBLIC	??_C@_03CMJG@OFF?$AA@				; `string'
PUBLIC	??_C@_07NPIG@TURN?5ON?$AA@			; `string'
PUBLIC	??_C@_08CGDJ@TURN?5OFF?$AA@			; `string'
PUBLIC	??_C@_06NCDP@IN?5USE?$AA@			; `string'
PUBLIC	??_C@_04ONLI@DEAD?$AA@				; `string'
PUBLIC	??_C@_0P@FIJK@UNKNOWN?5STATE?$CB?$AA@		; `string'
PUBLIC	?GetStringForState@@YAPBDW4STATE@@@Z		; GetStringForState
;	COMDAT ??_C@_02HAKO@ON?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_02HAKO@ON?$AA@ DB 'ON', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CMJG@OFF?$AA@
CONST	SEGMENT
??_C@_03CMJG@OFF?$AA@ DB 'OFF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NPIG@TURN?5ON?$AA@
CONST	SEGMENT
??_C@_07NPIG@TURN?5ON?$AA@ DB 'TURN ON', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CGDJ@TURN?5OFF?$AA@
CONST	SEGMENT
??_C@_08CGDJ@TURN?5OFF?$AA@ DB 'TURN OFF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NCDP@IN?5USE?$AA@
CONST	SEGMENT
??_C@_06NCDP@IN?5USE?$AA@ DB 'IN USE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ONLI@DEAD?$AA@
CONST	SEGMENT
??_C@_04ONLI@DEAD?$AA@ DB 'DEAD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FIJK@UNKNOWN?5STATE?$CB?$AA@
CONST	SEGMENT
??_C@_0P@FIJK@UNKNOWN?5STATE?$CB?$AA@ DB 'UNKNOWN STATE!', 00H ; `string'
CONST	ENDS
;	COMDAT ?GetStringForState@@YAPBDW4STATE@@@Z
_TEXT	SEGMENT
_state$ = 8
?GetStringForState@@YAPBDW4STATE@@@Z PROC NEAR		; GetStringForState, COMDAT

; 398  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 400  : 	{

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR -4+[ebp], eax
	cmp	DWORD PTR -4+[ebp], 5
	ja	SHORT $L40697
	mov	ecx, DWORD PTR -4+[ebp]
	jmp	DWORD PTR $L43683[ecx*4]
$L40685:

; 401  : 	case STATE_ON: return "ON";

	mov	eax, OFFSET FLAT:??_C@_02HAKO@ON?$AA@	; `string'
	jmp	SHORT $L40682
$L40687:

; 402  : 	case STATE_OFF: return "OFF";

	mov	eax, OFFSET FLAT:??_C@_03CMJG@OFF?$AA@	; `string'
	jmp	SHORT $L40682
$L40689:

; 403  : 	case STATE_TURN_ON: return "TURN ON";

	mov	eax, OFFSET FLAT:??_C@_07NPIG@TURN?5ON?$AA@ ; `string'
	jmp	SHORT $L40682
$L40691:

; 404  : 	case STATE_TURN_OFF: return "TURN OFF";

	mov	eax, OFFSET FLAT:??_C@_08CGDJ@TURN?5OFF?$AA@ ; `string'
	jmp	SHORT $L40682
$L40693:

; 405  : 	case STATE_IN_USE: return "IN USE";

	mov	eax, OFFSET FLAT:??_C@_06NCDP@IN?5USE?$AA@ ; `string'
	jmp	SHORT $L40682
$L40695:

; 406  : 	case STATE_DEAD: return "DEAD";

	mov	eax, OFFSET FLAT:??_C@_04ONLI@DEAD?$AA@	; `string'
	jmp	SHORT $L40682
$L40697:

; 407  : 	default: return "UNKNOWN STATE!";

	mov	eax, OFFSET FLAT:??_C@_0P@FIJK@UNKNOWN?5STATE?$CB?$AA@ ; `string'
$L40682:

; 409  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L43683:
	DD	$L40687
	DD	$L40685
	DD	$L40689
	DD	$L40691
	DD	$L40693
	DD	$L40695
?GetStringForState@@YAPBDW4STATE@@@Z ENDP		; GetStringForState
_TEXT	ENDS
PUBLIC	??_C@_0BO@PCB@Unknown?5state?5?8?$CFs?8?5specified?6?$AA@ ; `string'
PUBLIC	?GetStateForString@@YA?AW4STATE@@PBD@Z		; GetStateForString
EXTRN	?Q_isdigit@@YA_NPBD@Z:NEAR			; Q_isdigit
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
EXTRN	?Q_strnicmp@@YAHPBD0H@Z:NEAR			; Q_strnicmp
;	COMDAT ??_C@_0BO@PCB@Unknown?5state?5?8?$CFs?8?5specified?6?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0BO@PCB@Unknown?5state?5?8?$CFs?8?5specified?6?$AA@ DB 'Unknown sta'
	DB	'te ''%s'' specified', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?GetStateForString@@YA?AW4STATE@@PBD@Z
_TEXT	SEGMENT
_string$ = 8
?GetStateForString@@YA?AW4STATE@@PBD@Z PROC NEAR	; GetStateForString, COMDAT

; 412  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 413  : 	if( !Q_stricmp( string, "ON" ))

	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_02HAKO@ON?$AA@	; `string'
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L40702

; 414  : 		return STATE_ON;

	mov	eax, 1
	jmp	$L40701
$L40702:

; 415  : 	else if( !Q_stricmp( string, "OFF" ))

	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_03CMJG@OFF?$AA@	; `string'
	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L40704

; 416  : 		return STATE_OFF;

	xor	eax, eax
	jmp	$L40701
$L40704:

; 417  : 	else if( !Q_stricmp( string, "TURN ON" ))

	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_07NPIG@TURN?5ON?$AA@	; `string'
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L40706

; 418  : 		return STATE_TURN_ON;

	mov	eax, 2
	jmp	$L40701
$L40706:

; 419  : 	else if( !Q_stricmp( string, "TURN OFF" ))

	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_08CGDJ@TURN?5OFF?$AA@	; `string'
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L40708

; 420  : 		return STATE_TURN_OFF;

	mov	eax, 3
	jmp	SHORT $L40701
$L40708:

; 421  : 	else if( !Q_stricmp( string, "IN USE" ))

	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_06NCDP@IN?5USE?$AA@	; `string'
	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L40710

; 422  : 		return STATE_IN_USE;

	mov	eax, 4
	jmp	SHORT $L40701
$L40710:

; 423  : 	else if( !Q_stricmp( string, "DEAD" ))

	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_04ONLI@DEAD?$AA@	; `string'
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L40712

; 424  : 		return STATE_DEAD;

	mov	eax, 5
	jmp	SHORT $L40701
$L40712:

; 425  : 	else if( Q_isdigit( string ))

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	?Q_isdigit@@YA_NPBD@Z			; Q_isdigit
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40714

; 426  : 		return (STATE)Q_atoi( string );

	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	jmp	SHORT $L40701
$L40714:

; 427  : 
; 428  : 	// assume error
; 429  : 	ALERT( at_error, "Unknown state '%s' specified\n", string );

	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BO@PCB@Unknown?5state?5?8?$CFs?8?5specified?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 430  : 
; 431  : 	return (STATE)-1;

	or	eax, -1
$L40701:

; 432  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetStateForString@@YA?AW4STATE@@PBD@Z ENDP		; GetStateForString
_TEXT	ENDS
PUBLIC	??_C@_08ELHM@DAMAGE?3?5?$AA@			; `string'
PUBLIC	??_C@_08MDIH@Generic?5?$AA@			; `string'
PUBLIC	??_C@_06KJJ@Crush?5?$AA@			; `string'
PUBLIC	??_C@_07LABF@Bullet?5?$AA@			; `string'
PUBLIC	??_C@_06FDFC@Slash?5?$AA@			; `string'
PUBLIC	??_C@_05PPGG@Burn?5?$AA@			; `string'
PUBLIC	??_C@_07DPFD@Freeze?5?$AA@			; `string'
PUBLIC	??_C@_05MPGH@Fall?5?$AA@			; `string'
PUBLIC	??_C@_06BJKH@Blast?5?$AA@			; `string'
PUBLIC	??_C@_05FEDP@Club?5?$AA@			; `string'
PUBLIC	??_C@_06DMCO@Shock?5?$AA@			; `string'
PUBLIC	??_C@_06PIEK@Sonic?5?$AA@			; `string'
PUBLIC	??_C@_0N@HKFE@Energy?5Beam?5?$AA@		; `string'
PUBLIC	??_C@_0L@GDEN@Never?5Gib?5?$AA@			; `string'
PUBLIC	??_C@_0M@KFMM@Always?5Gib?5?$AA@		; `string'
PUBLIC	??_C@_06OIEJ@Drown?5?$AA@			; `string'
PUBLIC	??_C@_0O@EBHB@Paralyze?5Gas?5?$AA@		; `string'
PUBLIC	??_C@_0L@IHMH@Nerve?5Gas?5?$AA@			; `string'
PUBLIC	??_C@_07LLKI@Poison?5?$AA@			; `string'
PUBLIC	??_C@_0L@DINM@Radiation?5?$AA@			; `string'
PUBLIC	??_C@_0P@BJOK@Drown?5Recover?5?$AA@		; `string'
PUBLIC	??_C@_05EKCB@Acid?5?$AA@			; `string'
PUBLIC	??_C@_0L@PHFJ@Slow?5Burn?5?$AA@			; `string'
PUBLIC	??_C@_0N@ENAO@Slow?5Freeze?5?$AA@		; `string'
PUBLIC	??_C@_07FCKH@Mortar?5?$AA@			; `string'
PUBLIC	??_C@_0BB@GFG@Nuclear?5Explode?5?$AA@		; `string'
PUBLIC	?PrintStringForDamage@@YAXH@Z			; PrintStringForDamage
EXTRN	?Q_strncat@@YAIPADPBDI@Z:NEAR			; Q_strncat
;	COMDAT ??_C@_08ELHM@DAMAGE?3?5?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_08ELHM@DAMAGE?3?5?$AA@ DB 'DAMAGE: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MDIH@Generic?5?$AA@
CONST	SEGMENT
??_C@_08MDIH@Generic?5?$AA@ DB 'Generic ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KJJ@Crush?5?$AA@
CONST	SEGMENT
??_C@_06KJJ@Crush?5?$AA@ DB 'Crush ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LABF@Bullet?5?$AA@
CONST	SEGMENT
??_C@_07LABF@Bullet?5?$AA@ DB 'Bullet ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDFC@Slash?5?$AA@
CONST	SEGMENT
??_C@_06FDFC@Slash?5?$AA@ DB 'Slash ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPGG@Burn?5?$AA@
CONST	SEGMENT
??_C@_05PPGG@Burn?5?$AA@ DB 'Burn ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DPFD@Freeze?5?$AA@
CONST	SEGMENT
??_C@_07DPFD@Freeze?5?$AA@ DB 'Freeze ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPGH@Fall?5?$AA@
CONST	SEGMENT
??_C@_05MPGH@Fall?5?$AA@ DB 'Fall ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BJKH@Blast?5?$AA@
CONST	SEGMENT
??_C@_06BJKH@Blast?5?$AA@ DB 'Blast ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FEDP@Club?5?$AA@
CONST	SEGMENT
??_C@_05FEDP@Club?5?$AA@ DB 'Club ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DMCO@Shock?5?$AA@
CONST	SEGMENT
??_C@_06DMCO@Shock?5?$AA@ DB 'Shock ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PIEK@Sonic?5?$AA@
CONST	SEGMENT
??_C@_06PIEK@Sonic?5?$AA@ DB 'Sonic ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HKFE@Energy?5Beam?5?$AA@
CONST	SEGMENT
??_C@_0N@HKFE@Energy?5Beam?5?$AA@ DB 'Energy Beam ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GDEN@Never?5Gib?5?$AA@
CONST	SEGMENT
??_C@_0L@GDEN@Never?5Gib?5?$AA@ DB 'Never Gib ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KFMM@Always?5Gib?5?$AA@
CONST	SEGMENT
??_C@_0M@KFMM@Always?5Gib?5?$AA@ DB 'Always Gib ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OIEJ@Drown?5?$AA@
CONST	SEGMENT
??_C@_06OIEJ@Drown?5?$AA@ DB 'Drown ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EBHB@Paralyze?5Gas?5?$AA@
CONST	SEGMENT
??_C@_0O@EBHB@Paralyze?5Gas?5?$AA@ DB 'Paralyze Gas ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IHMH@Nerve?5Gas?5?$AA@
CONST	SEGMENT
??_C@_0L@IHMH@Nerve?5Gas?5?$AA@ DB 'Nerve Gas ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LLKI@Poison?5?$AA@
CONST	SEGMENT
??_C@_07LLKI@Poison?5?$AA@ DB 'Poison ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DINM@Radiation?5?$AA@
CONST	SEGMENT
??_C@_0L@DINM@Radiation?5?$AA@ DB 'Radiation ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BJOK@Drown?5Recover?5?$AA@
CONST	SEGMENT
??_C@_0P@BJOK@Drown?5Recover?5?$AA@ DB 'Drown Recover ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05EKCB@Acid?5?$AA@
CONST	SEGMENT
??_C@_05EKCB@Acid?5?$AA@ DB 'Acid ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PHFJ@Slow?5Burn?5?$AA@
CONST	SEGMENT
??_C@_0L@PHFJ@Slow?5Burn?5?$AA@ DB 'Slow Burn ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ENAO@Slow?5Freeze?5?$AA@
CONST	SEGMENT
??_C@_0N@ENAO@Slow?5Freeze?5?$AA@ DB 'Slow Freeze ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FCKH@Mortar?5?$AA@
CONST	SEGMENT
??_C@_07FCKH@Mortar?5?$AA@ DB 'Mortar ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GFG@Nuclear?5Explode?5?$AA@
CONST	SEGMENT
??_C@_0BB@GFG@Nuclear?5Explode?5?$AA@ DB 'Nuclear Explode ', 00H ; `string'
CONST	ENDS
;	COMDAT ?PrintStringForDamage@@YAXH@Z
_TEXT	SEGMENT
_dmgbits$ = 8
_szDmgBits$ = -256
?PrintStringForDamage@@YAXH@Z PROC NEAR			; PrintStringForDamage, COMDAT

; 435  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H
	push	ebx
	push	esi
	push	edi

; 436  : 	char szDmgBits[256];
; 437  : 	Q_strcat( szDmgBits, "DAMAGE: " );

	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_08ELHM@DAMAGE?3?5?$AA@ ; `string'
	lea	eax, DWORD PTR _szDmgBits$[ebp]
	push	eax
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 438  : 
; 439  : 	if( dmgbits & DMG_GENERIC ) Q_strcat( szDmgBits, "Generic " );

	xor	ecx, ecx
	test	ecx, ecx
	je	SHORT $L40723
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_08MDIH@Generic?5?$AA@	; `string'
	lea	edx, DWORD PTR _szDmgBits$[ebp]
	push	edx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40723:

; 440  : 	if( dmgbits & DMG_CRUSH ) Q_strcat( szDmgBits, "Crush "  );

	mov	eax, DWORD PTR _dmgbits$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L40725
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_06KJJ@Crush?5?$AA@	; `string'
	lea	ecx, DWORD PTR _szDmgBits$[ebp]
	push	ecx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40725:

; 441  : 	if( dmgbits & DMG_BULLET ) Q_strcat( szDmgBits, "Bullet "   );

	mov	edx, DWORD PTR _dmgbits$[ebp]
	and	edx, 2
	test	edx, edx
	je	SHORT $L40727
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_07LABF@Bullet?5?$AA@	; `string'
	lea	eax, DWORD PTR _szDmgBits$[ebp]
	push	eax
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40727:

; 442  : 	if( dmgbits & DMG_SLASH ) Q_strcat( szDmgBits, "Slash " );

	mov	ecx, DWORD PTR _dmgbits$[ebp]
	and	ecx, 4
	test	ecx, ecx
	je	SHORT $L40729
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_06FDFC@Slash?5?$AA@	; `string'
	lea	edx, DWORD PTR _szDmgBits$[ebp]
	push	edx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40729:

; 443  : 	if( dmgbits & DMG_BURN ) Q_strcat( szDmgBits, "Burn " );

	mov	eax, DWORD PTR _dmgbits$[ebp]
	and	eax, 8
	test	eax, eax
	je	SHORT $L40731
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_05PPGG@Burn?5?$AA@	; `string'
	lea	ecx, DWORD PTR _szDmgBits$[ebp]
	push	ecx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40731:

; 444  : 	if( dmgbits & DMG_FREEZE ) Q_strcat( szDmgBits, "Freeze "  );

	mov	edx, DWORD PTR _dmgbits$[ebp]
	and	edx, 16					; 00000010H
	test	edx, edx
	je	SHORT $L40733
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_07DPFD@Freeze?5?$AA@	; `string'
	lea	eax, DWORD PTR _szDmgBits$[ebp]
	push	eax
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40733:

; 445  : 	if( dmgbits & DMG_FALL ) Q_strcat( szDmgBits, "Fall " );

	mov	ecx, DWORD PTR _dmgbits$[ebp]
	and	ecx, 32					; 00000020H
	test	ecx, ecx
	je	SHORT $L40735
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_05MPGH@Fall?5?$AA@	; `string'
	lea	edx, DWORD PTR _szDmgBits$[ebp]
	push	edx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40735:

; 446  : 	if( dmgbits & DMG_BLAST ) Q_strcat( szDmgBits, "Blast "  );

	mov	eax, DWORD PTR _dmgbits$[ebp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $L40737
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_06BJKH@Blast?5?$AA@	; `string'
	lea	ecx, DWORD PTR _szDmgBits$[ebp]
	push	ecx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40737:

; 447  : 	if( dmgbits & DMG_CLUB ) Q_strcat( szDmgBits, "Club "   );

	mov	edx, DWORD PTR _dmgbits$[ebp]
	and	edx, 128				; 00000080H
	test	edx, edx
	je	SHORT $L40739
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_05FEDP@Club?5?$AA@	; `string'
	lea	eax, DWORD PTR _szDmgBits$[ebp]
	push	eax
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40739:

; 448  : 	if( dmgbits & DMG_SHOCK ) Q_strcat( szDmgBits, "Shock " );

	mov	ecx, DWORD PTR _dmgbits$[ebp]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	je	SHORT $L40741
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_06DMCO@Shock?5?$AA@	; `string'
	lea	edx, DWORD PTR _szDmgBits$[ebp]
	push	edx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40741:

; 449  : 	if( dmgbits & DMG_SONIC ) Q_strcat( szDmgBits, "Sonic " );

	mov	eax, DWORD PTR _dmgbits$[ebp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $L40743
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_06PIEK@Sonic?5?$AA@	; `string'
	lea	ecx, DWORD PTR _szDmgBits$[ebp]
	push	ecx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40743:

; 450  : 	if( dmgbits & DMG_ENERGYBEAM ) Q_strcat( szDmgBits, "Energy Beam " );

	mov	edx, DWORD PTR _dmgbits$[ebp]
	and	edx, 1024				; 00000400H
	test	edx, edx
	je	SHORT $L40745
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0N@HKFE@Energy?5Beam?5?$AA@ ; `string'
	lea	eax, DWORD PTR _szDmgBits$[ebp]
	push	eax
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40745:

; 451  : 	if( dmgbits & DMG_NEVERGIB ) Q_strcat( szDmgBits, "Never Gib " );

	mov	ecx, DWORD PTR _dmgbits$[ebp]
	and	ecx, 4096				; 00001000H
	test	ecx, ecx
	je	SHORT $L40747
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0L@GDEN@Never?5Gib?5?$AA@ ; `string'
	lea	edx, DWORD PTR _szDmgBits$[ebp]
	push	edx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40747:

; 452  : 	if( dmgbits & DMG_ALWAYSGIB ) Q_strcat( szDmgBits, "Always Gib " );

	mov	eax, DWORD PTR _dmgbits$[ebp]
	and	eax, 8192				; 00002000H
	test	eax, eax
	je	SHORT $L40749
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0M@KFMM@Always?5Gib?5?$AA@ ; `string'
	lea	ecx, DWORD PTR _szDmgBits$[ebp]
	push	ecx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40749:

; 453  : 	if( dmgbits & DMG_DROWN ) Q_strcat( szDmgBits, "Drown " );

	mov	edx, DWORD PTR _dmgbits$[ebp]
	and	edx, 16384				; 00004000H
	test	edx, edx
	je	SHORT $L40751
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_06OIEJ@Drown?5?$AA@	; `string'
	lea	eax, DWORD PTR _szDmgBits$[ebp]
	push	eax
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40751:

; 454  : 	if( dmgbits & DMG_PARALYZE ) Q_strcat( szDmgBits, "Paralyze Gas " );

	mov	ecx, DWORD PTR _dmgbits$[ebp]
	and	ecx, 32768				; 00008000H
	test	ecx, ecx
	je	SHORT $L40753
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0O@EBHB@Paralyze?5Gas?5?$AA@ ; `string'
	lea	edx, DWORD PTR _szDmgBits$[ebp]
	push	edx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40753:

; 455  : 	if( dmgbits & DMG_NERVEGAS ) Q_strcat( szDmgBits, "Nerve Gas " );

	mov	eax, DWORD PTR _dmgbits$[ebp]
	and	eax, 65536				; 00010000H
	test	eax, eax
	je	SHORT $L40755
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0L@IHMH@Nerve?5Gas?5?$AA@ ; `string'
	lea	ecx, DWORD PTR _szDmgBits$[ebp]
	push	ecx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40755:

; 456  : 	if( dmgbits & DMG_POISON ) Q_strcat( szDmgBits, "Poison "  );

	mov	edx, DWORD PTR _dmgbits$[ebp]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L40757
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_07LLKI@Poison?5?$AA@	; `string'
	lea	eax, DWORD PTR _szDmgBits$[ebp]
	push	eax
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40757:

; 457  : 	if( dmgbits & DMG_RADIATION ) Q_strcat( szDmgBits, "Radiation " );

	mov	ecx, DWORD PTR _dmgbits$[ebp]
	and	ecx, 262144				; 00040000H
	test	ecx, ecx
	je	SHORT $L40759
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0L@DINM@Radiation?5?$AA@ ; `string'
	lea	edx, DWORD PTR _szDmgBits$[ebp]
	push	edx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40759:

; 458  : 	if( dmgbits & DMG_DROWNRECOVER ) Q_strcat( szDmgBits, "Drown Recover "  );

	mov	eax, DWORD PTR _dmgbits$[ebp]
	and	eax, 524288				; 00080000H
	test	eax, eax
	je	SHORT $L40761
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0P@BJOK@Drown?5Recover?5?$AA@ ; `string'
	lea	ecx, DWORD PTR _szDmgBits$[ebp]
	push	ecx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40761:

; 459  : 	if( dmgbits & DMG_ACID ) Q_strcat( szDmgBits, "Acid "   );

	mov	edx, DWORD PTR _dmgbits$[ebp]
	and	edx, 1048576				; 00100000H
	test	edx, edx
	je	SHORT $L40763
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_05EKCB@Acid?5?$AA@	; `string'
	lea	eax, DWORD PTR _szDmgBits$[ebp]
	push	eax
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40763:

; 460  : 	if( dmgbits & DMG_SLOWBURN ) Q_strcat( szDmgBits, "Slow Burn " );

	mov	ecx, DWORD PTR _dmgbits$[ebp]
	and	ecx, 2097152				; 00200000H
	test	ecx, ecx
	je	SHORT $L40765
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0L@PHFJ@Slow?5Burn?5?$AA@ ; `string'
	lea	edx, DWORD PTR _szDmgBits$[ebp]
	push	edx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40765:

; 461  : 	if( dmgbits & DMG_SLOWFREEZE ) Q_strcat( szDmgBits, "Slow Freeze " );

	mov	eax, DWORD PTR _dmgbits$[ebp]
	and	eax, 4194304				; 00400000H
	test	eax, eax
	je	SHORT $L40767
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0N@ENAO@Slow?5Freeze?5?$AA@ ; `string'
	lea	ecx, DWORD PTR _szDmgBits$[ebp]
	push	ecx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40767:

; 462  : 	if( dmgbits & DMG_MORTAR ) Q_strcat( szDmgBits, "Mortar "  );

	mov	edx, DWORD PTR _dmgbits$[ebp]
	and	edx, 16777216				; 01000000H
	test	edx, edx
	je	SHORT $L40769
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_07FCKH@Mortar?5?$AA@	; `string'
	lea	eax, DWORD PTR _szDmgBits$[ebp]
	push	eax
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40769:

; 463  : 	if( dmgbits & DMG_NUCLEAR ) Q_strcat( szDmgBits, "Nuclear Explode " );		

	mov	ecx, DWORD PTR _dmgbits$[ebp]
	and	ecx, 8388608				; 00800000H
	test	ecx, ecx
	je	SHORT $L40771
	push	99999					; 0001869fH
	push	OFFSET FLAT:??_C@_0BB@GFG@Nuclear?5Explode?5?$AA@ ; `string'
	lea	edx, DWORD PTR _szDmgBits$[ebp]
	push	edx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$L40771:

; 464  : 
; 465  : 	Msg( "%s\n", szDmgBits );

	lea	eax, DWORD PTR _szDmgBits$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_03HHKO@?$CFs?6?$AA@	; `string'
	call	?Msg@@YAXPBDZZ				; Msg
	add	esp, 8

; 466  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintStringForDamage@@YAXH@Z ENDP			; PrintStringForDamage
_TEXT	ENDS
PUBLIC	?GetContentsString@@YAPBDH@Z			; GetContentsString
PUBLIC	??_C@_05CLBC@EMPTY?$AA@				; `string'
PUBLIC	??_C@_05DEEH@SOLID?$AA@				; `string'
PUBLIC	??_C@_05EJIN@WATER?$AA@				; `string'
PUBLIC	??_C@_05LBMA@SLIME?$AA@				; `string'
PUBLIC	??_C@_04IEEF@LAVA?$AA@				; `string'
PUBLIC	??_C@_03IEGK@SKY?$AA@				; `string'
PUBLIC	??_C@_06IJPP@LADDER?$AA@			; `string'
PUBLIC	??_C@_08JNJG@FLYFIELD?$AA@			; `string'
PUBLIC	??_C@_0BB@NOJI@GRAVITY_FLYFIELD?$AA@		; `string'
PUBLIC	??_C@_03OHFM@FOG?$AA@				; `string'
PUBLIC	??_C@_09JOMD@SPECIAL?51?$AA@			; `string'
PUBLIC	??_C@_09GBHK@SPECIAL?52?$AA@			; `string'
PUBLIC	??_C@_09MLON@SPECIAL?53?$AA@			; `string'
PUBLIC	??_C@_0N@LABL@NO?5CONTENTS?$CB?$AA@		; `string'
;	COMDAT ??_C@_05CLBC@EMPTY?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_05CLBC@EMPTY?$AA@ DB 'EMPTY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DEEH@SOLID?$AA@
CONST	SEGMENT
??_C@_05DEEH@SOLID?$AA@ DB 'SOLID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05EJIN@WATER?$AA@
CONST	SEGMENT
??_C@_05EJIN@WATER?$AA@ DB 'WATER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LBMA@SLIME?$AA@
CONST	SEGMENT
??_C@_05LBMA@SLIME?$AA@ DB 'SLIME', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IEEF@LAVA?$AA@
CONST	SEGMENT
??_C@_04IEEF@LAVA?$AA@ DB 'LAVA', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IEGK@SKY?$AA@
CONST	SEGMENT
??_C@_03IEGK@SKY?$AA@ DB 'SKY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJPP@LADDER?$AA@
CONST	SEGMENT
??_C@_06IJPP@LADDER?$AA@ DB 'LADDER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JNJG@FLYFIELD?$AA@
CONST	SEGMENT
??_C@_08JNJG@FLYFIELD?$AA@ DB 'FLYFIELD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NOJI@GRAVITY_FLYFIELD?$AA@
CONST	SEGMENT
??_C@_0BB@NOJI@GRAVITY_FLYFIELD?$AA@ DB 'GRAVITY_FLYFIELD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OHFM@FOG?$AA@
CONST	SEGMENT
??_C@_03OHFM@FOG?$AA@ DB 'FOG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09JOMD@SPECIAL?51?$AA@
CONST	SEGMENT
??_C@_09JOMD@SPECIAL?51?$AA@ DB 'SPECIAL 1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GBHK@SPECIAL?52?$AA@
CONST	SEGMENT
??_C@_09GBHK@SPECIAL?52?$AA@ DB 'SPECIAL 2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MLON@SPECIAL?53?$AA@
CONST	SEGMENT
??_C@_09MLON@SPECIAL?53?$AA@ DB 'SPECIAL 3', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LABL@NO?5CONTENTS?$CB?$AA@
CONST	SEGMENT
??_C@_0N@LABL@NO?5CONTENTS?$CB?$AA@ DB 'NO CONTENTS!', 00H ; `string'
CONST	ENDS
;	COMDAT ?GetContentsString@@YAPBDH@Z
_TEXT	SEGMENT
_contents$ = 8
?GetContentsString@@YAPBDH@Z PROC NEAR			; GetContentsString, COMDAT

; 469  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 471  : 	{

	mov	eax, DWORD PTR _contents$[ebp]
	mov	DWORD PTR -4+[ebp], eax
	mov	ecx, DWORD PTR -4+[ebp]
	add	ecx, 22					; 00000016H
	mov	DWORD PTR -4+[ebp], ecx
	cmp	DWORD PTR -4+[ebp], 21			; 00000015H
	ja	SHORT $L40806
	mov	eax, DWORD PTR -4+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L43690[eax]
	jmp	DWORD PTR $L43691[edx*4]
$L40780:

; 472  : 	case -1: return "EMPTY";

	mov	eax, OFFSET FLAT:??_C@_05CLBC@EMPTY?$AA@ ; `string'
	jmp	SHORT $L40777
$L40782:

; 473  : 	case -2: return "SOLID";

	mov	eax, OFFSET FLAT:??_C@_05DEEH@SOLID?$AA@ ; `string'
	jmp	SHORT $L40777
$L40784:

; 474  : 	case -3: return "WATER";

	mov	eax, OFFSET FLAT:??_C@_05EJIN@WATER?$AA@ ; `string'
	jmp	SHORT $L40777
$L40786:

; 475  : 	case -4: return "SLIME";

	mov	eax, OFFSET FLAT:??_C@_05LBMA@SLIME?$AA@ ; `string'
	jmp	SHORT $L40777
$L40788:

; 476  : 	case -5: return "LAVA";

	mov	eax, OFFSET FLAT:??_C@_04IEEF@LAVA?$AA@	; `string'
	jmp	SHORT $L40777
$L40790:

; 477  : 	case -6: return "SKY";

	mov	eax, OFFSET FLAT:??_C@_03IEGK@SKY?$AA@	; `string'
	jmp	SHORT $L40777
$L40792:

; 478  : 	case -16: return "LADDER";

	mov	eax, OFFSET FLAT:??_C@_06IJPP@LADDER?$AA@ ; `string'
	jmp	SHORT $L40777
$L40794:

; 479  : 	case -17: return "FLYFIELD";

	mov	eax, OFFSET FLAT:??_C@_08JNJG@FLYFIELD?$AA@ ; `string'
	jmp	SHORT $L40777
$L40796:

; 480  : 	case -18: return "GRAVITY_FLYFIELD";

	mov	eax, OFFSET FLAT:??_C@_0BB@NOJI@GRAVITY_FLYFIELD?$AA@ ; `string'
	jmp	SHORT $L40777
$L40798:

; 481  : 	case -19: return "FOG";

	mov	eax, OFFSET FLAT:??_C@_03OHFM@FOG?$AA@	; `string'
	jmp	SHORT $L40777
$L40800:

; 482  : 	case -20: return "SPECIAL 1";

	mov	eax, OFFSET FLAT:??_C@_09JOMD@SPECIAL?51?$AA@ ; `string'
	jmp	SHORT $L40777
$L40802:

; 483  : 	case -21: return "SPECIAL 2";

	mov	eax, OFFSET FLAT:??_C@_09GBHK@SPECIAL?52?$AA@ ; `string'
	jmp	SHORT $L40777
$L40804:

; 484  : 	case -22: return "SPECIAL 3";

	mov	eax, OFFSET FLAT:??_C@_09MLON@SPECIAL?53?$AA@ ; `string'
	jmp	SHORT $L40777
$L40806:

; 485  : 	default: return "NO CONTENTS!";

	mov	eax, OFFSET FLAT:??_C@_0N@LABL@NO?5CONTENTS?$CB?$AA@ ; `string'
$L40777:

; 487  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L43691:
	DD	$L40804
	DD	$L40802
	DD	$L40800
	DD	$L40798
	DD	$L40796
	DD	$L40794
	DD	$L40792
	DD	$L40790
	DD	$L40788
	DD	$L40786
	DD	$L40784
	DD	$L40782
	DD	$L40780
	DD	$L40806
$L43690:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
?GetContentsString@@YAPBDH@Z ENDP			; GetContentsString
_TEXT	ENDS
PUBLIC	?GetStringForGlobalState@@YAPBDW4GLOBALESTATE@@@Z ; GetStringForGlobalState
PUBLIC	??_C@_09JMKL@GLOBAL?5ON?$AA@			; `string'
PUBLIC	??_C@_0L@GPHK@GLOBAL?5OFF?$AA@			; `string'
PUBLIC	??_C@_0M@CCPL@GLOBAL?5DEAD?$AA@			; `string'
;	COMDAT ??_C@_09JMKL@GLOBAL?5ON?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_09JMKL@GLOBAL?5ON?$AA@ DB 'GLOBAL ON', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GPHK@GLOBAL?5OFF?$AA@
CONST	SEGMENT
??_C@_0L@GPHK@GLOBAL?5OFF?$AA@ DB 'GLOBAL OFF', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CCPL@GLOBAL?5DEAD?$AA@
CONST	SEGMENT
??_C@_0M@CCPL@GLOBAL?5DEAD?$AA@ DB 'GLOBAL DEAD', 00H	; `string'
CONST	ENDS
;	COMDAT ?GetStringForGlobalState@@YAPBDW4GLOBALESTATE@@@Z
_TEXT	SEGMENT
_state$ = 8
?GetStringForGlobalState@@YAPBDW4GLOBALESTATE@@@Z PROC NEAR ; GetStringForGlobalState, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 492  : 	{

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR -4+[ebp], eax
	cmp	DWORD PTR -4+[ebp], 0
	je	SHORT $L40817
	cmp	DWORD PTR -4+[ebp], 1
	je	SHORT $L40815
	cmp	DWORD PTR -4+[ebp], 2
	je	SHORT $L40819
	jmp	SHORT $L40821
$L40815:

; 493  : 	case GLOBAL_ON: return "GLOBAL ON";

	mov	eax, OFFSET FLAT:??_C@_09JMKL@GLOBAL?5ON?$AA@ ; `string'
	jmp	SHORT $L40812
$L40817:

; 494  : 	case GLOBAL_OFF: return "GLOBAL OFF";

	mov	eax, OFFSET FLAT:??_C@_0L@GPHK@GLOBAL?5OFF?$AA@ ; `string'
	jmp	SHORT $L40812
$L40819:

; 495  : 	case GLOBAL_DEAD: return "GLOBAL DEAD";

	mov	eax, OFFSET FLAT:??_C@_0M@CCPL@GLOBAL?5DEAD?$AA@ ; `string'
	jmp	SHORT $L40812
$L40821:

; 496  : 	default: return "UNKNOWN STATE!";

	mov	eax, OFFSET FLAT:??_C@_0P@FIJK@UNKNOWN?5STATE?$CB?$AA@ ; `string'
$L40812:

; 498  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetStringForGlobalState@@YAPBDW4GLOBALESTATE@@@Z ENDP	; GetStringForGlobalState
_TEXT	ENDS
PUBLIC	?UTIL_GetNextBestWeapon@@YAHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z ; UTIL_GetNextBestWeapon
EXTRN	?g_pGameRules@@3PAVCGameRules@@A:DWORD		; g_pGameRules
;	COMDAT ?UTIL_GetNextBestWeapon@@YAHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_pCurrentWeapon$ = 12
?UTIL_GetNextBestWeapon@@YAHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z PROC NEAR ; UTIL_GetNextBestWeapon, COMDAT

; 501  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 502  : 	return g_pGameRules->GetNextBestWeapon( pPlayer, pCurrentWeapon );

	mov	eax, DWORD PTR _pCurrentWeapon$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+20]

; 503  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_GetNextBestWeapon@@YAHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z ENDP ; UTIL_GetNextBestWeapon
_TEXT	ENDS
PUBLIC	__real@4@00000000000000000000
PUBLIC	__real@4@4007b400000000000000
PUBLIC	?UTIL_AngleMod@@YAMM@Z				; UTIL_AngleMod
EXTRN	__ftol:NEAR
;	COMDAT __real@4@00000000000000000000
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT __real@4@4007b400000000000000
CONST	SEGMENT
__real@4@4007b400000000000000 DD 043b40000r	; 360
CONST	ENDS
;	COMDAT ?UTIL_AngleMod@@YAMM@Z
_TEXT	SEGMENT
_a$ = 8
?UTIL_AngleMod@@YAMM@Z PROC NEAR			; UTIL_AngleMod, COMDAT

; 507  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 508  : 	if (a < 0)

	fld	DWORD PTR _a$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40829

; 510  : 		a = a + 360 * ((int)(a / 360) + 1);

	fld	DWORD PTR _a$[ebp]
	fdiv	DWORD PTR __real@4@4007b400000000000000
	call	__ftol
	add	eax, 1
	imul	eax, 360				; 00000168H
	mov	DWORD PTR -4+[ebp], eax
	fild	DWORD PTR -4+[ebp]
	fadd	DWORD PTR _a$[ebp]
	fstp	DWORD PTR _a$[ebp]

; 512  : 	else if (a >= 360)

	jmp	SHORT $L40832
$L40829:
	fld	DWORD PTR _a$[ebp]
	fcomp	DWORD PTR __real@4@4007b400000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40832

; 514  : 		a = a - 360 * ((int)(a / 360));

	fld	DWORD PTR _a$[ebp]
	fdiv	DWORD PTR __real@4@4007b400000000000000
	call	__ftol
	imul	eax, 360				; 00000168H
	mov	DWORD PTR -8+[ebp], eax
	fild	DWORD PTR -8+[ebp]
	fsubr	DWORD PTR _a$[ebp]
	fstp	DWORD PTR _a$[ebp]
$L40832:

; 516  : 	// a = (360.0/65536) * ((int)(a*(65536/360.0)) & 65535);
; 517  : 	return a;

	fld	DWORD PTR _a$[ebp]

; 518  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_AngleMod@@YAMM@Z ENDP				; UTIL_AngleMod
_TEXT	ENDS
PUBLIC	__real@4@4006b400000000000000
PUBLIC	__real@4@c006b400000000000000
PUBLIC	?UTIL_AngleDiff@@YAMMM@Z			; UTIL_AngleDiff
;	COMDAT __real@4@4006b400000000000000
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
__real@4@4006b400000000000000 DD 043340000r	; 180
CONST	ENDS
;	COMDAT __real@4@c006b400000000000000
CONST	SEGMENT
__real@4@c006b400000000000000 DD 0c3340000r	; -180
CONST	ENDS
;	COMDAT ?UTIL_AngleDiff@@YAMMM@Z
_TEXT	SEGMENT
_destAngle$ = 8
_srcAngle$ = 12
_delta$ = -4
?UTIL_AngleDiff@@YAMMM@Z PROC NEAR			; UTIL_AngleDiff, COMDAT

; 521  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 522  : 	float delta;
; 523  : 
; 524  : 	delta = destAngle - srcAngle;

	fld	DWORD PTR _destAngle$[ebp]
	fsub	DWORD PTR _srcAngle$[ebp]
	fstp	DWORD PTR _delta$[ebp]

; 525  : 	if ( destAngle > srcAngle )

	fld	DWORD PTR _destAngle$[ebp]
	fcomp	DWORD PTR _srcAngle$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40839

; 527  : 		if ( delta >= 180 )

	fld	DWORD PTR _delta$[ebp]
	fcomp	DWORD PTR __real@4@4006b400000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40840

; 528  : 			delta -= 360;

	fld	DWORD PTR _delta$[ebp]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _delta$[ebp]
$L40840:

; 530  : 	else

	jmp	SHORT $L40842
$L40839:

; 532  : 		if ( delta <= -180 )

	fld	DWORD PTR _delta$[ebp]
	fcomp	DWORD PTR __real@4@c006b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40842

; 533  : 			delta += 360;

	fld	DWORD PTR _delta$[ebp]
	fadd	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _delta$[ebp]
$L40842:

; 535  : 	return delta;

	fld	DWORD PTR _delta$[ebp]

; 536  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_AngleDiff@@YAMMM@Z ENDP				; UTIL_AngleDiff
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z		; UTIL_VecToAngles
EXTRN	?VectorAngles@@YAXABVVector@@AAV1@@Z:NEAR	; VectorAngles
;	COMDAT ?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z
_TEXT	SEGMENT
_vec$ = 12
___$ReturnUdt$ = 8
_angles$ = -12
?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z PROC NEAR	; UTIL_VecToAngles, COMDAT

; 539  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 540  : 	Vector angles;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 541  : 
; 542  : 	VectorAngles( vec, angles );

	lea	eax, DWORD PTR _angles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	call	?VectorAngles@@YAXABVVector@@AAV1@@Z	; VectorAngles
	add	esp, 8

; 543  : 
; 544  : 	return angles;

	lea	edx, DWORD PTR _angles$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 545  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z ENDP		; UTIL_VecToAngles
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
PUBLIC	?CopyToArray@Vector@@QBEXPAM@Z			; Vector::CopyToArray
PUBLIC	?UTIL_MoveToOrigin@@YAXPAUedict_s@@ABVVector@@MH@Z ; UTIL_MoveToOrigin
;	COMDAT ?UTIL_MoveToOrigin@@YAXPAUedict_s@@ABVVector@@MH@Z
_TEXT	SEGMENT
_pent$ = 8
_vecGoal$ = 12
_flDist$ = 16
_iMoveType$ = 20
_rgfl$ = -12
?UTIL_MoveToOrigin@@YAXPAUedict_s@@ABVVector@@MH@Z PROC NEAR ; UTIL_MoveToOrigin, COMDAT

; 548  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 549  : 	float rgfl[3];
; 550  : 	vecGoal.CopyToArray(rgfl);

	lea	eax, DWORD PTR _rgfl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecGoal$[ebp]
	call	?CopyToArray@Vector@@QBEXPAM@Z		; Vector::CopyToArray

; 551  : 	MOVE_TO_ORIGIN ( pent, rgfl, flDist, iMoveType ); 

	mov	ecx, DWORD PTR _iMoveType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flDist$[ebp]
	push	edx
	lea	eax, DWORD PTR _rgfl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+44
	add	esp, 16					; 00000010H

; 552  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_MoveToOrigin@@YAXPAUedict_s@@ABVVector@@MH@Z ENDP	; UTIL_MoveToOrigin
_TEXT	ENDS
;	COMDAT ?CopyToArray@Vector@@QBEXPAM@Z
_TEXT	SEGMENT
_rgfl$ = 8
_this$ = -4
?CopyToArray@Vector@@QBEXPAM@Z PROC NEAR		; Vector::CopyToArray, COMDAT

; 225  : 	inline void CopyToArray( float *rgfl ) const	{ rgfl[0] = x, rgfl[1] = y, rgfl[2] = z; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _rgfl$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _rgfl$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _rgfl$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CopyToArray@Vector@@QBEXPAM@Z ENDP			; Vector::CopyToArray
_TEXT	ENDS
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
PUBLIC	?UTIL_Teleport@@YAXPAVCBaseEntity@@AAUTeleportListEntry_t@@PBVVector@@22@Z ; UTIL_Teleport
PUBLIC	?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z	; CBaseEntity::SetBaseVelocity
PUBLIC	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
PUBLIC	?ClearGroundEntity@CBaseEntity@@QAEXXZ		; CBaseEntity::ClearGroundEntity
PUBLIC	?MakeNonSolid@CBaseEntity@@QAEXXZ		; CBaseEntity::MakeNonSolid
PUBLIC	?RestoreSolid@CBaseEntity@@QAEXXZ		; CBaseEntity::RestoreSolid
EXTRN	?WorldPhysic@@3PAVIPhysicLayer@@A:DWORD		; WorldPhysic
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
EXTRN	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsAngles
EXTRN	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAngles
EXTRN	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsVelocity
EXTRN	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ:NEAR	; CBaseEntity::CalcAbsolutePosition
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	?SnapEyeAngles@CBasePlayer@@QAEXABVVector@@@Z:NEAR ; CBasePlayer::SnapEyeAngles
EXTRN	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z:NEAR ; CBaseEntity::RelinkEntity
;	COMDAT ?UTIL_Teleport@@YAXPAVCBaseEntity@@AAUTeleportListEntry_t@@PBVVector@@22@Z
_TEXT	SEGMENT
_pSource$ = 8
_entry$ = 12
_newOrigin$ = 16
_newAngles$ = 20
_newVelocity$ = 24
_pTeleport$ = -4
_prevOrigin$ = -16
_prevAngles$ = -28
_pPlayer$40868 = -32
?UTIL_Teleport@@YAXPAVCBaseEntity@@AAUTeleportListEntry_t@@PBVVector@@22@Z PROC NEAR ; UTIL_Teleport, COMDAT

; 555  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 556  : 	CBaseEntity *pTeleport = entry.pEntity;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pTeleport$[ebp], ecx

; 557  : 	Vector prevOrigin = pTeleport->GetAbsOrigin();

	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _prevOrigin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 558  : 	Vector prevAngles = pTeleport->GetAbsAngles();

	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _prevAngles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 559  : 
; 560  : 	pTeleport->m_iTeleportFilter = TRUE;

	mov	edx, DWORD PTR _pTeleport$[ebp]
	mov	DWORD PTR [edx+40], 1

; 561  : 	pTeleport->MakeNonSolid();

	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?MakeNonSolid@CBaseEntity@@QAEXXZ	; CBaseEntity::MakeNonSolid

; 562  : 
; 563  : 	// i'm teleporting myself
; 564  : 	if( pSource == pTeleport )

	mov	eax, DWORD PTR _pSource$[ebp]
	cmp	eax, DWORD PTR _pTeleport$[ebp]
	jne	$L40865

; 566  : 		if( newAngles )

	cmp	DWORD PTR _newAngles$[ebp], 0
	je	SHORT $L40870

; 568  : 			pTeleport->SetLocalAngles( *newAngles );

	mov	ecx, DWORD PTR _newAngles$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 569  : 
; 570  : 			if( pTeleport->IsPlayer() )

	mov	edx, DWORD PTR _pTeleport$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	DWORD PTR [eax+224]
	test	eax, eax
	je	SHORT $L40867

; 572  : 				CBasePlayer *pPlayer = (CBasePlayer *)pTeleport;

	mov	ecx, DWORD PTR _pTeleport$[ebp]
	mov	DWORD PTR _pPlayer$40868[ebp], ecx

; 573  : 				pPlayer->SnapEyeAngles( *newAngles );

	mov	edx, DWORD PTR _newAngles$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$40868[ebp]
	call	?SnapEyeAngles@CBasePlayer@@QAEXABVVector@@@Z ; CBasePlayer::SnapEyeAngles
$L40867:

; 575  : 
; 576  : 			if( pTeleport->IsRigidBody( ))

	mov	eax, DWORD PTR _pTeleport$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	DWORD PTR [edx+76]
	test	eax, eax
	je	SHORT $L40870

; 577  : 				WorldPhysic->SetAngles( pTeleport, *newAngles );

	mov	eax, DWORD PTR _newAngles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [eax+60]
$L40870:

; 579  : 
; 580  : 		if( newVelocity )

	cmp	DWORD PTR _newVelocity$[ebp], 0
	je	SHORT $L40873

; 582  : 			pTeleport->SetAbsVelocity( *newVelocity );

	mov	ecx, DWORD PTR _newVelocity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 583  : 			pTeleport->SetBaseVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetBaseVelocity

; 584  : 
; 585  : 			if( pTeleport->IsRigidBody( ))

	mov	edx, DWORD PTR _pTeleport$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	DWORD PTR [eax+76]
	test	eax, eax
	je	SHORT $L40873

; 587  : 				WorldPhysic->SetVelocity( pTeleport, *newVelocity );

	mov	ecx, DWORD PTR _newVelocity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTeleport$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+64]

; 588  : 
; 589  : 				// HACKHACK reset avelocity for rigid body
; 590  : 				if( *newVelocity == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _newVelocity$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L40873

; 591  : 					WorldPhysic->SetAvelocity( pTeleport, g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _pTeleport$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+68]
$L40873:

; 594  : 
; 595  : 		if( newOrigin )

	cmp	DWORD PTR _newOrigin$[ebp], 0
	je	$L40877

; 597  : 			SetBits( pTeleport->pev->effects, EF_NOINTERP );

	mov	eax, DWORD PTR _pTeleport$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _pTeleport$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx

; 598  : 			UTIL_SetOrigin( pTeleport, *newOrigin );

	mov	edx, DWORD PTR _newOrigin$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTeleport$[ebp]
	push	eax
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 599  : 
; 600  : 			if( pTeleport->IsRigidBody( ))

	mov	ecx, DWORD PTR _pTeleport$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	DWORD PTR [edx+76]
	test	eax, eax
	je	SHORT $L40875

; 601  : 				WorldPhysic->SetOrigin( pTeleport, *newOrigin );

	mov	eax, DWORD PTR _newOrigin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [eax+56]
$L40875:

; 605  : 			{

	mov	ecx, DWORD PTR _pTeleport$[ebp]
	mov	dl, BYTE PTR [ecx+1604]
	mov	BYTE PTR -36+[ebp], dl
	cmp	BYTE PTR -36+[ebp], 2
	je	SHORT $L40880
	cmp	BYTE PTR -36+[ebp], 3
	je	SHORT $L40881
	jmp	SHORT $L40877
$L40880:

; 606  : 			case ACTOR_KINEMATIC:
; 607  : 				WorldPhysic->TeleportActor( pTeleport );

	mov	eax, DWORD PTR _pTeleport$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+148]

; 608  : 				break;

	jmp	SHORT $L40877
$L40881:

; 609  : 			case ACTOR_CHARACTER:
; 610  : 				WorldPhysic->TeleportCharacter( pTeleport );

	mov	eax, DWORD PTR _pTeleport$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+144]
$L40877:

; 615  : 	else

	jmp	SHORT $L40884
$L40865:

; 617  : 		// My parent is teleporting, just update my position & physics
; 618  : 		pTeleport->CalcAbsolutePosition();

	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsolutePosition

; 622  : 		{

	mov	eax, DWORD PTR _pTeleport$[ebp]
	mov	cl, BYTE PTR [eax+1604]
	mov	BYTE PTR -40+[ebp], cl
	cmp	BYTE PTR -40+[ebp], 2
	je	SHORT $L40887
	cmp	BYTE PTR -40+[ebp], 3
	je	SHORT $L40888
	jmp	SHORT $L40884
$L40887:

; 623  : 		case ACTOR_KINEMATIC:
; 624  : 			WorldPhysic->TeleportActor( pTeleport );

	mov	edx, DWORD PTR _pTeleport$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+148]

; 625  : 			break;

	jmp	SHORT $L40884
$L40888:

; 626  : 		case ACTOR_CHARACTER:
; 627  : 			WorldPhysic->TeleportCharacter( pTeleport );

	mov	eax, DWORD PTR _pTeleport$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+144]
$L40884:

; 631  : 
; 632  : 	pTeleport->RestoreSolid();

	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?RestoreSolid@CBaseEntity@@QAEXXZ	; CBaseEntity::RestoreSolid

; 633  : 	pTeleport->RelinkEntity( TRUE, NULL, TRUE );	// need to move back in solid list

	push	1
	push	0
	push	1
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 634  : 	pTeleport->ClearGroundEntity();

	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?ClearGroundEntity@CBaseEntity@@QAEXXZ	; CBaseEntity::ClearGroundEntity

; 635  : 	pTeleport->OnTeleport();		// call event

	mov	eax, DWORD PTR _pTeleport$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	DWORD PTR [edx+36]

; 636  : 	pTeleport->m_iTeleportFilter = FALSE;

	mov	eax, DWORD PTR _pTeleport$[ebp]
	mov	DWORD PTR [eax+40], 0

; 637  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_Teleport@@YAXPAVCBaseEntity@@AAUTeleportListEntry_t@@PBVVector@@22@Z ENDP ; UTIL_Teleport
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L43721
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L43721
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L43721
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L43722
$L43721:
	mov	DWORD PTR -8+[ebp], 0
$L43722:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
;	COMDAT ?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4
_v$ = 8
?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR ; CBaseEntity::SetBaseVelocity, COMDAT

; 390  : 	void SetBaseVelocity( const Vector& v ) { pev->basevelocity = v; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 44					; 0000002cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z ENDP	; CBaseEntity::SetBaseVelocity
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ClearGroundEntity@CBaseEntity@@QAEXXZ PROC NEAR	; CBaseEntity::ClearGroundEntity, COMDAT

; 631  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 632  : 		pev->groundentity = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+412], 0

; 633  : 		pev->flags &= ~FL_ONGROUND;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ch, -3					; fffffffdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx

; 634  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearGroundEntity@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::ClearGroundEntity
_TEXT	ENDS
;	COMDAT ?MakeNonSolid@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MakeNonSolid@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::MakeNonSolid, COMDAT

; 637  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 		if( m_iOldSolid == SOLID_NOT && pev->solid != SOLID_NOT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $L35080
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 0
	je	SHORT $L35080

; 640  : 			WorldPhysic->EnableCollision( this, FALSE );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+92]

; 641  : 			m_iOldSolid = pev->solid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+268]
	mov	DWORD PTR [edx+16], eax

; 642  : 			pev->solid = SOLID_NOT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 0
$L35080:

; 644  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MakeNonSolid@CBaseEntity@@QAEXXZ ENDP			; CBaseEntity::MakeNonSolid
_TEXT	ENDS
;	COMDAT ?RestoreSolid@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RestoreSolid@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::RestoreSolid, COMDAT

; 647  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 648  : 		if( m_iOldSolid != SOLID_NOT && pev->solid == SOLID_NOT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L35083
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 0
	jne	SHORT $L35083

; 650  : 			WorldPhysic->EnableCollision( this, TRUE );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+92]

; 651  : 			pev->solid = m_iOldSolid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+268], eax

; 652  : 			m_iOldSolid = SOLID_NOT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
$L35083:

; 654  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RestoreSolid@CBaseEntity@@QAEXXZ ENDP			; CBaseEntity::RestoreSolid
_TEXT	ENDS
PUBLIC	??0matrix4x4@@QAE@ABVmatrix3x4@@@Z		; matrix4x4::matrix4x4
PUBLIC	?GetOrigin@matrix4x4@@QBE?AVVector@@XZ		; matrix4x4::GetOrigin
PUBLIC	?GetAngles@matrix4x4@@QAE?AVVector@@XZ		; matrix4x4::GetAngles
PUBLIC	??0matrix4x4@@QAE@ABV0@@Z			; matrix4x4::matrix4x4
PUBLIC	?UTIL_ParentToWorldSpace@@YAXPAVCBaseEntity@@AAVVector@@1@Z ; UTIL_ParentToWorldSpace
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
PUBLIC	??0matrix3x4@@QAE@ABVVector@@0M@Z		; matrix3x4::matrix3x4
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	??4matrix4x4@@QAEAAV0@ABV0@@Z:NEAR		; matrix4x4::operator=
EXTRN	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z:NEAR	; matrix4x4::ConcatTransforms
EXTRN	?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ:NEAR ; CBaseEntity::GetParentToWorldTransform
;	COMDAT ?UTIL_ParentToWorldSpace@@YAXPAVCBaseEntity@@AAVVector@@1@Z
_TEXT	SEGMENT
$T43733 = -240
$T43734 = -304
$T43736 = -372
$T43737 = -384
$T43738 = -396
_pEntity$ = 8
_vecPosition$ = 12
_vecAngles$ = 16
_matEntityToParent$ = -64
_matResult$ = -128
_matParentToWorld$ = -192
?UTIL_ParentToWorldSpace@@YAXPAVCBaseEntity@@AAVVector@@1@Z PROC NEAR ; UTIL_ParentToWorldSpace, COMDAT

; 644  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 460				; 000001ccH
	push	ebx
	push	esi
	push	edi

; 645  : 	if ( pEntity == NULL )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L40894

; 646  : 		return;

	jmp	$L40893
$L40894:

; 647  : 
; 648  : 	// Construct the entity-to-world matrix
; 649  : 	// Start with making an entity-to-parent matrix
; 650  : 	matrix4x4 matEntityToParent = matrix3x4( vecPosition, vecAngles );

	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _vecAngles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecPosition$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T43733[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@0M@Z	; matrix3x4::matrix3x4
	push	eax
	lea	ecx, DWORD PTR _matEntityToParent$[ebp]
	call	??0matrix4x4@@QAE@ABVmatrix3x4@@@Z	; matrix4x4::matrix4x4

; 651  : 
; 652  : 	// concatenate with our parent's transform
; 653  : 	matrix4x4 matResult, matParentToWorld;

	lea	ecx, DWORD PTR _matResult$[ebp]
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	lea	ecx, DWORD PTR _matParentToWorld$[ebp]
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4

; 654  : 	
; 655  : 	if( pEntity->m_hParent != NULL )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40899

; 657  : 		matParentToWorld = pEntity->GetParentToWorldTransform();

	lea	edx, DWORD PTR $T43734[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ ; CBaseEntity::GetParentToWorldTransform
	push	eax
	lea	ecx, DWORD PTR _matParentToWorld$[ebp]
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 659  : 	else

	jmp	SHORT $L40901
$L40899:

; 661  : 		matParentToWorld = pEntity->EntityToWorldTransform();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	push	eax
	lea	ecx, DWORD PTR _matParentToWorld$[ebp]
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=
$L40901:

; 663  : 
; 664  : 	matResult = matParentToWorld.ConcatTransforms( matEntityToParent );

	sub	esp, 64					; 00000040H
	mov	ecx, esp
	lea	eax, DWORD PTR _matEntityToParent$[ebp]
	push	eax
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	lea	ecx, DWORD PTR $T43736[ebp]
	push	ecx
	lea	ecx, DWORD PTR _matParentToWorld$[ebp]
	call	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z ; matrix4x4::ConcatTransforms
	push	eax
	lea	ecx, DWORD PTR _matResult$[ebp]
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 665  : 	vecPosition = matResult.GetOrigin();

	lea	edx, DWORD PTR $T43737[ebp]
	push	edx
	lea	ecx, DWORD PTR _matResult$[ebp]
	call	?GetOrigin@matrix4x4@@QBE?AVVector@@XZ	; matrix4x4::GetOrigin
	mov	ecx, DWORD PTR _vecPosition$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 666  : 	vecAngles = matResult.GetAngles();

	lea	ecx, DWORD PTR $T43738[ebp]
	push	ecx
	lea	ecx, DWORD PTR _matResult$[ebp]
	call	?GetAngles@matrix4x4@@QAE?AVVector@@XZ	; matrix4x4::GetAngles
	mov	edx, DWORD PTR _vecAngles$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L40893:

; 667  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ParentToWorldSpace@@YAXPAVCBaseEntity@@AAVVector@@1@Z ENDP ; UTIL_ParentToWorldSpace
_TEXT	ENDS
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	__real@8@3ff98efa351294e9c800
PUBLIC	?SinCos@@YAXMPAM0@Z				; SinCos
;	COMDAT __real@8@3ff98efa351294e9c800
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@8@3ff98efa351294e9c800 DQ 03f91df46a2529d39r ; 0.0174533
CONST	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT
_origin$ = 8
_angles$ = 12
_scale$ = 16
_this$ = -4
_angle$ = -8
_sr$ = -12
_sp$ = -16
_sy$ = -20
_cr$ = -24
_cp$ = -28
_cy$ = -32
??0matrix3x4@@QAE@ABVVector@@0M@Z PROC NEAR		; matrix3x4::matrix3x4, COMDAT

; 354  : 	_forceinline matrix3x4( const Vector &origin, const Vector &angles, float scale = 1.0f )

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 355  : 	{
; 356  : 		float	angle, sr, sp, sy, cr, cp, cy;
; 357  : 
; 358  : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25537

; 360  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 361  : 			SinCos( angle, &sy, &cy );

	lea	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 362  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 363  : 			SinCos( angle, &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 364  : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 365  : 			SinCos( angle, &sr, &cr );

	lea	ecx, DWORD PTR _cr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sr$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 366  : 
; 367  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax], ecx

; 368  : 			mat[1][0] = (sr*sp*cy+cr*-sy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _cr$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax], edx

; 369  : 			mat[2][0] = (cr*sp*cy+-sr*-sy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR [eax], ecx

; 370  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 371  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+4], edx

; 372  : 			mat[1][1] = (sr*sp*sy+cr*cy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 373  : 			mat[2][1] = (cr*sp*sy+-sr*cy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax+4], edx

; 374  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 375  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 376  : 			mat[1][2] = (sr*cp) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -64+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+8], edx

; 377  : 			mat[2][2] = (cr*cp) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 378  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 380  : 		else if( angles[PITCH] )

	jmp	$L25542
$L25537:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25539

; 382  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 383  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 384  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 385  : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 386  : 
; 387  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -72+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -72+[ebp]
	mov	DWORD PTR [eax], edx

; 388  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -76+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -76+[ebp]
	mov	DWORD PTR [eax], ecx

; 389  : 			mat[2][0] = (sp*cy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -80+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -80+[ebp]
	mov	DWORD PTR [eax], edx

; 390  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 391  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -84+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -84+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 392  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -88+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -88+[ebp]
	mov	DWORD PTR [eax+4], edx

; 393  : 			mat[2][1] = (sp*sy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -92+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -92+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 394  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 395  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -96+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -96+[ebp]
	mov	DWORD PTR [eax+8], edx

; 396  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 397  : 			mat[2][2] = (cp) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -100+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -100+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 398  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 400  : 		else if( angles[YAW] )

	jmp	$L25542
$L25539:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25541

; 402  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 403  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 404  : 
; 405  : 			mat[0][0] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -104+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -104+[ebp]
	mov	DWORD PTR [eax], edx

; 406  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -108+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -108+[ebp]
	mov	DWORD PTR [eax], ecx

; 407  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 408  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 409  : 			mat[0][1] = (sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -112+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -112+[ebp]
	mov	DWORD PTR [eax+4], edx

; 410  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -116+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -116+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 411  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 412  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 413  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 414  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 415  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], edx

; 416  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 418  : 		else

	jmp	$L25542
$L25541:

; 420  : 			mat[0][0] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax], ecx

; 421  : 			mat[1][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 422  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 423  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 424  : 			mat[0][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 425  : 			mat[1][1] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+4], edx

; 426  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 427  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 428  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 429  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 430  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 431  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
$L25542:

; 433  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0matrix3x4@@QAE@ABVVector@@0M@Z ENDP			; matrix3x4::matrix3x4
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT
_angle$ = 8
_sine$ = 12
_cosine$ = 16
?SinCos@@YAXMPAM0@Z PROC NEAR				; SinCos, COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 37   : 	__asm
; 38   : 	{
; 39   : 		push	ecx

	push	ecx

; 40   : 		fld	dword ptr angle

	fld	DWORD PTR _angle$[ebp]

; 41   : 		fsincos

	fsincos

; 42   : 		mov	ecx, dword ptr[cosine]

	mov	ecx, DWORD PTR _cosine$[ebp]

; 43   : 		fstp      dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 44   : 		mov 	ecx, dword ptr[sine]

	mov	ecx, DWORD PTR _sine$[ebp]

; 45   : 		fstp	dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 46   : 		pop	ecx

	pop	ecx

; 47   : 	}
; 48   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SinCos@@YAXMPAM0@Z ENDP				; SinCos
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QBEPBMXZ PROC NEAR				; Vector::operator float const *, COMDAT

; 229  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
PUBLIC	??0Vector4D@@QAE@XZ				; Vector4D::Vector4D
PUBLIC	??BVector4D@@QAEPAMXZ				; Vector4D::operator float *
PUBLIC	??Amatrix3x4@@QBEPBMH@Z				; matrix3x4::operator[]
;	COMDAT ??0matrix4x4@@QAE@ABVmatrix3x4@@@Z
_TEXT	SEGMENT
_in$ = 8
_this$ = -4
??0matrix4x4@@QAE@ABVmatrix3x4@@@Z PROC NEAR		; matrix4x4::matrix4x4, COMDAT

; 918  : 	_forceinline matrix4x4( const matrix3x4 &in )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 919  : 	{
; 920  : 		mat[0][0] = in[0][0];

	push	0
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 921  : 		mat[0][1] = in[0][1];

	push	0
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx

; 922  : 		mat[0][2] = in[0][2];

	push	0
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx

; 923  : 		mat[1][0] = in[1][0];

	push	1
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx

; 924  : 		mat[1][1] = in[1][1];

	push	1
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx

; 925  : 		mat[1][2] = in[1][2];

	push	1
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx

; 926  : 		mat[2][0] = in[2][0];

	push	2
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 927  : 		mat[2][1] = in[2][1];

	push	2
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx

; 928  : 		mat[2][2] = in[2][2];

	push	2
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx

; 929  : 		mat[3][0] = in[3][0];

	push	3
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx

; 930  : 		mat[3][1] = in[3][1];

	push	3
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx

; 931  : 		mat[3][2] = in[3][2];

	push	3
	mov	ecx, DWORD PTR _in$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx

; 932  : 		mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 933  : 		mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 934  : 		mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 935  : 		mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 936  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix4x4@@QAE@ABVmatrix3x4@@@Z ENDP			; matrix4x4::matrix4x4
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector4D@@QAE@XZ PROC NEAR				; Vector4D::Vector4D, COMDAT

; 311  : 	inline Vector4D( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector4D@@QAE@XZ ENDP				; Vector4D::Vector4D
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector4D@@QAEPAMXZ PROC NEAR				; Vector4D::operator float *, COMDAT

; 325  : 	operator float *()					{ return &x; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector4D@@QAEPAMXZ ENDP				; Vector4D::operator float *
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??Amatrix3x4@@QBEPBMH@Z PROC NEAR			; matrix3x4::operator[], COMDAT

; 498  : 	float const* operator[]( int i ) const { return mat[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, eax
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??Amatrix3x4@@QBEPBMH@Z ENDP				; matrix3x4::operator[]
_TEXT	ENDS
PUBLIC	??BVector4D@@QBE?BVVector@@XZ			; Vector4D::operator Vector const 
;	COMDAT ?GetOrigin@matrix4x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T43759 = -16
$T43760 = -28
?GetOrigin@matrix4x4@@QBE?AVVector@@XZ PROC NEAR	; matrix4x4::GetOrigin, COMDAT

; 980  : 	Vector	GetOrigin() const { return mat[3]; };

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T43760[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QBE?BVVector@@XZ		; Vector4D::operator Vector const 
	push	eax
	lea	ecx, DWORD PTR $T43759[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR $T43759[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetOrigin@matrix4x4@@QBE?AVVector@@XZ ENDP		; matrix4x4::GetOrigin
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T43763 = -16
??BVector4D@@QBE?BVVector@@XZ PROC NEAR			; Vector4D::operator Vector const , COMDAT

; 330  : 	operator const Vector() const				{ return Vector( x, y, z ); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR $T43763[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??BVector4D@@QBE?BVVector@@XZ ENDP			; Vector4D::operator Vector const 
_TEXT	ENDS
PUBLIC	__real@4@3ff583126f0000000000
PUBLIC	__real@4@4004e52ee10000000000
EXTRN	_atan2:NEAR
EXTRN	_sqrt:NEAR
;	COMDAT __real@4@3ff583126f0000000000
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@4@3ff583126f0000000000 DD 03a83126fr	; 0.001
CONST	ENDS
;	COMDAT __real@4@4004e52ee10000000000
CONST	SEGMENT
__real@4@4004e52ee10000000000 DD 042652ee1r	; 57.2958
CONST	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_xyDist$ = -8
_angles$ = -20
?GetAngles@matrix4x4@@QAE?AVVector@@XZ PROC NEAR	; matrix4x4::GetAngles, COMDAT

; 993  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 994  : 		float xyDist = sqrt( mat[0][0] * mat[0][0] + mat[0][1] * mat[0][1] );

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [esi+4]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -24+[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _xyDist$[ebp]

; 995  : 		Vector angles;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 996  : 
; 997  : 		// enough here to get angles?
; 998  : 		if( xyDist > 0.001f )

	fld	DWORD PTR _xyDist$[ebp]
	fcomp	DWORD PTR __real@4@3ff583126f0000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L25975

; 1000 : 			angles[0] = RAD2DEG( atan2( -mat[0][2], xyDist ) );

	fld	DWORD PTR _xyDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -28+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -32+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -32+[ebp]
	mov	DWORD PTR [eax], ecx

; 1001 : 			angles[1] = RAD2DEG( atan2( mat[0][1], mat[0][0] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -36+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -40+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax+4], edx

; 1002 : 			angles[2] = RAD2DEG( atan2( mat[1][2], mat[2][2] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -44+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -48+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1004 : 		else	// forward is mostly Z, gimbal lock

	jmp	$L25982
$L25975:

; 1006 : 			angles[0] = RAD2DEG( atan2( -mat[0][2], xyDist ) );

	fld	DWORD PTR _xyDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -52+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -56+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax], edx

; 1007 : 			angles[1] = RAD2DEG( atan2( -mat[1][0], mat[1][1] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -60+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -64+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1008 : 			angles[2] = 0;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0
$L25982:

; 1010 : 
; 1011 : 		return angles;

	lea	edx, DWORD PTR _angles$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1012 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAngles@matrix4x4@@QAE?AVVector@@XZ ENDP		; matrix4x4::GetAngles
_TEXT	ENDS
PUBLIC	??0Vector4D@@QAE@ABV0@@Z			; Vector4D::Vector4D
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
_$S7$ = -8
_$S8$ = -12
_$S9$ = -16
??0matrix4x4@@QAE@ABV0@@Z PROC NEAR			; matrix4x4::matrix4x4, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S7$[ebp], 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _$S8$[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR _$S9$[ebp], ecx
$L26032:
	mov	edx, DWORD PTR _$S9$[ebp]
	push	edx
	mov	ecx, DWORD PTR _$S8$[ebp]
	call	??0Vector4D@@QAE@ABV0@@Z		; Vector4D::Vector4D
	mov	eax, DWORD PTR _$S8$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _$S8$[ebp], eax
	mov	ecx, DWORD PTR _$S9$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _$S9$[ebp], ecx
	mov	edx, DWORD PTR _$S7$[ebp]
	sub	edx, 1
	mov	DWORD PTR _$S7$[ebp], edx
	cmp	DWORD PTR _$S7$[ebp], 0
	ja	SHORT $L26032
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix4x4@@QAE@ABV0@@Z ENDP				; matrix4x4::matrix4x4
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector4D@@QAE@ABV0@@Z PROC NEAR			; Vector4D::Vector4D, COMDAT

; 313  : 	inline Vector4D( const Vector4D& v ) { x = v.x; y = v.y; z = v.z, w = v.w; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector4D@@QAE@ABV0@@Z ENDP				; Vector4D::Vector4D
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
PUBLIC	??0matrix4x4@@QAE@ABVVector@@0M@Z		; matrix4x4::matrix4x4
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ
_TEXT	SEGMENT
_this$ = -4
$T43780 = -68
$T43781 = -80
?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ PROC NEAR ; CBaseEntity::EntityToWorldTransform, COMDAT

; 732  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 733  : 	if( IsPlayer( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L35136

; 735  : 		m_local = matrix4x4( pev->origin, Vector( 0.0f, pev->angles.y, 0.0f ));

	push	1065353216				; 3f800000H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	push	0
	lea	ecx, DWORD PTR $T43781[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	push	ecx
	lea	ecx, DWORD PTR $T43780[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 737  : 	else if( pev->flags & FL_ABSTRANSFORM )

	jmp	SHORT $L35140
$L35136:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L35140

; 739  : 		CalcAbsolutePosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsolutePosition
$L35140:

; 741  : 	return m_local; 

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 180				; 000000b4H

; 742  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ENDP ; CBaseEntity::EntityToWorldTransform
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT
_origin$ = 8
_angles$ = 12
_scale$ = 16
_this$ = -4
_angle$ = -8
_sr$ = -12
_sp$ = -16
_sy$ = -20
_cr$ = -24
_cp$ = -28
_cy$ = -32
??0matrix4x4@@QAE@ABVVector@@0M@Z PROC NEAR		; matrix4x4::matrix4x4, COMDAT

; 701  : 	_forceinline matrix4x4( const Vector &origin, const Vector &angles, float scale = 1.0f )

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 702  : 	{
; 703  : 		float	angle, sr, sp, sy, cr, cp, cy;
; 704  : 
; 705  : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25873

; 707  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 708  : 			SinCos( angle, &sy, &cy );

	lea	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 709  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 710  : 			SinCos( angle, &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 711  : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 712  : 			SinCos( angle, &sr, &cr );

	lea	ecx, DWORD PTR _cr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sr$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 713  : 
; 714  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax], ecx

; 715  : 			mat[1][0] = (sr*sp*cy+cr*-sy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _cr$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax], edx

; 716  : 			mat[2][0] = (cr*sp*cy+-sr*-sy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR [eax], ecx

; 717  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 718  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+4], edx

; 719  : 			mat[1][1] = (sr*sp*sy+cr*cy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 720  : 			mat[2][1] = (cr*sp*sy+-sr*cy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax+4], edx

; 721  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 722  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 723  : 			mat[1][2] = (sr*cp) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -64+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+8], edx

; 724  : 			mat[2][2] = (cr*cp) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 725  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 726  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 727  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 728  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 729  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 731  : 		else if( angles[PITCH] )

	jmp	$L25878
$L25873:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25875

; 733  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 734  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 735  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 736  : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 737  : 
; 738  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -72+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -72+[ebp]
	mov	DWORD PTR [eax], edx

; 739  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -76+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -76+[ebp]
	mov	DWORD PTR [eax], ecx

; 740  : 			mat[2][0] = (sp*cy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -80+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -80+[ebp]
	mov	DWORD PTR [eax], edx

; 741  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 742  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -84+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -84+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 743  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -88+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -88+[ebp]
	mov	DWORD PTR [eax+4], edx

; 744  : 			mat[2][1] = (sp*sy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -92+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -92+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 745  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 746  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -96+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -96+[ebp]
	mov	DWORD PTR [eax+8], edx

; 747  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 748  : 			mat[2][2] = (cp) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -100+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -100+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 749  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 750  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 751  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 752  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 753  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 755  : 		else if( angles[YAW] )

	jmp	$L25878
$L25875:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25877

; 757  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 758  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 759  : 
; 760  : 			mat[0][0] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -104+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -104+[ebp]
	mov	DWORD PTR [eax], edx

; 761  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -108+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -108+[ebp]
	mov	DWORD PTR [eax], ecx

; 762  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 763  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 764  : 			mat[0][1] = (sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -112+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -112+[ebp]
	mov	DWORD PTR [eax+4], edx

; 765  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -116+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -116+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 766  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 767  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 768  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 769  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 770  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], edx

; 771  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 772  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 773  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 774  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 775  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 777  : 		else

	jmp	$L25878
$L25877:

; 779  : 			mat[0][0] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax], ecx

; 780  : 			mat[1][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 781  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 782  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 783  : 			mat[0][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 784  : 			mat[1][1] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+4], edx

; 785  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 786  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 787  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 788  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 789  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 790  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 791  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 792  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 793  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 794  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H
$L25878:

; 796  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0matrix4x4@@QAE@ABVVector@@0M@Z ENDP			; matrix4x4::matrix4x4
_TEXT	ENDS
PUBLIC	?INDEXENT@@YAPAUedict_s@@H@Z			; INDEXENT
PUBLIC	?UTIL_EntitiesInBox@@YAHPAPAVCBaseEntity@@HABVVector@@1H@Z ; UTIL_EntitiesInBox
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
;	COMDAT ?UTIL_EntitiesInBox@@YAHPAPAVCBaseEntity@@HABVVector@@1H@Z
_TEXT	SEGMENT
_pList$ = 8
_listMax$ = 12
_mins$ = 16
_maxs$ = 20
_flagMask$ = 24
_pEdict$ = -4
_pEntity$ = -8
_count$ = -12
_i$ = -16
?UTIL_EntitiesInBox@@YAHPAPAVCBaseEntity@@HABVVector@@1H@Z PROC NEAR ; UTIL_EntitiesInBox, COMDAT

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 671  : 	edict_t *pEdict = INDEXENT( 1 );

	push	1
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	mov	DWORD PTR _pEdict$[ebp], eax

; 672  : 	CBaseEntity *pEntity;
; 673  : 	int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 674  : 
; 675  : 	if ( !pEdict )

	cmp	DWORD PTR _pEdict$[ebp], 0
	jne	SHORT $L40916

; 676  : 		return count;

	mov	eax, DWORD PTR _count$[ebp]
	jmp	$L40912
$L40916:

; 677  : 
; 678  : 	for ( int i = 1; i < gpGlobals->maxEntities; i++, pEdict++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L40918
$L40919:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _pEdict$[ebp]
	add	ecx, 804				; 00000324H
	mov	DWORD PTR _pEdict$[ebp], ecx
$L40918:
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+148]
	jge	$L40920

; 680  : 		if ( pEdict->free )	// Not in use

	mov	ecx, DWORD PTR _pEdict$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L40921

; 681  : 			continue;

	jmp	SHORT $L40919
$L40921:

; 682  : 		
; 683  : 		if ( flagMask && !(pEdict->v.flags & flagMask) )	// Does it meet the criteria?

	cmp	DWORD PTR _flagMask$[ebp], 0
	je	SHORT $L40922
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, DWORD PTR _flagMask$[ebp]
	test	eax, eax
	jne	SHORT $L40922

; 684  : 			continue;

	jmp	SHORT $L40919
$L40922:

; 687  : 			 mins.y > pEdict->v.absmax.y ||
; 688  : 			 mins.z > pEdict->v.absmax.z ||
; 689  : 			 maxs.x < pEdict->v.absmin.x ||
; 690  : 			 maxs.y < pEdict->v.absmin.y ||
; 691  : 			 maxs.z < pEdict->v.absmin.z )

	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR _pEdict$[ebp]
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR [edx+336]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40924
	mov	eax, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR _pEdict$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR [ecx+340]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40924
	mov	edx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR _pEdict$[ebp]
	fld	DWORD PTR [edx+8]
	fcomp	DWORD PTR [eax+344]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40924
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR _pEdict$[ebp]
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR [edx+324]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40924
	mov	eax, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR _pEdict$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR [ecx+328]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40924
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR _pEdict$[ebp]
	fld	DWORD PTR [edx+8]
	fcomp	DWORD PTR [eax+332]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40923
$L40924:

; 692  : 			 continue;

	jmp	$L40919
$L40923:

; 693  : 
; 694  : 		pEntity = CBaseEntity::Instance(pEdict);

	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 695  : 		if ( !pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L40925

; 696  : 			continue;

	jmp	$L40919
$L40925:

; 697  : 
; 698  : 		pList[ count ] = pEntity;

	mov	edx, DWORD PTR _count$[ebp]
	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 699  : 		count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 700  : 
; 701  : 		if ( count >= listMax )

	mov	eax, DWORD PTR _count$[ebp]
	cmp	eax, DWORD PTR _listMax$[ebp]
	jl	SHORT $L40926

; 702  : 			return count;

	mov	eax, DWORD PTR _count$[ebp]
	jmp	SHORT $L40912
$L40926:

; 703  : 	}

	jmp	$L40919
$L40920:

; 704  : 
; 705  : 	return count;

	mov	eax, DWORD PTR _count$[ebp]
$L40912:

; 706  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_EntitiesInBox@@YAHPAPAVCBaseEntity@@HABVVector@@1H@Z ENDP ; UTIL_EntitiesInBox
_TEXT	ENDS
;	COMDAT ?INDEXENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_iEdictNum$ = 8
?INDEXENT@@YAPAUedict_s@@H@Z PROC NEAR			; INDEXENT, COMDAT

; 187  : inline edict_t* INDEXENT( int iEdictNum )		{ return (*g_engfuncs.pfnPEntityOfEntIndex)(iEdictNum); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _iEdictNum$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+288
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?INDEXENT@@YAPAUedict_s@@H@Z ENDP			; INDEXENT
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
PUBLIC	__real@8@3ffe8000000000000000
PUBLIC	?UTIL_MonstersInSphere@@YAHPAPAVCBaseEntity@@HABVVector@@M@Z ; UTIL_MonstersInSphere
;	COMDAT __real@8@3ffe8000000000000000
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
__real@8@3ffe8000000000000000 DQ 03fe0000000000000r ; 0.5
CONST	ENDS
;	COMDAT ?UTIL_MonstersInSphere@@YAHPAPAVCBaseEntity@@HABVVector@@M@Z
_TEXT	SEGMENT
_pList$ = 8
_listMax$ = 12
_center$ = 16
_radius$ = 20
_pEdict$ = -4
_pEntity$ = -8
_count$ = -12
_distance$ = -16
_delta$ = -20
_radiusSquared$ = -24
_i$ = -28
?UTIL_MonstersInSphere@@YAHPAPAVCBaseEntity@@HABVVector@@M@Z PROC NEAR ; UTIL_MonstersInSphere, COMDAT

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 711  : 	edict_t *pEdict = INDEXENT( 1 );

	push	1
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	mov	DWORD PTR _pEdict$[ebp], eax

; 712  : 	CBaseEntity *pEntity;
; 713  : 	int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 714  : 	float distance, delta;
; 715  : 	float radiusSquared = radius * radius;

	fld	DWORD PTR _radius$[ebp]
	fmul	DWORD PTR _radius$[ebp]
	fstp	DWORD PTR _radiusSquared$[ebp]

; 716  : 
; 717  : 	if ( !pEdict )

	cmp	DWORD PTR _pEdict$[ebp], 0
	jne	SHORT $L40939

; 718  : 		return count;

	mov	eax, DWORD PTR _count$[ebp]
	jmp	$L40932
$L40939:

; 719  : 
; 720  : 	for ( int i = 1; i < gpGlobals->maxEntities; i++, pEdict++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L40941
$L40942:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _pEdict$[ebp]
	add	ecx, 804				; 00000324H
	mov	DWORD PTR _pEdict$[ebp], ecx
$L40941:
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+148]
	jge	$L40943

; 722  : 		if ( pEdict->free )	// Not in use

	mov	ecx, DWORD PTR _pEdict$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L40944

; 723  : 			continue;

	jmp	SHORT $L40942
$L40944:

; 724  : 		
; 725  : 		if ( !(pEdict->v.flags & (FL_CLIENT|FL_MONSTER)) )	// Not a client/monster ?

	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 40					; 00000028H
	test	eax, eax
	jne	SHORT $L40945

; 726  : 			continue;

	jmp	SHORT $L40942
$L40945:

; 727  : 
; 728  : 		// Use origin for X & Y since they are centered for all monsters
; 729  : 		// Now X
; 730  : 		delta = center.x - pEdict->v.origin.x;//(pEdict->v.absmin.x + pEdict->v.absmax.x)*0.5;

	mov	ecx, DWORD PTR _center$[ebp]
	mov	edx, DWORD PTR _pEdict$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx+136]
	fst	DWORD PTR _delta$[ebp]

; 731  : 		delta *= delta;

	fmul	DWORD PTR _delta$[ebp]
	fstp	DWORD PTR _delta$[ebp]

; 732  : 
; 733  : 		if ( delta > radiusSquared )

	fld	DWORD PTR _delta$[ebp]
	fcomp	DWORD PTR _radiusSquared$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40946

; 734  : 			continue;

	jmp	SHORT $L40942
$L40946:

; 735  : 		distance = delta;

	mov	eax, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _distance$[ebp], eax

; 736  : 		
; 737  : 		// Now Y
; 738  : 		delta = center.y - pEdict->v.origin.y;//(pEdict->v.absmin.y + pEdict->v.absmax.y)*0.5;

	mov	ecx, DWORD PTR _center$[ebp]
	mov	edx, DWORD PTR _pEdict$[ebp]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR [edx+140]
	fst	DWORD PTR _delta$[ebp]

; 739  : 		delta *= delta;

	fmul	DWORD PTR _delta$[ebp]
	fstp	DWORD PTR _delta$[ebp]

; 740  : 
; 741  : 		distance += delta;

	fld	DWORD PTR _distance$[ebp]
	fadd	DWORD PTR _delta$[ebp]
	fstp	DWORD PTR _distance$[ebp]

; 742  : 		if ( distance > radiusSquared )

	fld	DWORD PTR _distance$[ebp]
	fcomp	DWORD PTR _radiusSquared$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40947

; 743  : 			continue;

	jmp	$L40942
$L40947:

; 744  : 
; 745  : 		// Now Z
; 746  : 		delta = center.z - (pEdict->v.absmin.z + pEdict->v.absmax.z)*0.5;

	mov	eax, DWORD PTR _center$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	edx, DWORD PTR _pEdict$[ebp]
	fld	DWORD PTR [ecx+332]
	fadd	DWORD PTR [edx+344]
	fmul	QWORD PTR __real@8@3ffe8000000000000000
	fsubp	ST(1), ST(0)
	fst	DWORD PTR _delta$[ebp]

; 747  : 		delta *= delta;

	fmul	DWORD PTR _delta$[ebp]
	fstp	DWORD PTR _delta$[ebp]

; 748  : 
; 749  : 		distance += delta;

	fld	DWORD PTR _distance$[ebp]
	fadd	DWORD PTR _delta$[ebp]
	fstp	DWORD PTR _distance$[ebp]

; 750  : 		if ( distance > radiusSquared )

	fld	DWORD PTR _distance$[ebp]
	fcomp	DWORD PTR _radiusSquared$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40948

; 751  : 			continue;

	jmp	$L40942
$L40948:

; 752  : 
; 753  : 		pEntity = CBaseEntity::Instance(pEdict);

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 754  : 		if ( !pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L40949

; 755  : 			continue;

	jmp	$L40942
$L40949:

; 756  : 
; 757  : 		pList[ count ] = pEntity;

	mov	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _pList$[ebp]
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 758  : 		count++;

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 759  : 
; 760  : 		if ( count >= listMax )

	mov	edx, DWORD PTR _count$[ebp]
	cmp	edx, DWORD PTR _listMax$[ebp]
	jl	SHORT $L40950

; 761  : 			return count;

	mov	eax, DWORD PTR _count$[ebp]
	jmp	SHORT $L40932
$L40950:

; 762  : 	}

	jmp	$L40942
$L40943:

; 763  : 
; 764  : 
; 765  : 	return count;

	mov	eax, DWORD PTR _count$[ebp]
$L40932:

; 766  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_MonstersInSphere@@YAHPAPAVCBaseEntity@@HABVVector@@M@Z ENDP ; UTIL_MonstersInSphere
_TEXT	ENDS
PUBLIC	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z ; UTIL_FindEntityInSphere
;	COMDAT ?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z
_TEXT	SEGMENT
_pStartEntity$ = 8
_vecCenter$ = 12
_flRadius$ = 16
_pentEntity$ = -4
?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z PROC NEAR ; UTIL_FindEntityInSphere, COMDAT

; 770  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 771  : 	edict_t	*pentEntity;
; 772  : 
; 773  : 	if (pStartEntity)

	cmp	DWORD PTR _pStartEntity$[ebp], 0
	je	SHORT $L40957

; 774  : 		pentEntity = pStartEntity->edict();

	mov	ecx, DWORD PTR _pStartEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _pentEntity$[ebp], eax

; 775  : 	else

	jmp	SHORT $L40958
$L40957:

; 776  : 		pentEntity = NULL;

	mov	DWORD PTR _pentEntity$[ebp], 0
$L40958:

; 777  : 
; 778  : 	pentEntity = FIND_ENTITY_IN_SPHERE( pentEntity, vecCenter, flRadius);

	mov	eax, DWORD PTR _flRadius$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecCenter$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _pentEntity$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+64
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pentEntity$[ebp], eax

; 779  : 
; 780  : 	if (!FNullEnt(pentEntity))

	mov	edx, DWORD PTR _pentEntity$[ebp]
	push	edx
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40959

; 781  : 		return CBaseEntity::Instance(pentEntity);

	mov	eax, DWORD PTR _pentEntity$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	jmp	SHORT $L40955
$L40959:

; 782  : 	return NULL;

	xor	eax, eax
$L40955:

; 783  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z ENDP ; UTIL_FindEntityInSphere
_TEXT	ENDS
PUBLIC	?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z ; UTIL_FindEntityByString
;	COMDAT ?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z
_TEXT	SEGMENT
_pStartEntity$ = 8
_szKeyword$ = 12
_szValue$ = 16
_pentEntity$ = -4
?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z PROC NEAR ; UTIL_FindEntityByString, COMDAT

; 787  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 788  : 	edict_t	*pentEntity;
; 789  : 
; 790  : 	if (pStartEntity)

	cmp	DWORD PTR _pStartEntity$[ebp], 0
	je	SHORT $L40966

; 791  : 		pentEntity = pStartEntity->edict();

	mov	ecx, DWORD PTR _pStartEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _pentEntity$[ebp], eax

; 792  : 	else

	jmp	SHORT $L40967
$L40966:

; 793  : 		pentEntity = NULL;

	mov	DWORD PTR _pentEntity$[ebp], 0
$L40967:

; 794  : 
; 795  : 	pentEntity = FIND_ENTITY_BY_STRING( pentEntity, szKeyword, szValue );

	mov	eax, DWORD PTR _szValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szKeyword$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pentEntity$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+56
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pentEntity$[ebp], eax

; 796  : 
; 797  : 	if (!FNullEnt(pentEntity))

	mov	eax, DWORD PTR _pentEntity$[ebp]
	push	eax
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40968

; 798  : 		return CBaseEntity::Instance(pentEntity);

	mov	ecx, DWORD PTR _pentEntity$[ebp]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	jmp	SHORT $L40964
$L40968:

; 799  : 	return NULL;

	xor	eax, eax
$L40964:

; 800  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z ENDP ; UTIL_FindEntityByString
_TEXT	ENDS
PUBLIC	??_C@_09JDJH@classname?$AA@			; `string'
PUBLIC	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
;	COMDAT ??_C@_09JDJH@classname?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_09JDJH@classname?$AA@ DB 'classname', 00H		; `string'
CONST	ENDS
;	COMDAT ?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z
_TEXT	SEGMENT
_pStartEntity$ = 8
_szName$ = 12
?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z PROC NEAR ; UTIL_FindEntityByClassname, COMDAT

; 803  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 804  : 	return UTIL_FindEntityByString( pStartEntity, "classname", szName );

	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_09JDJH@classname?$AA@	; `string'
	mov	ecx, DWORD PTR _pStartEntity$[ebp]
	push	ecx
	call	?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z ; UTIL_FindEntityByString
	add	esp, 12					; 0000000cH

; 805  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ENDP ; UTIL_FindEntityByClassname
_TEXT	ENDS
PUBLIC	??_C@_0L@PMO@targetname?$AA@			; `string'
PUBLIC	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0L@PMO@targetname?$AA@ DB 'targetname', 00H	; `string'
CONST	ENDS
;	COMDAT ?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z
_TEXT	SEGMENT
_pStartEntity$ = 8
_szName$ = 12
?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z PROC NEAR ; UTIL_FindEntityByTargetname, COMDAT

; 808  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 809  : 	return UTIL_FindEntityByString( pStartEntity, "targetname", szName );

	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@PMO@targetname?$AA@ ; `string'
	mov	ecx, DWORD PTR _pStartEntity$[ebp]
	push	ecx
	call	?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z ; UTIL_FindEntityByString
	add	esp, 12					; 0000000cH

; 810  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ENDP ; UTIL_FindEntityByTargetname
_TEXT	ENDS
PUBLIC	??_C@_06FJBO@?$CKlocus?$AA@			; `string'
PUBLIC	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD0@Z ; UTIL_FindEntityByTargetname
PUBLIC	?eoffset@CBaseEntity@@QAEHXZ			; CBaseEntity::eoffset
;	COMDAT ??_C@_06FJBO@?$CKlocus?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_06FJBO@?$CKlocus?$AA@ DB '*locus', 00H		; `string'
CONST	ENDS
;	COMDAT ?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD0@Z
_TEXT	SEGMENT
_pStartEntity$ = 8
_szName$ = 12
_pActivator$ = 16
?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD0@Z PROC NEAR ; UTIL_FindEntityByTargetname, COMDAT

; 813  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 814  : 	if( FStrEq( szName, "*locus" ))

	push	OFFSET FLAT:??_C@_06FJBO@?$CKlocus?$AA@	; `string'
	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L40982

; 816  : 		if( pActivator && ( pStartEntity == NULL || pActivator->eoffset() > pStartEntity->eoffset( )))

	cmp	DWORD PTR _pActivator$[ebp], 0
	je	SHORT $L40984
	cmp	DWORD PTR _pStartEntity$[ebp], 0
	je	SHORT $L40985
	mov	ecx, DWORD PTR _pActivator$[ebp]
	call	?eoffset@CBaseEntity@@QAEHXZ		; CBaseEntity::eoffset
	mov	esi, eax
	mov	ecx, DWORD PTR _pStartEntity$[ebp]
	call	?eoffset@CBaseEntity@@QAEHXZ		; CBaseEntity::eoffset
	cmp	esi, eax
	jle	SHORT $L40984
$L40985:

; 817  : 			return pActivator;

	mov	eax, DWORD PTR _pActivator$[ebp]
	jmp	SHORT $L40981
$L40984:

; 818  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L40981
$L40982:

; 820  : 	return UTIL_FindEntityByTargetname( pStartEntity, szName );

	mov	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pStartEntity$[ebp]
	push	edx
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
$L40981:

; 821  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD0@Z ENDP ; UTIL_FindEntityByTargetname
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
;	COMDAT ?eoffset@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?eoffset@CBaseEntity@@QAEHXZ PROC NEAR			; CBaseEntity::eoffset, COMDAT

; 711  : 	EOFFSET eoffset( ) { return OFFSET( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?eoffset@CBaseEntity@@QAEHXZ ENDP			; CBaseEntity::eoffset
_TEXT	ENDS
PUBLIC	??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad pev in OFFSET()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?OFFSET@@YAHPAUentvars_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L32439

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32439:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
PUBLIC	??_C@_06CCPD@target?$AA@			; `string'
PUBLIC	?UTIL_FindEntityByTarget@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTarget
;	COMDAT ??_C@_06CCPD@target?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_06CCPD@target?$AA@ DB 'target', 00H		; `string'
CONST	ENDS
;	COMDAT ?UTIL_FindEntityByTarget@@YAPAVCBaseEntity@@PAV1@PBD@Z
_TEXT	SEGMENT
_pStartEntity$ = 8
_szName$ = 12
?UTIL_FindEntityByTarget@@YAPAVCBaseEntity@@PAV1@PBD@Z PROC NEAR ; UTIL_FindEntityByTarget, COMDAT

; 824  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 825  : 	return UTIL_FindEntityByString( pStartEntity, "target", szName );

	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_06CCPD@target?$AA@	; `string'
	mov	ecx, DWORD PTR _pStartEntity$[ebp]
	push	ecx
	call	?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z ; UTIL_FindEntityByString
	add	esp, 12					; 0000000cH

; 826  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FindEntityByTarget@@YAPAVCBaseEntity@@PAV1@PBD@Z ENDP ; UTIL_FindEntityByTarget
_TEXT	ENDS
PUBLIC	?UTIL_FindEntityByMonsterTarget@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByMonsterTarget
PUBLIC	?GetMonsterPointer@CBaseEntity@@SAPAVCBaseMonster@@PAUedict_s@@@Z ; CBaseEntity::GetMonsterPointer
PUBLIC	?entindex@CBaseEntity@@QAEHXZ			; CBaseEntity::entindex
;	COMDAT ?UTIL_FindEntityByMonsterTarget@@YAPAVCBaseEntity@@PAV1@PBD@Z
_TEXT	SEGMENT
_pStartEntity$ = 8
_szName$ = 12
_e$ = -4
_pEdict$41001 = -8
_pMonster$41004 = -12
?UTIL_FindEntityByMonsterTarget@@YAPAVCBaseEntity@@PAV1@PBD@Z PROC NEAR ; UTIL_FindEntityByMonsterTarget, COMDAT

; 829  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 830  : 	if( !szName || !*szName )

	cmp	DWORD PTR _szName$[ebp], 0
	je	SHORT $L40995
	mov	eax, DWORD PTR _szName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L40994
$L40995:

; 831  : 		return NULL;

	xor	eax, eax
	jmp	$L40993
$L40994:

; 832  : 
; 833  : 	int e = 0;

	mov	DWORD PTR _e$[ebp], 0

; 834  : 
; 835  : 	if (pStartEntity)

	cmp	DWORD PTR _pStartEntity$[ebp], 0
	je	SHORT $L40997

; 836  : 		e = pStartEntity->entindex();

	mov	ecx, DWORD PTR _pStartEntity$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	mov	DWORD PTR _e$[ebp], eax
$L40997:

; 837  : 
; 838  : 	for ( e++; e < gpGlobals->maxEntities; e++ )

	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 1
	mov	DWORD PTR _e$[ebp], edx
	jmp	SHORT $L40998
$L40999:
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 1
	mov	DWORD PTR _e$[ebp], eax
$L40998:
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _e$[ebp]
	cmp	edx, DWORD PTR [ecx+148]
	jge	SHORT $L41000

; 840  : 		edict_t *pEdict = INDEXENT( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	mov	DWORD PTR _pEdict$41001[ebp], eax

; 841  : 
; 842  : 		if( !pEdict || pEdict->free )	// Not in use

	cmp	DWORD PTR _pEdict$41001[ebp], 0
	je	SHORT $L41003
	mov	ecx, DWORD PTR _pEdict$41001[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L41002
$L41003:

; 843  : 			continue;

	jmp	SHORT $L40999
$L41002:

; 844  : 
; 845  : 		CBaseMonster *pMonster = CBaseEntity::GetMonsterPointer( pEdict );

	mov	edx, DWORD PTR _pEdict$41001[ebp]
	push	edx
	call	?GetMonsterPointer@CBaseEntity@@SAPAVCBaseMonster@@PAUedict_s@@@Z ; CBaseEntity::GetMonsterPointer
	add	esp, 4
	mov	DWORD PTR _pMonster$41004[ebp], eax

; 846  : 
; 847  : 		if( !pMonster )

	cmp	DWORD PTR _pMonster$41004[ebp], 0
	jne	SHORT $L41005

; 848  : 			continue;

	jmp	SHORT $L40999
$L41005:

; 849  : 
; 850  : 		if( !Q_strcmp( szName, STRING( pMonster->m_iszTriggerTarget )) )

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pMonster$41004[ebp]
	mov	ecx, DWORD PTR [eax+2360]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _szName$[ebp]
	push	edx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L41006

; 851  : 			return pMonster;

	mov	eax, DWORD PTR _pMonster$41004[ebp]
	jmp	SHORT $L40993
$L41006:

; 852  : 	}

	jmp	SHORT $L40999
$L41000:

; 853  : 
; 854  : 	return NULL;

	xor	eax, eax
$L40993:

; 855  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FindEntityByMonsterTarget@@YAPAVCBaseEntity@@PAV1@PBD@Z ENDP ; UTIL_FindEntityByMonsterTarget
_TEXT	ENDS
;	COMDAT ?GetMonsterPointer@CBaseEntity@@SAPAVCBaseMonster@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEntity$ = -4
_pentMonster$ = 8
?GetMonsterPointer@CBaseEntity@@SAPAVCBaseMonster@@PAUedict_s@@@Z PROC NEAR ; CBaseEntity::GetMonsterPointer, COMDAT

; 544  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 545  : 		CBaseEntity *pEntity = Instance( pentMonster );

	mov	eax, DWORD PTR _pentMonster$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 546  : 		if ( pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L35041

; 547  : 			return pEntity->MyMonsterPointer();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+124]
	jmp	SHORT $L35039
$L35041:

; 548  : 		return NULL;

	xor	eax, eax
$L35039:

; 549  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMonsterPointer@CBaseEntity@@SAPAVCBaseMonster@@PAUedict_s@@@Z ENDP ; CBaseEntity::GetMonsterPointer
_TEXT	ENDS
PUBLIC	?ENTINDEX@@YAHPAUedict_s@@@Z			; ENTINDEX
;	COMDAT ?entindex@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?entindex@CBaseEntity@@QAEHXZ PROC NEAR			; CBaseEntity::entindex, COMDAT

; 712  : 	int entindex( ) { return ENTINDEX( edict() ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?entindex@CBaseEntity@@QAEHXZ ENDP			; CBaseEntity::entindex
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT
_pEdict$ = 8
?ENTINDEX@@YAHPAUedict_s@@@Z PROC NEAR			; ENTINDEX, COMDAT

; 186  : inline int	  ENTINDEX(edict_t *pEdict)			{ return (*g_engfuncs.pfnIndexOfEdict)(pEdict); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+284
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENTINDEX@@YAHPAUedict_s@@@Z ENDP			; ENTINDEX
_TEXT	ENDS
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	?UTIL_FindEntityGeneric@@YAPAVCBaseEntity@@PBDABVVector@@M@Z ; UTIL_FindEntityGeneric
;	COMDAT ?UTIL_FindEntityGeneric@@YAPAVCBaseEntity@@PBDABVVector@@M@Z
_TEXT	SEGMENT
_szWhatever$ = 8
_vecSrc$ = 12
_flRadius$ = 16
_pEntity$ = -4
_pSearch$ = -8
_flMaxDist2$ = -12
_flDist2$41019 = -16
$T43824 = -28
?UTIL_FindEntityGeneric@@YAPAVCBaseEntity@@PBDABVVector@@M@Z PROC NEAR ; UTIL_FindEntityGeneric, COMDAT

; 858  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 859  : 	CBaseEntity *pEntity = NULL;

	mov	DWORD PTR _pEntity$[ebp], 0

; 860  : 
; 861  : 	pEntity = UTIL_FindEntityByTargetname( NULL, szWhatever );

	mov	eax, DWORD PTR _szWhatever$[ebp]
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pEntity$[ebp], eax

; 862  : 	if (pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L41013

; 863  : 		return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]
	jmp	SHORT $L41011
$L41013:

; 864  : 
; 865  : 	CBaseEntity *pSearch = NULL;

	mov	DWORD PTR _pSearch$[ebp], 0

; 866  : 	float flMaxDist2 = flRadius * flRadius;

	fld	DWORD PTR _flRadius$[ebp]
	fmul	DWORD PTR _flRadius$[ebp]
	fstp	DWORD PTR _flMaxDist2$[ebp]
$L41017:

; 867  : 	while ((pSearch = UTIL_FindEntityByClassname( pSearch, szWhatever )) != NULL)

	mov	ecx, DWORD PTR _szWhatever$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSearch$[ebp]
	push	edx
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pSearch$[ebp], eax
	cmp	DWORD PTR _pSearch$[ebp], 0
	je	SHORT $L41018

; 869  : 		float flDist2 = (pSearch->GetAbsOrigin() - vecSrc).Length();

	mov	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T43824[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pSearch$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flDist2$41019[ebp]

; 870  : 		flDist2 = flDist2 * flDist2;

	fld	DWORD PTR _flDist2$41019[ebp]
	fmul	DWORD PTR _flDist2$41019[ebp]
	fstp	DWORD PTR _flDist2$41019[ebp]

; 871  : 		if (flMaxDist2 > flDist2)

	fld	DWORD PTR _flMaxDist2$[ebp]
	fcomp	DWORD PTR _flDist2$41019[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41021

; 873  : 			pEntity = pSearch;

	mov	edx, DWORD PTR _pSearch$[ebp]
	mov	DWORD PTR _pEntity$[ebp], edx

; 874  : 			flMaxDist2 = flDist2;

	mov	eax, DWORD PTR _flDist2$41019[ebp]
	mov	DWORD PTR _flMaxDist2$[ebp], eax
$L41021:

; 876  : 	}

	jmp	SHORT $L41017
$L41018:

; 877  : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]
$L41011:

; 878  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FindEntityGeneric@@YAPAVCBaseEntity@@PBDABVVector@@M@Z ENDP ; UTIL_FindEntityGeneric
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T43827 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T43827[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
PUBLIC	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z	; UTIL_PlayerByIndex
;	COMDAT ?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_playerIndex$ = 8
_pPlayer$ = -4
_pPlayerEdict$41027 = -8
?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z PROC NEAR	; UTIL_PlayerByIndex, COMDAT

; 885  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 886  : 	CBaseEntity *pPlayer = NULL;

	mov	DWORD PTR _pPlayer$[ebp], 0

; 887  : 
; 888  : 	if ( playerIndex > 0 && playerIndex <= gpGlobals->maxClients )

	cmp	DWORD PTR _playerIndex$[ebp], 0
	jle	SHORT $L41028
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _playerIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+144]
	jg	SHORT $L41028

; 890  : 		edict_t *pPlayerEdict = INDEXENT( playerIndex );

	mov	edx, DWORD PTR _playerIndex$[ebp]
	push	edx
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	mov	DWORD PTR _pPlayerEdict$41027[ebp], eax

; 891  : 		if ( pPlayerEdict && !pPlayerEdict->free )

	cmp	DWORD PTR _pPlayerEdict$41027[ebp], 0
	je	SHORT $L41028
	mov	eax, DWORD PTR _pPlayerEdict$41027[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L41028

; 893  : 			pPlayer = CBaseEntity::Instance( pPlayerEdict );

	mov	ecx, DWORD PTR _pPlayerEdict$41027[ebp]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pPlayer$[ebp], eax
$L41028:

; 896  : 	
; 897  : 	return pPlayer;

	mov	eax, DWORD PTR _pPlayer$[ebp]

; 898  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ENDP		; UTIL_PlayerByIndex
_TEXT	ENDS
PUBLIC	?UTIL_MakeVectors@@YAXABVVector@@@Z		; UTIL_MakeVectors
;	COMDAT ?UTIL_MakeVectors@@YAXABVVector@@@Z
_TEXT	SEGMENT
_vecAngles$ = 8
?UTIL_MakeVectors@@YAXABVVector@@@Z PROC NEAR		; UTIL_MakeVectors, COMDAT

; 902  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 903  : 	MAKE_VECTORS( vecAngles );

	mov	ecx, DWORD PTR _vecAngles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+76
	add	esp, 4

; 904  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_MakeVectors@@YAXABVVector@@@Z ENDP		; UTIL_MakeVectors
_TEXT	ENDS
PUBLIC	?UTIL_MakeAimVectors@@YAXABVVector@@@Z		; UTIL_MakeAimVectors
;	COMDAT ?UTIL_MakeAimVectors@@YAXABVVector@@@Z
_TEXT	SEGMENT
_vecAngles$ = 8
_rgflVec$ = -12
?UTIL_MakeAimVectors@@YAXABVVector@@@Z PROC NEAR	; UTIL_MakeAimVectors, COMDAT

; 908  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 909  : 	float rgflVec[3];
; 910  : 	vecAngles.CopyToArray(rgflVec);

	lea	eax, DWORD PTR _rgflVec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecAngles$[ebp]
	call	?CopyToArray@Vector@@QBEXPAM@Z		; Vector::CopyToArray

; 911  : 	rgflVec[0] = -rgflVec[0];

	fld	DWORD PTR _rgflVec$[ebp]
	fchs
	fstp	DWORD PTR _rgflVec$[ebp]

; 912  : 	MAKE_VECTORS(rgflVec);

	lea	ecx, DWORD PTR _rgflVec$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+76
	add	esp, 4

; 913  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_MakeAimVectors@@YAXABVVector@@@Z ENDP		; UTIL_MakeAimVectors
_TEXT	ENDS
PUBLIC	?UTIL_MakeInvVectors@@YAXABVVector@@PAUglobalvars_t@@@Z ; UTIL_MakeInvVectors
;	COMDAT ?UTIL_MakeInvVectors@@YAXABVVector@@PAUglobalvars_t@@@Z
_TEXT	SEGMENT
_vec$ = 8
_pgv$ = 12
_tmp$ = -4
$T43838 = -16
?UTIL_MakeInvVectors@@YAXABVVector@@PAUglobalvars_t@@@Z PROC NEAR ; UTIL_MakeInvVectors, COMDAT

; 919  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 920  : 	MAKE_VECTORS(vec);

	mov	ecx, DWORD PTR _vec$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+76
	add	esp, 4

; 921  : 
; 922  : 	float tmp;
; 923  : 	pgv->v_right = pgv->v_right * -1;

	push	-1082130432				; bf800000H
	lea	eax, DWORD PTR $T43838[ebp]
	push	eax
	mov	ecx, DWORD PTR _pgv$[ebp]
	add	ecx, 64					; 00000040H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR _pgv$[ebp]
	add	ecx, 64					; 00000040H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 924  : 
; 925  : 	SWAP(pgv->v_forward.y, pgv->v_right.x, tmp);

	mov	ecx, DWORD PTR _pgv$[ebp]
	fld	DWORD PTR [ecx+44]
	fstp	DWORD PTR _tmp$[ebp]
	mov	edx, DWORD PTR _pgv$[ebp]
	fld	DWORD PTR [edx+64]
	mov	eax, DWORD PTR _pgv$[ebp]
	fstp	DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _pgv$[ebp]
	mov	edx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [ecx+64], edx

; 926  : 	SWAP(pgv->v_forward.z, pgv->v_up.x, tmp);

	mov	eax, DWORD PTR _pgv$[ebp]
	fld	DWORD PTR [eax+48]
	fstp	DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR _pgv$[ebp]
	fld	DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _pgv$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _pgv$[ebp]
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 927  : 	SWAP(pgv->v_right.z, pgv->v_up.y, tmp);

	mov	edx, DWORD PTR _pgv$[ebp]
	fld	DWORD PTR [edx+72]
	fstp	DWORD PTR _tmp$[ebp]
	mov	eax, DWORD PTR _pgv$[ebp]
	fld	DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _pgv$[ebp]
	fstp	DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _pgv$[ebp]
	mov	eax, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [edx+56], eax

; 928  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_MakeInvVectors@@YAXABVVector@@PAUglobalvars_t@@@Z ENDP ; UTIL_MakeInvVectors
_TEXT	ENDS
PUBLIC	?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ; UTIL_EmitAmbientSound
EXTRN	?SENTENCEG_Lookup@@YAHPBDPAD@Z:NEAR		; SENTENCEG_Lookup
;	COMDAT ?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z
_TEXT	SEGMENT
_entity$ = 8
_vecOrigin$ = 12
_samp$ = 16
_vol$ = 20
_attenuation$ = 24
_fFlags$ = 28
_pitch$ = 32
_rgfl$ = -12
_name$41054 = -44
?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z PROC NEAR ; UTIL_EmitAmbientSound, COMDAT

; 932  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 933  : 	float rgfl[3];
; 934  : 	vecOrigin.CopyToArray(rgfl);

	lea	eax, DWORD PTR _rgfl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecOrigin$[ebp]
	call	?CopyToArray@Vector@@QBEXPAM@Z		; Vector::CopyToArray

; 935  : 
; 936  : 	if (samp && *samp == '!')

	cmp	DWORD PTR _samp$[ebp], 0
	je	SHORT $L41053
	mov	ecx, DWORD PTR _samp$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 33					; 00000021H
	jne	SHORT $L41053

; 938  : 		char name[32];
; 939  : 		if (SENTENCEG_Lookup(samp, name) >= 0)

	lea	eax, DWORD PTR _name$41054[ebp]
	push	eax
	mov	ecx, DWORD PTR _samp$[ebp]
	push	ecx
	call	?SENTENCEG_Lookup@@YAHPBDPAD@Z		; SENTENCEG_Lookup
	add	esp, 8
	test	eax, eax
	jl	SHORT $L41055

; 940  : 			EMIT_AMBIENT_SOUND(entity, rgfl, name, vol, attenuation, fFlags, pitch);

	mov	edx, DWORD PTR _pitch$[ebp]
	push	edx
	mov	eax, DWORD PTR _fFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _attenuation$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vol$[ebp]
	push	edx
	lea	eax, DWORD PTR _name$41054[ebp]
	push	eax
	lea	ecx, DWORD PTR _rgfl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entity$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+120
	add	esp, 28					; 0000001cH
$L41055:

; 942  : 	else

	jmp	SHORT $L41056
$L41053:

; 943  : 		EMIT_AMBIENT_SOUND(entity, rgfl, samp, vol, attenuation, fFlags, pitch);

	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _attenuation$[ebp]
	push	edx
	mov	eax, DWORD PTR _vol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _samp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _rgfl$[ebp]
	push	edx
	mov	eax, DWORD PTR _entity$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+120
	add	esp, 28					; 0000001cH
$L41056:

; 944  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_EmitAmbientSound@@YAXPAUedict_s@@ABVVector@@PBDMMHH@Z ENDP ; UTIL_EmitAmbientSound
_TEXT	ENDS
PUBLIC	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z		; MESSAGE_BEGIN
PUBLIC	?UTIL_ScreenShake@@YAXABVVector@@MMMM_N@Z	; UTIL_ScreenShake
EXTRN	?gmsgShake@@3HA:DWORD				; gmsgShake
;	COMDAT ?UTIL_ScreenShake@@YAXABVVector@@MMMM_N@Z
_TEXT	SEGMENT
_center$ = 8
_amplitude$ = 12
_frequency$ = 16
_duration$ = 20
_radius$ = 24
_bAllowInAir$ = 28
_i$ = -4
_localAmplitude$ = -8
_shake$ = -16
_pPlayer$41087 = -20
_delta$41092 = -32
_distance$41094 = -36
$T43843 = -48
?UTIL_ScreenShake@@YAXABVVector@@MMMM_N@Z PROC NEAR	; UTIL_ScreenShake, COMDAT

; 980  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 981  : 	int			i;
; 982  : 	float		localAmplitude;
; 983  : 	ScreenShake	shake;
; 984  : 
; 985  : 	shake.duration = FixedUnsigned16( duration, 1<<12 );		// 4.12 fixed

	push	1166016512				; 45800000H
	mov	eax, DWORD PTR _duration$[ebp]
	push	eax
	call	?FixedUnsigned16@@YAGMM@Z		; FixedUnsigned16
	add	esp, 8
	mov	WORD PTR _shake$[ebp+2], ax

; 986  : 	shake.frequency = FixedUnsigned16( frequency, 1<<8 );	// 8.8 fixed

	push	1132462080				; 43800000H
	mov	ecx, DWORD PTR _frequency$[ebp]
	push	ecx
	call	?FixedUnsigned16@@YAGMM@Z		; FixedUnsigned16
	add	esp, 8
	mov	WORD PTR _shake$[ebp+4], ax

; 987  : 
; 988  : 	for ( i = 1; i <= gpGlobals->maxClients; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L41084
$L41085:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L41084:
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+144]
	jg	$L41086

; 990  : 		CBaseEntity *pPlayer = UTIL_PlayerByIndex( i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pPlayer$41087[ebp], eax

; 991  : 
; 992  : 		if ( !pPlayer || ( !FBitSet( pPlayer->pev->flags, FL_ONGROUND ) && !bAllowInAir )) // Don't shake if not onground

	cmp	DWORD PTR _pPlayer$41087[ebp], 0
	je	SHORT $L41089
	mov	eax, DWORD PTR _pPlayer$41087[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	jne	SHORT $L41088
	mov	eax, DWORD PTR _bAllowInAir$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41088
$L41089:

; 993  : 			continue;

	jmp	SHORT $L41085
$L41088:

; 994  : 
; 995  : 		localAmplitude = 0;

	mov	DWORD PTR _localAmplitude$[ebp], 0

; 996  : 
; 997  : 		if ( radius <= 0 )

	fld	DWORD PTR _radius$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L41090

; 998  : 			localAmplitude = amplitude;

	mov	ecx, DWORD PTR _amplitude$[ebp]
	mov	DWORD PTR _localAmplitude$[ebp], ecx

; 999  : 		else

	jmp	SHORT $L41095
$L41090:

; 1001 : 			Vector delta = center - pPlayer->GetAbsOrigin();

	mov	ecx, DWORD PTR _pPlayer$41087[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T43843[ebp]
	push	edx
	mov	ecx, DWORD PTR _center$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _delta$41092[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1002 : 			float distance = delta.Length();

	lea	ecx, DWORD PTR _delta$41092[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _distance$41094[ebp]

; 1003 : 	
; 1004 : 			// Had to get rid of this falloff - it didn't work well
; 1005 : 			if ( distance < radius )

	fld	DWORD PTR _distance$41094[ebp]
	fcomp	DWORD PTR _radius$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41095

; 1006 : 				localAmplitude = amplitude;//radius - distance;

	mov	eax, DWORD PTR _amplitude$[ebp]
	mov	DWORD PTR _localAmplitude$[ebp], eax
$L41095:

; 1008 : 		if ( localAmplitude )

	fld	DWORD PTR _localAmplitude$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41096

; 1010 : 			shake.amplitude = FixedUnsigned16( localAmplitude, 1<<12 );		// 4.12 fixed

	push	1166016512				; 45800000H
	mov	ecx, DWORD PTR _localAmplitude$[ebp]
	push	ecx
	call	?FixedUnsigned16@@YAGMM@Z		; FixedUnsigned16
	add	esp, 8
	mov	WORD PTR _shake$[ebp], ax

; 1011 : 			
; 1012 : 			MESSAGE_BEGIN( MSG_ONE, gmsgShake, NULL, pPlayer->edict() );		// use the magic #1 for "one client"

	mov	ecx, DWORD PTR _pPlayer$41087[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	mov	edx, DWORD PTR ?gmsgShake@@3HA		; gmsgShake
	push	edx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1013 : 				
; 1014 : 				WRITE_SHORT( shake.amplitude );				// shake amount

	mov	eax, DWORD PTR _shake$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1015 : 				WRITE_SHORT( shake.duration );				// shake lasts this long

	mov	ecx, DWORD PTR _shake$[ebp+2]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1016 : 				WRITE_SHORT( shake.frequency );				// shake noise frequency

	mov	edx, DWORD PTR _shake$[ebp+4]
	and	edx, 65535				; 0000ffffH
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1017 : 
; 1018 : 			MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41096:

; 1020 : 	}

	jmp	$L41085
$L41086:

; 1021 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ScreenShake@@YAXABVVector@@MMMM_N@Z ENDP		; UTIL_ScreenShake
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_type$ = 12
_pOrigin$ = 16
_ed$ = 20
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z PROC NEAR	; MESSAGE_BEGIN, COMDAT

; 72   : inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin = NULL, edict_t *ed = NULL ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 73   : 	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ed);

	mov	eax, DWORD PTR _ed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+184
	add	esp, 16					; 00000010H

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z ENDP		; MESSAGE_BEGIN
_TEXT	ENDS
;	COMDAT ?FixedUnsigned16@@YAGMM@Z
_TEXT	SEGMENT
_value$ = 8
_scale$ = 12
_output$ = -4
?FixedUnsigned16@@YAGMM@Z PROC NEAR			; FixedUnsigned16, COMDAT

; 947  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 948  : 	int output;
; 949  : 
; 950  : 	output = value * scale;

	fld	DWORD PTR _value$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	call	__ftol
	mov	DWORD PTR _output$[ebp], eax

; 951  : 	if ( output < 0 )

	cmp	DWORD PTR _output$[ebp], 0
	jge	SHORT $L41062

; 952  : 		output = 0;

	mov	DWORD PTR _output$[ebp], 0
$L41062:

; 953  : 	if ( output > 0xFFFF )

	cmp	DWORD PTR _output$[ebp], 65535		; 0000ffffH
	jle	SHORT $L41063

; 954  : 		output = 0xFFFF;

	mov	DWORD PTR _output$[ebp], 65535		; 0000ffffH
$L41063:

; 955  : 
; 956  : 	return (unsigned short)output;

	mov	ax, WORD PTR _output$[ebp]

; 957  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FixedUnsigned16@@YAGMM@Z ENDP				; FixedUnsigned16
_TEXT	ENDS
PUBLIC	?UTIL_ScreenShakeAll@@YAXABVVector@@MMM@Z	; UTIL_ScreenShakeAll
;	COMDAT ?UTIL_ScreenShakeAll@@YAXABVVector@@MMM@Z
_TEXT	SEGMENT
_center$ = 8
_amplitude$ = 12
_frequency$ = 16
_duration$ = 20
?UTIL_ScreenShakeAll@@YAXABVVector@@MMM@Z PROC NEAR	; UTIL_ScreenShakeAll, COMDAT

; 1026 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1027 : 	UTIL_ScreenShake( center, amplitude, frequency, duration, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _duration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _frequency$[ebp]
	push	ecx
	mov	edx, DWORD PTR _amplitude$[ebp]
	push	edx
	mov	eax, DWORD PTR _center$[ebp]
	push	eax
	call	?UTIL_ScreenShake@@YAXABVVector@@MMMM_N@Z ; UTIL_ScreenShake
	add	esp, 24					; 00000018H

; 1028 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ScreenShakeAll@@YAXABVVector@@MMM@Z ENDP		; UTIL_ScreenShakeAll
_TEXT	ENDS
PUBLIC	?UTIL_ScreenFadeBuild@@YAXAAUScreenFade@@ABVVector@@MMHH@Z ; UTIL_ScreenFadeBuild
;	COMDAT ?UTIL_ScreenFadeBuild@@YAXAAUScreenFade@@ABVVector@@MMHH@Z
_TEXT	SEGMENT
_fade$ = 8
_color$ = 12
_fadeTime$ = 16
_fadeHold$ = 20
_alpha$ = 24
_flags$ = 28
?UTIL_ScreenFadeBuild@@YAXAAUScreenFade@@ABVVector@@MMHH@Z PROC NEAR ; UTIL_ScreenFadeBuild, COMDAT

; 1032 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1033 : 	fade.duration = FixedUnsigned16( fadeTime, 1<<12 );		// 4.12 fixed

	push	1166016512				; 45800000H
	mov	eax, DWORD PTR _fadeTime$[ebp]
	push	eax
	call	?FixedUnsigned16@@YAGMM@Z		; FixedUnsigned16
	add	esp, 8
	mov	ecx, DWORD PTR _fade$[ebp]
	mov	WORD PTR [ecx], ax

; 1034 : 	fade.holdTime = FixedUnsigned16( fadeHold, 1<<12 );		// 4.12 fixed

	push	1166016512				; 45800000H
	mov	edx, DWORD PTR _fadeHold$[ebp]
	push	edx
	call	?FixedUnsigned16@@YAGMM@Z		; FixedUnsigned16
	add	esp, 8
	mov	ecx, DWORD PTR _fade$[ebp]
	mov	WORD PTR [ecx+2], ax

; 1035 : 	fade.r = (int)color.x;

	mov	edx, DWORD PTR _color$[ebp]
	fld	DWORD PTR [edx]
	call	__ftol
	mov	ecx, DWORD PTR _fade$[ebp]
	mov	BYTE PTR [ecx+6], al

; 1036 : 	fade.g = (int)color.y;

	mov	edx, DWORD PTR _color$[ebp]
	fld	DWORD PTR [edx+4]
	call	__ftol
	mov	ecx, DWORD PTR _fade$[ebp]
	mov	BYTE PTR [ecx+7], al

; 1037 : 	fade.b = (int)color.z;

	mov	edx, DWORD PTR _color$[ebp]
	fld	DWORD PTR [edx+8]
	call	__ftol
	mov	ecx, DWORD PTR _fade$[ebp]
	mov	BYTE PTR [ecx+8], al

; 1038 : 	fade.a = alpha;

	mov	edx, DWORD PTR _fade$[ebp]
	mov	al, BYTE PTR _alpha$[ebp]
	mov	BYTE PTR [edx+9], al

; 1039 : 	fade.fadeFlags = flags;

	mov	ecx, DWORD PTR _fade$[ebp]
	mov	dx, WORD PTR _flags$[ebp]
	mov	WORD PTR [ecx+4], dx

; 1040 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ScreenFadeBuild@@YAXAAUScreenFade@@ABVVector@@MMHH@Z ENDP ; UTIL_ScreenFadeBuild
_TEXT	ENDS
PUBLIC	?UTIL_ScreenFadeWrite@@YAXABUScreenFade@@PAVCBaseEntity@@@Z ; UTIL_ScreenFadeWrite
EXTRN	?gmsgFade@@3HA:DWORD				; gmsgFade
;	COMDAT ?UTIL_ScreenFadeWrite@@YAXABUScreenFade@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT
_fade$ = 8
_pEntity$ = 12
?UTIL_ScreenFadeWrite@@YAXABUScreenFade@@PAVCBaseEntity@@@Z PROC NEAR ; UTIL_ScreenFadeWrite, COMDAT

; 1044 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1045 : 	if ( !pEntity || !pEntity->IsNetClient() )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L41119
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+228]
	test	eax, eax
	jne	SHORT $L41118
$L41119:

; 1046 : 		return;

	jmp	$L41117
$L41118:

; 1047 : 
; 1048 : 	MESSAGE_BEGIN( MSG_ONE, gmsgFade, NULL, pEntity->edict() );		// use the magic #1 for "one client"

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	mov	eax, DWORD PTR ?gmsgFade@@3HA		; gmsgFade
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1049 : 		
; 1050 : 		WRITE_SHORT( fade.duration );		// fade lasts this long

	mov	ecx, DWORD PTR _fade$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1051 : 		WRITE_SHORT( fade.holdTime );		// fade lasts this long

	mov	eax, DWORD PTR _fade$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+2]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1052 : 		WRITE_SHORT( fade.fadeFlags );		// fade type (in / out)

	mov	edx, DWORD PTR _fade$[ebp]
	movsx	eax, WORD PTR [edx+4]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1053 : 		WRITE_BYTE( fade.r );				// fade red

	mov	ecx, DWORD PTR _fade$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+6]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1054 : 		WRITE_BYTE( fade.g );				// fade green

	mov	eax, DWORD PTR _fade$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+7]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1055 : 		WRITE_BYTE( fade.b );				// fade blue

	mov	edx, DWORD PTR _fade$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1056 : 		WRITE_BYTE( fade.a );				// fade blue

	mov	ecx, DWORD PTR _fade$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+9]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1057 : 
; 1058 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41117:

; 1059 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ScreenFadeWrite@@YAXABUScreenFade@@PAVCBaseEntity@@@Z ENDP ; UTIL_ScreenFadeWrite
_TEXT	ENDS
PUBLIC	?UTIL_ScreenFadeAll@@YAXABVVector@@MMHH@Z	; UTIL_ScreenFadeAll
;	COMDAT ?UTIL_ScreenFadeAll@@YAXABVVector@@MMHH@Z
_TEXT	SEGMENT
_color$ = 8
_fadeTime$ = 12
_fadeHold$ = 16
_alpha$ = 20
_flags$ = 24
_i$ = -4
_fade$ = -16
_pPlayer$41132 = -20
?UTIL_ScreenFadeAll@@YAXABVVector@@MMHH@Z PROC NEAR	; UTIL_ScreenFadeAll, COMDAT

; 1063 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1064 : 	int			i;
; 1065 : 	ScreenFade	fade;
; 1066 : 
; 1067 : 
; 1068 : 	UTIL_ScreenFadeBuild( fade, color, fadeTime, fadeHold, alpha, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _alpha$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fadeHold$[ebp]
	push	edx
	mov	eax, DWORD PTR _fadeTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	lea	edx, DWORD PTR _fade$[ebp]
	push	edx
	call	?UTIL_ScreenFadeBuild@@YAXAAUScreenFade@@ABVVector@@MMHH@Z ; UTIL_ScreenFadeBuild
	add	esp, 24					; 00000018H

; 1069 : 
; 1070 : 	for ( i = 1; i <= gpGlobals->maxClients; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L41129
$L41130:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L41129:
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+144]
	jg	SHORT $L41131

; 1072 : 		CBaseEntity *pPlayer = UTIL_PlayerByIndex( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pPlayer$41132[ebp], eax

; 1073 : 	
; 1074 : 		UTIL_ScreenFadeWrite( fade, pPlayer );

	mov	ecx, DWORD PTR _pPlayer$41132[ebp]
	push	ecx
	lea	edx, DWORD PTR _fade$[ebp]
	push	edx
	call	?UTIL_ScreenFadeWrite@@YAXABUScreenFade@@PAVCBaseEntity@@@Z ; UTIL_ScreenFadeWrite
	add	esp, 8

; 1075 : 	}

	jmp	SHORT $L41130
$L41131:

; 1076 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ScreenFadeAll@@YAXABVVector@@MMHH@Z ENDP		; UTIL_ScreenFadeAll
_TEXT	ENDS
PUBLIC	?UTIL_ScreenFade@@YAXPAVCBaseEntity@@ABVVector@@MMHH@Z ; UTIL_ScreenFade
;	COMDAT ?UTIL_ScreenFade@@YAXPAVCBaseEntity@@ABVVector@@MMHH@Z
_TEXT	SEGMENT
_pEntity$ = 8
_color$ = 12
_fadeTime$ = 16
_fadeHold$ = 20
_alpha$ = 24
_flags$ = 28
_fade$ = -12
?UTIL_ScreenFade@@YAXPAVCBaseEntity@@ABVVector@@MMHH@Z PROC NEAR ; UTIL_ScreenFade, COMDAT

; 1080 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1081 : 	ScreenFade	fade;
; 1082 : 
; 1083 : 	UTIL_ScreenFadeBuild( fade, color, fadeTime, fadeHold, alpha, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _alpha$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fadeHold$[ebp]
	push	edx
	mov	eax, DWORD PTR _fadeTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	lea	edx, DWORD PTR _fade$[ebp]
	push	edx
	call	?UTIL_ScreenFadeBuild@@YAXAAUScreenFade@@ABVVector@@MMHH@Z ; UTIL_ScreenFadeBuild
	add	esp, 24					; 00000018H

; 1084 : 	UTIL_ScreenFadeWrite( fade, pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fade$[ebp]
	push	ecx
	call	?UTIL_ScreenFadeWrite@@YAXABUScreenFade@@PAVCBaseEntity@@@Z ; UTIL_ScreenFadeWrite
	add	esp, 8

; 1085 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ScreenFade@@YAXPAVCBaseEntity@@ABVVector@@MMHH@Z ENDP ; UTIL_ScreenFade
_TEXT	ENDS
PUBLIC	?UTIL_HudMessage@@YAXPAVCBaseEntity@@ABUhudtextparms_s@@PBD@Z ; UTIL_HudMessage
EXTRN	_strlen:NEAR
EXTRN	_strncpy:NEAR
;	COMDAT ?UTIL_HudMessage@@YAXPAVCBaseEntity@@ABUhudtextparms_s@@PBD@Z
_TEXT	SEGMENT
_pEntity$ = 8
_textparms$ = 12
_pMessage$ = 16
_tmp$41152 = -512
?UTIL_HudMessage@@YAXPAVCBaseEntity@@ABUhudtextparms_s@@PBD@Z PROC NEAR ; UTIL_HudMessage, COMDAT

; 1089 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 576				; 00000240H
	push	ebx
	push	esi
	push	edi

; 1090 : 	if ( !pEntity || !pEntity->IsNetClient() )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L41148
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+228]
	test	eax, eax
	jne	SHORT $L41147
$L41148:

; 1091 : 		return;

	jmp	$L41146
$L41147:

; 1092 : 
; 1093 : 	MESSAGE_BEGIN( MSG_ONE, SVC_TEMPENTITY, NULL, pEntity->edict() );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	push	23					; 00000017H
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1094 : 		WRITE_BYTE( TE_TEXTMESSAGE );

	push	29					; 0000001dH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1095 : 		WRITE_BYTE( textparms.channel & 0xFF );

	mov	eax, DWORD PTR _textparms$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 255				; 000000ffH
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1096 : 
; 1097 : 		WRITE_SHORT( FixedSigned16( textparms.x, 1<<13 ) );

	push	1174405120				; 46000000H
	mov	edx, DWORD PTR _textparms$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?FixedSigned16@@YAFMM@Z			; FixedSigned16
	add	esp, 8
	movsx	ecx, ax
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1098 : 		WRITE_SHORT( FixedSigned16( textparms.y, 1<<13 ) );

	push	1174405120				; 46000000H
	mov	edx, DWORD PTR _textparms$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FixedSigned16@@YAFMM@Z			; FixedSigned16
	add	esp, 8
	movsx	ecx, ax
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1099 : 		WRITE_BYTE( textparms.effect );

	mov	edx, DWORD PTR _textparms$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1100 : 
; 1101 : 		WRITE_BYTE( textparms.r1 );

	mov	ecx, DWORD PTR _textparms$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+12]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1102 : 		WRITE_BYTE( textparms.g1 );

	mov	eax, DWORD PTR _textparms$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+13]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1103 : 		WRITE_BYTE( textparms.b1 );

	mov	edx, DWORD PTR _textparms$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+14]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1104 : 		WRITE_BYTE( textparms.a1 );

	mov	ecx, DWORD PTR _textparms$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+15]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1105 : 
; 1106 : 		WRITE_BYTE( textparms.r2 );

	mov	eax, DWORD PTR _textparms$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+16]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1107 : 		WRITE_BYTE( textparms.g2 );

	mov	edx, DWORD PTR _textparms$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+17]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1108 : 		WRITE_BYTE( textparms.b2 );

	mov	ecx, DWORD PTR _textparms$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+18]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1109 : 		WRITE_BYTE( textparms.a2 );

	mov	eax, DWORD PTR _textparms$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+19]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1110 : 
; 1111 : 		WRITE_SHORT( FixedUnsigned16( textparms.fadeinTime, 1<<8 ) );

	push	1132462080				; 43800000H
	mov	edx, DWORD PTR _textparms$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?FixedUnsigned16@@YAGMM@Z		; FixedUnsigned16
	add	esp, 8
	and	eax, 65535				; 0000ffffH
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1112 : 		WRITE_SHORT( FixedUnsigned16( textparms.fadeoutTime, 1<<8 ) );

	push	1132462080				; 43800000H
	mov	ecx, DWORD PTR _textparms$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?FixedUnsigned16@@YAGMM@Z		; FixedUnsigned16
	add	esp, 8
	and	eax, 65535				; 0000ffffH
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1113 : 		WRITE_SHORT( FixedUnsigned16( textparms.holdTime, 1<<8 ) );

	push	1132462080				; 43800000H
	mov	eax, DWORD PTR _textparms$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	?FixedUnsigned16@@YAGMM@Z		; FixedUnsigned16
	add	esp, 8
	and	eax, 65535				; 0000ffffH
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1114 : 
; 1115 : 		if ( textparms.effect == 2 )

	mov	edx, DWORD PTR _textparms$[ebp]
	cmp	DWORD PTR [edx+8], 2
	jne	SHORT $L41149

; 1116 : 			WRITE_SHORT( FixedUnsigned16( textparms.fxTime, 1<<8 ) );

	push	1132462080				; 43800000H
	mov	eax, DWORD PTR _textparms$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	?FixedUnsigned16@@YAGMM@Z		; FixedUnsigned16
	add	esp, 8
	and	eax, 65535				; 0000ffffH
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4
$L41149:

; 1117 : 		
; 1118 : 		if ( strlen( pMessage ) < 512 )

	mov	edx, DWORD PTR _pMessage$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 512				; 00000200H
	jae	SHORT $L41150

; 1120 : 			WRITE_STRING( pMessage );

	mov	eax, DWORD PTR _pMessage$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 1122 : 		else

	jmp	SHORT $L41151
$L41150:

; 1124 : 			char tmp[512];
; 1125 : 			strncpy( tmp, pMessage, 511 );

	push	511					; 000001ffH
	mov	ecx, DWORD PTR _pMessage$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tmp$41152[ebp]
	push	edx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 1126 : 			tmp[511] = 0;

	mov	BYTE PTR _tmp$41152[ebp+511], 0

; 1127 : 			WRITE_STRING( tmp );

	lea	eax, DWORD PTR _tmp$41152[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4
$L41151:

; 1129 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41146:

; 1130 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_HudMessage@@YAXPAVCBaseEntity@@ABUhudtextparms_s@@PBD@Z ENDP ; UTIL_HudMessage
_TEXT	ENDS
;	COMDAT ?FixedSigned16@@YAFMM@Z
_TEXT	SEGMENT
_value$ = 8
_scale$ = 12
_output$ = -4
?FixedSigned16@@YAFMM@Z PROC NEAR			; FixedSigned16, COMDAT

; 960  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 961  : 	int output;
; 962  : 
; 963  : 	output = value * scale;

	fld	DWORD PTR _value$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	call	__ftol
	mov	DWORD PTR _output$[ebp], eax

; 964  : 
; 965  : 	if ( output > 32767 )

	cmp	DWORD PTR _output$[ebp], 32767		; 00007fffH
	jle	SHORT $L41070

; 966  : 		output = 32767;

	mov	DWORD PTR _output$[ebp], 32767		; 00007fffH
$L41070:

; 967  : 
; 968  : 	if ( output < -32768 )

	cmp	DWORD PTR _output$[ebp], -32768		; ffff8000H
	jge	SHORT $L41071

; 969  : 		output = -32768;

	mov	DWORD PTR _output$[ebp], -32768		; ffff8000H
$L41071:

; 970  : 
; 971  : 	return (short)output;

	mov	ax, WORD PTR _output$[ebp]

; 972  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FixedSigned16@@YAFMM@Z ENDP				; FixedSigned16
_TEXT	ENDS
PUBLIC	?UTIL_HudMessageAll@@YAXABUhudtextparms_s@@PBD@Z ; UTIL_HudMessageAll
;	COMDAT ?UTIL_HudMessageAll@@YAXABUhudtextparms_s@@PBD@Z
_TEXT	SEGMENT
_textparms$ = 8
_pMessage$ = 12
_i$ = -4
_pPlayer$41161 = -8
?UTIL_HudMessageAll@@YAXABUhudtextparms_s@@PBD@Z PROC NEAR ; UTIL_HudMessageAll, COMDAT

; 1133 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1134 : 	int			i;
; 1135 : 
; 1136 : 	for ( i = 1; i <= gpGlobals->maxClients; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L41158
$L41159:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L41158:
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+144]
	jg	SHORT $L41160

; 1138 : 		CBaseEntity *pPlayer = UTIL_PlayerByIndex( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pPlayer$41161[ebp], eax

; 1139 : 		if ( pPlayer )

	cmp	DWORD PTR _pPlayer$41161[ebp], 0
	je	SHORT $L41162

; 1140 : 			UTIL_HudMessage( pPlayer, textparms, pMessage );

	mov	ecx, DWORD PTR _pMessage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _textparms$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlayer$41161[ebp]
	push	eax
	call	?UTIL_HudMessage@@YAXPAVCBaseEntity@@ABUhudtextparms_s@@PBD@Z ; UTIL_HudMessage
	add	esp, 12					; 0000000cH
$L41162:

; 1141 : 	}

	jmp	SHORT $L41159
$L41160:

; 1142 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_HudMessageAll@@YAXABUhudtextparms_s@@PBD@Z ENDP	; UTIL_HudMessageAll
_TEXT	ENDS
PUBLIC	?UTIL_ClientPrintAll@@YAXHPBD0000@Z		; UTIL_ClientPrintAll
EXTRN	?gmsgTextMsg@@3HA:DWORD				; gmsgTextMsg
;	COMDAT ?UTIL_ClientPrintAll@@YAXHPBD0000@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_name$ = 12
_param1$ = 16
_param2$ = 20
_param3$ = 24
_param4$ = 28
?UTIL_ClientPrintAll@@YAXHPBD0000@Z PROC NEAR		; UTIL_ClientPrintAll, COMDAT

; 1147 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1148 : 	MESSAGE_BEGIN( MSG_ALL, gmsgTextMsg );

	push	0
	push	0
	mov	eax, DWORD PTR ?gmsgTextMsg@@3HA	; gmsgTextMsg
	push	eax
	push	2
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1149 : 		WRITE_BYTE( msg_dest );

	mov	ecx, DWORD PTR _msg_dest$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1150 : 		WRITE_STRING( msg_name );

	mov	edx, DWORD PTR _msg_name$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 1151 : 
; 1152 : 		if ( param1 )

	cmp	DWORD PTR _param1$[ebp], 0
	je	SHORT $L41173

; 1153 : 			WRITE_STRING( param1 );

	mov	eax, DWORD PTR _param1$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4
$L41173:

; 1154 : 		if ( param2 )

	cmp	DWORD PTR _param2$[ebp], 0
	je	SHORT $L41174

; 1155 : 			WRITE_STRING( param2 );

	mov	ecx, DWORD PTR _param2$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4
$L41174:

; 1156 : 		if ( param3 )

	cmp	DWORD PTR _param3$[ebp], 0
	je	SHORT $L41175

; 1157 : 			WRITE_STRING( param3 );

	mov	edx, DWORD PTR _param3$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4
$L41175:

; 1158 : 		if ( param4 )

	cmp	DWORD PTR _param4$[ebp], 0
	je	SHORT $L41176

; 1159 : 			WRITE_STRING( param4 );

	mov	eax, DWORD PTR _param4$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4
$L41176:

; 1160 : 
; 1161 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 1162 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ClientPrintAll@@YAXHPBD0000@Z ENDP		; UTIL_ClientPrintAll
_TEXT	ENDS
PUBLIC	?ClientPrint@@YAXPAUentvars_s@@HPBD1111@Z	; ClientPrint
PUBLIC	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z	; MESSAGE_BEGIN
;	COMDAT ?ClientPrint@@YAXPAUentvars_s@@HPBD1111@Z
_TEXT	SEGMENT
_client$ = 8
_msg_dest$ = 12
_msg_name$ = 16
_param1$ = 20
_param2$ = 24
_param3$ = 28
_param4$ = 32
?ClientPrint@@YAXPAUentvars_s@@HPBD1111@Z PROC NEAR	; ClientPrint, COMDAT

; 1165 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1166 : 	MESSAGE_BEGIN( MSG_ONE, gmsgTextMsg, NULL, client );

	mov	eax, DWORD PTR _client$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gmsgTextMsg@@3HA	; gmsgTextMsg
	push	ecx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1167 : 		WRITE_BYTE( msg_dest );

	mov	edx, DWORD PTR _msg_dest$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1168 : 		WRITE_STRING( msg_name );

	mov	eax, DWORD PTR _msg_name$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 1169 : 
; 1170 : 		if ( param1 )

	cmp	DWORD PTR _param1$[ebp], 0
	je	SHORT $L41186

; 1171 : 			WRITE_STRING( param1 );

	mov	ecx, DWORD PTR _param1$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4
$L41186:

; 1172 : 		if ( param2 )

	cmp	DWORD PTR _param2$[ebp], 0
	je	SHORT $L41187

; 1173 : 			WRITE_STRING( param2 );

	mov	edx, DWORD PTR _param2$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4
$L41187:

; 1174 : 		if ( param3 )

	cmp	DWORD PTR _param3$[ebp], 0
	je	SHORT $L41188

; 1175 : 			WRITE_STRING( param3 );

	mov	eax, DWORD PTR _param3$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4
$L41188:

; 1176 : 		if ( param4 )

	cmp	DWORD PTR _param4$[ebp], 0
	je	SHORT $L41189

; 1177 : 			WRITE_STRING( param4 );

	mov	ecx, DWORD PTR _param4$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4
$L41189:

; 1178 : 
; 1179 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 1180 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClientPrint@@YAXPAUentvars_s@@HPBD1111@Z ENDP		; ClientPrint
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_type$ = 12
_pOrigin$ = 16
_ent$ = 20
?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z PROC NEAR	; MESSAGE_BEGIN, COMDAT

; 188  : inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin, entvars_t *ent ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 189  : 	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ENT(ent));

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+184
	add	esp, 16					; 00000010H

; 190  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ENDP		; MESSAGE_BEGIN
_TEXT	ENDS
PUBLIC	?UTIL_SayText@@YAXPBDPAVCBaseEntity@@@Z		; UTIL_SayText
EXTRN	?gmsgSayText@@3HA:DWORD				; gmsgSayText
;	COMDAT ?UTIL_SayText@@YAXPBDPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pText$ = 8
_pEntity$ = 12
?UTIL_SayText@@YAXPBDPAVCBaseEntity@@@Z PROC NEAR	; UTIL_SayText, COMDAT

; 1183 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1184 : 	if ( !pEntity->IsNetClient() )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+228]
	test	eax, eax
	jne	SHORT $L41194

; 1185 : 		return;

	jmp	SHORT $L41193
$L41194:

; 1186 : 
; 1187 : 	MESSAGE_BEGIN( MSG_ONE, gmsgSayText, NULL, pEntity->edict() );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	mov	eax, DWORD PTR ?gmsgSayText@@3HA	; gmsgSayText
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1188 : 		WRITE_BYTE( pEntity->entindex() );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1189 : 		WRITE_STRING( pText );

	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 1190 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41193:

; 1191 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_SayText@@YAXPBDPAVCBaseEntity@@@Z ENDP		; UTIL_SayText
_TEXT	ENDS
PUBLIC	?UTIL_SayTextAll@@YAXPBDPAVCBaseEntity@@@Z	; UTIL_SayTextAll
;	COMDAT ?UTIL_SayTextAll@@YAXPBDPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pText$ = 8
_pEntity$ = 12
?UTIL_SayTextAll@@YAXPBDPAVCBaseEntity@@@Z PROC NEAR	; UTIL_SayTextAll, COMDAT

; 1194 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1195 : 	MESSAGE_BEGIN( MSG_ALL, gmsgSayText, NULL );

	push	0
	push	0
	mov	eax, DWORD PTR ?gmsgSayText@@3HA	; gmsgSayText
	push	eax
	push	2
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1196 : 		WRITE_BYTE( pEntity->entindex() );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1197 : 		WRITE_STRING( pText );

	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 1198 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 1199 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_SayTextAll@@YAXPBDPAVCBaseEntity@@@Z ENDP		; UTIL_SayTextAll
_TEXT	ENDS
PUBLIC	?UTIL_dtos1@@YAPADH@Z				; UTIL_dtos1
PUBLIC	??_C@_02MECO@?$CFd?$AA@				; `string'
_BSS	SEGMENT
_?buf@?1??UTIL_dtos1@@YAPADH@Z@4PADA DB 08H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_02MECO@?$CFd?$AA@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ?UTIL_dtos1@@YAPADH@Z
_TEXT	SEGMENT
_d$ = 8
?UTIL_dtos1@@YAPADH@Z PROC NEAR				; UTIL_dtos1, COMDAT

; 1203 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1204 : 	static char buf[8];
; 1205 : 	sprintf( buf, "%d", d );

	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	push	OFFSET FLAT:_?buf@?1??UTIL_dtos1@@YAPADH@Z@4PADA
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1206 : 	return buf;

	mov	eax, OFFSET FLAT:_?buf@?1??UTIL_dtos1@@YAPADH@Z@4PADA

; 1207 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_dtos1@@YAPADH@Z ENDP				; UTIL_dtos1
_TEXT	ENDS
PUBLIC	?UTIL_dtos2@@YAPADH@Z				; UTIL_dtos2
_BSS	SEGMENT
_?buf@?1??UTIL_dtos2@@YAPADH@Z@4PADA DB 08H DUP (?)
_BSS	ENDS
;	COMDAT ?UTIL_dtos2@@YAPADH@Z
_TEXT	SEGMENT
_d$ = 8
?UTIL_dtos2@@YAPADH@Z PROC NEAR				; UTIL_dtos2, COMDAT

; 1210 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1211 : 	static char buf[8];
; 1212 : 	sprintf( buf, "%d", d );

	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	push	OFFSET FLAT:_?buf@?1??UTIL_dtos2@@YAPADH@Z@4PADA
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1213 : 	return buf;

	mov	eax, OFFSET FLAT:_?buf@?1??UTIL_dtos2@@YAPADH@Z@4PADA

; 1214 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_dtos2@@YAPADH@Z ENDP				; UTIL_dtos2
_TEXT	ENDS
PUBLIC	?UTIL_dtos3@@YAPADH@Z				; UTIL_dtos3
_BSS	SEGMENT
_?buf@?1??UTIL_dtos3@@YAPADH@Z@4PADA DB 08H DUP (?)
_BSS	ENDS
;	COMDAT ?UTIL_dtos3@@YAPADH@Z
_TEXT	SEGMENT
_d$ = 8
?UTIL_dtos3@@YAPADH@Z PROC NEAR				; UTIL_dtos3, COMDAT

; 1217 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1218 : 	static char buf[8];
; 1219 : 	sprintf( buf, "%d", d );

	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	push	OFFSET FLAT:_?buf@?1??UTIL_dtos3@@YAPADH@Z@4PADA
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1220 : 	return buf;

	mov	eax, OFFSET FLAT:_?buf@?1??UTIL_dtos3@@YAPADH@Z@4PADA

; 1221 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_dtos3@@YAPADH@Z ENDP				; UTIL_dtos3
_TEXT	ENDS
PUBLIC	?UTIL_dtos4@@YAPADH@Z				; UTIL_dtos4
_BSS	SEGMENT
_?buf@?1??UTIL_dtos4@@YAPADH@Z@4PADA DB 08H DUP (?)
_BSS	ENDS
;	COMDAT ?UTIL_dtos4@@YAPADH@Z
_TEXT	SEGMENT
_d$ = 8
?UTIL_dtos4@@YAPADH@Z PROC NEAR				; UTIL_dtos4, COMDAT

; 1224 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1225 : 	static char buf[8];
; 1226 : 	sprintf( buf, "%d", d );

	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	push	OFFSET FLAT:_?buf@?1??UTIL_dtos4@@YAPADH@Z@4PADA
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1227 : 	return buf;

	mov	eax, OFFSET FLAT:_?buf@?1??UTIL_dtos4@@YAPADH@Z@4PADA

; 1228 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_dtos4@@YAPADH@Z ENDP				; UTIL_dtos4
_TEXT	ENDS
PUBLIC	?UTIL_ShowMessage@@YAXPBDPAVCBaseEntity@@@Z	; UTIL_ShowMessage
EXTRN	?gmsgHudText@@3HA:DWORD				; gmsgHudText
;	COMDAT ?UTIL_ShowMessage@@YAXPBDPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pString$ = 8
_pEntity$ = 12
?UTIL_ShowMessage@@YAXPBDPAVCBaseEntity@@@Z PROC NEAR	; UTIL_ShowMessage, COMDAT

; 1231 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1232 : 	if ( !pEntity || !pEntity->IsNetClient() )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L41225
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+228]
	test	eax, eax
	jne	SHORT $L41224
$L41225:

; 1233 : 		return;

	jmp	SHORT $L41223
$L41224:

; 1234 : 
; 1235 : 	MESSAGE_BEGIN( MSG_ONE, gmsgHudText, NULL, pEntity->edict() );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	mov	eax, DWORD PTR ?gmsgHudText@@3HA	; gmsgHudText
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1236 : 	WRITE_STRING( pString );

	mov	ecx, DWORD PTR _pString$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 1237 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41223:

; 1238 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ShowMessage@@YAXPBDPAVCBaseEntity@@@Z ENDP	; UTIL_ShowMessage
_TEXT	ENDS
PUBLIC	?UTIL_ShowMessageAll@@YAXPBD@Z			; UTIL_ShowMessageAll
;	COMDAT ?UTIL_ShowMessageAll@@YAXPBD@Z
_TEXT	SEGMENT
_pString$ = 8
_i$ = -4
_pPlayer$41233 = -8
?UTIL_ShowMessageAll@@YAXPBD@Z PROC NEAR		; UTIL_ShowMessageAll, COMDAT

; 1242 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1243 : 	int		i;
; 1244 : 
; 1245 : 	// loop through all players
; 1246 : 
; 1247 : 	for ( i = 1; i <= gpGlobals->maxClients; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L41230
$L41231:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L41230:
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+144]
	jg	SHORT $L41232

; 1249 : 		CBaseEntity *pPlayer = UTIL_PlayerByIndex( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pPlayer$41233[ebp], eax

; 1250 : 		if ( pPlayer )

	cmp	DWORD PTR _pPlayer$41233[ebp], 0
	je	SHORT $L41234

; 1251 : 			UTIL_ShowMessage( pString, pPlayer );

	mov	ecx, DWORD PTR _pPlayer$41233[ebp]
	push	ecx
	mov	edx, DWORD PTR _pString$[ebp]
	push	edx
	call	?UTIL_ShowMessage@@YAXPBDPAVCBaseEntity@@@Z ; UTIL_ShowMessage
	add	esp, 8
$L41234:

; 1252 : 	}

	jmp	SHORT $L41231
$L41232:

; 1253 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ShowMessageAll@@YAXPBD@Z ENDP			; UTIL_ShowMessageAll
_TEXT	ENDS
PUBLIC	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
;	COMDAT ?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z
_TEXT	SEGMENT
_vecStart$ = 8
_vecEnd$ = 12
_igmon$ = 16
_ignoreGlass$ = 20
_pentIgnore$ = 24
_ptr$ = 28
?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z PROC NEAR ; UTIL_TraceLine, COMDAT

; 1257 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1258 : 	TRACE_LINE( vecStart, vecEnd, (igmon == ignore_monsters ? TRUE : FALSE) | (ignoreGlass?0x100:0), pentIgnore, ptr );

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pentIgnore$[ebp]
	push	ecx
	xor	edx, edx
	cmp	DWORD PTR _igmon$[ebp], 1
	sete	dl
	mov	eax, DWORD PTR _ignoreGlass$[ebp]
	neg	eax
	sbb	eax, eax
	and	eax, 256				; 00000100H
	or	edx, eax
	push	edx
	mov	ecx, DWORD PTR _vecEnd$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _vecStart$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+124
	add	esp, 20					; 00000014H

; 1259 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z ENDP ; UTIL_TraceLine
_TEXT	ENDS
PUBLIC	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
;	COMDAT ?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z
_TEXT	SEGMENT
_vecStart$ = 8
_vecEnd$ = 12
_igmon$ = 16
_pentIgnore$ = 20
_ptr$ = 24
?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z PROC NEAR ; UTIL_TraceLine, COMDAT

; 1263 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1264 : 	TRACE_LINE( vecStart, vecEnd, (igmon == ignore_monsters ? TRUE : FALSE), pentIgnore, ptr );

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pentIgnore$[ebp]
	push	ecx
	xor	edx, edx
	cmp	DWORD PTR _igmon$[ebp], 1
	sete	dl
	push	edx
	mov	ecx, DWORD PTR _vecEnd$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _vecStart$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+124
	add	esp, 20					; 00000014H

; 1265 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ENDP ; UTIL_TraceLine
_TEXT	ENDS
PUBLIC	?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceHull
;	COMDAT ?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z
_TEXT	SEGMENT
_vecStart$ = 8
_vecEnd$ = 12
_igmon$ = 16
_hullNumber$ = 20
_pentIgnore$ = 24
_ptr$ = 28
?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z PROC NEAR ; UTIL_TraceHull, COMDAT

; 1269 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1270 : 	TRACE_HULL( vecStart, vecEnd, (igmon == ignore_monsters ? TRUE : FALSE), hullNumber, pentIgnore, ptr );

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pentIgnore$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hullNumber$[ebp]
	push	edx
	xor	eax, eax
	cmp	DWORD PTR _igmon$[ebp], 1
	sete	al
	push	eax
	mov	ecx, DWORD PTR _vecEnd$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _vecStart$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+136
	add	esp, 24					; 00000018H

; 1271 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z ENDP ; UTIL_TraceHull
_TEXT	ENDS
PUBLIC	?UTIL_TraceModel@@YAXABVVector@@0HPAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceModel
;	COMDAT ?UTIL_TraceModel@@YAXABVVector@@0HPAUedict_s@@PAUgametrace_s@@@Z
_TEXT	SEGMENT
_vecStart$ = 8
_vecEnd$ = 12
_hullNumber$ = 16
_pentModel$ = 20
_ptr$ = 24
?UTIL_TraceModel@@YAXABVVector@@0HPAUedict_s@@PAUgametrace_s@@@Z PROC NEAR ; UTIL_TraceModel, COMDAT

; 1274 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1275 : 	g_engfuncs.pfnTraceModel( vecStart, vecEnd, hullNumber, pentModel, ptr );

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pentModel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hullNumber$[ebp]
	push	edx
	mov	ecx, DWORD PTR _vecEnd$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _vecStart$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+140
	add	esp, 20					; 00000014H

; 1276 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_TraceModel@@YAXABVVector@@0HPAUedict_s@@PAUgametrace_s@@@Z ENDP ; UTIL_TraceModel
_TEXT	ENDS
PUBLIC	?UTIL_TraceEntity@@YAXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z ; UTIL_TraceEntity
EXTRN	?GetRootParent@CBaseEntity@@QAEPAV1@XZ:NEAR	; CBaseEntity::GetRootParent
;	COMDAT ?UTIL_TraceEntity@@YAXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_vecStart$ = 12
_vecEnd$ = 16
_ptr$ = 20
?UTIL_TraceEntity@@YAXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z PROC NEAR ; UTIL_TraceEntity, COMDAT

; 1279 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1280 : 	// setup the improved trace filter (don't collide with entity parent)
; 1281 : 	pEntity->m_pRootParent = pEntity->GetRootParent();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetRootParent@CBaseEntity@@QAEPAV1@XZ	; CBaseEntity::GetRootParent
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1282 : 	pEntity->m_iParentFilter = TRUE;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [edx+32], 1

; 1283 : 
; 1284 : 	if( pEntity->m_iActorType == ACTOR_DYNAMIC || pEntity->m_iActorType == ACTOR_VEHICLE )

	mov	eax, DWORD PTR _pEntity$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	cmp	ecx, 1
	je	SHORT $L41272
	mov	edx, DWORD PTR _pEntity$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+1604]
	cmp	eax, 5
	jne	SHORT $L41271
$L41272:

; 1285 : 		WorldPhysic->SweepEntity( pEntity, vecStart, vecEnd, ptr );

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vecEnd$[ebp]
	push	edx
	mov	eax, DWORD PTR _vecStart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [eax+164]

; 1286 : 	else if( pEntity->pev->movetype == MOVETYPE_FLYMISSILE )

	jmp	$L41278
$L41271:
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 9
	jne	SHORT $L41274

; 1287 : 		TRACE_MONSTER_HULL( pEntity->edict(), vecStart, vecEnd, missile, pEntity->edict(), ptr ); 

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	2
	mov	ecx, DWORD PTR _vecEnd$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _vecStart$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+132
	add	esp, 24					; 00000018H

; 1288 : 	else if( pEntity->pev->solid == SOLID_TRIGGER || pEntity->pev->solid == SOLID_NOT ) // only clip against bmodels

	jmp	$L41278
$L41274:
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 1
	je	SHORT $L41277
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+268], 0
	jne	SHORT $L41276
$L41277:

; 1289 : 		TRACE_MONSTER_HULL( pEntity->edict(), vecStart, vecEnd, ignore_monsters, pEntity->edict(), ptr ); 

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	mov	ecx, DWORD PTR _vecEnd$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _vecStart$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+132
	add	esp, 24					; 00000018H

; 1290 : 	else TRACE_MONSTER_HULL( pEntity->edict(), vecStart, vecEnd, dont_ignore_monsters, pEntity->edict(), ptr );

	jmp	SHORT $L41278
$L41276:
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	mov	ecx, DWORD PTR _vecEnd$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _vecStart$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+132
	add	esp, 24					; 00000018H
$L41278:

; 1291 : 
; 1292 : 	pEntity->m_iParentFilter = FALSE;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 1293 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_TraceEntity@@YAXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z ENDP ; UTIL_TraceEntity
_TEXT	ENDS
PUBLIC	??0gametrace_s@@QAE@XZ				; gametrace_s::gametrace_s
PUBLIC	??0gametrace_s@@QAE@ABU0@@Z			; gametrace_s::gametrace_s
PUBLIC	?UTIL_GetGlobalTrace@@YA?AUgametrace_s@@XZ	; UTIL_GetGlobalTrace
;	COMDAT ?UTIL_GetGlobalTrace@@YA?AUgametrace_s@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_tr$ = -56
?UTIL_GetGlobalTrace@@YA?AUgametrace_s@@XZ PROC NEAR	; UTIL_GetGlobalTrace, COMDAT

; 1296 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi

; 1297 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1298 : 
; 1299 : 	tr.fAllSolid		= gpGlobals->trace_allsolid;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+76]
	call	__ftol
	mov	DWORD PTR _tr$[ebp], eax

; 1300 : 	tr.fStartSolid		= gpGlobals->trace_startsolid;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+80]
	call	__ftol
	mov	DWORD PTR _tr$[ebp+4], eax

; 1301 : 	tr.fInOpen			= gpGlobals->trace_inopen;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx+120]
	call	__ftol
	mov	DWORD PTR _tr$[ebp+8], eax

; 1302 : 	tr.fInWater			= gpGlobals->trace_inwater;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+124]
	call	__ftol
	mov	DWORD PTR _tr$[ebp+12], eax

; 1303 : 	tr.flFraction		= gpGlobals->trace_fraction;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR _tr$[ebp+16], edx

; 1304 : 	tr.flPlaneDist		= gpGlobals->trace_plane_dist;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR _tr$[ebp+32], ecx

; 1305 : 	tr.pHit			= gpGlobals->trace_ent;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR _tr$[ebp+48], eax

; 1306 : 	tr.vecEndPos		= gpGlobals->trace_endpos;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 88					; 00000058H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _tr$[ebp+20], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _tr$[ebp+24], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _tr$[ebp+28], ecx

; 1307 : 	tr.vecPlaneNormal	= gpGlobals->trace_plane_normal;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	edx, 100				; 00000064H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _tr$[ebp+36], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _tr$[ebp+40], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _tr$[ebp+44], edx

; 1308 : 	tr.iHitgroup		= gpGlobals->trace_hitgroup;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _tr$[ebp+52], ecx

; 1309 : 	return tr;

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0gametrace_s@@QAE@ABU0@@Z		; gametrace_s::gametrace_s
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1310 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_GetGlobalTrace@@YA?AUgametrace_s@@XZ ENDP		; UTIL_GetGlobalTrace
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0gametrace_s@@QAE@XZ PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0gametrace_s@@QAE@XZ ENDP				; gametrace_s::gametrace_s
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0gametrace_s@@QAE@ABU0@@Z PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+52], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0gametrace_s@@QAE@ABU0@@Z ENDP			; gametrace_s::gametrace_s
_TEXT	ENDS
PUBLIC	?UTIL_CopyTraceToGlobal@@YAXPAUgametrace_s@@@Z	; UTIL_CopyTraceToGlobal
;	COMDAT ?UTIL_CopyTraceToGlobal@@YAXPAUgametrace_s@@@Z
_TEXT	SEGMENT
_trace$ = 8
?UTIL_CopyTraceToGlobal@@YAXPAUgametrace_s@@@Z PROC NEAR ; UTIL_CopyTraceToGlobal, COMDAT

; 1320 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1321 : 	gpGlobals->trace_allsolid = trace->fAllSolid;

	mov	eax, DWORD PTR _trace$[ebp]
	fild	DWORD PTR [eax]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fstp	DWORD PTR [ecx+76]

; 1322 : 	gpGlobals->trace_startsolid = trace->fStartSolid;

	mov	edx, DWORD PTR _trace$[ebp]
	fild	DWORD PTR [edx+4]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fstp	DWORD PTR [eax+80]

; 1323 : 	gpGlobals->trace_fraction = trace->flFraction;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+84], eax

; 1324 : 	gpGlobals->trace_plane_dist = trace->flPlaneDist;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+112], eax

; 1325 : 	gpGlobals->trace_inopen = trace->fInOpen;

	mov	ecx, DWORD PTR _trace$[ebp]
	fild	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fstp	DWORD PTR [edx+120]

; 1326 : 	gpGlobals->trace_inwater = trace->fInWater;

	mov	eax, DWORD PTR _trace$[ebp]
	fild	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fstp	DWORD PTR [ecx+124]

; 1327 : 	gpGlobals->trace_endpos = trace->vecEndPos;

	mov	edx, DWORD PTR _trace$[ebp]
	add	edx, 20					; 00000014H
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	eax, 88					; 00000058H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 1328 : 	gpGlobals->trace_plane_normal = trace->vecPlaneNormal;

	mov	eax, DWORD PTR _trace$[ebp]
	add	eax, 36					; 00000024H
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 100				; 00000064H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1329 : 	gpGlobals->trace_hitgroup = trace->iHitgroup;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+128], eax

; 1330 : 	gpGlobals->trace_flags = 0;	// clear trace flags

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	DWORD PTR [ecx+132], 0

; 1331 : 
; 1332 : 	if( !FNullEnt( trace->pHit ))

	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41291

; 1333 : 		gpGlobals->trace_ent = trace->pHit;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+116], eax

; 1334 : 	else gpGlobals->trace_ent = ENT(0); // world

	jmp	SHORT $L41292
$L41291:
	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	DWORD PTR [ecx+116], eax
$L41292:

; 1335 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_CopyTraceToGlobal@@YAXPAUgametrace_s@@@Z ENDP	; UTIL_CopyTraceToGlobal
_TEXT	ENDS
PUBLIC	?UTIL_CopyTraceToGlobal@@YAXPAUtrace_s@@@Z	; UTIL_CopyTraceToGlobal
;	COMDAT ?UTIL_CopyTraceToGlobal@@YAXPAUtrace_s@@@Z
_TEXT	SEGMENT
_trace$ = 8
?UTIL_CopyTraceToGlobal@@YAXPAUtrace_s@@@Z PROC NEAR	; UTIL_CopyTraceToGlobal, COMDAT

; 1338 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1339 : 	gpGlobals->trace_allsolid = trace->allsolid;

	mov	eax, DWORD PTR _trace$[ebp]
	fild	DWORD PTR [eax]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fstp	DWORD PTR [ecx+76]

; 1340 : 	gpGlobals->trace_startsolid = trace->startsolid;

	mov	edx, DWORD PTR _trace$[ebp]
	fild	DWORD PTR [edx+4]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fstp	DWORD PTR [eax+80]

; 1341 : 	gpGlobals->trace_fraction = trace->fraction;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+84], eax

; 1342 : 	gpGlobals->trace_plane_dist = trace->plane.dist;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+112], eax

; 1343 : 	gpGlobals->trace_inopen = trace->inopen;

	mov	ecx, DWORD PTR _trace$[ebp]
	fild	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fstp	DWORD PTR [edx+120]

; 1344 : 	gpGlobals->trace_inwater = trace->inwater;

	mov	eax, DWORD PTR _trace$[ebp]
	fild	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fstp	DWORD PTR [ecx+124]

; 1345 : 	gpGlobals->trace_endpos = trace->endpos;

	mov	edx, DWORD PTR _trace$[ebp]
	add	edx, 20					; 00000014H
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	eax, 88					; 00000058H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 1346 : 	gpGlobals->trace_plane_normal = trace->plane.normal;

	mov	eax, DWORD PTR _trace$[ebp]
	add	eax, 32					; 00000020H
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 100				; 00000064H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1347 : 	gpGlobals->trace_hitgroup = trace->hitgroup;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+128], eax

; 1348 : 	gpGlobals->trace_flags = 0;	// clear trace flags

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	DWORD PTR [ecx+132], 0

; 1349 : 
; 1350 : 	if( !FNullEnt( trace->ent ))

	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41297

; 1351 : 		gpGlobals->trace_ent = trace->ent;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+116], eax

; 1352 : 	else gpGlobals->trace_ent = ENT(0); // world

	jmp	SHORT $L41298
$L41297:
	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	DWORD PTR [ecx+116], eax
$L41298:

; 1353 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_CopyTraceToGlobal@@YAXPAUtrace_s@@@Z ENDP		; UTIL_CopyTraceToGlobal
_TEXT	ENDS
PUBLIC	?UTIL_ConvertTrace@@YAXPAUgametrace_s@@PAUtrace_s@@@Z ; UTIL_ConvertTrace
;	COMDAT ?UTIL_ConvertTrace@@YAXPAUgametrace_s@@PAUtrace_s@@@Z
_TEXT	SEGMENT
_dst$ = 8
_src$ = 12
?UTIL_ConvertTrace@@YAXPAUgametrace_s@@PAUtrace_s@@@Z PROC NEAR ; UTIL_ConvertTrace, COMDAT

; 1363 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1364 : 	dst->fAllSolid = src->allsolid;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1365 : 	dst->fStartSolid = src->startsolid;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1366 : 	dst->fInOpen = src->inopen;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 1367 : 	dst->fInWater = src->inwater;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 1368 : 	dst->flFraction = src->fraction;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 1369 : 	dst->vecEndPos = src->endpos;

	mov	eax, DWORD PTR _src$[ebp]
	add	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _dst$[ebp]
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1370 : 	dst->flPlaneDist = src->plane.dist;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+32], eax

; 1371 : 	dst->vecPlaneNormal = src->plane.normal;

	mov	ecx, DWORD PTR _src$[ebp]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _dst$[ebp]
	add	edx, 36					; 00000024H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 1372 : 	dst->pHit = src->ent;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx

; 1373 : 	dst->iHitgroup = src->hitgroup;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+52], ecx

; 1374 : 
; 1375 : 	// reset trace flags
; 1376 : 	gpGlobals->trace_flags = 0;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	DWORD PTR [edx+132], 0

; 1377 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ConvertTrace@@YAXPAUgametrace_s@@PAUtrace_s@@@Z ENDP ; UTIL_ConvertTrace
_TEXT	ENDS
PUBLIC	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z	; UTIL_SetSize
;	COMDAT ?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z
_TEXT	SEGMENT
_pev$ = 8
_vecMin$ = 12
_vecMax$ = 16
?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z PROC NEAR ; UTIL_SetSize, COMDAT

; 1380 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1381 : 	SET_SIZE( ENT(pev), vecMin, vecMax );

	mov	ecx, DWORD PTR _vecMax$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _vecMin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+20
	add	esp, 12					; 0000000cH

; 1382 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ENDP	; UTIL_SetSize
_TEXT	ENDS
PUBLIC	?UTIL_VecToYaw@@YAMABVVector@@@Z		; UTIL_VecToYaw
;	COMDAT ?UTIL_VecToYaw@@YAMABVVector@@@Z
_TEXT	SEGMENT
_vec$ = 8
?UTIL_VecToYaw@@YAMABVVector@@@Z PROC NEAR		; UTIL_VecToYaw, COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1386 : 	return VEC_TO_YAW(vec);

	mov	ecx, DWORD PTR _vec$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+36
	add	esp, 4

; 1387 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_VecToYaw@@YAMABVVector@@@Z ENDP			; UTIL_VecToYaw
_TEXT	ENDS
EXTRN	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalOrigin
;	COMDAT ?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_vecOrigin$ = 12
?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z PROC NEAR ; UTIL_SetOrigin, COMDAT

; 1390 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1391 : 	pEntity->SetLocalOrigin( vecOrigin );

	mov	eax, DWORD PTR _vecOrigin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalOrigin

; 1392 : 	pEntity->RelinkEntity( TRUE );

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 1393 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ENDP	; UTIL_SetOrigin
_TEXT	ENDS
PUBLIC	?UTIL_SetAngles@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetAngles
;	COMDAT ?UTIL_SetAngles@@YAXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_vecAngles$ = 12
?UTIL_SetAngles@@YAXPAVCBaseEntity@@ABVVector@@@Z PROC NEAR ; UTIL_SetAngles, COMDAT

; 1396 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1397 : 	pEntity->SetLocalAngles( vecAngles );

	mov	eax, DWORD PTR _vecAngles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 1398 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_SetAngles@@YAXPAVCBaseEntity@@ABVVector@@@Z ENDP	; UTIL_SetAngles
_TEXT	ENDS
PUBLIC	?UTIL_ParticleEffect@@YAXABVVector@@0KK@Z	; UTIL_ParticleEffect
;	COMDAT ?UTIL_ParticleEffect@@YAXABVVector@@0KK@Z
_TEXT	SEGMENT
_vecOrigin$ = 8
_vecDirection$ = 12
_ulColor$ = 16
_ulCount$ = 20
?UTIL_ParticleEffect@@YAXABVVector@@0KK@Z PROC NEAR	; UTIL_ParticleEffect, COMDAT

; 1401 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1402 : 	PARTICLE_EFFECT( vecOrigin, vecDirection, (float)ulColor, (float)ulCount );

	mov	eax, DWORD PTR _ulCount$[ebp]
	mov	DWORD PTR -8+[ebp], eax
	mov	DWORD PTR -8+[ebp+4], 0
	fild	QWORD PTR -8+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _ulColor$[ebp]
	mov	DWORD PTR -16+[ebp], ecx
	mov	DWORD PTR -16+[ebp+4], 0
	fild	QWORD PTR -16+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _vecDirection$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _vecOrigin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+168
	add	esp, 16					; 00000010H

; 1403 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ParticleEffect@@YAXABVVector@@0KK@Z ENDP		; UTIL_ParticleEffect
_TEXT	ENDS
PUBLIC	?UTIL_Approach@@YAMMMM@Z			; UTIL_Approach
;	COMDAT ?UTIL_Approach@@YAMMMM@Z
_TEXT	SEGMENT
_target$ = 8
_value$ = 12
_speed$ = 16
_delta$ = -4
?UTIL_Approach@@YAMMMM@Z PROC NEAR			; UTIL_Approach, COMDAT

; 1407 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1408 : 	float delta = target - value;

	fld	DWORD PTR _target$[ebp]
	fsub	DWORD PTR _value$[ebp]
	fstp	DWORD PTR _delta$[ebp]

; 1409 : 
; 1410 : 	if ( delta > speed )

	fld	DWORD PTR _delta$[ebp]
	fcomp	DWORD PTR _speed$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41333

; 1411 : 		value += speed;

	fld	DWORD PTR _value$[ebp]
	fadd	DWORD PTR _speed$[ebp]
	fstp	DWORD PTR _value$[ebp]

; 1412 : 	else if ( delta < -speed )

	jmp	SHORT $L41336
$L41333:
	fld	DWORD PTR _speed$[ebp]
	fchs
	fcomp	DWORD PTR _delta$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41335

; 1413 : 		value -= speed;

	fld	DWORD PTR _value$[ebp]
	fsub	DWORD PTR _speed$[ebp]
	fstp	DWORD PTR _value$[ebp]

; 1414 : 	else 

	jmp	SHORT $L41336
$L41335:

; 1415 : 		value = target;

	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR _value$[ebp], eax
$L41336:

; 1416 : 
; 1417 : 	return value;

	fld	DWORD PTR _value$[ebp]

; 1418 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_Approach@@YAMMMM@Z ENDP				; UTIL_Approach
_TEXT	ENDS
PUBLIC	?UTIL_ApproachAngle@@YAMMMM@Z			; UTIL_ApproachAngle
;	COMDAT ?UTIL_ApproachAngle@@YAMMMM@Z
_TEXT	SEGMENT
_target$ = 8
_value$ = 12
_speed$ = 16
_delta$ = -4
?UTIL_ApproachAngle@@YAMMMM@Z PROC NEAR			; UTIL_ApproachAngle, COMDAT

; 1422 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1423 : 	target = UTIL_AngleMod( target );

	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	call	?UTIL_AngleMod@@YAMM@Z			; UTIL_AngleMod
	add	esp, 4
	fstp	DWORD PTR _target$[ebp]

; 1424 : 	value = UTIL_AngleMod( target );

	mov	ecx, DWORD PTR _target$[ebp]
	push	ecx
	call	?UTIL_AngleMod@@YAMM@Z			; UTIL_AngleMod
	add	esp, 4
	fstp	DWORD PTR _value$[ebp]

; 1425 : 	
; 1426 : 	float delta = target - value;

	fld	DWORD PTR _target$[ebp]
	fsub	DWORD PTR _value$[ebp]
	fstp	DWORD PTR _delta$[ebp]

; 1427 : 
; 1428 : 	// Speed is assumed to be positive
; 1429 : 	if ( speed < 0 )

	fld	DWORD PTR _speed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41343

; 1430 : 		speed = -speed;

	fld	DWORD PTR _speed$[ebp]
	fchs
	fstp	DWORD PTR _speed$[ebp]
$L41343:

; 1431 : 
; 1432 : 	if ( delta < -180 )

	fld	DWORD PTR _delta$[ebp]
	fcomp	DWORD PTR __real@4@c006b400000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41344

; 1433 : 		delta += 360;

	fld	DWORD PTR _delta$[ebp]
	fadd	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _delta$[ebp]

; 1434 : 	else if ( delta > 180 )

	jmp	SHORT $L41346
$L41344:
	fld	DWORD PTR _delta$[ebp]
	fcomp	DWORD PTR __real@4@4006b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41346

; 1435 : 		delta -= 360;

	fld	DWORD PTR _delta$[ebp]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _delta$[ebp]
$L41346:

; 1436 : 
; 1437 : 	if ( delta > speed )

	fld	DWORD PTR _delta$[ebp]
	fcomp	DWORD PTR _speed$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41347

; 1438 : 		value += speed;

	fld	DWORD PTR _value$[ebp]
	fadd	DWORD PTR _speed$[ebp]
	fstp	DWORD PTR _value$[ebp]

; 1439 : 	else if ( delta < -speed )

	jmp	SHORT $L41350
$L41347:
	fld	DWORD PTR _speed$[ebp]
	fchs
	fcomp	DWORD PTR _delta$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41349

; 1440 : 		value -= speed;

	fld	DWORD PTR _value$[ebp]
	fsub	DWORD PTR _speed$[ebp]
	fstp	DWORD PTR _value$[ebp]

; 1441 : 	else 

	jmp	SHORT $L41350
$L41349:

; 1442 : 		value = target;

	mov	edx, DWORD PTR _target$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$L41350:

; 1443 : 
; 1444 : 	return value;

	fld	DWORD PTR _value$[ebp]

; 1445 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ApproachAngle@@YAMMMM@Z ENDP			; UTIL_ApproachAngle
_TEXT	ENDS
PUBLIC	?UTIL_AngleDistance@@YAMMM@Z			; UTIL_AngleDistance
;	COMDAT ?UTIL_AngleDistance@@YAMMM@Z
_TEXT	SEGMENT
_next$ = 8
_cur$ = 12
_delta$ = -4
?UTIL_AngleDistance@@YAMMM@Z PROC NEAR			; UTIL_AngleDistance, COMDAT

; 1449 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1450 : 	float delta = next - cur;

	fld	DWORD PTR _next$[ebp]
	fsub	DWORD PTR _cur$[ebp]
	fstp	DWORD PTR _delta$[ebp]

; 1451 : 
; 1452 : 	if ( delta < -180 )

	fld	DWORD PTR _delta$[ebp]
	fcomp	DWORD PTR __real@4@c006b400000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41356

; 1453 : 		delta += 360;

	fld	DWORD PTR _delta$[ebp]
	fadd	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _delta$[ebp]

; 1454 : 	else if ( delta > 180 )

	jmp	SHORT $L41358
$L41356:
	fld	DWORD PTR _delta$[ebp]
	fcomp	DWORD PTR __real@4@4006b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41358

; 1455 : 		delta -= 360;

	fld	DWORD PTR _delta$[ebp]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _delta$[ebp]
$L41358:

; 1456 : 
; 1457 : 	return delta;

	fld	DWORD PTR _delta$[ebp]

; 1458 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_AngleDistance@@YAMMM@Z ENDP			; UTIL_AngleDistance
_TEXT	ENDS
PUBLIC	?UTIL_SplineFraction@@YAMMM@Z			; UTIL_SplineFraction
PUBLIC	__real@4@4000c000000000000000
PUBLIC	__real@4@40008000000000000000
;	COMDAT __real@4@4000c000000000000000
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
__real@4@4000c000000000000000 DD 040400000r	; 3
CONST	ENDS
;	COMDAT __real@4@40008000000000000000
CONST	SEGMENT
__real@4@40008000000000000000 DD 040000000r	; 2
CONST	ENDS
;	COMDAT ?UTIL_SplineFraction@@YAMMM@Z
_TEXT	SEGMENT
_value$ = 8
_scale$ = 12
_valueSquared$ = -4
?UTIL_SplineFraction@@YAMMM@Z PROC NEAR			; UTIL_SplineFraction, COMDAT

; 1462 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1463 : 	value = scale * value;

	fld	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR _value$[ebp]
	fst	DWORD PTR _value$[ebp]

; 1464 : 	float valueSquared = value * value;

	fmul	DWORD PTR _value$[ebp]
	fstp	DWORD PTR _valueSquared$[ebp]

; 1465 : 
; 1466 : 	// Nice little ease-in, ease-out spline-like curve
; 1467 : 	return 3 * valueSquared - 2 * valueSquared * value;

	fld	DWORD PTR __real@4@4000c000000000000000
	fmul	DWORD PTR _valueSquared$[ebp]
	fld	DWORD PTR __real@4@40008000000000000000
	fmul	DWORD PTR _valueSquared$[ebp]
	fmul	DWORD PTR _value$[ebp]
	fsubp	ST(1), ST(0)

; 1468 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_SplineFraction@@YAMMM@Z ENDP			; UTIL_SplineFraction
_TEXT	ENDS
PUBLIC	?UTIL_VarArgs@@YAPADPADZZ			; UTIL_VarArgs
EXTRN	_vsprintf:NEAR
_BSS	SEGMENT
_?string@?1??UTIL_VarArgs@@YAPADPADZZ@4PADA DB 0400H DUP (?)
_BSS	ENDS
;	COMDAT ?UTIL_VarArgs@@YAPADPADZZ
_TEXT	SEGMENT
_format$ = 8
_argptr$ = -4
?UTIL_VarArgs@@YAPADPADZZ PROC NEAR			; UTIL_VarArgs, COMDAT

; 1472 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1473 : 	va_list		argptr;
; 1474 : 	static char		string[1024];
; 1475 : 	
; 1476 : 	va_start (argptr, format);

	lea	eax, DWORD PTR _format$[ebp+4]
	mov	DWORD PTR _argptr$[ebp], eax

; 1477 : 	vsprintf (string, format,argptr);

	mov	ecx, DWORD PTR _argptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	push	edx
	push	OFFSET FLAT:_?string@?1??UTIL_VarArgs@@YAPADPADZZ@4PADA
	call	_vsprintf
	add	esp, 12					; 0000000cH

; 1478 : 	va_end (argptr);

	mov	DWORD PTR _argptr$[ebp], 0

; 1479 : 
; 1480 : 	return string;	

	mov	eax, OFFSET FLAT:_?string@?1??UTIL_VarArgs@@YAPADPADZZ@4PADA

; 1481 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_VarArgs@@YAPADPADZZ ENDP				; UTIL_VarArgs
_TEXT	ENDS
PUBLIC	?UTIL_GetAimVector@@YA?AVVector@@PAUedict_s@@M@Z ; UTIL_GetAimVector
;	COMDAT ?UTIL_GetAimVector@@YA?AVVector@@PAUedict_s@@M@Z
_TEXT	SEGMENT
_pent$ = 12
_flSpeed$ = 16
___$ReturnUdt$ = 8
_tmp$ = -12
?UTIL_GetAimVector@@YA?AVVector@@PAUedict_s@@M@Z PROC NEAR ; UTIL_GetAimVector, COMDAT

; 1484 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1485 : 	Vector tmp;

	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1486 : 	GET_AIM_VECTOR(pent, flSpeed, tmp);

	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	eax, DWORD PTR _flSpeed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+152
	add	esp, 12					; 0000000cH

; 1487 : 	return tmp;

	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1488 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_GetAimVector@@YA?AVVector@@PAUedict_s@@M@Z ENDP	; UTIL_GetAimVector
_TEXT	ENDS
PUBLIC	?UTIL_IsMasterTriggered@@YAHHPAVCBaseEntity@@@Z	; UTIL_IsMasterTriggered
PUBLIC	??_C@_0BM@MKOH@Missing?5?8?$CJ?8?5in?5master?5?$CC?$CFs?$CC?6?$AA@ ; `string'
EXTRN	?Q_strncpy@@YAIPADPBDI@Z:NEAR			; Q_strncpy
;	COMDAT ??_C@_0BM@MKOH@Missing?5?8?$CJ?8?5in?5master?5?$CC?$CFs?$CC?6?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0BM@MKOH@Missing?5?8?$CJ?8?5in?5master?5?$CC?$CFs?$CC?6?$AA@ DB 'Mi'
	DB	'ssing '')'' in master "%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?UTIL_IsMasterTriggered@@YAHHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_sMaster$ = 8
_pActivator$ = 12
_szMaster$ = -4
_pMaster$ = -8
_pOldMaster$ = -12
_i$ = -16
_j$ = -20
_numMasters$ = -24
_MASTER_STATE$ = -28
_szBuf$ = -156
_reverse$41397 = -160
_found$41398 = -164
?UTIL_IsMasterTriggered@@YAHHPAVCBaseEntity@@@Z PROC NEAR ; UTIL_IsMasterTriggered, COMDAT

; 1491 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi

; 1492 : 	const char *szMaster;
; 1493 : 	CBaseEntity *pMaster, *pOldMaster;
; 1494 : 	int i, j, numMasters = 0;

	mov	DWORD PTR _numMasters$[ebp], 0

; 1495 : 	int MASTER_STATE = 1;

	mov	DWORD PTR _MASTER_STATE$[ebp], 1

; 1496 : 	char szBuf[128];
; 1497 : 
; 1498 : 	if( sMaster )

	cmp	DWORD PTR _sMaster$[ebp], 0
	je	$L41396

; 1500 : //		ALERT( at_console, "IsMasterTriggered(%s, %s \"%s\")\n", STRING( sMaster ), pActivator->GetClassname(), pActivator->GetTargetname());
; 1501 : 
; 1502 : 		pMaster = NULL;

	mov	DWORD PTR _pMaster$[ebp], 0
$L41394:

; 1505 : 			int reverse = false;

	mov	DWORD PTR _reverse$41397[ebp], 0

; 1506 : 			int found = false;

	mov	DWORD PTR _found$41398[ebp], 0

; 1507 : 
; 1508 : 			szMaster = STRING( sMaster );

	mov	eax, DWORD PTR _sMaster$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _szMaster$[ebp], eax

; 1509 : 			if( szMaster[0] == '~' ) // inverse master

	mov	ecx, DWORD PTR _szMaster$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 126				; 0000007eH
	jne	SHORT $L41399

; 1511 : 				reverse = true;

	mov	DWORD PTR _reverse$41397[ebp], 1

; 1512 : 				szMaster++;

	mov	eax, DWORD PTR _szMaster$[ebp]
	add	eax, 1
	mov	DWORD PTR _szMaster$[ebp], eax
$L41399:

; 1514 : 
; 1515 : 			pOldMaster = pMaster;

	mov	ecx, DWORD PTR _pMaster$[ebp]
	mov	DWORD PTR _pOldMaster$[ebp], ecx

; 1516 : 			pMaster = UTIL_FindEntityByTargetname( pMaster, szMaster );

	mov	edx, DWORD PTR _szMaster$[ebp]
	push	edx
	mov	eax, DWORD PTR _pMaster$[ebp]
	push	eax
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pMaster$[ebp], eax

; 1517 : 
; 1518 : 			if( !pMaster )

	cmp	DWORD PTR _pMaster$[ebp], 0
	jne	$L41400

; 1520 : 				for( i = 0; szMaster[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L41401
$L41402:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L41401:
	mov	edx, DWORD PTR _szMaster$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$L41403

; 1522 : 					if( szMaster[i] == '(' )

	mov	ecx, DWORD PTR _szMaster$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 40					; 00000028H
	jne	$L41404

; 1524 : 						for( j = i+1; szMaster[j]; j++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L41405
$L41406:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L41405:
	mov	edx, DWORD PTR _szMaster$[ebp]
	add	edx, DWORD PTR _j$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L41407

; 1526 : 							if( szMaster[j] == ')' )

	mov	ecx, DWORD PTR _szMaster$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	jne	SHORT $L41408

; 1528 : 								Q_strncpy( szBuf, szMaster + i + 1, (j - i) - 1 );

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _szMaster$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	push	eax
	lea	ecx, DWORD PTR _szBuf$[ebp]
	push	ecx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1529 : 								szBuf[(j-i)-1] = 0;

	mov	edx, DWORD PTR _j$[ebp]
	sub	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _szBuf$[ebp+edx-1], 0

; 1530 : 								pActivator = UTIL_FindEntityByTargetname( NULL, szBuf );

	lea	eax, DWORD PTR _szBuf$[ebp]
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pActivator$[ebp], eax

; 1531 : 								found = true;

	mov	DWORD PTR _found$41398[ebp], 1

; 1532 : 								break;

	jmp	SHORT $L41407
$L41408:

; 1534 : 						}

	jmp	SHORT $L41406
$L41407:

; 1535 : 
; 1536 : 						if( !found )

	cmp	DWORD PTR _found$41398[ebp], 0
	jne	SHORT $L41409

; 1538 : 							ALERT( at_error, "Missing ')' in master \"%s\"\n", szMaster );

	mov	ecx, DWORD PTR _szMaster$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BM@MKOH@Missing?5?8?$CJ?8?5in?5master?5?$CC?$CFs?$CC?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1539 : 							return FALSE;

	xor	eax, eax
	jmp	$L41384
$L41409:

; 1541 : 						break;

	jmp	SHORT $L41403
$L41404:

; 1543 : 				}

	jmp	$L41402
$L41403:

; 1544 : 
; 1545 : 				if( !found && !numMasters ) // no ( found

	cmp	DWORD PTR _found$41398[ebp], 0
	jne	SHORT $L41411
	cmp	DWORD PTR _numMasters$[ebp], 0
	jne	SHORT $L41411

; 1547 : 					return TRUE;

	mov	eax, 1
	jmp	$L41384
$L41411:

; 1549 : 
; 1550 : 				Q_strncpy( szBuf, szMaster, i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _szMaster$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szBuf$[ebp]
	push	ecx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1551 : 				szBuf[i] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _szBuf$[ebp+edx], 0

; 1552 : 				pMaster = UTIL_FindEntityByTargetname( pOldMaster, szBuf );

	lea	eax, DWORD PTR _szBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOldMaster$[ebp]
	push	ecx
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pMaster$[ebp], eax
$L41400:

; 1554 : 
; 1555 : 			if( pMaster )

	cmp	DWORD PTR _pMaster$[ebp], 0
	je	SHORT $L41412

; 1557 : 				// some entities can't be used as masters
; 1558 : 				if( pMaster->ObjectCaps() & FCAP_NOT_MASTER )

	mov	edx, DWORD PTR _pMaster$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pMaster$[ebp]
	call	DWORD PTR [eax+24]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $L41413

; 1559 : 					continue;

	jmp	SHORT $L41412
$L41413:

; 1560 :  
; 1561 : 				if( pMaster->GetState( pActivator ) == STATE_ON )

	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMaster$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pMaster$[ebp]
	call	DWORD PTR [eax+84]
	cmp	eax, 1
	jne	SHORT $L41414

; 1563 : 					if( reverse )

	cmp	DWORD PTR _reverse$41397[ebp], 0
	je	SHORT $L41415

; 1564 : 						return FALSE;

	xor	eax, eax
	jmp	SHORT $L41384
$L41415:

; 1566 : 				else

	jmp	SHORT $L41417
$L41414:

; 1568 : 					if( !reverse )

	cmp	DWORD PTR _reverse$41397[ebp], 0
	jne	SHORT $L41417

; 1569 : 						return FALSE;

	xor	eax, eax
	jmp	SHORT $L41384
$L41417:

; 1571 : 				numMasters++;

	mov	ecx, DWORD PTR _numMasters$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numMasters$[ebp], ecx
$L41412:

; 1573 : 
; 1574 : 		} while( pMaster != NULL );

	cmp	DWORD PTR _pMaster$[ebp], 0
	jne	$L41394
$L41396:

; 1576 : 
; 1577 : 	// if the entity has no master (or the master is missing), just say yes.
; 1578 : 	return TRUE;

	mov	eax, 1
$L41384:

; 1579 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_IsMasterTriggered@@YAHHPAVCBaseEntity@@@Z ENDP	; UTIL_IsMasterTriggered
_TEXT	ENDS
PUBLIC	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
PUBLIC	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
;	COMDAT ?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_targetName$ = 8
_pActivator$ = 12
_pCaller$ = 16
_useType$ = 20
_value$ = 24
?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; UTIL_FireTargets, COMDAT

; 1586 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1587 : 	if( targetName != NULL_STRING )

	cmp	DWORD PTR _targetName$[ebp], 0
	je	SHORT $L41425

; 1588 : 		UTIL_FireTargets( STRING( targetName ), pActivator, pCaller, useType, value );	

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _useType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCaller$[ebp]
	push	edx
	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _targetName$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L41425:

; 1589 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; UTIL_FireTargets
_TEXT	ENDS
PUBLIC	??_C@_0BO@OIPF@Missing?5?8?$CJ?8?5in?5targetname?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CD@CLIA@Firing?3?5?$CI?$CFs?$CJ?5with?5?$CFs?5and?5value?5?$CF@ ; `string'
PUBLIC	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z		; UTIL_Remove
EXTRN	?Q_atof@@YAMPBD@Z:NEAR				; Q_atof
;	COMDAT ??_C@_0BO@OIPF@Missing?5?8?$CJ?8?5in?5targetname?3?5?$CFs?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0BO@OIPF@Missing?5?8?$CJ?8?5in?5targetname?3?5?$CFs?$AA@ DB 'Missin'
	DB	'g '')'' in targetname: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CLIA@Firing?3?5?$CI?$CFs?$CJ?5with?5?$CFs?5and?5value?5?$CF@
CONST	SEGMENT
??_C@_0CD@CLIA@Firing?3?5?$CI?$CFs?$CJ?5with?5?$CFs?5and?5value?5?$CF@ DB 'F'
	DB	'iring: (%s) with %s and value %g', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_targetName$ = 8
_pActivator$ = 12
_pCaller$ = 16
_useType$ = 20
_value$ = 24
_inputTargetName$ = -4
_inputActivator$ = -8
_pTarget$ = -12
_i$ = -16
_j$ = -20
_found$ = -24
_szBuf$ = -152
?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z PROC NEAR ; UTIL_FireTargets, COMDAT

; 1592 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi

; 1593 : 	const char *inputTargetName = targetName;

	mov	eax, DWORD PTR _targetName$[ebp]
	mov	DWORD PTR _inputTargetName$[ebp], eax

; 1594 : 	CBaseEntity *inputActivator = pActivator;

	mov	ecx, DWORD PTR _pActivator$[ebp]
	mov	DWORD PTR _inputActivator$[ebp], ecx

; 1595 : 	CBaseEntity *pTarget = NULL;

	mov	DWORD PTR _pTarget$[ebp], 0

; 1596 : 	int i, j, found = false;

	mov	DWORD PTR _found$[ebp], 0

; 1597 : 	char szBuf[128];
; 1598 : 
; 1599 : 	if( !targetName || !*targetName )

	cmp	DWORD PTR _targetName$[ebp], 0
	je	SHORT $L41441
	mov	edx, DWORD PTR _targetName$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $L41440
$L41441:

; 1600 : 		return;

	jmp	$L41432
$L41440:

; 1601 : 	
; 1602 : 	if( targetName[0] == '+' )

	mov	ecx, DWORD PTR _targetName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	jne	SHORT $L41442

; 1604 : 		targetName++;

	mov	eax, DWORD PTR _targetName$[ebp]
	add	eax, 1
	mov	DWORD PTR _targetName$[ebp], eax

; 1605 : 		useType = USE_ON;

	mov	DWORD PTR _useType$[ebp], 1

; 1607 : 	else if( targetName[0] == '-' )

	jmp	SHORT $L41450
$L41442:
	mov	ecx, DWORD PTR _targetName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $L41444

; 1609 : 		targetName++;

	mov	eax, DWORD PTR _targetName$[ebp]
	add	eax, 1
	mov	DWORD PTR _targetName$[ebp], eax

; 1610 : 		useType = USE_OFF;

	mov	DWORD PTR _useType$[ebp], 0

; 1612 :  	else if( targetName[0] == '<' )

	jmp	SHORT $L41450
$L41444:
	mov	ecx, DWORD PTR _targetName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 60					; 0000003cH
	jne	SHORT $L41446

; 1614 : 		targetName++;

	mov	eax, DWORD PTR _targetName$[ebp]
	add	eax, 1
	mov	DWORD PTR _targetName$[ebp], eax

; 1615 : 		useType = USE_SET;

	mov	DWORD PTR _useType$[ebp], 2

; 1617 : 	else if( targetName[0] == '>' )

	jmp	SHORT $L41450
$L41446:
	mov	ecx, DWORD PTR _targetName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	jne	SHORT $L41448

; 1619 : 		targetName++;

	mov	eax, DWORD PTR _targetName$[ebp]
	add	eax, 1
	mov	DWORD PTR _targetName$[ebp], eax

; 1620 : 		useType = USE_RESET;

	mov	DWORD PTR _useType$[ebp], 4

; 1622 : 	else if( targetName[0] == '!' )

	jmp	SHORT $L41450
$L41448:
	mov	ecx, DWORD PTR _targetName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 33					; 00000021H
	jne	SHORT $L41450

; 1624 : 		targetName++;

	mov	eax, DWORD PTR _targetName$[ebp]
	add	eax, 1
	mov	DWORD PTR _targetName$[ebp], eax

; 1625 : 		useType = USE_REMOVE;

	mov	DWORD PTR _useType$[ebp], 5
$L41450:

; 1627 : 
; 1628 : 	pTarget = UTIL_FindEntityByTargetname( pTarget, targetName, pActivator );

	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	edx, DWORD PTR _targetName$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD0@Z ; UTIL_FindEntityByTargetname
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTarget$[ebp], eax

; 1629 : 
; 1630 : 	// smart field name?
; 1631 : 	if( !pTarget )

	cmp	DWORD PTR _pTarget$[ebp], 0
	jne	$L41469

; 1633 : 		// try to extract value from name (it's more usefully than "locus" specifier)
; 1634 : 		for( i = 0; targetName[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L41452
$L41453:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L41452:
	mov	edx, DWORD PTR _targetName$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L41454

; 1636 : 			if( targetName[i] == '.' )

	mov	ecx, DWORD PTR _targetName$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $L41455

; 1638 : 				// value specifier
; 1639 : 				value = Q_atof( &targetName[i+1] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _targetName$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	fstp	DWORD PTR _value$[ebp]

; 1640 : 				Q_strncpy( szBuf, targetName, sizeof( szBuf ));

	push	128					; 00000080H
	mov	eax, DWORD PTR _targetName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szBuf$[ebp]
	push	ecx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1641 : 				szBuf[i] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _szBuf$[ebp+edx], 0

; 1642 : 				targetName = szBuf;

	lea	eax, DWORD PTR _szBuf$[ebp]
	mov	DWORD PTR _targetName$[ebp], eax

; 1643 : 				pTarget = UTIL_FindEntityByTargetname( NULL, targetName, inputActivator );						

	mov	ecx, DWORD PTR _inputActivator$[ebp]
	push	ecx
	mov	edx, DWORD PTR _targetName$[ebp]
	push	edx
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD0@Z ; UTIL_FindEntityByTargetname
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTarget$[ebp], eax

; 1644 : 				break;

	jmp	SHORT $L41454
$L41455:

; 1646 : 		}

	jmp	SHORT $L41453
$L41454:

; 1647 : 
; 1648 : 		// try to extract activator specified
; 1649 : 		if( !pTarget )

	cmp	DWORD PTR _pTarget$[ebp], 0
	jne	$L41469

; 1651 : 			for( i = 0; targetName[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L41457
$L41458:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L41457:
	mov	ecx, DWORD PTR _targetName$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$L41459

; 1653 : 				if( targetName[i] == '(' )

	mov	eax, DWORD PTR _targetName$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 40					; 00000028H
	jne	$L41460

; 1655 : 					i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 1656 : 					for( j = i; targetName[j]; j++ )

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L41461
$L41462:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L41461:
	mov	edx, DWORD PTR _targetName$[ebp]
	add	edx, DWORD PTR _j$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L41463

; 1658 : 						if( targetName[j] == ')' )

	mov	ecx, DWORD PTR _targetName$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	jne	SHORT $L41464

; 1660 : 							Q_strncpy( szBuf, targetName+i, j - i + 1 );

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _targetName$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szBuf$[ebp]
	push	edx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1661 : 							pActivator = UTIL_FindEntityByTargetname( NULL, szBuf, inputActivator );

	mov	eax, DWORD PTR _inputActivator$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szBuf$[ebp]
	push	ecx
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD0@Z ; UTIL_FindEntityByTargetname
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pActivator$[ebp], eax

; 1662 : 							if( !pActivator ) return; // it's a locus specifier, but the locus is invalid.

	cmp	DWORD PTR _pActivator$[ebp], 0
	jne	SHORT $L41465
	jmp	$L41432
$L41465:

; 1663 : 							found = true;

	mov	DWORD PTR _found$[ebp], 1

; 1664 : 							break;

	jmp	SHORT $L41463
$L41464:

; 1666 : 					}

	jmp	SHORT $L41462
$L41463:

; 1667 : 
; 1668 : 					if( !found )

	cmp	DWORD PTR _found$[ebp], 0
	jne	SHORT $L41466

; 1669 : 						ALERT( at_error, "Missing ')' in targetname: %s", inputTargetName );

	mov	edx, DWORD PTR _inputTargetName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BO@OIPF@Missing?5?8?$CJ?8?5in?5targetname?3?5?$CFs?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L41466:

; 1670 : 					break;

	jmp	SHORT $L41459
$L41460:

; 1672 : 			}

	jmp	$L41458
$L41459:

; 1673 : 
; 1674 : 			// no, it's not a locus specifier.
; 1675 : 			if( !found ) return;

	cmp	DWORD PTR _found$[ebp], 0
	jne	SHORT $L41468
	jmp	$L41432
$L41468:

; 1676 : 
; 1677 : 			Q_strncpy( szBuf, targetName, i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _targetName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szBuf$[ebp]
	push	edx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 1678 : 			targetName = szBuf;

	lea	eax, DWORD PTR _szBuf$[ebp]
	mov	DWORD PTR _targetName$[ebp], eax

; 1679 : 			pTarget = UTIL_FindEntityByTargetname( NULL, targetName, inputActivator );

	mov	ecx, DWORD PTR _inputActivator$[ebp]
	push	ecx
	mov	edx, DWORD PTR _targetName$[ebp]
	push	edx
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD0@Z ; UTIL_FindEntityByTargetname
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTarget$[ebp], eax

; 1680 : 
; 1681 : 			// it's a locus specifier all right, but the target's invalid.
; 1682 : 			if( !pTarget ) return;

	cmp	DWORD PTR _pTarget$[ebp], 0
	jne	SHORT $L41469
	jmp	$L41432
$L41469:

; 1685 : 
; 1686 : 	ALERT( at_aiconsole, "Firing: (%s) with %s and value %g\n", targetName, GetStringForUseType( useType ), value );

	fld	DWORD PTR _value$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	eax, DWORD PTR _useType$[ebp]
	push	eax
	call	?GetStringForUseType@@YAPBDW4USE_TYPE@@@Z ; GetStringForUseType
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _targetName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CD@CLIA@Firing?3?5?$CI?$CFs?$CJ?5with?5?$CFs?5and?5value?5?$CF@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 24					; 00000018H
$L41471:

; 1691 : 		if(!( pTarget->pev->flags & FL_KILLME ))

	mov	edx, DWORD PTR _pTarget$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 1073741824				; 40000000H
	test	ecx, ecx
	jne	SHORT $L41476

; 1693 : 			if( useType == USE_REMOVE ) UTIL_Remove( pTarget );

	cmp	DWORD PTR _useType$[ebp], 5
	jne	SHORT $L41475
	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 1694 : 			else pTarget->Use( pActivator, pCaller, useType, value );

	jmp	SHORT $L41476
$L41475:
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _useType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCaller$[ebp]
	push	edx
	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [edx+276]
$L41476:

; 1696 : 
; 1697 : 		pTarget = UTIL_FindEntityByTargetname( pTarget, targetName, inputActivator );

	mov	eax, DWORD PTR _inputActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _targetName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD0@Z ; UTIL_FindEntityByTargetname
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTarget$[ebp], eax

; 1698 : 
; 1699 : 	} while( pTarget != NULL );

	cmp	DWORD PTR _pTarget$[ebp], 0
	jne	SHORT $L41471
$L41432:

; 1700 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ENDP ; UTIL_FireTargets
_TEXT	ENDS
PUBLIC	?UTIL_ShouldShowBlood@@YAHH@Z			; UTIL_ShouldShowBlood
PUBLIC	??_C@_0BA@DNOL@violence_hblood?$AA@		; `string'
PUBLIC	??_C@_0BA@FEK@violence_ablood?$AA@		; `string'
;	COMDAT ??_C@_0BA@DNOL@violence_hblood?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0BA@DNOL@violence_hblood?$AA@ DB 'violence_hblood', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FEK@violence_ablood?$AA@
CONST	SEGMENT
??_C@_0BA@FEK@violence_ablood?$AA@ DB 'violence_ablood', 00H ; `string'
CONST	ENDS
;	COMDAT ?UTIL_ShouldShowBlood@@YAHH@Z
_TEXT	SEGMENT
_color$ = 8
?UTIL_ShouldShowBlood@@YAHH@Z PROC NEAR			; UTIL_ShouldShowBlood, COMDAT

; 1703 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1704 : 	if ( color != DONT_BLEED )

	cmp	DWORD PTR _color$[ebp], -1
	je	SHORT $L41486

; 1706 : 		if ( color == BLOOD_COLOR_RED )

	cmp	DWORD PTR _color$[ebp], 247		; 000000f7H
	jne	SHORT $L41482

; 1708 : 			if ( CVAR_GET_FLOAT("violence_hblood") != 0 )

	push	OFFSET FLAT:??_C@_0BA@DNOL@violence_hblood?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41483

; 1709 : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $L41479
$L41483:

; 1711 : 		else

	jmp	SHORT $L41486
$L41482:

; 1713 : 			if ( CVAR_GET_FLOAT("violence_ablood") != 0 )

	push	OFFSET FLAT:??_C@_0BA@FEK@violence_ablood?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41486

; 1714 : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $L41479
$L41486:

; 1717 : 	return FALSE;

	xor	eax, eax
$L41479:

; 1718 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ShouldShowBlood@@YAHH@Z ENDP			; UTIL_ShouldShowBlood
_TEXT	ENDS
PUBLIC	?UTIL_PointContents@@YAHABVVector@@@Z		; UTIL_PointContents
;	COMDAT ?UTIL_PointContents@@YAHABVVector@@@Z
_TEXT	SEGMENT
_vec$ = 8
?UTIL_PointContents@@YAHABVVector@@@Z PROC NEAR		; UTIL_PointContents, COMDAT

; 1721 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1722 : 	return POINT_CONTENTS(vec);

	mov	ecx, DWORD PTR _vec$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+180
	add	esp, 4

; 1723 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_PointContents@@YAHABVVector@@@Z ENDP		; UTIL_PointContents
_TEXT	ENDS
PUBLIC	?UTIL_BloodStream@@YAXABVVector@@0HH@Z		; UTIL_BloodStream
EXTRN	?g_Language@@3HA:DWORD				; g_Language
;	COMDAT ?UTIL_BloodStream@@YAXABVVector@@0HH@Z
_TEXT	SEGMENT
_origin$ = 8
_direction$ = 12
_color$ = 16
_amount$ = 20
?UTIL_BloodStream@@YAXABVVector@@0HH@Z PROC NEAR	; UTIL_BloodStream, COMDAT

; 1726 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1727 : 	if ( !UTIL_ShouldShowBlood( color ) )

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	call	?UTIL_ShouldShowBlood@@YAHH@Z		; UTIL_ShouldShowBlood
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41497

; 1728 : 		return;

	jmp	$L41496
$L41497:

; 1729 : 
; 1730 : 	if ( g_Language == LANGUAGE_GERMAN && color == BLOOD_COLOR_RED )

	cmp	DWORD PTR ?g_Language@@3HA, 1		; g_Language
	jne	SHORT $L41499
	cmp	DWORD PTR _color$[ebp], 247		; 000000f7H
	jne	SHORT $L41499

; 1731 : 		color = 0;

	mov	DWORD PTR _color$[ebp], 0
$L41499:

; 1732 : 
; 1733 : 	
; 1734 : 	MESSAGE_BEGIN( MSG_PVS, SVC_TEMPENTITY, origin );

	push	0
	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	push	23					; 00000017H
	push	4
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1735 : 		WRITE_BYTE( TE_BLOODSTREAM );

	push	101					; 00000065H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1736 : 		WRITE_COORD( origin.x );

	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1737 : 		WRITE_COORD( origin.y );

	mov	eax, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1738 : 		WRITE_COORD( origin.z );

	mov	edx, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1739 : 		WRITE_COORD( direction.x );

	mov	ecx, DWORD PTR _direction$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1740 : 		WRITE_COORD( direction.y );

	mov	eax, DWORD PTR _direction$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1741 : 		WRITE_COORD( direction.z );

	mov	edx, DWORD PTR _direction$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1742 : 		WRITE_BYTE( color );

	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1743 : 		WRITE_BYTE( Q_min( amount, 255 ) );

	cmp	DWORD PTR _amount$[ebp], 255		; 000000ffH
	jge	SHORT $L43946
	mov	edx, DWORD PTR _amount$[ebp]
	mov	DWORD PTR -4+[ebp], edx
	jmp	SHORT $L43947
$L43946:
	mov	DWORD PTR -4+[ebp], 255			; 000000ffH
$L43947:
	mov	eax, DWORD PTR -4+[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1744 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41496:

; 1745 : }				

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_BloodStream@@YAXABVVector@@0HH@Z ENDP		; UTIL_BloodStream
_TEXT	ENDS
PUBLIC	?UTIL_BloodDrips@@YAXABVVector@@0HH@Z		; UTIL_BloodDrips
EXTRN	?g_sModelIndexBloodDrop@@3FA:WORD		; g_sModelIndexBloodDrop
EXTRN	?g_sModelIndexBloodSpray@@3FA:WORD		; g_sModelIndexBloodSpray
;	COMDAT ?UTIL_BloodDrips@@YAXABVVector@@0HH@Z
_TEXT	SEGMENT
_origin$ = 8
_color$ = 16
_amount$ = 20
?UTIL_BloodDrips@@YAXABVVector@@0HH@Z PROC NEAR		; UTIL_BloodDrips, COMDAT

; 1748 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1749 : 	if ( !UTIL_ShouldShowBlood( color ) )

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	call	?UTIL_ShouldShowBlood@@YAHH@Z		; UTIL_ShouldShowBlood
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41506

; 1750 : 		return;

	jmp	$L41505
$L41506:

; 1751 : 
; 1752 : 	if ( color == DONT_BLEED || amount == 0 )

	cmp	DWORD PTR _color$[ebp], -1
	je	SHORT $L41508
	cmp	DWORD PTR _amount$[ebp], 0
	jne	SHORT $L41507
$L41508:

; 1753 : 		return;

	jmp	$L41505
$L41507:

; 1754 : 
; 1755 : 	if ( g_Language == LANGUAGE_GERMAN && color == BLOOD_COLOR_RED )

	cmp	DWORD PTR ?g_Language@@3HA, 1		; g_Language
	jne	SHORT $L41510
	cmp	DWORD PTR _color$[ebp], 247		; 000000f7H
	jne	SHORT $L41510

; 1756 : 		color = 0;

	mov	DWORD PTR _color$[ebp], 0
$L41510:

; 1757 : 
; 1758 : 	if ( g_pGameRules->IsMultiplayer() )

	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $L41511

; 1760 : 		// scale up blood effect in multiplayer for better visibility
; 1761 : 		amount *= 2;

	mov	eax, DWORD PTR _amount$[ebp]
	shl	eax, 1
	mov	DWORD PTR _amount$[ebp], eax
$L41511:

; 1763 : 
; 1764 : 	if ( amount > 255 )

	cmp	DWORD PTR _amount$[ebp], 255		; 000000ffH
	jle	SHORT $L41512

; 1765 : 		amount = 255;

	mov	DWORD PTR _amount$[ebp], 255		; 000000ffH
$L41512:

; 1766 : 
; 1767 : 	MESSAGE_BEGIN( MSG_PVS, SVC_TEMPENTITY, origin );

	push	0
	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	push	23					; 00000017H
	push	4
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1768 : 		WRITE_BYTE( TE_BLOODSPRITE );

	push	115					; 00000073H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1769 : 		WRITE_COORD( origin.x);								// pos

	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1770 : 		WRITE_COORD( origin.y);

	mov	eax, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1771 : 		WRITE_COORD( origin.z);

	mov	edx, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1772 : 		WRITE_SHORT( g_sModelIndexBloodSpray );				// initial sprite model

	movsx	ecx, WORD PTR ?g_sModelIndexBloodSpray@@3FA ; g_sModelIndexBloodSpray
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1773 : 		WRITE_SHORT( g_sModelIndexBloodDrop );				// droplet sprite models

	movsx	edx, WORD PTR ?g_sModelIndexBloodDrop@@3FA ; g_sModelIndexBloodDrop
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1774 : 		WRITE_BYTE( color );								// color index into host_basepal

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1775 : 		WRITE_BYTE( Q_min( Q_max( 3, amount / 10 ), 16 ) );		// size

	mov	eax, DWORD PTR _amount$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cmp	eax, 3
	jge	SHORT $L43950
	mov	DWORD PTR -4+[ebp], 3
	jmp	SHORT $L43951
$L43950:
	mov	eax, DWORD PTR _amount$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR -4+[ebp], eax
$L43951:
	cmp	DWORD PTR -4+[ebp], 16			; 00000010H
	jge	SHORT $L43954
	mov	eax, DWORD PTR _amount$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cmp	eax, 3
	jge	SHORT $L43952
	mov	DWORD PTR -8+[ebp], 3
	jmp	SHORT $L43953
$L43952:
	mov	eax, DWORD PTR _amount$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR -8+[ebp], eax
$L43953:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR -12+[ebp], edx
	jmp	SHORT $L43955
$L43954:
	mov	DWORD PTR -12+[ebp], 16			; 00000010H
$L43955:
	mov	eax, DWORD PTR -12+[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1776 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41505:

; 1777 : }				

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_BloodDrips@@YAXABVVector@@0HH@Z ENDP		; UTIL_BloodDrips
_TEXT	ENDS
PUBLIC	?UTIL_RandomBloodVector@@YA?AVVector@@XZ	; UTIL_RandomBloodVector
;	COMDAT ?UTIL_RandomBloodVector@@YA?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_direction$ = -12
?UTIL_RandomBloodVector@@YA?AVVector@@XZ PROC NEAR	; UTIL_RandomBloodVector, COMDAT

; 1780 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1781 : 	Vector direction;

	lea	ecx, DWORD PTR _direction$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1782 : 
; 1783 : 	direction.x = RANDOM_FLOAT ( -1, 1 );

	push	1065353216				; 3f800000H
	push	-1082130432				; bf800000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fstp	DWORD PTR _direction$[ebp]

; 1784 : 	direction.y = RANDOM_FLOAT ( -1, 1 );

	push	1065353216				; 3f800000H
	push	-1082130432				; bf800000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fstp	DWORD PTR _direction$[ebp+4]

; 1785 : 	direction.z = RANDOM_FLOAT ( 0, 1 );

	push	1065353216				; 3f800000H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fstp	DWORD PTR _direction$[ebp+8]

; 1786 : 
; 1787 : 	return direction;

	lea	eax, DWORD PTR _direction$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1788 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_RandomBloodVector@@YA?AVVector@@XZ ENDP		; UTIL_RandomBloodVector
_TEXT	ENDS
PUBLIC	?UTIL_BloodDecalTrace@@YAXPAUgametrace_s@@H@Z	; UTIL_BloodDecalTrace
PUBLIC	?UTIL_DecalTrace@@YAXPAUgametrace_s@@H@Z	; UTIL_DecalTrace
;	COMDAT ?UTIL_BloodDecalTrace@@YAXPAUgametrace_s@@H@Z
_TEXT	SEGMENT
_pTrace$ = 8
_bloodColor$ = 12
?UTIL_BloodDecalTrace@@YAXPAUgametrace_s@@H@Z PROC NEAR	; UTIL_BloodDecalTrace, COMDAT

; 1792 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1793 : 	if ( UTIL_ShouldShowBlood( bloodColor ) )

	mov	eax, DWORD PTR _bloodColor$[ebp]
	push	eax
	call	?UTIL_ShouldShowBlood@@YAHH@Z		; UTIL_ShouldShowBlood
	add	esp, 4
	test	eax, eax
	je	SHORT $L41525

; 1795 : 		if ( bloodColor == BLOOD_COLOR_RED )

	cmp	DWORD PTR _bloodColor$[ebp], 247	; 000000f7H
	jne	SHORT $L41524

; 1796 : 			UTIL_DecalTrace( pTrace, DECAL_BLOOD1 + RANDOM_LONG(0,5) );

	push	5
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 13					; 0000000dH
	push	eax
	mov	ecx, DWORD PTR _pTrace$[ebp]
	push	ecx
	call	?UTIL_DecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_DecalTrace
	add	esp, 8

; 1797 : 		else

	jmp	SHORT $L41525
$L41524:

; 1798 : 			UTIL_DecalTrace( pTrace, DECAL_YBLOOD1 + RANDOM_LONG(0,5) );

	push	5
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 19					; 00000013H
	push	eax
	mov	edx, DWORD PTR _pTrace$[ebp]
	push	edx
	call	?UTIL_DecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_DecalTrace
	add	esp, 8
$L41525:

; 1800 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_BloodDecalTrace@@YAXPAUgametrace_s@@H@Z ENDP	; UTIL_BloodDecalTrace
_TEXT	ENDS
PUBLIC	?UTIL_BloodStudioDecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_BloodStudioDecalTrace
PUBLIC	?UTIL_StudioDecalTrace@@YAXPAUgametrace_s@@HH@Z	; UTIL_StudioDecalTrace
;	COMDAT ?UTIL_BloodStudioDecalTrace@@YAXPAUgametrace_s@@H@Z
_TEXT	SEGMENT
_pTrace$ = 8
_bloodColor$ = 12
?UTIL_BloodStudioDecalTrace@@YAXPAUgametrace_s@@H@Z PROC NEAR ; UTIL_BloodStudioDecalTrace, COMDAT

; 1803 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1804 : 	if ( UTIL_ShouldShowBlood( bloodColor ) )

	mov	eax, DWORD PTR _bloodColor$[ebp]
	push	eax
	call	?UTIL_ShouldShowBlood@@YAHH@Z		; UTIL_ShouldShowBlood
	add	esp, 4
	test	eax, eax
	je	SHORT $L41533

; 1806 : 		if ( bloodColor == BLOOD_COLOR_RED )

	cmp	DWORD PTR _bloodColor$[ebp], 247	; 000000f7H
	jne	SHORT $L41532

; 1807 : 			UTIL_StudioDecalTrace( pTrace, DECAL_BLOOD1 + RANDOM_LONG(0,5), 0 );

	push	0
	push	5
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 13					; 0000000dH
	push	eax
	mov	ecx, DWORD PTR _pTrace$[ebp]
	push	ecx
	call	?UTIL_StudioDecalTrace@@YAXPAUgametrace_s@@HH@Z ; UTIL_StudioDecalTrace
	add	esp, 12					; 0000000cH

; 1808 : 		else

	jmp	SHORT $L41533
$L41532:

; 1809 : 			UTIL_StudioDecalTrace( pTrace, DECAL_YBLOOD1 + RANDOM_LONG(0,5), 0 );

	push	0
	push	5
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 19					; 00000013H
	push	eax
	mov	edx, DWORD PTR _pTrace$[ebp]
	push	edx
	call	?UTIL_StudioDecalTrace@@YAXPAUgametrace_s@@HH@Z ; UTIL_StudioDecalTrace
	add	esp, 12					; 0000000cH
$L41533:

; 1811 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_BloodStudioDecalTrace@@YAXPAUgametrace_s@@H@Z ENDP ; UTIL_BloodStudioDecalTrace
_TEXT	ENDS
PUBLIC	__real@8@3fff8000000000000000
EXTRN	?gDecals@@3PAUDLL_DECALLIST@@A:BYTE		; gDecals
;	COMDAT __real@8@3fff8000000000000000
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT ?UTIL_DecalTrace@@YAXPAUgametrace_s@@H@Z
_TEXT	SEGMENT
_pTrace$ = 8
_decalNumber$ = 12
_entityIndex$ = -4
_index$ = -8
_message$ = -12
_pEntity$41545 = -16
?UTIL_DecalTrace@@YAXPAUgametrace_s@@H@Z PROC NEAR	; UTIL_DecalTrace, COMDAT

; 1814 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1815 : 	short entityIndex;
; 1816 : 	int index;
; 1817 : 	int message;
; 1818 : 
; 1819 : 	if ( decalNumber < 0 )

	cmp	DWORD PTR _decalNumber$[ebp], 0
	jge	SHORT $L41541

; 1820 : 		return;

	jmp	$L41537
$L41541:

; 1821 : 
; 1822 : 	index = gDecals[ decalNumber ].index;

	mov	eax, DWORD PTR _decalNumber$[ebp]
	mov	ecx, DWORD PTR ?gDecals@@3PAUDLL_DECALLIST@@A[eax*8+4]
	mov	DWORD PTR _index$[ebp], ecx

; 1823 : 
; 1824 : 	if ( index < 0 )

	cmp	DWORD PTR _index$[ebp], 0
	jge	SHORT $L41542

; 1825 : 		return;

	jmp	$L41537
$L41542:

; 1826 : 
; 1827 : 	if (pTrace->flFraction == 1.0)

	mov	edx, DWORD PTR _pTrace$[ebp]
	fld	DWORD PTR [edx+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41543

; 1828 : 		return;

	jmp	$L41537
$L41543:

; 1829 : 
; 1830 : 	// Only decal BSP models
; 1831 : 	if ( pTrace->pHit )

	mov	eax, DWORD PTR _pTrace$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $L41544

; 1833 : 		CBaseEntity *pEntity = CBaseEntity::Instance( pTrace->pHit );

	mov	ecx, DWORD PTR _pTrace$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$41545[ebp], eax

; 1834 : 		if ( pEntity && !pEntity->IsBSPModel() )

	cmp	DWORD PTR _pEntity$41545[ebp], 0
	je	SHORT $L41546
	mov	eax, DWORD PTR _pEntity$41545[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$41545[ebp]
	call	DWORD PTR [edx+204]
	test	eax, eax
	jne	SHORT $L41546

; 1835 : 			return;

	jmp	$L41537
$L41546:

; 1836 : 		entityIndex = ENTINDEX( pTrace->pHit );

	mov	eax, DWORD PTR _pTrace$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	mov	WORD PTR _entityIndex$[ebp], ax

; 1838 : 	else 

	jmp	SHORT $L41547
$L41544:

; 1839 : 		entityIndex = 0;

	mov	WORD PTR _entityIndex$[ebp], 0
$L41547:

; 1840 : 
; 1841 : 	message = TE_DECAL;

	mov	DWORD PTR _message$[ebp], 104		; 00000068H

; 1842 : 	if ( entityIndex != 0 )

	movsx	edx, WORD PTR _entityIndex$[ebp]
	test	edx, edx
	je	SHORT $L41548

; 1844 : 		if ( index > 255 )

	cmp	DWORD PTR _index$[ebp], 255		; 000000ffH
	jle	SHORT $L41549

; 1846 : 			message = TE_DECALHIGH;

	mov	DWORD PTR _message$[ebp], 118		; 00000076H

; 1847 : 			index -= 256;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 256				; 00000100H
	mov	DWORD PTR _index$[ebp], eax
$L41549:

; 1850 : 	else

	jmp	SHORT $L41551
$L41548:

; 1852 : 		message = TE_WORLDDECAL;

	mov	DWORD PTR _message$[ebp], 116		; 00000074H

; 1853 : 		if ( index > 255 )

	cmp	DWORD PTR _index$[ebp], 255		; 000000ffH
	jle	SHORT $L41551

; 1855 : 			message = TE_WORLDDECALHIGH;

	mov	DWORD PTR _message$[ebp], 117		; 00000075H

; 1856 : 			index -= 256;

	mov	ecx, DWORD PTR _index$[ebp]
	sub	ecx, 256				; 00000100H
	mov	DWORD PTR _index$[ebp], ecx
$L41551:

; 1859 : 	
; 1860 : 	MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );

	push	0
	push	0
	push	23					; 00000017H
	push	0
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1861 : 		WRITE_BYTE( message );

	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1862 : 		WRITE_COORD( pTrace->vecEndPos.x );

	mov	eax, DWORD PTR _pTrace$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1863 : 		WRITE_COORD( pTrace->vecEndPos.y );

	mov	edx, DWORD PTR _pTrace$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1864 : 		WRITE_COORD( pTrace->vecEndPos.z );

	mov	ecx, DWORD PTR _pTrace$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1865 : 		WRITE_BYTE( index );

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1866 : 		if ( entityIndex )

	movsx	ecx, WORD PTR _entityIndex$[ebp]
	test	ecx, ecx
	je	SHORT $L41552

; 1867 : 			WRITE_SHORT( entityIndex );

	movsx	edx, WORD PTR _entityIndex$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4
$L41552:

; 1868 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41537:

; 1869 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_DecalTrace@@YAXPAUgametrace_s@@H@Z ENDP		; UTIL_DecalTrace
_TEXT	ENDS
PUBLIC	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z	; UTIL_GetModelType
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	__real@4@40028000000000000000
EXTRN	?gmsgStudioDecal@@3HA:DWORD			; gmsgStudioDecal
EXTRN	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix4x4::VectorITransform
;	COMDAT __real@4@3fff8000000000000000
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT __real@4@40028000000000000000
CONST	SEGMENT
__real@4@40028000000000000000 DD 041000000r	; 8
CONST	ENDS
;	COMDAT ?UTIL_StudioDecalTrace@@YAXPAUgametrace_s@@HH@Z
_TEXT	SEGMENT
_pTrace$ = 8
_decalNumber$ = 12
_flags$ = 16
_entityIndex$ = -4
_decalIndex$ = -8
_pEntity$ = -12
_vecSrc$ = -24
_vecEnd$ = -36
_mat$ = -100
$T43968 = -112
$T43969 = -124
$T43970 = -136
$T43971 = -148
?UTIL_StudioDecalTrace@@YAXPAUgametrace_s@@HH@Z PROC NEAR ; UTIL_StudioDecalTrace, COMDAT

; 1872 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi

; 1873 : 	short entityIndex;
; 1874 : 	int decalIndex;
; 1875 : 
; 1876 : 	if ( decalNumber < 0 )

	cmp	DWORD PTR _decalNumber$[ebp], 0
	jge	SHORT $L41560

; 1877 : 		return;

	jmp	$L41557
$L41560:

; 1878 : 
; 1879 : 	decalIndex = gDecals[ decalNumber ].index;

	mov	eax, DWORD PTR _decalNumber$[ebp]
	mov	ecx, DWORD PTR ?gDecals@@3PAUDLL_DECALLIST@@A[eax*8+4]
	mov	DWORD PTR _decalIndex$[ebp], ecx

; 1880 : 
; 1881 : 	if( decalIndex < 0 )

	cmp	DWORD PTR _decalIndex$[ebp], 0
	jge	SHORT $L41561

; 1882 : 		return;

	jmp	$L41557
$L41561:

; 1883 : 
; 1884 : 	if( pTrace->flFraction == 1.0f )

	mov	edx, DWORD PTR _pTrace$[ebp]
	fld	DWORD PTR [edx+16]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41562

; 1885 : 		return;

	jmp	$L41557
$L41562:

; 1888 : 
; 1889 : 	// Only decal Studio models
; 1890 : 	if( pTrace->pHit )

	mov	eax, DWORD PTR _pTrace$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $L41564

; 1892 : 		pEntity = CBaseEntity::Instance( pTrace->pHit );

	mov	ecx, DWORD PTR _pTrace$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 1893 : 
; 1894 : 		if( !pEntity || UTIL_GetModelType( pEntity->pev->modelindex ) != mod_studio )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L41566
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	cmp	eax, 3
	je	SHORT $L41565
$L41566:

; 1895 : 			return;

	jmp	$L41557
$L41565:

; 1896 : 
; 1897 : 		entityIndex = ENTINDEX( pTrace->pHit );

	mov	eax, DWORD PTR _pTrace$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	mov	WORD PTR _entityIndex$[ebp], ax

; 1899 : 	else

	jmp	SHORT $L41567
$L41564:

; 1901 : 		return;

	jmp	$L41557
$L41567:

; 1903 : 
; 1904 : 	Vector vecSrc = pTrace->vecEndPos + pTrace->vecPlaneNormal * 5.0f;	// magic Valve constant

	push	1084227584				; 40a00000H
	lea	edx, DWORD PTR $T43968[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTrace$[ebp]
	add	ecx, 36					; 00000024H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T43969[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTrace$[ebp]
	add	ecx, 20					; 00000014H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1905 : 	Vector vecEnd = pTrace->vecEndPos;

	mov	ecx, DWORD PTR _pTrace$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1906 : #if 1
; 1907 : 	// write local coords to avoid reduce precision
; 1908 : 	matrix4x4 mat = pEntity->EntityToWorldTransform();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 1909 : 	vecSrc = mat.VectorITransform( vecSrc );

	lea	edx, DWORD PTR _vecSrc$[ebp]
	push	edx
	lea	eax, DWORD PTR $T43970[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecSrc$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecSrc$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecSrc$[ebp+8], eax

; 1910 : 	vecEnd = mat.VectorITransform( vecEnd );

	lea	ecx, DWORD PTR _vecEnd$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T43971[ebp]
	push	edx
	lea	ecx, DWORD PTR _mat$[ebp]
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecEnd$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecEnd$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecEnd$[ebp+8], eax

; 1911 : 	SetBits( flags, FDECAL_LOCAL_SPACE ); // now it's in local space

	mov	ecx, DWORD PTR _flags$[ebp]
	or	cl, -128				; ffffff80H
	mov	DWORD PTR _flags$[ebp], ecx

; 1912 : #endif	
; 1913 : 	MESSAGE_BEGIN( MSG_BROADCAST, gmsgStudioDecal );

	push	0
	push	0
	mov	edx, DWORD PTR ?gmsgStudioDecal@@3HA	; gmsgStudioDecal
	push	edx
	push	0
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1914 : 		WRITE_COORD( vecEnd.x );		// write pos

	mov	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1915 : 		WRITE_COORD( vecEnd.y );

	mov	ecx, DWORD PTR _vecEnd$[ebp+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1916 : 		WRITE_COORD( vecEnd.z );

	mov	edx, DWORD PTR _vecEnd$[ebp+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1917 : 		WRITE_COORD( vecSrc.x );		// write start

	mov	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1918 : 		WRITE_COORD( vecSrc.y );

	mov	ecx, DWORD PTR _vecSrc$[ebp+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1919 : 		WRITE_COORD( vecSrc.z );

	mov	edx, DWORD PTR _vecSrc$[ebp+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1920 : 		WRITE_SHORT( decalIndex );		// decal texture

	mov	eax, DWORD PTR _decalIndex$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1921 : 		WRITE_SHORT( entityIndex );

	movsx	ecx, WORD PTR _entityIndex$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1922 : 		WRITE_SHORT( pEntity->pev->modelindex );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+180]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1923 : 		WRITE_BYTE( flags );

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1924 : 
; 1925 : 		// write model state for correct restore
; 1926 : 		WRITE_SHORT( pEntity->pev->sequence );

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1927 : 		WRITE_SHORT( (int)( pEntity->pev->frame * 8.0f ));

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+304]
	fmul	DWORD PTR __real@4@40028000000000000000
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1928 : 		WRITE_BYTE( pEntity->pev->blending[0] );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+320]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1929 : 		WRITE_BYTE( pEntity->pev->blending[1] );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+321]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1930 : 		WRITE_BYTE( pEntity->pev->controller[0] );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+316]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1931 : 		WRITE_BYTE( pEntity->pev->controller[1] );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+317]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1932 : 		WRITE_BYTE( pEntity->pev->controller[2] );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+318]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1933 : 		WRITE_BYTE( pEntity->pev->controller[3] );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+319]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1934 : 		WRITE_BYTE( pEntity->pev->body );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+276]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1935 : 		WRITE_BYTE( pEntity->pev->skin );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+272]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1936 : 
; 1937 : 		if( FBitSet( pEntity->pev->iuser1, CF_STATIC_ENTITY ))

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+580]
	and	ecx, 64					; 00000040H
	test	ecx, ecx
	je	SHORT $L41576

; 1938 : 			WRITE_SHORT( pEntity->pev->iuser3 );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1939 : 		else WRITE_SHORT( 0 );

	jmp	SHORT $L41577
$L41576:
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4
$L41577:

; 1940 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41557:

; 1941 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_StudioDecalTrace@@YAXPAUgametrace_s@@HH@Z ENDP	; UTIL_StudioDecalTrace
_TEXT	ENDS
PUBLIC	?UTIL_RestoreStudioDecal@@YAXABVVector@@0HHPBDHPAUmodelstate_s@@H@Z ; UTIL_RestoreStudioDecal
;	COMDAT ?UTIL_RestoreStudioDecal@@YAXABVVector@@0HHPBDHPAUmodelstate_s@@H@Z
_TEXT	SEGMENT
_vecEnd$ = 8
_vecSrc$ = 12
_entityIndex$ = 16
_modelIndex$ = 20
_name$ = 24
_flags$ = 28
_state$ = 32
_lightcache$ = 36
?UTIL_RestoreStudioDecal@@YAXABVVector@@0HHPBDHPAUmodelstate_s@@H@Z PROC NEAR ; UTIL_RestoreStudioDecal, COMDAT

; 1944 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1945 : 	MESSAGE_BEGIN( MSG_INIT, gmsgStudioDecal );

	push	0
	push	0
	mov	eax, DWORD PTR ?gmsgStudioDecal@@3HA	; gmsgStudioDecal
	push	eax
	push	3
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1946 : 		WRITE_COORD( vecEnd.x );	// write pos

	mov	ecx, DWORD PTR _vecEnd$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1947 : 		WRITE_COORD( vecEnd.y );

	mov	eax, DWORD PTR _vecEnd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1948 : 		WRITE_COORD( vecEnd.z );

	mov	edx, DWORD PTR _vecEnd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1949 : 		WRITE_COORD( vecSrc.x );	// write start

	mov	ecx, DWORD PTR _vecSrc$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1950 : 		WRITE_COORD( vecSrc.y );

	mov	eax, DWORD PTR _vecSrc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1951 : 		WRITE_COORD( vecSrc.z );

	mov	edx, DWORD PTR _vecSrc$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 1952 : 		WRITE_SHORT( DECAL_INDEX( name ));	// decal texture

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+176
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1953 : 		WRITE_SHORT( entityIndex );

	mov	edx, DWORD PTR _entityIndex$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1954 : 		WRITE_SHORT( modelIndex );

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1955 : 		WRITE_BYTE( flags );

	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1956 : 
; 1957 : 		// write model state for correct restore
; 1958 : 		WRITE_SHORT( state->sequence );

	mov	edx, DWORD PTR _state$[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1959 : 		WRITE_SHORT( state->frame );	// already premultiplied by 8

	mov	ecx, DWORD PTR _state$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1960 : 		WRITE_BYTE( state->blending[0] );

	mov	eax, DWORD PTR _state$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1961 : 		WRITE_BYTE( state->blending[1] );

	mov	edx, DWORD PTR _state$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+5]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1962 : 		WRITE_BYTE( state->controller[0] );

	mov	ecx, DWORD PTR _state$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+6]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1963 : 		WRITE_BYTE( state->controller[1] );

	mov	eax, DWORD PTR _state$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+7]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1964 : 		WRITE_BYTE( state->controller[2] );

	mov	edx, DWORD PTR _state$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1965 : 		WRITE_BYTE( state->controller[3] );

	mov	ecx, DWORD PTR _state$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+9]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1966 : 		WRITE_BYTE( state->body );

	mov	eax, DWORD PTR _state$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+26]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1967 : 		WRITE_BYTE( state->skin );

	mov	edx, DWORD PTR _state$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+27]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1968 : 		WRITE_SHORT( lightcache );

	mov	ecx, DWORD PTR _lightcache$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1969 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 1970 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_RestoreStudioDecal@@YAXABVVector@@0HHPBDHPAUmodelstate_s@@H@Z ENDP ; UTIL_RestoreStudioDecal
_TEXT	ENDS
PUBLIC	?UTIL_PlayerDecalTrace@@YAXPAUgametrace_s@@HHH@Z ; UTIL_PlayerDecalTrace
;	COMDAT ?UTIL_PlayerDecalTrace@@YAXPAUgametrace_s@@HHH@Z
_TEXT	SEGMENT
_pTrace$ = 8
_playernum$ = 12
_decalNumber$ = 16
_bIsCustom$ = 20
_index$ = -4
?UTIL_PlayerDecalTrace@@YAXPAUgametrace_s@@HHH@Z PROC NEAR ; UTIL_PlayerDecalTrace, COMDAT

; 1982 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1983 : 	int index;
; 1984 : 	
; 1985 : 	if (!bIsCustom)

	cmp	DWORD PTR _bIsCustom$[ebp], 0
	jne	SHORT $L41595

; 1987 : 		if ( decalNumber < 0 )

	cmp	DWORD PTR _decalNumber$[ebp], 0
	jge	SHORT $L41596

; 1988 : 			return;

	jmp	$L41593
$L41596:

; 1989 : 
; 1990 : 		index = gDecals[ decalNumber ].index;

	mov	eax, DWORD PTR _decalNumber$[ebp]
	mov	ecx, DWORD PTR ?gDecals@@3PAUDLL_DECALLIST@@A[eax*8+4]
	mov	DWORD PTR _index$[ebp], ecx

; 1991 : 		if ( index < 0 )

	cmp	DWORD PTR _index$[ebp], 0
	jge	SHORT $L41597

; 1992 : 			return;

	jmp	$L41593
$L41597:

; 1994 : 	else

	jmp	SHORT $L41598
$L41595:

; 1995 : 		index = decalNumber;

	mov	edx, DWORD PTR _decalNumber$[ebp]
	mov	DWORD PTR _index$[ebp], edx
$L41598:

; 1996 : 
; 1997 : 	if (pTrace->flFraction == 1.0)

	mov	eax, DWORD PTR _pTrace$[ebp]
	fld	DWORD PTR [eax+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41599

; 1998 : 		return;

	jmp	$L41593
$L41599:

; 1999 : 
; 2000 : 	MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );

	push	0
	push	0
	push	23					; 00000017H
	push	0
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 2001 : 		WRITE_BYTE( TE_PLAYERDECAL );

	push	112					; 00000070H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2002 : 		WRITE_BYTE ( playernum );

	mov	ecx, DWORD PTR _playernum$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2003 : 		WRITE_COORD( pTrace->vecEndPos.x );

	mov	edx, DWORD PTR _pTrace$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2004 : 		WRITE_COORD( pTrace->vecEndPos.y );

	mov	ecx, DWORD PTR _pTrace$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2005 : 		WRITE_COORD( pTrace->vecEndPos.z );

	mov	eax, DWORD PTR _pTrace$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2006 : 		WRITE_SHORT( (short)ENTINDEX(pTrace->pHit) );

	mov	edx, DWORD PTR _pTrace$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	movsx	ecx, ax
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 2007 : 		WRITE_BYTE( index );

	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2008 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41593:

; 2009 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_PlayerDecalTrace@@YAXPAUgametrace_s@@HHH@Z ENDP	; UTIL_PlayerDecalTrace
_TEXT	ENDS
PUBLIC	?UTIL_GunshotDecalTrace@@YAXPAUgametrace_s@@H@Z	; UTIL_GunshotDecalTrace
;	COMDAT ?UTIL_GunshotDecalTrace@@YAXPAUgametrace_s@@H@Z
_TEXT	SEGMENT
_pTrace$ = 8
_decalNumber$ = 12
_index$ = -4
?UTIL_GunshotDecalTrace@@YAXPAUgametrace_s@@H@Z PROC NEAR ; UTIL_GunshotDecalTrace, COMDAT

; 2012 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2013 : 	if ( decalNumber < 0 )

	cmp	DWORD PTR _decalNumber$[ebp], 0
	jge	SHORT $L41605

; 2014 : 		return;

	jmp	$L41604
$L41605:

; 2015 : 
; 2016 : 	int index = gDecals[ decalNumber ].index;

	mov	eax, DWORD PTR _decalNumber$[ebp]
	mov	ecx, DWORD PTR ?gDecals@@3PAUDLL_DECALLIST@@A[eax*8+4]
	mov	DWORD PTR _index$[ebp], ecx

; 2017 : 	if ( index < 0 )

	cmp	DWORD PTR _index$[ebp], 0
	jge	SHORT $L41607

; 2018 : 		return;

	jmp	$L41604
$L41607:

; 2019 : 
; 2020 : 	if (pTrace->flFraction == 1.0)

	mov	edx, DWORD PTR _pTrace$[ebp]
	fld	DWORD PTR [edx+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41608

; 2021 : 		return;

	jmp	$L41604
$L41608:

; 2022 : 
; 2023 : 	MESSAGE_BEGIN( MSG_PAS, SVC_TEMPENTITY, pTrace->vecEndPos );

	push	0
	mov	ecx, DWORD PTR _pTrace$[ebp]
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	push	23					; 00000017H
	push	5
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 2024 : 		WRITE_BYTE( TE_GUNSHOTDECAL );

	push	109					; 0000006dH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2025 : 		WRITE_COORD( pTrace->vecEndPos.x );

	mov	eax, DWORD PTR _pTrace$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2026 : 		WRITE_COORD( pTrace->vecEndPos.y );

	mov	edx, DWORD PTR _pTrace$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2027 : 		WRITE_COORD( pTrace->vecEndPos.z );

	mov	ecx, DWORD PTR _pTrace$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2028 : 		WRITE_SHORT( (short)ENTINDEX(pTrace->pHit) );

	mov	eax, DWORD PTR _pTrace$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	movsx	edx, ax
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 2029 : 		WRITE_BYTE( index );

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2030 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41604:

; 2031 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_GunshotDecalTrace@@YAXPAUgametrace_s@@H@Z ENDP	; UTIL_GunshotDecalTrace
_TEXT	ENDS
PUBLIC	?UTIL_Sparks@@YAXABVVector@@@Z			; UTIL_Sparks
;	COMDAT ?UTIL_Sparks@@YAXABVVector@@@Z
_TEXT	SEGMENT
_position$ = 8
?UTIL_Sparks@@YAXABVVector@@@Z PROC NEAR		; UTIL_Sparks, COMDAT

; 2035 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2036 : 	MESSAGE_BEGIN( MSG_PVS, SVC_TEMPENTITY, position );

	push	0
	mov	ecx, DWORD PTR _position$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	push	23					; 00000017H
	push	4
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 2037 : 		WRITE_BYTE( TE_SPARKS );

	push	9
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2038 : 		WRITE_COORD( position.x );

	mov	eax, DWORD PTR _position$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2039 : 		WRITE_COORD( position.y );

	mov	edx, DWORD PTR _position$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2040 : 		WRITE_COORD( position.z );

	mov	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2041 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 2042 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_Sparks@@YAXABVVector@@@Z ENDP			; UTIL_Sparks
_TEXT	ENDS
PUBLIC	?UTIL_DoSpark@@YAXPAUentvars_s@@ABVVector@@@Z	; UTIL_DoSpark
PUBLIC	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z		; EMIT_SOUND
PUBLIC	??_C@_0BD@ONNB@buttons?1spark1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@NLO@buttons?1spark2?4wav?$AA@		; `string'
PUBLIC	??_C@_0BD@KNJL@buttons?1spark3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@MNGB@buttons?1spark4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@GNEE@buttons?1spark5?4wav?$AA@	; `string'
PUBLIC	??_C@_0BD@INCL@buttons?1spark6?4wav?$AA@	; `string'
PUBLIC	__real@8@3ffdccccccccccccd000
;	COMDAT ??_C@_0BD@ONNB@buttons?1spark1?4wav?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0BD@ONNB@buttons?1spark1?4wav?$AA@ DB 'buttons/spark1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NLO@buttons?1spark2?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@NLO@buttons?1spark2?4wav?$AA@ DB 'buttons/spark2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KNJL@buttons?1spark3?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@KNJL@buttons?1spark3?4wav?$AA@ DB 'buttons/spark3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MNGB@buttons?1spark4?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@MNGB@buttons?1spark4?4wav?$AA@ DB 'buttons/spark4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNEE@buttons?1spark5?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@GNEE@buttons?1spark5?4wav?$AA@ DB 'buttons/spark5.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@INCL@buttons?1spark6?4wav?$AA@
CONST	SEGMENT
??_C@_0BD@INCL@buttons?1spark6?4wav?$AA@ DB 'buttons/spark6.wav', 00H ; `string'
CONST	ENDS
;	COMDAT __real@8@3ffdccccccccccccd000
CONST	SEGMENT
__real@8@3ffdccccccccccccd000 DQ 03fd999999999999ar ; 0.4
CONST	ENDS
;	COMDAT ?UTIL_DoSpark@@YAXPAUentvars_s@@ABVVector@@@Z
_TEXT	SEGMENT
_pev$ = 8
_location$ = 12
_tmp$ = -12
_flVolume$ = -16
$T43986 = -28
$T43987 = -40
?UTIL_DoSpark@@YAXPAUentvars_s@@ABVVector@@@Z PROC NEAR	; UTIL_DoSpark, COMDAT

; 2048 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 2049 : 	Vector tmp = location + pev->size * 0.5;

	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T43986[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	add	ecx, 244				; 000000f4H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T43987[ebp]
	push	ecx
	mov	ecx, DWORD PTR _location$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2050 : 
; 2051 : 	UTIL_Sparks( tmp );

	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	call	?UTIL_Sparks@@YAXABVVector@@@Z		; UTIL_Sparks
	add	esp, 4

; 2052 : 
; 2053 : 	float flVolume = RANDOM_FLOAT( 0.25f, 0.75f ) * 0.4; // random volume range

	push	1061158912				; 3f400000H
	push	1048576000				; 3e800000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fmul	QWORD PTR __real@8@3ffdccccccccccccd000
	fstp	DWORD PTR _flVolume$[ebp]

; 2056 : 	{

	push	5
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR -44+[ebp], eax
	cmp	DWORD PTR -44+[ebp], 5
	ja	$L41622
	mov	eax, DWORD PTR -44+[ebp]
	jmp	DWORD PTR $L43990[eax*4]
$L41625:

; 2057 : 	case 0: EMIT_SOUND( ENT(pev), CHAN_VOICE, "buttons/spark1.wav", flVolume, ATTN_STATIC ); break;

	push	1067450368				; 3fa00000H
	mov	ecx, DWORD PTR _flVolume$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BD@ONNB@buttons?1spark1?4wav?$AA@ ; `string'
	push	2
	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
	jmp	$L41622
$L41628:

; 2058 : 	case 1: EMIT_SOUND( ENT(pev), CHAN_VOICE, "buttons/spark2.wav", flVolume, ATTN_STATIC ); break;

	push	1067450368				; 3fa00000H
	mov	eax, DWORD PTR _flVolume$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BD@NLO@buttons?1spark2?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
	jmp	$L41622
$L41631:

; 2059 : 	case 2: EMIT_SOUND( ENT(pev), CHAN_VOICE, "buttons/spark3.wav", flVolume, ATTN_STATIC ); break;

	push	1067450368				; 3fa00000H
	mov	edx, DWORD PTR _flVolume$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BD@KNJL@buttons?1spark3?4wav?$AA@ ; `string'
	push	2
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
	jmp	SHORT $L41622
$L41634:

; 2060 : 	case 3: EMIT_SOUND( ENT(pev), CHAN_VOICE, "buttons/spark4.wav", flVolume, ATTN_STATIC ); break;

	push	1067450368				; 3fa00000H
	mov	ecx, DWORD PTR _flVolume$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BD@MNGB@buttons?1spark4?4wav?$AA@ ; `string'
	push	2
	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
	jmp	SHORT $L41622
$L41637:

; 2061 : 	case 4: EMIT_SOUND( ENT(pev), CHAN_VOICE, "buttons/spark5.wav", flVolume, ATTN_STATIC ); break;

	push	1067450368				; 3fa00000H
	mov	eax, DWORD PTR _flVolume$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BD@GNEE@buttons?1spark5?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
	jmp	SHORT $L41622
$L41640:

; 2062 : 	case 5: EMIT_SOUND( ENT(pev), CHAN_VOICE, "buttons/spark6.wav", flVolume, ATTN_STATIC ); break;

	push	1067450368				; 3fa00000H
	mov	edx, DWORD PTR _flVolume$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BD@INCL@buttons?1spark6?4wav?$AA@ ; `string'
	push	2
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L41622:

; 2064 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L43990:
	DD	$L41625
	DD	$L41628
	DD	$L41631
	DD	$L41634
	DD	$L41637
	DD	$L41640
?UTIL_DoSpark@@YAXPAUentvars_s@@ABVVector@@@Z ENDP	; UTIL_DoSpark
_TEXT	ENDS
EXTRN	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z:NEAR	; EMIT_SOUND_DYN
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
_volume$ = 20
_attenuation$ = 24
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z PROC NEAR		; EMIT_SOUND, COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 610  : 	EMIT_SOUND_DYN( entity, channel, sample, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 611  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z ENDP		; EMIT_SOUND
_TEXT	ENDS
PUBLIC	?UTIL_Ricochet@@YAXABVVector@@M@Z		; UTIL_Ricochet
PUBLIC	__real@4@4002a000000000000000
;	COMDAT __real@4@4002a000000000000000
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
__real@4@4002a000000000000000 DD 041200000r	; 10
CONST	ENDS
;	COMDAT ?UTIL_Ricochet@@YAXABVVector@@M@Z
_TEXT	SEGMENT
_position$ = 8
_scale$ = 12
?UTIL_Ricochet@@YAXABVVector@@M@Z PROC NEAR		; UTIL_Ricochet, COMDAT

; 2067 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2068 : 	MESSAGE_BEGIN( MSG_PVS, SVC_TEMPENTITY, position );

	push	0
	mov	ecx, DWORD PTR _position$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	push	23					; 00000017H
	push	4
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 2069 : 		WRITE_BYTE( TE_ARMOR_RICOCHET );

	push	111					; 0000006fH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2070 : 		WRITE_COORD( position.x );

	mov	eax, DWORD PTR _position$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2071 : 		WRITE_COORD( position.y );

	mov	edx, DWORD PTR _position$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2072 : 		WRITE_COORD( position.z );

	mov	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2073 : 		WRITE_BYTE( (int)(scale*10) );

	fld	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR __real@4@4002a000000000000000
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2074 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 2075 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_Ricochet@@YAXABVVector@@M@Z ENDP			; UTIL_Ricochet
_TEXT	ENDS
PUBLIC	?UTIL_TeamsMatch@@YAHPBD0@Z			; UTIL_TeamsMatch
EXTRN	_stricmp:NEAR
;	COMDAT ?UTIL_TeamsMatch@@YAHPBD0@Z
_TEXT	SEGMENT
_pTeamName1$ = 8
_pTeamName2$ = 12
?UTIL_TeamsMatch@@YAHPBD0@Z PROC NEAR			; UTIL_TeamsMatch, COMDAT

; 2079 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2080 : 	// Everyone matches unless it's teamplay
; 2081 : 	if ( !g_pGameRules->IsTeamplay() )

	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+32]
	test	eax, eax
	jne	SHORT $L41652

; 2082 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L41651
$L41652:

; 2083 : 
; 2084 : 	// Both on a team?
; 2085 : 	if ( *pTeamName1 != 0 && *pTeamName2 != 0 )

	mov	eax, DWORD PTR _pTeamName1$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L41654
	mov	edx, DWORD PTR _pTeamName2$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L41654

; 2087 : 		if ( !stricmp( pTeamName1, pTeamName2 ) )	// Same Team?

	mov	ecx, DWORD PTR _pTeamName2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTeamName1$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L41654

; 2088 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L41651
$L41654:

; 2090 : 
; 2091 : 	return FALSE;

	xor	eax, eax
$L41651:

; 2092 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_TeamsMatch@@YAHPBD0@Z ENDP			; UTIL_TeamsMatch
_TEXT	ENDS
PUBLIC	?UTIL_IsFacing@@YAHPAUentvars_s@@ABVVector@@@Z	; UTIL_IsFacing
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	?DotProduct@@YAMABVVector@@0@Z			; DotProduct
PUBLIC	?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z	; UTIL_MakeVectorsPrivate
PUBLIC	__real@8@3ffef5c28f5c28f5c000
;	COMDAT __real@8@3ffef5c28f5c28f5c000
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
__real@8@3ffef5c28f5c28f5c000 DQ 03feeb851eb851eb8r ; 0.96
CONST	ENDS
;	COMDAT ?UTIL_IsFacing@@YAHPAUentvars_s@@ABVVector@@@Z
_TEXT	SEGMENT
_pevTest$ = 8
_reference$ = 12
_vecDir$ = -12
_forward$ = -24
_angle$ = -36
$T44001 = -48
$T44002 = -60
?UTIL_IsFacing@@YAHPAUentvars_s@@ABVVector@@@Z PROC NEAR ; UTIL_IsFacing, COMDAT

; 2096 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 2097 : 	Vector vecDir = (reference - pevTest->origin);

	mov	eax, DWORD PTR _pevTest$[ebp]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR $T44001[ebp]
	push	ecx
	mov	ecx, DWORD PTR _reference$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2098 : 	vecDir.z = 0;

	mov	DWORD PTR _vecDir$[ebp+8], 0

; 2099 : 	vecDir = vecDir.Normalize();

	lea	edx, DWORD PTR $T44002[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecDir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecDir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecDir$[ebp+8], eax

; 2100 : 	Vector forward, angle;

	lea	ecx, DWORD PTR _forward$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _angle$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2101 : 	angle = pevTest->v_angle;

	mov	ecx, DWORD PTR _pevTest$[ebp]
	add	ecx, 116				; 00000074H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _angle$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _angle$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _angle$[ebp+8], ecx

; 2102 : 	angle.x = 0;

	mov	DWORD PTR _angle$[ebp], 0

; 2103 : 	UTIL_MakeVectorsPrivate( angle, forward, NULL, NULL );

	push	0
	push	0
	lea	ecx, DWORD PTR _forward$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	edx, DWORD PTR _angle$[ebp]
	push	edx
	call	?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z ; UTIL_MakeVectorsPrivate
	add	esp, 16					; 00000010H

; 2104 : 	// He's facing me, he meant it
; 2105 : 	if ( DotProduct( forward, vecDir ) > 0.96 )	// +/- 15 degrees or so

	lea	eax, DWORD PTR _vecDir$[ebp]
	push	eax
	lea	ecx, DWORD PTR _forward$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fcomp	QWORD PTR __real@8@3ffef5c28f5c28f5c000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41664

; 2107 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L41658
$L41664:

; 2109 : 	return FALSE;

	xor	eax, eax
$L41658:

; 2110 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_IsFacing@@YAHPAUentvars_s@@ABVVector@@@Z ENDP	; UTIL_IsFacing
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_flLen$ = -8
$T44007 = -20
?Normalize@Vector@@QBE?AV1@XZ PROC NEAR			; Vector::Normalize, COMDAT

; 232  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 234  : 
; 235  : 		if( flLen )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L24894

; 237  : 			flLen = 1.0f / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 238  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T44007[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L24892
$L24894:

; 240  : 
; 241  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L24892:

; 242  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProduct@@YAMABVVector@@0@Z PROC NEAR		; DotProduct, COMDAT

; 289  : inline float DotProduct(const Vector& a, const Vector& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector@@0@Z ENDP			; DotProduct
_TEXT	ENDS
;	COMDAT ?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z
_TEXT	SEGMENT
_vecAngles$ = 8
_p_vForward$ = 12
_p_vRight$ = 16
_p_vUp$ = 20
?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z PROC NEAR ; UTIL_MakeVectorsPrivate, COMDAT

; 343  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 344  : 	g_engfuncs.pfnAngleVectors( vecAngles, p_vForward, p_vRight, p_vUp );

	mov	eax, DWORD PTR _p_vUp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p_vRight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p_vForward$[ebp]
	push	edx
	mov	ecx, DWORD PTR _vecAngles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+80
	add	esp, 16					; 00000010H

; 345  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z ENDP	; UTIL_MakeVectorsPrivate
_TEXT	ENDS
PUBLIC	?UTIL_StringToVector@@YAXPAMPBD@Z		; UTIL_StringToVector
EXTRN	_atof:NEAR
EXTRN	_strcpy:NEAR
;	COMDAT ?UTIL_StringToVector@@YAXPAMPBD@Z
_TEXT	SEGMENT
_pVector$ = 8
_pString$ = 12
_pstr$ = -4
_pfront$ = -8
_tempString$ = -136
_j$ = -140
?UTIL_StringToVector@@YAXPAMPBD@Z PROC NEAR		; UTIL_StringToVector, COMDAT

; 2113 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi

; 2114 : 	char *pstr, *pfront, tempString[128];
; 2115 : 	int	j;
; 2116 : 
; 2117 : 	strcpy( tempString, pString );

	mov	eax, DWORD PTR _pString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempString$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2118 : 	pstr = pfront = tempString;

	lea	edx, DWORD PTR _tempString$[ebp]
	mov	DWORD PTR _pfront$[ebp], edx
	mov	eax, DWORD PTR _pfront$[ebp]
	mov	DWORD PTR _pstr$[ebp], eax

; 2119 : 
; 2120 : 	for ( j = 0; j < 3; j++ )			// lifted from pr_edict.c

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L41673
$L41674:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L41673:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $L41675

; 2122 : 		pVector[j] = atof( pfront );

	mov	edx, DWORD PTR _pfront$[ebp]
	push	edx
	call	_atof
	add	esp, 4
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pVector$[ebp]
	fstp	DWORD PTR [ecx+eax*4]
$L41677:

; 2123 : 
; 2124 : 		while ( *pstr && *pstr != ' ' )

	mov	edx, DWORD PTR _pstr$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L41678
	mov	ecx, DWORD PTR _pstr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $L41678

; 2125 : 			pstr++;

	mov	eax, DWORD PTR _pstr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pstr$[ebp], eax
	jmp	SHORT $L41677
$L41678:

; 2126 : 		if (!*pstr)

	mov	ecx, DWORD PTR _pstr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L41679

; 2127 : 			break;

	jmp	SHORT $L41675
$L41679:

; 2128 : 		pstr++;

	mov	eax, DWORD PTR _pstr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pstr$[ebp], eax

; 2129 : 		pfront = pstr;

	mov	ecx, DWORD PTR _pstr$[ebp]
	mov	DWORD PTR _pfront$[ebp], ecx

; 2130 : 	}

	jmp	SHORT $L41674
$L41675:

; 2131 : 	if (j < 2)

	cmp	DWORD PTR _j$[ebp], 2
	jge	SHORT $L41683

; 2133 : 		/*
; 2134 : 		ALERT( at_error, "Bad field in entity!! %s:%s == \"%s\"\n",
; 2135 : 			pkvd->szClassName, pkvd->szKeyName, pkvd->szValue );
; 2136 : 		*/
; 2137 : 		for (j = j+1;j < 3; j++)

	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	jmp	SHORT $L41681
$L41682:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L41681:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $L41683

; 2138 : 			pVector[j] = 0;

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pVector$[ebp]
	mov	DWORD PTR [edx+ecx*4], 0
	jmp	SHORT $L41682
$L41683:

; 2140 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_StringToVector@@YAXPAMPBD@Z ENDP			; UTIL_StringToVector
_TEXT	ENDS
PUBLIC	?UTIL_StringToIntArray@@YAXPAHHPBD@Z		; UTIL_StringToIntArray
EXTRN	_atoi:NEAR
;	COMDAT ?UTIL_StringToIntArray@@YAXPAHHPBD@Z
_TEXT	SEGMENT
_pVector$ = 8
_count$ = 12
_pString$ = 16
_pstr$ = -4
_pfront$ = -8
_tempString$ = -136
_j$ = -140
?UTIL_StringToIntArray@@YAXPAHHPBD@Z PROC NEAR		; UTIL_StringToIntArray, COMDAT

; 2144 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi

; 2145 : 	char *pstr, *pfront, tempString[128];
; 2146 : 	int	j;
; 2147 : 
; 2148 : 	strcpy( tempString, pString );

	mov	eax, DWORD PTR _pString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempString$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2149 : 	pstr = pfront = tempString;

	lea	edx, DWORD PTR _tempString$[ebp]
	mov	DWORD PTR _pfront$[ebp], edx
	mov	eax, DWORD PTR _pfront$[ebp]
	mov	DWORD PTR _pstr$[ebp], eax

; 2150 : 
; 2151 : 	for ( j = 0; j < count; j++ )			// lifted from pr_edict.c

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L41693
$L41694:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L41693:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $L41695

; 2153 : 		pVector[j] = atoi( pfront );

	mov	eax, DWORD PTR _pfront$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pVector$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$L41697:

; 2154 : 
; 2155 : 		while ( *pstr && *pstr != ' ' )

	mov	eax, DWORD PTR _pstr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L41698
	mov	edx, DWORD PTR _pstr$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $L41698

; 2156 : 			pstr++;

	mov	ecx, DWORD PTR _pstr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pstr$[ebp], ecx
	jmp	SHORT $L41697
$L41698:

; 2157 : 		if (!*pstr)

	mov	edx, DWORD PTR _pstr$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $L41699

; 2158 : 			break;

	jmp	SHORT $L41695
$L41699:

; 2159 : 		pstr++;

	mov	ecx, DWORD PTR _pstr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pstr$[ebp], ecx

; 2160 : 		pfront = pstr;

	mov	edx, DWORD PTR _pstr$[ebp]
	mov	DWORD PTR _pfront$[ebp], edx

; 2161 : 	}

	jmp	SHORT $L41694
$L41695:

; 2162 : 
; 2163 : 	for ( j++; j < count; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L41700
$L41701:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L41700:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $L41702

; 2165 : 		pVector[j] = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pVector$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 2166 : 	}

	jmp	SHORT $L41701
$L41702:

; 2167 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_StringToIntArray@@YAXPAHHPBD@Z ENDP		; UTIL_StringToIntArray
_TEXT	ENDS
PUBLIC	?UTIL_ClampVectorToBox@@YA?AVVector@@ABV1@0@Z	; UTIL_ClampVectorToBox
;	COMDAT ?UTIL_ClampVectorToBox@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT
_input$ = 12
_clampSize$ = 16
___$ReturnUdt$ = 8
_sourceVector$ = -12
$T44018 = -24
?UTIL_ClampVectorToBox@@YA?AVVector@@ABV1@0@Z PROC NEAR	; UTIL_ClampVectorToBox, COMDAT

; 2170 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 2171 : 	Vector sourceVector = input;

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sourceVector$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2172 : 
; 2173 : 	if ( sourceVector.x > clampSize.x )

	mov	ecx, DWORD PTR _clampSize$[ebp]
	fld	DWORD PTR _sourceVector$[ebp]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41709

; 2174 : 		sourceVector.x -= clampSize.x;

	mov	edx, DWORD PTR _clampSize$[ebp]
	fld	DWORD PTR _sourceVector$[ebp]
	fsub	DWORD PTR [edx]
	fstp	DWORD PTR _sourceVector$[ebp]

; 2175 : 	else if ( sourceVector.x < -clampSize.x )

	jmp	SHORT $L41712
$L41709:
	mov	eax, DWORD PTR _clampSize$[ebp]
	fld	DWORD PTR [eax]
	fchs
	fcomp	DWORD PTR _sourceVector$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41711

; 2176 : 		sourceVector.x += clampSize.x;

	mov	ecx, DWORD PTR _clampSize$[ebp]
	fld	DWORD PTR _sourceVector$[ebp]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR _sourceVector$[ebp]

; 2177 : 	else

	jmp	SHORT $L41712
$L41711:

; 2178 : 		sourceVector.x = 0;

	mov	DWORD PTR _sourceVector$[ebp], 0
$L41712:

; 2179 : 
; 2180 : 	if ( sourceVector.y > clampSize.y )

	mov	edx, DWORD PTR _clampSize$[ebp]
	fld	DWORD PTR _sourceVector$[ebp+4]
	fcomp	DWORD PTR [edx+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41713

; 2181 : 		sourceVector.y -= clampSize.y;

	mov	eax, DWORD PTR _clampSize$[ebp]
	fld	DWORD PTR _sourceVector$[ebp+4]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR _sourceVector$[ebp+4]

; 2182 : 	else if ( sourceVector.y < -clampSize.y )

	jmp	SHORT $L41716
$L41713:
	mov	ecx, DWORD PTR _clampSize$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	fcomp	DWORD PTR _sourceVector$[ebp+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41715

; 2183 : 		sourceVector.y += clampSize.y;

	mov	edx, DWORD PTR _clampSize$[ebp]
	fld	DWORD PTR _sourceVector$[ebp+4]
	fadd	DWORD PTR [edx+4]
	fstp	DWORD PTR _sourceVector$[ebp+4]

; 2184 : 	else

	jmp	SHORT $L41716
$L41715:

; 2185 : 		sourceVector.y = 0;

	mov	DWORD PTR _sourceVector$[ebp+4], 0
$L41716:

; 2186 : 	
; 2187 : 	if ( sourceVector.z > clampSize.z )

	mov	eax, DWORD PTR _clampSize$[ebp]
	fld	DWORD PTR _sourceVector$[ebp+8]
	fcomp	DWORD PTR [eax+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41717

; 2188 : 		sourceVector.z -= clampSize.z;

	mov	ecx, DWORD PTR _clampSize$[ebp]
	fld	DWORD PTR _sourceVector$[ebp+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _sourceVector$[ebp+8]

; 2189 : 	else if ( sourceVector.z < -clampSize.z )

	jmp	SHORT $L41720
$L41717:
	mov	edx, DWORD PTR _clampSize$[ebp]
	fld	DWORD PTR [edx+8]
	fchs
	fcomp	DWORD PTR _sourceVector$[ebp+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41719

; 2190 : 		sourceVector.z += clampSize.z;

	mov	eax, DWORD PTR _clampSize$[ebp]
	fld	DWORD PTR _sourceVector$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _sourceVector$[ebp+8]

; 2191 : 	else

	jmp	SHORT $L41720
$L41719:

; 2192 : 		sourceVector.z = 0;

	mov	DWORD PTR _sourceVector$[ebp+8], 0
$L41720:

; 2193 : 
; 2194 : 	return sourceVector.Normalize();

	lea	ecx, DWORD PTR $T44018[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sourceVector$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2195 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_ClampVectorToBox@@YA?AVVector@@ABV1@0@Z ENDP	; UTIL_ClampVectorToBox
_TEXT	ENDS
PUBLIC	?UTIL_WaterLevel@@YAMABVVector@@MM@Z		; UTIL_WaterLevel
PUBLIC	__real@8@40008000000000000000
;	COMDAT __real@8@40008000000000000000
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
__real@8@40008000000000000000 DQ 04000000000000000r ; 2
CONST	ENDS
;	COMDAT ?UTIL_WaterLevel@@YAMABVVector@@MM@Z
_TEXT	SEGMENT
_position$ = 8
_minz$ = 12
_maxz$ = 16
_midUp$ = -12
_diff$ = -16
?UTIL_WaterLevel@@YAMABVVector@@MM@Z PROC NEAR		; UTIL_WaterLevel, COMDAT

; 2199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 2200 : 	Vector midUp = position;

	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	lea	ecx, DWORD PTR _midUp$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2201 : 	midUp.z = minz;

	mov	ecx, DWORD PTR _minz$[ebp]
	mov	DWORD PTR _midUp$[ebp+8], ecx

; 2202 : 
; 2203 : 	if (UTIL_PointContents(midUp) != CONTENTS_WATER)

	lea	edx, DWORD PTR _midUp$[ebp]
	push	edx
	call	?UTIL_PointContents@@YAHABVVector@@@Z	; UTIL_PointContents
	add	esp, 4
	cmp	eax, -3					; fffffffdH
	je	SHORT $L41728

; 2204 : 		return minz;

	fld	DWORD PTR _minz$[ebp]
	jmp	SHORT $L41726
$L41728:

; 2205 : 
; 2206 : 	midUp.z = maxz;

	mov	eax, DWORD PTR _maxz$[ebp]
	mov	DWORD PTR _midUp$[ebp+8], eax

; 2207 : 	if (UTIL_PointContents(midUp) == CONTENTS_WATER)

	lea	ecx, DWORD PTR _midUp$[ebp]
	push	ecx
	call	?UTIL_PointContents@@YAHABVVector@@@Z	; UTIL_PointContents
	add	esp, 4
	cmp	eax, -3					; fffffffdH
	jne	SHORT $L41729

; 2208 : 		return maxz;

	fld	DWORD PTR _maxz$[ebp]
	jmp	SHORT $L41726
$L41729:

; 2209 : 
; 2210 : 	float diff = maxz - minz;

	fld	DWORD PTR _maxz$[ebp]
	fsub	DWORD PTR _minz$[ebp]
	fstp	DWORD PTR _diff$[ebp]
$L41732:

; 2211 : 	while (diff > 1.0)

	fld	DWORD PTR _diff$[ebp]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41733

; 2213 : 		midUp.z = minz + diff/2.0;

	fld	DWORD PTR _minz$[ebp]
	fld	DWORD PTR _diff$[ebp]
	fdiv	QWORD PTR __real@8@40008000000000000000
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _midUp$[ebp+8]

; 2214 : 		if (UTIL_PointContents(midUp) == CONTENTS_WATER)

	lea	edx, DWORD PTR _midUp$[ebp]
	push	edx
	call	?UTIL_PointContents@@YAHABVVector@@@Z	; UTIL_PointContents
	add	esp, 4
	cmp	eax, -3					; fffffffdH
	jne	SHORT $L41734

; 2216 : 			minz = midUp.z;

	mov	eax, DWORD PTR _midUp$[ebp+8]
	mov	DWORD PTR _minz$[ebp], eax

; 2218 : 		else

	jmp	SHORT $L41735
$L41734:

; 2220 : 			maxz = midUp.z;

	mov	ecx, DWORD PTR _midUp$[ebp+8]
	mov	DWORD PTR _maxz$[ebp], ecx
$L41735:

; 2222 : 		diff = maxz - minz;

	fld	DWORD PTR _maxz$[ebp]
	fsub	DWORD PTR _minz$[ebp]
	fstp	DWORD PTR _diff$[ebp]

; 2223 : 	}

	jmp	SHORT $L41732
$L41733:

; 2224 : 
; 2225 : 	return midUp.z;

	fld	DWORD PTR _midUp$[ebp+8]
$L41726:

; 2226 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_WaterLevel@@YAMABVVector@@MM@Z ENDP		; UTIL_WaterLevel
_TEXT	ENDS
PUBLIC	?UTIL_Bubbles@@YAXVVector@@0H@Z			; UTIL_Bubbles
PUBLIC	__real@4@40098000000000000000
EXTRN	?g_sModelIndexBubbles@@3FA:WORD			; g_sModelIndexBubbles
;	COMDAT __real@4@40098000000000000000
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
__real@4@40098000000000000000 DD 044800000r	; 1024
CONST	ENDS
;	COMDAT ?UTIL_Bubbles@@YAXVVector@@0H@Z
_TEXT	SEGMENT
_mins$ = 8
_maxs$ = 20
_count$ = 32
_mid$ = -12
_flHeight$ = -16
$T44025 = -28
$T44026 = -40
?UTIL_Bubbles@@YAXVVector@@0H@Z PROC NEAR		; UTIL_Bubbles, COMDAT

; 2232 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 2233 : 	Vector mid =  (mins + maxs) * 0.5;

	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T44026[ebp]
	push	eax
	lea	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T44025[ebp]
	push	edx
	lea	ecx, DWORD PTR _mins$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _mid$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2234 : 
; 2235 : 	float flHeight = UTIL_WaterLevel( mid,  mid.z, mid.z + 1024 );

	fld	DWORD PTR _mid$[ebp+8]
	fadd	DWORD PTR __real@4@40098000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _mid$[ebp+8]
	push	eax
	lea	ecx, DWORD PTR _mid$[ebp]
	push	ecx
	call	?UTIL_WaterLevel@@YAMABVVector@@MM@Z	; UTIL_WaterLevel
	add	esp, 12					; 0000000cH
	fst	DWORD PTR _flHeight$[ebp]

; 2236 : 	flHeight = flHeight - mins.z;

	fsub	DWORD PTR _mins$[ebp+8]
	fstp	DWORD PTR _flHeight$[ebp]

; 2237 : 
; 2238 : 	MESSAGE_BEGIN( MSG_PAS, SVC_TEMPENTITY, mid );

	push	0
	lea	ecx, DWORD PTR _mid$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	push	23					; 00000017H
	push	5
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 2239 : 		WRITE_BYTE( TE_BUBBLES );

	push	113					; 00000071H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2240 : 		WRITE_COORD( mins.x );	// mins

	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2241 : 		WRITE_COORD( mins.y );

	mov	eax, DWORD PTR _mins$[ebp+4]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2242 : 		WRITE_COORD( mins.z );

	mov	ecx, DWORD PTR _mins$[ebp+8]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2243 : 		WRITE_COORD( maxs.x );	// maxz

	mov	edx, DWORD PTR _maxs$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2244 : 		WRITE_COORD( maxs.y );

	mov	eax, DWORD PTR _maxs$[ebp+4]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2245 : 		WRITE_COORD( maxs.z );

	mov	ecx, DWORD PTR _maxs$[ebp+8]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2246 : 		WRITE_COORD( flHeight );			// height

	mov	edx, DWORD PTR _flHeight$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2247 : 		WRITE_SHORT( g_sModelIndexBubbles );

	movsx	eax, WORD PTR ?g_sModelIndexBubbles@@3FA ; g_sModelIndexBubbles
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 2248 : 		WRITE_BYTE( count ); // count

	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2249 : 		WRITE_COORD( 8 ); // speed

	push	1090519040				; 41000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2250 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 2251 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_Bubbles@@YAXVVector@@0H@Z ENDP			; UTIL_Bubbles
_TEXT	ENDS
PUBLIC	?UTIL_BubbleTrail@@YAXVVector@@0H@Z		; UTIL_BubbleTrail
PUBLIC	__real@4@40078000000000000000
;	COMDAT __real@4@40078000000000000000
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
__real@4@40078000000000000000 DD 043800000r	; 256
CONST	ENDS
;	COMDAT ?UTIL_BubbleTrail@@YAXVVector@@0H@Z
_TEXT	SEGMENT
_from$ = 8
_to$ = 20
_count$ = 32
_flHeight$ = -4
?UTIL_BubbleTrail@@YAXVVector@@0H@Z PROC NEAR		; UTIL_BubbleTrail, COMDAT

; 2254 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2255 : 	float flHeight = UTIL_WaterLevel( from,  from.z, from.z + 256 );

	fld	DWORD PTR _from$[ebp+8]
	fadd	DWORD PTR __real@4@40078000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _from$[ebp+8]
	push	eax
	lea	ecx, DWORD PTR _from$[ebp]
	push	ecx
	call	?UTIL_WaterLevel@@YAMABVVector@@MM@Z	; UTIL_WaterLevel
	add	esp, 12					; 0000000cH
	fst	DWORD PTR _flHeight$[ebp]

; 2256 : 	flHeight = flHeight - from.z;

	fsub	DWORD PTR _from$[ebp+8]
	fstp	DWORD PTR _flHeight$[ebp]

; 2257 : 
; 2258 : 	if (flHeight < 8)

	fld	DWORD PTR _flHeight$[ebp]
	fcomp	DWORD PTR __real@4@40028000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41751

; 2260 : 		flHeight = UTIL_WaterLevel( to,  to.z, to.z + 256 );

	fld	DWORD PTR _to$[ebp+8]
	fadd	DWORD PTR __real@4@40078000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _to$[ebp+8]
	push	edx
	lea	eax, DWORD PTR _to$[ebp]
	push	eax
	call	?UTIL_WaterLevel@@YAMABVVector@@MM@Z	; UTIL_WaterLevel
	add	esp, 12					; 0000000cH
	fst	DWORD PTR _flHeight$[ebp]

; 2261 : 		flHeight = flHeight - to.z;

	fsub	DWORD PTR _to$[ebp+8]
	fstp	DWORD PTR _flHeight$[ebp]

; 2262 : 		if (flHeight < 8)

	fld	DWORD PTR _flHeight$[ebp]
	fcomp	DWORD PTR __real@4@40028000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41752

; 2263 : 			return;

	jmp	$L41749
$L41752:

; 2264 : 
; 2265 : 		// UNDONE: do a ploink sound
; 2266 : 		flHeight = flHeight + to.z - from.z;

	fld	DWORD PTR _flHeight$[ebp]
	fadd	DWORD PTR _to$[ebp+8]
	fsub	DWORD PTR _from$[ebp+8]
	fstp	DWORD PTR _flHeight$[ebp]
$L41751:

; 2268 : 
; 2269 : 	if (count > 255) 

	cmp	DWORD PTR _count$[ebp], 255		; 000000ffH
	jle	SHORT $L41753

; 2270 : 		count = 255;

	mov	DWORD PTR _count$[ebp], 255		; 000000ffH
$L41753:

; 2271 : 
; 2272 : 	MESSAGE_BEGIN( MSG_BROADCAST, SVC_TEMPENTITY );

	push	0
	push	0
	push	23					; 00000017H
	push	0
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 2273 : 		WRITE_BYTE( TE_BUBBLETRAIL );

	push	114					; 00000072H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2274 : 		WRITE_COORD( from.x );	// mins

	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2275 : 		WRITE_COORD( from.y );

	mov	edx, DWORD PTR _from$[ebp+4]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2276 : 		WRITE_COORD( from.z );

	mov	eax, DWORD PTR _from$[ebp+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2277 : 		WRITE_COORD( to.x );	// maxz

	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2278 : 		WRITE_COORD( to.y );

	mov	edx, DWORD PTR _to$[ebp+4]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2279 : 		WRITE_COORD( to.z );

	mov	eax, DWORD PTR _to$[ebp+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2280 : 		WRITE_COORD( flHeight );			// height

	mov	ecx, DWORD PTR _flHeight$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2281 : 		WRITE_SHORT( g_sModelIndexBubbles );

	movsx	edx, WORD PTR ?g_sModelIndexBubbles@@3FA ; g_sModelIndexBubbles
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 2282 : 		WRITE_BYTE( count ); // count

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2283 : 		WRITE_COORD( 8 ); // speed

	push	1090519040				; 41000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 2284 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41749:

; 2285 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_BubbleTrail@@YAXVVector@@0H@Z ENDP		; UTIL_BubbleTrail
_TEXT	ENDS
PUBLIC	?UTIL_SetMovedir@@YAXPAVCBaseEntity@@@Z		; UTIL_SetMovedir
PUBLIC	?SetMoveDir@CBaseEntity@@QAEXABVVector@@@Z	; CBaseEntity::SetMoveDir
;	COMDAT ?UTIL_SetMovedir@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T44035 = -24
$T44036 = -36
$T44037 = -48
$T44038 = -60
_pEnt$ = 8
_angles$ = -12
?UTIL_SetMovedir@@YAXPAVCBaseEntity@@@Z PROC NEAR	; UTIL_SetMovedir, COMDAT

; 2292 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 2293 : 	Vector angles = pEnt->pev->angles;

	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 80					; 00000050H
	push	ecx
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2294 : 	pEnt->pev->angles = g_vecZero;

	mov	edx, DWORD PTR _pEnt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [eax+8], ecx

; 2295 : 
; 2296 : 	if( angles == Vector( 0, -1, 0 ))

	push	0
	push	-1082130432				; bf800000H
	push	0
	lea	ecx, DWORD PTR $T44035[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L41759

; 2298 : 		pEnt->SetMoveDir( Vector( 0, 0, 1 ));

	push	1065353216				; 3f800000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T44036[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?SetMoveDir@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetMoveDir

; 2300 : 	else if( angles == Vector( 0, -2, 0 ))

	jmp	SHORT $L41765
$L41759:
	push	0
	push	-1073741824				; c0000000H
	push	0
	lea	ecx, DWORD PTR $T44037[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L41763

; 2302 : 		pEnt->SetMoveDir( Vector( 0, 0, -1 ));

	push	-1082130432				; bf800000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T44038[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?SetMoveDir@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetMoveDir

; 2304 : 	else

	jmp	SHORT $L41765
$L41763:

; 2306 : 		UTIL_MakeVectors( angles );

	lea	edx, DWORD PTR _angles$[ebp]
	push	edx
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 2307 : 		pEnt->SetMoveDir( gpGlobals->v_forward );

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?SetMoveDir@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetMoveDir
$L41765:

; 2309 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_SetMovedir@@YAXPAVCBaseEntity@@@Z ENDP		; UTIL_SetMovedir
_TEXT	ENDS
;	COMDAT ?SetMoveDir@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4
_v$ = 8
?SetMoveDir@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR	; CBaseEntity::SetMoveDir, COMDAT

; 389  : 	void SetMoveDir( const Vector& v ) { pev->movedir = v; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMoveDir@CBaseEntity@@QAEXABVVector@@@Z ENDP		; CBaseEntity::SetMoveDir
_TEXT	ENDS
EXTRN	?UpdateOnRemove@CBaseEntity@@QAEXXZ:NEAR	; CBaseEntity::UpdateOnRemove
;	COMDAT ?UTIL_Remove@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
?UTIL_Remove@@YAXPAVCBaseEntity@@@Z PROC NEAR		; UTIL_Remove, COMDAT

; 2312 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2313 : 	if ( !pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L41769

; 2314 : 		return;

	jmp	SHORT $L41768
$L41769:

; 2315 : 
; 2316 : 	pEntity->UpdateOnRemove();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?UpdateOnRemove@CBaseEntity@@QAEXXZ	; CBaseEntity::UpdateOnRemove

; 2317 : 	pEntity->pev->flags |= FL_KILLME;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 2318 : 	pEntity->pev->targetname = 0;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+460], 0
$L41768:

; 2319 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_Remove@@YAXPAVCBaseEntity@@@Z ENDP		; UTIL_Remove
_TEXT	ENDS
PUBLIC	?UTIL_IsValidEntity@@YAHPAUedict_s@@@Z		; UTIL_IsValidEntity
;	COMDAT ?UTIL_IsValidEntity@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?UTIL_IsValidEntity@@YAHPAUedict_s@@@Z PROC NEAR	; UTIL_IsValidEntity, COMDAT

; 2323 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2324 : 	if ( !pent || pent->free || (pent->v.flags & FL_KILLME) )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L41774
	mov	eax, DWORD PTR _pent$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L41774
	mov	ecx, DWORD PTR _pent$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 1073741824				; 40000000H
	test	edx, edx
	je	SHORT $L41773
$L41774:

; 2325 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L41772
$L41773:

; 2326 : 	return TRUE;

	mov	eax, 1
$L41772:

; 2327 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_IsValidEntity@@YAHPAUedict_s@@@Z ENDP		; UTIL_IsValidEntity
_TEXT	ENDS
PUBLIC	?UTIL_PrecacheOther@@YAXPBD@Z			; UTIL_PrecacheOther
PUBLIC	??_C@_0CA@LCCD@NULL?5Ent?5in?5UTIL_PrecacheOther?6?$AA@ ; `string'
EXTRN	?CreateEntityByName@@YAPAVCBaseEntity@@PBDPAUentvars_s@@@Z:NEAR ; CreateEntityByName
;	COMDAT ??_C@_0CA@LCCD@NULL?5Ent?5in?5UTIL_PrecacheOther?6?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0CA@LCCD@NULL?5Ent?5in?5UTIL_PrecacheOther?6?$AA@ DB 'NULL Ent in U'
	DB	'TIL_PrecacheOther', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?UTIL_PrecacheOther@@YAXPBD@Z
_TEXT	SEGMENT
_szClassname$ = 8
_pEntity$ = -4
?UTIL_PrecacheOther@@YAXPBD@Z PROC NEAR			; UTIL_PrecacheOther, COMDAT

; 2331 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2332 : 	CBaseEntity *pEntity = CreateEntityByName( szClassname );

	push	0
	mov	eax, DWORD PTR _szClassname$[ebp]
	push	eax
	call	?CreateEntityByName@@YAPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CreateEntityByName
	add	esp, 8
	mov	DWORD PTR _pEntity$[ebp], eax

; 2333 : 
; 2334 : 	if( !pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L41779

; 2336 : 		ALERT ( at_console, "NULL Ent in UTIL_PrecacheOther\n" );

	push	OFFSET FLAT:??_C@_0CA@LCCD@NULL?5Ent?5in?5UTIL_PrecacheOther?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2337 : 		return;

	jmp	SHORT $L41777
$L41779:

; 2339 : 
; 2340 : 	pEntity->Precache( );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+8]

; 2341 : 	REMOVE_ENTITY( pEntity->edict( ));

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+88
	add	esp, 4
$L41777:

; 2342 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_PrecacheOther@@YAXPBD@Z ENDP			; UTIL_PrecacheOther
_TEXT	ENDS
PUBLIC	?UTIL_PrecacheSound@@YAHPBD@Z			; UTIL_PrecacheSound
;	COMDAT ?UTIL_PrecacheSound@@YAHH@Z
_TEXT	SEGMENT
_s$ = 8
?UTIL_PrecacheSound@@YAHH@Z PROC NEAR			; UTIL_PrecacheSound, COMDAT

; 2345 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2346 : 	return UTIL_PrecacheSound( STRING( s ));

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4

; 2347 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_PrecacheSound@@YAHH@Z ENDP			; UTIL_PrecacheSound
_TEXT	ENDS
PUBLIC	??_C@_0CK@HEKC@UTIL_PrecacheSound?3?5sound?5not?5sp@ ; `string'
PUBLIC	??_C@_08CIGF@sound?1?$CFs?$AA@			; `string'
PUBLIC	??_C@_03JAAL@wav?$AA@				; `string'
PUBLIC	??_C@_03FMPB@mp3?$AA@				; `string'
PUBLIC	??_C@_0BH@LGPK@sound?5?$CC?$CFs?$CC?5not?5found?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@KEDF@invalid?5name?5?$CC?$CFs?$CC?$CB?6?$AA@ ; `string'
EXTRN	?UTIL_FileExtension@@YAPBDPBD@Z:NEAR		; UTIL_FileExtension
EXTRN	?Q_snprintf@@YAHPADIPBDZZ:NEAR			; Q_snprintf
;	COMDAT ??_C@_0CK@HEKC@UTIL_PrecacheSound?3?5sound?5not?5sp@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0CK@HEKC@UTIL_PrecacheSound?3?5sound?5not?5sp@ DB 'UTIL_PrecacheSou'
	DB	'nd: sound not specified!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CIGF@sound?1?$CFs?$AA@
CONST	SEGMENT
??_C@_08CIGF@sound?1?$CFs?$AA@ DB 'sound/%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JAAL@wav?$AA@
CONST	SEGMENT
??_C@_03JAAL@wav?$AA@ DB 'wav', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FMPB@mp3?$AA@
CONST	SEGMENT
??_C@_03FMPB@mp3?$AA@ DB 'mp3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LGPK@sound?5?$CC?$CFs?$CC?5not?5found?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BH@LGPK@sound?5?$CC?$CFs?$CC?5not?5found?$CB?6?$AA@ DB 'sound "%s"'
	DB	' not found!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KEDF@invalid?5name?5?$CC?$CFs?$CC?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BE@KEDF@invalid?5name?5?$CC?$CFs?$CC?$CB?6?$AA@ DB 'invalid name "'
	DB	'%s"!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?UTIL_PrecacheSound@@YAHPBD@Z
_TEXT	SEGMENT
_s$ = 8
_path$ = -256
_iCompare$ = -260
_ext$ = -264
?UTIL_PrecacheSound@@YAHPBD@Z PROC NEAR			; UTIL_PrecacheSound, COMDAT

; 2350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	push	ebx
	push	esi
	push	edi

; 2351 : 	if( !s || !*s )

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $L41788
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L41787
$L41788:

; 2353 : 		ALERT( at_warning, "UTIL_PrecacheSound: sound not specified!\n" );

	push	OFFSET FLAT:??_C@_0CK@HEKC@UTIL_PrecacheSound?3?5sound?5not?5sp@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2354 : 		return MAKE_STRING( "common/null.wav" ); // set null sound

	push	OFFSET FLAT:??_C@_0BA@LNFJ@common?1null?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	jmp	$L41786
$L41787:

; 2356 : 
; 2357 : 	if( *s == '!' )

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 33					; 00000021H
	jne	SHORT $L41790

; 2359 : 		// sentence - just make string
; 2360 :           	return MAKE_STRING( s );

	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	jmp	$L41786
$L41790:

; 2364 : 	
; 2365 : 	// NOTE: Engine function as predicted for sound folder
; 2366 : 	// But COMPARE_FILE_TIME don't known about this. Set it manualy
; 2367 : 	Q_snprintf( path, sizeof( path ), "sound/%s", s );

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08CIGF@sound?1?$CFs?$AA@ ; `string'
	push	256					; 00000100H
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 2368 : 
; 2369 : 	int iCompare;
; 2370 : 
; 2371 : 	// verify file exists
; 2372 : 	// g-cont. idea! use COMPARE_FILE_TIME instead of LOAD_FILE_FOR_ME
; 2373 : 	if( COMPARE_FILE_TIME( path, path, &iCompare ))

	lea	ecx, DWORD PTR _iCompare$[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+392
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L41794

; 2375 : 		g_engfuncs.pfnPrecacheSound( s );

	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 2376 : 		return MAKE_STRING( s );

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	jmp	SHORT $L41786
$L41794:

; 2378 : 
; 2379 : 	const char *ext = UTIL_FileExtension( s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?UTIL_FileExtension@@YAPBDPBD@Z		; UTIL_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$[ebp], eax

; 2380 : 
; 2381 : 	if( FStrEq( ext, "wav" ) || FStrEq( ext, "mp3" ))

	push	OFFSET FLAT:??_C@_03JAAL@wav?$AA@	; `string'
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L41797
	push	OFFSET FLAT:??_C@_03FMPB@mp3?$AA@	; `string'
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L41796
$L41797:

; 2382 : 		ALERT( at_warning, "sound \"%s\" not found!\n", path );

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BH@LGPK@sound?5?$CC?$CFs?$CC?5not?5found?$CB?6?$AA@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2383 : 	else ALERT( at_error, "invalid name \"%s\"!\n", s );

	jmp	SHORT $L41801
$L41796:
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BE@KEDF@invalid?5name?5?$CC?$CFs?$CC?$CB?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L41801:

; 2384 : 
; 2385 : 	return MAKE_STRING( "common/null.wav" ); // set null sound

	push	OFFSET FLAT:??_C@_0BA@LNFJ@common?1null?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
$L41786:

; 2386 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_PrecacheSound@@YAHPBD@Z ENDP			; UTIL_PrecacheSound
_TEXT	ENDS
PUBLIC	?UTIL_PrecacheMovie@@YAGPBDH@Z			; UTIL_PrecacheMovie
PUBLIC	?UTIL_PrecacheMovie@@YAGHH@Z			; UTIL_PrecacheMovie
;	COMDAT ?UTIL_PrecacheMovie@@YAGHH@Z
_TEXT	SEGMENT
_iString$ = 8
_allow_sound$ = 12
?UTIL_PrecacheMovie@@YAGHH@Z PROC NEAR			; UTIL_PrecacheMovie, COMDAT

; 2389 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2390 : 	return UTIL_PrecacheMovie( STRING( iString ), allow_sound );

	mov	eax, DWORD PTR _allow_sound$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iString$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?UTIL_PrecacheMovie@@YAGPBDH@Z		; UTIL_PrecacheMovie
	add	esp, 8

; 2391 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_PrecacheMovie@@YAGHH@Z ENDP			; UTIL_PrecacheMovie
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
PUBLIC	??_C@_08GNNL@media?1?$CFs?$AA@			; `string'
PUBLIC	??_C@_01FDHG@?$CK?$AA@				; `string'
PUBLIC	??_C@_04DCMN@?$CFs?$CFs?$AA@			; `string'
PUBLIC	??_C@_0CA@PCK@Warning?3?5video?5?$CI?$CFs?$CJ?5not?5found?$CB?6?$AA@ ; `string'
;	COMDAT ??_C@_00A@?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08GNNL@media?1?$CFs?$AA@
CONST	SEGMENT
??_C@_08GNNL@media?1?$CFs?$AA@ DB 'media/%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01FDHG@?$CK?$AA@
CONST	SEGMENT
??_C@_01FDHG@?$CK?$AA@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DCMN@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04DCMN@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PCK@Warning?3?5video?5?$CI?$CFs?$CJ?5not?5found?$CB?6?$AA@
CONST	SEGMENT
??_C@_0CA@PCK@Warning?3?5video?5?$CI?$CFs?$CJ?5not?5found?$CB?6?$AA@ DB 'W'
	DB	'arning: video (%s) not found!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?UTIL_PrecacheMovie@@YAGPBDH@Z
_TEXT	SEGMENT
_s$ = 8
_allow_sound$ = 12
_iCompare$ = -4
_path$ = -68
_temp$ = -132
?UTIL_PrecacheMovie@@YAGPBDH@Z PROC NEAR		; UTIL_PrecacheMovie, COMDAT

; 2394 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi

; 2395 : 	int iCompare;
; 2396 : 	char path[64], temp[64];
; 2397 : 
; 2398 : 	Q_snprintf( path, sizeof( path ), "media/%s", s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08GNNL@media?1?$CFs?$AA@ ; `string'
	push	64					; 00000040H
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 2399 : 	Q_snprintf( temp, sizeof( temp ), "%s%s", allow_sound ? "*" : "", s );

	cmp	DWORD PTR _allow_sound$[ebp], 0
	je	SHORT $L44055
	mov	DWORD PTR -136+[ebp], OFFSET FLAT:??_C@_01FDHG@?$CK?$AA@ ; `string'
	jmp	SHORT $L44056
$L44055:
	mov	DWORD PTR -136+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L44056:
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	eax, DWORD PTR -136+[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_04DCMN@?$CFs?$CFs?$AA@ ; `string'
	push	64					; 00000040H
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 20					; 00000014H

; 2400 : 
; 2401 : 	// verify file exists
; 2402 : 	// g-cont. idea! use COMPARE_FILE_TIME instead of LOAD_FILE_FOR_ME
; 2403 : 	if( COMPARE_FILE_TIME( path, path, &iCompare ))

	lea	edx, DWORD PTR _iCompare$[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+392
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L41817

; 2405 : 		return g_engfuncs.pfnPrecacheGeneric( temp );

	lea	edx, DWORD PTR _temp$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+448
	add	esp, 4
	jmp	SHORT $L41810
$L41817:

; 2407 : 
; 2408 : 	ALERT( at_console, "Warning: video (%s) not found!\n", path );

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CA@PCK@Warning?3?5video?5?$CI?$CFs?$CJ?5not?5found?$CB?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2409 : 
; 2410 : 	return 0;

	xor	ax, ax
$L41810:

; 2411 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_PrecacheMovie@@YAGPBDH@Z ENDP			; UTIL_PrecacheMovie
_TEXT	ENDS
PUBLIC	?UTIL_LogPrintf@@YAXPADZZ			; UTIL_LogPrintf
PUBLIC	??_C@_02DILL@?$CFs?$AA@				; `string'
_BSS	SEGMENT
_?string@?1??UTIL_LogPrintf@@YAXPADZZ@4PADA DB 0400H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_02DILL@?$CFs?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_02DILL@?$CFs?$AA@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ?UTIL_LogPrintf@@YAXPADZZ
_TEXT	SEGMENT
_fmt$ = 8
_argptr$ = -4
?UTIL_LogPrintf@@YAXPADZZ PROC NEAR			; UTIL_LogPrintf, COMDAT

; 2418 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2419 : 	va_list			argptr;
; 2420 : 	static char		string[1024];
; 2421 : 	
; 2422 : 	va_start ( argptr, fmt );

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _argptr$[ebp], eax

; 2423 : 	vsprintf ( string, fmt, argptr );

	mov	ecx, DWORD PTR _argptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fmt$[ebp]
	push	edx
	push	OFFSET FLAT:_?string@?1??UTIL_LogPrintf@@YAXPADZZ@4PADA
	call	_vsprintf
	add	esp, 12					; 0000000cH

; 2424 : 	va_end   ( argptr );

	mov	DWORD PTR _argptr$[ebp], 0

; 2425 : 
; 2426 : 	// Print to server console
; 2427 : 	ALERT( at_logged, "%s", string );

	push	OFFSET FLAT:_?string@?1??UTIL_LogPrintf@@YAXPADZZ@4PADA
	push	OFFSET FLAT:??_C@_02DILL@?$CFs?$AA@	; `string'
	push	5
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2428 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_LogPrintf@@YAXPADZZ ENDP				; UTIL_LogPrintf
_TEXT	ENDS
PUBLIC	?Normalize@Vector2D@@QBE?AV1@XZ			; Vector2D::Normalize
PUBLIC	?DotProduct@@YAMABVVector2D@@0@Z		; DotProduct
PUBLIC	?Make2D@Vector@@QBE?AVVector2D@@XZ		; Vector::Make2D
PUBLIC	?UTIL_DotPoints@@YAMABVVector@@00@Z		; UTIL_DotPoints
PUBLIC	??0Vector2D@@QAE@XZ				; Vector2D::Vector2D
;	COMDAT ?UTIL_DotPoints@@YAMABVVector@@00@Z
_TEXT	SEGMENT
$T44061 = -20
$T44062 = -28
$T44063 = -36
$T44064 = -44
_vecSrc$ = 8
_vecCheck$ = 12
_vecDir$ = 16
_vec2LOS$ = -8
?UTIL_DotPoints@@YAMABVVector@@00@Z PROC NEAR		; UTIL_DotPoints, COMDAT

; 2435 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 2436 : 	Vector2D	vec2LOS;

	lea	ecx, DWORD PTR _vec2LOS$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 2437 : 
; 2438 : 	vec2LOS = ( vecCheck - vecSrc ).Make2D();

	lea	eax, DWORD PTR $T44062[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T44061[ebp]
	push	edx
	mov	ecx, DWORD PTR _vecCheck$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Make2D@Vector@@QBE?AVVector2D@@XZ	; Vector::Make2D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vec2LOS$[ebp], ecx
	mov	DWORD PTR _vec2LOS$[ebp+4], edx

; 2439 : 	vec2LOS = vec2LOS.Normalize();

	lea	eax, DWORD PTR $T44063[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec2LOS$[ebp]
	call	?Normalize@Vector2D@@QBE?AV1@XZ		; Vector2D::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vec2LOS$[ebp], ecx
	mov	DWORD PTR _vec2LOS$[ebp+4], edx

; 2440 : 
; 2441 : 	return DotProduct (vec2LOS , ( vecDir.Make2D() ) );

	lea	eax, DWORD PTR $T44064[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecDir$[ebp]
	call	?Make2D@Vector@@QBE?AVVector2D@@XZ	; Vector::Make2D
	push	eax
	lea	ecx, DWORD PTR _vec2LOS$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector2D@@0@Z	; DotProduct
	add	esp, 8

; 2442 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_DotPoints@@YAMABVVector@@00@Z ENDP		; UTIL_DotPoints
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector2D@@QAE@XZ PROC NEAR				; Vector2D::Vector2D, COMDAT

; 57   : 	inline Vector2D(void) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector2D@@QAE@XZ ENDP				; Vector2D::Vector2D
_TEXT	ENDS
PUBLIC	?Length@Vector2D@@QBEMXZ			; Vector2D::Length
PUBLIC	??0Vector2D@@QAE@MM@Z				; Vector2D::Vector2D
;	COMDAT ?Normalize@Vector2D@@QBE?AV1@XZ
_TEXT	SEGMENT
$T44069 = -24
$T44070 = -32
___$ReturnUdt$ = 8
_this$ = -4
_vec2$ = -12
_flLen$ = -16
?Normalize@Vector2D@@QBE?AV1@XZ PROC NEAR		; Vector2D::Normalize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		Vector2D vec2;

	lea	ecx, DWORD PTR _vec2$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 105  : 
; 106  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector2D@@QBEMXZ		; Vector2D::Length
	fstp	DWORD PTR _flLen$[ebp]

; 107  : 		if ( flLen == 0 )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L24660

; 109  : 			return Vector2D( 0, 0 );

	push	0
	push	0
	lea	ecx, DWORD PTR $T44069[ebp]
	call	??0Vector2D@@QAE@MM@Z			; Vector2D::Vector2D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L24662
$L24660:

; 113  : 			flLen = 1 / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 114  : 			return Vector2D( x * flLen, y * flLen );

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T44070[ebp]
	call	??0Vector2D@@QAE@MM@Z			; Vector2D::Vector2D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L24662:

; 116  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector2D@@QBE?AV1@XZ ENDP			; Vector2D::Normalize
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT
_this$ = -4
_X$ = 8
_Y$ = 12
??0Vector2D@@QAE@MM@Z PROC NEAR				; Vector2D::Vector2D, COMDAT

; 58   : 	inline Vector2D(float X, float Y) { x = X; y = Y; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0Vector2D@@QAE@MM@Z ENDP				; Vector2D::Vector2D
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector2D@@QBEMXZ PROC NEAR			; Vector2D::Length, COMDAT

; 101  : 	inline float Length(void) const { return sqrt(x*x + y*y ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector2D@@QBEMXZ ENDP				; Vector2D::Length
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector2D@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProduct@@YAMABVVector2D@@0@Z PROC NEAR		; DotProduct, COMDAT

; 122  : inline float DotProduct(const Vector2D& a, const Vector2D& b) { return( a.x*b.x + a.y*b.y ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector2D@@0@Z ENDP			; DotProduct
_TEXT	ENDS
;	COMDAT ?Make2D@Vector@@QBE?AVVector2D@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_Vec2$ = -12
?Make2D@Vector@@QBE?AVVector2D@@XZ PROC NEAR		; Vector::Make2D, COMDAT

; 275  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 276  : 		Vector2D	Vec2;

	lea	ecx, DWORD PTR _Vec2$[ebp]
	call	??0Vector2D@@QAE@XZ			; Vector2D::Vector2D

; 277  : 		Vec2.x = x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _Vec2$[ebp], ecx

; 278  : 		Vec2.y = y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _Vec2$[ebp+4], eax

; 279  : 		return Vec2;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _Vec2$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _Vec2$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 280  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Make2D@Vector@@QBE?AVVector2D@@XZ ENDP			; Vector::Make2D
_TEXT	ENDS
PUBLIC	?UTIL_StripToken@@YAXPBDPAD@Z			; UTIL_StripToken
;	COMDAT ?UTIL_StripToken@@YAXPBDPAD@Z
_TEXT	SEGMENT
_pKey$ = 8
_pDest$ = 12
_i$ = -4
?UTIL_StripToken@@YAXPBDPAD@Z PROC NEAR			; UTIL_StripToken, COMDAT

; 2449 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2450 : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0
$L41847:

; 2451 : 
; 2452 : 	while ( pKey[i] && pKey[i] != '#' )

	mov	eax, DWORD PTR _pKey$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L41848
	mov	edx, DWORD PTR _pKey$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 35					; 00000023H
	je	SHORT $L41848

; 2454 : 		pDest[i] = pKey[i];

	mov	ecx, DWORD PTR _pDest$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pKey$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 2455 : 		i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 2456 : 	}

	jmp	SHORT $L41847
$L41848:

; 2457 : 	pDest[i] = 0;

	mov	edx, DWORD PTR _pDest$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], 0

; 2458 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_StripToken@@YAXPBDPAD@Z ENDP			; UTIL_StripToken
_TEXT	ENDS
PUBLIC	?UTIL_SetView@@YAXH@Z				; UTIL_SetView
PUBLIC	?UTIL_SetView@@YAXPAVCBaseEntity@@H@Z		; UTIL_SetView
;	COMDAT ?UTIL_SetView@@YAXH@Z
_TEXT	SEGMENT
_iszViewEntity$ = 8
_pPlayer$ = -4
?UTIL_SetView@@YAXH@Z PROC NEAR				; UTIL_SetView, COMDAT

; 2461 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2462 : 	if( g_pGameRules->IsMultiplayer())

	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $L41852

; 2463 : 		return;

	jmp	SHORT $L41851
$L41852:

; 2464 : 
; 2465 : 	CBaseEntity *pPlayer = UTIL_PlayerByIndex( 1 );

	push	1
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pPlayer$[ebp], eax

; 2466 : 	UTIL_SetView( pPlayer, iszViewEntity );

	mov	eax, DWORD PTR _iszViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	call	?UTIL_SetView@@YAXPAVCBaseEntity@@H@Z	; UTIL_SetView
	add	esp, 8
$L41851:

; 2467 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_SetView@@YAXH@Z ENDP				; UTIL_SetView
_TEXT	ENDS
PUBLIC	?UTIL_SetView@@YAXPAVCBaseEntity@@0@Z		; UTIL_SetView
;	COMDAT ?UTIL_SetView@@YAXPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_pActivator$ = 8
_iszViewEntity$ = 12
_pViewEnt$ = -4
?UTIL_SetView@@YAXPAVCBaseEntity@@H@Z PROC NEAR		; UTIL_SetView, COMDAT

; 2470 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2471 :           CBaseEntity *pViewEnt = NULL;

	mov	DWORD PTR _pViewEnt$[ebp], 0

; 2472 :           
; 2473 : 	if( iszViewEntity )

	cmp	DWORD PTR _iszViewEntity$[ebp], 0
	je	SHORT $L41860

; 2475 : 		pViewEnt = UTIL_FindEntityByString( NULL, "targetname", STRING( iszViewEntity ));

	mov	eax, DWORD PTR _iszViewEntity$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0L@PMO@targetname?$AA@ ; `string'
	push	0
	call	?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z ; UTIL_FindEntityByString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pViewEnt$[ebp], eax

; 2476 : 		if( !pViewEnt ) pViewEnt = UTIL_FindEntityByString( NULL, "classname", STRING( iszViewEntity ));

	cmp	DWORD PTR _pViewEnt$[ebp], 0
	jne	SHORT $L41860
	mov	ecx, DWORD PTR _iszViewEntity$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_09JDJH@classname?$AA@	; `string'
	push	0
	call	?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z ; UTIL_FindEntityByString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pViewEnt$[ebp], eax
$L41860:

; 2478 : 
; 2479 : 	UTIL_SetView( pActivator, pViewEnt );

	mov	edx, DWORD PTR _pViewEnt$[ebp]
	push	edx
	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	call	?UTIL_SetView@@YAXPAVCBaseEntity@@0@Z	; UTIL_SetView
	add	esp, 8

; 2480 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_SetView@@YAXPAVCBaseEntity@@H@Z ENDP		; UTIL_SetView
_TEXT	ENDS
PUBLIC	??_C@_0CD@CNK@UTIL_SetView?3?5pActivator?5?$DN?$DN?5NULL@ ; `string'
PUBLIC	??_C@_0CI@DCOA@UTIL_SetView?3?5pActivator?5not?5a?5p@ ; `string'
;	COMDAT ??_C@_0CD@CNK@UTIL_SetView?3?5pActivator?5?$DN?$DN?5NULL@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0CD@CNK@UTIL_SetView?3?5pActivator?5?$DN?$DN?5NULL@ DB 'UTIL_SetVie'
	DB	'w: pActivator == NULL!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DCOA@UTIL_SetView?3?5pActivator?5not?5a?5p@
CONST	SEGMENT
??_C@_0CI@DCOA@UTIL_SetView?3?5pActivator?5not?5a?5p@ DB 'UTIL_SetView: p'
	DB	'Activator not a player!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?UTIL_SetView@@YAXPAVCBaseEntity@@0@Z
_TEXT	SEGMENT
_pActivator$ = 8
_pViewEnt$ = 12
?UTIL_SetView@@YAXPAVCBaseEntity@@0@Z PROC NEAR		; UTIL_SetView, COMDAT

; 2483 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2484 : 	if( !pActivator || !pActivator->IsPlayer( ))

	cmp	DWORD PTR _pActivator$[ebp], 0
	je	SHORT $L41866
	mov	eax, DWORD PTR _pActivator$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActivator$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L41865
$L41866:

; 2486 : 		if( !pActivator )

	cmp	DWORD PTR _pActivator$[ebp], 0
	jne	SHORT $L41867

; 2487 : 			ALERT( at_error, "UTIL_SetView: pActivator == NULL!\n" );

	push	OFFSET FLAT:??_C@_0CD@CNK@UTIL_SetView?3?5pActivator?5?$DN?$DN?5NULL@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2488 : 		else ALERT( at_error, "UTIL_SetView: pActivator not a player!\n" ); 

	jmp	SHORT $L41869
$L41867:
	push	OFFSET FLAT:??_C@_0CI@DCOA@UTIL_SetView?3?5pActivator?5not?5a?5p@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L41869:

; 2489 : 		return;

	jmp	SHORT $L41864
$L41865:

; 2491 : 
; 2492 : 	if( !pViewEnt ) pViewEnt = pActivator;

	cmp	DWORD PTR _pViewEnt$[ebp], 0
	jne	SHORT $L41871
	mov	eax, DWORD PTR _pActivator$[ebp]
	mov	DWORD PTR _pViewEnt$[ebp], eax
$L41871:

; 2493 : 	SET_VIEW( pActivator->edict(), pViewEnt->edict() );

	mov	ecx, DWORD PTR _pViewEnt$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+368
	add	esp, 8
$L41864:

; 2494 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_SetView@@YAXPAVCBaseEntity@@0@Z ENDP		; UTIL_SetView
_TEXT	ENDS
PUBLIC	?UTIL_FindClientInPVS@@YAPAVCBaseEntity@@PAUedict_s@@@Z ; UTIL_FindClientInPVS
;	COMDAT ?UTIL_FindClientInPVS@@YAPAVCBaseEntity@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEdict$ = 8
_client$ = -4
?UTIL_FindClientInPVS@@YAPAVCBaseEntity@@PAUedict_s@@@Z PROC NEAR ; UTIL_FindClientInPVS, COMDAT

; 2500 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2501 : 	edict_t *client = FIND_CLIENT_IN_PVS (pEdict);

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+68
	add	esp, 4
	mov	DWORD PTR _client$[ebp], eax

; 2502 : 
; 2503 : 	if( !FNullEnt(client))

	mov	ecx, DWORD PTR _client$[ebp]
	push	ecx
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41876

; 2505 : 		return CBaseEntity::Instance( client );

	mov	edx, DWORD PTR _client$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	jmp	SHORT $L41874
$L41876:

; 2507 : 
; 2508 : 	return NULL;

	xor	eax, eax
$L41874:

; 2509 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FindClientInPVS@@YAPAVCBaseEntity@@PAUedict_s@@@Z ENDP ; UTIL_FindClientInPVS
_TEXT	ENDS
EXTRN	?g_fPhysicInitialized@@3HA:DWORD		; g_fPhysicInitialized
EXTRN	?g_physfuncs@@3Userver_physics_api_s@@A:BYTE	; g_physfuncs
;	COMDAT ?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z
_TEXT	SEGMENT
_modelindex$ = 8
_mod$ = -4
?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z PROC NEAR	; UTIL_GetModelType, COMDAT

; 2512 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2513 : 	if( !g_fPhysicInitialized )

	cmp	DWORD PTR ?g_fPhysicInitialized@@3HA, 0	; g_fPhysicInitialized
	jne	SHORT $L41880

; 2514 : 		return mod_bad;

	or	eax, -1
	jmp	SHORT $L41879
$L41880:

; 2515 : 
; 2516 : 	model_t *mod = (model_t *)MODEL_HANDLE( modelindex );

	mov	eax, DWORD PTR _modelindex$[ebp]
	push	eax
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 2517 : 	if( mod )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $L41883

; 2518 : 		return (modtype_t)mod->type;

	mov	ecx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [ecx+68]
	jmp	SHORT $L41879
$L41883:

; 2519 : 
; 2520 : 	return mod_bad;

	or	eax, -1
$L41879:

; 2521 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ENDP		; UTIL_GetModelType
_TEXT	ENDS
PUBLIC	?UTIL_GetSpriteType@@YA?AW4angletype_t@@H@Z	; UTIL_GetSpriteType
;	COMDAT ?UTIL_GetSpriteType@@YA?AW4angletype_t@@H@Z
_TEXT	SEGMENT
_modelindex$ = 8
_mod$ = -4
_spr$ = -8
?UTIL_GetSpriteType@@YA?AW4angletype_t@@H@Z PROC NEAR	; UTIL_GetSpriteType, COMDAT

; 2524 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2525 : 	if( UTIL_GetModelType( modelindex ) != mod_sprite )

	mov	eax, DWORD PTR _modelindex$[ebp]
	push	eax
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	cmp	eax, 1
	je	SHORT $L41888

; 2526 : 		return (angletype_t)-1; // bad sprite

	or	eax, -1
	jmp	SHORT $L41887
$L41888:

; 2527 : 
; 2528 : 	model_t *mod = (model_t *)MODEL_HANDLE( modelindex );

	mov	ecx, DWORD PTR _modelindex$[ebp]
	push	ecx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 2529 : 	msprite_t *spr = (msprite_t *)mod->cache.data;

	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+388]
	mov	DWORD PTR _spr$[ebp], eax

; 2530 : 
; 2531 : 	return (angletype_t)spr->type;

	mov	ecx, DWORD PTR _spr$[ebp]
	movsx	eax, WORD PTR [ecx]
$L41887:

; 2532 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_GetSpriteType@@YA?AW4angletype_t@@H@Z ENDP	; UTIL_GetSpriteType
_TEXT	ENDS
PUBLIC	?UITL_ExternalBmodel@@YAHH@Z			; UITL_ExternalBmodel
;	COMDAT ?UITL_ExternalBmodel@@YAHH@Z
_TEXT	SEGMENT
_modelindex$ = 8
_mod$ = -4
?UITL_ExternalBmodel@@YAHH@Z PROC NEAR			; UITL_ExternalBmodel, COMDAT

; 2535 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2536 : 	if( !g_fPhysicInitialized || modelindex <= 1 )

	cmp	DWORD PTR ?g_fPhysicInitialized@@3HA, 0	; g_fPhysicInitialized
	je	SHORT $L41899
	cmp	DWORD PTR _modelindex$[ebp], 1
	jg	SHORT $L41898
$L41899:

; 2537 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L41897
$L41898:

; 2538 : 
; 2539 : 	model_t *mod = (model_t *)MODEL_HANDLE( modelindex );

	mov	eax, DWORD PTR _modelindex$[ebp]
	push	eax
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 2540 : 
; 2541 : 	// brush models can be stored as individual bsp-files and go across the transition
; 2542 : 	if( mod && mod->type == mod_brush && mod->name[0] != '*' )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $L41902
	mov	ecx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $L41902
	mov	edx, DWORD PTR _mod$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 42					; 0000002aH
	je	SHORT $L41902

; 2543 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L41897
$L41902:

; 2544 : 
; 2545 : 	return FALSE;	

	xor	eax, eax
$L41897:

; 2546 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UITL_ExternalBmodel@@YAHH@Z ENDP			; UITL_ExternalBmodel
_TEXT	ENDS
PUBLIC	?UTIL_GetModelBounds@@YAXHAAVVector@@0@Z	; UTIL_GetModelBounds
PUBLIC	??_C@_0CE@FNKF@UTIL_GetModelBounds?3?5NULL?5model?5@ ; `string'
;	COMDAT ??_C@_0CE@FNKF@UTIL_GetModelBounds?3?5NULL?5model?5@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0CE@FNKF@UTIL_GetModelBounds?3?5NULL?5model?5@ DB 'UTIL_GetModelBou'
	DB	'nds: NULL model %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?UTIL_GetModelBounds@@YAXHAAVVector@@0@Z
_TEXT	SEGMENT
_modelIndex$ = 8
_mins$ = 12
_maxs$ = 16
_mod$ = -4
?UTIL_GetModelBounds@@YAXHAAVVector@@0@Z PROC NEAR	; UTIL_GetModelBounds, COMDAT

; 2554 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2555 : 	if( modelIndex <= 0 ) return;

	cmp	DWORD PTR _modelIndex$[ebp], 0
	jg	SHORT $L41908
	jmp	$L41907
$L41908:

; 2556 : 
; 2557 : 	model_t *mod = (model_t *)MODEL_HANDLE( modelIndex );

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 2558 : 
; 2559 : 	if( mod )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $L41911

; 2561 : 		mins = mod->mins;

	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 84					; 00000054H
	mov	edx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 2562 : 		maxs = mod->maxs;

	mov	edx, DWORD PTR _mod$[ebp]
	add	edx, 96					; 00000060H
	mov	eax, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 2564 : 	else

	jmp	SHORT $L41912
$L41911:

; 2566 : 		ALERT( at_error, "UTIL_GetModelBounds: NULL model %i\n", modelIndex );

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CE@FNKF@UTIL_GetModelBounds?3?5NULL?5model?5@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2567 : 		mins = maxs = g_vecZero;

	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L41912:
$L41907:

; 2569 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_GetModelBounds@@YAXHAAVVector@@0@Z ENDP		; UTIL_GetModelBounds
_TEXT	ENDS
PUBLIC	?UTIL_SetSize@@YAXPAVCBaseEntity@@ABVVector@@1@Z ; UTIL_SetSize
PUBLIC	??_C@_0CG@PMFB@UTIL_SetSize?3?5?$CFs?5backwards?5mins?1@ ; `string'
;	COMDAT ??_C@_0CG@PMFB@UTIL_SetSize?3?5?$CFs?5backwards?5mins?1@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0CG@PMFB@UTIL_SetSize?3?5?$CFs?5backwards?5mins?1@ DB 'UTIL_SetSize'
	DB	': %s backwards mins/maxs', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?UTIL_SetSize@@YAXPAVCBaseEntity@@ABVVector@@1@Z
_TEXT	SEGMENT
$T44099 = -12
_pEntity$ = 8
_min$ = 12
_max$ = 16
?UTIL_SetSize@@YAXPAVCBaseEntity@@ABVVector@@1@Z PROC NEAR ; UTIL_SetSize, COMDAT

; 2572 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2573 : 	// check bounds
; 2574 : 	if( min.x > max.x || min.y > max.y || min.z > max.z )

	mov	eax, DWORD PTR _min$[ebp]
	mov	ecx, DWORD PTR _max$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L41920
	mov	edx, DWORD PTR _min$[ebp]
	mov	eax, DWORD PTR _max$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L41920
	mov	ecx, DWORD PTR _min$[ebp]
	mov	edx, DWORD PTR _max$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41919
$L41920:

; 2576 : 		ALERT( at_error, "UTIL_SetSize: %s backwards mins/maxs\n", pEntity->GetClassname( ));

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CG@PMFB@UTIL_SetSize?3?5?$CFs?5backwards?5mins?1@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2577 : 		return;

	jmp	SHORT $L41918
$L41919:

; 2579 : 
; 2580 : 	pEntity->pev->size = (max - min);

	mov	eax, DWORD PTR _min$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T44099[ebp]
	push	ecx
	mov	ecx, DWORD PTR _max$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 244				; 000000f4H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 2581 : 	pEntity->pev->mins = min;

	mov	ecx, DWORD PTR _min$[ebp]
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 220				; 000000dcH
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 2582 : 	pEntity->pev->maxs = max;

	mov	edx, DWORD PTR _max$[ebp]
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 232				; 000000e8H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 2583 : 
; 2584 : 	pEntity->RelinkEntity( FALSE, NULL );

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity
$L41918:

; 2585 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_SetSize@@YAXPAVCBaseEntity@@ABVVector@@1@Z ENDP	; UTIL_SetSize
_TEXT	ENDS
PUBLIC	?UTIL_CanRotate@@YAHPAVCBaseEntity@@@Z		; UTIL_CanRotate
;	COMDAT ?UTIL_CanRotate@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_mod$ = -4
?UTIL_CanRotate@@YAHPAVCBaseEntity@@@Z PROC NEAR	; UTIL_CanRotate, COMDAT

; 2596 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2597 : 	model_t	*mod;
; 2598 : 
; 2599 : 	if( !g_fPhysicInitialized )

	cmp	DWORD PTR ?g_fPhysicInitialized@@3HA, 0	; g_fPhysicInitialized
	jne	SHORT $L41927

; 2600 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L41925
$L41927:

; 2601 : 
; 2602 : 	mod = (model_t *)MODEL_HANDLE( pEntity->pev->modelindex );

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 2603 : 	if( !mod || mod->type != mod_brush )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $L41930
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $L41929
$L41930:

; 2604 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L41925
$L41929:

; 2605 : 
; 2606 : 	// NOTE: flag 2 it's a internal engine flag (see model.c for details)
; 2607 : 	// we can recalc real model origin here but this check is faster :)
; 2608 : 	return (mod->flags & 2) ? TRUE : FALSE;

	mov	ecx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [ecx+80]
	and	eax, 2
	neg	eax
	sbb	eax, eax
	neg	eax
$L41925:

; 2609 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_CanRotate@@YAHPAVCBaseEntity@@@Z ENDP		; UTIL_CanRotate
_TEXT	ENDS
PUBLIC	?UTIL_CanRotateBModel@@YAHPAVCBaseEntity@@@Z	; UTIL_CanRotateBModel
;	COMDAT ?UTIL_CanRotateBModel@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_mod$ = -4
?UTIL_CanRotateBModel@@YAHPAVCBaseEntity@@@Z PROC NEAR	; UTIL_CanRotateBModel, COMDAT

; 2620 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2621 : 	model_t	*mod;
; 2622 : 
; 2623 : 	if( !g_fPhysicInitialized )

	cmp	DWORD PTR ?g_fPhysicInitialized@@3HA, 0	; g_fPhysicInitialized
	jne	SHORT $L41935

; 2624 : 		return (pEntity->pev->solid == SOLID_BSP);

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+268], 4
	sete	al
	jmp	SHORT $L41933
$L41935:

; 2625 : 
; 2626 : 	mod = (model_t *)MODEL_HANDLE( pEntity->pev->modelindex );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+180]
	push	ecx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 2627 : 	if( !mod || mod->type != mod_brush )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $L41938
	mov	edx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $L41937
$L41938:

; 2628 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L41933
$L41937:

; 2629 : 
; 2630 : 	// NOTE: flag 2 it's a internal engine flag (see model.c for details)
; 2631 : 	// we can recalc real model origin here but this check is faster :)
; 2632 : 	return (mod->flags & 2) ? TRUE : FALSE;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [eax+80]
	and	eax, 2
	neg	eax
	sbb	eax, eax
	neg	eax
$L41933:

; 2633 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_CanRotateBModel@@YAHPAVCBaseEntity@@@Z ENDP	; UTIL_CanRotateBModel
_TEXT	ENDS
PUBLIC	?UTIL_AllowHitboxTrace@@YAHPAVCBaseEntity@@@Z	; UTIL_AllowHitboxTrace
;	COMDAT ?UTIL_AllowHitboxTrace@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_mod$ = -4
?UTIL_AllowHitboxTrace@@YAHPAVCBaseEntity@@@Z PROC NEAR	; UTIL_AllowHitboxTrace, COMDAT

; 2643 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2644 : 	model_t	*mod;
; 2645 : 
; 2646 : 	if( !g_fPhysicInitialized )

	cmp	DWORD PTR ?g_fPhysicInitialized@@3HA, 0	; g_fPhysicInitialized
	jne	SHORT $L41943

; 2647 : 		return (pEntity->pev->solid == SOLID_BBOX);

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+268], 2
	sete	al
	jmp	SHORT $L41941
$L41943:

; 2648 : 
; 2649 : 	mod = (model_t *)MODEL_HANDLE( pEntity->pev->modelindex );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+180]
	push	ecx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 2650 : 	if( !mod || mod->type != mod_studio )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $L41946
	mov	edx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [edx+68], 3
	je	SHORT $L41945
$L41946:

; 2651 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L41941
$L41945:

; 2652 : 
; 2653 : 	// NOTE: flag 2 it's a internal engine flag (see model.c for details)
; 2654 : 	// we can recalc real model origin here but this check is faster :)
; 2655 : 	return (mod->flags & STUDIO_TRACE_HITBOX) ? TRUE : FALSE;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [eax+80]
	and	eax, 512				; 00000200H
	neg	eax
	sbb	eax, eax
	neg	eax
$L41941:

; 2656 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_AllowHitboxTrace@@YAHPAVCBaseEntity@@@Z ENDP	; UTIL_AllowHitboxTrace
_TEXT	ENDS
PUBLIC	??0areaclip_t@@QAE@XZ				; areaclip_t::areaclip_t
PUBLIC	?UTIL_AreaNode@@YAXVVector@@0HP6AXPAVCBaseEntity@@@Z@Z ; UTIL_AreaNode
;	COMDAT ?UTIL_AreaNode@@YAXVVector@@0HP6AXPAVCBaseEntity@@@Z@Z
_TEXT	SEGMENT
_vecAbsMin$ = 8
_vecAbsMax$ = 20
_type$ = 32
_pfnCallback$ = 36
_clip$ = -32
?UTIL_AreaNode@@YAXVVector@@0HP6AXPAVCBaseEntity@@@Z@Z PROC NEAR ; UTIL_AreaNode, COMDAT

; 2708 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 2709 : 	areaclip_t clip;

	lea	ecx, DWORD PTR _clip$[ebp]
	call	??0areaclip_t@@QAE@XZ			; areaclip_t::areaclip_t

; 2710 : 
; 2711 : 	clip.vecAbsMin = vecAbsMin;

	mov	eax, DWORD PTR _vecAbsMin$[ebp]
	mov	DWORD PTR _clip$[ebp], eax
	mov	ecx, DWORD PTR _vecAbsMin$[ebp+4]
	mov	DWORD PTR _clip$[ebp+4], ecx
	mov	edx, DWORD PTR _vecAbsMin$[ebp+8]
	mov	DWORD PTR _clip$[ebp+8], edx

; 2712 : 	clip.vecAbsMax = vecAbsMax;

	mov	eax, DWORD PTR _vecAbsMax$[ebp]
	mov	DWORD PTR _clip$[ebp+12], eax
	mov	ecx, DWORD PTR _vecAbsMax$[ebp+4]
	mov	DWORD PTR _clip$[ebp+16], ecx
	mov	edx, DWORD PTR _vecAbsMax$[ebp+8]
	mov	DWORD PTR _clip$[ebp+20], edx

; 2713 : 	clip.m_pfnCallback = pfnCallback;

	mov	eax, DWORD PTR _pfnCallback$[ebp]
	mov	DWORD PTR _clip$[ebp+24], eax

; 2714 : 	clip.area_type = type;

	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR _clip$[ebp+28], ecx

; 2715 : 
; 2716 : 	UTIL_RecursiveWalkNodes( &clip, GET_AREANODE() );

	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+16
	push	eax
	lea	edx, DWORD PTR _clip$[ebp]
	push	edx
	call	?UTIL_RecursiveWalkNodes@@YAXPAUareaclip_t@@PAUareanode_s@@@Z ; UTIL_RecursiveWalkNodes
	add	esp, 8

; 2717 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_AreaNode@@YAXVVector@@0HP6AXPAVCBaseEntity@@@Z@Z ENDP ; UTIL_AreaNode
_TEXT	ENDS
EXTRN	?AreaIntersect@CBaseEntity@@QAEHVVector@@0@Z:NEAR ; CBaseEntity::AreaIntersect
;	COMDAT ?UTIL_RecursiveWalkNodes@@YAXPAUareaclip_t@@PAUareanode_s@@@Z
_TEXT	SEGMENT
_clip$ = 8
_node$ = 12
_l$ = -4
_start$ = -8
_next$ = -12
_pCheck$41963 = -16
?UTIL_RecursiveWalkNodes@@YAXPAUareaclip_t@@PAUareanode_s@@@Z PROC NEAR ; UTIL_RecursiveWalkNodes, COMDAT

; 2666 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 2667 : 	link_t	*l, *start, *next;
; 2668 : 
; 2669 : 	// touch linked edicts
; 2670 : 	if( clip->area_type == AREA_SOLID )

	mov	eax, DWORD PTR _clip$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $L41954

; 2671 : 		start = &node->solid_edicts;

	mov	ecx, DWORD PTR _node$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR _start$[ebp], ecx

; 2672 : 	else if( clip->area_type == AREA_TRIGGERS )

	jmp	SHORT $L41959
$L41954:
	mov	edx, DWORD PTR _clip$[ebp]
	cmp	DWORD PTR [edx+28], 1
	jne	SHORT $L41956

; 2673 : 		start = &node->trigger_edicts;

	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _start$[ebp], eax

; 2674 : 	else if( clip->area_type == AREA_WATER )

	jmp	SHORT $L41959
$L41956:
	mov	ecx, DWORD PTR _clip$[ebp]
	cmp	DWORD PTR [ecx+28], 2
	jne	SHORT $L41958

; 2675 : 		start = &node->solid_edicts;

	mov	edx, DWORD PTR _node$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR _start$[ebp], edx

; 2676 : 	else return;

	jmp	SHORT $L41959
$L41958:
	jmp	$L41950
$L41959:

; 2677 : 
; 2678 : 	// touch linked edicts
; 2679 : 	for( l = start->next; l != start; l = next )

	mov	eax, DWORD PTR _start$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _l$[ebp], ecx
	jmp	SHORT $L41960
$L41961:
	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], edx
$L41960:
	mov	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _start$[ebp]
	je	$L41962

; 2681 : 		next = l->next;

	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _next$[ebp], edx

; 2682 : 
; 2683 : 		CBaseEntity *pCheck = CBaseEntity :: Instance( EDICT_FROM_AREA( l ));

	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 8
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pCheck$41963[ebp], eax

; 2684 : 
; 2685 : 		if( clip->area_type == AREA_SOLID && pCheck->pev->solid == SOLID_NOT )

	mov	ecx, DWORD PTR _clip$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $L41968
	mov	edx, DWORD PTR _pCheck$41963[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+268], 0
	jne	SHORT $L41968

; 2686 : 			continue;

	jmp	SHORT $L41961
$L41968:

; 2687 : 
; 2688 : 		if( clip->area_type == AREA_WATER && pCheck->pev->solid != SOLID_NOT )

	mov	ecx, DWORD PTR _clip$[ebp]
	cmp	DWORD PTR [ecx+28], 2
	jne	SHORT $L41969
	mov	edx, DWORD PTR _pCheck$41963[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+268], 0
	je	SHORT $L41969

; 2689 : 			continue;

	jmp	SHORT $L41961
$L41969:

; 2690 : 
; 2691 : 		if( pCheck && pCheck->AreaIntersect( clip->vecAbsMin, clip->vecAbsMax ))

	cmp	DWORD PTR _pCheck$41963[ebp], 0
	je	SHORT $L41973
	mov	ecx, DWORD PTR _clip$[ebp]
	add	ecx, 12					; 0000000cH
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	push	ecx
	mov	ecx, edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _pCheck$41963[ebp]
	call	?AreaIntersect@CBaseEntity@@QAEHVVector@@0@Z ; CBaseEntity::AreaIntersect
	test	eax, eax
	je	SHORT $L41973

; 2693 : 			if( clip->m_pfnCallback )

	mov	ecx, DWORD PTR _clip$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $L41973

; 2694 : 				clip->m_pfnCallback( pCheck );

	mov	edx, DWORD PTR _pCheck$41963[ebp]
	push	edx
	mov	eax, DWORD PTR _clip$[ebp]
	call	DWORD PTR [eax+24]
	add	esp, 4
$L41973:

; 2696 : 	}

	jmp	$L41961
$L41962:

; 2697 : 	
; 2698 : 	// recurse down both sides
; 2699 : 	if( node->axis == -1 ) return;

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx], -1
	jne	SHORT $L41974
	jmp	SHORT $L41950
$L41974:

; 2700 : 
; 2701 : 	if( clip->vecAbsMax[node->axis] > node->dist )

	mov	ecx, DWORD PTR _clip$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _node$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR [edx+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41975

; 2702 : 		UTIL_RecursiveWalkNodes( clip, node->children[0] );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _clip$[ebp]
	push	edx
	call	?UTIL_RecursiveWalkNodes@@YAXPAUareaclip_t@@PAUareanode_s@@@Z ; UTIL_RecursiveWalkNodes
	add	esp, 8
$L41975:

; 2703 : 	if( clip->vecAbsMin[node->axis] < node->dist )

	mov	ecx, DWORD PTR _clip$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _node$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fcomp	DWORD PTR [ecx+4]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41976

; 2704 : 		UTIL_RecursiveWalkNodes( clip, node->children[1] );

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _clip$[ebp]
	push	ecx
	call	?UTIL_RecursiveWalkNodes@@YAXPAUareaclip_t@@PAUareanode_s@@@Z ; UTIL_RecursiveWalkNodes
	add	esp, 8
$L41976:
$L41950:

; 2705 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_RecursiveWalkNodes@@YAXPAUareaclip_t@@PAUareanode_s@@@Z ENDP ; UTIL_RecursiveWalkNodes
_TEXT	ENDS
;	COMDAT ??0areaclip_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0areaclip_t@@QAE@XZ PROC NEAR				; areaclip_t::areaclip_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0areaclip_t@@QAE@XZ ENDP				; areaclip_t::areaclip_t
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z@4FA ; `UTIL_DropToFloor'::`2'::__LINE__Var
PUBLIC	??_C@_0BA@IDJO@pEntity?5?$CB?$DN?5NULL?$AA@	; `string'
PUBLIC	?UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z	; UTIL_DropToFloor
PUBLIC	?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z ; CBaseEntity::SetGroundEntity
EXTRN	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsOrigin
;	COMDAT ?__LINE__Var@?1??UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z@4FA
; File z:\xashxtsrc\server\util.cpp
_DATA	SEGMENT
?__LINE__Var@?1??UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z@4FA DW 0aa3H ; `UTIL_DropToFloor'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@IDJO@pEntity?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BA@IDJO@pEntity?5?$CB?$DN?5NULL?$AA@ DB 'pEntity != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_trace$ = -56
_vecStart$ = -68
_vecEnd$ = -80
$T44116 = -92
$T44117 = -104
?UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z PROC NEAR	; UTIL_DropToFloor, COMDAT

; 2723 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	push	ebx
	push	esi
	push	edi

; 2724 : 	ASSERT( pEntity != NULL );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z@4FA ; `UTIL_DropToFloor'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0BN@PKKM@z?3?2xashxtsrc?2server?2util?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@IDJO@pEntity?5?$CB?$DN?5NULL?$AA@ ; `string'
	xor	ecx, ecx
	cmp	DWORD PTR _pEntity$[ebp], 0
	setne	cl
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 2725 : 
; 2726 : 	// Assume no ground
; 2727 : //	pEntity->ClearGroundEntity();
; 2728 : 
; 2729 : 	TraceResult trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 2730 : 	Vector vecStart = pEntity->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2731 : 	Vector vecEnd = pEntity->GetAbsOrigin() - Vector( 0, 0, 256 );

	push	1132462080				; 43800000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T44116[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	edx, DWORD PTR $T44117[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2732 : 
; 2733 : 	if( FBitSet( pEntity->pev->iuser1, CF_STATIC_ENTITY )) TRACE_LINE( vecStart, vecEnd, TRUE, pEntity->edict(), &trace );

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+580]
	and	edx, 64					; 00000040H
	test	edx, edx
	je	SHORT $L41996
	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+124
	add	esp, 20					; 00000014H

; 2734 : 	else TRACE_MONSTER_HULL( pEntity->edict(), vecStart, vecEnd, dont_ignore_monsters, pEntity->edict(), &trace );

	jmp	SHORT $L41997
$L41996:
	lea	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+132
	add	esp, 24					; 00000018H
$L41997:

; 2735 : 
; 2736 : 	if( trace.fAllSolid )

	cmp	DWORD PTR _trace$[ebp], 0
	je	SHORT $L41998

; 2737 : 		return -1;

	or	eax, -1
	jmp	SHORT $L41988
$L41998:

; 2738 : 
; 2739 : 	if( trace.flFraction == 1.0f )

	cmp	DWORD PTR _trace$[ebp+16], 1065353216	; 3f800000H
	jne	SHORT $L41999

; 2740 : 		return 0;

	xor	eax, eax
	jmp	SHORT $L41988
$L41999:

; 2741 : 
; 2742 : 	pEntity->SetAbsOrigin( trace.vecEndPos );

	lea	edx, DWORD PTR _trace$[ebp+20]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 2743 : 	pEntity->SetGroundEntity( trace.pHit );

	mov	eax, DWORD PTR _trace$[ebp+48]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z ; CBaseEntity::SetGroundEntity

; 2744 : 
; 2745 : 	return 1;

	mov	eax, 1
$L41988:

; 2746 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z ENDP		; UTIL_DropToFloor
_TEXT	ENDS
;	COMDAT ?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pentGround$ = 8
?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z PROC NEAR ; CBaseEntity::SetGroundEntity, COMDAT

; 611  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		if( pentGround != NULL )

	cmp	DWORD PTR _pentGround$[ebp], 0
	je	SHORT $L35070

; 614  : 			pev->groundentity = pentGround;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pentGround$[ebp]
	mov	DWORD PTR [ecx+412], edx

; 615  : 			pev->flags |= FL_ONGROUND;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	or	dh, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 617  : 		else ClearGroundEntity();

	jmp	SHORT $L35071
$L35070:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearGroundEntity@CBaseEntity@@QAEXXZ	; CBaseEntity::ClearGroundEntity
$L35071:

; 618  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z ENDP	; CBaseEntity::SetGroundEntity
_TEXT	ENDS
PUBLIC	??_C@_0CN@GCC@Entity?5?$CFi?5SOLID_BSP?5with?5a?5non?5b@ ; `string'
PUBLIC	__real@4@40049000000000000000
PUBLIC	??YVector@@QAEAAV0@ABV0@@Z			; Vector::operator+=
PUBLIC	?UTIL_HullForBsp@@YAPAUhull_s@@PAVCBaseEntity@@ABVVector@@1AAV3@@Z ; UTIL_HullForBsp
;	COMDAT ??_C@_0CN@GCC@Entity?5?$CFi?5SOLID_BSP?5with?5a?5non?5b@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0CN@GCC@Entity?5?$CFi?5SOLID_BSP?5with?5a?5non?5b@ DB 'Entity %i SO'
	DB	'LID_BSP with a non bsp model %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@4@40049000000000000000
CONST	SEGMENT
__real@4@40049000000000000000 DD 042100000r	; 36
CONST	ENDS
;	COMDAT ?UTIL_HullForBsp@@YAPAUhull_s@@PAVCBaseEntity@@ABVVector@@1AAV3@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_mins$ = 12
_maxs$ = 16
_offset$ = 20
_hull$ = -4
_model$ = -8
_size$ = -20
$T44122 = -32
$T44123 = -44
?UTIL_HullForBsp@@YAPAUhull_s@@PAVCBaseEntity@@ABVVector@@1AAV3@@Z PROC NEAR ; UTIL_HullForBsp, COMDAT

; 2756 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 2757 : 	hull_t *hull;
; 2758 : 	model_t *model;
; 2759 : 	Vector size;

	lea	ecx, DWORD PTR _size$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2760 : 			
; 2761 : 	// decide which clipping hull to use, based on the size
; 2762 : 	model = (model_t *)MODEL_HANDLE( pEntity->pev->modelindex );

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 2763 : 
; 2764 : 	if( !model || model->type != mod_brush )

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $L42011
	mov	eax, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $L42010
$L42011:

; 2765 : 		HOST_ERROR( "Entity %i SOLID_BSP with a non bsp model %i\n", pEntity->entindex(), model->type );

	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	push	eax
	push	OFFSET FLAT:??_C@_0CN@GCC@Entity?5?$CFi?5SOLID_BSP?5with?5a?5non?5b@ ; `string'
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+24
	add	esp, 12					; 0000000cH
$L42010:

; 2766 : 
; 2767 : 	size = maxs - mins;

	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T44122[ebp]
	push	ecx
	mov	ecx, DWORD PTR _maxs$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _size$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _size$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _size$[ebp+8], edx

; 2768 : 
; 2769 : 	if( size[0] <= 8.0f || model->flags & 4 ) // a MODEL_LIQUID flag

	lea	ecx, DWORD PTR _size$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@40028000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L42015
	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 4
	test	ecx, ecx
	je	SHORT $L42014
$L42015:

; 2771 : 		hull = &model->hulls[0];

	mov	edx, DWORD PTR _model$[ebp]
	add	edx, 208				; 000000d0H
	mov	DWORD PTR _hull$[ebp], edx

; 2772 : 		offset = hull->clip_mins; 

	mov	eax, DWORD PTR _hull$[ebp]
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 2774 : 	else

	jmp	SHORT $L42016
$L42014:

; 2776 : 		if( size[0] <= 36.0f )

	lea	ecx, DWORD PTR _size$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@40049000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L42017

; 2778 : 			if( size[2] <= 36.0f )

	lea	ecx, DWORD PTR _size$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@40049000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L42018

; 2779 : 				hull = &model->hulls[3];

	mov	ecx, DWORD PTR _model$[ebp]
	add	ecx, 328				; 00000148H
	mov	DWORD PTR _hull$[ebp], ecx

; 2780 : 			else hull = &model->hulls[1];

	jmp	SHORT $L42019
$L42018:
	mov	edx, DWORD PTR _model$[ebp]
	add	edx, 248				; 000000f8H
	mov	DWORD PTR _hull$[ebp], edx
$L42019:

; 2782 : 		else hull = &model->hulls[2];

	jmp	SHORT $L42020
$L42017:
	mov	eax, DWORD PTR _model$[ebp]
	add	eax, 288				; 00000120H
	mov	DWORD PTR _hull$[ebp], eax
$L42020:

; 2783 : 
; 2784 : 		offset = hull->clip_mins - mins;

	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T44123[ebp]
	push	edx
	mov	ecx, DWORD PTR _hull$[ebp]
	add	ecx, 16					; 00000010H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L42016:

; 2786 : 
; 2787 : 	offset += pEntity->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _offset$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2788 : 
; 2789 : 	return hull;

	mov	eax, DWORD PTR _hull$[ebp]

; 2790 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_HullForBsp@@YAPAUhull_s@@PAVCBaseEntity@@ABVVector@@1AAV3@@Z ENDP ; UTIL_HullForBsp
_TEXT	ENDS
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??YVector@@QAEAAV0@ABV0@@Z PROC NEAR			; Vector::operator+=, COMDAT

; 159  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		x+=v.x; y+=v.y; z += v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 161  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 162  : 	}			

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??YVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator+=
_TEXT	ENDS
PUBLIC	?UTIL_HullPointContents@@YAHPAUhull_s@@HABVVector@@@Z ; UTIL_HullPointContents
;	COMDAT ?UTIL_HullPointContents@@YAHPAUhull_s@@HABVVector@@@Z
_TEXT	SEGMENT
_hull$ = 8
_num$ = 12
_p$ = 16
_plane$ = -4
?UTIL_HullPointContents@@YAHPAUhull_s@@HABVVector@@@Z PROC NEAR ; UTIL_HullPointContents, COMDAT

; 2799 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2800 : 	mplane_t *plane;
; 2801 : 
; 2802 : 	if( !hull || !hull->planes )	// in case we restore saved game while map is changed

	cmp	DWORD PTR _hull$[ebp], 0
	je	SHORT $L42029
	mov	eax, DWORD PTR _hull$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L42028
$L42029:

; 2803 : 		return CONTENTS_NONE;

	xor	eax, eax
	jmp	$L42026
$L42028:

; 2804 : 
; 2805 : 	while( num >= 0 )

	cmp	DWORD PTR _num$[ebp], 0
	jl	$L42032

; 2807 : 		plane = &hull->planes[hull->clipnodes[num].planenum];

	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, ecx
	mov	DWORD PTR _plane$[ebp], eax

; 2808 : 		num = hull->clipnodes[num].children[PlaneDiff( p, plane ) < 0];

	mov	ecx, DWORD PTR _plane$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $L44130
	mov	ecx, DWORD PTR _p$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _plane$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L44131
$L44130:
	mov	ecx, DWORD PTR _plane$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR -8+[ebp]
$L44131:
	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR -8+[ebp]
	fsub	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L44132
	mov	DWORD PTR -12+[ebp], 1
	jmp	SHORT $L44133
$L44132:
	mov	DWORD PTR -12+[ebp], 0
$L44133:
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _num$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR -12+[ebp]
	movsx	eax, WORD PTR [ecx+edx*2+4]
	mov	DWORD PTR _num$[ebp], eax

; 2809 : 	}

	jmp	$L42028
$L42032:

; 2810 : 	return num;

	mov	eax, DWORD PTR _num$[ebp]
$L42026:

; 2811 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_HullPointContents@@YAHPAUhull_s@@HABVVector@@@Z ENDP ; UTIL_HullPointContents
_TEXT	ENDS
PUBLIC	?UTIL_MoveBounds@@YAXABVVector@@000AAV1@1@Z	; UTIL_MoveBounds
;	COMDAT ?UTIL_MoveBounds@@YAXABVVector@@000AAV1@1@Z
_TEXT	SEGMENT
_start$ = 8
_mins$ = 12
_maxs$ = 16
_end$ = 20
_outmins$ = 24
_outmaxs$ = 28
_i$ = -4
?UTIL_MoveBounds@@YAXABVVector@@000AAV1@1@Z PROC NEAR	; UTIL_MoveBounds, COMDAT

; 2819 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 2820 : 	for( int i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L42042
$L42043:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L42042:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$L42044

; 2822 : 		if( end[i] > start[i] )

	mov	ecx, DWORD PTR _end$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	ecx, DWORD PTR _start$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [esi+ecx*4]
	fcomp	DWORD PTR [eax+edx*4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L42045

; 2824 : 			outmins[i] = start[i] + mins[i] - 1;

	mov	ecx, DWORD PTR _start$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	ecx, DWORD PTR _mins$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [esi+ecx*4]
	fadd	DWORD PTR [eax+edx*4]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _outmins$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 2825 : 			outmaxs[i] = end[i] + maxs[i] + 1;

	mov	ecx, DWORD PTR _end$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	ecx, DWORD PTR _maxs$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [esi+ecx*4]
	fadd	DWORD PTR [eax+edx*4]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR -12+[ebp]
	mov	ecx, DWORD PTR _outmaxs$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR -12+[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 2827 : 		else

	jmp	SHORT $L42046
$L42045:

; 2829 : 			outmins[i] = end[i] + mins[i] - 1;

	mov	ecx, DWORD PTR _end$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	ecx, DWORD PTR _mins$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [esi+ecx*4]
	fadd	DWORD PTR [eax+edx*4]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR -16+[ebp]
	mov	ecx, DWORD PTR _outmins$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR -16+[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 2830 : 			outmaxs[i] = start[i] + maxs[i] + 1;

	mov	ecx, DWORD PTR _start$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	ecx, DWORD PTR _maxs$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [esi+ecx*4]
	fadd	DWORD PTR [eax+edx*4]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR -20+[ebp]
	mov	ecx, DWORD PTR _outmaxs$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR -20+[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
$L42046:

; 2832 : 	}

	jmp	$L42043
$L42044:

; 2833 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_MoveBounds@@YAXABVVector@@000AAV1@1@Z ENDP	; UTIL_MoveBounds
_TEXT	ENDS
PUBLIC	??0trace_s@@QAE@ABU0@@Z				; trace_s::trace_s
PUBLIC	?UTIL_CombineTraces@@YA?AUtrace_s@@PAU1@0PAVCBaseEntity@@@Z ; UTIL_CombineTraces
;	COMDAT ?UTIL_CombineTraces@@YA?AUtrace_s@@PAU1@0PAVCBaseEntity@@@Z
_TEXT	SEGMENT
_cliptrace$ = 12
_trace$ = 16
_pTouch$ = 20
___$ReturnUdt$ = 8
?UTIL_CombineTraces@@YA?AUtrace_s@@PAU1@0PAVCBaseEntity@@@Z PROC NEAR ; UTIL_CombineTraces, COMDAT

; 2836 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2837 : 	if( trace->allsolid || trace->startsolid || trace->fraction < cliptrace->fraction )

	mov	eax, DWORD PTR _trace$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L42054
	mov	ecx, DWORD PTR _trace$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L42054
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR _cliptrace$[ebp]
	fld	DWORD PTR [edx+16]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L42056
$L42054:

; 2839 : 		trace->ent = pTouch->edict();

	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 2840 : 		
; 2841 : 		if( cliptrace->startsolid )

	mov	edx, DWORD PTR _cliptrace$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L42055

; 2843 : 			*cliptrace = *trace;

	mov	esi, DWORD PTR _trace$[ebp]
	mov	ecx, 14					; 0000000eH
	mov	edi, DWORD PTR _cliptrace$[ebp]
	rep movsd

; 2844 : 			cliptrace->startsolid = true;

	mov	eax, DWORD PTR _cliptrace$[ebp]
	mov	DWORD PTR [eax+4], 1

; 2846 : 		else *cliptrace = *trace;

	jmp	SHORT $L42056
$L42055:
	mov	esi, DWORD PTR _trace$[ebp]
	mov	ecx, 14					; 0000000eH
	mov	edi, DWORD PTR _cliptrace$[ebp]
	rep movsd
$L42056:

; 2848 : 
; 2849 : 	return *cliptrace;

	mov	ecx, DWORD PTR _cliptrace$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0trace_s@@QAE@ABU0@@Z			; trace_s::trace_s
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2850 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_CombineTraces@@YA?AUtrace_s@@PAU1@0PAVCBaseEntity@@@Z ENDP ; UTIL_CombineTraces
_TEXT	ENDS
PUBLIC	??0plane_s@@QAE@ABU0@@Z				; plane_s::plane_s
;	COMDAT ??0trace_s@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0trace_s@@QAE@ABU0@@Z PROC NEAR			; trace_s::trace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0plane_s@@QAE@ABU0@@Z			; plane_s::plane_s
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+52], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0trace_s@@QAE@ABU0@@Z ENDP				; trace_s::trace_s
_TEXT	ENDS
;	COMDAT ??0plane_s@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0plane_s@@QAE@ABU0@@Z PROC NEAR			; plane_s::plane_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0plane_s@@QAE@ABU0@@Z ENDP				; plane_s::plane_s
_TEXT	ENDS
PUBLIC	??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@CEPA@player?1pl_wade3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@EEAK@player?1pl_wade4?4wav?$AA@	; `string'
PUBLIC	__real@4@4002c000000000000000
PUBLIC	__real@4@4002f000000000000000
PUBLIC	__real@4@3ffccccccd0000000000
PUBLIC	__real@4@bffecccccd0000000000
PUBLIC	?UTIL_WaterMove@@YAXPAVCBaseEntity@@@Z		; UTIL_WaterMove
;	COMDAT ??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@ DB 'player/pl_wade1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@ DB 'player/pl_wade2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CEPA@player?1pl_wade3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@CEPA@player?1pl_wade3?4wav?$AA@ DB 'player/pl_wade3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EEAK@player?1pl_wade4?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@EEAK@player?1pl_wade4?4wav?$AA@ DB 'player/pl_wade4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4@4002c000000000000000
CONST	SEGMENT
__real@4@4002c000000000000000 DD 041400000r	; 12
CONST	ENDS
;	COMDAT __real@4@4002f000000000000000
CONST	SEGMENT
__real@4@4002f000000000000000 DD 041700000r	; 15
CONST	ENDS
;	COMDAT __real@4@3ffccccccd0000000000
CONST	SEGMENT
__real@4@3ffccccccd0000000000 DD 03e4ccccdr	; 0.2
CONST	ENDS
;	COMDAT __real@4@bffecccccd0000000000
CONST	SEGMENT
__real@4@bffecccccd0000000000 DD 0bf4ccccdr	; -0.8
CONST	ENDS
;	COMDAT ?UTIL_WaterMove@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_drownlevel$ = -4
_waterlevel$ = -8
_watertype$ = -12
_flags$ = -16
$T44146 = -28
?UTIL_WaterMove@@YAXPAVCBaseEntity@@@Z PROC NEAR	; UTIL_WaterMove, COMDAT

; 2853 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 2854 : 	float	drownlevel;
; 2855 : 	int	waterlevel;
; 2856 : 	int	watertype;
; 2857 : 	int	flags;
; 2858 : 
; 2859 : 	if( pEntity->pev->movetype == MOVETYPE_NOCLIP )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+264], 8
	jne	SHORT $L42070

; 2861 : 		pEntity->pev->air_finished = gpGlobals->time + 12.0f;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	DWORD PTR __real@4@4002c000000000000000
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+508]

; 2862 : 		return;

	jmp	$L42065
$L42070:

; 2864 : 
; 2865 : 	if(( pEntity->pev->flags & FL_MONSTER ) && pEntity->pev->health <= 0.0f )

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 32					; 00000020H
	test	ecx, ecx
	je	SHORT $L42071
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L42071

; 2866 : 		return;

	jmp	$L42065
$L42071:

; 2867 : 
; 2868 : 	drownlevel = (pEntity->pev->deadflag == DEAD_NO) ? 3.0 : 1.0;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+368], 0
	jne	SHORT $L44144
	mov	DWORD PTR -36+[ebp], 0
	mov	DWORD PTR -36+[ebp+4], 1074266112	; 40080000H
	jmp	SHORT $L44145
$L44144:
	mov	DWORD PTR -36+[ebp], 0
	mov	DWORD PTR -36+[ebp+4], 1072693248	; 3ff00000H
$L44145:
	fld	QWORD PTR -36+[ebp]
	fstp	DWORD PTR _drownlevel$[ebp]

; 2869 : 	waterlevel = pEntity->pev->waterlevel;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+448]
	mov	DWORD PTR _waterlevel$[ebp], edx

; 2870 : 	watertype = pEntity->pev->watertype;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+452]
	mov	DWORD PTR _watertype$[ebp], edx

; 2871 : 	flags = pEntity->pev->flags;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	mov	DWORD PTR _flags$[ebp], edx

; 2872 : 
; 2873 : 	if( !( flags & FL_GODMODE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	$L42078

; 2875 : 		if((( flags & FL_SWIM ) && waterlevel > drownlevel ) || waterlevel <= drownlevel )

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L42075
	fild	DWORD PTR _waterlevel$[ebp]
	fcomp	DWORD PTR _drownlevel$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L42074
$L42075:
	fild	DWORD PTR _waterlevel$[ebp]
	fcomp	DWORD PTR _drownlevel$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L42073
$L42074:

; 2877 : 			if( pEntity->pev->air_finished > gpGlobals->time && pEntity->pev->pain_finished > gpGlobals->time )

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+508]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L42076
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+512]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L42076

; 2879 : 				pEntity->pev->dmg += 2;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+480]
	fadd	DWORD PTR __real@4@40008000000000000000
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+480]

; 2880 : 
; 2881 : 				if( pEntity->pev->dmg < 15 )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+480]
	fcomp	DWORD PTR __real@4@4002f000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L42077

; 2882 : 					pEntity->pev->dmg = 10; // quake1 original code

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+480], 1092616192		; 41200000H
$L42077:

; 2883 : 				pEntity->pev->pain_finished = gpGlobals->time + 1.0f;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+512]
$L42076:

; 2886 : 		else

	jmp	SHORT $L42078
$L42073:

; 2888 : 			pEntity->pev->air_finished = gpGlobals->time + 12.0f;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@4002c000000000000000
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+508]

; 2889 : 			pEntity->pev->dmg = 2;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+480], 1073741824		; 40000000H
$L42078:

; 2892 : 
; 2893 : 	if( !waterlevel )

	cmp	DWORD PTR _waterlevel$[ebp], 0
	jne	$L42079

; 2895 : 		if( flags & FL_INWATER )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	test	eax, eax
	je	$L42080

; 2899 : 			{

	push	3
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR -40+[ebp], eax
	cmp	DWORD PTR -40+[ebp], 3
	ja	$L42082
	mov	ecx, DWORD PTR -40+[ebp]
	jmp	DWORD PTR $L44155[ecx*4]
$L42085:

; 2900 : 			case 0:
; 2901 : 				EMIT_SOUND( pEntity->edict(), CHAN_BODY, "player/pl_wade1.wav", 1.0f, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 2902 : 				break;

	jmp	SHORT $L42082
$L42088:

; 2903 : 			case 1:
; 2904 : 				EMIT_SOUND( pEntity->edict(), CHAN_BODY, "player/pl_wade2.wav", 1.0f, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 2905 : 				break;

	jmp	SHORT $L42082
$L42091:

; 2906 : 			case 2:
; 2907 : 				EMIT_SOUND( pEntity->edict(), CHAN_BODY, "player/pl_wade3.wav", 1.0f, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@CEPA@player?1pl_wade3?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 2908 : 				break;

	jmp	SHORT $L42082
$L42094:

; 2909 : 			case 3:
; 2910 : 				EMIT_SOUND( pEntity->edict(), CHAN_BODY, "player/pl_wade4.wav", 1.0f, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@EEAK@player?1pl_wade4?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L42082:

; 2913 : 
; 2914 : 			pEntity->pev->flags = flags & ~FL_INWATER;

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx
$L42080:

; 2916 : 
; 2917 : 		pEntity->pev->air_finished = gpGlobals->time + 12.0f;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	DWORD PTR __real@4@4002c000000000000000
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+508]

; 2918 : 		return;

	jmp	$L42065
$L42079:

; 2920 : 
; 2921 : 	if( watertype == CONTENTS_LAVA )

	cmp	DWORD PTR _watertype$[ebp], -5		; fffffffbH
	jne	SHORT $L42097

; 2923 : 		if((!( flags & FL_GODMODE )) && pEntity->pev->dmgtime < gpGlobals->time )

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 64					; 00000040H
	test	edx, edx
	jne	SHORT $L42100
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+484]
	fcomp	DWORD PTR [edx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L42100

; 2925 : 			if( pEntity->pev->radsuit_finished < gpGlobals->time )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+516]
	fcomp	DWORD PTR [edx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L42099

; 2926 : 				pEntity->pev->dmgtime = gpGlobals->time + 0.2f;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@3ffccccccd0000000000
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+484]

; 2927 : 			else pEntity->pev->dmgtime = gpGlobals->time + 1.0f;

	jmp	SHORT $L42100
$L42099:
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+484]
$L42100:

; 2930 : 	else if( watertype == CONTENTS_SLIME )

	jmp	SHORT $L42104
$L42097:
	cmp	DWORD PTR _watertype$[ebp], -4		; fffffffcH
	jne	SHORT $L42104

; 2932 : 		if((!( flags & FL_GODMODE )) && pEntity->pev->dmgtime < gpGlobals->time )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $L42104
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx+484]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L42104

; 2934 : 			if( pEntity->pev->radsuit_finished < gpGlobals->time )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx+516]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L42104

; 2935 : 				pEntity->pev->dmgtime = gpGlobals->time + 1.0;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	QWORD PTR __real@8@3fff8000000000000000
	fst	DWORD PTR -44+[ebp]
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+484]
$L42104:

; 2939 : 
; 2940 : 	if(!( flags & FL_INWATER ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 16					; 00000010H
	test	ecx, ecx
	jne	$L42105

; 2942 : 		if( watertype == CONTENTS_WATER )

	cmp	DWORD PTR _watertype$[ebp], -3		; fffffffdH
	jne	$L42108

; 2946 : 			{

	push	3
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR -48+[ebp], eax
	cmp	DWORD PTR -48+[ebp], 3
	ja	$L42108
	mov	edx, DWORD PTR -48+[ebp]
	jmp	DWORD PTR $L44156[edx*4]
$L42111:

; 2947 : 			case 0:
; 2948 : 				EMIT_SOUND( pEntity->edict(), CHAN_BODY, "player/pl_wade1.wav", 1.0f, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 2949 : 				break;

	jmp	SHORT $L42108
$L42113:

; 2950 : 			case 1:
; 2951 : 				EMIT_SOUND( pEntity->edict(), CHAN_BODY, "player/pl_wade2.wav", 1.0f, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 2952 : 				break;

	jmp	SHORT $L42108
$L42115:

; 2953 : 			case 2:
; 2954 : 				EMIT_SOUND( pEntity->edict(), CHAN_BODY, "player/pl_wade3.wav", 1.0f, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@CEPA@player?1pl_wade3?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 2955 : 				break;

	jmp	SHORT $L42108
$L42117:

; 2956 : 			case 3:
; 2957 : 				EMIT_SOUND( pEntity->edict(), CHAN_BODY, "player/pl_wade4.wav", 1.0f, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@EEAK@player?1pl_wade4?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L42108:

; 2961 : 
; 2962 : 		pEntity->pev->flags = flags | FL_INWATER;

	mov	eax, DWORD PTR _flags$[ebp]
	or	al, 16					; 00000010H
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+420], eax

; 2963 : 		pEntity->pev->dmgtime = 0.0f;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+484], 0
$L42105:

; 2965 : 
; 2966 : 	if(!( flags & FL_WATERJUMP ) && !pEntity->IsRigidBody( ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 2048				; 00000800H
	test	edx, edx
	jne	SHORT $L42119
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+76]
	test	eax, eax
	jne	SHORT $L42119

; 2968 : 		pEntity->pev->velocity += pEntity->pev->velocity * ( pEntity->pev->waterlevel * -0.8f * gpGlobals->frametime );

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fild	DWORD PTR [ecx+448]
	fmul	DWORD PTR __real@4@bffecccccd0000000000
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fmul	DWORD PTR [edx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T44146[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 32					; 00000020H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 32					; 00000020H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=
$L42119:
$L42065:

; 2970 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L44155:
	DD	$L42085
	DD	$L42088
	DD	$L42091
	DD	$L42094
$L44156:
	DD	$L42111
	DD	$L42113
	DD	$L42115
	DD	$L42117
?UTIL_WaterMove@@YAXPAVCBaseEntity@@@Z ENDP		; UTIL_WaterMove
_TEXT	ENDS
;	COMDAT ?UTIL_LoadSoundPreset@@YAHH@Z
_TEXT	SEGMENT
_iString$ = 8
_pString$42125 = -4
?UTIL_LoadSoundPreset@@YAHH@Z PROC NEAR			; UTIL_LoadSoundPreset, COMDAT

; 2973 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2974 : 	if( iString != NULL_STRING )

	cmp	DWORD PTR _iString$[ebp], 0
	je	SHORT $L42126

; 2976 : 		const char *pString = STRING( iString );

	mov	eax, DWORD PTR _iString$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _pString$42125[ebp], eax

; 2977 : 
; 2978 : 		if( Q_isdigit( pString ))

	mov	ecx, DWORD PTR _pString$42125[ebp]
	push	ecx
	call	?Q_isdigit@@YA_NPBD@Z			; Q_isdigit
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42126

; 2979 : 			return Q_atoi( pString );

	mov	edx, DWORD PTR _pString$42125[ebp]
	push	edx
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	jmp	SHORT $L42123
$L42126:

; 2981 : 
; 2982 : 	return iString;

	mov	eax, DWORD PTR _iString$[ebp]
$L42123:

; 2983 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_LoadSoundPreset@@YAHH@Z ENDP			; UTIL_LoadSoundPreset
_TEXT	ENDS
PUBLIC	??_C@_09LNMM@?$CFs?1bin?1?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BI@NFHJ@?$CFs?5loaded?5succesfully?$CB?6?$AA@ ; `string'
PUBLIC	?Sys_LoadLibrary@@YA_NPBDPAPAUHINSTANCE__@@PBUdllfunc_s@@@Z ; Sys_LoadLibrary
PUBLIC	?Sys_GetProcAddress@@YAPAXPAUHINSTANCE__@@PBD@Z	; Sys_GetProcAddress
PUBLIC	?Sys_FreeLibrary@@YAXPAPAUHINSTANCE__@@@Z	; Sys_FreeLibrary
EXTRN	__imp__LoadLibraryA@4:NEAR
;	COMDAT ??_C@_09LNMM@?$CFs?1bin?1?$CFs?$AA@
; File z:\xashxtsrc\server\util.cpp
CONST	SEGMENT
??_C@_09LNMM@?$CFs?1bin?1?$CFs?$AA@ DB '%s/bin/%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NFHJ@?$CFs?5loaded?5succesfully?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BI@NFHJ@?$CFs?5loaded?5succesfully?$CB?6?$AA@ DB '%s loaded succes'
	DB	'fully!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?Sys_LoadLibrary@@YA_NPBDPAPAUHINSTANCE__@@PBUdllfunc_s@@@Z
_TEXT	SEGMENT
_dllname$ = 8
_handle$ = 12
_fcts$ = 16
_gamefunc$ = -4
_dllpath$ = -132
_szDirName$ = -392
_dllhandle$ = -396
?Sys_LoadLibrary@@YA_NPBDPAPAUHINSTANCE__@@PBUdllfunc_s@@@Z PROC NEAR ; Sys_LoadLibrary, COMDAT

; 2992 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 464				; 000001d0H
	push	ebx
	push	esi
	push	edi

; 2993 : 	if( !handle ) return false;

	cmp	DWORD PTR _handle$[ebp], 0
	jne	SHORT $L42132
	xor	al, al
	jmp	$L42131
$L42132:

; 2996 : 
; 2997 : 	// Initializations
; 2998 : 	for( gamefunc = fcts; gamefunc && gamefunc->name != NULL; gamefunc++ )

	mov	eax, DWORD PTR _fcts$[ebp]
	mov	DWORD PTR _gamefunc$[ebp], eax
	jmp	SHORT $L42134
$L42135:
	mov	ecx, DWORD PTR _gamefunc$[ebp]
	add	ecx, 8
	mov	DWORD PTR _gamefunc$[ebp], ecx
$L42134:
	cmp	DWORD PTR _gamefunc$[ebp], 0
	je	SHORT $L42136
	mov	edx, DWORD PTR _gamefunc$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L42136

; 2999 : 		*gamefunc->func = NULL;

	mov	eax, DWORD PTR _gamefunc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $L42135
$L42136:

; 3000 : 
; 3001 : 	char dllpath[128];
; 3002 : 	char szDirName[MAX_PATH];
; 3003 : 
; 3004 : 	GET_GAME_DIR( szDirName );

	lea	edx, DWORD PTR _szDirName$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+396
	add	esp, 4

; 3005 : 
; 3006 : 	// is direct path used ?
; 3007 : 	if( dllname[0] == '*' ) Q_strncpy( dllpath, dllname + 1, sizeof( dllpath ));

	mov	eax, DWORD PTR _dllname$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $L42139
	push	128					; 00000080H
	mov	edx, DWORD PTR _dllname$[ebp]
	add	edx, 1
	push	edx
	lea	eax, DWORD PTR _dllpath$[ebp]
	push	eax
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 3008 : 	else Q_snprintf( dllpath, sizeof( dllpath ), "%s/bin/%s", szDirName, dllname );

	jmp	SHORT $L42140
$L42139:
	mov	ecx, DWORD PTR _dllname$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDirName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_09LNMM@?$CFs?1bin?1?$CFs?$AA@ ; `string'
	push	128					; 00000080H
	lea	eax, DWORD PTR _dllpath$[ebp]
	push	eax
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 20					; 00000014H
$L42140:

; 3009 : 
; 3010 : 	dllhandle_t dllhandle = LoadLibrary( dllpath );

	lea	ecx, DWORD PTR _dllpath$[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	DWORD PTR _dllhandle$[ebp], eax

; 3011 :         
; 3012 : 	// No DLL found
; 3013 : 	if( !dllhandle ) return false;

	cmp	DWORD PTR _dllhandle$[ebp], 0
	jne	SHORT $L42143
	xor	al, al
	jmp	$L42131
$L42143:

; 3014 : 
; 3015 : 	// Get the function adresses
; 3016 : 	for( gamefunc = fcts; gamefunc && gamefunc->name != NULL; gamefunc++ )

	mov	edx, DWORD PTR _fcts$[ebp]
	mov	DWORD PTR _gamefunc$[ebp], edx
	jmp	SHORT $L42144
$L42145:
	mov	eax, DWORD PTR _gamefunc$[ebp]
	add	eax, 8
	mov	DWORD PTR _gamefunc$[ebp], eax
$L42144:
	cmp	DWORD PTR _gamefunc$[ebp], 0
	je	SHORT $L42146
	mov	ecx, DWORD PTR _gamefunc$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L42146

; 3018 : 		if( !( *gamefunc->func = (void *)Sys_GetProcAddress( dllhandle, gamefunc->name )))

	mov	edx, DWORD PTR _gamefunc$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _dllhandle$[ebp]
	push	ecx
	call	?Sys_GetProcAddress@@YAPAXPAUHINSTANCE__@@PBD@Z ; Sys_GetProcAddress
	add	esp, 8
	mov	edx, DWORD PTR _gamefunc$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR _gamefunc$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L42148

; 3020 : 			Sys_FreeLibrary( &dllhandle );

	lea	ecx, DWORD PTR _dllhandle$[ebp]
	push	ecx
	call	?Sys_FreeLibrary@@YAXPAPAUHINSTANCE__@@@Z ; Sys_FreeLibrary
	add	esp, 4

; 3021 : 			return false;

	xor	al, al
	jmp	SHORT $L42131
$L42148:

; 3023 : 	}          

	jmp	SHORT $L42145
$L42146:

; 3024 : 
; 3025 : 	ALERT( at_aiconsole, "%s loaded succesfully!\n", (dllname[0] == '*') ? (dllname+1) : (dllname));

	mov	edx, DWORD PTR _dllname$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $L44161
	mov	ecx, DWORD PTR _dllname$[ebp]
	add	ecx, 1
	mov	DWORD PTR -400+[ebp], ecx
	jmp	SHORT $L44162
$L44161:
	mov	edx, DWORD PTR _dllname$[ebp]
	mov	DWORD PTR -400+[ebp], edx
$L44162:
	mov	eax, DWORD PTR -400+[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BI@NFHJ@?$CFs?5loaded?5succesfully?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 3026 : 	*handle = dllhandle;

	mov	ecx, DWORD PTR _handle$[ebp]
	mov	edx, DWORD PTR _dllhandle$[ebp]
	mov	DWORD PTR [ecx], edx

; 3027 : 
; 3028 : 	return true;

	mov	al, 1
$L42131:

; 3029 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Sys_LoadLibrary@@YA_NPBDPAPAUHINSTANCE__@@PBUdllfunc_s@@@Z ENDP ; Sys_LoadLibrary
_TEXT	ENDS
EXTRN	__imp__GetProcAddress@8:NEAR
;	COMDAT ?Sys_GetProcAddress@@YAPAXPAUHINSTANCE__@@PBD@Z
_TEXT	SEGMENT
_handle$ = 8
_name$ = 12
?Sys_GetProcAddress@@YAPAXPAUHINSTANCE__@@PBD@Z PROC NEAR ; Sys_GetProcAddress, COMDAT

; 3032 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3033 : 	return (void *)GetProcAddress( handle, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8

; 3034 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Sys_GetProcAddress@@YAPAXPAUHINSTANCE__@@PBD@Z ENDP	; Sys_GetProcAddress
_TEXT	ENDS
EXTRN	__imp__FreeLibrary@4:NEAR
;	COMDAT ?Sys_FreeLibrary@@YAXPAPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_handle$ = 8
?Sys_FreeLibrary@@YAXPAPAUHINSTANCE__@@@Z PROC NEAR	; Sys_FreeLibrary, COMDAT

; 3037 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3038 : 	if( !handle || !*handle )

	cmp	DWORD PTR _handle$[ebp], 0
	je	SHORT $L42159
	mov	eax, DWORD PTR _handle$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L42158
$L42159:

; 3039 : 		return;

	jmp	SHORT $L42157
$L42158:

; 3040 : 
; 3041 : 	FreeLibrary( *handle );

	mov	ecx, DWORD PTR _handle$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__FreeLibrary@4

; 3042 : 	*handle = NULL;

	mov	eax, DWORD PTR _handle$[ebp]
	mov	DWORD PTR [eax], 0
$L42157:

; 3043 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Sys_FreeLibrary@@YAXPAPAUHINSTANCE__@@@Z ENDP		; Sys_FreeLibrary
_TEXT	ENDS
PUBLIC	??0?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@HHP6A_NABQBD0@Z@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CUtlMap<char const *,IEntityFactory *,unsigned short>
PUBLIC	?SetLessFunc@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXP6A_NABQBD0@Z@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::SetLessFunc
PUBLIC	??1?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ	; CUtlMap<char const *,IEntityFactory *,unsigned short>::~CUtlMap<char const *,IEntityFactory *,unsigned short>
PUBLIC	?StringLessThan@@YA_NABQBD0@Z			; StringLessThan
PUBLIC	?CaselessStringLessThan@@YA_NABQBD0@Z		; CaselessStringLessThan
PUBLIC	?CaselessStringLessThanIgnoreSlashes@@YA_NABQBD0@Z ; CaselessStringLessThanIgnoreSlashes
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utldict.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_compareType$ = 8
_growSize$ = 12
_initSize$ = 16
_this$ = -16
??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z PROC NEAR	; CUtlDict<IEntityFactory *,unsigned short>::CUtlDict<IEntityFactory *,unsigned short>, COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@HHP6A_NABQBD0@Z@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CUtlMap<char const *,IEntityFactory *,unsigned short>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 	if ( compareType == k_eDictCompareTypeFilenames )

	cmp	DWORD PTR _compareType$[ebp], 2
	jne	SHORT $L42188

; 98   : 		m_Elements.SetLessFunc( CaselessStringLessThanIgnoreSlashes );

	push	OFFSET FLAT:?CaselessStringLessThanIgnoreSlashes@@YA_NABQBD0@Z ; CaselessStringLessThanIgnoreSlashes
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLessFunc@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXP6A_NABQBD0@Z@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::SetLessFunc

; 100  : 	else if ( compareType == k_eDictCompareTypeCaseInsensitive )

	jmp	SHORT $L42191
$L42188:
	cmp	DWORD PTR _compareType$[ebp], 1
	jne	SHORT $L42190

; 102  : 		m_Elements.SetLessFunc( CaselessStringLessThan );

	push	OFFSET FLAT:?CaselessStringLessThan@@YA_NABQBD0@Z ; CaselessStringLessThan
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLessFunc@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXP6A_NABQBD0@Z@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::SetLessFunc

; 104  : 	else

	jmp	SHORT $L42191
$L42190:

; 106  : 		m_Elements.SetLessFunc( StringLessThan );

	push	OFFSET FLAT:?StringLessThan@@YA_NABQBD0@Z ; StringLessThan
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLessFunc@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXP6A_NABQBD0@Z@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::SetLessFunc
$L42191:

; 108  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::~CUtlMap<char const *,IEntityFactory *,unsigned short>
	ret	0
__ehhandler$??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlDict@PAVIEntityFactory@@G@@QAE@HHH@Z ENDP	; CUtlDict<IEntityFactory *,unsigned short>::CUtlDict<IEntityFactory *,unsigned short>
EXTRN	_strcmp:NEAR
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT
_lhs$ = 8
_rhs$ = 12
?StringLessThan@@YA_NABQBD0@Z PROC NEAR			; StringLessThan, COMDAT

; 36   : inline bool StringLessThan( const char * const &lhs, const char * const &rhs)			{ return ( strcmp( lhs, rhs) < 0 );  }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lhs$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strcmp
	add	esp, 8
	xor	ecx, ecx
	test	eax, eax
	setl	cl
	mov	al, cl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StringLessThan@@YA_NABQBD0@Z ENDP			; StringLessThan
_TEXT	ENDS
;	COMDAT ?CaselessStringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT
_lhs$ = 8
_rhs$ = 12
?CaselessStringLessThan@@YA_NABQBD0@Z PROC NEAR		; CaselessStringLessThan, COMDAT

; 37   : inline bool CaselessStringLessThan( const char * const &lhs, const char * const &rhs )	{ return ( stricmp( lhs, rhs) < 0 ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lhs$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_stricmp
	add	esp, 8
	xor	ecx, ecx
	test	eax, eax
	setl	cl
	mov	al, cl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CaselessStringLessThan@@YA_NABQBD0@Z ENDP		; CaselessStringLessThan
_TEXT	ENDS
;	COMDAT ?CaselessStringLessThanIgnoreSlashes@@YA_NABQBD0@Z
_TEXT	SEGMENT
_lhs$ = 8
_rhs$ = 12
_pa$ = -4
_pb$ = -8
_a$30366 = -12
_b$30367 = -16
?CaselessStringLessThanIgnoreSlashes@@YA_NABQBD0@Z PROC NEAR ; CaselessStringLessThanIgnoreSlashes, COMDAT

; 41   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 42   : 	const char *pa = lhs;

	mov	eax, DWORD PTR _lhs$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pa$[ebp], ecx

; 43   : 	const char *pb = rhs;

	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pb$[ebp], eax
$L30364:

; 44   : 	while ( *pa && *pb )

	mov	ecx, DWORD PTR _pa$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$L30365
	mov	eax, DWORD PTR _pb$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$L30365

; 46   : 		char a = *pa;

	mov	edx, DWORD PTR _pa$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _a$30366[ebp], al

; 47   : 		char b = *pb;

	mov	ecx, DWORD PTR _pb$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _b$30367[ebp], dl

; 48   : 		
; 49   : 		// Check for dir slashes.
; 50   : 		if ( a == '/' || a == '\\' )

	movsx	eax, BYTE PTR _a$30366[ebp]
	cmp	eax, 47					; 0000002fH
	je	SHORT $L30369
	movsx	ecx, BYTE PTR _a$30366[ebp]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $L30368
$L30369:

; 52   : 			if ( b != '/' && b != '\\' )

	movsx	edx, BYTE PTR _b$30367[ebp]
	cmp	edx, 47					; 0000002fH
	je	SHORT $L30370
	movsx	eax, BYTE PTR _b$30367[ebp]
	cmp	eax, 92					; 0000005cH
	je	SHORT $L30370

; 53   : 				return ('/' < b);

	movsx	ecx, BYTE PTR _b$30367[ebp]
	xor	eax, eax
	cmp	ecx, 47					; 0000002fH
	setg	al
	jmp	SHORT $L30360
$L30370:

; 55   : 		else

	jmp	SHORT $L30376
$L30368:

; 57   : 			if ( a >= 'a' && a <= 'z' )

	movsx	edx, BYTE PTR _a$30366[ebp]
	cmp	edx, 97					; 00000061H
	jl	SHORT $L30372
	movsx	eax, BYTE PTR _a$30366[ebp]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $L30372

; 58   : 				a = 'A' + (a - 'a');

	movsx	ecx, BYTE PTR _a$30366[ebp]
	sub	ecx, 32					; 00000020H
	mov	BYTE PTR _a$30366[ebp], cl
$L30372:

; 59   : 			
; 60   : 			if ( b >= 'a' && b <= 'z' )

	movsx	edx, BYTE PTR _b$30367[ebp]
	cmp	edx, 97					; 00000061H
	jl	SHORT $L30373
	movsx	eax, BYTE PTR _b$30367[ebp]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $L30373

; 61   : 				b = 'A' + (b - 'a');

	movsx	ecx, BYTE PTR _b$30367[ebp]
	sub	ecx, 32					; 00000020H
	mov	BYTE PTR _b$30367[ebp], cl
$L30373:

; 62   : 				
; 63   : 			if ( a > b )

	movsx	edx, BYTE PTR _a$30366[ebp]
	movsx	eax, BYTE PTR _b$30367[ebp]
	cmp	edx, eax
	jle	SHORT $L30374

; 64   : 				return false;

	xor	al, al
	jmp	SHORT $L30360
$L30374:

; 65   : 			else if ( a < b )

	movsx	ecx, BYTE PTR _a$30366[ebp]
	movsx	edx, BYTE PTR _b$30367[ebp]
	cmp	ecx, edx
	jge	SHORT $L30376

; 66   : 				return true;

	mov	al, 1
	jmp	SHORT $L30360
$L30376:

; 68   : 		++pa;

	mov	eax, DWORD PTR _pa$[ebp]
	add	eax, 1
	mov	DWORD PTR _pa$[ebp], eax

; 69   : 		++pb;

	mov	ecx, DWORD PTR _pb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pb$[ebp], ecx

; 70   : 	}

	jmp	$L30364
$L30365:

; 71   : 	
; 72   : 	return false;

	xor	al, al
$L30360:

; 73   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CaselessStringLessThanIgnoreSlashes@@YA_NABQBD0@Z ENDP	; CaselessStringLessThanIgnoreSlashes
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlDict@PAVIEntityFactory@@G@@QAEXXZ	; CUtlDict<IEntityFactory *,unsigned short>::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utldict.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ PROC NEAR	; CUtlDict<IEntityFactory *,unsigned short>::~CUtlDict<IEntityFactory *,unsigned short>, COMDAT

; 112  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 113  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlDict@PAVIEntityFactory@@G@@QAEXXZ ; CUtlDict<IEntityFactory *,unsigned short>::Purge

; 114  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::~CUtlMap<char const *,IEntityFactory *,unsigned short>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::~CUtlMap<char const *,IEntityFactory *,unsigned short>
	ret	0
__ehhandler$??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlDict@PAVIEntityFactory@@G@@QAE@XZ ENDP		; CUtlDict<IEntityFactory *,unsigned short>::~CUtlDict<IEntityFactory *,unsigned short>
PUBLIC	?Element@?$CUtlDict@PAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z ; CUtlDict<IEntityFactory *,unsigned short>::Element
;	COMDAT ??A?$CUtlDict@PAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlDict@PAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z PROC NEAR ; CUtlDict<IEntityFactory *,unsigned short>::operator[], COMDAT

; 154  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 	return Element(i); 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlDict@PAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z ; CUtlDict<IEntityFactory *,unsigned short>::Element

; 156  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlDict@PAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z ENDP ; CUtlDict<IEntityFactory *,unsigned short>::operator[]
_TEXT	ENDS
PUBLIC	?Key@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEAAPBDG@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Key
;	COMDAT ?GetElementName@?$CUtlDict@PAVIEntityFactory@@G@@QAEPADG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?GetElementName@?$CUtlDict@PAVIEntityFactory@@G@@QAEPADG@Z PROC NEAR ; CUtlDict<IEntityFactory *,unsigned short>::GetElementName, COMDAT

; 142  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 	return (char *)m_Elements.Key( i );

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Key@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEAAPBDG@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Key
	mov	eax, DWORD PTR [eax]

; 144  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetElementName@?$CUtlDict@PAVIEntityFactory@@G@@QAEPADG@Z ENDP ; CUtlDict<IEntityFactory *,unsigned short>::GetElementName
_TEXT	ENDS
PUBLIC	?InvalidIndex@?$CUtlMap@PBDPAVIEntityFactory@@G@@SAGXZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::InvalidIndex
;	COMDAT ?InvalidIndex@?$CUtlDict@PAVIEntityFactory@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlDict@PAVIEntityFactory@@G@@SAGXZ PROC NEAR ; CUtlDict<IEntityFactory *,unsigned short>::InvalidIndex, COMDAT

; 199  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 200  : 	return DictElementMap_t::InvalidIndex(); 

	call	?InvalidIndex@?$CUtlMap@PBDPAVIEntityFactory@@G@@SAGXZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::InvalidIndex

; 201  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlDict@PAVIEntityFactory@@G@@SAGXZ ENDP ; CUtlDict<IEntityFactory *,unsigned short>::InvalidIndex
_TEXT	ENDS
PUBLIC	?Insert@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEGABQBDABQAVIEntityFactory@@@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Insert
EXTRN	_strdup:NEAR
;	COMDAT ?Insert@?$CUtlDict@PAVIEntityFactory@@G@@QAEGPBDABQAVIEntityFactory@@@Z
_TEXT	SEGMENT
$T44203 = -8
_pName$ = 8
_element$ = 12
_this$ = -4
?Insert@?$CUtlDict@PAVIEntityFactory@@G@@QAEGPBDABQAVIEntityFactory@@@Z PROC NEAR ; CUtlDict<IEntityFactory *,unsigned short>::Insert, COMDAT

; 272  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 273  : 	return m_Elements.Insert( strdup( pName ), element );

	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	call	_strdup
	add	esp, 4
	mov	DWORD PTR $T44203[ebp], eax
	mov	ecx, DWORD PTR _element$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T44203[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEGABQBDABQAVIEntityFactory@@@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Insert

; 274  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@?$CUtlDict@PAVIEntityFactory@@G@@QAEGPBDABQAVIEntityFactory@@@Z ENDP ; CUtlDict<IEntityFactory *,unsigned short>::Insert
_TEXT	ENDS
PUBLIC	?Find@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGABQBD@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Find
;	COMDAT ?Find@?$CUtlDict@PAVIEntityFactory@@G@@QBEGPBD@Z
_TEXT	SEGMENT
_pName$ = 8
_this$ = -4
?Find@?$CUtlDict@PAVIEntityFactory@@G@@QBEGPBD@Z PROC NEAR ; CUtlDict<IEntityFactory *,unsigned short>::Find, COMDAT

; 288  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 289  : 	if ( pName )

	cmp	DWORD PTR _pName$[ebp], 0
	je	SHORT $L42216

; 290  : 		return m_Elements.Find( pName );

	lea	eax, DWORD PTR _pName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Find@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGABQBD@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Find
	jmp	SHORT $L42217
$L42216:

; 292  : 		return InvalidIndex();

	call	?InvalidIndex@?$CUtlDict@PAVIEntityFactory@@G@@SAGXZ ; CUtlDict<IEntityFactory *,unsigned short>::InvalidIndex
$L42217:

; 293  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Find@?$CUtlDict@PAVIEntityFactory@@G@@QBEGPBD@Z ENDP	; CUtlDict<IEntityFactory *,unsigned short>::Find
_TEXT	ENDS
PUBLIC	?FirstInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGXZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::FirstInorder
;	COMDAT ?First@?$CUtlDict@PAVIEntityFactory@@G@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
?First@?$CUtlDict@PAVIEntityFactory@@G@@QBEGXZ PROC NEAR ; CUtlDict<IEntityFactory *,unsigned short>::First, COMDAT

; 301  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 302  : 	return m_Elements.FirstInorder();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FirstInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGXZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::FirstInorder

; 303  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?First@?$CUtlDict@PAVIEntityFactory@@G@@QBEGXZ ENDP	; CUtlDict<IEntityFactory *,unsigned short>::First
_TEXT	ENDS
PUBLIC	?NextInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGG@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::NextInorder
;	COMDAT ?Next@?$CUtlDict@PAVIEntityFactory@@G@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Next@?$CUtlDict@PAVIEntityFactory@@G@@QBEGG@Z PROC NEAR ; CUtlDict<IEntityFactory *,unsigned short>::Next, COMDAT

; 307  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 308  : 	return m_Elements.NextInorder(i);

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGG@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::NextInorder

; 309  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Next@?$CUtlDict@PAVIEntityFactory@@G@@QBEGG@Z ENDP	; CUtlDict<IEntityFactory *,unsigned short>::Next
_TEXT	ENDS
PUBLIC	??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::~CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >
;	COMDAT ??1?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ PROC NEAR	; CUtlMap<char const *,IEntityFactory *,unsigned short>::~CUtlMap<char const *,IEntityFactory *,unsigned short>, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::~CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ ENDP	; CUtlMap<char const *,IEntityFactory *,unsigned short>::~CUtlMap<char const *,IEntityFactory *,unsigned short>
_TEXT	ENDS
PUBLIC	??0CKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@P6A_NABQBD0@Z@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::CKeyLess
PUBLIC	??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >
;	COMDAT ??0?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@HHP6A_NABQBD0@Z@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_lessfunc$ = 16
$T44215 = -8
_this$ = -4
??0?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@HHP6A_NABQBD0@Z@Z PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CUtlMap<char const *,IEntityFactory *,unsigned short>, COMDAT

; 50   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _lessfunc$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T44215[ebp]
	call	??0CKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@P6A_NABQBD0@Z@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::CKeyLess
	push	eax
	mov	ecx, DWORD PTR _initSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _growSize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >

; 51   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@HHP6A_NABQBD0@Z@Z ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CUtlMap<char const *,IEntityFactory *,unsigned short>
_TEXT	ENDS
PUBLIC	?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEAAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element
;	COMDAT ?Key@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEAAPBDG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Key@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEAAPBDG@Z PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Key, COMDAT

; 65   : 	KeyType_t &			Key( IndexType_t i )				{ return m_Tree.Element( i ).key; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEAAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Key@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEAAPBDG@Z ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Key
_TEXT	ENDS
PUBLIC	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
;	COMDAT ?InvalidIndex@?$CUtlMap@PBDPAVIEntityFactory@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlMap@PBDPAVIEntityFactory@@G@@SAGXZ PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::InvalidIndex, COMDAT

; 82   : 	static IndexType_t InvalidIndex()						{ return CTree::InvalidIndex(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlMap@PBDPAVIEntityFactory@@G@@SAGXZ ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::InvalidIndex
_TEXT	ENDS
PUBLIC	?SetLessFunc@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetLessFunc
;	COMDAT ?SetLessFunc@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXP6A_NABQBD0@Z@Z
_TEXT	SEGMENT
_func$ = 8
$T44223 = -8
_this$ = -4
?SetLessFunc@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXP6A_NABQBD0@Z@Z PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::SetLessFunc, COMDAT

; 86   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 		m_Tree.SetLessFunc( CKeyLess( func ) );

	mov	eax, DWORD PTR _func$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T44223[ebp]
	call	??0CKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@P6A_NABQBD0@Z@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::CKeyLess
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLessFunc@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetLessFunc

; 88   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLessFunc@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXP6A_NABQBD0@Z@Z ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::SetLessFunc
_TEXT	ENDS
PUBLIC	??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t::Node_t
PUBLIC	?Insert@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEGABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Insert
;	COMDAT ?Insert@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEGABQBDABQAVIEntityFactory@@@Z
_TEXT	SEGMENT
_key$ = 8
_insert$ = 12
_this$ = -4
_node$ = -12
?Insert@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEGABQBDABQAVIEntityFactory@@@Z PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Insert, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		Node_t node;

	lea	ecx, DWORD PTR _node$[ebp]
	call	??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t::Node_t

; 94   : 		node.key = key;

	mov	eax, DWORD PTR _key$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _node$[ebp], ecx

; 95   : 		node.elem = insert;

	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _node$[ebp+4], eax

; 96   : 		return m_Tree.Insert( node );

	lea	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEGABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Insert

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEGABQBDABQAVIEntityFactory@@@Z ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Insert
_TEXT	ENDS
PUBLIC	?Find@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Find
;	COMDAT ?Find@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGABQBD@Z
_TEXT	SEGMENT
_key$ = 8
_this$ = -4
_dummyNode$ = -12
?Find@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGABQBD@Z PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Find, COMDAT

; 108  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 		Node_t dummyNode;

	lea	ecx, DWORD PTR _dummyNode$[ebp]
	call	??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t::Node_t

; 110  : 		dummyNode.key = key;

	mov	eax, DWORD PTR _key$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dummyNode$[ebp], ecx

; 111  : 		return m_Tree.Find( dummyNode );

	lea	edx, DWORD PTR _dummyNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Find@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Find

; 112  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Find@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGABQBD@Z ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Find
_TEXT	ENDS
PUBLIC	?FirstInorder@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::FirstInorder
;	COMDAT ?FirstInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
?FirstInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGXZ PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::FirstInorder, COMDAT

; 126  : 	IndexType_t  FirstInorder() const						{ return m_Tree.FirstInorder(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FirstInorder@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::FirstInorder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FirstInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGXZ ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::FirstInorder
_TEXT	ENDS
PUBLIC	?NextInorder@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::NextInorder
;	COMDAT ?NextInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?NextInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGG@Z PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::NextInorder, COMDAT

; 127  : 	IndexType_t  NextInorder( IndexType_t i ) const			{ return m_Tree.NextInorder( i ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextInorder@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::NextInorder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?NextInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGG@Z ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::NextInorder
_TEXT	ENDS
;	COMDAT ??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t::Node_t, COMDAT

; 159  : 		Node_t()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		{
; 161  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t::Node_t
_TEXT	ENDS
;	COMDAT ??0CKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@P6A_NABQBD0@Z@Z
_TEXT	SEGMENT
_lessFunc$ = 8
_this$ = -4
??0CKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@P6A_NABQBD0@Z@Z PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::CKeyLess, COMDAT

; 176  : 		CKeyLess( LessFunc_t lessFunc ) : m_LessFunc(lessFunc) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lessFunc$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@P6A_NABQBD0@Z@Z ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::CKeyLess
_TEXT	ENDS
PUBLIC	??A?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::operator[]
;	COMDAT ?Element@?$CUtlDict@PAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlDict@PAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z PROC NEAR ; CUtlDict<IEntityFactory *,unsigned short>::Element, COMDAT

; 127  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 	return m_Elements[i]; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::operator[]

; 129  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlDict@PAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z ENDP ; CUtlDict<IEntityFactory *,unsigned short>::Element
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlDict@PAVIEntityFactory@@G@@QAEXXZ ; CUtlDict<IEntityFactory *,unsigned short>::RemoveAll
;	COMDAT ?Purge@?$CUtlDict@PAVIEntityFactory@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlDict@PAVIEntityFactory@@G@@QAEXXZ PROC NEAR ; CUtlDict<IEntityFactory *,unsigned short>::Purge, COMDAT

; 246  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlDict@PAVIEntityFactory@@G@@QAEXXZ ; CUtlDict<IEntityFactory *,unsigned short>::RemoveAll

; 248  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlDict@PAVIEntityFactory@@G@@QAEXXZ ENDP	; CUtlDict<IEntityFactory *,unsigned short>::Purge
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@HH@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>
PUBLIC	??1?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::~CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>
PUBLIC	?InvalidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIterator
PUBLIC	?ResetDbgInfo@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlrbtree.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
_TEXT	SEGMENT
$T44242 = -20
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_lessfunc$ = 16
_this$ = -16
??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >, COMDAT

; 362  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _lessfunc$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@HH@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+16], ax
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], 0
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+20], ax
	lea	edx, DWORD PTR $T44242[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?InvalidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIterator
	mov	ax, WORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+22], ax

; 363  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::ResetDbgInfo

; 364  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::~CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>
	ret	0
__ehhandler$??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@HHABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >
PUBLIC	?Purge@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlrbtree.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::~CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >, COMDAT

; 380  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 381  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Purge

; 382  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::~CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::~CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>
	ret	0
__ehhandler$??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAE@XZ ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::~CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >
PUBLIC	??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEAAU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::operator[]
;	COMDAT ?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEAAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEAAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element, COMDAT

; 410  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 411  : 	return m_Elements[i].m_Data; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEAAU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::operator[]
	add	eax, 8

; 412  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEAAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element
_TEXT	ENDS
PUBLIC	?InvalidIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@SAGXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIndex
;	COMDAT ?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex, COMDAT

; 548  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 549  : 	return ( I )M::InvalidIndex();

	call	?InvalidIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@SAGXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIndex

; 550  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
_TEXT	ENDS
PUBLIC	??7CKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NXZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::operator!
PUBLIC	?Count@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEIXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Count
PUBLIC	??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
;	COMDAT ??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@
; File z:\xashxtsrc\game_shared\utlrbtree.h
CONST	SEGMENT
??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlrbtree.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ?SetLessFunc@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
_TEXT	SEGMENT
_func$ = 8
_this$ = -4
?SetLessFunc@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetLessFunc, COMDAT

; 1424 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1425 : 	if (!m_LessFunc)

	mov	ecx, DWORD PTR _this$[ebp]
	call	??7CKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NXZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::operator!
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42382

; 1427 : 		m_LessFunc = func;

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 1429 : 	else if ( Count() > 0 )

	jmp	SHORT $L44265
$L42382:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEIXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Count
	test	eax, eax
	jbe	SHORT $L44265

; 1431 : 		// need to re-sort the tree here....
; 1432 : 		assert(0);

	xor	eax, eax
	test	eax, eax
	jne	SHORT $L44265
	push	1432					; 00000598H
	push	OFFSET FLAT:??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44265:

; 1434 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLessFunc@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXABVCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetLessFunc
_TEXT	ENDS
PUBLIC	?InsertAt@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEGG_N@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InsertAt
PUBLIC	?FindInsertionPosition@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@AAGAA_N@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::FindInsertionPosition
PUBLIC	?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z ; CopyConstruct
;	COMDAT ?Insert@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEGABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
_TEXT	SEGMENT
_insert$ = 8
_this$ = -4
_parent$ = -8
_leftchild$ = -12
_newNode$ = -16
?Insert@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEGABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Insert, COMDAT

; 1467 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1468 : 	// use copy constructor to copy it in
; 1469 : 	I parent;
; 1470 : 	bool leftchild;
; 1471 : 	FindInsertionPosition( insert, parent, leftchild );

	lea	eax, DWORD PTR _leftchild$[ebp]
	push	eax
	lea	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _insert$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindInsertionPosition@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@AAGAA_N@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::FindInsertionPosition

; 1472 : 	I newNode = InsertAt( parent, leftchild );

	mov	al, BYTE PTR _leftchild$[ebp]
	push	eax
	mov	cx, WORD PTR _parent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertAt@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEGG_N@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InsertAt
	mov	WORD PTR _newNode$[ebp], ax

; 1473 : 	CopyConstruct( &Element( newNode ), insert );

	mov	edx, DWORD PTR _insert$[ebp]
	push	edx
	mov	ax, WORD PTR _newNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEAAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z ; CopyConstruct
	add	esp, 8

; 1474 : 	return newNode;

	mov	ax, WORD PTR _newNode$[ebp]

; 1475 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEGABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Insert
_TEXT	ENDS
PUBLIC	??RCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NABUNode_t@1@0@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::operator()
PUBLIC	?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element
PUBLIC	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
PUBLIC	?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RightChild
PUBLIC	??_C@_0M@JPEA@?$CGm_LessFunc?$AA@		; `string'
;	COMDAT ??_C@_0M@JPEA@?$CGm_LessFunc?$AA@
; File z:\xashxtsrc\game_shared\utlrbtree.h
CONST	SEGMENT
??_C@_0M@JPEA@?$CGm_LessFunc?$AA@ DB '&m_LessFunc', 00H	; `string'
CONST	ENDS
;	COMDAT ?Find@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
_TEXT	SEGMENT
_search$ = 8
_this$ = -4
_current$ = -8
?Find@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Find, COMDAT

; 1525 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1526 : 	assert( &m_LessFunc );

	cmp	DWORD PTR _this$[ebp], 0
	jne	SHORT $L44270
	push	1526					; 000005f6H
	push	OFFSET FLAT:??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
	push	OFFSET FLAT:??_C@_0M@JPEA@?$CGm_LessFunc?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44270:

; 1527 : 
; 1528 : 	I current = m_Root;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+16]
	mov	WORD PTR _current$[ebp], dx
$L42408:

; 1529 : 	while (current != InvalidIndex()) 

	mov	esi, DWORD PTR _current$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L42409

; 1531 : 		if (m_LessFunc( search, Element(current) ))

	mov	ax, WORD PTR _current$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??RCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NABUNode_t@1@0@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::operator()
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42410

; 1532 : 			current = LeftChild(current);

	mov	dx, WORD PTR _current$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
	mov	WORD PTR _current$[ebp], ax

; 1533 : 		else if (m_LessFunc( Element(current), search ))

	jmp	SHORT $L42413
$L42410:
	mov	eax, DWORD PTR _search$[ebp]
	push	eax
	mov	cx, WORD PTR _current$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??RCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NABUNode_t@1@0@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::operator()
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42412

; 1534 : 			current = RightChild(current);

	mov	dx, WORD PTR _current$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RightChild
	mov	WORD PTR _current$[ebp], ax

; 1535 : 		else 

	jmp	SHORT $L42413
$L42412:

; 1536 : 			break;

	jmp	SHORT $L42409
$L42413:

; 1537 : 	}

	jmp	$L42408
$L42409:

; 1538 : 	return current;

	mov	ax, WORD PTR _current$[ebp]

; 1539 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Find@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Find
_TEXT	ENDS
;	COMDAT ?FirstInorder@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?FirstInorder@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGXZ PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::FirstInorder, COMDAT

; 1154 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1155 : 	I i = m_Root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	mov	WORD PTR _i$[ebp], cx
$L42419:

; 1156 : 	while (LeftChild(i) != InvalidIndex())

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
	mov	si, ax
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L42420

; 1157 : 		i = LeftChild(i);

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $L42419
$L42420:

; 1158 : 	return i;

	mov	ax, WORD PTR _i$[ebp]

; 1159 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FirstInorder@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGXZ ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::FirstInorder
_TEXT	ENDS
PUBLIC	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
PUBLIC	?IsRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRightChild
PUBLIC	?IsValidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsValidIndex
PUBLIC	??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@	; `string'
;	COMDAT ??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlrbtree.h
CONST	SEGMENT
??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@ DB 'IsValidIndex(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ?NextInorder@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
_parent$ = -8
?NextInorder@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::NextInorder, COMDAT

; 1163 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1164 : 	assert(IsValidIndex(i));

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L44275
	push	1164					; 0000048cH
	push	OFFSET FLAT:??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@MBHJ@IsValidIndex?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44275:

; 1165 : 
; 1166 : 	if (RightChild(i) != InvalidIndex())

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RightChild
	mov	si, ax
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L42427

; 1168 : 		i = RightChild(i);

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RightChild
	mov	WORD PTR _i$[ebp], ax
$L42429:

; 1169 : 		while (LeftChild(i) != InvalidIndex())

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
	mov	si, ax
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L42430

; 1170 : 			i = LeftChild(i);

	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $L42429
$L42430:

; 1171 : 		return i;

	mov	ax, WORD PTR _i$[ebp]
	jmp	SHORT $L42424
$L42427:

; 1173 : 
; 1174 : 	I parent = Parent(i);

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	mov	WORD PTR _parent$[ebp], ax
$L42433:

; 1175 : 	while (IsRightChild(i))

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRightChild
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42434

; 1177 : 		i = parent;

	mov	dx, WORD PTR _parent$[ebp]
	mov	WORD PTR _i$[ebp], dx

; 1178 : 		if (i == InvalidIndex()) break;

	mov	esi, DWORD PTR _i$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L42435
	jmp	SHORT $L42434
$L42435:

; 1179 : 		parent = Parent(i);

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	mov	WORD PTR _parent$[ebp], ax

; 1180 : 	}

	jmp	SHORT $L42433
$L42434:

; 1181 : 	return parent;

	mov	ax, WORD PTR _parent$[ebp]
$L42424:

; 1182 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?NextInorder@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::NextInorder
_TEXT	ENDS
;	COMDAT ??A?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::operator[], COMDAT

; 63   : 	ElemType_t &		operator[]( IndexType_t i )			{ return m_Tree.Element( i ).elem; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEAAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element
	add	eax, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEAAPAVIEntityFactory@@G@Z ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::operator[]
_TEXT	ENDS
;	COMDAT ??7CKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
??7CKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NXZ PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::operator!, COMDAT

; 179  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 			return !m_LessFunc;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	sete	cl
	mov	al, cl

; 181  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??7CKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NXZ ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::operator!
_TEXT	ENDS
;	COMDAT ??RCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NABUNode_t@1@0@Z
_TEXT	SEGMENT
_left$ = 8
_right$ = 12
_this$ = -4
??RCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NABUNode_t@1@0@Z PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::operator(), COMDAT

; 184  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 			return m_LessFunc( left.key, right.key );

	mov	eax, DWORD PTR _right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _left$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	add	esp, 8

; 186  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??RCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NABUNode_t@1@0@Z ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::operator()
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEPAU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Base
;	COMDAT ?ResetDbgInfo@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXXZ PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::ResetDbgInfo, COMDAT

; 293  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 294  : 		m_pElements = (Node_t*)m_Elements.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Base@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEPAU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 295  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXXZ ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	??0Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@G@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::Iterator_t
;	COMDAT ?InvalidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ
_TEXT	SEGMENT
$T44286 = -8
___$ReturnUdt$ = 8
_this$ = -4
?InvalidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIterator, COMDAT

; 93   : 	Iterator_t InvalidIterator() const					{ return Iterator_t( InvalidIndex() ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	call	?InvalidIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@SAGXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIndex
	push	eax
	lea	ecx, DWORD PTR $T44286[ebp]
	call	??0Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@G@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::Iterator_t
	mov	ax, WORD PTR [eax]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	WORD PTR [ecx], ax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InvalidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIterator
_TEXT	ENDS
;	COMDAT ?InvalidIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@SAGXZ PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIndex, COMDAT

; 103  : 	static I InvalidIndex() { return ( I )-1; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	or	ax, 65535				; 0000ffffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@SAGXZ ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIndex
_TEXT	ENDS
;	COMDAT ??0Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??0Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@G@Z PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::Iterator_t, COMDAT

; 82   : 		Iterator_t( I i ) : index( i ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax], cx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@G@Z ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::Iterator_t
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXXZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::RemoveAll
EXTRN	_free:NEAR
;	COMDAT ?RemoveAll@?$CUtlDict@PAVIEntityFactory@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_index$ = -8
?RemoveAll@?$CUtlDict@PAVIEntityFactory@@G@@QAEXXZ PROC NEAR ; CUtlDict<IEntityFactory *,unsigned short>::RemoveAll, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 	typename DictElementMap_t::IndexType_t index = m_Elements.FirstInorder();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FirstInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGXZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::FirstInorder
	mov	WORD PTR _index$[ebp], ax
$L42552:

; 235  : 	while ( index != m_Elements.InvalidIndex() )

	mov	esi, DWORD PTR _index$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlMap@PBDPAVIEntityFactory@@G@@SAGXZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L42553

; 237  : 		free( (void *)m_Elements.Key( index ) );

	mov	ax, WORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Key@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEAAPBDG@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Key
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 238  : 		index = m_Elements.NextInorder( index );

	mov	dx, WORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextInorder@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBEGG@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::NextInorder
	mov	WORD PTR _index$[ebp], ax

; 239  : 	}

	jmp	SHORT $L42552
$L42553:

; 240  : 
; 241  : 	m_Elements.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXXZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::RemoveAll

; 242  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlDict@PAVIEntityFactory@@G@@QAEXXZ ENDP	; CUtlDict<IEntityFactory *,unsigned short>::RemoveAll
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEABU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::operator[]
;	COMDAT ?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element, COMDAT

; 416  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 417  : 	return m_Elements[i].m_Data; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEABU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::operator[]
	add	eax, 8

; 418  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEIXZ PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Count, COMDAT

; 454  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 455  : 	return (unsigned int)m_NumElements; 

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+18]
	mov	eax, ecx

; 456  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEIXZ ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Count
_TEXT	ENDS
PUBLIC	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
;	COMDAT ?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent, COMDAT

; 475  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 476  : 	return Links(i).m_Parent; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	mov	ax, WORD PTR [eax+4]

; 477  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
_TEXT	ENDS
;	COMDAT ?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild, COMDAT

; 481  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 482  : 	return Links(i).m_Left; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	mov	ax, WORD PTR [eax]

; 483  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
_TEXT	ENDS
;	COMDAT ?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RightChild, COMDAT

; 487  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	return Links(i).m_Right; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	mov	ax, WORD PTR [eax+2]

; 489  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RightChild
_TEXT	ENDS
;	COMDAT ?IsRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRightChild, COMDAT

; 503  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 504  : 	return RightChild(Parent(i)) == i; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RightChild
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	xor	edx, edx
	cmp	eax, ecx
	sete	dl
	mov	al, dl

; 505  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRightChild
_TEXT	ENDS
PUBLIC	?IsIdxAfter@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NGABVIterator_t@1@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxAfter
PUBLIC	?IsIdxValid@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NG@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxValid
;	COMDAT ?IsValidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsValidIndex, COMDAT

; 531  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 532  : 	if ( !m_Elements.IsIdxValid( i ) )

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?IsIdxValid@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NG@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42583

; 533  : 		return false;

	xor	al, al
	jmp	SHORT $L42582
$L42583:

; 534  : 
; 535  : 	if ( m_Elements.IsIdxAfter( i, m_LastAlloc ) )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 22					; 00000016H
	push	ecx
	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?IsIdxAfter@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NGABVIterator_t@1@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxAfter
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42584

; 536  : 		return false; // don't read values that have been allocated, but not constructed

	xor	al, al
	jmp	SHORT $L42582
$L42584:

; 537  : 
; 538  : 	return LeftChild(i) != i; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	xor	edx, edx
	cmp	eax, ecx
	setne	dl
	mov	al, dl
$L42582:

; 539  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEXXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Purge
;	COMDAT ?Purge@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXXZ
_TEXT	SEGMENT
$T44309 = -8
_this$ = -4
?Purge@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXXZ PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Purge, COMDAT

; 1140 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1141 : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RemoveAll

; 1142 : 	m_FirstFree = InvalidIndex();

	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+20], ax

; 1143 : 	m_Elements.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Purge@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEXXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Purge

; 1144 : 	m_LastAlloc = m_Elements.InvalidIterator();

	lea	edx, DWORD PTR $T44309[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?InvalidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIterator
	mov	ax, WORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+22], ax

; 1145 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXXZ ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Purge
_TEXT	ENDS
PUBLIC	?IsValid@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsValid
PUBLIC	?NewNode@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::NewNode
PUBLIC	?LinkToParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG_N@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LinkToParent
PUBLIC	??_C@_09MKKF@IsValid?$CI?$CJ?$AA@		; `string'
;	COMDAT ??_C@_09MKKF@IsValid?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlrbtree.h
CONST	SEGMENT
??_C@_09MKKF@IsValid?$CI?$CJ?$AA@ DB 'IsValid()', 00H	; `string'
CONST	ENDS
;	COMDAT ?InsertAt@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEGG_N@Z
_TEXT	SEGMENT
_parent$ = 8
_leftchild$ = 12
_this$ = -4
_i$ = -8
?InsertAt@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEGG_N@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InsertAt, COMDAT

; 843  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 844  : 	I i = NewNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NewNode@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::NewNode
	mov	WORD PTR _i$[ebp], ax

; 845  : 	LinkToParent( i, parent, leftchild );

	mov	al, BYTE PTR _leftchild$[ebp]
	push	eax
	mov	cx, WORD PTR _parent$[ebp]
	push	ecx
	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkToParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG_N@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LinkToParent

; 846  : 	++m_NumElements;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+18]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+18], cx

; 847  : 
; 848  : 	assert(IsValid());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValid@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L44312
	push	848					; 00000350H
	push	OFFSET FLAT:??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
	push	OFFSET FLAT:??_C@_09MKKF@IsValid?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44312:

; 849  : 
; 850  : 	return i;

	mov	ax, WORD PTR _i$[ebp]

; 851  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertAt@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEGG_N@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InsertAt
_TEXT	ENDS
;	COMDAT ?FindInsertionPosition@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@AAGAA_N@Z
_TEXT	SEGMENT
_insert$ = 8
_parent$ = 12
_leftchild$ = 16
_this$ = -4
_current$ = -8
?FindInsertionPosition@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@AAGAA_N@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::FindInsertionPosition, COMDAT

; 1444 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1445 : 	assert( &m_LessFunc );

	cmp	DWORD PTR _this$[ebp], 0
	jne	SHORT $L44315
	push	1445					; 000005a5H
	push	OFFSET FLAT:??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
	push	OFFSET FLAT:??_C@_0M@JPEA@?$CGm_LessFunc?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44315:

; 1446 : 
; 1447 : 	/* find where node belongs */
; 1448 : 	I current = m_Root;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+16]
	mov	WORD PTR _current$[ebp], dx

; 1449 : 	parent = InvalidIndex();

	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	mov	ecx, DWORD PTR _parent$[ebp]
	mov	WORD PTR [ecx], ax

; 1450 : 	leftchild = false;

	mov	edx, DWORD PTR _leftchild$[ebp]
	mov	BYTE PTR [edx], 0
$L42606:

; 1451 : 	while (current != InvalidIndex()) 

	mov	esi, DWORD PTR _current$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L42607

; 1453 : 		parent = current;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	cx, WORD PTR _current$[ebp]
	mov	WORD PTR [eax], cx

; 1454 : 		if (m_LessFunc( insert, Element(current) ))

	mov	dx, WORD PTR _current$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEAAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element
	push	eax
	mov	eax, DWORD PTR _insert$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??RCKeyLess@?$CUtlMap@PBDPAVIEntityFactory@@G@@QBE_NABUNode_t@1@0@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess::operator()
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42608

; 1456 : 			leftchild = true; current = LeftChild(current);

	mov	ecx, DWORD PTR _leftchild$[ebp]
	mov	BYTE PTR [ecx], 1
	mov	dx, WORD PTR _current$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
	mov	WORD PTR _current$[ebp], ax

; 1458 : 		else

	jmp	SHORT $L42609
$L42608:

; 1460 : 			leftchild = false; current = RightChild(current);

	mov	eax, DWORD PTR _leftchild$[ebp]
	mov	BYTE PTR [eax], 0
	mov	cx, WORD PTR _current$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RightChild
	mov	WORD PTR _current$[ebp], ax
$L42609:

; 1462 : 	}

	jmp	SHORT $L42606
$L42607:

; 1463 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?FindInsertionPosition@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXABUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@AAGAA_N@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::FindInsertionPosition
_TEXT	ENDS
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
PUBLIC	?ValidateGrowSize@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@IAEXXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::ValidateGrowSize
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@HH@Z PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@IAEXXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L44318
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44318:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L42616

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L42616:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@HH@Z ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@XZ PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::~CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEXXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@XZ ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::~CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>
_TEXT	ENDS
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
PUBLIC	?IsReadOnly@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsReadOnly
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEAAU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEAAU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L44323
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44323:

; 425  : 	assert( IsIdxValid(i) );

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NG@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L44324
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44324:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEAAU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEPAU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEPAU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@XZ PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L44327
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44327:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEPAU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@XZ ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Base
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@ABU01@@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t::Node_t
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlmemory.h
xdata$x	SEGMENT
__ehfuncinfo$?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z$0
xdata$x	ENDS
;	COMDAT ?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z
_TEXT	SEGMENT
$T44330 = -16
$T44331 = -20
__$EHRec$ = -12
_pMemory$ = 8
_src$ = 12
?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z PROC NEAR ; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T44331[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T44331[ebp], 0
	je	SHORT $L44332
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T44331[ebp]
	call	??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@ABU01@@Z ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t::Node_t
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L44333
$L44332:
	mov	DWORD PTR -24+[ebp], 0
$L44333:
	mov	edx, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T44330[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 45   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z$0:
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T44331[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?CopyConstruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@ABU12@@Z ENDP ; CopyConstruct
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 79   : 	{return; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RemoveAll@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXXZ PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::RemoveAll, COMDAT

; 123  : 	void     RemoveAll( )									{ m_Tree.RemoveAll(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RemoveAll
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAEXXZ ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::RemoveAll
_TEXT	ENDS
;	COMDAT ??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@ABU01@@Z
_TEXT	SEGMENT
_from$ = 8
_this$ = -4
??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@ABU01@@Z PROC NEAR ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t::Node_t, COMDAT

; 166  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _from$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _from$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 167  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@ABU01@@Z ENDP ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t::Node_t
_TEXT	ENDS
;	COMDAT ?IsIdxAfter@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NGABVIterator_t@1@@Z
_TEXT	SEGMENT
_i$ = 8
_it$ = 12
_this$ = -4
?IsIdxAfter@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NGABVIterator_t@1@@Z PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxAfter, COMDAT

; 91   : 	bool IsIdxAfter( I i, const Iterator_t &it ) const	{ return i > it.index; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _it$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx]
	xor	ecx, ecx
	cmp	eax, edx
	setg	cl
	mov	al, cl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?IsIdxAfter@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NGABVIterator_t@1@@Z ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxAfter
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@IAEXXZ PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@IAEXXZ ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::ValidateGrowSize
_TEXT	ENDS
PUBLIC	?Root@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Root
PUBLIC	??8Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::operator==
;	COMDAT ?IsValid@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NXZ
_TEXT	SEGMENT
$T44355 = -8
_this$ = -4
?IsValid@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NXZ PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsValid, COMDAT

; 1337 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1338 : 	if ( !Count() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEIXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Count
	test	eax, eax
	jne	SHORT $L42714

; 1339 : 		return true;

	mov	al, 1
	jmp	SHORT $L42713
$L42714:

; 1340 : 
; 1341 : 	if ( m_LastAlloc == m_Elements.InvalidIterator() )

	lea	eax, DWORD PTR $T44355[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?InvalidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIterator
	mov	cx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 22					; 00000016H
	call	??8Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::operator==
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42716

; 1342 : 		return false;

	xor	al, al
	jmp	SHORT $L42713
$L42716:

; 1343 : 
; 1344 : 	if ( !m_Elements.IsIdxValid( Root() ) )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Root@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Root
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?IsIdxValid@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NG@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42717

; 1345 : 		return false;

	xor	al, al
	jmp	SHORT $L42713
$L42717:

; 1346 : 
; 1347 : 	if ( Parent( Root() ) != InvalidIndex() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Root@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Root
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	mov	si, ax
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L42718

; 1348 : 		return false;

	xor	al, al
	jmp	SHORT $L42713
$L42718:

; 1349 : 
; 1350 : #ifdef UTLTREE_PARANOID
; 1351 : 
; 1352 : 	// First check to see that mNumEntries matches reality.
; 1353 : 	// count items on the free list
; 1354 : 	int numFree = 0;
; 1355 : 	for ( int i = m_FirstFree; i != InvalidIndex(); i = RightChild( i ) )
; 1356 : 	{
; 1357 : 		++numFree;
; 1358 : 		if ( !m_Elements.IsIdxValid( i ) )
; 1359 : 			return false;
; 1360 : 	}
; 1361 : 
; 1362 : 	// iterate over all elements, looking for validity 
; 1363 : 	// based on the self pointers
; 1364 : 	int nElements = 0;
; 1365 : 	int numFree2 = 0;
; 1366 : 	for ( M::Iterator_t it = m_Elements.First(); it != m_Elements.InvalidIterator(); it = m_Elements.Next( it ) )
; 1367 : 	{
; 1368 : 		I i = m_Elements.GetIndex( it );
; 1369 : 		if ( !IsValidIndex( i ) )
; 1370 : 		{
; 1371 : 			++numFree2;
; 1372 : 		}
; 1373 : 		else
; 1374 : 		{
; 1375 : 			++nElements;
; 1376 : 
; 1377 : 			int right = RightChild( i );
; 1378 : 			int left = LeftChild( i );
; 1379 : 			if ( ( right == left ) && ( right != InvalidIndex() ) )
; 1380 : 				return false;
; 1381 : 
; 1382 : 			if ( right != InvalidIndex() )
; 1383 : 			{
; 1384 : 				if ( !IsValidIndex( right ) ) 
; 1385 : 					return false;
; 1386 : 				if ( Parent( right ) != i )
; 1387 : 					return false;
; 1388 : 				if ( IsRed( i ) && IsRed( right ) ) 
; 1389 : 					return false;
; 1390 : 			}
; 1391 : 
; 1392 : 			if ( left != InvalidIndex() )
; 1393 : 			{
; 1394 : 				if ( !IsValidIndex( left ) ) 
; 1395 : 					return false;
; 1396 : 				if ( Parent( left ) != i ) 
; 1397 : 					return false;
; 1398 : 				if ( IsRed( i ) && IsRed( left ) ) 
; 1399 : 					return false;
; 1400 : 			}
; 1401 : 		}
; 1402 : 
; 1403 : 		if ( it == m_LastAlloc )
; 1404 : 			break;
; 1405 : 	}
; 1406 : 	if ( numFree2 != numFree )
; 1407 : 		return false;
; 1408 : 
; 1409 : 	if ( nElements != m_NumElements )
; 1410 : 		return false;
; 1411 : 
; 1412 : #endif // UTLTREE_PARANOID
; 1413 : 
; 1414 : 	return true;

	mov	al, 1
$L42713:

; 1415 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsValid@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NXZ ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsValid
_TEXT	ENDS
PUBLIC	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
PUBLIC	?First@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::First
PUBLIC	?Next@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@ABV21@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Next
PUBLIC	?GetIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEGABVIterator_t@1@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::GetIndex
PUBLIC	?IsValidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NABVIterator_t@1@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsValidIterator
PUBLIC	?Grow@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEXH@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Grow
PUBLIC	??_C@_0EA@LGGP@m_Elements?4IsValidIterator?$CI?5m_La@ ; `string'
PUBLIC	??_C@_0CB@IMPD@m_Elements?4IsValidIterator?$CI?5it?5?$CJ@ ; `string'
PUBLIC	??_C@_0BG@LCOD@CUtlRBTree?5overflow?$CB?6?$AA@	; `string'
PUBLIC	??_C@_0CK@EPOF@m_Elements?4IsValidIterator?$CI?5m_La@ ; `string'
PUBLIC	?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ; Construct
;	COMDAT ??_C@_0EA@LGGP@m_Elements?4IsValidIterator?$CI?5m_La@
; File z:\xashxtsrc\game_shared\utlrbtree.h
CONST	SEGMENT
??_C@_0EA@LGGP@m_Elements?4IsValidIterator?$CI?5m_La@ DB 'm_Elements.IsVa'
	DB	'lidIterator( m_LastAlloc ) || m_NumElements == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IMPD@m_Elements?4IsValidIterator?$CI?5it?5?$CJ@
CONST	SEGMENT
??_C@_0CB@IMPD@m_Elements?4IsValidIterator?$CI?5it?5?$CJ@ DB 'm_Elements.'
	DB	'IsValidIterator( it )', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LCOD@CUtlRBTree?5overflow?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BG@LCOD@CUtlRBTree?5overflow?$CB?6?$AA@ DB 'CUtlRBTree overflow!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EPOF@m_Elements?4IsValidIterator?$CI?5m_La@
CONST	SEGMENT
??_C@_0CK@EPOF@m_Elements?4IsValidIterator?$CI?5m_La@ DB 'm_Elements.IsVa'
	DB	'lidIterator( m_LastAlloc )', 00H		; `string'
CONST	ENDS
;	COMDAT ?NewNode@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEGXZ
_TEXT	SEGMENT
$T44359 = -20
$T44360 = -24
$T44361 = -28
$T44364 = -32
$T44365 = -36
$T44366 = -40
_this$ = -4
_elem$ = -8
_it$42726 = -12
_node$ = -16
?NewNode@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEGXZ PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::NewNode, COMDAT

; 648  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 649  : 	I elem;
; 650  : 
; 651  : 	// Nothing in the free list; add.
; 652  : 	if ( m_FirstFree == InvalidIndex() )

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+20]
	mov	esi, ecx
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	$L42723

; 654  : 		assert( m_Elements.IsValidIterator( m_LastAlloc ) || m_NumElements == 0 );

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 22					; 00000016H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?IsValidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NABVIterator_t@1@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsValidIterator
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L44358
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+18]
	test	ecx, ecx
	je	SHORT $L44358
	push	654					; 0000028eH
	push	OFFSET FLAT:??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
	push	OFFSET FLAT:??_C@_0EA@LGGP@m_Elements?4IsValidIterator?$CI?5m_La@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44358:

; 655  : 		typename M::Iterator_t it = m_Elements.IsValidIterator( m_LastAlloc ) ? m_Elements.Next( m_LastAlloc ) : m_Elements.First();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 22					; 00000016H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?IsValidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NABVIterator_t@1@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsValidIterator
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L44362
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 22					; 00000016H
	push	ecx
	lea	edx, DWORD PTR $T44360[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Next@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@ABV21@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Next
	mov	DWORD PTR -44+[ebp], eax
	jmp	SHORT $L44363
$L44362:
	lea	eax, DWORD PTR $T44361[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?First@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::First
	mov	DWORD PTR -44+[ebp], eax
$L44363:
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR $T44359[ebp], ecx
	mov	edx, DWORD PTR $T44359[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR _it$42726[ebp], ax

; 656  : 		if ( !m_Elements.IsValidIterator( it ) )

	lea	ecx, DWORD PTR _it$42726[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?IsValidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NABVIterator_t@1@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsValidIterator
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	$L42736

; 658  : 			m_Elements.Grow();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Grow@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEXH@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Grow

; 659  : 
; 660  : 			it = m_Elements.IsValidIterator( m_LastAlloc ) ? m_Elements.Next( m_LastAlloc ) : m_Elements.First();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 22					; 00000016H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?IsValidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NABVIterator_t@1@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsValidIterator
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L44367
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 22					; 00000016H
	push	eax
	lea	ecx, DWORD PTR $T44365[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Next@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@ABV21@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Next
	mov	DWORD PTR -48+[ebp], eax
	jmp	SHORT $L44368
$L44367:
	lea	edx, DWORD PTR $T44366[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?First@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::First
	mov	DWORD PTR -48+[ebp], eax
$L44368:
	mov	eax, DWORD PTR -48+[ebp]
	mov	DWORD PTR $T44364[ebp], eax
	mov	ecx, DWORD PTR $T44364[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR _it$42726[ebp], dx

; 661  : 
; 662  : 			assert( m_Elements.IsValidIterator( it ) );

	lea	eax, DWORD PTR _it$42726[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?IsValidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NABVIterator_t@1@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsValidIterator
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L44369
	push	662					; 00000296H
	push	OFFSET FLAT:??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
	push	OFFSET FLAT:??_C@_0CB@IMPD@m_Elements?4IsValidIterator?$CI?5it?5?$CJ@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44369:

; 663  : 			if ( !m_Elements.IsValidIterator( it ) )

	lea	edx, DWORD PTR _it$42726[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?IsValidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NABVIterator_t@1@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsValidIterator
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42736

; 665  : 				HOST_ERROR( "CUtlRBTree overflow!\n" );

	push	OFFSET FLAT:??_C@_0BG@LCOD@CUtlRBTree?5overflow?$CB?6?$AA@ ; `string'
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+24
	add	esp, 4
$L42736:

; 668  : 		m_LastAlloc = it;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _it$42726[ebp]
	mov	WORD PTR [eax+22], cx

; 669  : 		elem = m_Elements.GetIndex( m_LastAlloc );

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 22					; 00000016H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEGABVIterator_t@1@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::GetIndex
	mov	WORD PTR _elem$[ebp], ax

; 670  : 		assert( m_Elements.IsValidIterator( m_LastAlloc ) );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 22					; 00000016H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?IsValidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NABVIterator_t@1@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsValidIterator
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L44370
	push	670					; 0000029eH
	push	OFFSET FLAT:??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
	push	OFFSET FLAT:??_C@_0CK@EPOF@m_Elements?4IsValidIterator?$CI?5m_La@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44370:

; 672  : 	else

	jmp	SHORT $L42740
$L42723:

; 674  : 		elem = m_FirstFree;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+20]
	mov	WORD PTR _elem$[ebp], ax

; 675  : 		m_FirstFree = Links( m_FirstFree ).m_Right;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+20]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [eax+2]
	mov	WORD PTR [ecx+20], dx
$L42740:

; 677  : 
; 678  : #ifdef _DEBUG
; 679  : 	// reset links to invalid....
; 680  : 	Links_t &node = Links( elem );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	mov	DWORD PTR _node$[ebp], eax

; 681  : 	node.m_Left = node.m_Right = node.m_Parent = InvalidIndex();

	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	mov	ecx, DWORD PTR _node$[ebp]
	mov	WORD PTR [ecx+4], ax
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	cx, WORD PTR [eax+4]
	mov	WORD PTR [edx+2], cx
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	cx, WORD PTR [eax+2]
	mov	WORD PTR [edx], cx

; 682  : #endif
; 683  : 
; 684  : 	Construct( &Element( elem ) );

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEAAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element
	push	eax
	call	?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ; Construct
	add	esp, 4

; 685  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::ResetDbgInfo

; 686  : 
; 687  : 	return elem;

	mov	ax, WORD PTR _elem$[ebp]

; 688  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NewNode@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEGXZ ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::NewNode
_TEXT	ENDS
PUBLIC	?SetLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetLeftChild
PUBLIC	?SetRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetRightChild
PUBLIC	??9Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::operator!=
PUBLIC	??_C@_0BJ@PMK@m_Root?5?$DN?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BO@BLFE@m_FirstFree?5?$DN?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BD@OBAD@m_NumElements?5?$DN?$DN?50?$AA@	; `string'
PUBLIC	?Destruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ; Destruct
;	COMDAT ??_C@_0BJ@PMK@m_Root?5?$DN?$DN?5InvalidIndex?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlrbtree.h
CONST	SEGMENT
??_C@_0BJ@PMK@m_Root?5?$DN?$DN?5InvalidIndex?$CI?$CJ?$AA@ DB 'm_Root == I'
	DB	'nvalidIndex()', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BLFE@m_FirstFree?5?$DN?$DN?5InvalidIndex?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BO@BLFE@m_FirstFree?5?$DN?$DN?5InvalidIndex?$CI?$CJ?$AA@ DB 'm_Fir'
	DB	'stFree == InvalidIndex()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OBAD@m_NumElements?5?$DN?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BD@OBAD@m_NumElements?5?$DN?$DN?50?$AA@ DB 'm_NumElements == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ?RemoveAll@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXXZ
_TEXT	SEGMENT
$T44373 = -16
$T44377 = -20
$T44378 = -24
$T44379 = -28
_this$ = -4
_it$ = -8
_i$42764 = -12
?RemoveAll@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXXZ PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RemoveAll, COMDAT

; 1099 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1100 : 	// Have to do some convoluted stuff to invoke the destructor on all
; 1101 : 	// valid elements for the multilist case (since we don't have all elements
; 1102 : 	// connected to each other in a list).
; 1103 : 
; 1104 : 	if ( m_LastAlloc == m_Elements.InvalidIterator() )

	lea	eax, DWORD PTR $T44373[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?InvalidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIterator
	mov	cx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 22					; 00000016H
	call	??8Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::operator==
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L42750

; 1106 : 		assert( m_Root == InvalidIndex() );

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+16]
	mov	esi, eax
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L44374
	push	1106					; 00000452H
	push	OFFSET FLAT:??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
	push	OFFSET FLAT:??_C@_0BJ@PMK@m_Root?5?$DN?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44374:

; 1107 : 		assert( m_FirstFree == InvalidIndex() );

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+20]
	mov	esi, eax
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L44375
	push	1107					; 00000453H
	push	OFFSET FLAT:??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
	push	OFFSET FLAT:??_C@_0BO@BLFE@m_FirstFree?5?$DN?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44375:

; 1108 : 		assert( m_NumElements == 0 );

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+18]
	test	eax, eax
	je	SHORT $L44376
	push	1108					; 00000454H
	push	OFFSET FLAT:??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@OBAD@m_NumElements?5?$DN?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44376:

; 1109 : 		return;

	jmp	$L42748
$L42750:

; 1111 : 
; 1112 : 	for ( typename M::Iterator_t it = m_Elements.First(); it != m_Elements.InvalidIterator(); it = m_Elements.Next( it ) )

	lea	edx, DWORD PTR $T44377[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?First@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::First
	mov	ax, WORD PTR [eax]
	mov	WORD PTR _it$[ebp], ax
	jmp	SHORT $L42761
$L42762:
	lea	ecx, DWORD PTR _it$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T44378[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Next@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@ABV21@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Next
	mov	ax, WORD PTR [eax]
	mov	WORD PTR _it$[ebp], ax
$L42761:
	lea	ecx, DWORD PTR $T44379[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?InvalidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIterator
	mov	dx, WORD PTR [eax]
	push	edx
	lea	ecx, DWORD PTR _it$[ebp]
	call	??9Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::operator!=
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L42763

; 1114 : 		I i = m_Elements.GetIndex( it );

	lea	eax, DWORD PTR _it$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEGABVIterator_t@1@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::GetIndex
	mov	WORD PTR _i$42764[ebp], ax

; 1115 : 		if ( IsValidIndex( i ) ) // skip elements in the free list

	mov	cx, WORD PTR _i$42764[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42765

; 1117 : 			Destruct( &Element( i ) );

	mov	dx, WORD PTR _i$42764[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEAAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Element
	push	eax
	call	?Destruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ; Destruct
	add	esp, 4

; 1118 : 			SetRightChild( i, m_FirstFree );

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+20]
	push	ecx
	mov	dx, WORD PTR _i$42764[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetRightChild

; 1119 : 			SetLeftChild( i, i );

	mov	ax, WORD PTR _i$42764[ebp]
	push	eax
	mov	cx, WORD PTR _i$42764[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetLeftChild

; 1120 : 			m_FirstFree = i;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _i$42764[ebp]
	mov	WORD PTR [edx+20], ax
$L42765:

; 1122 : 
; 1123 : 		if ( it == m_LastAlloc )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+22]
	push	edx
	lea	ecx, DWORD PTR _it$[ebp]
	call	??8Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::operator==
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42770

; 1124 : 			break; // don't destruct elements that haven't ever been constucted

	jmp	SHORT $L42763
$L42770:

; 1125 : 	}

	jmp	$L42762
$L42763:

; 1126 : 
; 1127 : 	// Clear everything else out
; 1128 : 	m_Root = InvalidIndex(); 

	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+16], ax

; 1129 : 	m_NumElements = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+18], 0

; 1130 : 
; 1131 : 	assert( IsValid() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValid@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L44380
	push	1131					; 0000046bH
	push	OFFSET FLAT:??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
	push	OFFSET FLAT:??_C@_09MKKF@IsValid?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44380:
$L42748:

; 1132 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QAEXXZ ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RemoveAll
_TEXT	ENDS
PUBLIC	?InsertRebalance@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InsertRebalance
;	COMDAT ?LinkToParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG_N@Z
_TEXT	SEGMENT
_i$ = 8
_parent$ = 12
_isLeft$ = 16
_this$ = -4
_elem$ = -8
?LinkToParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG_N@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LinkToParent, COMDAT

; 855  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 856  : 	Links_t &elem = Links(i);

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	mov	DWORD PTR _elem$[ebp], eax

; 857  : 	elem.m_Parent = parent;

	mov	ecx, DWORD PTR _elem$[ebp]
	mov	dx, WORD PTR _parent$[ebp]
	mov	WORD PTR [ecx+4], dx

; 858  : 	elem.m_Left = elem.m_Right = InvalidIndex();

	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	mov	ecx, DWORD PTR _elem$[ebp]
	mov	WORD PTR [ecx+2], ax
	mov	edx, DWORD PTR _elem$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	cx, WORD PTR [eax+2]
	mov	WORD PTR [edx], cx

; 859  : 	elem.m_Tag = RED;

	mov	edx, DWORD PTR _elem$[ebp]
	mov	WORD PTR [edx+6], 0

; 860  : 
; 861  : 	/* insert node in tree */
; 862  : 	if (parent != InvalidIndex()) 

	mov	esi, DWORD PTR _parent$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L42779

; 864  : 		if (isLeft)

	mov	eax, DWORD PTR _isLeft$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42780

; 865  : 			Links(parent).m_Left = i;

	mov	cx, WORD PTR _parent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax], dx

; 866  : 		else

	jmp	SHORT $L42781
$L42780:

; 867  : 			Links(parent).m_Right = i;

	mov	ax, WORD PTR _parent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+2], cx
$L42781:

; 869  : 	else 

	jmp	SHORT $L42782
$L42779:

; 871  : 		m_Root = i;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _i$[ebp]
	mov	WORD PTR [edx+16], ax
$L42782:

; 873  : 
; 874  : 	InsertRebalance(i);	

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertRebalance@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InsertRebalance

; 875  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?LinkToParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG_N@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LinkToParent
_TEXT	ENDS
PUBLIC	?s_Sentinel@?1??Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z@4U3@A ; `CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links'::`2'::s_Sentinel
;	COMDAT ?s_Sentinel@?1??Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z@4U3@A
; File z:\xashxtsrc\game_shared\utlrbtree.h
_BSS	SEGMENT
?s_Sentinel@?1??Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z@4U3@A DQ 01H DUP (?) ; `CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links'::`2'::s_Sentinel
_BSS	ENDS
_DATA	SEGMENT
COMM	??_B?1??Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z@51:BYTE							; `CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links'::`2'::`local static guard'
_DATA	ENDS
;	COMDAT ?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z
_TEXT	SEGMENT
$T44385 = -8
_i$ = 8
_this$ = -4
?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links, COMDAT

; 591  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 592  : 	// Sentinel node, makes life easier
; 593  : 	static Links_t s_Sentinel = 
; 594  : 	{ 
; 595  : 		InvalidIndex(), InvalidIndex(), InvalidIndex(), CUtlRBTree<T, I, L, M>::BLACK 

	xor	eax, eax
	mov	al, BYTE PTR ??_B?1??Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z@51 ; `CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links'::`2'::`local static guard'
	and	eax, 1
	test	eax, eax
	jne	SHORT $L42791
	mov	cl, BYTE PTR ??_B?1??Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z@51 ; `CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links'::`2'::`local static guard'
	or	cl, 1
	mov	BYTE PTR ??_B?1??Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z@51, cl ; `CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links'::`2'::`local static guard'
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	mov	WORD PTR ?s_Sentinel@?1??Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z@4U3@A, ax
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	mov	WORD PTR ?s_Sentinel@?1??Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z@4U3@A+2, ax
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	mov	WORD PTR ?s_Sentinel@?1??Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z@4U3@A+4, ax

; 596  : 	};

	mov	WORD PTR ?s_Sentinel@?1??Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z@4U3@A+6, 1
$L42791:

; 597  : 
; 598  : 	return (i != InvalidIndex()) ? *(Links_t*)&m_Elements[i] : *(Links_t*)&s_Sentinel;

	mov	esi, DWORD PTR _i$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L44386
	mov	dx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEABU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::operator[]
	mov	DWORD PTR -12+[ebp], eax
	jmp	SHORT $L44387
$L44386:
	mov	DWORD PTR -12+[ebp], OFFSET FLAT:?s_Sentinel@?1??Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z@4U3@A ; `CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links'::`2'::s_Sentinel
$L44387:
	mov	eax, DWORD PTR -12+[ebp]
	mov	DWORD PTR $T44385[ebp], eax
	mov	eax, DWORD PTR $T44385[ebp]

; 599  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEABU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEABU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NG@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L44391
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44391:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 65535				; 0000ffffH
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEABU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::operator[]
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NG@Z PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	jl	SHORT $L44394
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+4]
	jge	SHORT $L44394
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L44395
$L44394:
	mov	DWORD PTR -8+[ebp], 0
$L44395:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NG@Z ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEXXZ PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42810

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L42811

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L42811:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L42810:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEXXZ ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?First@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ
_TEXT	SEGMENT
$T44402 = -8
___$ReturnUdt$ = 8
_this$ = -4
?First@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::First, COMDAT

; 88   : 	Iterator_t First() const							{ return Iterator_t( IsIdxValid( 0 ) ? 0 : InvalidIndex() ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NG@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L44403
	mov	DWORD PTR -12+[ebp], 0
	jmp	SHORT $L44404
$L44403:
	call	?InvalidIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@SAGXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR -12+[ebp], eax
$L44404:
	mov	ax, WORD PTR -12+[ebp]
	push	eax
	lea	ecx, DWORD PTR $T44402[ebp]
	call	??0Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@G@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::Iterator_t
	mov	cx, WORD PTR [eax]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?First@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@XZ ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::First
_TEXT	ENDS
;	COMDAT ?Next@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@ABV21@@Z
_TEXT	SEGMENT
$T44407 = -8
_it$ = 12
___$ReturnUdt$ = 8
_this$ = -4
?Next@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@ABV21@@Z PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Next, COMDAT

; 89   : 	Iterator_t Next( const Iterator_t &it ) const		{ return Iterator_t( IsIdxValid( it.index + 1 ) ? it.index + 1 : InvalidIndex() ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _it$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NG@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L44408
	mov	edx, DWORD PTR _it$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx]
	add	eax, 1
	mov	DWORD PTR -12+[ebp], eax
	jmp	SHORT $L44409
$L44408:
	call	?InvalidIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@SAGXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::InvalidIndex
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR -12+[ebp], eax
$L44409:
	mov	cx, WORD PTR -12+[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T44407[ebp]
	call	??0Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAE@G@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::Iterator_t
	mov	dx, WORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	WORD PTR [eax], dx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Next@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE?AVIterator_t@1@ABV21@@Z ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Next
_TEXT	ENDS
;	COMDAT ?GetIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEGABVIterator_t@1@@Z
_TEXT	SEGMENT
_it$ = 8
_this$ = -4
?GetIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEGABVIterator_t@1@@Z PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::GetIndex, COMDAT

; 90   : 	I GetIndex( const Iterator_t &it ) const			{ return it.index; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _it$[ebp]
	mov	ax, WORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetIndex@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBEGABVIterator_t@1@@Z ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::GetIndex
_TEXT	ENDS
;	COMDAT ?IsValidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NABVIterator_t@1@@Z
_TEXT	SEGMENT
_it$ = 8
_this$ = -4
?IsValidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NABVIterator_t@1@@Z PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsValidIterator, COMDAT

; 92   : 	bool IsValidIterator( const Iterator_t &it ) const	{ return IsIdxValid( it.index ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _it$[ebp]
	mov	cx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NG@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsIdxValid
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIterator@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NABVIterator_t@1@@Z ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsValidIterator
_TEXT	ENDS
;	COMDAT ??8Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z
_TEXT	SEGMENT
_it$ = 8
_this$ = -4
??8Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::operator==, COMDAT

; 85   : 		bool operator==( const Iterator_t it ) const	{ return index == it.index; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax]
	mov	edx, DWORD PTR _it$[ebp]
	and	edx, 65535				; 0000ffffH
	xor	eax, eax
	cmp	ecx, edx
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::operator==
_TEXT	ENDS
;	COMDAT ??9Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z
_TEXT	SEGMENT
_it$ = 8
_this$ = -4
??9Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::operator!=, COMDAT

; 86   : 		bool operator!=( const Iterator_t it ) const	{ return index != it.index; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax]
	mov	edx, DWORD PTR _it$[ebp]
	and	edx, 65535				; 0000ffffH
	xor	eax, eax
	cmp	ecx, edx
	setne	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Iterator_t@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NV01@@Z ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Iterator_t::operator!=
_TEXT	ENDS
;	COMDAT ?Root@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
?Root@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGXZ PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Root, COMDAT

; 444  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 	return m_Root; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+16]

; 446  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Root@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGXZ ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Root
_TEXT	ENDS
;	COMDAT ?SetLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z
_TEXT	SEGMENT
_i$ = 8
_child$ = 12
_this$ = -4
?SetLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetLeftChild, COMDAT

; 575  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 576  : 	Links(i).m_Left = child; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	mov	cx, WORD PTR _child$[ebp]
	mov	WORD PTR [eax], cx

; 577  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetLeftChild
_TEXT	ENDS
;	COMDAT ?SetRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z
_TEXT	SEGMENT
_i$ = 8
_child$ = 12
_this$ = -4
?SetRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetRightChild, COMDAT

; 581  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 582  : 	Links(i).m_Right = child; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	mov	cx, WORD PTR _child$[ebp]
	mov	WORD PTR [eax+2], cx

; 583  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetRightChild
_TEXT	ENDS
PUBLIC	??_C@_0BE@HIOD@i?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
;	COMDAT ??_C@_0BE@HIOD@i?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlrbtree.h
CONST	SEGMENT
??_C@_0BE@HIOD@i?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@ DB 'i != InvalidInd'
	DB	'ex()', 00H					; `string'
CONST	ENDS
;	COMDAT ?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links, COMDAT

; 603  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 604  : 	assert(i != InvalidIndex()); 

	mov	esi, DWORD PTR _i$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	jne	SHORT $L44426
	push	604					; 0000025cH
	push	OFFSET FLAT:??_C@_0CF@ENGD@z?3?2xashxtsrc?2game_shared?2utlrbtr@ ; `string'
	push	OFFSET FLAT:??_C@_0BE@HIOD@i?5?$CB?$DN?5InvalidIndex?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44426:

; 605  : 	return *(Links_t *)&m_Elements[i];

	mov	cx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEAAU?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@Z ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::operator[]

; 606  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
_TEXT	ENDS
PUBLIC	?IsLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsLeftChild
PUBLIC	?IsRoot@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRoot
PUBLIC	?IsRed@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRed
PUBLIC	?Color@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBE?AW4NodeColor_t@1@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Color
PUBLIC	?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor
PUBLIC	?RotateLeft@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RotateLeft
PUBLIC	?RotateRight@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RotateRight
;	COMDAT ?InsertRebalance@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_parent$42879 = -8
_grandparent$42880 = -12
_uncle$42882 = -16
_uncle$42887 = -20
?InsertRebalance@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InsertRebalance, COMDAT

; 768  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
$L42877:

; 769  : 	while ( !IsRoot(elem) && (Color(Parent(elem)) == RED) )

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRoot@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRoot
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	$L42878
	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Color@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBE?AW4NodeColor_t@1@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Color
	test	eax, eax
	jne	$L42878

; 771  : 		I parent = Parent(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	mov	WORD PTR _parent$42879[ebp], ax

; 772  : 		I grandparent = Parent(parent);

	mov	ax, WORD PTR _parent$42879[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	mov	WORD PTR _grandparent$42880[ebp], ax

; 773  : 
; 774  : 		/* we have a violation */
; 775  : 		if (IsLeftChild(parent))

	mov	cx, WORD PTR _parent$42879[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsLeftChild
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L42881

; 777  : 			I uncle = RightChild(grandparent);

	mov	dx, WORD PTR _grandparent$42880[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RightChild
	mov	WORD PTR _uncle$42882[ebp], ax

; 778  : 			if (IsRed(uncle)) 

	mov	ax, WORD PTR _uncle$42882[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRed@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRed
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42883

; 780  : 				/* uncle is RED */
; 781  : 				SetColor(parent, BLACK);

	push	1
	mov	cx, WORD PTR _parent$42879[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor

; 782  : 				SetColor(uncle, BLACK);

	push	1
	mov	dx, WORD PTR _uncle$42882[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor

; 783  : 				SetColor(grandparent, RED);

	push	0
	mov	ax, WORD PTR _grandparent$42880[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor

; 784  : 				elem = grandparent;

	mov	cx, WORD PTR _grandparent$42880[ebp]
	mov	WORD PTR _elem$[ebp], cx

; 786  : 			else 

	jmp	SHORT $L42884
$L42883:

; 788  : 				/* uncle is BLACK */
; 789  : 				if (IsRightChild(elem))

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRightChild
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42885

; 791  : 					/* make x a left child, will change parent and grandparent */
; 792  : 					elem = parent;

	mov	ax, WORD PTR _parent$42879[ebp]
	mov	WORD PTR _elem$[ebp], ax

; 793  : 					RotateLeft(elem);

	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotateLeft@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RotateLeft

; 794  : 					parent = Parent(elem);

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	mov	WORD PTR _parent$42879[ebp], ax

; 795  : 					grandparent = Parent(parent);

	mov	ax, WORD PTR _parent$42879[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	mov	WORD PTR _grandparent$42880[ebp], ax
$L42885:

; 797  : 				/* recolor and rotate */
; 798  : 				SetColor(parent, BLACK);

	push	1
	mov	cx, WORD PTR _parent$42879[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor

; 799  : 				SetColor(grandparent, RED);

	push	0
	mov	dx, WORD PTR _grandparent$42880[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor

; 800  : 				RotateRight(grandparent);

	mov	ax, WORD PTR _grandparent$42880[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotateRight@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RotateRight
$L42884:

; 803  : 		else 

	jmp	$L42889
$L42881:

; 805  : 			/* mirror image of above code */
; 806  : 			I uncle = LeftChild(grandparent);

	mov	cx, WORD PTR _grandparent$42880[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
	mov	WORD PTR _uncle$42887[ebp], ax

; 807  : 			if (IsRed(uncle)) 

	mov	dx, WORD PTR _uncle$42887[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRed@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRed
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42888

; 809  : 				/* uncle is RED */
; 810  : 				SetColor(parent, BLACK);

	push	1
	mov	ax, WORD PTR _parent$42879[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor

; 811  : 				SetColor(uncle, BLACK);

	push	1
	mov	cx, WORD PTR _uncle$42887[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor

; 812  : 				SetColor(grandparent, RED);

	push	0
	mov	dx, WORD PTR _grandparent$42880[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor

; 813  : 				elem = grandparent;

	mov	ax, WORD PTR _grandparent$42880[ebp]
	mov	WORD PTR _elem$[ebp], ax

; 815  : 			else 

	jmp	SHORT $L42889
$L42888:

; 817  : 				/* uncle is BLACK */
; 818  : 				if (IsLeftChild(elem))

	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsLeftChild
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42890

; 820  : 					/* make x a right child, will change parent and grandparent */
; 821  : 					elem = parent;

	mov	dx, WORD PTR _parent$42879[ebp]
	mov	WORD PTR _elem$[ebp], dx

; 822  : 					RotateRight(parent);

	mov	ax, WORD PTR _parent$42879[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotateRight@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RotateRight

; 823  : 					parent = Parent(elem);

	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	mov	WORD PTR _parent$42879[ebp], ax

; 824  : 					grandparent = Parent(parent);

	mov	dx, WORD PTR _parent$42879[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	mov	WORD PTR _grandparent$42880[ebp], ax
$L42890:

; 826  : 				/* recolor and rotate */
; 827  : 				SetColor(parent, BLACK);

	push	1
	mov	ax, WORD PTR _parent$42879[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor

; 828  : 				SetColor(grandparent, RED);

	push	0
	mov	cx, WORD PTR _grandparent$42880[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor

; 829  : 				RotateLeft(grandparent);

	mov	dx, WORD PTR _grandparent$42880[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotateLeft@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RotateLeft
$L42889:

; 832  : 	}

	jmp	$L42877
$L42878:

; 833  : 	SetColor( m_Root, BLACK );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor

; 834  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InsertRebalance@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InsertRebalance
_TEXT	ENDS
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEXH@Z PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L44431
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44431:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42896

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L44432
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44432:

; 567  : 		return;

	jmp	$L42894
$L42896:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	16					; 00000010H
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	$L42915

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $L42907
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	and	ecx, 65535				; 0000ffffH
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L42907

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 583  : 		else

	jmp	SHORT $L42915
$L42907:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	and	edx, 65535				; 0000ffffH
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L42911

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	eax, eax
	test	eax, eax
	jne	SHORT $L44433
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44433:

; 589  : 				return;

	jmp	$L42894
$L42911:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L42915

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 594  : 			}

	jmp	SHORT $L42911
$L42915:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L42918

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 601  : 		assert( m_pMemory );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L44434
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44434:

; 603  : 	else

	jmp	SHORT $L44435
$L42918:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 4
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L44435
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44435:
$L42894:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QAEXH@Z ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L28985

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L28990
$L28985:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L28987

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L28987:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L28990

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L28987
$L28990:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ PROC NEAR ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@QBE_NXZ ENDP ; CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlmemory.h
xdata$x	SEGMENT
__ehfuncinfo$?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z$0
xdata$x	ENDS
;	COMDAT ?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
_TEXT	SEGMENT
$T44442 = -16
$T44443 = -20
__$EHRec$ = -12
_pMemory$ = 8
?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z PROC NEAR ; Construct, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 38   : 	new( pMemory ) T;

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T44443[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T44443[ebp], 0
	je	SHORT $L44444
	mov	ecx, DWORD PTR $T44443[ebp]
	call	??0Node_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@QAE@XZ ; CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t::Node_t
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L44445
$L44444:
	mov	DWORD PTR -24+[ebp], 0
$L44445:
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T44442[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 39   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z$0:
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T44443[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?Construct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ENDP ; Construct
EXTRN	_memset:NEAR
;	COMDAT ?Destruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z PROC NEAR ; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	8
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@@Z ENDP ; Destruct
_TEXT	ENDS
;	COMDAT ?IsLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsLeftChild, COMDAT

; 497  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 498  : 	return LeftChild(Parent(i)) == i; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 65535				; 0000ffffH
	xor	edx, edx
	cmp	eax, ecx
	sete	dl
	mov	al, dl

; 499  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsLeftChild
_TEXT	ENDS
;	COMDAT ?IsRoot@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsRoot@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRoot, COMDAT

; 514  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 	return i == m_Root; 

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+16]
	xor	ecx, ecx
	cmp	eax, edx
	sete	cl
	mov	al, cl

; 516  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsRoot@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRoot
_TEXT	ENDS
;	COMDAT ?IsRed@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBE_NG@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsRed@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBE_NG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRed, COMDAT

; 614  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 615  : 	return (Links(i).m_Tag == RED); 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+6]
	mov	eax, ecx
	neg	eax
	sbb	eax, eax
	inc	eax

; 616  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsRed@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBE_NG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRed
_TEXT	ENDS
;	COMDAT ?Color@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBE?AW4NodeColor_t@1@G@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Color@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBE?AW4NodeColor_t@1@G@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Color, COMDAT

; 631  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 632  : 	return (NodeColor_t)Links(i).m_Tag; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBEABU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+6]
	mov	eax, ecx

; 633  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Color@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IBE?AW4NodeColor_t@1@G@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Color
_TEXT	ENDS
;	COMDAT ?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z
_TEXT	SEGMENT
_i$ = 8
_c$ = 12
_this$ = -4
?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor, COMDAT

; 637  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 	Links(i).m_Tag = (I)c; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	mov	cx, WORD PTR _c$[ebp]
	mov	WORD PTR [eax+6], cx

; 639  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetColor@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGW4NodeColor_t@1@@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetColor
_TEXT	ENDS
PUBLIC	?SetParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetParent
;	COMDAT ?RotateLeft@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_rightchild$ = -8
?RotateLeft@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RotateLeft, COMDAT

; 708  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 709  : 	I rightchild = RightChild(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RightChild
	mov	WORD PTR _rightchild$[ebp], ax

; 710  : 	SetRightChild( elem, LeftChild(rightchild) );

	mov	cx, WORD PTR _rightchild$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
	push	eax
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetRightChild

; 711  : 	if (LeftChild(rightchild) != InvalidIndex())

	mov	ax, WORD PTR _rightchild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
	mov	si, ax
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L42993

; 712  : 		SetParent( LeftChild(rightchild), elem );

	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	dx, WORD PTR _rightchild$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetParent
$L42993:

; 713  : 
; 714  : 	if (rightchild != InvalidIndex())

	mov	esi, DWORD PTR _rightchild$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L42994

; 715  : 		SetParent( rightchild, Parent(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	push	eax
	mov	cx, WORD PTR _rightchild$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetParent
$L42994:

; 716  : 	if (!IsRoot(elem))

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRoot@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRoot
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42995

; 718  : 		if (IsLeftChild(elem))

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsLeftChild
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42996

; 719  : 			SetLeftChild( Parent(elem), rightchild );

	mov	cx, WORD PTR _rightchild$[ebp]
	push	ecx
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetLeftChild

; 720  : 		else

	jmp	SHORT $L42997
$L42996:

; 721  : 			SetRightChild( Parent(elem), rightchild );

	mov	ax, WORD PTR _rightchild$[ebp]
	push	eax
	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetRightChild
$L42997:

; 723  : 	else

	jmp	SHORT $L42998
$L42995:

; 724  : 		m_Root = rightchild;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _rightchild$[ebp]
	mov	WORD PTR [edx+16], ax
$L42998:

; 725  : 
; 726  : 	SetLeftChild( rightchild, elem );

	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	dx, WORD PTR _rightchild$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetLeftChild

; 727  : 	if (elem != InvalidIndex())

	mov	esi, DWORD PTR _elem$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L42999

; 728  : 		SetParent( elem, rightchild );

	mov	ax, WORD PTR _rightchild$[ebp]
	push	eax
	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetParent
$L42999:

; 729  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RotateLeft@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RotateLeft
_TEXT	ENDS
;	COMDAT ?RotateRight@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
_leftchild$ = -8
?RotateRight@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RotateRight, COMDAT

; 738  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 739  : 	I leftchild = LeftChild(elem);

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::LeftChild
	mov	WORD PTR _leftchild$[ebp], ax

; 740  : 	SetLeftChild( elem, RightChild(leftchild) );

	mov	cx, WORD PTR _leftchild$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RightChild
	push	eax
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetLeftChild

; 741  : 	if (RightChild(leftchild) != InvalidIndex())

	mov	ax, WORD PTR _leftchild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RightChild
	mov	si, ax
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L43005

; 742  : 		SetParent( RightChild(leftchild), elem );

	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	dx, WORD PTR _leftchild$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RightChild
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetParent
$L43005:

; 743  : 
; 744  : 	if (leftchild != InvalidIndex())

	mov	esi, DWORD PTR _leftchild$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L43006

; 745  : 		SetParent( leftchild, Parent(elem) );

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	push	eax
	mov	cx, WORD PTR _leftchild$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetParent
$L43006:

; 746  : 	if (!IsRoot(elem))

	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRoot@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRoot
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L43007

; 748  : 		if (IsRightChild(elem))

	mov	ax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBE_NG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::IsRightChild
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L43008

; 749  : 			SetRightChild( Parent(elem), leftchild );

	mov	cx, WORD PTR _leftchild$[ebp]
	push	ecx
	mov	dx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetRightChild

; 750  : 		else

	jmp	SHORT $L43009
$L43008:

; 751  : 			SetLeftChild( Parent(elem), leftchild );

	mov	ax, WORD PTR _leftchild$[ebp]
	push	eax
	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@QBEGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Parent
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLeftChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetLeftChild
$L43009:

; 753  : 	else

	jmp	SHORT $L43010
$L43007:

; 754  : 		m_Root = leftchild;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _leftchild$[ebp]
	mov	WORD PTR [edx+16], ax
$L43010:

; 755  : 
; 756  : 	SetRightChild( leftchild, elem );

	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	dx, WORD PTR _leftchild$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRightChild@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetRightChild

; 757  : 	if (elem != InvalidIndex())

	mov	esi, DWORD PTR _elem$[ebp]
	and	esi, 65535				; 0000ffffH
	call	?InvalidIndex@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@SAGXZ ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::InvalidIndex
	and	eax, 65535				; 0000ffffH
	cmp	esi, eax
	je	SHORT $L43011

; 758  : 		SetParent( elem, leftchild );

	mov	ax, WORD PTR _leftchild$[ebp]
	push	eax
	mov	cx, WORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetParent
$L43011:

; 759  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RotateRight@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::RotateRight
_TEXT	ENDS
;	COMDAT ?SetParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z
_TEXT	SEGMENT
_i$ = 8
_parent$ = 12
_this$ = -4
?SetParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z PROC NEAR ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetParent, COMDAT

; 569  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 570  : 	Links(i).m_Parent = parent; 

	mov	ax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Links@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEAAU?$UtlRBTreeLinks_t@G@@G@Z ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::Links
	mov	cx, WORD PTR _parent$[ebp]
	mov	WORD PTR [eax+4], cx

; 571  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetParent@?$CUtlRBTree@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@GVCKeyLess@2@V?$CUtlMemory@U?$UtlRBTreeNode_t@UNode_t@?$CUtlMap@PBDPAVIEntityFactory@@G@@G@@G@@@@IAEXGG@Z ENDP ; CUtlRBTree<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short,CUtlMap<char const *,IEntityFactory *,unsigned short>::CKeyLess,CUtlMemory<UtlRBTreeNode_t<CUtlMap<char const *,IEntityFactory *,unsigned short>::Node_t,unsigned short>,unsigned short> >::SetParent
_TEXT	ENDS
END
