	TITLE	Z:\XashXTSRC\server\physic.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OJHA@Bad?5link?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09OKKL@Half?9Life?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@DIJK@func_door_rotating?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OCEI@sv_friction?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@PJCG@sv_stopspeed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@EEMA@Interpenetrating?5entities?$CB?5?$CI?$CFs?5a@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@EHCK@Ignoring?5player?5blocking?5train?$CB?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@OAP@z?3?2xashxtsrc?2server?2physic?4cpp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LAPH@m_nBlocker?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??RegisterBlockage@CPhysicsPushedEntities@@IAEPAVCBaseEntity@@XZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@NFJM@sv_maxvelocity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@EMCI@Got?5a?5NaN?5velocity?5on?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@FDAD@Got?5a?5NaN?5origin?5on?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@ECAF@SV_FlyMove?3?5trace?4pHit?5?$DN?$DN?5NULL?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GIJ@sv_gravity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@PBM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@QAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ZVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CrossProduct@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QAEPAMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?INDEXENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeNonSolid@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RestoreSolid@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IncrementLocalTime@CBaseEntity@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMoveDoneTime@CBaseEntity@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMoveDoneTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Node@CGraph@@QAEAAVCNode@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Link@CGraph@@QAEAAVCLink@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NodeLink@CGraph@@QAEAAVCLink@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPhysicsPushedEntities@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E21
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E22
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E23
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPhysicsPushedEntities@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EngineSetFeatures@@YAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawDebugTriangles@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawOrthoTriangles@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_AllowPushRotate@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_ClipMoveToEntity@@YAXPAUedict_s@@PBMPAM21PAUtrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_ClipPMoveToEntity@@YAXPAUphysent_s@@PBMPAM21PAUpmtrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0trace_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0plane_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_RestoreDecal@@YAHPAUdecallist_s@@PAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PM_PlayerTouch@@YAXPAUplayermove_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_AllocString@@YAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_MakeString@@YAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_GetString@@YAPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepWorldFrame@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Server_GetPhysicsInterface
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DispatchCreateEntity@@YAHPAUedict_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DispatchPhysicsEntity@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DispatchUpdatePlayerBaseVelocity@@YAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddEntityToBlockingList@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_AngularMove@@YAXPAVCBaseEntity@@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_LinearMove@@YAXPAVCBaseEntity@@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnlinkPusherList@CPhysicsPushedEntities@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RelinkPusherList@CPhysicsPushedEntities@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcRotationalPushDirection@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@ABURotatingPushMove_t@1@AAVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPushedPositionValid@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpeculativelyCheckPush@CPhysicsPushedEntities@@IAE_NAAUPhysicsPushedInfo_t@1@ABVVector@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpeculativelyCheckRotPush@CPhysicsPushedEntities@@MAE_NABURotatingPushMove_t@1@PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpeculativelyCheckLinearPush@CPhysicsPushedEntities@@MAE_NABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinishPushers@CPhysicsPushedEntities@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinishRotPushedEntity@CPhysicsPushedEntities@@MAEXPAVCBaseEntity@@ABURotatingPushMove_t@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinishPush@CPhysicsPushedEntities@@IAEX_NPBURotatingPushMove_t@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BeginPush@CPhysicsPushedEntities@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterBlockage@CPhysicsPushedEntities@@IAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RestoreEntities@CPhysicsPushedEntities@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStandingOnPusher@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPushedEntityToBlockingList@CPhysicsPushedEntities@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateBlockingEntityList@CPhysicsPushedEntities@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateBlockingEntityListAddBox@CPhysicsPushedEntities@@IAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetupAllInHierarchy@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotateRootEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@MAAURotatingPushMove_t@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PerformRotatePush@CPhysicsPushedEntities@@QAEPAVCBaseEntity@@PAV2@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0RotatingPushMove_t@CPhysicsPushedEntities@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinearlyMoveRootEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@MAAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PerformLinearPush@CPhysicsPushedEntities@@QAEPAVCBaseEntity@@PAV2@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_UpdateBaseVelocity@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_RunThink@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_Impact@@YAXPAVCBaseEntity@@0PAUgametrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_TestEntityPosition@@YAHPAVCBaseEntity@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_RecursiveWaterLevel@@YAMABVVector@@MMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_Submerged@@YAMPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_CheckMover@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_CheckWater@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_CheckWaterTransition@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_ClipVelocity@@YAHABVVector@@0AAV1@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_CalcOverBounce@@YAMPAVCBaseEntity@@PAUgametrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_FlyMove@@YAHPAVCBaseEntity@@MPAUgametrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_AddGravity@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_AddHalfGravity@@YAXPAVCBaseEntity@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_PushEntity@@YA?AUgametrace_s@@PAVCBaseEntity@@ABVVector@@1PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_Physics_None@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_Physics_Rigid@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_Physics_Noclip@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_Physics_Follow@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_Physics_Compound@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_Physics_Toss@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E26
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E27
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E28
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E29
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddEntityToGroundList@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_Physics_Step@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_PushMove@@YAPAVCBaseEntity@@PAV1@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_PushRotate@@YAPAVCBaseEntity@@PAV1@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_Physics_Pusher@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SV_Physics_Vehicle@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RunPhysicsFrame@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PAVCBaseEntity@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PAVCBaseEntity@@H@@QAEPAPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PAVCBaseEntity@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Construct@@YAXPAPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PhysicsPusherInfo_t@CPhysicsPushedEntities@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PhysicsPushedInfo_t@CPhysicsPushedEntities@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CPhysicsPushedEntities@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?s_PushedEntities@@3VCPhysicsPushedEntities@@A	; s_PushedEntities
PUBLIC	?g_pPushedEntities@@3PAVCPhysicsPushedEntities@@A ; g_pPushedEntities
PUBLIC	?EngineSetFeatures@@YAIXZ			; EngineSetFeatures
PUBLIC	?DrawDebugTriangles@@YAXXZ			; DrawDebugTriangles
PUBLIC	?DrawOrthoTriangles@@YAXXZ			; DrawOrthoTriangles
PUBLIC	?SV_ClipMoveToEntity@@YAXPAUedict_s@@PBMPAM21PAUtrace_s@@@Z ; SV_ClipMoveToEntity
PUBLIC	?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A ; m_rgGroundEnts
PUBLIC	?SV_ClipPMoveToEntity@@YAXPAUphysent_s@@PBMPAM21PAUpmtrace_s@@@Z ; SV_ClipPMoveToEntity
PUBLIC	?SV_RestoreDecal@@YAHPAUdecallist_s@@PAUedict_s@@H@Z ; SV_RestoreDecal
PUBLIC	?PM_PlayerTouch@@YAXPAUplayermove_s@@PAUedict_s@@@Z ; PM_PlayerTouch
PUBLIC	?DispatchCreateEntity@@YAHPAUedict_s@@PBD@Z	; DispatchCreateEntity
PUBLIC	?SV_AllocString@@YAHPBD@Z			; SV_AllocString
PUBLIC	?DispatchPhysicsEntity@@YAHPAUedict_s@@@Z	; DispatchPhysicsEntity
PUBLIC	?SV_MakeString@@YAHPBD@Z			; SV_MakeString
PUBLIC	?SV_GetString@@YAPBDH@Z				; SV_GetString
PUBLIC	?DispatchUpdatePlayerBaseVelocity@@YAXPAUedict_s@@@Z ; DispatchUpdatePlayerBaseVelocity
PUBLIC	?PrepWorldFrame@@YAXXZ				; PrepWorldFrame
EXTRN	?EndFrame@@YAXXZ:NEAR				; EndFrame
EXTRN	?DispatchCreateEntitiesInRestoreList@@YAXPAUsaverestore_s@@HH@Z:NEAR ; DispatchCreateEntitiesInRestoreList
EXTRN	?DispatchSpawnEntities@@YAHPBDPAD@Z:NEAR	; DispatchSpawnEntities
_BSS	SEGMENT
?s_PushedEntities@@3VCPhysicsPushedEntities@@A DB 038H DUP (?) ; s_PushedEntities
?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A DB 014H DUP (?) ; m_rgGroundEnts
_BSS	ENDS
CRT$XCU	SEGMENT
_$S25	DD	FLAT:_$E24
CRT$XCU	ENDS
_DATA	SEGMENT
?g_pPushedEntities@@3PAVCPhysicsPushedEntities@@A DD FLAT:?s_PushedEntities@@3VCPhysicsPushedEntities@@A ; g_pPushedEntities
	ORG $+4
_gPhysicsInterface DD 06H
	DD	FLAT:?DispatchCreateEntity@@YAHPAUedict_s@@PBD@Z
	DD	FLAT:?DispatchPhysicsEntity@@YAHPAUedict_s@@@Z
	DD	FLAT:?DispatchSpawnEntities@@YAHPBDPAD@Z
	DD	FLAT:?DispatchUpdatePlayerBaseVelocity@@YAXPAUedict_s@@@Z
	DD	00H
	DD	00H
	DD	FLAT:?EngineSetFeatures@@YAIXZ
	DD	FLAT:?DrawDebugTriangles@@YAXXZ
	DD	FLAT:?PrepWorldFrame@@YAXXZ
	DD	FLAT:?DrawOrthoTriangles@@YAXXZ
	DD	FLAT:?SV_ClipMoveToEntity@@YAXPAUedict_s@@PBMPAM21PAUtrace_s@@@Z
	DD	FLAT:?SV_ClipPMoveToEntity@@YAXPAUphysent_s@@PBMPAM21PAUpmtrace_s@@@Z
	DD	FLAT:?EndFrame@@YAXXZ
	DD	00H
	DD	FLAT:?DispatchCreateEntitiesInRestoreList@@YAXPAUsaverestore_s@@HH@Z
	DD	FLAT:?SV_AllocString@@YAHPBD@Z
	DD	FLAT:?SV_MakeString@@YAHPBD@Z
	DD	FLAT:?SV_GetString@@YAPBDH@Z
	DD	FLAT:?SV_RestoreDecal@@YAHPAUdecallist_s@@PAUedict_s@@H@Z
	DD	FLAT:?PM_PlayerTouch@@YAXPAUplayermove_s@@PAUedict_s@@@Z
	ORG $+12
_DATA	ENDS
CRT$XCU	SEGMENT
_$S30	DD	FLAT:_$E29
CRT$XCU	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
;	COMDAT _$E24
_TEXT	SEGMENT
_$E24	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E21
	call	_$E23
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E24	ENDP
_TEXT	ENDS
PUBLIC	??0CPhysicsPushedEntities@@QAE@XZ		; CPhysicsPushedEntities::CPhysicsPushedEntities
;	COMDAT _$E21
_TEXT	SEGMENT
_$E21	PROC NEAR					; COMDAT

; 38   : CPhysicsPushedEntities	s_PushedEntities;

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:?s_PushedEntities@@3VCPhysicsPushedEntities@@A
	call	??0CPhysicsPushedEntities@@QAE@XZ	; CPhysicsPushedEntities::CPhysicsPushedEntities
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E21	ENDP
_TEXT	ENDS
PUBLIC	?SpeculativelyCheckRotPush@CPhysicsPushedEntities@@MAE_NABURotatingPushMove_t@1@PAVCBaseEntity@@@Z ; CPhysicsPushedEntities::SpeculativelyCheckRotPush
PUBLIC	?SpeculativelyCheckLinearPush@CPhysicsPushedEntities@@MAE_NABVVector@@@Z ; CPhysicsPushedEntities::SpeculativelyCheckLinearPush
PUBLIC	?FinishRotPushedEntity@CPhysicsPushedEntities@@MAEXPAVCBaseEntity@@ABURotatingPushMove_t@1@@Z ; CPhysicsPushedEntities::FinishRotPushedEntity
PUBLIC	??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >
PUBLIC	??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::~CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >
PUBLIC	??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >
PUBLIC	??_7CPhysicsPushedEntities@@6B@			; CPhysicsPushedEntities::`vftable'
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT ??_7CPhysicsPushedEntities@@6B@
; File z:\xashxtsrc\server\movelist.h
CONST	SEGMENT
??_7CPhysicsPushedEntities@@6B@ DD FLAT:?SpeculativelyCheckRotPush@CPhysicsPushedEntities@@MAE_NABURotatingPushMove_t@1@PAVCBaseEntity@@@Z ; CPhysicsPushedEntities::`vftable'
	DD	FLAT:?SpeculativelyCheckLinearPush@CPhysicsPushedEntities@@MAE_NABVVector@@@Z
	DD	FLAT:?FinishRotPushedEntity@CPhysicsPushedEntities@@MAEXPAVCBaseEntity@@ABURotatingPushMove_t@1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CPhysicsPushedEntities@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CPhysicsPushedEntities@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CPhysicsPushedEntities@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CPhysicsPushedEntities@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CPhysicsPushedEntities@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0CPhysicsPushedEntities@@QAE@XZ PROC NEAR		; CPhysicsPushedEntities::CPhysicsPushedEntities, COMDAT

; 29   : 	CPhysicsPushedEntities( void ) : m_rgPusher( 8, 8 ), m_rgMoved( 32, 32 ) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CPhysicsPushedEntities@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	8
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	32					; 00000020H
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CPhysicsPushedEntities@@6B@ ; CPhysicsPushedEntities::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CPhysicsPushedEntities@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::~CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >
	ret	0
__ehhandler$??0CPhysicsPushedEntities@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CPhysicsPushedEntities@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CPhysicsPushedEntities@@QAE@XZ ENDP			; CPhysicsPushedEntities::CPhysicsPushedEntities
EXTRN	_atexit:NEAR
;	COMDAT _$E23
_TEXT	SEGMENT
_$E23	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:_$E22
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E23	ENDP
_TEXT	ENDS
PUBLIC	??1CPhysicsPushedEntities@@QAE@XZ		; CPhysicsPushedEntities::~CPhysicsPushedEntities
;	COMDAT _$E22
_TEXT	SEGMENT
_$E22	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:?s_PushedEntities@@3VCPhysicsPushedEntities@@A
	call	??1CPhysicsPushedEntities@@QAE@XZ	; CPhysicsPushedEntities::~CPhysicsPushedEntities
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E22	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::~CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CPhysicsPushedEntities@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CPhysicsPushedEntities@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CPhysicsPushedEntities@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CPhysicsPushedEntities@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CPhysicsPushedEntities@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1CPhysicsPushedEntities@@QAE@XZ PROC NEAR		; CPhysicsPushedEntities::~CPhysicsPushedEntities, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CPhysicsPushedEntities@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::~CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::~CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CPhysicsPushedEntities@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::~CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >
	ret	0
__ehhandler$??1CPhysicsPushedEntities@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CPhysicsPushedEntities@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CPhysicsPushedEntities@@QAE@XZ ENDP			; CPhysicsPushedEntities::~CPhysicsPushedEntities
;	COMDAT ?EngineSetFeatures@@YAIXZ
_TEXT	SEGMENT
_flags$ = -4
?EngineSetFeatures@@YAIXZ PROC NEAR			; EngineSetFeatures, COMDAT

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 43   : 	unsigned int flags = (ENGINE_WRITE_LARGE_COORD|ENGINE_TRANSFORM_TRACE_AABB|ENGINE_COMPUTE_STUDIO_LERP);

	mov	DWORD PTR _flags$[ebp], 137		; 00000089H

; 44   : 
; 45   : 	flags |= ENGINE_LARGE_LIGHTMAPS|ENGINE_LOAD_DELUXEDATA;

	mov	eax, DWORD PTR _flags$[ebp]
	or	al, 20					; 00000014H
	mov	DWORD PTR _flags$[ebp], eax

; 46   : 	flags |= ENGINE_COMPENSATE_QUAKE_BUG;

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 32					; 00000020H
	mov	DWORD PTR _flags$[ebp], ecx

; 47   : 
; 48   : 	return flags;

	mov	eax, DWORD PTR _flags$[ebp]

; 49   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EngineSetFeatures@@YAIXZ ENDP				; EngineSetFeatures
_TEXT	ENDS
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	??_C@_0BD@DIJK@func_door_rotating?$AA@		; `string'
PUBLIC	__real@4@00000000000000000000
PUBLIC	?INDEXENT@@YAPAUedict_s@@H@Z			; INDEXENT
PUBLIC	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z		; FClassnameIs
EXTRN	?WorldPhysic@@3PAVIPhysicLayer@@A:DWORD		; WorldPhysic
EXTRN	?g_debugdraw@@3PAUcvar_s@@A:DWORD		; g_debugdraw
EXTRN	?g_physdebug@@3PAUcvar_s@@A:DWORD		; g_physdebug
EXTRN	__fltused:NEAR
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
EXTRN	?g_physfuncs@@3Userver_physics_api_s@@A:BYTE	; g_physfuncs
;	COMDAT ??_C@_0BD@DIJK@func_door_rotating?$AA@
; File z:\xashxtsrc\server\physic.cpp
CONST	SEGMENT
??_C@_0BD@DIJK@func_door_rotating?$AA@ DB 'func_door_rotating', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4@00000000000000000000
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT ?DrawDebugTriangles@@YAXXZ
_TEXT	SEGMENT
_pEdict$39230 = -4
_i$39231 = -8
?DrawDebugTriangles@@YAXXZ PROC NEAR			; DrawDebugTriangles, COMDAT

; 52   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 53   : 	if( g_debugdraw != NULL && g_debugdraw->value > 0.0f )

	cmp	DWORD PTR ?g_debugdraw@@3PAUcvar_s@@A, 0 ; g_debugdraw
	je	SHORT $L39228
	mov	eax, DWORD PTR ?g_debugdraw@@3PAUcvar_s@@A ; g_debugdraw
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39228

; 54   : 		WorldPhysic->DebugDraw();

	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+132]
$L39228:

; 55   : 
; 56   : 	if( g_physdebug != NULL && g_physdebug->value > 0.0f )

	cmp	DWORD PTR ?g_physdebug@@3PAUcvar_s@@A, 0 ; g_physdebug
	je	$L39234
	mov	eax, DWORD PTR ?g_physdebug@@3PAUcvar_s@@A ; g_physdebug
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L39234

; 58   : 		edict_t *pEdict = INDEXENT( 1 );

	push	1
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	mov	DWORD PTR _pEdict$39230[ebp], eax

; 59   : 		for ( int i = 1; i < gpGlobals->maxEntities; i++, pEdict++ )

	mov	DWORD PTR _i$39231[ebp], 1
	jmp	SHORT $L39232
$L39233:
	mov	ecx, DWORD PTR _i$39231[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$39231[ebp], ecx
	mov	edx, DWORD PTR _pEdict$39230[ebp]
	add	edx, 804				; 00000324H
	mov	DWORD PTR _pEdict$39230[ebp], edx
$L39232:
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _i$39231[ebp]
	cmp	ecx, DWORD PTR [eax+148]
	jge	SHORT $L39234

; 61   : 			if ( pEdict->free )	// Not in use

	mov	edx, DWORD PTR _pEdict$39230[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L39235

; 62   : 				continue;

	jmp	SHORT $L39233
$L39235:

; 63   : 
; 64   : 			if( FClassnameIs( &pEdict->v, "func_door_rotating" ))

	push	OFFSET FLAT:??_C@_0BD@DIJK@func_door_rotating?$AA@ ; `string'
	mov	eax, DWORD PTR _pEdict$39230[ebp]
	add	eax, 128				; 00000080H
	push	eax
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L39236

; 66   : 				Tri->Color4f( 1.0f, 0.5f, 0.0f, 1.0f );

	push	1065353216				; 3f800000H
	push	0
	push	1056964608				; 3f000000H
	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [ecx+16]
	add	esp, 16					; 00000010H

; 67   : 				Tri->Begin( TRI_POINTS );

	push	7
	mov	edx, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [edx+8]
	add	esp, 4

; 68   : 					Tri->Vertex3fv( pEdict->v.origin );

	mov	ecx, DWORD PTR _pEdict$39230[ebp]
	add	ecx, 136				; 00000088H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	eax, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [eax+28]
	add	esp, 4

; 69   : 				Tri->End();

	mov	ecx, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [ecx+12]
$L39236:

; 71   : 		}

	jmp	$L39233
$L39234:

; 73   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawDebugTriangles@@YAXXZ ENDP				; DrawDebugTriangles
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
;	COMDAT ?INDEXENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_iEdictNum$ = 8
?INDEXENT@@YAPAUedict_s@@H@Z PROC NEAR			; INDEXENT, COMDAT

; 187  : inline edict_t* INDEXENT( int iEdictNum )		{ return (*g_engfuncs.pfnPEntityOfEntIndex)(iEdictNum); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _iEdictNum$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+288
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?INDEXENT@@YAPAUedict_s@@H@Z ENDP			; INDEXENT
_TEXT	ENDS
PUBLIC	?FNullEnt@@YAHPAUentvars_s@@@Z			; FNullEnt
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT
_pev$ = 8
_szClassname$ = 12
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z PROC NEAR		; FClassnameIs, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 295  : 	if( FNullEnt( pev )) return FALSE;

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L32565
	xor	eax, eax
	jmp	SHORT $L32564
$L32565:

; 296  : 	return FStrEq( STRING( pev->classname ), szClassname );

	mov	ecx, DWORD PTR _szClassname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pev$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
$L32564:

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z ENDP		; FClassnameIs
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?FNullEnt@@YAHPAUentvars_s@@@Z PROC NEAR		; FNullEnt, COMDAT

; 196  : inline BOOL FNullEnt(entvars_t* pev)				{ return pev == NULL || FNullEnt(OFFSET(pev)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pev$[ebp], 0
	je	SHORT $L41526
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41526
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L41527
$L41526:
	mov	DWORD PTR -4+[ebp], 1
$L41527:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAUentvars_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad pev in OFFSET()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?OFFSET@@YAHPAUentvars_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L32439

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32439:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
EXTRN	?p_speeds@@3PAUcvar_s@@A:DWORD			; p_speeds
;	COMDAT ?DrawOrthoTriangles@@YAXXZ
_TEXT	SEGMENT
?DrawOrthoTriangles@@YAXXZ PROC NEAR			; DrawOrthoTriangles, COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 77   : 	if( p_speeds != NULL && p_speeds->value > 0.0f )

	cmp	DWORD PTR ?p_speeds@@3PAUcvar_s@@A, 0	; p_speeds
	je	SHORT $L39241
	mov	eax, DWORD PTR ?p_speeds@@3PAUcvar_s@@A	; p_speeds
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39241

; 78   : 		WorldPhysic->DrawPSpeeds();

	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+136]
$L39241:

; 79   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawOrthoTriangles@@YAXXZ ENDP				; DrawOrthoTriangles
_TEXT	ENDS
PUBLIC	?SV_AllowPushRotate@@YAHPAVCBaseEntity@@@Z	; SV_AllowPushRotate
;	COMDAT ?SV_AllowPushRotate@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_mod$ = -4
?SV_AllowPushRotate@@YAHPAVCBaseEntity@@@Z PROC NEAR	; SV_AllowPushRotate, COMDAT

; 89   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 90   : 	model_t	*mod;
; 91   : 
; 92   : 	mod = (model_t *)MODEL_HANDLE( pEntity->pev->modelindex );

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 93   : 	if( !mod || mod->type != mod_brush )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $L39248
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $L39247
$L39248:

; 94   : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L39244
$L39247:

; 95   : 
; 96   : 	// NOTE: flag 2 it's a internal engine flag (see model.c for details)
; 97   : 	// we can recalc real model origin here but this check is faster :)
; 98   : 	return (mod->flags & 2) ? TRUE : FALSE;

	mov	ecx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [ecx+80]
	and	eax, 2
	neg	eax
	sbb	eax, eax
	neg	eax
$L39244:

; 99   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_AllowPushRotate@@YAHPAVCBaseEntity@@@Z ENDP		; SV_AllowPushRotate
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@PBM@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@QAM@Z				; Vector::Vector
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
;	COMDAT ?SV_ClipMoveToEntity@@YAXPAUedict_s@@PBMPAM21PAUtrace_s@@@Z
_TEXT	SEGMENT
_ent$ = 8
_start$ = 12
_mins$ = 16
_maxs$ = 20
_end$ = 24
_trace$ = 28
_pTouch$ = -4
$T41544 = -16
$T41545 = -28
$T41546 = -40
$T41547 = -52
?SV_ClipMoveToEntity@@YAXPAUedict_s@@PBMPAM21PAUtrace_s@@@Z PROC NEAR ; SV_ClipMoveToEntity, COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 103  : 	// convert edict_t to base entity
; 104  : 	CBaseEntity *pTouch = CBaseEntity::Instance( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pTouch$[ebp], eax

; 105  : 
; 106  : 	if( !pTouch )

	cmp	DWORD PTR _pTouch$[ebp], 0
	jne	SHORT $L39258

; 108  : 		// removed entity?
; 109  : 		trace->allsolid = false;

	mov	ecx, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [ecx], 0

; 110  : 		return;

	jmp	SHORT $L39256
$L39258:

; 112  : 
; 113  : 	WorldPhysic->SweepTest( pTouch, start, mins, maxs, end, trace );

	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T41544[ebp]
	call	??0Vector@@QAE@PBM@Z			; Vector::Vector
	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41545[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T41546[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T41547[ebp]
	call	??0Vector@@QAE@PBM@Z			; Vector::Vector
	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41544[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41545[ebp]
	push	edx
	lea	eax, DWORD PTR $T41546[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41547[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTouch$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+160]
$L39256:

; 114  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_ClipMoveToEntity@@YAXPAUedict_s@@PBMPAM21PAUtrace_s@@@Z ENDP ; SV_ClipMoveToEntity
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@PBM@Z
_TEXT	SEGMENT
_rgfl$ = 8
_this$ = -4
??0Vector@@QAE@PBM@Z PROC NEAR				; Vector::Vector, COMDAT

; 137  : 	inline Vector( const float *rgfl )		{ x = rgfl[0]; y = rgfl[1]; z = rgfl[2];   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@PBM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@QAM@Z
_TEXT	SEGMENT
_rgfl$ = 8
_this$ = -4
??0Vector@@QAE@QAM@Z PROC NEAR				; Vector::Vector, COMDAT

; 138  : 	inline Vector(float rgfl[3])			{ x = rgfl[0]; y = rgfl[1]; z = rgfl[2];   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@QAM@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
PUBLIC	??0trace_s@@QAE@XZ				; trace_s::trace_s
EXTRN	_memcpy:NEAR
EXTRN	_memset:NEAR
;	COMDAT ?SV_ClipPMoveToEntity@@YAXPAUphysent_s@@PBMPAM21PAUpmtrace_s@@@Z
_TEXT	SEGMENT
_pe$ = 8
_start$ = 12
_mins$ = 16
_maxs$ = 20
_end$ = 24
_tr$ = 28
_pTouch$ = -4
_trace$ = -60
$T41560 = -72
$T41561 = -84
$T41562 = -96
$T41563 = -108
$T41564 = -120
?SV_ClipPMoveToEntity@@YAXPAUphysent_s@@PBMPAM21PAUpmtrace_s@@@Z PROC NEAR ; SV_ClipPMoveToEntity, COMDAT

; 117  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	push	ebx
	push	esi
	push	edi

; 118  : 	// convert physent_t to base entity
; 119  : 	CBaseEntity *pTouch = CBaseEntity::Instance( INDEXENT( pe->info ));

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pTouch$[ebp], eax

; 120  : 	trace_t trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0trace_s@@QAE@XZ			; trace_s::trace_s

; 121  : 
; 122  : 	if( !pTouch )

	cmp	DWORD PTR _pTouch$[ebp], 0
	jne	SHORT $L39273

; 124  : 		// removed entity?
; 125  : 		tr->allsolid = false;

	mov	edx, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [edx], 0

; 126  : 		return;

	jmp	$L39270
$L39273:

; 128  : 
; 129  : 	// make trace default
; 130  : 	memset( &trace, 0, sizeof( trace ));

	push	56					; 00000038H
	push	0
	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 131  : 	trace.allsolid = true;

	mov	DWORD PTR _trace$[ebp], 1

; 132  : 	trace.fraction = 1.0f;

	mov	DWORD PTR _trace$[ebp+16], 1065353216	; 3f800000H

; 133  : 	trace.endpos = end;

	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T41560[ebp]
	call	??0Vector@@QAE@PBM@Z			; Vector::Vector
	mov	edx, DWORD PTR $T41560[ebp]
	mov	DWORD PTR _trace$[ebp+20], edx
	mov	eax, DWORD PTR $T41560[ebp+4]
	mov	DWORD PTR _trace$[ebp+24], eax
	mov	ecx, DWORD PTR $T41560[ebp+8]
	mov	DWORD PTR _trace$[ebp+28], ecx

; 134  : 
; 135  : 	WorldPhysic->SweepTest( pTouch, start, mins, maxs, end, &trace );

	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T41561[ebp]
	call	??0Vector@@QAE@PBM@Z			; Vector::Vector
	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41562[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T41563[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T41564[ebp]
	call	??0Vector@@QAE@PBM@Z			; Vector::Vector
	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41561[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41562[ebp]
	push	edx
	lea	eax, DWORD PTR $T41563[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41564[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTouch$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+160]

; 136  : 
; 137  : 	// convert trace_t into pmtrace_t
; 138  : 	memcpy( tr, &trace, 48 );

	push	48					; 00000030H
	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 139  : 	tr->hitgroup = trace.hitgroup;

	mov	edx, DWORD PTR _tr$[ebp]
	mov	eax, DWORD PTR _trace$[ebp+52]
	mov	DWORD PTR [edx+64], eax

; 140  : 
; 141  : 	if( trace.ent != NULL )

	cmp	DWORD PTR _trace$[ebp+48], 0
	je	SHORT $L39279

; 142  : 		tr->ent = pe->info;

	mov	ecx, DWORD PTR _tr$[ebp]
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR [ecx+48], eax

; 143  : 	else tr->ent = -1;

	jmp	SHORT $L39280
$L39279:
	mov	ecx, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [ecx+48], -1
$L39280:
$L39270:

; 144  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_ClipPMoveToEntity@@YAXPAUphysent_s@@PBMPAM21PAUpmtrace_s@@@Z ENDP ; SV_ClipPMoveToEntity
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0plane_s@@QAE@XZ				; plane_s::plane_s
;	COMDAT ??0trace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0trace_s@@QAE@XZ PROC NEAR				; trace_s::trace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0plane_s@@QAE@XZ			; plane_s::plane_s
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0trace_s@@QAE@XZ ENDP					; trace_s::trace_s
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
;	COMDAT ??0plane_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0plane_s@@QAE@XZ PROC NEAR				; plane_s::plane_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0plane_s@@QAE@XZ ENDP					; plane_s::plane_s
_TEXT	ENDS
PUBLIC	?ENTINDEX@@YAHPAUedict_s@@@Z			; ENTINDEX
EXTRN	?UTIL_RestoreStudioDecal@@YAXABVVector@@0HHPBDHPAUmodelstate_s@@H@Z:NEAR ; UTIL_RestoreStudioDecal
;	COMDAT ?SV_RestoreDecal@@YAHPAUdecallist_s@@PAUedict_s@@H@Z
_TEXT	SEGMENT
_entry$ = 8
_pEdict$ = 12
_flags$ = -4
_entityIndex$ = -8
_cacheID$ = -12
_modelIndex$ = -16
?SV_RestoreDecal@@YAHPAUdecallist_s@@PAUedict_s@@H@Z PROC NEAR ; SV_RestoreDecal, COMDAT

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 148  : 	int	flags = entry->flags;

	mov	eax, DWORD PTR _entry$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+79]
	mov	DWORD PTR _flags$[ebp], ecx

; 149  : 	int	entityIndex = ENTINDEX( pEdict );

	mov	edx, DWORD PTR _pEdict$[ebp]
	push	edx
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax

; 150  : 	int	cacheID = 0, modelIndex = 0;

	mov	DWORD PTR _cacheID$[ebp], 0
	mov	DWORD PTR _modelIndex$[ebp], 0

; 151  : 
; 152  : 	if( flags & FDECAL_STUDIO )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $L39294

; 154  : 		if( FBitSet( pEdict->v.iuser1, CF_STATIC_ENTITY ))

	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	edx, DWORD PTR [ecx+708]
	and	edx, 64					; 00000040H
	test	edx, edx
	je	SHORT $L39295

; 155  : 			cacheID = pEdict->v.iuser3;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [eax+716]
	mov	DWORD PTR _cacheID$[ebp], ecx
$L39295:

; 157  : 		pEdict->v.modelindex, entry->name, flags, &entry->studio_state, cacheID );

	mov	edx, DWORD PTR _cacheID$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	mov	edx, DWORD PTR _entityIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	mov	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	call	?UTIL_RestoreStudioDecal@@YAXABVVector@@0HHPBDHPAUmodelstate_s@@H@Z ; UTIL_RestoreStudioDecal
	add	esp, 32					; 00000020H

; 158  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L39289
$L39294:

; 160  : 
; 161  : 	return FALSE; // let the engine restore bsp decals

	xor	eax, eax
$L39289:

; 162  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_RestoreDecal@@YAHPAUdecallist_s@@PAUedict_s@@H@Z ENDP ; SV_RestoreDecal
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT
_pEdict$ = 8
?ENTINDEX@@YAHPAUedict_s@@@Z PROC NEAR			; ENTINDEX, COMDAT

; 186  : inline int	  ENTINDEX(edict_t *pEdict)			{ return (*g_engfuncs.pfnIndexOfEdict)(pEdict); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+284
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENTINDEX@@YAHPAUedict_s@@@Z ENDP			; ENTINDEX
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	?SV_Impact@@YAXPAVCBaseEntity@@0PAUgametrace_s@@@Z ; SV_Impact
PUBLIC	??0gametrace_s@@QAE@XZ				; gametrace_s::gametrace_s
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
EXTRN	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsVelocity
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
EXTRN	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z:NEAR ; CBaseEntity::RelinkEntity
;	COMDAT ?PM_PlayerTouch@@YAXPAUplayermove_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pmove$ = 8
_client$ = 12
_pPlayer$ = -4
_oldAbsVelocity$ = -16
_i$ = -20
_pmtrace$39309 = -24
_pTouch$39310 = -28
_tr$39313 = -84
?PM_PlayerTouch@@YAXPAUplayermove_s@@PAUedict_s@@@Z PROC NEAR ; PM_PlayerTouch, COMDAT

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi

; 167  : 	CBasePlayer *pPlayer = (CBasePlayer *)CBaseEntity :: Instance( client );

	mov	eax, DWORD PTR _client$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pPlayer$[ebp], eax

; 168  : 
; 169  : 	if( !pPlayer || !pmove ) return; // ???

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $L39303
	cmp	DWORD PTR _pmove$[ebp], 0
	jne	SHORT $L39302
$L39303:
	jmp	$L39299
$L39302:

; 170  : 
; 171  : 	// touch triggers
; 172  : 	pPlayer->RelinkEntity( true );

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 173  : 
; 174  : 	// save original velocity
; 175  : 	Vector oldAbsVelocity = pPlayer->GetAbsVelocity();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _oldAbsVelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 176  : 
; 177  : 	// touch other objects
; 178  : 	for( int i = 0; i < pmove->numtouch; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39306
$L39307:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L39306:
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+283788]
	jge	$L39308

; 180  : 		pmtrace_t *pmtrace = &pmove->touchindex[i];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 68					; 00000044H
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+283792]
	mov	DWORD PTR _pmtrace$39309[ebp], eax

; 181  : 		CBaseEntity *pTouch = CBaseEntity :: Instance( INDEXENT( pmove->physents[pmtrace->ent].info ) );

	mov	ecx, DWORD PTR _pmtrace$39309[ebp]
	mov	edx, DWORD PTR [ecx+48]
	imul	edx, 224				; 000000e0H
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+edx+672]
	push	ecx
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pTouch$39310[ebp], eax

; 182  : 
; 183  : 		// touch himself?
; 184  : 		if( !pTouch || pTouch == pPlayer )

	cmp	DWORD PTR _pTouch$39310[ebp], 0
	je	SHORT $L39312
	mov	edx, DWORD PTR _pTouch$39310[ebp]
	cmp	edx, DWORD PTR _pPlayer$[ebp]
	jne	SHORT $L39311
$L39312:

; 185  : 			continue;

	jmp	SHORT $L39307
$L39311:

; 186  : 
; 187  : 		// set momentum velocity to allow player pushing boxes
; 188  : 		pPlayer->SetAbsVelocity( pmtrace->deltavelocity );

	mov	eax, DWORD PTR _pmtrace$39309[ebp]
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 189  : 
; 190  : 		TraceResult tr;

	lea	ecx, DWORD PTR _tr$39313[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 191  : 
; 192  : 		tr.fAllSolid = pmtrace->allsolid;

	mov	ecx, DWORD PTR _pmtrace$39309[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _tr$39313[ebp], edx

; 193  : 		tr.fStartSolid = pmtrace->startsolid;

	mov	eax, DWORD PTR _pmtrace$39309[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _tr$39313[ebp+4], ecx

; 194  : 		tr.fInOpen = pmtrace->inopen;

	mov	edx, DWORD PTR _pmtrace$39309[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _tr$39313[ebp+8], eax

; 195  : 		tr.fInWater = pmtrace->inwater;

	mov	ecx, DWORD PTR _pmtrace$39309[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _tr$39313[ebp+12], edx

; 196  : 		tr.flFraction = pmtrace->fraction;

	mov	eax, DWORD PTR _pmtrace$39309[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _tr$39313[ebp+16], ecx

; 197  : 		tr.vecEndPos = pmtrace->endpos;

	mov	edx, DWORD PTR _pmtrace$39309[ebp]
	add	edx, 20					; 00000014H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _tr$39313[ebp+20], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _tr$39313[ebp+24], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _tr$39313[ebp+28], edx

; 198  : 		tr.flPlaneDist = pmtrace->plane.dist;

	mov	eax, DWORD PTR _pmtrace$39309[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _tr$39313[ebp+32], ecx

; 199  : 		tr.vecPlaneNormal = pmtrace->plane.normal;

	mov	edx, DWORD PTR _pmtrace$39309[ebp]
	add	edx, 32					; 00000020H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _tr$39313[ebp+36], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _tr$39313[ebp+40], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _tr$39313[ebp+44], edx

; 200  : 		tr.iHitgroup = pmtrace->hitgroup;

	mov	eax, DWORD PTR _pmtrace$39309[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _tr$39313[ebp+52], ecx

; 201  : 		tr.pHit = pTouch->edict();

	mov	ecx, DWORD PTR _pTouch$39310[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _tr$39313[ebp+48], eax

; 202  : 
; 203  : 		// IMPORTANT: don't change order!
; 204  : 		SV_Impact( pTouch, pPlayer, &tr );

	lea	edx, DWORD PTR _tr$39313[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTouch$39310[ebp]
	push	ecx
	call	?SV_Impact@@YAXPAVCBaseEntity@@0PAUgametrace_s@@@Z ; SV_Impact
	add	esp, 12					; 0000000cH

; 205  : 	}

	jmp	$L39307
$L39308:

; 206  : 
; 207  : 	// restore velocity
; 208  : 	pPlayer->SetAbsVelocity( oldAbsVelocity );

	lea	edx, DWORD PTR _oldAbsVelocity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L39299:

; 209  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_PlayerTouch@@YAXPAUplayermove_s@@PAUedict_s@@@Z ENDP ; PM_PlayerTouch
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0gametrace_s@@QAE@XZ PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0gametrace_s@@QAE@XZ ENDP				; gametrace_s::gametrace_s
_TEXT	ENDS
EXTRN	?AllocString@CStringPool@@QAEHPBD@Z:NEAR	; CStringPool::AllocString
EXTRN	?g_GameStringPool@@3VCStringPool@@A:BYTE	; g_GameStringPool
;	COMDAT ?SV_AllocString@@YAHPBD@Z
_TEXT	SEGMENT
_szValue$ = 8
?SV_AllocString@@YAHPBD@Z PROC NEAR			; SV_AllocString, COMDAT

; 212  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 213  : 	return g_GameStringPool.AllocString( szValue );

	mov	eax, DWORD PTR _szValue$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?g_GameStringPool@@3VCStringPool@@A
	call	?AllocString@CStringPool@@QAEHPBD@Z	; CStringPool::AllocString

; 214  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_AllocString@@YAHPBD@Z ENDP				; SV_AllocString
_TEXT	ENDS
;	COMDAT ?SV_MakeString@@YAHPBD@Z
_TEXT	SEGMENT
_szValue$ = 8
?SV_MakeString@@YAHPBD@Z PROC NEAR			; SV_MakeString, COMDAT

; 217  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 218  : 	return g_GameStringPool.AllocString( szValue );

	mov	eax, DWORD PTR _szValue$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?g_GameStringPool@@3VCStringPool@@A
	call	?AllocString@CStringPool@@QAEHPBD@Z	; CStringPool::AllocString

; 219  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_MakeString@@YAHPBD@Z ENDP				; SV_MakeString
_TEXT	ENDS
EXTRN	?FindString@CStringPool@@QAEPBDH@Z:NEAR		; CStringPool::FindString
;	COMDAT ?SV_GetString@@YAPBDH@Z
_TEXT	SEGMENT
_iString$ = 8
?SV_GetString@@YAPBDH@Z PROC NEAR			; SV_GetString, COMDAT

; 222  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 223  : 	return g_GameStringPool.FindString( iString );

	mov	eax, DWORD PTR _iString$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?g_GameStringPool@@3VCStringPool@@A
	call	?FindString@CStringPool@@QAEPBDH@Z	; CStringPool::FindString

; 224  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_GetString@@YAPBDH@Z ENDP				; SV_GetString
_TEXT	ENDS
;	COMDAT ?PrepWorldFrame@@YAXXZ
_TEXT	SEGMENT
?PrepWorldFrame@@YAXXZ PROC NEAR			; PrepWorldFrame, COMDAT

; 227  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 228  : 	WorldPhysic->EndFrame();

	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+12]

; 229  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrepWorldFrame@@YAXXZ ENDP				; PrepWorldFrame
_TEXT	ENDS
PUBLIC	_Server_GetPhysicsInterface
EXTRN	?g_fPhysicInitialized@@3HA:DWORD		; g_fPhysicInitialized
EXTRN	?g_iXashEngineBuildNumber@@3HA:DWORD		; g_iXashEngineBuildNumber
;	COMDAT _Server_GetPhysicsInterface
_TEXT	SEGMENT
_iVersion$ = 8
_pfuncsFromEngine$ = 12
_pFunctionTable$ = 16
_iExportSize$ = -4
_iImportSize$ = -8
_Server_GetPhysicsInterface PROC NEAR			; COMDAT

; 266  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 267  : 	if ( !pFunctionTable || !pfuncsFromEngine || iVersion != SV_PHYSICS_INTERFACE_VERSION )

	cmp	DWORD PTR _pFunctionTable$[ebp], 0
	je	SHORT $L39335
	cmp	DWORD PTR _pfuncsFromEngine$[ebp], 0
	je	SHORT $L39335
	cmp	DWORD PTR _iVersion$[ebp], 6
	je	SHORT $L39334
$L39335:

; 269  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L39333
$L39334:

; 271  : 
; 272  : 	if( g_iXashEngineBuildNumber < 4140 )

	cmp	DWORD PTR ?g_iXashEngineBuildNumber@@3HA, 4140 ; g_iXashEngineBuildNumber, 0000102cH
	jge	SHORT $L39336

; 273  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L39333
$L39336:

; 274  : 
; 275  : 	size_t iExportSize = sizeof( server_physics_api_t );

	mov	DWORD PTR _iExportSize$[ebp], 124	; 0000007cH

; 276  : 	size_t iImportSize = sizeof( physics_interface_t );

	mov	DWORD PTR _iImportSize$[ebp], 96	; 00000060H

; 277  : 
; 278  : 	// copy new physics interface
; 279  : 	memcpy( &g_physfuncs, pfuncsFromEngine, iExportSize );

	mov	eax, DWORD PTR _iExportSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfuncsFromEngine$[ebp]
	push	ecx
	push	OFFSET FLAT:?g_physfuncs@@3Userver_physics_api_s@@A ; g_physfuncs
	call	_memcpy
	add	esp, 12					; 0000000cH

; 280  : 
; 281  : 	// fill engine callbacks
; 282  : 	memcpy( pFunctionTable, &gPhysicsInterface, iImportSize );

	mov	edx, DWORD PTR _iImportSize$[ebp]
	push	edx
	push	OFFSET FLAT:_gPhysicsInterface
	mov	eax, DWORD PTR _pFunctionTable$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 283  : 
; 284  : 	g_fPhysicInitialized = TRUE;

	mov	DWORD PTR ?g_fPhysicInitialized@@3HA, 1	; g_fPhysicInitialized

; 285  : 
; 286  : 	return TRUE;

	mov	eax, 1
$L39333:

; 287  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Server_GetPhysicsInterface ENDP
_TEXT	ENDS
;	COMDAT ?DispatchCreateEntity@@YAHPAUedict_s@@PBD@Z
_TEXT	SEGMENT
?DispatchCreateEntity@@YAHPAUedict_s@@PBD@Z PROC NEAR	; DispatchCreateEntity, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 295  : 	return -1;

	or	eax, -1

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DispatchCreateEntity@@YAHPAUedict_s@@PBD@Z ENDP	; DispatchCreateEntity
_TEXT	ENDS
PUBLIC	?RunPhysicsFrame@@YAHPAVCBaseEntity@@@Z		; RunPhysicsFrame
;	COMDAT ?DispatchPhysicsEntity@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT
_pEdict$ = 8
_pEntity$ = -4
?DispatchPhysicsEntity@@YAHPAUedict_s@@@Z PROC NEAR	; DispatchPhysicsEntity, COMDAT

; 303  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 304  : 	CBaseEntity *pEntity = CBaseEntity :: Instance( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 305  : 
; 306  : 	if( !pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L39349

; 307  : 		return 0;	// not initialized

	xor	eax, eax
	jmp	SHORT $L39347
$L39349:

; 308  : 
; 309  : 	if( RunPhysicsFrame( pEntity ))

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?RunPhysicsFrame@@YAHPAVCBaseEntity@@@Z	; RunPhysicsFrame
	add	esp, 4
	test	eax, eax
	je	SHORT $L39350

; 311  : 		// g-cont. don't alow free entities during loading because
; 312  : 		// this produce a corrupted baselines
; 313  : 		if( GET_SERVER_STATE() == SERVER_ACTIVE )

	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+20
	cmp	eax, 2
	jne	SHORT $L39352

; 315  : 			// g-cont. impulse 101 issues
; 316  : 			if( !pEdict->free && pEntity->pev->flags & FL_KILLME )

	mov	edx, DWORD PTR _pEdict$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L39352
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 1073741824				; 40000000H
	test	edx, edx
	je	SHORT $L39352

; 317  : 				REMOVE_ENTITY( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+88
	add	esp, 4
$L39352:

; 319  : 		return 1;

	mov	eax, 1
	jmp	SHORT $L39347
$L39350:

; 321  : 
; 322  : 	return 0;

	xor	eax, eax
$L39347:

; 323  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DispatchPhysicsEntity@@YAHPAUedict_s@@@Z ENDP		; DispatchPhysicsEntity
_TEXT	ENDS
PUBLIC	?SV_UpdateBaseVelocity@@YAXPAVCBaseEntity@@@Z	; SV_UpdateBaseVelocity
;	COMDAT ?DispatchUpdatePlayerBaseVelocity@@YAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pEdict$ = 8
_pEntity$ = -4
?DispatchUpdatePlayerBaseVelocity@@YAXPAUedict_s@@@Z PROC NEAR ; DispatchUpdatePlayerBaseVelocity, COMDAT

; 326  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 327  : 	CBaseEntity *pEntity = CBaseEntity :: Instance( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 328  : 
; 329  : 	if( !pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L39357

; 330  : 		return;

	jmp	SHORT $L39355
$L39357:

; 331  : 
; 332  : 	SV_UpdateBaseVelocity( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_UpdateBaseVelocity@@YAXPAVCBaseEntity@@@Z ; SV_UpdateBaseVelocity
	add	esp, 4
$L39355:

; 333  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DispatchUpdatePlayerBaseVelocity@@YAXPAUedict_s@@@Z ENDP ; DispatchUpdatePlayerBaseVelocity
_TEXT	ENDS
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	??YVector@@QAEAAV0@ABV0@@Z			; Vector::operator+=
PUBLIC	?SV_AngularMove@@YAXPAVCBaseEntity@@MM@Z	; SV_AngularMove
PUBLIC	??_C@_0M@OCEI@sv_friction?$AA@			; `string'
PUBLIC	??_C@_0N@PJCG@sv_stopspeed?$AA@			; `string'
PUBLIC	__real@4@4002a000000000000000
EXTRN	_fabs:NEAR
EXTRN	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAngles
EXTRN	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAngles
EXTRN	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAvelocity
EXTRN	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAvelocity
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
;	COMDAT ??_C@_0M@OCEI@sv_friction?$AA@
; File z:\xashxtsrc\server\physic.cpp
CONST	SEGMENT
??_C@_0M@OCEI@sv_friction?$AA@ DB 'sv_friction', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PJCG@sv_stopspeed?$AA@
CONST	SEGMENT
??_C@_0N@PJCG@sv_stopspeed?$AA@ DB 'sv_stopspeed', 00H	; `string'
CONST	ENDS
;	COMDAT __real@4@4002a000000000000000
CONST	SEGMENT
__real@4@4002a000000000000000 DD 041200000r	; 10
CONST	ENDS
;	COMDAT ?SV_AngularMove@@YAXPAVCBaseEntity@@MM@Z
_TEXT	SEGMENT
_pEntity$ = 8
_frametime$ = 12
_friction$ = 16
_angles$ = -12
_amove$ = -24
_game_friction$ = -28
_game_stopspeed$ = -32
_adjustment$ = -36
_avelocity$ = -48
_i$ = -52
$T41601 = -64
?SV_AngularMove@@YAXPAVCBaseEntity@@MM@Z PROC NEAR	; SV_AngularMove, COMDAT

; 348  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi

; 349  : 	Vector angles = pEntity->GetLocalAngles();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 350  : 	Vector amove = pEntity->GetLocalAvelocity() * frametime;

	mov	eax, DWORD PTR _frametime$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41601[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _amove$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 351  : 
; 352  : 	angles += amove;

	lea	edx, DWORD PTR _amove$[ebp]
	push	edx
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 353  : 	pEntity->SetLocalAngles( angles );

	lea	eax, DWORD PTR _angles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 354  : 
; 355  : 	if( friction == 0.0f || pEntity->GetLocalAvelocity() == g_vecZero )

	fld	DWORD PTR _friction$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39370
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L39369
$L39370:

; 356  : 		return;

	jmp	$L39365
$L39369:

; 357  : 
; 358  : 	float game_friction = CVAR_GET_FLOAT( "sv_friction" );

	push	OFFSET FLAT:??_C@_0M@OCEI@sv_friction?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fstp	DWORD PTR _game_friction$[ebp]

; 359  : 	float game_stopspeed = CVAR_GET_FLOAT( "sv_stopspeed" );

	push	OFFSET FLAT:??_C@_0N@PJCG@sv_stopspeed?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fst	DWORD PTR _game_stopspeed$[ebp]

; 360  : 	float adjustment = frametime * (game_stopspeed / 10) * game_friction * fabs( friction );

	fdiv	DWORD PTR __real@4@4002a000000000000000
	fmul	DWORD PTR _frametime$[ebp]
	fmul	DWORD PTR _game_friction$[ebp]
	fstp	QWORD PTR -72+[ebp]
	fld	DWORD PTR _friction$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fmul	QWORD PTR -72+[ebp]
	fstp	DWORD PTR _adjustment$[ebp]

; 361  : 	Vector avelocity = pEntity->GetLocalAvelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	push	eax
	lea	ecx, DWORD PTR _avelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 362  : 
; 363  : 	for( int i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39378
$L39379:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L39378:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$L39380

; 365  : 		if( avelocity[i] > 0.0f )

	lea	ecx, DWORD PTR _avelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39381

; 367  : 			avelocity[i] -= adjustment;

	lea	ecx, DWORD PTR _avelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR -76+[ebp], edx
	mov	eax, DWORD PTR -76+[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR _adjustment$[ebp]
	mov	ecx, DWORD PTR -76+[ebp]
	fstp	DWORD PTR [ecx]

; 368  : 			if( avelocity[i] < 0.0f ) avelocity[i] = 0.0f;

	lea	ecx, DWORD PTR _avelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39382
	lea	ecx, DWORD PTR _avelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0
$L39382:

; 370  : 		else

	jmp	SHORT $L39384
$L39381:

; 372  : 			avelocity[i] += adjustment;

	lea	ecx, DWORD PTR _avelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR -80+[ebp], eax
	mov	ecx, DWORD PTR -80+[ebp]
	fld	DWORD PTR _adjustment$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR -80+[ebp]
	fstp	DWORD PTR [edx]

; 373  : 			if( avelocity[i] > 0.0f ) avelocity[i] = 0.0f;

	lea	ecx, DWORD PTR _avelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39384
	lea	ecx, DWORD PTR _avelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+edx*4], 0
$L39384:

; 375  : 	}

	jmp	$L39379
$L39380:

; 376  : 
; 377  : 	pEntity->SetLocalAvelocity( avelocity );

	lea	eax, DWORD PTR _avelocity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity
$L39365:

; 378  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_AngularMove@@YAXPAVCBaseEntity@@MM@Z ENDP		; SV_AngularMove
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41606
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41606
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41606
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41607
$L41606:
	mov	DWORD PTR -8+[ebp], 0
$L41607:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T41610 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41610[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??YVector@@QAEAAV0@ABV0@@Z PROC NEAR			; Vector::operator+=, COMDAT

; 159  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		x+=v.x; y+=v.y; z += v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 161  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 162  : 	}			

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??YVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator+=
_TEXT	ENDS
PUBLIC	?SV_LinearMove@@YAXPAVCBaseEntity@@MM@Z		; SV_LinearMove
EXTRN	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalOrigin
EXTRN	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalOrigin
EXTRN	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalVelocity
EXTRN	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalVelocity
;	COMDAT ?SV_LinearMove@@YAXPAVCBaseEntity@@MM@Z
_TEXT	SEGMENT
_pEntity$ = 8
_frametime$ = 12
_friction$ = 16
_origin$ = -12
_move$ = -24
_game_friction$ = -28
_game_stopspeed$ = -32
_adjustment$ = -36
_velocity$ = -48
_i$ = -52
$T41617 = -64
?SV_LinearMove@@YAXPAVCBaseEntity@@MM@Z PROC NEAR	; SV_LinearMove, COMDAT

; 388  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi

; 389  : 	Vector origin = pEntity->GetLocalOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	ecx, DWORD PTR _origin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 390  : 	Vector move = pEntity->GetLocalVelocity() * frametime;

	mov	eax, DWORD PTR _frametime$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41617[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _move$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 391  : 
; 392  : 	origin += move;

	lea	edx, DWORD PTR _move$[ebp]
	push	edx
	lea	ecx, DWORD PTR _origin$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 393  : 	pEntity->SetLocalOrigin( origin );

	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalOrigin

; 394  : 
; 395  : 	if( friction == 0.0f || pEntity->GetAbsVelocity() == g_vecZero )

	fld	DWORD PTR _friction$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39394
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L39393
$L39394:

; 396  : 		return;

	jmp	$L39389
$L39393:

; 397  : 
; 398  : 	float game_friction = CVAR_GET_FLOAT( "sv_friction" );

	push	OFFSET FLAT:??_C@_0M@OCEI@sv_friction?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fstp	DWORD PTR _game_friction$[ebp]

; 399  : 	float game_stopspeed = CVAR_GET_FLOAT( "sv_stopspeed" );

	push	OFFSET FLAT:??_C@_0N@PJCG@sv_stopspeed?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fst	DWORD PTR _game_stopspeed$[ebp]

; 400  : 	float adjustment = frametime * (game_stopspeed / 10) * game_friction * fabs( friction );

	fdiv	DWORD PTR __real@4@4002a000000000000000
	fmul	DWORD PTR _frametime$[ebp]
	fmul	DWORD PTR _game_friction$[ebp]
	fstp	QWORD PTR -72+[ebp]
	fld	DWORD PTR _friction$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fmul	QWORD PTR -72+[ebp]
	fstp	DWORD PTR _adjustment$[ebp]

; 401  : 	Vector velocity = pEntity->GetLocalVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalVelocity
	push	eax
	lea	ecx, DWORD PTR _velocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 402  : 
; 403  : 	for( int i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39400
$L39401:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L39400:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$L39402

; 405  : 		if( velocity[i] > 0.0f )

	lea	ecx, DWORD PTR _velocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39403

; 407  : 			velocity[i] -= adjustment;

	lea	ecx, DWORD PTR _velocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR -76+[ebp], edx
	mov	eax, DWORD PTR -76+[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR _adjustment$[ebp]
	mov	ecx, DWORD PTR -76+[ebp]
	fstp	DWORD PTR [ecx]

; 408  : 			if( velocity[i] < 0.0f ) velocity[i] = 0.0f;

	lea	ecx, DWORD PTR _velocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39404
	lea	ecx, DWORD PTR _velocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0
$L39404:

; 410  : 		else

	jmp	SHORT $L39406
$L39403:

; 412  : 			velocity[i] += adjustment;

	lea	ecx, DWORD PTR _velocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR -80+[ebp], eax
	mov	ecx, DWORD PTR -80+[ebp]
	fld	DWORD PTR _adjustment$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR -80+[ebp]
	fstp	DWORD PTR [edx]

; 413  : 			if( velocity[i] > 0.0f ) velocity[i] = 0.0f;

	lea	ecx, DWORD PTR _velocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39406
	lea	ecx, DWORD PTR _velocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+edx*4], 0
$L39406:

; 415  : 	}

	jmp	$L39401
$L39402:

; 416  : 
; 417  : 	pEntity->SetLocalVelocity( velocity );

	lea	eax, DWORD PTR _velocity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity
$L39389:

; 418  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_LinearMove@@YAXPAVCBaseEntity@@MM@Z ENDP		; SV_LinearMove
_TEXT	ENDS
PUBLIC	?AddEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::AddEntity
PUBLIC	??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::operator[]
PUBLIC	?AddToTail@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::AddToTail
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
;	COMDAT ?AddEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_ent$ = 8
_this$ = -4
_i$ = -8
?AddEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicsPushedEntities::AddEntity, COMDAT

; 424  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 425  : 	int i = m_rgMoved.AddToTail();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?AddToTail@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::AddToTail
	mov	DWORD PTR _i$[ebp], eax

; 426  : 	m_rgMoved[i].m_pEntity = ent;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::operator[]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax], ecx

; 427  : 	m_rgMoved[i].m_vecStartAbsOrigin = ent->GetAbsOrigin();

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	esi, eax
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::operator[]
	add	eax, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx

; 428  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z ENDP ; CPhysicsPushedEntities::AddEntity
_TEXT	ENDS
PUBLIC	?UnlinkPusherList@CPhysicsPushedEntities@@IAEXXZ ; CPhysicsPushedEntities::UnlinkPusherList
PUBLIC	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Count
PUBLIC	?MakeNonSolid@CBaseEntity@@QAEXXZ		; CBaseEntity::MakeNonSolid
;	COMDAT ?UnlinkPusherList@CPhysicsPushedEntities@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
_pEnt$39420 = -12
?UnlinkPusherList@CPhysicsPushedEntities@@IAEXXZ PROC NEAR ; CPhysicsPushedEntities::UnlinkPusherList, COMDAT

; 434  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 435  : 	for( int i = m_rgPusher.Count(); --i >= 0; )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Count@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Count
	mov	DWORD PTR _i$[ebp], eax
$L39418:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L39419

; 437  : 		CBaseEntity *pEnt = m_rgPusher[i].m_pEntity;

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _pEnt$39420[ebp], edx

; 438  : 		pEnt->MakeNonSolid();

	mov	ecx, DWORD PTR _pEnt$39420[ebp]
	call	?MakeNonSolid@CBaseEntity@@QAEXXZ	; CBaseEntity::MakeNonSolid

; 439  : 	}

	jmp	SHORT $L39418
$L39419:

; 440  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UnlinkPusherList@CPhysicsPushedEntities@@IAEXXZ ENDP	; CPhysicsPushedEntities::UnlinkPusherList
_TEXT	ENDS
;	COMDAT ?MakeNonSolid@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MakeNonSolid@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::MakeNonSolid, COMDAT

; 637  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 		if( m_iOldSolid == SOLID_NOT && pev->solid != SOLID_NOT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $L35080
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 0
	je	SHORT $L35080

; 640  : 			WorldPhysic->EnableCollision( this, FALSE );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+92]

; 641  : 			m_iOldSolid = pev->solid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+268]
	mov	DWORD PTR [edx+16], eax

; 642  : 			pev->solid = SOLID_NOT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 0
$L35080:

; 644  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MakeNonSolid@CBaseEntity@@QAEXXZ ENDP			; CBaseEntity::MakeNonSolid
_TEXT	ENDS
PUBLIC	?RelinkPusherList@CPhysicsPushedEntities@@IAEXXZ ; CPhysicsPushedEntities::RelinkPusherList
PUBLIC	?RestoreSolid@CBaseEntity@@QAEXXZ		; CBaseEntity::RestoreSolid
;	COMDAT ?RelinkPusherList@CPhysicsPushedEntities@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
_pEnt$39429 = -12
?RelinkPusherList@CPhysicsPushedEntities@@IAEXXZ PROC NEAR ; CPhysicsPushedEntities::RelinkPusherList, COMDAT

; 443  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 444  : 	for( int i = m_rgPusher.Count(); --i >= 0; )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Count@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Count
	mov	DWORD PTR _i$[ebp], eax
$L39427:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L39428

; 446  : 		CBaseEntity *pEnt = m_rgPusher[i].m_pEntity;

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _pEnt$39429[ebp], edx

; 447  : 		pEnt->RestoreSolid();

	mov	ecx, DWORD PTR _pEnt$39429[ebp]
	call	?RestoreSolid@CBaseEntity@@QAEXXZ	; CBaseEntity::RestoreSolid

; 448  : 		pEnt->RelinkEntity( FALSE );

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pEnt$39429[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 449  : 	}

	jmp	SHORT $L39427
$L39428:

; 450  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RelinkPusherList@CPhysicsPushedEntities@@IAEXXZ ENDP	; CPhysicsPushedEntities::RelinkPusherList
_TEXT	ENDS
;	COMDAT ?RestoreSolid@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RestoreSolid@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::RestoreSolid, COMDAT

; 647  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 648  : 		if( m_iOldSolid != SOLID_NOT && pev->solid == SOLID_NOT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L35083
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 0
	jne	SHORT $L35083

; 650  : 			WorldPhysic->EnableCollision( this, TRUE );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+92]

; 651  : 			pev->solid = m_iOldSolid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+268], eax

; 652  : 			m_iOldSolid = SOLID_NOT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
$L35083:

; 654  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RestoreSolid@CBaseEntity@@QAEXXZ ENDP			; CBaseEntity::RestoreSolid
_TEXT	ENDS
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	?CalcRotationalPushDirection@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@ABURotatingPushMove_t@1@AAVVector@@0@Z ; CPhysicsPushedEntities::CalcRotationalPushDirection
EXTRN	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix4x4::VectorTransform
EXTRN	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix4x4::VectorITransform
;	COMDAT ?CalcRotationalPushDirection@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@ABURotatingPushMove_t@1@AAVVector@@0@Z
_TEXT	SEGMENT
_pBlocker$ = 8
_rotMove$ = 12
_pMove$ = 16
_this$ = -4
_start$ = -16
_local$ = -28
_end$ = -40
$T41630 = -52
$T41631 = -64
$T41632 = -76
$T41633 = -88
?CalcRotationalPushDirection@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@ABURotatingPushMove_t@1@AAVVector@@0@Z PROC NEAR ; CPhysicsPushedEntities::CalcRotationalPushDirection, COMDAT

; 456  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 	// calculate destination position
; 458  : 	// "start" is relative to the *root* pusher, world orientation
; 459  : 	Vector start;

	lea	ecx, DWORD PTR _start$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 460  : 
; 461  : 	if( !SV_AllowPushRotate( pBlocker ) || pBlocker->pev->movetype == MOVETYPE_STEP )

	mov	eax, DWORD PTR _pBlocker$[ebp]
	push	eax
	call	?SV_AllowPushRotate@@YAHPAVCBaseEntity@@@Z ; SV_AllowPushRotate
	add	esp, 4
	test	eax, eax
	je	SHORT $L39439
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 4
	jne	SHORT $L39438
$L39439:

; 462  : 		start = pBlocker->Center();

	lea	eax, DWORD PTR $T41630[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	DWORD PTR [edx+304]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _start$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _start$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _start$[ebp+8], eax

; 463  : 	else start = pBlocker->GetAbsOrigin();

	jmp	SHORT $L39441
$L39438:
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _start$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _start$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _start$[ebp+8], eax
$L39441:

; 464  : 
; 465  : 	// org is pusher local coordinate of start
; 466  : 
; 467  : 	// transform starting point into local space
; 468  : 	Vector local = rotMove.startLocalToWorld.VectorITransform( start );

	lea	ecx, DWORD PTR _start$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41631[ebp]
	push	edx
	mov	ecx, DWORD PTR _rotMove$[ebp]
	add	ecx, 24					; 00000018H
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	push	eax
	lea	ecx, DWORD PTR _local$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 469  : 
; 470  : 	// rotate local org into world space at end of rotation
; 471  : 	Vector end = rotMove.endLocalToWorld.VectorTransform( local );

	lea	eax, DWORD PTR _local$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41632[ebp]
	push	ecx
	mov	ecx, DWORD PTR _rotMove$[ebp]
	add	ecx, 88					; 00000058H
	call	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorTransform
	push	eax
	lea	ecx, DWORD PTR _end$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 472  : 
; 473  : 	// move is the difference (in world space) that the move will push this object
; 474  : 	pMove = end - start;

	lea	edx, DWORD PTR _start$[ebp]
	push	edx
	lea	eax, DWORD PTR $T41633[ebp]
	push	eax
	lea	ecx, DWORD PTR _end$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR _pMove$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 475  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CalcRotationalPushDirection@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@ABURotatingPushMove_t@1@AAVVector@@0@Z ENDP ; CPhysicsPushedEntities::CalcRotationalPushDirection
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T41636 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41636[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
PUBLIC	?IsPushedPositionValid@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::IsPushedPositionValid
EXTRN	?UTIL_TraceEntity@@YAXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z:NEAR ; UTIL_TraceEntity
;	COMDAT ?IsPushedPositionValid@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pBlocker$ = 8
_this$ = -4
_trace$ = -60
?IsPushedPositionValid@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z PROC NEAR ; CPhysicsPushedEntities::IsPushedPositionValid, COMDAT

; 478  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 479  : 	TraceResult trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 480  : 
; 481  : 	UTIL_TraceEntity( pBlocker, pBlocker->GetAbsOrigin(), pBlocker->GetAbsOrigin(), &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	push	ecx
	call	?UTIL_TraceEntity@@YAXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z ; UTIL_TraceEntity
	add	esp, 16					; 00000010H

; 482  : 
; 483  : 	return !trace.fStartSolid;

	xor	eax, eax
	cmp	DWORD PTR _trace$[ebp+4], 0
	sete	al

; 484  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsPushedPositionValid@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z ENDP ; CPhysicsPushedEntities::IsPushedPositionValid
_TEXT	ENDS
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??Amatrix4x4@@QAEPAMH@Z				; matrix4x4::operator[]
PUBLIC	?SpeculativelyCheckPush@CPhysicsPushedEntities@@IAE_NAAUPhysicsPushedInfo_t@1@ABVVector@@_N@Z ; CPhysicsPushedEntities::SpeculativelyCheckPush
PUBLIC	??_C@_0CI@EEMA@Interpenetrating?5entities?$CB?5?$CI?$CFs?5a@ ; `string'
PUBLIC	??_C@_0CB@EHCK@Ignoring?5player?5blocking?5train?$CB?6@ ; `string'
PUBLIC	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
PUBLIC	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ	; CBaseEntity::GetGroundEntity
EXTRN	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsOrigin
EXTRN	?GetRootParent@CBaseEntity@@QAEPAV1@XZ:NEAR	; CBaseEntity::GetRootParent
;	COMDAT ??_C@_0CI@EEMA@Interpenetrating?5entities?$CB?5?$CI?$CFs?5a@
; File z:\xashxtsrc\server\physic.cpp
CONST	SEGMENT
??_C@_0CI@EEMA@Interpenetrating?5entities?$CB?5?$CI?$CFs?5a@ DB 'Interpen'
	DB	'etrating entities! (%s and %s)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EHCK@Ignoring?5player?5blocking?5train?$CB?6@
CONST	SEGMENT
??_C@_0CB@EHCK@Ignoring?5player?5blocking?5train?$CB?6@ DB 'Ignoring play'
	DB	'er blocking train!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?SpeculativelyCheckPush@CPhysicsPushedEntities@@IAE_NAAUPhysicsPushedInfo_t@1@ABVVector@@_N@Z
_TEXT	SEGMENT
_info$ = 8
_srcAbsPush$ = 12
_bRotationalPush$ = 16
_this$ = -4
_pBlocker$ = -8
_ent$ = -12
_vecAbsPush$ = -24
_pushDestPosition$ = -36
_bIsDynamic$ = -40
_bIsCharacter$ = -44
_bIsUnblockable$ = -48
_bIsBlocked$ = -52
_org$39491 = -64
_checkCount$39492 = -68
_move$39496 = -80
_factor$39497 = -84
$T41641 = -96
$T41648 = -108
$T41649 = -120
?SpeculativelyCheckPush@CPhysicsPushedEntities@@IAE_NAAUPhysicsPushedInfo_t@1@ABVVector@@_N@Z PROC NEAR ; CPhysicsPushedEntities::SpeculativelyCheckPush, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 491  : 	CBaseEntity *pBlocker = info.m_pEntity;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pBlocker$[ebp], ecx

; 492  : 	edict_t *ent = pBlocker->edict();

	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _ent$[ebp], eax

; 493  : 	Vector vecAbsPush = srcAbsPush;

	mov	edx, DWORD PTR _srcAbsPush$[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecAbsPush$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 494  : 
; 495  : 	// See if it's possible to move the entity, but disable all pushers in the hierarchy first
; 496  : 	UnlinkPusherList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnlinkPusherList@CPhysicsPushedEntities@@IAEXXZ ; CPhysicsPushedEntities::UnlinkPusherList

; 497  : 
; 498  : 	// i can't clear FL_ONGROUND in all cases because many bad things may be happen
; 499  : 	if( pBlocker->pev->movetype != MOVETYPE_WALK && bRotationalPush )

	mov	eax, DWORD PTR _pBlocker$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+264], 3
	je	SHORT $L39462
	mov	edx, DWORD PTR _bRotationalPush$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L39462

; 501  : 		if( vecAbsPush[2] < 0.0f && !m_rgPusher[0].m_pEntity->pev->dmg )

	lea	ecx, DWORD PTR _vecAbsPush$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39462
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+480]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39462

; 502  : 			vecAbsPush[2] = 0.0f; // let's the free falling

	lea	ecx, DWORD PTR _vecAbsPush$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0
$L39462:

; 504  : 
; 505  : 	Vector pushDestPosition = pBlocker->GetAbsOrigin() + vecAbsPush;

	lea	edx, DWORD PTR _vecAbsPush$[ebp]
	push	edx
	lea	eax, DWORD PTR $T41641[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _pushDestPosition$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 506  : 
; 507  : 	UTIL_TraceEntity( pBlocker, pBlocker->GetAbsOrigin(), pushDestPosition, &info.m_trace );

	mov	ecx, DWORD PTR _info$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	lea	edx, DWORD PTR _pushDestPosition$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	eax, DWORD PTR _pBlocker$[ebp]
	push	eax
	call	?UTIL_TraceEntity@@YAXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z ; UTIL_TraceEntity
	add	esp, 16					; 00000010H

; 508  : 
; 509  : 	RelinkPusherList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkPusherList@CPhysicsPushedEntities@@IAEXXZ ; CPhysicsPushedEntities::RelinkPusherList

; 510  : 
; 511  : 	info.m_bPusherIsGround = false;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	BYTE PTR [ecx+73], 0

; 512  : 
; 513  : 	// remove the onground flag for non-players
; 514  : 	if( pBlocker->pev->movetype != MOVETYPE_WALK && !bRotationalPush )

	mov	edx, DWORD PTR _pBlocker$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+264], 3
	je	SHORT $L39465
	mov	ecx, DWORD PTR _bRotationalPush$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L39465

; 515  : 		pBlocker->pev->flags &= ~FL_ONGROUND;

	mov	edx, DWORD PTR _pBlocker$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ch, -3					; fffffffdH
	mov	edx, DWORD PTR _pBlocker$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx
$L39465:

; 516  : 
; 517  : 	if( pBlocker->GetGroundEntity() && pBlocker->GetGroundEntity()->GetRootParent() == m_rgPusher[0].m_pEntity )

	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ; CBaseEntity::GetGroundEntity
	test	eax, eax
	je	SHORT $L39466
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ; CBaseEntity::GetGroundEntity
	mov	ecx, eax
	call	?GetRootParent@CBaseEntity@@QAEPAV1@XZ	; CBaseEntity::GetRootParent
	mov	esi, eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $L39466

; 519  : 		info.m_bPusherIsGround = true;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	BYTE PTR [ecx+73], 1
$L39466:

; 521  : 
; 522  : 	bool bIsDynamic = ( pBlocker->m_iActorType == ACTOR_DYNAMIC ) ? true : false;

	mov	edx, DWORD PTR _pBlocker$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+1604]
	cmp	eax, 1
	sete	cl
	mov	BYTE PTR _bIsDynamic$[ebp], cl

; 523  : 	bool bIsCharacter = (pBlocker->IsPlayer() || pBlocker->MyMonsterPointer()) ? true : false;

	mov	edx, DWORD PTR _pBlocker$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	DWORD PTR [eax+224]
	test	eax, eax
	jne	SHORT $L41642
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	DWORD PTR [edx+124]
	test	eax, eax
	jne	SHORT $L41642
	mov	BYTE PTR -121+[ebp], 0
	jmp	SHORT $L41643
$L41642:
	mov	BYTE PTR -121+[ebp], 1
$L41643:
	mov	al, BYTE PTR -121+[ebp]
	mov	BYTE PTR _bIsCharacter$[ebp], al

; 524  : 	bool bIsUnblockable = (m_bIsUnblockableByPlayer && bIsCharacter) ? true : false;

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+48]
	test	edx, edx
	je	SHORT $L41644
	mov	eax, DWORD PTR _bIsCharacter$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41644
	mov	BYTE PTR -122+[ebp], 1
	jmp	SHORT $L41645
$L41644:
	mov	BYTE PTR -122+[ebp], 0
$L41645:
	mov	cl, BYTE PTR -122+[ebp]
	mov	BYTE PTR _bIsUnblockable$[ebp], cl

; 525  : 	bool bIsBlocked = (pushDestPosition != info.m_trace.vecEndPos) ? true : false;

	mov	edx, DWORD PTR _info$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	lea	ecx, DWORD PTR _pushDestPosition$[ebp]
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	setne	al
	mov	BYTE PTR _bIsBlocked$[ebp], al

; 526  : 
; 527  : 	if( pBlocker->pev->movetype != MOVETYPE_WALK )

	mov	ecx, DWORD PTR _pBlocker$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 3
	je	SHORT $L39472

; 529  : 		if( bRotationalPush && ( bIsBlocked || srcAbsPush.z != 0.0f ))

	mov	eax, DWORD PTR _bRotationalPush$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L39472
	mov	ecx, DWORD PTR _bIsBlocked$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L39473
	mov	edx, DWORD PTR _srcAbsPush$[ebp]
	fld	DWORD PTR [edx+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39472
$L39473:

; 530  : 			pBlocker->pev->flags &= ~FL_ONGROUND;

	mov	eax, DWORD PTR _pBlocker$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	dh, -3					; fffffffdH
	mov	eax, DWORD PTR _pBlocker$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx
$L39472:

; 532  : 
; 533  : 	if( bIsUnblockable )

	mov	edx, DWORD PTR _bIsUnblockable$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L39474

; 535  : 		pBlocker->SetAbsOrigin( pushDestPosition );

	lea	eax, DWORD PTR _pushDestPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 537  : 	else

	jmp	$L39484
$L39474:

; 539  : 		// move the blocker into its new position
; 540  : 		if( info.m_trace.flFraction )

	mov	ecx, DWORD PTR _info$[ebp]
	fld	DWORD PTR [ecx+32]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39479

; 542  : 			if( !info.m_trace.fAllSolid )

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $L39477

; 544  : 				pBlocker->SetAbsOrigin( info.m_trace.vecEndPos );

	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 546  : 			else if( pBlocker->m_iActorType == ACTOR_DYNAMIC && !info.m_bPusherIsGround && !bRotationalPush )

	jmp	SHORT $L39479
$L39477:
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+1604]
	cmp	edx, 1
	jne	SHORT $L39479
	mov	eax, DWORD PTR _info$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+73]
	test	ecx, ecx
	jne	SHORT $L39479
	mov	edx, DWORD PTR _bRotationalPush$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L39479

; 548  : 				return false;

	xor	al, al
	jmp	$L39457
$L39479:

; 551  : 
; 552  : 		// we're not blocked if the blocker is point-sized or non-solid
; 553  : 		if( pBlocker->IsPointSized() || pBlocker->pev->solid == SOLID_NOT )

	mov	eax, DWORD PTR _pBlocker$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	DWORD PTR [edx+320]
	test	eax, eax
	jne	SHORT $L39481
	mov	eax, DWORD PTR _pBlocker$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+268], 0
	jne	SHORT $L39480
$L39481:

; 555  : 			return true;

	mov	al, 1
	jmp	$L39457
$L39480:

; 557  : 
; 558  : 		// we're not blocked if the blocker is dead body or trigger
; 559  : 		if( pBlocker->pev->deadflag >= DEAD_DEAD || pBlocker->pev->solid == SOLID_TRIGGER )

	mov	edx, DWORD PTR _pBlocker$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+368], 2
	jge	SHORT $L39483
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 1
	jne	SHORT $L39482
$L39483:

; 561  : 			return true;

	mov	al, 1
	jmp	$L39457
$L39482:

; 563  : 
; 564  : 		if(( !bRotationalPush || bIsDynamic || bIsCharacter ) && ( pBlocker->GetAbsOrigin() == pushDestPosition ))

	mov	eax, DWORD PTR _bRotationalPush$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L39485
	mov	ecx, DWORD PTR _bIsDynamic$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L39485
	mov	edx, DWORD PTR _bIsCharacter$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L39484
$L39485:
	lea	eax, DWORD PTR _pushDestPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L39484

; 566  : 			if( !info.m_bPusherIsGround && !IsPushedPositionValid( pBlocker ))

	mov	ecx, DWORD PTR _info$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+73]
	test	edx, edx
	jne	SHORT $L39487
	mov	eax, DWORD PTR _pBlocker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPushedPositionValid@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::IsPushedPositionValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39487

; 568  : 				if( !bIsDynamic )

	mov	ecx, DWORD PTR _bIsDynamic$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L39487

; 570  : 					ALERT( at_warning, "Interpenetrating entities! (%s and %s)\n",
; 571  : 					pBlocker->GetClassname(), m_rgPusher[0].m_pEntity->GetClassname() );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CI@EEMA@Interpenetrating?5entities?$CB?5?$CI?$CFs?5a@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H
$L39487:

; 574  : 			return true;

	mov	al, 1
	jmp	$L39457
$L39484:

; 577  : 
; 578  : 	// check to see if we're still blocked by the pushers
; 579  : 	// FIXME: If the trace fraction == 0 can we early out also?
; 580  : 	info.m_bBlocked = !IsPushedPositionValid( pBlocker );

	mov	edx, DWORD PTR _pBlocker$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPushedPositionValid@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::IsPushedPositionValid
	and	eax, 255				; 000000ffH
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	BYTE PTR [ecx+72], al

; 581  : 
; 582  : 	if( !info.m_bBlocked /* && !bIsBlocked*/ )

	mov	edx, DWORD PTR _info$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+72]
	test	eax, eax
	jne	SHORT $L39489

; 583  : 		return true;

	mov	al, 1
	jmp	$L39457
$L39489:

; 584  : 
; 585  : 	// if the player is blocking the train try nudging him around to fix accumulated error
; 586  : 	if( bIsUnblockable )

	mov	ecx, DWORD PTR _bIsUnblockable$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	$L39490

; 588  : 		Vector org = pBlocker->GetAbsOrigin();

	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _org$39491[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 589  : 
; 590  : 		for( int checkCount = 0; checkCount < 4; checkCount++ )

	mov	DWORD PTR _checkCount$39492[ebp], 0
	jmp	SHORT $L39493
$L39494:
	mov	edx, DWORD PTR _checkCount$39492[ebp]
	add	edx, 1
	mov	DWORD PTR _checkCount$39492[ebp], edx
$L39493:
	cmp	DWORD PTR _checkCount$39492[ebp], 4
	jge	$L39495

; 592  : 			Vector move = m_rgPusher[0].m_pEntity->EntityToWorldTransform()[checkCount>>1];

	mov	eax, DWORD PTR _checkCount$39492[ebp]
	sar	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	mov	ecx, eax
	call	??Amatrix4x4@@QAEPAMH@Z			; matrix4x4::operator[]
	push	eax
	lea	ecx, DWORD PTR _move$39496[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector

; 593  : 			
; 594  : 			// alternate movements 1/2" in each direction
; 595  : 			float factor = ( checkCount & 1 ) ? -0.5f : 0.5f;

	mov	ecx, DWORD PTR _checkCount$39492[ebp]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L41646
	mov	DWORD PTR -128+[ebp], -1090519040	; bf000000H
	jmp	SHORT $L41647
$L41646:
	mov	DWORD PTR -128+[ebp], 1056964608	; 3f000000H
$L41647:
	mov	edx, DWORD PTR -128+[ebp]
	mov	DWORD PTR _factor$39497[ebp], edx

; 596  : 			pBlocker->SetAbsOrigin( org + move * factor );

	mov	eax, DWORD PTR _factor$39497[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41648[ebp]
	push	ecx
	lea	ecx, DWORD PTR _move$39496[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T41649[ebp]
	push	edx
	lea	ecx, DWORD PTR _org$39491[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 597  : 			info.m_bBlocked = !IsPushedPositionValid( pBlocker );

	mov	eax, DWORD PTR _pBlocker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPushedPositionValid@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::IsPushedPositionValid
	and	eax, 255				; 000000ffH
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	BYTE PTR [ecx+72], al

; 598  : 
; 599  : 			if( !info.m_bBlocked )

	mov	edx, DWORD PTR _info$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+72]
	test	eax, eax
	jne	SHORT $L39500

; 600  : 				return true;

	mov	al, 1
	jmp	SHORT $L39457
$L39500:

; 601  : 		}

	jmp	$L39494
$L39495:

; 602  : 
; 603  : 		pBlocker->SetAbsOrigin( pushDestPosition );

	lea	ecx, DWORD PTR _pushDestPosition$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 604  : 		ALERT( at_aiconsole, "Ignoring player blocking train!\n" );

	push	OFFSET FLAT:??_C@_0CB@EHCK@Ignoring?5player?5blocking?5train?$CB?6@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 605  : 		return true;

	mov	al, 1
	jmp	SHORT $L39457
$L39490:

; 607  : 
; 608  : 	return false;

	xor	al, al
$L39457:

; 609  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SpeculativelyCheckPush@CPhysicsPushedEntities@@IAE_NAAUPhysicsPushedInfo_t@1@ABVVector@@_N@Z ENDP ; CPhysicsPushedEntities::SpeculativelyCheckPush
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T41654 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41654[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
PUBLIC	??BVector4D@@QAEPAMXZ				; Vector4D::operator float *
;	COMDAT ??Amatrix4x4@@QAEPAMH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??Amatrix4x4@@QAEPAMH@Z PROC NEAR			; matrix4x4::operator[], COMDAT

; 952  : 	float* operator[]( int i ) { return mat[i]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, eax
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??Amatrix4x4@@QAEPAMH@Z ENDP				; matrix4x4::operator[]
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector4D@@QAEPAMXZ PROC NEAR				; Vector4D::operator float *, COMDAT

; 325  : 	operator float *()					{ return &x; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector4D@@QAEPAMXZ ENDP				; Vector4D::operator float *
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
;	COMDAT ?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ PROC NEAR	; CBaseEntity::GetGroundEntity, COMDAT

; 599  : 	CBaseEntity *GetGroundEntity( void ) { return Instance( pev->groundentity ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+412]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ENDP		; CBaseEntity::GetGroundEntity
_TEXT	ENDS
PUBLIC	??0matrix4x4@@QAE@ABVVector@@0M@Z		; matrix4x4::matrix4x4
EXTRN	??4matrix4x4@@QAEAAV0@ABV0@@Z:NEAR		; matrix4x4::operator=
EXTRN	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ:NEAR	; CBaseEntity::CalcAbsolutePosition
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ
_TEXT	SEGMENT
_this$ = -4
$T41665 = -68
$T41666 = -80
?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ PROC NEAR ; CBaseEntity::EntityToWorldTransform, COMDAT

; 732  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 733  : 	if( IsPlayer( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L35136

; 735  : 		m_local = matrix4x4( pev->origin, Vector( 0.0f, pev->angles.y, 0.0f ));

	push	1065353216				; 3f800000H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	push	0
	lea	ecx, DWORD PTR $T41666[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	push	ecx
	lea	ecx, DWORD PTR $T41665[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 737  : 	else if( pev->flags & FL_ABSTRANSFORM )

	jmp	SHORT $L35140
$L35136:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L35140

; 739  : 		CalcAbsolutePosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsolutePosition
$L35140:

; 741  : 	return m_local; 

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 180				; 000000b4H

; 742  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ENDP ; CBaseEntity::EntityToWorldTransform
_TEXT	ENDS
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	??0Vector4D@@QAE@XZ				; Vector4D::Vector4D
PUBLIC	__real@8@3ff98efa351294e9c800
PUBLIC	?SinCos@@YAXMPAM0@Z				; SinCos
;	COMDAT __real@8@3ff98efa351294e9c800
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@8@3ff98efa351294e9c800 DQ 03f91df46a2529d39r ; 0.0174533
CONST	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT
_origin$ = 8
_angles$ = 12
_scale$ = 16
_this$ = -4
_angle$ = -8
_sr$ = -12
_sp$ = -16
_sy$ = -20
_cr$ = -24
_cp$ = -28
_cy$ = -32
??0matrix4x4@@QAE@ABVVector@@0M@Z PROC NEAR		; matrix4x4::matrix4x4, COMDAT

; 701  : 	_forceinline matrix4x4( const Vector &origin, const Vector &angles, float scale = 1.0f )

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 702  : 	{
; 703  : 		float	angle, sr, sp, sy, cr, cp, cy;
; 704  : 
; 705  : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25873

; 707  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 708  : 			SinCos( angle, &sy, &cy );

	lea	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 709  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 710  : 			SinCos( angle, &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 711  : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 712  : 			SinCos( angle, &sr, &cr );

	lea	ecx, DWORD PTR _cr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sr$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 713  : 
; 714  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax], ecx

; 715  : 			mat[1][0] = (sr*sp*cy+cr*-sy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _cr$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax], edx

; 716  : 			mat[2][0] = (cr*sp*cy+-sr*-sy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR [eax], ecx

; 717  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 718  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+4], edx

; 719  : 			mat[1][1] = (sr*sp*sy+cr*cy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 720  : 			mat[2][1] = (cr*sp*sy+-sr*cy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax+4], edx

; 721  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 722  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 723  : 			mat[1][2] = (sr*cp) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -64+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+8], edx

; 724  : 			mat[2][2] = (cr*cp) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 725  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 726  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 727  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 728  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 729  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 731  : 		else if( angles[PITCH] )

	jmp	$L25878
$L25873:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25875

; 733  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 734  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 735  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 736  : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 737  : 
; 738  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -72+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -72+[ebp]
	mov	DWORD PTR [eax], edx

; 739  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -76+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -76+[ebp]
	mov	DWORD PTR [eax], ecx

; 740  : 			mat[2][0] = (sp*cy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -80+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -80+[ebp]
	mov	DWORD PTR [eax], edx

; 741  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 742  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -84+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -84+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 743  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -88+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -88+[ebp]
	mov	DWORD PTR [eax+4], edx

; 744  : 			mat[2][1] = (sp*sy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -92+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -92+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 745  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 746  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -96+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -96+[ebp]
	mov	DWORD PTR [eax+8], edx

; 747  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 748  : 			mat[2][2] = (cp) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -100+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -100+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 749  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 750  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 751  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 752  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 753  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 755  : 		else if( angles[YAW] )

	jmp	$L25878
$L25875:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25877

; 757  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 758  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 759  : 
; 760  : 			mat[0][0] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -104+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -104+[ebp]
	mov	DWORD PTR [eax], edx

; 761  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -108+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -108+[ebp]
	mov	DWORD PTR [eax], ecx

; 762  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 763  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 764  : 			mat[0][1] = (sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -112+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -112+[ebp]
	mov	DWORD PTR [eax+4], edx

; 765  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -116+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -116+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 766  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 767  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 768  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 769  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 770  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], edx

; 771  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 772  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 773  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 774  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 775  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 777  : 		else

	jmp	$L25878
$L25877:

; 779  : 			mat[0][0] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax], ecx

; 780  : 			mat[1][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 781  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 782  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 783  : 			mat[0][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 784  : 			mat[1][1] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+4], edx

; 785  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 786  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 787  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 788  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 789  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 790  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 791  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 792  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 793  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 794  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H
$L25878:

; 796  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0matrix4x4@@QAE@ABVVector@@0M@Z ENDP			; matrix4x4::matrix4x4
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT
_angle$ = 8
_sine$ = 12
_cosine$ = 16
?SinCos@@YAXMPAM0@Z PROC NEAR				; SinCos, COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 37   : 	__asm
; 38   : 	{
; 39   : 		push	ecx

	push	ecx

; 40   : 		fld	dword ptr angle

	fld	DWORD PTR _angle$[ebp]

; 41   : 		fsincos

	fsincos

; 42   : 		mov	ecx, dword ptr[cosine]

	mov	ecx, DWORD PTR _cosine$[ebp]

; 43   : 		fstp      dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 44   : 		mov 	ecx, dword ptr[sine]

	mov	ecx, DWORD PTR _sine$[ebp]

; 45   : 		fstp	dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 46   : 		pop	ecx

	pop	ecx

; 47   : 	}
; 48   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SinCos@@YAXMPAM0@Z ENDP				; SinCos
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QBEPBMXZ PROC NEAR				; Vector::operator float const *, COMDAT

; 229  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector4D@@QAE@XZ PROC NEAR				; Vector4D::Vector4D, COMDAT

; 311  : 	inline Vector4D( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector4D@@QAE@XZ ENDP				; Vector4D::Vector4D
_TEXT	ENDS
PUBLIC	?Count@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Count
;	COMDAT ?SpeculativelyCheckRotPush@CPhysicsPushedEntities@@MAE_NABURotatingPushMove_t@1@PAVCBaseEntity@@@Z
_TEXT	SEGMENT
_rotPushMove$ = 8
_pRoot$ = 12
_this$ = -4
_vecAbsPush$ = -16
_i$ = -20
?SpeculativelyCheckRotPush@CPhysicsPushedEntities@@MAE_NABURotatingPushMove_t@1@PAVCBaseEntity@@@Z PROC NEAR ; CPhysicsPushedEntities::SpeculativelyCheckRotPush, COMDAT

; 615  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 616  : 	Vector vecAbsPush;

	lea	ecx, DWORD PTR _vecAbsPush$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 617  : 	m_nBlocker = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], -1

; 618  : 
; 619  : 	for( int i = m_rgMoved.Count(); --i >= 0; )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Count@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Count
	mov	DWORD PTR _i$[ebp], eax
$L39510:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L39511

; 621  : 		CalcRotationalPushDirection( m_rgMoved[i].m_pEntity, rotPushMove, vecAbsPush, pRoot );

	mov	edx, DWORD PTR _pRoot$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecAbsPush$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rotPushMove$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcRotationalPushDirection@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@ABURotatingPushMove_t@1@AAVVector@@0@Z ; CPhysicsPushedEntities::CalcRotationalPushDirection

; 622  : 
; 623  : 		if( !SpeculativelyCheckPush( m_rgMoved[i], vecAbsPush, true ))

	push	1
	lea	ecx, DWORD PTR _vecAbsPush$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SpeculativelyCheckPush@CPhysicsPushedEntities@@IAE_NAAUPhysicsPushedInfo_t@1@ABVVector@@_N@Z ; CPhysicsPushedEntities::SpeculativelyCheckPush
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39512

; 625  : 			m_nBlocker = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 626  : 			return false;

	xor	al, al
	jmp	SHORT $L39506
$L39512:

; 628  : 	}

	jmp	SHORT $L39510
$L39511:

; 629  : 	return true;

	mov	al, 1
$L39506:

; 630  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SpeculativelyCheckRotPush@CPhysicsPushedEntities@@MAE_NABURotatingPushMove_t@1@PAVCBaseEntity@@@Z ENDP ; CPhysicsPushedEntities::SpeculativelyCheckRotPush
_TEXT	ENDS
;	COMDAT ?SpeculativelyCheckLinearPush@CPhysicsPushedEntities@@MAE_NABVVector@@@Z
_TEXT	SEGMENT
_vecAbsPush$ = 8
_this$ = -4
_i$ = -8
?SpeculativelyCheckLinearPush@CPhysicsPushedEntities@@MAE_NABVVector@@@Z PROC NEAR ; CPhysicsPushedEntities::SpeculativelyCheckLinearPush, COMDAT

; 636  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 637  : 	m_nBlocker = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], -1

; 638  : 
; 639  : 	for( int i = m_rgMoved.Count(); --i >= 0; )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Count@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Count
	mov	DWORD PTR _i$[ebp], eax
$L39519:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L39520

; 641  : 		if( !SpeculativelyCheckPush( m_rgMoved[i], vecAbsPush, false ))

	push	0
	mov	edx, DWORD PTR _vecAbsPush$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SpeculativelyCheckPush@CPhysicsPushedEntities@@IAE_NAAUPhysicsPushedInfo_t@1@ABVVector@@_N@Z ; CPhysicsPushedEntities::SpeculativelyCheckPush
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39521

; 643  : 			m_nBlocker = i;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+44], edx

; 644  : 			return false;

	xor	al, al
	jmp	SHORT $L39516
$L39521:

; 646  : 	}

	jmp	SHORT $L39519
$L39520:

; 647  : 	return true;

	mov	al, 1
$L39516:

; 648  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SpeculativelyCheckLinearPush@CPhysicsPushedEntities@@MAE_NABVVector@@@Z ENDP ; CPhysicsPushedEntities::SpeculativelyCheckLinearPush
_TEXT	ENDS
PUBLIC	?FinishPushers@CPhysicsPushedEntities@@IAEXXZ	; CPhysicsPushedEntities::FinishPushers
;	COMDAT ?FinishPushers@CPhysicsPushedEntities@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
_info$39529 = -12
?FinishPushers@CPhysicsPushedEntities@@IAEXXZ PROC NEAR	; CPhysicsPushedEntities::FinishPushers, COMDAT

; 654  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 655  : 	// We succeeded! Now that we know the final location of all entities,
; 656  : 	// touch triggers + update physics objects + do other fixup
; 657  : 	for( int i = m_rgPusher.Count(); --i >= 0; )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Count@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Count
	mov	DWORD PTR _i$[ebp], eax
$L39527:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L39528

; 659  : 		PhysicsPusherInfo_t &info = m_rgPusher[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
	mov	DWORD PTR _info$39529[ebp], eax

; 660  : 
; 661  : 		// cause touch functions to be called
; 662  : 		info.m_pEntity->RelinkEntity( TRUE, &info.m_vecStartAbsOrigin );

	push	0
	mov	edx, DWORD PTR _info$39529[ebp]
	add	edx, 4
	push	edx
	push	1
	mov	eax, DWORD PTR _info$39529[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 663  : 
; 664  : 		// kinematic pushers that linked with parent system
; 665  : 		if( info.m_pEntity->m_iActorType == ACTOR_KINEMATIC )

	mov	ecx, DWORD PTR _info$39529[ebp]
	mov	edx, DWORD PTR [ecx]
	xor	eax, eax
	mov	al, BYTE PTR [edx+1604]
	cmp	eax, 2
	jne	SHORT $L39530

; 667  : 			WorldPhysic->MoveKinematic( info.m_pEntity );

	mov	ecx, DWORD PTR _info$39529[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+156]
$L39530:

; 669  : 	}

	jmp	SHORT $L39527
$L39528:

; 670  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FinishPushers@CPhysicsPushedEntities@@IAEXXZ ENDP	; CPhysicsPushedEntities::FinishPushers
_TEXT	ENDS
EXTRN	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsAngles
EXTRN	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsAngles
;	COMDAT ?FinishRotPushedEntity@CPhysicsPushedEntities@@MAEXPAVCBaseEntity@@ABURotatingPushMove_t@1@@Z
_TEXT	SEGMENT
_pPushedEntity$ = 8
_rotPushMove$ = 12
_this$ = -4
_angles$ = -16
?FinishRotPushedEntity@CPhysicsPushedEntities@@MAEXPAVCBaseEntity@@ABURotatingPushMove_t@1@@Z PROC NEAR ; CPhysicsPushedEntities::FinishRotPushedEntity, COMDAT

; 676  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 	// impart angular velocity of push onto pushed objects
; 678  : 	if( pPushedEntity->IsNetClient( ))

	mov	eax, DWORD PTR _pPushedEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pPushedEntity$[ebp]
	call	DWORD PTR [edx+228]
	test	eax, eax
	je	SHORT $L39537

; 680  : 		if( rotPushMove.amove[YAW] != 0.0f )

	mov	ecx, DWORD PTR _rotPushMove$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39537

; 682  : 			pPushedEntity->pev->avelocity[YAW] += rotPushMove.amove[YAW];

	mov	eax, DWORD PTR _pPushedEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 4
	mov	DWORD PTR -20+[ebp], eax
	mov	ecx, DWORD PTR _rotPushMove$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR -20+[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [eax+4]
	mov	edx, DWORD PTR -20+[ebp]
	fstp	DWORD PTR [edx]

; 683  : 			SetBits( pPushedEntity->pev->fixangle, 2 );

	mov	eax, DWORD PTR _pPushedEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+160]
	or	edx, 2
	mov	eax, DWORD PTR _pPushedEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+160], edx
$L39537:

; 686  : 
; 687  : 	Vector angles = pPushedEntity->GetAbsAngles();

	mov	ecx, DWORD PTR _pPushedEntity$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 688  : 
; 689  : 	// update goal if monster try turning on the rotational platform
; 690  : 	if( FBitSet( pPushedEntity->pev->flags, FL_MONSTER ))

	mov	edx, DWORD PTR _pPushedEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 32					; 00000020H
	test	ecx, ecx
	je	SHORT $L39539

; 691  : 		pPushedEntity->pev->ideal_yaw += rotPushMove.amove[YAW];

	mov	edx, DWORD PTR _pPushedEntity$[ebp]
	mov	esi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _rotPushMove$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [esi+172]
	fadd	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _pPushedEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+172]
$L39539:

; 692  : 		
; 693  : 	// only rotate YAW with pushing.
; 694  : 	angles.y += rotPushMove.amove.y;

	mov	edx, DWORD PTR _rotPushMove$[ebp]
	fld	DWORD PTR _angles$[ebp+4]
	fadd	DWORD PTR [edx+16]
	fstp	DWORD PTR _angles$[ebp+4]

; 695  : 	pPushedEntity->SetAbsAngles( angles );

	lea	eax, DWORD PTR _angles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPushedEntity$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 696  : 
; 697  : 	// keep gait yaw is actual
; 698  : 	if( pPushedEntity->IsPlayer( ) && rotPushMove.amove.y != 0.0f )

	mov	ecx, DWORD PTR _pPushedEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pPushedEntity$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L39540
	mov	eax, DWORD PTR _rotPushMove$[ebp]
	fld	DWORD PTR [eax+16]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39540

; 699  : 		pPushedEntity->m_flGaitYaw = pPushedEntity->pev->angles[YAW];

	mov	ecx, DWORD PTR _pPushedEntity$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 80					; 00000050H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _pPushedEntity$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+48], eax
$L39540:

; 700  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FinishRotPushedEntity@CPhysicsPushedEntities@@MAEXPAVCBaseEntity@@ABURotatingPushMove_t@1@@Z ENDP ; CPhysicsPushedEntities::FinishRotPushedEntity
_TEXT	ENDS
PUBLIC	?FinishPush@CPhysicsPushedEntities@@IAEX_NPBURotatingPushMove_t@1@@Z ; CPhysicsPushedEntities::FinishPush
;	COMDAT ?FinishPush@CPhysicsPushedEntities@@IAEX_NPBURotatingPushMove_t@1@@Z
_TEXT	SEGMENT
_bIsRotPush$ = 8
_pRotPushMove$ = 12
_this$ = -4
_i$ = -8
_info$39550 = -12
_pPushedEntity$39551 = -16
?FinishPush@CPhysicsPushedEntities@@IAEX_NPBURotatingPushMove_t@1@@Z PROC NEAR ; CPhysicsPushedEntities::FinishPush, COMDAT

; 706  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 707  : 	FinishPushers();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FinishPushers@CPhysicsPushedEntities@@IAEXXZ ; CPhysicsPushedEntities::FinishPushers

; 708  : 
; 709  : 	for( int i = m_rgMoved.Count(); --i >= 0; )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Count@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Count
	mov	DWORD PTR _i$[ebp], eax
$L39548:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jl	$L39549

; 711  : 		PhysicsPushedInfo_t &info = m_rgMoved[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::operator[]
	mov	DWORD PTR _info$39550[ebp], eax

; 712  : 		CBaseEntity *pPushedEntity = info.m_pEntity;

	mov	edx, DWORD PTR _info$39550[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pPushedEntity$39551[ebp], eax

; 713  : 
; 714  : 		// cause touch functions to be called
; 715  : 		info.m_pEntity->RelinkEntity( TRUE, &info.m_vecStartAbsOrigin );

	push	0
	mov	ecx, DWORD PTR _info$39550[ebp]
	add	ecx, 4
	push	ecx
	push	1
	mov	edx, DWORD PTR _info$39550[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 716  : 		info.m_pEntity->m_iFlags |= MF_GROUNDMOVE;

	mov	eax, DWORD PTR _info$39550[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 4
	mov	eax, DWORD PTR _info$39550[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+24], edx

; 717  : 
; 718  : 		// register physics impacts...
; 719  : 		if( info.m_trace.pHit )

	mov	edx, DWORD PTR _info$39550[ebp]
	cmp	DWORD PTR [edx+64], 0
	je	SHORT $L39552

; 721  : 			SV_Impact( pPushedEntity, NULL, &info.m_trace );

	mov	eax, DWORD PTR _info$39550[ebp]
	add	eax, 16					; 00000010H
	push	eax
	push	0
	mov	ecx, DWORD PTR _pPushedEntity$39551[ebp]
	push	ecx
	call	?SV_Impact@@YAXPAVCBaseEntity@@0PAUgametrace_s@@@Z ; SV_Impact
	add	esp, 12					; 0000000cH
$L39552:

; 723  : 
; 724  : 		if( bIsRotPush )

	mov	edx, DWORD PTR _bIsRotPush$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L39553

; 726  : 			FinishRotPushedEntity( pPushedEntity, *pRotPushMove );

	mov	eax, DWORD PTR _pRotPushMove$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPushedEntity$39551[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+8]
$L39553:

; 728  : 
; 729  : 		if( info.m_pEntity->m_iActorType == ACTOR_CHARACTER )

	mov	ecx, DWORD PTR _info$39550[ebp]
	mov	edx, DWORD PTR [ecx]
	xor	eax, eax
	mov	al, BYTE PTR [edx+1604]
	cmp	eax, 3
	jne	SHORT $L39554

; 731  : 			// NPC and player update shadow
; 732  : 			WorldPhysic->MoveCharacter( info.m_pEntity );

	mov	ecx, DWORD PTR _info$39550[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+152]
$L39554:

; 734  : 	}

	jmp	$L39548
$L39549:

; 735  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FinishPush@CPhysicsPushedEntities@@IAEX_NPBURotatingPushMove_t@1@@Z ENDP ; CPhysicsPushedEntities::FinishPush
_TEXT	ENDS
PUBLIC	?BeginPush@CPhysicsPushedEntities@@QAEXPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::BeginPush
PUBLIC	?RemoveAll@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::RemoveAll
PUBLIC	?RemoveAll@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::RemoveAll
;	COMDAT ?BeginPush@CPhysicsPushedEntities@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
?BeginPush@CPhysicsPushedEntities@@QAEXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicsPushedEntities::BeginPush, COMDAT

; 739  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 740  : 	m_rgMoved.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?RemoveAll@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::RemoveAll

; 741  : 	m_rgPusher.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?RemoveAll@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::RemoveAll

; 742  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?BeginPush@CPhysicsPushedEntities@@QAEXPAVCBaseEntity@@@Z ENDP ; CPhysicsPushedEntities::BeginPush
_TEXT	ENDS
PUBLIC	?RegisterBlockage@CPhysicsPushedEntities@@IAEPAVCBaseEntity@@XZ ; CPhysicsPushedEntities::RegisterBlockage
PUBLIC	?__LINE__Var@?1??RegisterBlockage@CPhysicsPushedEntities@@IAEPAVCBaseEntity@@XZ@4FA ; `CPhysicsPushedEntities::RegisterBlockage'::`2'::__LINE__Var
PUBLIC	??_C@_0BP@OAP@z?3?2xashxtsrc?2server?2physic?4cpp?$AA@ ; `string'
PUBLIC	??_C@_0BA@LAPH@m_nBlocker?5?$DO?$DN?50?$AA@	; `string'
EXTRN	?DBG_AssertFunction@@YAXHPBD0H0@Z:NEAR		; DBG_AssertFunction
;	COMDAT ?__LINE__Var@?1??RegisterBlockage@CPhysicsPushedEntities@@IAEPAVCBaseEntity@@XZ@4FA
; File z:\xashxtsrc\server\physic.cpp
_DATA	SEGMENT
?__LINE__Var@?1??RegisterBlockage@CPhysicsPushedEntities@@IAEPAVCBaseEntity@@XZ@4FA DW 02ecH ; `CPhysicsPushedEntities::RegisterBlockage'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BP@OAP@z?3?2xashxtsrc?2server?2physic?4cpp?$AA@
CONST	SEGMENT
??_C@_0BP@OAP@z?3?2xashxtsrc?2server?2physic?4cpp?$AA@ DB 'z:\xashxtsrc\s'
	DB	'erver\physic.cpp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LAPH@m_nBlocker?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BA@LAPH@m_nBlocker?5?$DO?$DN?50?$AA@ DB 'm_nBlocker >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ?RegisterBlockage@CPhysicsPushedEntities@@IAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
_info$ = -8
?RegisterBlockage@CPhysicsPushedEntities@@IAEPAVCBaseEntity@@XZ PROC NEAR ; CPhysicsPushedEntities::RegisterBlockage, COMDAT

; 748  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 749  : 	ASSERT( m_nBlocker >= 0 );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??RegisterBlockage@CPhysicsPushedEntities@@IAEPAVCBaseEntity@@XZ@4FA ; `CPhysicsPushedEntities::RegisterBlockage'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0BP@OAP@z?3?2xashxtsrc?2server?2physic?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@LAPH@m_nBlocker?5?$DO?$DN?50?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+44], 0
	setge	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 750  : 
; 751  : 	// generate a PhysicsImpact against the blocker...
; 752  : 	PhysicsPushedInfo_t &info = m_rgMoved[m_nBlocker];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::operator[]
	mov	DWORD PTR _info$[ebp], eax

; 753  : 
; 754  : 	if( info.m_trace.pHit )

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+64], 0
	je	SHORT $L39567

; 756  : 		SV_Impact( info.m_pEntity, NULL, &info.m_trace );

	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	push	0
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?SV_Impact@@YAXPAVCBaseEntity@@0PAUgametrace_s@@@Z ; SV_Impact
	add	esp, 12					; 0000000cH
$L39567:

; 758  : 
; 759  : 	// this is the dude 
; 760  : 	return info.m_pEntity;

	mov	eax, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [eax]

; 761  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RegisterBlockage@CPhysicsPushedEntities@@IAEPAVCBaseEntity@@XZ ENDP ; CPhysicsPushedEntities::RegisterBlockage
_TEXT	ENDS
PUBLIC	?RestoreEntities@CPhysicsPushedEntities@@IAEXXZ	; CPhysicsPushedEntities::RestoreEntities
;	COMDAT ?RestoreEntities@CPhysicsPushedEntities@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RestoreEntities@CPhysicsPushedEntities@@IAEXXZ PROC NEAR ; CPhysicsPushedEntities::RestoreEntities, COMDAT

; 769  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 770  : 	// reset all of the pushed entities to get them back into place also
; 771  : 	for( int i = m_rgMoved.Count(); --i >= 0; )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Count@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Count
	mov	DWORD PTR _i$[ebp], eax
$L39574:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L39575

; 773  : 		m_rgMoved[i].m_pEntity->SetAbsOrigin( m_rgMoved[i].m_vecStartAbsOrigin );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::operator[]
	add	eax, 4
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 774  : 	}

	jmp	SHORT $L39574
$L39575:

; 775  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RestoreEntities@CPhysicsPushedEntities@@IAEXXZ ENDP	; CPhysicsPushedEntities::RestoreEntities
_TEXT	ENDS
PUBLIC	?IsStandingOnPusher@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::IsStandingOnPusher
;	COMDAT ?IsStandingOnPusher@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pCheck$ = 8
_this$ = -4
_pGroundEnt$ = -8
_i$39583 = -12
?IsStandingOnPusher@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z PROC NEAR ; CPhysicsPushedEntities::IsStandingOnPusher, COMDAT

; 778  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 779  : 	CBaseEntity *pGroundEnt = pCheck->GetGroundEntity();

	mov	ecx, DWORD PTR _pCheck$[ebp]
	call	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ; CBaseEntity::GetGroundEntity
	mov	DWORD PTR _pGroundEnt$[ebp], eax

; 780  : 
; 781  : 	if( pCheck->pev->flags & FL_ONGROUND || pGroundEnt )

	mov	eax, DWORD PTR _pCheck$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	jne	SHORT $L39582
	cmp	DWORD PTR _pGroundEnt$[ebp], 0
	je	SHORT $L39586
$L39582:

; 783  : 		for( int i = m_rgPusher.Count(); --i >= 0; )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Count@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Count
	mov	DWORD PTR _i$39583[ebp], eax
$L39585:
	mov	eax, DWORD PTR _i$39583[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$39583[ebp], eax
	cmp	DWORD PTR _i$39583[ebp], 0
	jl	SHORT $L39586

; 785  : 			if( m_rgPusher[i].m_pEntity == pGroundEnt )

	mov	ecx, DWORD PTR _i$39583[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR _pGroundEnt$[ebp]
	jne	SHORT $L39587

; 786  : 				return true;

	mov	al, 1
	jmp	SHORT $L39579
$L39587:

; 787  : 		}

	jmp	SHORT $L39585
$L39586:

; 789  : 
; 790  : 	return false;

	xor	al, al
$L39579:

; 791  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsStandingOnPusher@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z ENDP ; CPhysicsPushedEntities::IsStandingOnPusher
_TEXT	ENDS
PUBLIC	?SV_TestEntityPosition@@YAHPAVCBaseEntity@@0@Z	; SV_TestEntityPosition
PUBLIC	?AddPushedEntityToBlockingList@CPhysicsPushedEntities@@QAEXPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::AddPushedEntityToBlockingList
;	COMDAT ?AddPushedEntityToBlockingList@CPhysicsPushedEntities@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pPushed$ = 8
_this$ = -4
_pRootHighestParent$ = -8
_pCheckHighestParent$ = -12
?AddPushedEntityToBlockingList@CPhysicsPushedEntities@@QAEXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicsPushedEntities::AddPushedEntityToBlockingList, COMDAT

; 794  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 795  : 	if( !pPushed ) return;

	cmp	DWORD PTR _pPushed$[ebp], 0
	jne	SHORT $L39592
	jmp	$L39591
$L39592:

; 796  : 
; 797  : 	if( pPushed->m_iPushEnumCount == s_nEnumCount )

	mov	eax, DWORD PTR _pPushed$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+56]
	cmp	edx, DWORD PTR [ecx+52]
	jne	SHORT $L39593

; 798  : 		return;	// already added

	jmp	$L39591
$L39593:

; 799  : 
; 800  : 	if( pPushed->pev->solid == SOLID_NOT )

	mov	eax, DWORD PTR _pPushed$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+268], 0
	jne	SHORT $L39594

; 801  : 		return;

	jmp	$L39591
$L39594:

; 805  : 	{

	mov	edx, DWORD PTR _pPushed$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+264]
	mov	DWORD PTR -16+[ebp], ecx
	cmp	DWORD PTR -16+[ebp], 14			; 0000000eH
	ja	SHORT $L39596
	mov	eax, DWORD PTR -16+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L41697[eax]
	jmp	DWORD PTR $L41698[edx*4]
$L39599:

; 806  : 	case MOVETYPE_NONE:
; 807  : 	case MOVETYPE_PUSH:
; 808  : 	case MOVETYPE_FOLLOW:
; 809  : 	case MOVETYPE_NOCLIP:
; 810  : 	case MOVETYPE_COMPOUND:
; 811  : 		return;

	jmp	SHORT $L39591
$L39596:

; 813  : 
; 814  : 	// All elements are part of the same hierarchy, so they all have
; 815  : 	// the same root, so it doesn't matter which one we grab
; 816  : 	CBaseEntity *pRootHighestParent = m_rgPusher[0].m_pEntity->GetRootParent();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?GetRootParent@CBaseEntity@@QAEPAV1@XZ	; CBaseEntity::GetRootParent
	mov	DWORD PTR _pRootHighestParent$[ebp], eax

; 817  : 	CBaseEntity *pCheckHighestParent = pPushed->GetRootParent();

	mov	ecx, DWORD PTR _pPushed$[ebp]
	call	?GetRootParent@CBaseEntity@@QAEPAV1@XZ	; CBaseEntity::GetRootParent
	mov	DWORD PTR _pCheckHighestParent$[ebp], eax

; 818  : 
; 819  : 	if( pCheckHighestParent == pRootHighestParent )

	mov	ecx, DWORD PTR _pCheckHighestParent$[ebp]
	cmp	ecx, DWORD PTR _pRootHighestParent$[ebp]
	jne	SHORT $L39603

; 821  : 		// g-cont. attached pushables can be block hierarchy!
; 822  : 		if( pPushed->pev->movetype != MOVETYPE_PUSHSTEP )

	mov	edx, DWORD PTR _pPushed$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+264], 13			; 0000000dH
	je	SHORT $L39603

; 823  : 			return;

	jmp	SHORT $L39591
$L39603:

; 825  : 
; 826  : 	// If we're standing on the pusher or any rigidly attached child
; 827  : 	// of the pusher, we don't need to bother checking for interpenetration
; 828  : 	if( !IsStandingOnPusher( pPushed ))

	mov	ecx, DWORD PTR _pPushed$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsStandingOnPusher@CPhysicsPushedEntities@@IAE_NPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::IsStandingOnPusher
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39605

; 830  : 		// Our surrounding boxes are touching. But we may well not be colliding....
; 831  : 		// see if the ent's bbox is inside the pusher's final position
; 832  : 		if( !SV_TestEntityPosition( pPushed, NULL ))

	push	0
	mov	edx, DWORD PTR _pPushed$[ebp]
	push	edx
	call	?SV_TestEntityPosition@@YAHPAVCBaseEntity@@0@Z ; SV_TestEntityPosition
	add	esp, 8
	test	eax, eax
	jne	SHORT $L39605

; 833  : 			return;

	jmp	SHORT $L39591
$L39605:

; 835  : 
; 836  : 	pCheckHighestParent->m_iPushEnumCount = s_nEnumCount;

	mov	eax, DWORD PTR _pCheckHighestParent$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+56], edx

; 837  : 
; 838  : 	// NOTE: This is pretty tricky here. If a rigidly attached child comes into
; 839  : 	// contact with a pusher, we *cannot* push the child. Instead, we must push
; 840  : 	// the highest parent of that child.
; 841  : 	AddEntity( pCheckHighestParent );

	mov	eax, DWORD PTR _pCheckHighestParent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::AddEntity
$L39591:

; 842  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L41698:
	DD	$L39599
	DD	$L39596
$L41697:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
?AddPushedEntityToBlockingList@CPhysicsPushedEntities@@QAEXPAVCBaseEntity@@@Z ENDP ; CPhysicsPushedEntities::AddPushedEntityToBlockingList
_TEXT	ENDS
PUBLIC	?GenerateBlockingEntityList@CPhysicsPushedEntities@@IAEXXZ ; CPhysicsPushedEntities::GenerateBlockingEntityList
EXTRN	?UTIL_AreaNode@@YAXVVector@@0HP6AXPAVCBaseEntity@@@Z@Z:NEAR ; UTIL_AreaNode
EXTRN	?WorldSpaceAABB@CBaseEntity@@QBEXAAVVector@@0@Z:NEAR ; CBaseEntity::WorldSpaceAABB
;	COMDAT ?GenerateBlockingEntityList@CPhysicsPushedEntities@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
_pPusher$39613 = -12
_vecAbsMins$39615 = -24
_vecAbsMaxs$39616 = -36
?GenerateBlockingEntityList@CPhysicsPushedEntities@@IAEXXZ PROC NEAR ; CPhysicsPushedEntities::GenerateBlockingEntityList, COMDAT

; 848  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 849  : 	m_rgMoved.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?RemoveAll@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::RemoveAll

; 850  : 	s_nEnumCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 851  : 
; 852  : 	for( int i = m_rgPusher.Count(); --i >= 0;  )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Count@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Count
	mov	DWORD PTR _i$[ebp], eax
$L39611:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jl	$L39612

; 854  : 		CBaseEntity *pPusher = m_rgPusher[i].m_pEntity;

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _pPusher$39613[ebp], edx

; 855  : 
; 856  : 		// don't bother if the pusher isn't solid
; 857  : 		if( pPusher->pev->solid == SOLID_NOT && !FBitSet( pPusher->m_iFlags, MF_LADDER ))

	mov	eax, DWORD PTR _pPusher$39613[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+268], 0
	jne	SHORT $L39614
	mov	edx, DWORD PTR _pPusher$39613[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 8
	test	eax, eax
	jne	SHORT $L39614

; 858  : 			continue;

	jmp	SHORT $L39611
$L39614:

; 859  : 
; 860  : 		Vector vecAbsMins, vecAbsMaxs;

	lea	ecx, DWORD PTR _vecAbsMins$39615[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _vecAbsMaxs$39616[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 861  : 		pPusher->WorldSpaceAABB( vecAbsMins, vecAbsMaxs );

	lea	ecx, DWORD PTR _vecAbsMaxs$39616[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecAbsMins$39615[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPusher$39613[ebp]
	call	?WorldSpaceAABB@CBaseEntity@@QBEXAAVVector@@0@Z ; CBaseEntity::WorldSpaceAABB

; 862  : 
; 863  : 		UTIL_AreaNode( vecAbsMins, vecAbsMaxs, AREA_SOLID, AddEntityToBlockingList );

	push	OFFSET FLAT:?AddEntityToBlockingList@@YAXPAVCBaseEntity@@@Z ; AddEntityToBlockingList
	push	0
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecAbsMaxs$39616[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecAbsMins$39615[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?UTIL_AreaNode@@YAXVVector@@0HP6AXPAVCBaseEntity@@@Z@Z ; UTIL_AreaNode
	add	esp, 32					; 00000020H

; 864  : 		UTIL_AreaNode( vecAbsMins, vecAbsMaxs, AREA_TRIGGERS, AddEntityToBlockingList );

	push	OFFSET FLAT:?AddEntityToBlockingList@@YAXPAVCBaseEntity@@@Z ; AddEntityToBlockingList
	push	1
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecAbsMaxs$39616[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecAbsMins$39615[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?UTIL_AreaNode@@YAXVVector@@0HP6AXPAVCBaseEntity@@@Z@Z ; UTIL_AreaNode
	add	esp, 32					; 00000020H

; 865  : 	}

	jmp	$L39611
$L39612:

; 866  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GenerateBlockingEntityList@CPhysicsPushedEntities@@IAEXXZ ENDP ; CPhysicsPushedEntities::GenerateBlockingEntityList
_TEXT	ENDS
;	COMDAT ?AddEntityToBlockingList@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pPushed$ = 8
?AddEntityToBlockingList@@YAXPAVCBaseEntity@@@Z PROC NEAR ; AddEntityToBlockingList, COMDAT

; 336  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 337  : 	g_pPushedEntities->AddPushedEntityToBlockingList( pPushed );

	mov	eax, DWORD PTR _pPushed$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?g_pPushedEntities@@3PAVCPhysicsPushedEntities@@A ; g_pPushedEntities
	call	?AddPushedEntityToBlockingList@CPhysicsPushedEntities@@QAEXPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::AddPushedEntityToBlockingList

; 338  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddEntityToBlockingList@@YAXPAVCBaseEntity@@@Z ENDP	; AddEntityToBlockingList
_TEXT	ENDS
PUBLIC	?GenerateBlockingEntityListAddBox@CPhysicsPushedEntities@@IAEXABVVector@@@Z ; CPhysicsPushedEntities::GenerateBlockingEntityListAddBox
;	COMDAT ?GenerateBlockingEntityListAddBox@CPhysicsPushedEntities@@IAEXABVVector@@@Z
_TEXT	SEGMENT
_vecMoved$ = 8
_this$ = -4
_i$ = -8
_pPusher$39629 = -12
_vecAbsMins$39631 = -24
_vecAbsMaxs$39632 = -36
_iAxis$39633 = -40
?GenerateBlockingEntityListAddBox@CPhysicsPushedEntities@@IAEXABVVector@@@Z PROC NEAR ; CPhysicsPushedEntities::GenerateBlockingEntityListAddBox, COMDAT

; 872  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 873  : 	m_rgMoved.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?RemoveAll@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::RemoveAll

; 874  : 	s_nEnumCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 875  : 
; 876  : 	for( int i = m_rgPusher.Count(); --i >= 0;  )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Count@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Count
	mov	DWORD PTR _i$[ebp], eax
$L39627:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jl	$L39628

; 878  : 		CBaseEntity *pPusher = m_rgPusher[i].m_pEntity;

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _pPusher$39629[ebp], edx

; 879  : 
; 880  : 		// don't bother if the pusher isn't solid
; 881  : 		if( pPusher->pev->solid == SOLID_NOT && !FBitSet( pPusher->m_iFlags, MF_LADDER ))

	mov	eax, DWORD PTR _pPusher$39629[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+268], 0
	jne	SHORT $L39630
	mov	edx, DWORD PTR _pPusher$39629[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 8
	test	eax, eax
	jne	SHORT $L39630

; 882  : 			continue;

	jmp	SHORT $L39627
$L39630:

; 883  : 
; 884  : 		Vector vecAbsMins, vecAbsMaxs;

	lea	ecx, DWORD PTR _vecAbsMins$39631[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _vecAbsMaxs$39632[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 885  : 		pPusher->WorldSpaceAABB( vecAbsMins, vecAbsMaxs );

	lea	ecx, DWORD PTR _vecAbsMaxs$39632[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecAbsMins$39631[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPusher$39629[ebp]
	call	?WorldSpaceAABB@CBaseEntity@@QBEXAAVVector@@0@Z ; CBaseEntity::WorldSpaceAABB

; 886  : 
; 887  : 		for( int iAxis = 0; iAxis < 3; iAxis++ )

	mov	DWORD PTR _iAxis$39633[ebp], 0
	jmp	SHORT $L39634
$L39635:
	mov	eax, DWORD PTR _iAxis$39633[ebp]
	add	eax, 1
	mov	DWORD PTR _iAxis$39633[ebp], eax
$L39634:
	cmp	DWORD PTR _iAxis$39633[ebp], 3
	jge	SHORT $L39636

; 889  : 			if( vecMoved[iAxis] >= 0.0f )

	mov	ecx, DWORD PTR _vecMoved$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _iAxis$39633[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39637

; 890  : 				vecAbsMins[iAxis] -= vecMoved[iAxis];

	lea	ecx, DWORD PTR _vecAbsMins$39631[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _iAxis$39633[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR -60+[ebp], eax
	mov	ecx, DWORD PTR _vecMoved$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR -60+[ebp]
	mov	edx, DWORD PTR _iAxis$39633[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR -60+[ebp]
	fstp	DWORD PTR [eax]

; 891  : 			else vecAbsMaxs[iAxis] -= vecMoved[iAxis];

	jmp	SHORT $L39638
$L39637:
	lea	ecx, DWORD PTR _vecAbsMaxs$39632[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _iAxis$39633[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR -64+[ebp], edx
	mov	ecx, DWORD PTR _vecMoved$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR -64+[ebp]
	mov	edx, DWORD PTR _iAxis$39633[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR -64+[ebp]
	fstp	DWORD PTR [eax]
$L39638:

; 892  : 		}

	jmp	SHORT $L39635
$L39636:

; 893  : 
; 894  : 		UTIL_AreaNode( vecAbsMins, vecAbsMaxs, AREA_SOLID, AddEntityToBlockingList );

	push	OFFSET FLAT:?AddEntityToBlockingList@@YAXPAVCBaseEntity@@@Z ; AddEntityToBlockingList
	push	0
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecAbsMaxs$39632[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecAbsMins$39631[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?UTIL_AreaNode@@YAXVVector@@0HP6AXPAVCBaseEntity@@@Z@Z ; UTIL_AreaNode
	add	esp, 32					; 00000020H

; 895  : 		UTIL_AreaNode( vecAbsMins, vecAbsMaxs, AREA_TRIGGERS, AddEntityToBlockingList );

	push	OFFSET FLAT:?AddEntityToBlockingList@@YAXPAVCBaseEntity@@@Z ; AddEntityToBlockingList
	push	1
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecAbsMaxs$39632[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecAbsMins$39631[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?UTIL_AreaNode@@YAXVVector@@0HP6AXPAVCBaseEntity@@@Z@Z ; UTIL_AreaNode
	add	esp, 32					; 00000020H

; 896  : 	}

	jmp	$L39627
$L39628:

; 897  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GenerateBlockingEntityListAddBox@CPhysicsPushedEntities@@IAEXABVVector@@@Z ENDP ; CPhysicsPushedEntities::GenerateBlockingEntityListAddBox
_TEXT	ENDS
PUBLIC	??BEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator CBaseEntity *
PUBLIC	?SetupAllInHierarchy@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::SetupAllInHierarchy
PUBLIC	?AddToTail@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::AddToTail
;	COMDAT ?SetupAllInHierarchy@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pParent$ = 8
_this$ = -4
_i$ = -8
_pChild$ = -12
?SetupAllInHierarchy@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicsPushedEntities::SetupAllInHierarchy, COMDAT

; 903  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 904  : 	if( !pParent ) return;

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L39647
	jmp	$L39646
$L39647:

; 905  : 
; 906  : 	// Make sure to snack the position +before+ relink because applying the
; 907  : 	// rotation (which occurs in relink) will put it at the final location
; 908  : 	// NOTE: The root object at this point is actually at its final position.
; 909  : 	// We'll fix that up later
; 910  : 	int i = m_rgPusher.AddToTail();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?AddToTail@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::AddToTail
	mov	DWORD PTR _i$[ebp], eax

; 911  : 	m_rgPusher[i].m_pEntity = pParent;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
	mov	ecx, DWORD PTR _pParent$[ebp]
	mov	DWORD PTR [eax], ecx

; 912  : 	m_rgPusher[i].m_vecStartAbsOrigin = pParent->GetAbsOrigin();

	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	esi, eax
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
	add	eax, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx

; 913  : 
; 914  : 	for( CBaseEntity *pChild = pParent->m_hChild; pChild != NULL; pChild = pChild->m_hNextChild )

	mov	ecx, DWORD PTR _pParent$[ebp]
	add	ecx, 156				; 0000009cH
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pChild$[ebp], eax
	jmp	SHORT $L39650
$L39651:
	mov	ecx, DWORD PTR _pChild$[ebp]
	add	ecx, 164				; 000000a4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pChild$[ebp], eax
$L39650:
	cmp	DWORD PTR _pChild$[ebp], 0
	je	SHORT $L39652

; 916  : 		SetupAllInHierarchy( pChild );

	mov	edx, DWORD PTR _pChild$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupAllInHierarchy@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::SetupAllInHierarchy

; 917  : 	}

	jmp	SHORT $L39651
$L39652:
$L39646:

; 918  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetupAllInHierarchy@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z ENDP ; CPhysicsPushedEntities::SetupAllInHierarchy
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator CBaseEntity *, COMDAT

; 64   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator CBaseEntity *
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
PUBLIC	?RotateRootEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@MAAURotatingPushMove_t@1@@Z ; CPhysicsPushedEntities::RotateRootEntity
;	COMDAT ?RotateRootEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@MAAURotatingPushMove_t@1@@Z
_TEXT	SEGMENT
_pRoot$ = 8
_movetime$ = 12
_rotation$ = 16
_this$ = -4
$T41721 = -16
?RotateRootEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@MAAURotatingPushMove_t@1@@Z PROC NEAR ; CPhysicsPushedEntities::RotateRootEntity, COMDAT

; 925  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 926  : 	rotation.amove = pRoot->GetLocalAvelocity() * movetime;

	mov	eax, DWORD PTR _movetime$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41721[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pRoot$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	edx, DWORD PTR _rotation$[ebp]
	add	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 927  : 	rotation.origin = pRoot->GetAbsOrigin();

	mov	ecx, DWORD PTR _pRoot$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR _rotation$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 928  : 
; 929  : 	// knowing the initial + ending basis is needed for determining
; 930  : 	// which corner we're pushing 
; 931  : 	rotation.startLocalToWorld = pRoot->EntityToWorldTransform();

	mov	ecx, DWORD PTR _pRoot$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	push	eax
	mov	ecx, DWORD PTR _rotation$[ebp]
	add	ecx, 24					; 00000018H
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 932  : 
; 933  : 	if( pRoot->pev->movetype != MOVETYPE_VEHICLE )

	mov	ecx, DWORD PTR _pRoot$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 16			; 00000010H
	je	SHORT $L39660

; 935  : 		// rotate the pusher to it's final position
; 936  : 		SV_AngularMove( pRoot, movetime, pRoot->pev->friction );

	mov	eax, DWORD PTR _pRoot$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+288]
	push	edx
	mov	eax, DWORD PTR _movetime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRoot$[ebp]
	push	ecx
	call	?SV_AngularMove@@YAXPAVCBaseEntity@@MM@Z ; SV_AngularMove
	add	esp, 12					; 0000000cH
$L39660:

; 938  : 
; 939  : 	// compute the change in absangles
; 940  : 	rotation.endLocalToWorld = pRoot->EntityToWorldTransform();

	mov	ecx, DWORD PTR _pRoot$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	push	eax
	mov	ecx, DWORD PTR _rotation$[ebp]
	add	ecx, 88					; 00000058H
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 941  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?RotateRootEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@MAAURotatingPushMove_t@1@@Z ENDP ; CPhysicsPushedEntities::RotateRootEntity
_TEXT	ENDS
PUBLIC	?PerformRotatePush@CPhysicsPushedEntities@@QAEPAVCBaseEntity@@PAV2@M@Z ; CPhysicsPushedEntities::PerformRotatePush
PUBLIC	??0RotatingPushMove_t@CPhysicsPushedEntities@@QAE@XZ ; CPhysicsPushedEntities::RotatingPushMove_t::RotatingPushMove_t
;	COMDAT ?PerformRotatePush@CPhysicsPushedEntities@@QAEPAVCBaseEntity@@PAV2@M@Z
_TEXT	SEGMENT
_pRoot$ = 8
_movetime$ = 12
_this$ = -4
_angPrevAngles$ = -16
_rotPushMove$ = -168
_pBlocker$39669 = -172
?PerformRotatePush@CPhysicsPushedEntities@@QAEPAVCBaseEntity@@PAV2@M@Z PROC NEAR ; CPhysicsPushedEntities::PerformRotatePush, COMDAT

; 947  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 948  : 	m_bIsUnblockableByPlayer = FBitSet( pRoot->pev->flags, FL_UNBLOCKABLE ) ? true : false;

	mov	eax, DWORD PTR _pRoot$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 268435456				; 10000000H
	test	edx, edx
	setne	al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+48], al

; 949  : 
; 950  : 	// build a list of this entity + all its children because we're going to try to move them all
; 951  : 	// this will also make sure each entity is linked in the appropriate place
; 952  : 	// with correct absboxes
; 953  : 	m_rgPusher.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?RemoveAll@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::RemoveAll

; 954  : 	SetupAllInHierarchy( pRoot );

	mov	edx, DWORD PTR _pRoot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupAllInHierarchy@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::SetupAllInHierarchy

; 955  : 
; 956  : 	// save where we rotated from, in case we're blocked
; 957  : 	Vector angPrevAngles = pRoot->GetLocalAngles();

	mov	ecx, DWORD PTR _pRoot$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	lea	ecx, DWORD PTR _angPrevAngles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 958  : 
; 959  : 	// apply the rotation
; 960  : 	RotatingPushMove_t rotPushMove;

	lea	ecx, DWORD PTR _rotPushMove$[ebp]
	call	??0RotatingPushMove_t@CPhysicsPushedEntities@@QAE@XZ ; CPhysicsPushedEntities::RotatingPushMove_t::RotatingPushMove_t

; 961  : 	RotateRootEntity( pRoot, movetime, rotPushMove );

	lea	eax, DWORD PTR _rotPushMove$[ebp]
	push	eax
	mov	ecx, DWORD PTR _movetime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pRoot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotateRootEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@MAAURotatingPushMove_t@1@@Z ; CPhysicsPushedEntities::RotateRootEntity

; 962  : 
; 963  : 	// next generate a list of all entities that could potentially be intersecting with
; 964  : 	// any of the children in their new locations...
; 965  : 	GenerateBlockingEntityList( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateBlockingEntityList@CPhysicsPushedEntities@@IAEXXZ ; CPhysicsPushedEntities::GenerateBlockingEntityList

; 966  : 
; 967  : 	// now we have a unique list of things that could potentially block our push
; 968  : 	// and need to be pushed out of the way. Lets try to push them all out of the way.
; 969  : 	// if we fail, undo it all
; 970  : 	if( !SpeculativelyCheckRotPush( rotPushMove, pRoot ))

	mov	eax, DWORD PTR _pRoot$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rotPushMove$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39668

; 972  : 		CBaseEntity *pBlocker = RegisterBlockage();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterBlockage@CPhysicsPushedEntities@@IAEPAVCBaseEntity@@XZ ; CPhysicsPushedEntities::RegisterBlockage
	mov	DWORD PTR _pBlocker$39669[ebp], eax

; 973  : 		if( pRoot->pev->movetype != MOVETYPE_VEHICLE )

	mov	ecx, DWORD PTR _pRoot$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 16			; 00000010H
	je	SHORT $L39670

; 974  : 			pRoot->SetLocalAngles( angPrevAngles );

	lea	eax, DWORD PTR _angPrevAngles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRoot$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles
$L39670:

; 975  : 		RestoreEntities( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RestoreEntities@CPhysicsPushedEntities@@IAEXXZ ; CPhysicsPushedEntities::RestoreEntities

; 976  : 		return pBlocker;

	mov	eax, DWORD PTR _pBlocker$39669[ebp]
	jmp	SHORT $L39665
$L39668:

; 978  : 
; 979  : 	FinishPush( true, &rotPushMove );

	lea	ecx, DWORD PTR _rotPushMove$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FinishPush@CPhysicsPushedEntities@@IAEX_NPBURotatingPushMove_t@1@@Z ; CPhysicsPushedEntities::FinishPush

; 980  : 
; 981  : 	return NULL;

	xor	eax, eax
$L39665:

; 982  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?PerformRotatePush@CPhysicsPushedEntities@@QAEPAVCBaseEntity@@PAV2@M@Z ENDP ; CPhysicsPushedEntities::PerformRotatePush
_TEXT	ENDS
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
;	COMDAT ??0RotatingPushMove_t@CPhysicsPushedEntities@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0RotatingPushMove_t@CPhysicsPushedEntities@@QAE@XZ PROC NEAR ; CPhysicsPushedEntities::RotatingPushMove_t::RotatingPushMove_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0RotatingPushMove_t@CPhysicsPushedEntities@@QAE@XZ ENDP ; CPhysicsPushedEntities::RotatingPushMove_t::RotatingPushMove_t
_TEXT	ENDS
PUBLIC	?LinearlyMoveRootEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@MAAVVector@@@Z ; CPhysicsPushedEntities::LinearlyMoveRootEntity
;	COMDAT ?LinearlyMoveRootEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@MAAVVector@@@Z
_TEXT	SEGMENT
_pRoot$ = 8
_movetime$ = 12
_pAbsPushVector$ = 16
_this$ = -4
$T41728 = -16
?LinearlyMoveRootEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@MAAVVector@@@Z PROC NEAR ; CPhysicsPushedEntities::LinearlyMoveRootEntity, COMDAT

; 988  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 989  : 	if( pRoot->pev->movetype != MOVETYPE_VEHICLE )

	mov	eax, DWORD PTR _pRoot$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+264], 16			; 00000010H
	je	SHORT $L39679

; 991  : 		// move the pusher to it's final position
; 992  : 		SV_LinearMove( pRoot, movetime, pRoot->pev->friction );

	mov	edx, DWORD PTR _pRoot$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+288]
	push	ecx
	mov	edx, DWORD PTR _movetime$[ebp]
	push	edx
	mov	eax, DWORD PTR _pRoot$[ebp]
	push	eax
	call	?SV_LinearMove@@YAXPAVCBaseEntity@@MM@Z	; SV_LinearMove
	add	esp, 12					; 0000000cH
$L39679:

; 994  : 
; 995  : 	// Store off the abs push vector
; 996  : 	pAbsPushVector = pRoot->GetAbsVelocity() * movetime;

	mov	ecx, DWORD PTR _movetime$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41728[ebp]
	push	edx
	mov	ecx, DWORD PTR _pRoot$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR _pAbsPushVector$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 997  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?LinearlyMoveRootEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@MAAVVector@@@Z ENDP ; CPhysicsPushedEntities::LinearlyMoveRootEntity
_TEXT	ENDS
PUBLIC	?PerformLinearPush@CPhysicsPushedEntities@@QAEPAVCBaseEntity@@PAV2@M@Z ; CPhysicsPushedEntities::PerformLinearPush
;	COMDAT ?PerformLinearPush@CPhysicsPushedEntities@@QAEPAVCBaseEntity@@PAV2@M@Z
_TEXT	SEGMENT
_pRoot$ = 8
_movetime$ = 12
_this$ = -4
_vecPrevOrigin$ = -16
_vecAbsPush$ = -28
_pBlocker$39689 = -32
?PerformLinearPush@CPhysicsPushedEntities@@QAEPAVCBaseEntity@@PAV2@M@Z PROC NEAR ; CPhysicsPushedEntities::PerformLinearPush, COMDAT

; 1004 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1005 : 	m_bIsUnblockableByPlayer = FBitSet( pRoot->pev->flags, FL_UNBLOCKABLE ) ? true : false;

	mov	eax, DWORD PTR _pRoot$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 268435456				; 10000000H
	test	edx, edx
	setne	al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+48], al

; 1006 : 
; 1007 : 	// build a list of this entity + all its children because we're going to try to move them all
; 1008 : 	// this will also make sure each entity is linked in the appropriate place
; 1009 : 	// with correct absboxes
; 1010 : 	m_rgPusher.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?RemoveAll@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::RemoveAll

; 1011 : 	SetupAllInHierarchy( pRoot );

	mov	edx, DWORD PTR _pRoot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupAllInHierarchy@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::SetupAllInHierarchy

; 1012 : 
; 1013 : 	// save where we started from, in case we're blocked
; 1014 : 	Vector vecPrevOrigin = pRoot->GetAbsOrigin();

	mov	ecx, DWORD PTR _pRoot$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecPrevOrigin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1015 : 
; 1016 : 	// Move the root (and all children) into its new position
; 1017 : 	Vector vecAbsPush;

	lea	ecx, DWORD PTR _vecAbsPush$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1018 : 	LinearlyMoveRootEntity( pRoot, movetime, vecAbsPush );

	lea	eax, DWORD PTR _vecAbsPush$[ebp]
	push	eax
	mov	ecx, DWORD PTR _movetime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pRoot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinearlyMoveRootEntity@CPhysicsPushedEntities@@IAEXPAVCBaseEntity@@MAAVVector@@@Z ; CPhysicsPushedEntities::LinearlyMoveRootEntity

; 1019 : 
; 1020 : 	// Next generate a list of all entities that could potentially be intersecting with
; 1021 : 	// any of the children in their new locations...
; 1022 : 	GenerateBlockingEntityListAddBox( vecAbsPush );

	lea	eax, DWORD PTR _vecAbsPush$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateBlockingEntityListAddBox@CPhysicsPushedEntities@@IAEXABVVector@@@Z ; CPhysicsPushedEntities::GenerateBlockingEntityListAddBox

; 1023 : 
; 1024 : 	// Now we have a unique list of things that could potentially block our push
; 1025 : 	// and need to be pushed out of the way. Lets try to push them all out of the way.
; 1026 : 	// if we fail, undo it all
; 1027 : 	if( !SpeculativelyCheckLinearPush( vecAbsPush ))

	lea	ecx, DWORD PTR _vecAbsPush$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+4]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39688

; 1029 : 		CBaseEntity *pBlocker = RegisterBlockage();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterBlockage@CPhysicsPushedEntities@@IAEPAVCBaseEntity@@XZ ; CPhysicsPushedEntities::RegisterBlockage
	mov	DWORD PTR _pBlocker$39689[ebp], eax

; 1030 : 		if( pRoot->pev->movetype != MOVETYPE_VEHICLE )

	mov	ecx, DWORD PTR _pRoot$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 16			; 00000010H
	je	SHORT $L39690

; 1031 : 			pRoot->SetAbsOrigin( vecPrevOrigin );

	lea	eax, DWORD PTR _vecPrevOrigin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRoot$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin
$L39690:

; 1032 : 		RestoreEntities();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RestoreEntities@CPhysicsPushedEntities@@IAEXXZ ; CPhysicsPushedEntities::RestoreEntities

; 1033 : 		return pBlocker;

	mov	eax, DWORD PTR _pBlocker$39689[ebp]
	jmp	SHORT $L39685
$L39688:

; 1035 : 
; 1036 : 	FinishPush();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FinishPush@CPhysicsPushedEntities@@IAEX_NPBURotatingPushMove_t@1@@Z ; CPhysicsPushedEntities::FinishPush

; 1037 : 
; 1038 : 	return NULL;

	xor	eax, eax
$L39685:

; 1039 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?PerformLinearPush@CPhysicsPushedEntities@@QAEPAVCBaseEntity@@PAV2@M@Z ENDP ; CPhysicsPushedEntities::PerformLinearPush
_TEXT	ENDS
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ	; CBaseEntity::GetBaseVelocity
EXTRN	?VectorRotate@matrix4x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix4x4::VectorRotate
;	COMDAT ?SV_UpdateBaseVelocity@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T41733 = -40
$T41734 = -52
_pEntity$ = 8
_pGround$39695 = -4
_new_basevel$39698 = -16
_m_vecPushDir$39699 = -28
?SV_UpdateBaseVelocity@@YAXPAVCBaseEntity@@@Z PROC NEAR	; SV_UpdateBaseVelocity, COMDAT

; 1047 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 1048 : 	if( pEntity->pev->flags & FL_ONGROUND )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	$L39697

; 1050 : 		CBaseEntity *pGround = pEntity->GetGroundEntity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ; CBaseEntity::GetGroundEntity
	mov	DWORD PTR _pGround$39695[ebp], eax

; 1051 : 
; 1052 : 		if( pGround )

	cmp	DWORD PTR _pGround$39695[ebp], 0
	je	$L39697

; 1054 : 			// On conveyor belt that's moving?
; 1055 : 			if( pGround->pev->flags & FL_CONVEYOR )

	mov	eax, DWORD PTR _pGround$39695[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 4
	test	edx, edx
	je	$L39697

; 1057 : 				Vector	new_basevel, m_vecPushDir;

	lea	ecx, DWORD PTR _new_basevel$39698[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _m_vecPushDir$39699[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1058 : 
; 1059 : 				if( pGround->m_hParent != NULL )

	mov	ecx, DWORD PTR _pGround$39695[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39700

; 1060 : 					m_vecPushDir = pGround->EntityToWorldTransform().VectorRotate( pGround->pev->movedir );

	mov	eax, DWORD PTR _pGround$39695[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 68					; 00000044H
	push	ecx
	lea	edx, DWORD PTR $T41733[ebp]
	push	edx
	mov	ecx, DWORD PTR _pGround$39695[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	mov	ecx, eax
	call	?VectorRotate@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorRotate
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _m_vecPushDir$39699[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _m_vecPushDir$39699[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _m_vecPushDir$39699[ebp+8], eax

; 1061 : 				else m_vecPushDir = pGround->pev->movedir;

	jmp	SHORT $L39702
$L39700:
	mov	ecx, DWORD PTR _pGround$39695[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _m_vecPushDir$39699[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _m_vecPushDir$39699[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _m_vecPushDir$39699[ebp+8], edx
$L39702:

; 1062 : 
; 1063 : 				new_basevel = m_vecPushDir * pGround->pev->speed;

	mov	eax, DWORD PTR _pGround$39695[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+504]
	push	edx
	lea	eax, DWORD PTR $T41734[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_vecPushDir$39699[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _new_basevel$39698[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _new_basevel$39698[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _new_basevel$39698[ebp+8], eax

; 1064 : 				if( pEntity->pev->flags & FL_BASEVELOCITY )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 4194304				; 00400000H
	test	eax, eax
	je	SHORT $L39704

; 1065 : 					new_basevel += pEntity->GetBaseVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetBaseVelocity
	push	eax
	lea	ecx, DWORD PTR _new_basevel$39698[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=
$L39704:

; 1066 : 
; 1067 : 				pEntity->pev->flags |= FL_BASEVELOCITY;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	or	eax, 4194304				; 00400000H
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+420], eax

; 1068 : 				pEntity->pev->basevelocity = new_basevel;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _new_basevel$39698[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _new_basevel$39698[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _new_basevel$39698[ebp+8]
	mov	DWORD PTR [ecx+8], edx
$L39697:

; 1072 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_UpdateBaseVelocity@@YAXPAVCBaseEntity@@@Z ENDP	; SV_UpdateBaseVelocity
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ PROC NEAR ; CBaseEntity::GetBaseVelocity, COMDAT

; 224  : 	const Vector&	GetBaseVelocity( void ) const { return pev->basevelocity; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, 44					; 0000002cH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ENDP	; CBaseEntity::GetBaseVelocity
_TEXT	ENDS
PUBLIC	?SV_RunThink@@YAHPAVCBaseEntity@@@Z		; SV_RunThink
EXTRN	?DispatchThink@@YAXPAUedict_s@@@Z:NEAR		; DispatchThink
EXTRN	?DontThink@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::DontThink
;	COMDAT ?SV_RunThink@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_thinktime$ = -4
_ed$ = -8
?SV_RunThink@@YAHPAVCBaseEntity@@@Z PROC NEAR		; SV_RunThink, COMDAT

; 1085 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1086 : 	float	thinktime;
; 1087 : 	edict_t	*ed = pEntity->edict();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _ed$[ebp], eax

; 1088 : 
; 1089 : 	thinktime = pEntity->pev->nextthink;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+260]
	mov	DWORD PTR _thinktime$[ebp], edx

; 1090 : 
; 1091 : 	if( thinktime <= 0 || thinktime > PHYSICS_TIME( ) + gpGlobals->frametime )

	fld	DWORD PTR _thinktime$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39711
	fld	DWORD PTR _thinktime$[ebp]
	fstp	QWORD PTR -16+[ebp]
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+4
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fadd	DWORD PTR [eax+4]
	fcomp	QWORD PTR -16+[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39710
$L39711:

; 1092 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L39707
$L39710:

; 1093 : 		
; 1094 : 	if( thinktime < PHYSICS_TIME( ))

	fld	DWORD PTR _thinktime$[ebp]
	fstp	QWORD PTR -24+[ebp]
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+4
	fcomp	QWORD PTR -24+[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39712

; 1095 : 		thinktime = PHYSICS_TIME();	// don't let things stay in the past.

	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+4
	fstp	DWORD PTR _thinktime$[ebp]
$L39712:

; 1096 : 					// it is possible to start that way
; 1097 : 					// by a trigger with a local time.
; 1098 : 	pEntity->DontThink();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?DontThink@CBaseEntity@@QAEXXZ		; CBaseEntity::DontThink

; 1099 : 
; 1100 : 	gpGlobals->time = thinktime;	// ouch!!!

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _thinktime$[ebp]
	mov	DWORD PTR [ecx], edx

; 1101 : 	DispatchThink( pEntity->edict() );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?DispatchThink@@YAXPAUedict_s@@@Z	; DispatchThink
	add	esp, 4

; 1102 : 
; 1103 : 	return (ed->free) ? FALSE : TRUE;

	mov	eax, DWORD PTR _ed$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	sete	cl
	mov	eax, ecx
$L39707:

; 1104 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_RunThink@@YAHPAVCBaseEntity@@@Z ENDP		; SV_RunThink
_TEXT	ENDS
EXTRN	?DispatchTouch@@YAXPAUedict_s@@0@Z:NEAR		; DispatchTouch
EXTRN	?g_groupop@@3HA:DWORD				; g_groupop
EXTRN	?UTIL_CopyTraceToGlobal@@YAXPAUgametrace_s@@@Z:NEAR ; UTIL_CopyTraceToGlobal
;	COMDAT ?SV_Impact@@YAXPAVCBaseEntity@@0PAUgametrace_s@@@Z
_TEXT	SEGMENT
_pEntity1$ = 8
_pEntity2$ = 12
_trace$ = 16
?SV_Impact@@YAXPAVCBaseEntity@@0PAUgametrace_s@@@Z PROC NEAR ; SV_Impact, COMDAT

; 1114 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1115 : 	// get it from trace
; 1116 : 	if( !pEntity2 ) pEntity2 = CBaseEntity::Instance( trace->pHit );

	cmp	DWORD PTR _pEntity2$[ebp], 0
	jne	SHORT $L39718
	mov	eax, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity2$[ebp], eax
$L39718:

; 1117 : 
; 1118 : 	gpGlobals->time = PHYSICS_TIME(); // ouch!

	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+4
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fstp	DWORD PTR [edx]

; 1119 : 
; 1120 : 	if(( pEntity1->pev->flags|pEntity2->pev->flags ) & FL_KILLME )

	mov	eax, DWORD PTR _pEntity1$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pEntity2$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+420]
	or	ecx, DWORD PTR [eax+420]
	and	ecx, 1073741824				; 40000000H
	test	ecx, ecx
	je	SHORT $L39719

; 1121 : 		return;

	jmp	$L39717
$L39719:

; 1122 : 
; 1123 : 	// group trace support
; 1124 : 	if( pEntity1->pev->groupinfo && pEntity2->pev->groupinfo )

	mov	edx, DWORD PTR _pEntity1$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+576], 0
	je	SHORT $L39721
	mov	ecx, DWORD PTR _pEntity2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+576], 0
	je	SHORT $L39721

; 1127 : 		   ( g_groupop == 1 && ( pEntity1->pev->groupinfo & pEntity2->pev->groupinfo )))

	cmp	DWORD PTR ?g_groupop@@3HA, 0		; g_groupop
	jne	SHORT $L39723
	mov	eax, DWORD PTR _pEntity1$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pEntity2$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+576]
	and	ecx, DWORD PTR [eax+576]
	test	ecx, ecx
	je	SHORT $L39722
$L39723:
	cmp	DWORD PTR ?g_groupop@@3HA, 1		; g_groupop
	jne	SHORT $L39721
	mov	edx, DWORD PTR _pEntity1$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _pEntity2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+576]
	and	eax, DWORD PTR [edx+576]
	test	eax, eax
	je	SHORT $L39721
$L39722:

; 1128 : 			return;

	jmp	SHORT $L39717
$L39721:

; 1130 : 
; 1131 : 	if( pEntity1->pev->solid != SOLID_NOT )

	mov	ecx, DWORD PTR _pEntity1$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 0
	je	SHORT $L39724

; 1133 : 		UTIL_CopyTraceToGlobal( trace );

	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	call	?UTIL_CopyTraceToGlobal@@YAXPAUgametrace_s@@@Z ; UTIL_CopyTraceToGlobal
	add	esp, 4

; 1134 : 		DispatchTouch( pEntity1->edict(), pEntity2->edict());

	mov	ecx, DWORD PTR _pEntity2$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _pEntity1$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?DispatchTouch@@YAXPAUedict_s@@0@Z	; DispatchTouch
	add	esp, 8
$L39724:

; 1136 : 
; 1137 : 	if( pEntity2->pev->solid != SOLID_NOT )

	mov	ecx, DWORD PTR _pEntity2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 0
	je	SHORT $L39725

; 1139 : 		UTIL_CopyTraceToGlobal( trace );

	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	call	?UTIL_CopyTraceToGlobal@@YAXPAUgametrace_s@@@Z ; UTIL_CopyTraceToGlobal
	add	esp, 4

; 1140 : 		DispatchTouch( pEntity2->edict(), pEntity1->edict());

	mov	ecx, DWORD PTR _pEntity1$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _pEntity2$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?DispatchTouch@@YAXPAUedict_s@@0@Z	; DispatchTouch
	add	esp, 8
$L39725:
$L39717:

; 1142 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_Impact@@YAXPAVCBaseEntity@@0PAUgametrace_s@@@Z ENDP	; SV_Impact
_TEXT	ENDS
EXTRN	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z:NEAR ; UTIL_SetSize
;	COMDAT ?SV_TestEntityPosition@@YAHPAVCBaseEntity@@0@Z
_TEXT	SEGMENT
$T41745 = -72
$T41746 = -84
$T41747 = -96
$T41748 = -108
_pEntity$ = 8
_pBlocker$ = 12
_trace$ = -56
_pHit$39739 = -60
?SV_TestEntityPosition@@YAHPAVCBaseEntity@@0@Z PROC NEAR ; SV_TestEntityPosition, COMDAT

; 1152 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	ebx
	push	esi
	push	edi

; 1153 : 	TraceResult trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1154 : 
; 1155 : 	if( pEntity->IsPlayer( ))

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	$L39735

; 1157 : 		// to avoid falling through tracktrain update client mins\maxs here
; 1158 : 		if( pEntity->pev->flags & FL_DUCKING ) 

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 16384				; 00004000H
	test	edx, edx
	je	SHORT $L39732

; 1159 : 			UTIL_SetSize( pEntity->pev, VEC_DUCK_HULL_MIN, VEC_DUCK_HULL_MAX );

	push	1099956224				; 41900000H
	push	1098907648				; 41800000H
	push	1098907648				; 41800000H
	lea	ecx, DWORD PTR $T41745[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	push	-1047527424				; c1900000H
	push	-1048576000				; c1800000H
	push	-1048576000				; c1800000H
	lea	ecx, DWORD PTR $T41746[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 1160 : 		else UTIL_SetSize( pEntity->pev, VEC_HULL_MIN, VEC_HULL_MAX );

	jmp	SHORT $L39735
$L39732:
	push	1108344832				; 42100000H
	push	1098907648				; 41800000H
	push	1098907648				; 41800000H
	lea	ecx, DWORD PTR $T41747[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	push	-1039138816				; c2100000H
	push	-1048576000				; c1800000H
	push	-1048576000				; c1800000H
	lea	ecx, DWORD PTR $T41748[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH
$L39735:

; 1162 : 
; 1163 : 	gpGlobals->trace_flags = FTRACE_SIMPLEBOX;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	DWORD PTR [ecx+132], 1

; 1164 : 	TRACE_MONSTER_HULL( pEntity->edict(), pEntity->GetAbsOrigin(), pEntity->GetAbsOrigin(), dont_ignore_monsters, pEntity->edict(), &trace );

	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+132
	add	esp, 24					; 00000018H

; 1165 : 
; 1166 : 	if( pBlocker && trace.pHit )

	cmp	DWORD PTR _pBlocker$[ebp], 0
	je	SHORT $L39738
	cmp	DWORD PTR _trace$[ebp+48], 0
	je	SHORT $L39738

; 1168 : 		CBaseEntity *pHit = CBaseEntity::Instance( trace.pHit );

	mov	eax, DWORD PTR _trace$[ebp+48]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pHit$39739[ebp], eax

; 1169 : 		if( pHit->pev->movetype == MOVETYPE_PUSH || pHit == pBlocker )

	mov	ecx, DWORD PTR _pHit$39739[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 7
	je	SHORT $L39741
	mov	eax, DWORD PTR _pHit$39739[ebp]
	cmp	eax, DWORD PTR _pBlocker$[ebp]
	jne	SHORT $L39740
$L39741:

; 1170 : 			return trace.fStartSolid;

	mov	eax, DWORD PTR _trace$[ebp+4]
	jmp	SHORT $L39729
$L39740:

; 1171 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L39729
$L39738:

; 1173 : 
; 1174 : 	return trace.fStartSolid;

	mov	eax, DWORD PTR _trace$[ebp+4]
$L39729:

; 1175 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_TestEntityPosition@@YAHPAVCBaseEntity@@0@Z ENDP	; SV_TestEntityPosition
_TEXT	ENDS
PUBLIC	__real@4@3ffe8000000000000000
PUBLIC	?SV_RecursiveWaterLevel@@YAMABVVector@@MMH@Z	; SV_RecursiveWaterLevel
EXTRN	?UTIL_PointContents@@YAHABVVector@@@Z:NEAR	; UTIL_PointContents
;	COMDAT __real@4@3ffe8000000000000000
; File z:\xashxtsrc\server\physic.cpp
CONST	SEGMENT
__real@4@3ffe8000000000000000 DD 03f000000r	; 0.5
CONST	ENDS
;	COMDAT ?SV_RecursiveWaterLevel@@YAMABVVector@@MMH@Z
_TEXT	SEGMENT
$T41751 = -28
_origin$ = 8
_mins$ = 12
_maxs$ = 16
_depth$ = 20
_waterlevel$ = -4
_point$ = -16
?SV_RecursiveWaterLevel@@YAMABVVector@@MMH@Z PROC NEAR	; SV_RecursiveWaterLevel, COMDAT

; 1185 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1186 : 	float waterlevel = ((mins - maxs) * 0.5f) + maxs;

	fld	DWORD PTR _mins$[ebp]
	fsub	DWORD PTR _maxs$[ebp]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fadd	DWORD PTR _maxs$[ebp]
	fstp	DWORD PTR _waterlevel$[ebp]

; 1187 : 	if( ++depth > 5 ) return waterlevel;

	mov	eax, DWORD PTR _depth$[ebp]
	add	eax, 1
	mov	DWORD PTR _depth$[ebp], eax
	cmp	DWORD PTR _depth$[ebp], 5
	jle	SHORT $L39749
	fld	DWORD PTR _waterlevel$[ebp]
	jmp	SHORT $L39747
$L39749:

; 1188 : 
; 1189 : 	Vector point = Vector( origin.x, origin.y, origin.z + waterlevel );

	mov	ecx, DWORD PTR _origin$[ebp]
	fld	DWORD PTR _waterlevel$[ebp]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR $T41751[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _point$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1190 : 
; 1191 : 	if( UTIL_PointContents( point ) == CONTENTS_WATER )

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	?UTIL_PointContents@@YAHABVVector@@@Z	; UTIL_PointContents
	add	esp, 4
	cmp	eax, -3					; fffffffdH
	jne	SHORT $L39752

; 1192 : 		return SV_RecursiveWaterLevel( origin, mins, waterlevel, depth );

	mov	ecx, DWORD PTR _depth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _waterlevel$[ebp]
	push	edx
	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	call	?SV_RecursiveWaterLevel@@YAMABVVector@@MMH@Z ; SV_RecursiveWaterLevel
	add	esp, 16					; 00000010H
	jmp	SHORT $L39747
$L39752:

; 1193 : 	return SV_RecursiveWaterLevel( origin, waterlevel, maxs, depth );

	mov	edx, DWORD PTR _depth$[ebp]
	push	edx
	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _waterlevel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	call	?SV_RecursiveWaterLevel@@YAMABVVector@@MMH@Z ; SV_RecursiveWaterLevel
	add	esp, 16					; 00000010H
$L39747:

; 1194 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_RecursiveWaterLevel@@YAMABVVector@@MMH@Z ENDP	; SV_RecursiveWaterLevel
_TEXT	ENDS
PUBLIC	?SV_Submerged@@YAMPAVCBaseEntity@@@Z		; SV_Submerged
;	COMDAT ?SV_Submerged@@YAMPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T41756 = -40
$T41757 = -52
$T41758 = -64
_pEntity$ = 8
_point$ = -12
_halfmax$ = -24
_waterlevel$ = -28
?SV_Submerged@@YAMPAVCBaseEntity@@@Z PROC NEAR		; SV_Submerged, COMDAT

; 1204 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 1205 : 	Vector	point;

	lea	ecx, DWORD PTR _point$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1206 : 
; 1207 : 	Vector halfmax = (pEntity->pev->absmin + pEntity->pev->absmax) * 0.5f;

	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T41757[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 208				; 000000d0H
	push	edx
	lea	eax, DWORD PTR $T41756[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 196				; 000000c4H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _halfmax$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1208 : 	float waterlevel = pEntity->pev->absmin.z - halfmax.z;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+204]
	fsub	DWORD PTR _halfmax$[ebp+8]
	fstp	DWORD PTR _waterlevel$[ebp]

; 1211 : 	{

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+448]
	mov	DWORD PTR -68+[ebp], eax
	cmp	DWORD PTR -68+[ebp], 1
	je	SHORT $L39765
	cmp	DWORD PTR -68+[ebp], 2
	je	$L39768
	cmp	DWORD PTR -68+[ebp], 3
	je	SHORT $L39766
	jmp	$L39770
$L39765:

; 1212 : 	case 1:
; 1213 : 		return SV_RecursiveWaterLevel( halfmax, 0.0f, waterlevel, 0 ) - waterlevel;

	push	0
	mov	ecx, DWORD PTR _waterlevel$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _halfmax$[ebp]
	push	edx
	call	?SV_RecursiveWaterLevel@@YAMABVVector@@MMH@Z ; SV_RecursiveWaterLevel
	add	esp, 16					; 00000010H
	fsub	DWORD PTR _waterlevel$[ebp]
	jmp	$L39762
$L39766:

; 1214 : 	case 3:
; 1215 : 		point = Vector( halfmax.x, halfmax.y, pEntity->pev->absmax.z );

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+216]
	push	edx
	mov	eax, DWORD PTR _halfmax$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _halfmax$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T41758[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _point$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _point$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _point$[ebp+8], edx

; 1216 : 
; 1217 : 		if( UTIL_PointContents( point ) == CONTENTS_WATER )

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	?UTIL_PointContents@@YAHABVVector@@@Z	; UTIL_PointContents
	add	esp, 4
	cmp	eax, -3					; fffffffdH
	jne	SHORT $L39768

; 1219 : 			return (pEntity->pev->maxs.z - pEntity->pev->mins.z);

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [edx+240]
	fsub	DWORD PTR [ecx+228]
	jmp	SHORT $L39762
$L39768:

; 1223 : 		return SV_RecursiveWaterLevel( halfmax, pEntity->pev->absmax.z - halfmax.z, 0.0f, 0 ) - waterlevel;

	push	0
	push	0
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+216]
	fsub	DWORD PTR _halfmax$[ebp+8]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _halfmax$[ebp]
	push	ecx
	call	?SV_RecursiveWaterLevel@@YAMABVVector@@MMH@Z ; SV_RecursiveWaterLevel
	add	esp, 16					; 00000010H
	fsub	DWORD PTR _waterlevel$[ebp]
	jmp	SHORT $L39762
$L39770:

; 1224 : 	default:
; 1225 : 		return 0.0f;

	fld	DWORD PTR __real@4@00000000000000000000
$L39762:

; 1227 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_Submerged@@YAMPAVCBaseEntity@@@Z ENDP		; SV_Submerged
_TEXT	ENDS
PUBLIC	?SV_CheckMover@@YAHPAVCBaseEntity@@@Z		; SV_CheckMover
;	COMDAT ?SV_CheckMover@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_pGround$ = -4
?SV_CheckMover@@YAHPAVCBaseEntity@@@Z PROC NEAR		; SV_CheckMover, COMDAT

; 1237 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1238 : 	CBaseEntity *pGround = pEntity->GetGroundEntity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ; CBaseEntity::GetGroundEntity
	mov	DWORD PTR _pGround$[ebp], eax

; 1239 : 
; 1240 : 	if( !pGround )

	cmp	DWORD PTR _pGround$[ebp], 0
	jne	SHORT $L39775

; 1241 : 		return false;

	xor	eax, eax
	jmp	SHORT $L39773
$L39775:

; 1242 : 
; 1243 : 	if( pGround->pev->movetype != MOVETYPE_PUSH )

	mov	eax, DWORD PTR _pGround$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+264], 7
	je	SHORT $L39776

; 1244 : 		return false;

	xor	eax, eax
	jmp	SHORT $L39773
$L39776:

; 1245 : 
; 1246 : 	if( pGround->GetLocalVelocity() == g_vecZero && pGround->GetLocalAvelocity() == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pGround$[ebp]
	call	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalVelocity
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L39777
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pGround$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L39777

; 1247 : 		return false;

	xor	eax, eax
	jmp	SHORT $L39773
$L39777:

; 1248 : 
; 1249 : 	return true;

	mov	eax, 1
$L39773:

; 1250 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_CheckMover@@YAHPAVCBaseEntity@@@Z ENDP		; SV_CheckMover
_TEXT	ENDS
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	?SV_CheckWater@@YAHPAVCBaseEntity@@@Z		; SV_CheckWater
;	COMDAT __real@4@3fff8000000000000000
; File z:\xashxtsrc\server\physic.cpp
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT ?SV_CheckWater@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_point$ = -12
_cont$ = -16
?SV_CheckWater@@YAHPAVCBaseEntity@@@Z PROC NEAR		; SV_CheckWater, COMDAT

; 1258 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1259 : 	Vector	point;

	lea	ecx, DWORD PTR _point$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1260 : 
; 1261 : 	point.x = (pEntity->pev->absmin.x + pEntity->pev->absmax.x) * 0.5f;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [ecx+196]
	fadd	DWORD PTR [eax+208]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fstp	DWORD PTR _point$[ebp]

; 1262 : 	point.y = (pEntity->pev->absmin.y + pEntity->pev->absmax.y) * 0.5f;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [edx+200]
	fadd	DWORD PTR [ecx+212]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fstp	DWORD PTR _point$[ebp+4]

; 1263 : 	point.z =  pEntity->pev->absmin.z + 1;	

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+204]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _point$[ebp+8]

; 1264 : 
; 1265 : 	pEntity->pev->waterlevel = 0;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+448], 0

; 1266 : 	pEntity->pev->watertype = CONTENTS_EMPTY;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+452], -1

; 1267 : 
; 1268 : 	int cont = UTIL_PointContents( point );

	lea	edx, DWORD PTR _point$[ebp]
	push	edx
	call	?UTIL_PointContents@@YAHABVVector@@@Z	; UTIL_PointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 1269 : 
; 1270 : 	if( cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT )

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	$L39787
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jle	$L39787

; 1272 : 		pEntity->pev->watertype = cont;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _cont$[ebp]
	mov	DWORD PTR [ecx+452], edx

; 1273 : 		pEntity->pev->waterlevel = 1;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+448], 1

; 1274 : 
; 1275 : 		if( pEntity->pev->absmin.z == pEntity->pev->absmax.z )

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+204]
	fcomp	DWORD PTR [edx+216]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39784

; 1277 : 			// a point entity
; 1278 : 			pEntity->pev->waterlevel = 3;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+448], 3

; 1280 : 		else

	jmp	$L39787
$L39784:

; 1282 : 			point.z = (pEntity->pev->absmin.z + pEntity->pev->absmax.z) * 0.5f;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+204]
	fadd	DWORD PTR [edx+216]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fstp	DWORD PTR _point$[ebp+8]

; 1283 : 
; 1284 : 			cont = UTIL_PointContents( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	?UTIL_PointContents@@YAHABVVector@@@Z	; UTIL_PointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 1285 : 
; 1286 : 			if( cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT )

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	SHORT $L39787
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jle	SHORT $L39787

; 1288 : 				pEntity->pev->waterlevel = 2;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+448], 2

; 1289 : 
; 1290 : 				point += pEntity->pev->view_ofs;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	ecx, DWORD PTR _point$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1291 : 				cont = UTIL_PointContents( point );

	lea	edx, DWORD PTR _point$[ebp]
	push	edx
	call	?UTIL_PointContents@@YAHABVVector@@@Z	; UTIL_PointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 1292 : 
; 1293 : 				if( cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT )

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	SHORT $L39787
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jle	SHORT $L39787

; 1294 : 					pEntity->pev->waterlevel = 3;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+448], 3
$L39787:

; 1298 : 
; 1299 : 	return (pEntity->pev->waterlevel > 1);

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+448], 1
	setg	cl
	mov	eax, ecx

; 1300 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_CheckWater@@YAHPAVCBaseEntity@@@Z ENDP		; SV_CheckWater
_TEXT	ENDS
PUBLIC	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z		; EMIT_SOUND
PUBLIC	?SV_CheckWaterTransition@@YAXPAVCBaseEntity@@@Z	; SV_CheckWaterTransition
PUBLIC	??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@	; `string'
;	COMDAT ??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@
; File z:\xashxtsrc\server\physic.cpp
CONST	SEGMENT
??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@ DB 'player/pl_wade2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@ DB 'player/pl_wade1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?SV_CheckWaterTransition@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_cont$ = -4
_halfmax$ = -16
_vecAbsVelocity$39802 = -28
?SV_CheckWaterTransition@@YAXPAVCBaseEntity@@@Z PROC NEAR ; SV_CheckWaterTransition, COMDAT

; 1309 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1310 : 	int	cont;
; 1311 : 	Vector	halfmax;

	lea	ecx, DWORD PTR _halfmax$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1312 : 
; 1313 : 	halfmax.x = (pEntity->pev->absmax.x + pEntity->pev->absmin.x) * 0.5f;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [ecx+208]
	fadd	DWORD PTR [eax+196]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fstp	DWORD PTR _halfmax$[ebp]

; 1314 : 	halfmax.y = (pEntity->pev->absmax.y + pEntity->pev->absmin.y) * 0.5f;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [edx+212]
	fadd	DWORD PTR [ecx+200]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fstp	DWORD PTR _halfmax$[ebp+4]

; 1315 : 	halfmax.z =  pEntity->pev->absmin.z + 1.0f;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+204]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _halfmax$[ebp+8]

; 1316 : 
; 1317 : 	cont = UTIL_PointContents( halfmax );

	lea	ecx, DWORD PTR _halfmax$[ebp]
	push	ecx
	call	?UTIL_PointContents@@YAHABVVector@@@Z	; UTIL_PointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 1318 : 
; 1319 : 	if( !pEntity->pev->watertype )

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+452], 0
	jne	SHORT $L39793

; 1321 : 		// just spawned here
; 1322 : 		pEntity->pev->watertype = cont;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _cont$[ebp]
	mov	DWORD PTR [edx+452], eax

; 1323 : 		pEntity->pev->waterlevel = 1;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+448], 1

; 1324 : 		return;

	jmp	$L39790
$L39793:

; 1326 : 
; 1327 : 	if( cont > CONTENTS_WATER || cont <= CONTENTS_TRANSLUCENT )

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	SHORT $L39795
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jg	SHORT $L39794
$L39795:

; 1329 : 		if( pEntity->pev->watertype != CONTENTS_EMPTY )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+452], -1
	je	SHORT $L39796

; 1331 : 			EMIT_SOUND( pEntity->edict(), CHAN_BODY, "player/pl_wade2.wav", 1.0f, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L39796:

; 1333 : 
; 1334 : 		pEntity->pev->watertype = CONTENTS_EMPTY;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+452], -1

; 1335 : 		pEntity->pev->waterlevel = 0;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+448], 0

; 1336 : 		return;

	jmp	$L39790
$L39794:

; 1338 : 
; 1339 : 	if( pEntity->pev->watertype == CONTENTS_EMPTY )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+452], -1
	jne	SHORT $L39799

; 1341 : 		EMIT_SOUND( pEntity->edict(), CHAN_BODY, "player/pl_wade1.wav", 1.0f, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1342 : 		Vector vecAbsVelocity = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vecAbsVelocity$39802[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1343 : 		vecAbsVelocity.z *= 0.5f; // cut speed for floatables

	fld	DWORD PTR _vecAbsVelocity$39802[ebp+8]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fstp	DWORD PTR _vecAbsVelocity$39802[ebp+8]

; 1344 : 		pEntity->SetAbsVelocity( vecAbsVelocity );

	lea	edx, DWORD PTR _vecAbsVelocity$39802[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L39799:

; 1346 : 
; 1347 : 	pEntity->pev->watertype = cont;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _cont$[ebp]
	mov	DWORD PTR [ecx+452], edx

; 1348 : 	pEntity->pev->waterlevel = 1;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+448], 1

; 1349 : 
; 1350 : 	if( pEntity->pev->absmin.z == pEntity->pev->absmax.z )

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+204]
	fcomp	DWORD PTR [edx+216]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39803

; 1352 : 		// a point entity
; 1353 : 		pEntity->pev->waterlevel = 3;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+448], 3
$L39803:

; 1355 : 
; 1356 : 	halfmax.z = (pEntity->pev->absmin.z + pEntity->pev->absmax.z) * 0.5f;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+204]
	fadd	DWORD PTR [edx+216]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fstp	DWORD PTR _halfmax$[ebp+8]

; 1357 : 
; 1358 : 	cont = UTIL_PointContents( halfmax );

	lea	eax, DWORD PTR _halfmax$[ebp]
	push	eax
	call	?UTIL_PointContents@@YAHABVVector@@@Z	; UTIL_PointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 1359 : 
; 1360 : 	if( cont > CONTENTS_WATER || cont <= CONTENTS_TRANSLUCENT )

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	SHORT $L39805
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jg	SHORT $L39804
$L39805:

; 1361 : 		return;

	jmp	SHORT $L39790
$L39804:

; 1362 : 
; 1363 : 	pEntity->pev->waterlevel = 2;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+448], 2

; 1364 : 	halfmax += pEntity->pev->view_ofs;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	ecx, DWORD PTR _halfmax$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1365 : 
; 1366 : 	cont = UTIL_PointContents( halfmax );

	lea	edx, DWORD PTR _halfmax$[ebp]
	push	edx
	call	?UTIL_PointContents@@YAHABVVector@@@Z	; UTIL_PointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 1367 : 
; 1368 : 	if( cont > CONTENTS_WATER || cont <= CONTENTS_TRANSLUCENT )

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	SHORT $L39807
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jg	SHORT $L39806
$L39807:

; 1369 : 		return;

	jmp	SHORT $L39790
$L39806:

; 1370 : 
; 1371 : 	pEntity->pev->waterlevel = 3;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+448], 3
$L39790:

; 1372 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_CheckWaterTransition@@YAXPAVCBaseEntity@@@Z ENDP	; SV_CheckWaterTransition
_TEXT	ENDS
EXTRN	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z:NEAR	; EMIT_SOUND_DYN
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
_volume$ = 20
_attenuation$ = 24
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z PROC NEAR		; EMIT_SOUND, COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 610  : 	EMIT_SOUND_DYN( entity, channel, sample, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 611  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z ENDP		; EMIT_SOUND
_TEXT	ENDS
PUBLIC	?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z	; SV_CheckVelocity
PUBLIC	??_C@_0P@NFJM@sv_maxvelocity?$AA@		; `string'
PUBLIC	??_C@_0BK@EMCI@Got?5a?5NaN?5velocity?5on?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@FDAD@Got?5a?5NaN?5origin?5on?5?$CFs?6?$AA@ ; `string'
;	COMDAT ??_C@_0P@NFJM@sv_maxvelocity?$AA@
; File z:\xashxtsrc\server\physic.cpp
CONST	SEGMENT
??_C@_0P@NFJM@sv_maxvelocity?$AA@ DB 'sv_maxvelocity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EMCI@Got?5a?5NaN?5velocity?5on?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BK@EMCI@Got?5a?5NaN?5velocity?5on?5?$CFs?6?$AA@ DB 'Got a NaN velo'
	DB	'city on %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FDAD@Got?5a?5NaN?5origin?5on?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BI@FDAD@Got?5a?5NaN?5origin?5on?5?$CFs?6?$AA@ DB 'Got a NaN origin'
	DB	' on %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_origin$ = -12
_vecAbsVelocity$ = -24
_maxVelocity$ = -28
_bReset$ = -32
_i$ = -36
?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z PROC NEAR	; SV_CheckVelocity, COMDAT

; 1380 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 1381 : 	Vector origin = pEntity->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _origin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1382 : 	Vector vecAbsVelocity = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1383 : 	float maxVelocity = CVAR_GET_FLOAT( "sv_maxvelocity" );

	push	OFFSET FLAT:??_C@_0P@NFJM@sv_maxvelocity?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fstp	DWORD PTR _maxVelocity$[ebp]

; 1384 : 	bool bReset = false;

	mov	BYTE PTR _bReset$[ebp], 0

; 1385 : 
; 1386 : 	// bound velocity
; 1387 : 	for( int i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39817
$L39818:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L39817:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$L39819

; 1389 : 		if( IS_NAN( vecAbsVelocity[i] ))

	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	and	edx, 2139095040				; 7f800000H
	cmp	edx, 2139095040				; 7f800000H
	jne	SHORT $L39821

; 1391 : 			ALERT( at_console, "Got a NaN velocity on %s\n", pEntity->GetClassname( ));

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0BK@EMCI@Got?5a?5NaN?5velocity?5on?5?$CFs?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1392 : 			vecAbsVelocity[i] = 0.0f;

	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 1393 : 			bReset = true;

	mov	BYTE PTR _bReset$[ebp], 1
$L39821:

; 1395 : 
; 1396 : 		if( IS_NAN( origin[i] ))

	lea	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	and	eax, 2139095040				; 7f800000H
	cmp	eax, 2139095040				; 7f800000H
	jne	SHORT $L39824

; 1398 : 			ALERT( at_console, "Got a NaN origin on %s\n", pEntity->GetClassname( ));

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0BI@FDAD@Got?5a?5NaN?5origin?5on?5?$CFs?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1399 : 			origin[i] = 0.0f;

	lea	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 1400 : 			bReset = true;

	mov	BYTE PTR _bReset$[ebp], 1
$L39824:

; 1402 : 
; 1403 : 		if( vecAbsVelocity[i] > maxVelocity )

	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fcomp	DWORD PTR _maxVelocity$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39826

; 1405 : 			vecAbsVelocity[i] = maxVelocity;

	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _maxVelocity$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 1406 : 			bReset = true;

	mov	BYTE PTR _bReset$[ebp], 1

; 1408 : 		else if( vecAbsVelocity[i] < -maxVelocity )

	jmp	SHORT $L39828
$L39826:
	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _maxVelocity$[ebp]
	fchs
	mov	ecx, DWORD PTR _i$[ebp]
	fcomp	DWORD PTR [eax+ecx*4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39828

; 1410 : 			vecAbsVelocity[i] = -maxVelocity;

	fld	DWORD PTR _maxVelocity$[ebp]
	fchs
	fstp	DWORD PTR -40+[ebp]
	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1411 : 			bReset = true;

	mov	BYTE PTR _bReset$[ebp], 1
$L39828:

; 1413 : 	}

	jmp	$L39818
$L39819:

; 1414 : 
; 1415 : 	if( bReset )

	mov	edx, DWORD PTR _bReset$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L39829

; 1417 : 		pEntity->SetAbsOrigin( origin );

	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 1418 : 		pEntity->SetAbsVelocity( vecAbsVelocity );

	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L39829:

; 1420 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z ENDP		; SV_CheckVelocity
_TEXT	ENDS
PUBLIC	?DotProduct@@YAMABVVector@@0@Z			; DotProduct
PUBLIC	__real@4@bfff8000000000000000
PUBLIC	?SV_ClipVelocity@@YAHABVVector@@0AAV1@M@Z	; SV_ClipVelocity
;	COMDAT __real@4@bfff8000000000000000
; File z:\xashxtsrc\server\physic.cpp
CONST	SEGMENT
__real@4@bfff8000000000000000 DD 0bf800000r	; -1
CONST	ENDS
;	COMDAT ?SV_ClipVelocity@@YAHABVVector@@0AAV1@M@Z
_TEXT	SEGMENT
_in$ = 8
_normal$ = 12
_out$ = 16
_overbounce$ = 20
_blocked$ = -4
_backoff$ = -8
_i$ = -12
_change$39844 = -16
?SV_ClipVelocity@@YAHABVVector@@0AAV1@M@Z PROC NEAR	; SV_ClipVelocity, COMDAT

; 1430 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1431 : 	int blocked = 0;

	mov	DWORD PTR _blocked$[ebp], 0

; 1432 : 	if( normal[2] > 0.0f ) blocked |= 1;	// floor

	mov	ecx, DWORD PTR _normal$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39837
	mov	eax, DWORD PTR _blocked$[ebp]
	or	al, 1
	mov	DWORD PTR _blocked$[ebp], eax
$L39837:

; 1433 : 	if( !normal[2] ) blocked |= 2;	// step

	mov	ecx, DWORD PTR _normal$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39838
	mov	ecx, DWORD PTR _blocked$[ebp]
	or	ecx, 2
	mov	DWORD PTR _blocked$[ebp], ecx
$L39838:

; 1434 : 	
; 1435 : 	float backoff = DotProduct( in, normal ) * overbounce;

	mov	edx, DWORD PTR _normal$[ebp]
	push	edx
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fmul	DWORD PTR _overbounce$[ebp]
	fstp	DWORD PTR _backoff$[ebp]

; 1436 : 
; 1437 : 	for( int i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39841
$L39842:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L39841:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$L39843

; 1439 : 		float change = normal[i] * backoff;

	mov	ecx, DWORD PTR _normal$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, DWORD PTR _i$[ebp]
	fld	DWORD PTR _backoff$[ebp]
	fmul	DWORD PTR [eax+edx*4]
	fstp	DWORD PTR _change$39844[ebp]

; 1440 : 		out[i] = in[i] - change;

	mov	ecx, DWORD PTR _in$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fsub	DWORD PTR _change$39844[ebp]
	fstp	DWORD PTR -20+[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR -20+[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1441 : 
; 1442 : 		if( out[i] > -1.0f && out[i] < 1.0f )

	mov	ecx, DWORD PTR _out$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fcomp	DWORD PTR __real@4@bfff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39845
	mov	ecx, DWORD PTR _out$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39845

; 1443 : 			out[i] = 0.0f;

	mov	ecx, DWORD PTR _out$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+edx*4], 0
$L39845:

; 1444 : 	}

	jmp	$L39842
$L39843:

; 1445 : 
; 1446 : 	return blocked;

	mov	eax, DWORD PTR _blocked$[ebp]

; 1447 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_ClipVelocity@@YAHABVVector@@0AAV1@M@Z ENDP		; SV_ClipVelocity
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProduct@@YAMABVVector@@0@Z PROC NEAR		; DotProduct, COMDAT

; 289  : inline float DotProduct(const Vector& a, const Vector& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector@@0@Z ENDP			; DotProduct
_TEXT	ENDS
PUBLIC	?SV_CalcOverBounce@@YAMPAVCBaseEntity@@PAUgametrace_s@@@Z ; SV_CalcOverBounce
EXTRN	?FNullEnt@@YAHPAVCBaseEntity@@@Z:NEAR		; FNullEnt
;	COMDAT ?SV_CalcOverBounce@@YAMPAVCBaseEntity@@PAUgametrace_s@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_trace$ = 12
_overbounce$ = -4
_pHit$ = -8
?SV_CalcOverBounce@@YAMPAVCBaseEntity@@PAUgametrace_s@@@Z PROC NEAR ; SV_CalcOverBounce, COMDAT

; 1450 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1451 : 	float overbounce = 1.0f;

	mov	DWORD PTR _overbounce$[ebp], 1065353216	; 3f800000H

; 1452 : 
; 1453 : 	CBaseEntity *pHit = CBaseEntity::Instance( trace->pHit );

	mov	eax, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pHit$[ebp], eax

; 1454 : 
; 1455 : 	if( FNullEnt( pHit ))

	mov	edx, DWORD PTR _pHit$[ebp]
	push	edx
	call	?FNullEnt@@YAHPAVCBaseEntity@@@Z	; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L39852

; 1456 : 		return overbounce;

	fld	DWORD PTR _overbounce$[ebp]
	jmp	SHORT $L39849
$L39852:

; 1457 : 
; 1458 : 	if( pEntity->pev->movetype == MOVETYPE_PUSHSTEP && pHit->IsPlayer() && pHit->pev->button & IN_BACK )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+264], 13			; 0000000dH
	jne	SHORT $L39853
	mov	edx, DWORD PTR _pHit$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pHit$[ebp]
	call	DWORD PTR [eax+224]
	test	eax, eax
	je	SHORT $L39853
	mov	ecx, DWORD PTR _pHit$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+384]
	and	eax, 16					; 00000010H
	test	eax, eax
	je	SHORT $L39853

; 1460 : 		// g-cont. this is a player that pulling the 'func_pushable'
; 1461 : 		// disable overbounce to avoid box slide along the player
; 1462 : 		overbounce = 0.0f;

	mov	DWORD PTR _overbounce$[ebp], 0
$L39853:

; 1464 : 
; 1465 : 	return overbounce;

	fld	DWORD PTR _overbounce$[ebp]
$L39849:

; 1466 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_CalcOverBounce@@YAMPAVCBaseEntity@@PAUgametrace_s@@@Z ENDP ; SV_CalcOverBounce
_TEXT	ENDS
PUBLIC	?CrossProduct@@YA?AVVector@@ABV1@0@Z		; CrossProduct
PUBLIC	__real@4@3ffeb333330000000000
PUBLIC	?SV_FlyMove@@YAHPAVCBaseEntity@@MPAUgametrace_s@@@Z ; SV_FlyMove
PUBLIC	??_C@_0CA@ECAF@SV_FlyMove?3?5trace?4pHit?5?$DN?$DN?5NULL?6?$AA@ ; `string'
PUBLIC	?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z ; CBaseEntity::SetGroundEntity
;	COMDAT ??_C@_0CA@ECAF@SV_FlyMove?3?5trace?4pHit?5?$DN?$DN?5NULL?6?$AA@
; File z:\xashxtsrc\server\physic.cpp
CONST	SEGMENT
??_C@_0CA@ECAF@SV_FlyMove?3?5trace?4pHit?5?$DN?$DN?5NULL?6?$AA@ DB 'SV_Fl'
	DB	'yMove: trace.pHit == NULL', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@4@3ffeb333330000000000
CONST	SEGMENT
__real@4@3ffeb333330000000000 DD 03f333333r	; 0.7
CONST	ENDS
;	COMDAT ?SV_FlyMove@@YAHPAVCBaseEntity@@MPAUgametrace_s@@@Z
_TEXT	SEGMENT
$T41781 = -232
$T41782 = -244
$T41783 = -256
$T41784 = -268
_pEntity$ = 8
_time$ = 12
_steptrace$ = 16
_planes$ = -60
_new_velocity$ = -72
_trace$ = -128
_original_velocity$ = -140
_primal_velocity$ = -152
_ed$ = -156
_blocked$ = -160
_numplanes$ = -164
_allFraction$ = -168
_time_left$ = -172
_bumpcount$ = -176
_end$39875 = -188
_pHit$39878 = -192
_i$39892 = -196
_overbounce$39896 = -200
_j$39897 = -204
_dir$39907 = -216
_d$39909 = -220
?SV_FlyMove@@YAHPAVCBaseEntity@@MPAUgametrace_s@@@Z PROC NEAR ; SV_FlyMove, COMDAT

; 1488 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	push	ebx
	push	esi
	push	edi

; 1489 : 	Vector planes[MAX_CLIP_PLANES];

	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	5
	push	12					; 0000000cH
	lea	eax, DWORD PTR _planes$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 1490 : 	Vector new_velocity;

	lea	ecx, DWORD PTR _new_velocity$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1491 : 	TraceResult trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1492 : 
; 1493 : 	Vector original_velocity = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _original_velocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1494 : 	Vector primal_velocity = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _primal_velocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1495 : 	edict_t *ed = pEntity->edict();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _ed$[ebp], eax

; 1496 : 
; 1497 : 	int blocked = 0;

	mov	DWORD PTR _blocked$[ebp], 0

; 1498 : 	int numplanes = 0;

	mov	DWORD PTR _numplanes$[ebp], 0

; 1499 : 	float allFraction = 0;

	mov	DWORD PTR _allFraction$[ebp], 0

; 1500 : 	float time_left = time;

	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR _time_left$[ebp], ecx

; 1501 : 
; 1502 : 	for( int bumpcount = 0; bumpcount < 4; bumpcount++ )

	mov	DWORD PTR _bumpcount$[ebp], 0
	jmp	SHORT $L39871
$L39872:
	mov	edx, DWORD PTR _bumpcount$[ebp]
	add	edx, 1
	mov	DWORD PTR _bumpcount$[ebp], edx
$L39871:
	cmp	DWORD PTR _bumpcount$[ebp], 4
	jge	$L39873

; 1504 : 		if( pEntity->GetAbsVelocity() == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L39874

; 1505 : 			break;

	jmp	$L39873
$L39874:

; 1506 : 
; 1507 : 		Vector end = pEntity->GetAbsOrigin() + pEntity->GetAbsVelocity() * time_left;

	mov	eax, DWORD PTR _time_left$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41781[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T41782[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _end$39875[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1508 : 
; 1509 : 		pEntity->m_iPushableFilter = TRUE;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [eax+36], 1

; 1510 : 		TRACE_MONSTER_HULL( pEntity->edict(), pEntity->GetAbsOrigin(), end, dont_ignore_monsters, pEntity->edict(), &trace );

	lea	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	lea	ecx, DWORD PTR _end$39875[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+132
	add	esp, 24					; 00000018H

; 1511 : 		pEntity->m_iPushableFilter = FALSE;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [edx+36], 0

; 1512 : 
; 1513 : 		CBaseEntity *pHit = CBaseEntity::Instance( trace.pHit );

	mov	eax, DWORD PTR _trace$[ebp+48]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pHit$39878[ebp], eax

; 1514 : 		allFraction += trace.flFraction;

	fld	DWORD PTR _allFraction$[ebp]
	fadd	DWORD PTR _trace$[ebp+16]
	fstp	DWORD PTR _allFraction$[ebp]

; 1515 : 
; 1516 : 		if( trace.fAllSolid )

	cmp	DWORD PTR _trace$[ebp], 0
	je	SHORT $L39879

; 1518 : 			// entity is trapped in another solid
; 1519 : 			pEntity->SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1520 : 			return 4;

	mov	eax, 4
	jmp	$L39858
$L39879:

; 1522 : 
; 1523 : 		if( trace.flFraction > 0.0f )

	fld	DWORD PTR _trace$[ebp+16]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39880

; 1525 : 			// actually covered some distance
; 1526 : 			pEntity->SetAbsOrigin( trace.vecEndPos );

	lea	ecx, DWORD PTR _trace$[ebp+20]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 1527 : 			original_velocity = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _original_velocity$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _original_velocity$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _original_velocity$[ebp+8], edx

; 1528 : 			numplanes = 0;

	mov	DWORD PTR _numplanes$[ebp], 0
$L39880:

; 1530 : 
; 1531 : 		if( trace.flFraction == 1.0f )

	cmp	DWORD PTR _trace$[ebp+16], 1065353216	; 3f800000H
	jne	SHORT $L39881

; 1533 : 			 break; // moved the entire distance

	jmp	$L39873
$L39881:

; 1535 : 
; 1536 : 		if( !trace.pHit )

	cmp	DWORD PTR _trace$[ebp+48], 0
	jne	SHORT $L39882

; 1537 : 			ALERT( at_error, "SV_FlyMove: trace.pHit == NULL\n" );

	push	OFFSET FLAT:??_C@_0CA@ECAF@SV_FlyMove?3?5trace?4pHit?5?$DN?$DN?5NULL?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L39882:

; 1538 : 
; 1539 : 		if( trace.vecPlaneNormal.z > 0.7f )

	fld	DWORD PTR _trace$[ebp+44]
	fcomp	DWORD PTR __real@4@3ffeb333330000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39885

; 1541 : 			blocked |= 1; // floor

	mov	eax, DWORD PTR _blocked$[ebp]
	or	al, 1
	mov	DWORD PTR _blocked$[ebp], eax

; 1544 : 			trace.pHit->v.movetype == MOVETYPE_PUSHSTEP || (trace.pHit->v.flags & FL_CLIENT))

	mov	ecx, DWORD PTR _trace$[ebp+48]
	cmp	DWORD PTR [ecx+396], 4
	je	SHORT $L39886
	mov	edx, DWORD PTR _trace$[ebp+48]
	cmp	DWORD PTR [edx+396], 3
	je	SHORT $L39886
	mov	eax, DWORD PTR _trace$[ebp+48]
	cmp	DWORD PTR [eax+392], 13			; 0000000dH
	je	SHORT $L39886
	mov	ecx, DWORD PTR _trace$[ebp+48]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 8
	test	edx, edx
	je	SHORT $L39885
$L39886:

; 1546 : 				pEntity->SetGroundEntity( trace.pHit );

	mov	eax, DWORD PTR _trace$[ebp+48]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z ; CBaseEntity::SetGroundEntity
$L39885:

; 1549 : 
; 1550 : 		if( trace.vecPlaneNormal.z == 0.0f )

	fld	DWORD PTR _trace$[ebp+44]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39888

; 1552 : 			blocked |= 2; // step

	mov	ecx, DWORD PTR _blocked$[ebp]
	or	ecx, 2
	mov	DWORD PTR _blocked$[ebp], ecx

; 1553 : 			if( steptrace ) *steptrace = trace; // save for player extrafriction

	cmp	DWORD PTR _steptrace$[ebp], 0
	je	SHORT $L39888
	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR _trace$[ebp]
	mov	edi, DWORD PTR _steptrace$[ebp]
	rep movsd
$L39888:

; 1555 : 
; 1556 : 		// run the impact function
; 1557 : 		SV_Impact( pEntity, NULL, &trace );

	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_Impact@@YAXPAVCBaseEntity@@0PAUgametrace_s@@@Z ; SV_Impact
	add	esp, 12					; 0000000cH

; 1558 : 
; 1559 : 		// break if removed by the impact function
; 1560 : 		if( ed->free || pEntity->pev->flags & FL_KILLME )

	mov	ecx, DWORD PTR _ed$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $L39890
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 1073741824				; 40000000H
	test	ecx, ecx
	je	SHORT $L39889
$L39890:

; 1561 : 			break;

	jmp	$L39873
$L39889:

; 1562 : 
; 1563 : 		time_left -= time_left * trace.flFraction;

	fld	DWORD PTR _time_left$[ebp]
	fmul	DWORD PTR _trace$[ebp+16]
	fsubr	DWORD PTR _time_left$[ebp]
	fstp	DWORD PTR _time_left$[ebp]

; 1564 : 
; 1565 : 		// clipped to another plane
; 1566 : 		if( numplanes >= MAX_CLIP_PLANES )

	cmp	DWORD PTR _numplanes$[ebp], 5
	jl	SHORT $L39891

; 1568 : 			// this shouldn't really happen
; 1569 : 			pEntity->SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1570 : 			break;

	jmp	$L39873
$L39891:

; 1572 : 
; 1573 : 		planes[numplanes] = trace.vecPlaneNormal;

	mov	edx, DWORD PTR _numplanes$[ebp]
	imul	edx, 12					; 0000000cH
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, DWORD PTR _trace$[ebp+36]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _trace$[ebp+40]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _trace$[ebp+44]
	mov	DWORD PTR [eax+8], ecx

; 1574 : 		numplanes++;

	mov	edx, DWORD PTR _numplanes$[ebp]
	add	edx, 1
	mov	DWORD PTR _numplanes$[ebp], edx

; 1575 : 
; 1576 : 		// modify original_velocity so it parallels all of the clip planes
; 1577 : 		for( int i = 0; i < numplanes; i++ )

	mov	DWORD PTR _i$39892[ebp], 0
	jmp	SHORT $L39893
$L39894:
	mov	eax, DWORD PTR _i$39892[ebp]
	add	eax, 1
	mov	DWORD PTR _i$39892[ebp], eax
$L39893:
	mov	ecx, DWORD PTR _i$39892[ebp]
	cmp	ecx, DWORD PTR _numplanes$[ebp]
	jge	$L39895

; 1579 : 			float overbounce = SV_CalcOverBounce( pEntity, &trace );

	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_CalcOverBounce@@YAMPAVCBaseEntity@@PAUgametrace_s@@@Z ; SV_CalcOverBounce
	add	esp, 8
	fstp	DWORD PTR _overbounce$39896[ebp]

; 1580 : 
; 1581 : 			SV_ClipVelocity( original_velocity, planes[i], new_velocity, overbounce );

	mov	ecx, DWORD PTR _overbounce$39896[ebp]
	push	ecx
	lea	edx, DWORD PTR _new_velocity$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$39892[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _original_velocity$[ebp]
	push	edx
	call	?SV_ClipVelocity@@YAHABVVector@@0AAV1@M@Z ; SV_ClipVelocity
	add	esp, 16					; 00000010H

; 1582 : 
; 1583 : 			for( int j = 0; j < numplanes; j++ )

	mov	DWORD PTR _j$39897[ebp], 0
	jmp	SHORT $L39898
$L39899:
	mov	eax, DWORD PTR _j$39897[ebp]
	add	eax, 1
	mov	DWORD PTR _j$39897[ebp], eax
$L39898:
	mov	ecx, DWORD PTR _j$39897[ebp]
	cmp	ecx, DWORD PTR _numplanes$[ebp]
	jge	SHORT $L39900

; 1585 : 				if( j != i )

	mov	edx, DWORD PTR _j$39897[ebp]
	cmp	edx, DWORD PTR _i$39892[ebp]
	je	SHORT $L39902

; 1587 : 					if( DotProduct( new_velocity, planes[j] ) < 0.0f )

	mov	eax, DWORD PTR _j$39897[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _new_velocity$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39902

; 1588 : 						break; // not ok

	jmp	SHORT $L39900
$L39902:

; 1590 : 			}

	jmp	SHORT $L39899
$L39900:

; 1591 : 			if( j == numplanes )

	mov	eax, DWORD PTR _j$39897[ebp]
	cmp	eax, DWORD PTR _numplanes$[ebp]
	jne	SHORT $L39903

; 1592 : 				break;

	jmp	SHORT $L39895
$L39903:

; 1593 : 		}

	jmp	$L39894
$L39895:

; 1594 : 
; 1595 : 		if( i != numplanes )

	mov	ecx, DWORD PTR _i$39892[ebp]
	cmp	ecx, DWORD PTR _numplanes$[ebp]
	je	SHORT $L39904

; 1597 : 			// go along this plane
; 1598 : 			pEntity->SetAbsVelocity( new_velocity );

	lea	edx, DWORD PTR _new_velocity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1600 : 		else

	jmp	SHORT $L39905
$L39904:

; 1602 : 			// go along the crease
; 1603 : 			if( numplanes != 2 )

	cmp	DWORD PTR _numplanes$[ebp], 2
	je	SHORT $L39906

; 1605 : 				pEntity->SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1606 : 				break;

	jmp	$L39873
$L39906:

; 1608 : 
; 1609 : 			Vector dir = CrossProduct( planes[0], planes[1] );

	lea	eax, DWORD PTR _planes$[ebp+12]
	push	eax
	lea	ecx, DWORD PTR _planes$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41783[ebp]
	push	edx
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _dir$39907[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1610 : 			float d = DotProduct( dir, pEntity->GetAbsVelocity() );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	eax, DWORD PTR _dir$39907[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _d$39909[ebp]

; 1611 : 			pEntity->SetAbsVelocity( dir * d );

	mov	ecx, DWORD PTR _d$39909[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41784[ebp]
	push	edx
	lea	ecx, DWORD PTR _dir$39907[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L39905:

; 1613 : 
; 1614 : 		// if current velocity is against the original velocity,
; 1615 : 		// stop dead to avoid tiny occilations in sloping corners
; 1616 : 		if( DotProduct( pEntity->GetAbsVelocity(), primal_velocity ) <= 0.0f )

	lea	eax, DWORD PTR _primal_velocity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39911

; 1618 : 			pEntity->SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1619 : 			break;

	jmp	SHORT $L39873
$L39911:

; 1621 : 	}

	jmp	$L39872
$L39873:

; 1622 : 
; 1623 : 	if( allFraction == 0.0f )

	fld	DWORD PTR _allFraction$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39912

; 1624 : 		pEntity->SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L39912:

; 1625 : 
; 1626 : 	return blocked;

	mov	eax, DWORD PTR _blocked$[ebp]
$L39858:

; 1627 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_FlyMove@@YAHPAVCBaseEntity@@MPAUgametrace_s@@@Z ENDP ; SV_FlyMove
_TEXT	ENDS
;	COMDAT ?CrossProduct@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT
_a$ = 12
_b$ = 16
___$ReturnUdt$ = 8
$T41789 = -12
?CrossProduct@@YA?AVVector@@ABV1@0@Z PROC NEAR		; CrossProduct, COMDAT

; 291  : inline Vector CrossProduct( const Vector& a, const Vector& b ) { return Vector( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+4]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41789[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CrossProduct@@YA?AVVector@@ABV1@0@Z ENDP		; CrossProduct
_TEXT	ENDS
PUBLIC	?ClearGroundEntity@CBaseEntity@@QAEXXZ		; CBaseEntity::ClearGroundEntity
;	COMDAT ?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pentGround$ = 8
?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z PROC NEAR ; CBaseEntity::SetGroundEntity, COMDAT

; 611  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		if( pentGround != NULL )

	cmp	DWORD PTR _pentGround$[ebp], 0
	je	SHORT $L35070

; 614  : 			pev->groundentity = pentGround;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pentGround$[ebp]
	mov	DWORD PTR [ecx+412], edx

; 615  : 			pev->flags |= FL_ONGROUND;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	or	dh, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 617  : 		else ClearGroundEntity();

	jmp	SHORT $L35071
$L35070:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearGroundEntity@CBaseEntity@@QAEXXZ	; CBaseEntity::ClearGroundEntity
$L35071:

; 618  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z ENDP	; CBaseEntity::SetGroundEntity
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ClearGroundEntity@CBaseEntity@@QAEXXZ PROC NEAR	; CBaseEntity::ClearGroundEntity, COMDAT

; 631  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 632  : 		pev->groundentity = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+412], 0

; 633  : 		pev->flags &= ~FL_ONGROUND;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ch, -3					; fffffffdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx

; 634  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearGroundEntity@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::ClearGroundEntity
_TEXT	ENDS
PUBLIC	?SV_AddGravity@@YAXPAVCBaseEntity@@@Z		; SV_AddGravity
PUBLIC	??_C@_0L@GIJ@sv_gravity?$AA@			; `string'
;	COMDAT ??_C@_0L@GIJ@sv_gravity?$AA@
; File z:\xashxtsrc\server\physic.cpp
CONST	SEGMENT
??_C@_0L@GIJ@sv_gravity?$AA@ DB 'sv_gravity', 00H	; `string'
CONST	ENDS
;	COMDAT ?SV_AddGravity@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_ent_gravity$ = -4
_gravity$ = -8
_vecAbsVelocity$ = -20
?SV_AddGravity@@YAXPAVCBaseEntity@@@Z PROC NEAR		; SV_AddGravity, COMDAT

; 1636 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1637 : 	float	ent_gravity;
; 1638 : 
; 1639 : 	if( pEntity->pev->gravity )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+284]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39917

; 1640 : 		ent_gravity = pEntity->pev->gravity;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+284]
	mov	DWORD PTR _ent_gravity$[ebp], ecx

; 1641 : 	else ent_gravity = 1.0f; // factor

	jmp	SHORT $L39918
$L39917:
	mov	DWORD PTR _ent_gravity$[ebp], 1065353216 ; 3f800000H
$L39918:

; 1642 : 
; 1643 : 	float gravity = CVAR_GET_FLOAT( "sv_gravity" );

	push	OFFSET FLAT:??_C@_0L@GIJ@sv_gravity?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fstp	DWORD PTR _gravity$[ebp]

; 1644 : 	Vector vecAbsVelocity = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1645 : 
; 1646 : 	// add gravity incorrectly
; 1647 : 	vecAbsVelocity.z -= ( ent_gravity * gravity * gpGlobals->frametime );

	fld	DWORD PTR _ent_gravity$[ebp]
	fmul	DWORD PTR _gravity$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fmul	DWORD PTR [edx+4]
	fsubr	DWORD PTR _vecAbsVelocity$[ebp+8]
	fstp	DWORD PTR _vecAbsVelocity$[ebp+8]

; 1648 : 	vecAbsVelocity.z += pEntity->pev->basevelocity[2] * gpGlobals->frametime;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 44					; 0000002cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+4]
	fadd	DWORD PTR _vecAbsVelocity$[ebp+8]
	fstp	DWORD PTR _vecAbsVelocity$[ebp+8]

; 1649 : 	pEntity->pev->basevelocity[2] = 0.0f;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 44					; 0000002cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 1650 : 	pEntity->SetAbsVelocity( vecAbsVelocity );

	lea	eax, DWORD PTR _vecAbsVelocity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1651 : 
; 1652 : 	// bound velocity
; 1653 : 	SV_CheckVelocity( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z ; SV_CheckVelocity
	add	esp, 4

; 1654 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_AddGravity@@YAXPAVCBaseEntity@@@Z ENDP		; SV_AddGravity
_TEXT	ENDS
PUBLIC	?SV_AddHalfGravity@@YAXPAVCBaseEntity@@M@Z	; SV_AddHalfGravity
;	COMDAT ?SV_AddHalfGravity@@YAXPAVCBaseEntity@@M@Z
_TEXT	SEGMENT
_pEntity$ = 8
_timestep$ = 12
_ent_gravity$ = -4
_gravity$ = -8
_vecAbsVelocity$ = -20
?SV_AddHalfGravity@@YAXPAVCBaseEntity@@M@Z PROC NEAR	; SV_AddHalfGravity, COMDAT

; 1663 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1664 : 	float	ent_gravity;
; 1665 : 
; 1666 : 	if( pEntity->pev->gravity )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+284]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39927

; 1667 : 		ent_gravity = pEntity->pev->gravity;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+284]
	mov	DWORD PTR _ent_gravity$[ebp], ecx

; 1668 : 	else ent_gravity = 1.0f;

	jmp	SHORT $L39928
$L39927:
	mov	DWORD PTR _ent_gravity$[ebp], 1065353216 ; 3f800000H
$L39928:

; 1669 : 
; 1670 : 	float gravity = CVAR_GET_FLOAT( "sv_gravity" );

	push	OFFSET FLAT:??_C@_0L@GIJ@sv_gravity?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fstp	DWORD PTR _gravity$[ebp]

; 1671 : 	Vector vecAbsVelocity = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1672 : 
; 1673 : 	// Add 1/2 of the total gravitational effects over this timestep
; 1674 : 	vecAbsVelocity.z -= ( 0.5f * ent_gravity * gravity * timestep );

	fld	DWORD PTR __real@4@3ffe8000000000000000
	fmul	DWORD PTR _ent_gravity$[ebp]
	fmul	DWORD PTR _gravity$[ebp]
	fmul	DWORD PTR _timestep$[ebp]
	fsubr	DWORD PTR _vecAbsVelocity$[ebp+8]
	fstp	DWORD PTR _vecAbsVelocity$[ebp+8]

; 1675 : 	vecAbsVelocity.z += pEntity->pev->basevelocity.z * gpGlobals->frametime;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+52]
	fmul	DWORD PTR [ecx+4]
	fadd	DWORD PTR _vecAbsVelocity$[ebp+8]
	fstp	DWORD PTR _vecAbsVelocity$[ebp+8]

; 1676 : 	pEntity->pev->basevelocity.z = 0.0f;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+52], 0

; 1677 : 	pEntity->SetAbsVelocity( vecAbsVelocity );

	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1678 : 	
; 1679 : 	// bound velocity
; 1680 : 	SV_CheckVelocity( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z ; SV_CheckVelocity
	add	esp, 4

; 1681 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_AddHalfGravity@@YAXPAVCBaseEntity@@M@Z ENDP		; SV_AddHalfGravity
_TEXT	ENDS
PUBLIC	??0gametrace_s@@QAE@ABU0@@Z			; gametrace_s::gametrace_s
PUBLIC	?SV_PushEntity@@YA?AUgametrace_s@@PAVCBaseEntity@@ABVVector@@1PAH@Z ; SV_PushEntity
;	COMDAT ?SV_PushEntity@@YA?AUgametrace_s@@PAVCBaseEntity@@ABVVector@@1PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_trace$ = -56
_start$ = -68
_end$ = -80
_vecAngles$39945 = -92
$T41800 = -104
_pEntity$ = 12
_lpush$ = 16
_apush$ = 20
_blocked$ = 24
?SV_PushEntity@@YA?AUgametrace_s@@PAVCBaseEntity@@ABVVector@@1PAH@Z PROC NEAR ; SV_PushEntity, COMDAT

; 1691 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi

; 1692 : 	TraceResult trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1693 : 	Vector start = pEntity->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _start$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1694 : 	Vector end = start + lpush;

	mov	eax, DWORD PTR _lpush$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41800[ebp]
	push	ecx
	lea	ecx, DWORD PTR _start$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _end$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1695 : 
; 1696 : 	UTIL_TraceEntity( pEntity, pEntity->GetAbsOrigin(), end, &trace );

	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	lea	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?UTIL_TraceEntity@@YAXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z ; UTIL_TraceEntity
	add	esp, 16					; 00000010H

; 1697 : 
; 1698 : 	if( trace.flFraction != 0.0f )

	fld	DWORD PTR _trace$[ebp+16]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L39946

; 1700 : 		pEntity->SetAbsOrigin( trace.vecEndPos );

	lea	edx, DWORD PTR _trace$[ebp+20]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 1701 : 
; 1702 : 		if( apush[YAW] && pEntity->IsNetClient( ))

	mov	ecx, DWORD PTR _apush$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39943
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+228]
	test	eax, eax
	je	SHORT $L39943

; 1704 : 			pEntity->pev->avelocity[YAW] += apush[YAW];

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 4
	mov	DWORD PTR -108+[ebp], eax
	mov	ecx, DWORD PTR _apush$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR -108+[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [eax+4]
	mov	edx, DWORD PTR -108+[ebp]
	fstp	DWORD PTR [edx]

; 1705 : 			pEntity->pev->fixangle = 2;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+160], 2
$L39943:

; 1707 : 
; 1708 : 		// don't rotate pushables!
; 1709 : 		if( SV_AllowPushRotate( pEntity ))

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_AllowPushRotate@@YAHPAVCBaseEntity@@@Z ; SV_AllowPushRotate
	add	esp, 4
	test	eax, eax
	je	$L39946

; 1711 : 			Vector vecAngles = pEntity->GetAbsAngles();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _vecAngles$39945[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1712 : 			vecAngles[YAW] += trace.flFraction * apush[YAW];

	lea	ecx, DWORD PTR _vecAngles$39945[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	add	eax, 4
	mov	DWORD PTR -112+[ebp], eax
	mov	ecx, DWORD PTR _apush$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR _trace$[ebp+16]
	fmul	DWORD PTR [eax+4]
	mov	eax, DWORD PTR -112+[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR -112+[ebp]
	fstp	DWORD PTR [ecx]

; 1713 : 			pEntity->SetAbsAngles( vecAngles );

	lea	edx, DWORD PTR _vecAngles$39945[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 1714 : 
; 1715 : 			// keep gait yaw is actual
; 1716 : 			if( pEntity->IsPlayer( ) && apush[YAW] != 0.0f )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L39946
	mov	ecx, DWORD PTR _apush$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39946

; 1717 : 				pEntity->m_flGaitYaw = pEntity->pev->angles[YAW];

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 80					; 00000050H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+48], edx
$L39946:

; 1720 : 
; 1721 : 	// notsolid ents never touch triggers
; 1722 : 	pEntity->RelinkEntity( (pEntity->pev->solid == SOLID_NOT) ? FALSE : TRUE, &start );

	push	0
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	cmp	DWORD PTR [edx+268], 0
	setne	al
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 1723 : 
; 1724 : 	if( blocked )

	cmp	DWORD PTR _blocked$[ebp], 0
	je	SHORT $L39947

; 1726 : 		// can't move full distance
; 1727 : 		*blocked = ( pEntity->GetAbsOrigin() != end ) ? TRUE : FALSE;

	lea	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	edx, DWORD PTR _blocked$[ebp]
	mov	DWORD PTR [edx], eax
$L39947:

; 1729 : 
; 1730 : 	// so we can run impact function afterwards.
; 1731 : 	if( trace.pHit ) SV_Impact( pEntity, NULL, &trace );

	cmp	DWORD PTR _trace$[ebp+48], 0
	je	SHORT $L39948
	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_Impact@@YAXPAVCBaseEntity@@0PAUgametrace_s@@@Z ; SV_Impact
	add	esp, 12					; 0000000cH
$L39948:

; 1732 : 
; 1733 : 	return trace;

	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0gametrace_s@@QAE@ABU0@@Z		; gametrace_s::gametrace_s
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1734 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_PushEntity@@YA?AUgametrace_s@@PAVCBaseEntity@@ABVVector@@1PAH@Z ENDP ; SV_PushEntity
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0gametrace_s@@QAE@ABU0@@Z PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+52], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0gametrace_s@@QAE@ABU0@@Z ENDP			; gametrace_s::gametrace_s
_TEXT	ENDS
PUBLIC	?SV_Physics_None@@YAXPAVCBaseEntity@@@Z		; SV_Physics_None
;	COMDAT ?SV_Physics_None@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
?SV_Physics_None@@YAXPAVCBaseEntity@@@Z PROC NEAR	; SV_Physics_None, COMDAT

; 1744 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1745 : 	if( !SV_RunThink( pEntity ))

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_RunThink@@YAHPAVCBaseEntity@@@Z	; SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39955

; 1746 : 		return;

	jmp	SHORT $L39954
$L39955:

; 1747 : 
; 1748 : 	if( pEntity->m_hParent )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39956

; 1749 : 		pEntity->RelinkEntity( TRUE );

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity
$L39956:
$L39954:

; 1750 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_Physics_None@@YAXPAVCBaseEntity@@@Z ENDP		; SV_Physics_None
_TEXT	ENDS
PUBLIC	?SV_Physics_Rigid@@YAXPAVCBaseEntity@@@Z	; SV_Physics_Rigid
PUBLIC	??HVector@@QBE?AV0@M@Z				; Vector::operator+
PUBLIC	??GVector@@QBE?AV0@M@Z				; Vector::operator-
EXTRN	?UTIL_WaterMove@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_WaterMove
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
;	COMDAT ?SV_Physics_Rigid@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_pGround$ = -4
_trace$ = -60
_vecPos$ = -72
_vecEnd$ = -84
$T41807 = -96
$T41808 = -108
?SV_Physics_Rigid@@YAXPAVCBaseEntity@@@Z PROC NEAR	; SV_Physics_Rigid, COMDAT

; 1760 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi

; 1761 : 	if( !SV_RunThink( pEntity ))

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_RunThink@@YAHPAVCBaseEntity@@@Z	; SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39960

; 1762 : 		return;

	jmp	$L39959
$L39960:

; 1763 : 
; 1764 : 	UTIL_WaterMove( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?UTIL_WaterMove@@YAXPAVCBaseEntity@@@Z	; UTIL_WaterMove
	add	esp, 4

; 1765 : 	SV_CheckWater( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_CheckWater@@YAHPAVCBaseEntity@@@Z	; SV_CheckWater
	add	esp, 4

; 1766 : 	WorldPhysic->UpdateEntityPos( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+116]

; 1767 : 
; 1768 : 	// detect the ground
; 1769 : 	CBaseEntity *pGround = pEntity->GetGroundEntity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ; CBaseEntity::GetGroundEntity
	mov	DWORD PTR _pGround$[ebp], eax

; 1770 : 
; 1771 : 	if( pEntity->GetAbsVelocity().z > 0.0f || pGround == NULL || (pGround->pev->flags & ( FL_MONSTER|FL_CLIENT )))

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39963
	cmp	DWORD PTR _pGround$[ebp], 0
	je	SHORT $L39963
	mov	eax, DWORD PTR _pGround$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 40					; 00000028H
	test	edx, edx
	je	SHORT $L39962
$L39963:

; 1773 : 		pEntity->pev->flags &= ~FL_ONGROUND;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	dh, -3					; fffffffdH
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx
$L39962:

; 1775 : 
; 1776 : 	if( pEntity->m_iFlags & MF_GROUNDMOVE )

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 4
	test	eax, eax
	je	SHORT $L39964

; 1778 : 		pEntity->ClearGroundEntity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?ClearGroundEntity@CBaseEntity@@QAEXXZ	; CBaseEntity::ClearGroundEntity

; 1779 : 		pEntity->m_iFlags &= ~MF_GROUNDMOVE;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [eax+24], edx
$L39964:

; 1781 : 
; 1782 : 	// if on ground or not moving, return.
; 1783 : 	if( pEntity->pev->flags & FL_ONGROUND || WorldPhysic->IsBodySleeping( pEntity ))

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 512				; 00000200H
	test	eax, eax
	jne	SHORT $L39966
	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [eax+168]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L39965
$L39966:

; 1785 : 		if( pGround && FBitSet( pGround->pev->flags, FL_CONVEYOR ) && pGround->pev->speed && WorldPhysic->IsBodySleeping( pEntity ))

	cmp	DWORD PTR _pGround$[ebp], 0
	je	SHORT $L39967
	mov	ecx, DWORD PTR _pGround$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 4
	test	eax, eax
	je	SHORT $L39967
	mov	ecx, DWORD PTR _pGround$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39967
	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+168]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L39967

; 1787 : 			// wake up body if conveyor was enabled (add light kick)
; 1788 : 			WorldPhysic->AddForce( pEntity, pGround->pev->movedir );

	mov	eax, DWORD PTR _pGround$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+88]
$L39967:

; 1790 : 		return;	// at rest

	jmp	$L39959
$L39965:

; 1792 : 
; 1793 : 	TraceResult trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1794 : 	Vector vecPos = pEntity->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecPos$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1795 : 	Vector vecEnd = vecPos + pEntity->pev->mins.z - 1.0f;

	push	1065353216				; 3f800000H
	lea	eax, DWORD PTR $T41808[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+228]
	push	eax
	lea	ecx, DWORD PTR $T41807[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecPos$[ebp]
	call	??HVector@@QBE?AV0@M@Z			; Vector::operator+
	mov	ecx, eax
	call	??GVector@@QBE?AV0@M@Z			; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1796 : 
; 1797 : 	UTIL_TraceLine( vecPos, vecEnd, ignore_monsters, pEntity->edict() ,&trace );

	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecPos$[ebp]
	push	ecx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 1798 : 
; 1799 : 	if( trace.vecPlaneNormal[2] > 0.7f )

	lea	ecx, DWORD PTR _trace$[ebp+36]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@3ffeb333330000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39973

; 1800 : 		pEntity->SetGroundEntity( trace.pHit ? trace.pHit : ENT( 0 ));

	cmp	DWORD PTR _trace$[ebp+48], 0
	je	SHORT $L41809
	mov	edx, DWORD PTR _trace$[ebp+48]
	mov	DWORD PTR -112+[ebp], edx
	jmp	SHORT $L41810
$L41809:
	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR -112+[ebp], eax
$L41810:
	mov	eax, DWORD PTR -112+[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z ; CBaseEntity::SetGroundEntity
$L39973:
$L39959:

; 1801 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_Physics_Rigid@@YAXPAVCBaseEntity@@@Z ENDP		; SV_Physics_Rigid
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T41813 = -16
??HVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator+, COMDAT

; 151  : 	inline Vector operator+(float fl) const		{ return Vector(x+fl, y+fl, z+fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fadd	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fadd	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41813[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@M@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T41816 = -16
??GVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator-, COMDAT

; 152  : 	inline Vector operator-(float fl) const		{ return Vector(x-fl, y-fl, z-fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR _fl$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _fl$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR _fl$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41816[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@M@Z ENDP				; Vector::operator-
_TEXT	ENDS
PUBLIC	?SV_Physics_Noclip@@YAXPAVCBaseEntity@@@Z	; SV_Physics_Noclip
;	COMDAT ?SV_Physics_Noclip@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
?SV_Physics_Noclip@@YAXPAVCBaseEntity@@@Z PROC NEAR	; SV_Physics_Noclip, COMDAT

; 1811 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1812 : 	// regular thinking
; 1813 : 	if( !SV_RunThink( pEntity )) return;

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_RunThink@@YAHPAVCBaseEntity@@@Z	; SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39977
	jmp	SHORT $L39976
$L39977:

; 1814 : 
; 1815 : 	SV_CheckWater( pEntity );	

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_CheckWater@@YAHPAVCBaseEntity@@@Z	; SV_CheckWater
	add	esp, 4

; 1816 : 
; 1817 : 	SV_LinearMove( pEntity, gpGlobals->frametime, pEntity->pev->friction );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+288]
	push	ecx
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_LinearMove@@YAXPAVCBaseEntity@@MM@Z	; SV_LinearMove
	add	esp, 12					; 0000000cH

; 1818 : 	SV_AngularMove( pEntity, gpGlobals->frametime, pEntity->pev->friction );

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+288]
	push	ecx
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_AngularMove@@YAXPAVCBaseEntity@@MM@Z ; SV_AngularMove
	add	esp, 12					; 0000000cH

; 1819 : 
; 1820 : 	// noclip ents never touch triggers
; 1821 : 	pEntity->RelinkEntity( FALSE );

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity
$L39976:

; 1822 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_Physics_Noclip@@YAXPAVCBaseEntity@@@Z ENDP		; SV_Physics_Noclip
_TEXT	ENDS
PUBLIC	?SV_Physics_Follow@@YAXPAVCBaseEntity@@@Z	; SV_Physics_Follow
;	COMDAT ?SV_Physics_Follow@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_pParent$ = -4
$T41821 = -16
?SV_Physics_Follow@@YAXPAVCBaseEntity@@@Z PROC NEAR	; SV_Physics_Follow, COMDAT

; 1832 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1833 : 	CBaseEntity *pParent;
; 1834 : 
; 1835 : 	// regular thinking
; 1836 : 	if( !SV_RunThink( pEntity )) return;

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_RunThink@@YAHPAVCBaseEntity@@@Z	; SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39982
	jmp	SHORT $L39980
$L39982:

; 1837 : 
; 1838 : 	pParent = CBaseEntity::Instance( pEntity->pev->aiment );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+404]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pParent$[ebp], eax

; 1839 : 	if( !pParent ) return;

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L39983
	jmp	SHORT $L39980
$L39983:

; 1840 : 
; 1841 : 	pEntity->pev->v_angle = pParent->EyePosition();

	lea	ecx, DWORD PTR $T41821[ebp]
	push	ecx
	mov	edx, DWORD PTR _pParent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pParent$[ebp]
	call	DWORD PTR [eax+308]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 116				; 00000074H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1842 : 	pEntity->SetAbsAngles( pParent->GetAbsAngles());

	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 1843 : 
; 1844 : 	pEntity->RelinkEntity();

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity
$L39980:

; 1845 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_Physics_Follow@@YAXPAVCBaseEntity@@@Z ENDP		; SV_Physics_Follow
_TEXT	ENDS
PUBLIC	?SV_Physics_Compound@@YAXPAVCBaseEntity@@@Z	; SV_Physics_Compound
EXTRN	?SetParent@CBaseEntity@@QAEXPAV1@H@Z:NEAR	; CBaseEntity::SetParent
;	COMDAT ?SV_Physics_Compound@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_pParent$ = -4
?SV_Physics_Compound@@YAXPAVCBaseEntity@@@Z PROC NEAR	; SV_Physics_Compound, COMDAT

; 1855 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1856 : 	// regular thinking
; 1857 : 	if( !SV_RunThink( pEntity )) return;

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_RunThink@@YAHPAVCBaseEntity@@@Z	; SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39988
	jmp	SHORT $L39987
$L39988:

; 1858 : 
; 1859 : 	CBaseEntity *pParent = CBaseEntity :: Instance( pEntity->pev->aiment );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+404]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pParent$[ebp], eax

; 1860 : 	if( !pParent ) return;

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L39990
	jmp	SHORT $L39987
$L39990:

; 1861 : 
; 1862 : 	// not initialized ?
; 1863 : 	if( pEntity->m_hParent != pParent )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	cmp	eax, DWORD PTR _pParent$[ebp]
	je	SHORT $L39991

; 1865 : 		if( pEntity->pev->solid != SOLID_TRIGGER )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 1
	je	SHORT $L39992

; 1866 : 			pEntity->pev->solid = SOLID_NOT;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 0
$L39992:

; 1867 : 		pEntity->SetParent( pParent );

	push	0
	mov	edx, DWORD PTR _pParent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetParent@CBaseEntity@@QAEXPAV1@H@Z	; CBaseEntity::SetParent
$L39991:
$L39987:

; 1869 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_Physics_Compound@@YAXPAVCBaseEntity@@@Z ENDP	; SV_Physics_Compound
_TEXT	ENDS
PUBLIC	?SV_Physics_Toss@@YAXPAVCBaseEntity@@@Z		; SV_Physics_Toss
PUBLIC	??ZVector@@QAEAAV0@ABV0@@Z			; Vector::operator-=
PUBLIC	__real@4@40008000000000000000
PUBLIC	__real@4@4008e100000000000000
PUBLIC	__real@4@3ffee666660000000000
;	COMDAT __real@4@40008000000000000000
; File z:\xashxtsrc\server\physic.cpp
CONST	SEGMENT
__real@4@40008000000000000000 DD 040000000r	; 2
CONST	ENDS
;	COMDAT __real@4@4008e100000000000000
CONST	SEGMENT
__real@4@4008e100000000000000 DD 044610000r	; 900
CONST	ENDS
;	COMDAT __real@4@3ffee666660000000000
CONST	SEGMENT
__real@4@3ffee666660000000000 DD 03f666666r	; 0.9
CONST	ENDS
;	COMDAT ?SV_Physics_Toss@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_trace$ = -56
_move$ = -68
_backoff$ = -72
_ed$ = -76
_pGround$ = -80
_vecAbsVelocity$ = -92
_gravity$40034 = -96
_vel$40035 = -100
$T41826 = -112
$T41827 = -168
$T41828 = -180
$T41829 = -192
$T41830 = -204
$T41831 = -260
?SV_Physics_Toss@@YAXPAVCBaseEntity@@@Z PROC NEAR	; SV_Physics_Toss, COMDAT

; 1879 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	push	ebx
	push	esi
	push	edi

; 1880 : 	TraceResult	trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1881 : 	Vector		move;

	lea	ecx, DWORD PTR _move$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1882 : 	float		backoff;
; 1883 : 	edict_t		*ed = pEntity->edict();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _ed$[ebp], eax

; 1884 : 
; 1885 : 	SV_CheckWater( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_CheckWater@@YAHPAVCBaseEntity@@@Z	; SV_CheckWater
	add	esp, 4

; 1886 : 	
; 1887 : 	// regular thinking
; 1888 : 	if( !SV_RunThink( pEntity )) return;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_RunThink@@YAHPAVCBaseEntity@@@Z	; SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40000
	jmp	$L39995
$L40000:

; 1889 : 
; 1890 : 	CBaseEntity *pGround = pEntity->GetGroundEntity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ; CBaseEntity::GetGroundEntity
	mov	DWORD PTR _pGround$[ebp], eax

; 1891 : 
; 1892 : 	if( pEntity->GetAbsVelocity().z > 0.0f || pGround == NULL || (pGround->pev->flags & ( FL_MONSTER|FL_CLIENT )))

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40003
	cmp	DWORD PTR _pGround$[ebp], 0
	je	SHORT $L40003
	mov	edx, DWORD PTR _pGround$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 40					; 00000028H
	test	ecx, ecx
	je	SHORT $L40002
$L40003:

; 1894 : 		pEntity->pev->flags &= ~FL_ONGROUND;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ch, -3					; fffffffdH
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx
$L40002:

; 1896 : 
; 1897 : 	if( pEntity->m_iFlags & MF_GROUNDMOVE )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	and	edx, 4
	test	edx, edx
	je	SHORT $L40004

; 1899 : 		pEntity->ClearGroundEntity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?ClearGroundEntity@CBaseEntity@@QAEXXZ	; CBaseEntity::ClearGroundEntity

; 1900 : 		pEntity->m_iFlags &= ~MF_GROUNDMOVE;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [edx+24], ecx
$L40004:

; 1902 : 
; 1903 : 	// if on ground and not moving, return.
; 1904 : 	if( pEntity->pev->flags & FL_ONGROUND && pEntity->GetAbsVelocity() == g_vecZero )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	SHORT $L40006
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L40006

; 1906 : 		pEntity->SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 1907 : 
; 1908 : 		if( pEntity->pev->basevelocity == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 44					; 0000002cH
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L40006

; 1909 : 			return;	// at rest

	jmp	$L39995
$L40006:

; 1911 : 
; 1912 : 	SV_CheckVelocity( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z ; SV_CheckVelocity
	add	esp, 4

; 1916 : 	{

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+264]
	mov	DWORD PTR -264+[ebp], ecx
	cmp	DWORD PTR -264+[ebp], 5
	je	SHORT $L40011
	cmp	DWORD PTR -264+[ebp], 9
	je	SHORT $L40011
	cmp	DWORD PTR -264+[ebp], 11		; 0000000bH
	je	SHORT $L40011
	jmp	SHORT $L40012
$L40011:

; 1917 : 	case MOVETYPE_FLY:
; 1918 : 	case MOVETYPE_FLYMISSILE:
; 1919 : 	case MOVETYPE_BOUNCEMISSILE:
; 1920 : 		break;

	jmp	SHORT $L40008
$L40012:

; 1921 : 	default:
; 1922 : 		SV_AddGravity( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_AddGravity@@YAXPAVCBaseEntity@@@Z	; SV_AddGravity
	add	esp, 4
$L40008:

; 1928 : 	{

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+264]
	mov	DWORD PTR -268+[ebp], edx
	cmp	DWORD PTR -268+[ebp], 6
	je	SHORT $L40017
	cmp	DWORD PTR -268+[ebp], 10		; 0000000aH
	je	SHORT $L40017
	jmp	SHORT $L40018
$L40017:

; 1929 : 	case MOVETYPE_TOSS:
; 1930 : 	case MOVETYPE_BOUNCE:
; 1931 : 		SV_AngularMove( pEntity, gpGlobals->frametime, pEntity->pev->friction );

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+288]
	push	edx
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_AngularMove@@YAXPAVCBaseEntity@@MM@Z ; SV_AngularMove
	add	esp, 12					; 0000000cH

; 1932 : 		break;         

	jmp	SHORT $L40014
$L40018:

; 1933 : 	default:
; 1934 : 		SV_AngularMove( pEntity, gpGlobals->frametime, 0.0f );

	push	0
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_AngularMove@@YAXPAVCBaseEntity@@MM@Z ; SV_AngularMove
	add	esp, 12					; 0000000cH
$L40014:

; 1937 : 
; 1938 : 	// move origin
; 1939 : 	// Base velocity is not properly accounted for since this entity will move again
; 1940 : 	// after the bounce without taking it into account
; 1941 : 	Vector vecAbsVelocity = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1942 : 	vecAbsVelocity += pEntity->GetBaseVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetBaseVelocity
	push	eax
	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1943 : 	pEntity->SetAbsVelocity( vecAbsVelocity );

	lea	eax, DWORD PTR _vecAbsVelocity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1944 : 
; 1945 : 	SV_CheckVelocity( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z ; SV_CheckVelocity
	add	esp, 4

; 1946 : 
; 1947 : 	move = pEntity->GetAbsVelocity() * gpGlobals->frametime;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR $T41826[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _move$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _move$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _move$[ebp+8], edx

; 1948 : 
; 1949 : 	vecAbsVelocity = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecAbsVelocity$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecAbsVelocity$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecAbsVelocity$[ebp+8], eax

; 1950 : 	vecAbsVelocity -= pEntity->GetBaseVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetBaseVelocity
	push	eax
	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=

; 1951 : 	pEntity->SetAbsVelocity( vecAbsVelocity );

	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1952 : 
; 1953 : 	trace = SV_PushEntity( pEntity, move, g_vecZero, NULL );

	push	0
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	edx, DWORD PTR _move$[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T41827[ebp]
	push	ecx
	call	?SV_PushEntity@@YA?AUgametrace_s@@PAVCBaseEntity@@ABVVector@@1PAH@Z ; SV_PushEntity
	add	esp, 20					; 00000014H
	mov	esi, eax
	mov	ecx, 14					; 0000000eH
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1954 : 	if( ed->free || pEntity->pev->flags & FL_KILLME ) return;

	mov	edx, DWORD PTR _ed$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L40023
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 1073741824				; 40000000H
	test	edx, edx
	je	SHORT $L40022
$L40023:
	jmp	$L39995
$L40022:

; 1955 : 
; 1956 : 	SV_CheckVelocity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z ; SV_CheckVelocity
	add	esp, 4

; 1957 : 
; 1958 : 	if( trace.fAllSolid )

	cmp	DWORD PTR _trace$[ebp], 0
	je	SHORT $L40024

; 1960 : 		if( pEntity->m_iActorType == ACTOR_CHARACTER )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+1604]
	cmp	edx, 3
	jne	SHORT $L40025

; 1961 : 			WorldPhysic->MoveCharacter( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+152]
$L40025:

; 1962 : 
; 1963 : 		// entity is trapped in another solid
; 1964 : 		pEntity->SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 1965 : 		pEntity->SetLocalVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 1966 : 		return;

	jmp	$L39995
$L40024:

; 1968 : 
; 1969 : 	if( trace.flFraction == 1.0f )

	cmp	DWORD PTR _trace$[ebp+16], 1065353216	; 3f800000H
	jne	SHORT $L40026

; 1971 : 		if( pEntity->m_iActorType == ACTOR_CHARACTER )

	mov	eax, DWORD PTR _pEntity$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	cmp	ecx, 3
	jne	SHORT $L40027

; 1972 : 			WorldPhysic->MoveCharacter( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+152]
$L40027:

; 1973 : 
; 1974 : 		SV_CheckWaterTransition( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_CheckWaterTransition@@YAXPAVCBaseEntity@@@Z ; SV_CheckWaterTransition
	add	esp, 4

; 1975 : 		return;

	jmp	$L39995
$L40026:

; 1977 : 
; 1978 : 	if( pEntity->pev->movetype == MOVETYPE_BOUNCE )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 10			; 0000000aH
	jne	SHORT $L40028

; 1979 : 		backoff = 2.0f - pEntity->pev->friction;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR __real@4@40008000000000000000
	fsub	DWORD PTR [ecx+288]
	fstp	DWORD PTR _backoff$[ebp]

; 1980 : 	else if( pEntity->pev->movetype == MOVETYPE_BOUNCEMISSILE )

	jmp	SHORT $L40031
$L40028:
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+264], 11			; 0000000bH
	jne	SHORT $L40030

; 1981 : 		backoff = 2.0f;

	mov	DWORD PTR _backoff$[ebp], 1073741824	; 40000000H

; 1982 : 	else backoff = 1.0f;

	jmp	SHORT $L40031
$L40030:
	mov	DWORD PTR _backoff$[ebp], 1065353216	; 3f800000H
$L40031:

; 1983 : 
; 1984 : 	vecAbsVelocity = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecAbsVelocity$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecAbsVelocity$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecAbsVelocity$[ebp+8], eax

; 1985 : 	SV_ClipVelocity( vecAbsVelocity, trace.vecPlaneNormal, vecAbsVelocity, backoff );

	mov	ecx, DWORD PTR _backoff$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecAbsVelocity$[ebp]
	push	edx
	lea	eax, DWORD PTR _trace$[ebp+36]
	push	eax
	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	push	ecx
	call	?SV_ClipVelocity@@YAHABVVector@@0AAV1@M@Z ; SV_ClipVelocity
	add	esp, 16					; 00000010H

; 1986 : 	pEntity->SetAbsVelocity( vecAbsVelocity );

	lea	edx, DWORD PTR _vecAbsVelocity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1987 : 
; 1988 : 	// stop if on ground
; 1989 : 	if( trace.vecPlaneNormal[2] > 0.7f )

	lea	ecx, DWORD PTR _trace$[ebp+36]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@3ffeb333330000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L40043

; 1991 : 		move = pEntity->GetAbsVelocity() + pEntity->GetBaseVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetBaseVelocity
	push	eax
	lea	eax, DWORD PTR $T41828[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _move$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _move$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _move$[ebp+8], eax

; 1992 : 
; 1993 : 		float gravity = CVAR_GET_FLOAT( "sv_gravity" );

	push	OFFSET FLAT:??_C@_0L@GIJ@sv_gravity?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fstp	DWORD PTR _gravity$40034[ebp]

; 1994 : 		float vel = DotProduct( move, move );

	lea	ecx, DWORD PTR _move$[ebp]
	push	ecx
	lea	edx, DWORD PTR _move$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _vel$40035[ebp]

; 1995 : 
; 1996 : 		if( pEntity->GetAbsVelocity().z < gravity * gpGlobals->frametime )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _gravity$40034[ebp]
	fmul	DWORD PTR [ecx+4]
	fcomp	DWORD PTR [eax+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40036

; 1998 : 			// we're rolling on the ground, add static friction.
; 1999 : 			pEntity->SetGroundEntity( trace.pHit );

	mov	edx, DWORD PTR _trace$[ebp+48]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z ; CBaseEntity::SetGroundEntity

; 2000 : 			vecAbsVelocity = pEntity->GetAbsVelocity();			

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecAbsVelocity$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecAbsVelocity$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecAbsVelocity$[ebp+8], eax

; 2001 : 			vecAbsVelocity.z = 0.0f;

	mov	DWORD PTR _vecAbsVelocity$[ebp+8], 0

; 2002 : 			pEntity->SetAbsVelocity( vecAbsVelocity );

	lea	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L40036:

; 2004 : 
; 2005 : 		if( vel < 900.0f || ( pEntity->pev->movetype != MOVETYPE_BOUNCE && pEntity->pev->movetype != MOVETYPE_BOUNCEMISSILE ))

	fld	DWORD PTR _vel$40035[ebp]
	fcomp	DWORD PTR __real@4@4008e100000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40038
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+264], 10			; 0000000aH
	je	SHORT $L40037
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 11			; 0000000bH
	je	SHORT $L40037
$L40038:

; 2007 : 			pEntity->SetGroundEntity( trace.pHit );

	mov	eax, DWORD PTR _trace$[ebp+48]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z ; CBaseEntity::SetGroundEntity

; 2008 : 			pEntity->SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 2009 : 			pEntity->SetLocalVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 2011 : 		else

	jmp	$L40043
$L40037:

; 2013 : 			move = pEntity->GetAbsVelocity() * ((1.0f - trace.flFraction) * gpGlobals->frametime * 0.9f);

	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _trace$[ebp+16]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fmul	DWORD PTR [ecx+4]
	fmul	DWORD PTR __real@4@3ffee666660000000000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR $T41829[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _move$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _move$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _move$[ebp+8], eax

; 2014 : 			move += pEntity->GetBaseVelocity() * ((1.0f - trace.flFraction) * gpGlobals->frametime * 0.9f);

	fld	DWORD PTR __real@4@3fff8000000000000000
	fsub	DWORD PTR _trace$[ebp+16]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fmul	DWORD PTR [ecx+4]
	fmul	DWORD PTR __real@4@3ffee666660000000000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR $T41830[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetBaseVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _move$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2015 : 			trace = SV_PushEntity( pEntity, move, g_vecZero, NULL );

	push	0
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	eax, DWORD PTR _move$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41831[ebp]
	push	edx
	call	?SV_PushEntity@@YA?AUgametrace_s@@PAVCBaseEntity@@ABVVector@@1PAH@Z ; SV_PushEntity
	add	esp, 20					; 00000014H
	mov	esi, eax
	mov	ecx, 14					; 0000000eH
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 2016 : 			if( ed->free ) return;

	mov	eax, DWORD PTR _ed$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L40043
	jmp	SHORT $L39995
$L40043:

; 2019 : 
; 2020 : 	if( pEntity->m_iActorType == ACTOR_CHARACTER )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+1604]
	cmp	edx, 3
	jne	SHORT $L40044

; 2021 : 		WorldPhysic->MoveCharacter( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+152]
$L40044:

; 2022 : 	
; 2023 : 	// check for in water
; 2024 : 	SV_CheckWaterTransition( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_CheckWaterTransition@@YAXPAVCBaseEntity@@@Z ; SV_CheckWaterTransition
	add	esp, 4
$L39995:

; 2025 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_Physics_Toss@@YAXPAVCBaseEntity@@@Z ENDP		; SV_Physics_Toss
_TEXT	ENDS
;	COMDAT ??ZVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??ZVector@@QAEAAV0@ABV0@@Z PROC NEAR			; Vector::operator-=, COMDAT

; 164  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		x-=v.x; y-=v.y; z -= v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 166  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 167  : 	}		

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??ZVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator-=
_TEXT	ENDS
;	COMDAT _$E29
_TEXT	SEGMENT
_$E29	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E26
	call	_$E28
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E29	ENDP
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >
;	COMDAT _$E26
_TEXT	SEGMENT
_$E26	PROC NEAR					; COMDAT

; 2027 : CUtlArray<CBaseEntity*>	m_rgGroundEnts;

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	push	0
	mov	ecx, OFFSET FLAT:?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A
	call	??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E26	ENDP
_TEXT	ENDS
;	COMDAT _$E28
_TEXT	SEGMENT
_$E28	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:_$E27
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E28	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::~CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >
;	COMDAT _$E27
_TEXT	SEGMENT
_$E27	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A
	call	??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::~CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E27	ENDP
_TEXT	ENDS
PUBLIC	??GVector@@QBE?AV0@XZ				; Vector::operator-
PUBLIC	??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Count
PUBLIC	?RemoveAll@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::RemoveAll
PUBLIC	?SV_Physics_Step@@YAXPAVCBaseEntity@@@Z		; SV_Physics_Step
EXTRN	?g_psv_stepsize@@3PAUcvar_s@@A:DWORD		; g_psv_stepsize
EXTRN	_sqrt:NEAR
EXTRN	?ApplyAbsVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::ApplyAbsVelocityImpulse
_BSS	SEGMENT
_pMovingGround DD 01H DUP (?)
_s_nEnumCount DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?SV_Physics_Step@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_inwater$ = -4
_wasonmover$ = -8
_wasonground$ = -12
_ent$ = -16
_trace$ = -72
_oldAbsOrigin$ = -84
_game_friction$ = -88
_game_stopspeed$ = -92
_buoyancy$40318 = -96
_vecAbsVelocity$40319 = -108
_pGround$ = -112
_vel$40332 = -124
_control$40333 = -128
_speed$40334 = -132
_newspeed$40335 = -136
_friction$40336 = -140
_lastorg$40341 = -152
_lastvel$40342 = -164
_dest$40343 = -176
_downorg$40344 = -188
_downvel$40345 = -200
_updist$40347 = -204
_downdist$40348 = -208
_uporg$40349 = -220
_vel$40356 = -232
_move$40358 = -236
_mins$40362 = -248
_maxs$40364 = -260
_point$40366 = -272
_x$40367 = -276
_y$40372 = -280
_vecAbsMins$40378 = -292
_vecAbsMaxs$40379 = -304
_lmove$40384 = -316
_blocked$40386 = -320
_i$40387 = -324
$T41852 = -336
$T41853 = -348
$T41854 = -360
$T41863 = -388
$T41864 = -444
?SV_Physics_Step@@YAXPAVCBaseEntity@@@Z PROC NEAR	; SV_Physics_Step, COMDAT

; 2081 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 560				; 00000230H
	push	ebx
	push	esi
	push	edi

; 2082 : 	BOOL	inwater;
; 2083 : 	BOOL	wasonmover;
; 2084 : 	BOOL	wasonground;
; 2085 : 	edict_t	*ent = pEntity->edict();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _ent$[ebp], eax

; 2086 : 	TraceResult trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 2087 : 
; 2088 : 	Vector oldAbsOrigin = pEntity->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _oldAbsOrigin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2089 : 
; 2090 : 	UTIL_WaterMove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_WaterMove@@YAXPAVCBaseEntity@@@Z	; UTIL_WaterMove
	add	esp, 4

; 2091 : 	SV_CheckVelocity( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z ; SV_CheckVelocity
	add	esp, 4

; 2092 : 
; 2093 : 	wasonground = (pEntity->pev->flags & FL_ONGROUND);

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 512				; 00000200H
	mov	DWORD PTR _wasonground$[ebp], ecx

; 2094 : 	wasonmover = SV_CheckMover( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_CheckMover@@YAHPAVCBaseEntity@@@Z	; SV_CheckMover
	add	esp, 4
	mov	DWORD PTR _wasonmover$[ebp], eax

; 2095 : 	inwater = SV_CheckWater( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_CheckWater@@YAHPAVCBaseEntity@@@Z	; SV_CheckWater
	add	esp, 4
	mov	DWORD PTR _inwater$[ebp], eax

; 2096 : 
; 2097 : 	float game_friction = CVAR_GET_FLOAT( "sv_friction" );

	push	OFFSET FLAT:??_C@_0M@OCEI@sv_friction?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fstp	DWORD PTR _game_friction$[ebp]

; 2098 : 	float game_stopspeed = CVAR_GET_FLOAT( "sv_stopspeed" );

	push	OFFSET FLAT:??_C@_0N@PJCG@sv_stopspeed?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fstp	DWORD PTR _game_stopspeed$[ebp]

; 2099 : 
; 2100 : 	if( pEntity->pev->flags & FL_FLOAT && pEntity->pev->waterlevel > 0 && pEntity->m_hParent == NULL )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 32768				; 00008000H
	test	eax, eax
	je	SHORT $L40317
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+448], 0
	jle	SHORT $L40317
	mov	ecx, DWORD PTR _pEntity$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $L40317

; 2102 : 		float buoyancy = SV_Submerged( pEntity ) * pEntity->pev->skin * gpGlobals->frametime;

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_Submerged@@YAMPAVCBaseEntity@@@Z	; SV_Submerged
	add	esp, 4
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fimul	DWORD PTR [edx+272]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR _buoyancy$40318[ebp]

; 2103 : 
; 2104 : 		SV_AddGravity( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_AddGravity@@YAXPAVCBaseEntity@@@Z	; SV_AddGravity
	add	esp, 4

; 2105 : 
; 2106 : 		// add buoyancy
; 2107 : 		Vector vecAbsVelocity = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vecAbsVelocity$40319[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2108 : 		vecAbsVelocity.z += buoyancy;

	fld	DWORD PTR _vecAbsVelocity$40319[ebp+8]
	fadd	DWORD PTR _buoyancy$40318[ebp]
	fstp	DWORD PTR _vecAbsVelocity$40319[ebp+8]

; 2109 : 		pEntity->SetAbsVelocity( vecAbsVelocity );

	lea	edx, DWORD PTR _vecAbsVelocity$40319[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L40317:

; 2111 : 
; 2112 : 	if( !wasonground && !( pEntity->pev->flags & FL_FLY ) && (!( pEntity->pev->flags & FL_SWIM ) || pEntity->pev->waterlevel <= 0 ))

	cmp	DWORD PTR _wasonground$[ebp], 0
	jne	SHORT $L40322
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 1
	test	edx, edx
	jne	SHORT $L40322
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 2
	test	edx, edx
	je	SHORT $L40321
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+448], 0
	jg	SHORT $L40322
$L40321:

; 2114 : 		// compound link, so we ignore gravity here
; 2115 : 		if( !inwater && pEntity->m_hParent == NULL )

	cmp	DWORD PTR _inwater$[ebp], 0
	jne	SHORT $L40322
	mov	ecx, DWORD PTR _pEntity$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $L40322

; 2116 : 			SV_AddGravity( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_AddGravity@@YAXPAVCBaseEntity@@@Z	; SV_AddGravity
	add	esp, 4
$L40322:

; 2118 : 
; 2119 : 	if( pEntity->m_hParent != NULL )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40323

; 2120 : 		pEntity->SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L40323:

; 2121 : 
; 2122 : 	CBaseEntity *pGround = pEntity->GetGroundEntity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ; CBaseEntity::GetGroundEntity
	mov	DWORD PTR _pGround$[ebp], eax

; 2123 : 
; 2124 : 	if( !pGround || (pGround->pev->flags & ( FL_MONSTER|FL_CLIENT )))

	cmp	DWORD PTR _pGround$[ebp], 0
	je	SHORT $L40326
	mov	eax, DWORD PTR _pGround$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 40					; 00000028H
	test	edx, edx
	je	SHORT $L40325
$L40326:

; 2125 : 		pEntity->pev->flags &= ~FL_ONGROUND;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	dh, -3					; fffffffdH
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx
$L40325:

; 2126 : 
; 2127 : 	if( pEntity->GetAbsVelocity() != g_vecZero || pEntity->GetBaseVelocity() != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	jne	SHORT $L40328
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetBaseVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	$L40327
$L40328:

; 2129 : 		pEntity->pev->flags &= ~FL_ONGROUND;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ch, -3					; fffffffdH
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx

; 2130 : 
; 2131 : 		if(( wasonground || wasonmover ) && ( pEntity->pev->health > 0 || ENT_IS_ON_FLOOR( pEntity->edict() )))

	cmp	DWORD PTR _wasonground$[ebp], 0
	jne	SHORT $L40330
	cmp	DWORD PTR _wasonmover$[ebp], 0
	je	$L40337
$L40330:
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40331
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+100
	add	esp, 4
	test	eax, eax
	je	$L40337
$L40331:

; 2133 : 			Vector	vel = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vel$40332[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2134 : 			float	control, speed, newspeed;
; 2135 : 			float	friction;
; 2136 : 
; 2137 : 			speed = sqrt(( vel[0] * vel[0] ) + ( vel[1] * vel[1] ));	// DotProduct2D

	lea	ecx, DWORD PTR _vel$40332[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	lea	ecx, DWORD PTR _vel$40332[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -448+[ebp]
	lea	ecx, DWORD PTR _vel$40332[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	lea	ecx, DWORD PTR _vel$40332[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi+4]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -448+[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _speed$40334[ebp]

; 2138 : 
; 2139 : 			if( speed )

	fld	DWORD PTR _speed$40334[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L40337

; 2141 : 				friction = game_friction * pEntity->pev->friction;	// factor

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR _game_friction$[ebp]
	fmul	DWORD PTR [ecx+288]
	fstp	DWORD PTR _friction$40336[ebp]

; 2142 : 				pEntity->pev->friction = 1.0f; // g-cont. ???

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+288], 1065353216		; 3f800000H

; 2143 : 				if( wasonmover ) friction *= 0.5f;

	cmp	DWORD PTR _wasonmover$[ebp], 0
	je	SHORT $L40338
	fld	DWORD PTR _friction$40336[ebp]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fstp	DWORD PTR _friction$40336[ebp]
$L40338:

; 2144 : 
; 2145 : 				control = (speed < game_stopspeed) ? game_stopspeed : speed;

	fld	DWORD PTR _speed$40334[ebp]
	fcomp	DWORD PTR _game_stopspeed$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41850
	mov	ecx, DWORD PTR _game_stopspeed$[ebp]
	mov	DWORD PTR -452+[ebp], ecx
	jmp	SHORT $L41851
$L41850:
	mov	edx, DWORD PTR _speed$40334[ebp]
	mov	DWORD PTR -452+[ebp], edx
$L41851:
	mov	eax, DWORD PTR -452+[ebp]
	mov	DWORD PTR _control$40333[ebp], eax

; 2146 : 				newspeed = speed - (gpGlobals->frametime * control * friction);

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _control$40333[ebp]
	fmul	DWORD PTR [ecx+4]
	fmul	DWORD PTR _friction$40336[ebp]
	fsubr	DWORD PTR _speed$40334[ebp]
	fstp	DWORD PTR _newspeed$40335[ebp]

; 2147 : 
; 2148 : 				if( newspeed < 0 )

	fld	DWORD PTR _newspeed$40335[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40339

; 2149 : 					newspeed = 0;

	mov	DWORD PTR _newspeed$40335[ebp], 0
$L40339:

; 2150 : 				newspeed /= speed;

	fld	DWORD PTR _newspeed$40335[ebp]
	fdiv	DWORD PTR _speed$40334[ebp]
	fstp	DWORD PTR _newspeed$40335[ebp]

; 2151 : 
; 2152 : 				vel[0] = vel[0] * newspeed;

	lea	ecx, DWORD PTR _vel$40332[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _newspeed$40335[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -456+[ebp]
	lea	ecx, DWORD PTR _vel$40332[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -456+[ebp]
	mov	DWORD PTR [eax], edx

; 2153 : 				vel[1] = vel[1] * newspeed;

	lea	ecx, DWORD PTR _vel$40332[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR _newspeed$40335[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -460+[ebp]
	lea	ecx, DWORD PTR _vel$40332[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -460+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2154 : 
; 2155 : 				pEntity->SetAbsVelocity( vel );

	lea	edx, DWORD PTR _vel$40332[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L40337:

; 2158 : 
; 2159 : 		pEntity->ApplyAbsVelocityImpulse( pEntity->GetBaseVelocity( ));

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetBaseVelocity
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?ApplyAbsVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::ApplyAbsVelocityImpulse

; 2160 : 		SV_CheckVelocity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z ; SV_CheckVelocity
	add	esp, 4

; 2161 : 
; 2162 : 		if( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	$L40340

; 2164 : 			// Try sliding forward both on ground and up 16 pixels
; 2165 : 			// take the move that goes farthest
; 2166 : 			Vector lastorg = pEntity->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _lastorg$40341[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2167 : 			Vector lastvel = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _lastvel$40342[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2168 : 			Vector dest;

	lea	ecx, DWORD PTR _dest$40343[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2169 : 
; 2170 : 			SV_FlyMove( pEntity, gpGlobals->frametime, &trace );

	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_FlyMove@@YAHPAVCBaseEntity@@MPAUgametrace_s@@@Z ; SV_FlyMove
	add	esp, 12					; 0000000cH

; 2171 : 
; 2172 : 			// Copy the results out
; 2173 : 			Vector downorg = pEntity->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _downorg$40344[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2174 : 			Vector downvel = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _downvel$40345[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2175 : 
; 2176 : 			// Reset original values.
; 2177 : 			pEntity->SetAbsOrigin( lastorg );

	lea	eax, DWORD PTR _lastorg$40341[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 2178 : 			pEntity->SetAbsVelocity( lastvel );

	lea	ecx, DWORD PTR _lastvel$40342[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 2179 : 
; 2180 : 			// Start out up one stair height
; 2181 : 			dest = pEntity->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _dest$40343[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _dest$40343[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _dest$40343[ebp+8], edx

; 2182 : 			dest.z += g_psv_stepsize->value;

	mov	eax, DWORD PTR ?g_psv_stepsize@@3PAUcvar_s@@A ; g_psv_stepsize
	fld	DWORD PTR _dest$40343[ebp+8]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR _dest$40343[ebp+8]

; 2183 : 
; 2184 : 			pEntity->m_iPushableFilter = TRUE;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [ecx+36], 1

; 2185 : 			TRACE_MONSTER_HULL( pEntity->edict(), pEntity->GetAbsOrigin(), dest, dont_ignore_monsters, pEntity->edict(), &trace );

	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	lea	ecx, DWORD PTR _dest$40343[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+132
	add	esp, 24					; 00000018H

; 2186 : 			pEntity->m_iPushableFilter = FALSE;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [eax+36], 0

; 2187 : 	
; 2188 : 			// If we started okay and made it part of the way at least,
; 2189 : 			//  copy the results to the movement start position and then
; 2190 : 			//  run another move try.
; 2191 : 			if( !trace.fStartSolid && !trace.fAllSolid )

	cmp	DWORD PTR _trace$[ebp+4], 0
	jne	SHORT $L40346
	cmp	DWORD PTR _trace$[ebp], 0
	jne	SHORT $L40346

; 2193 : 				pEntity->SetAbsOrigin( trace.vecEndPos );

	lea	ecx, DWORD PTR _trace$[ebp+20]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin
$L40346:

; 2195 : 
; 2196 : 			SV_FlyMove( pEntity, gpGlobals->frametime, &trace );	

	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_FlyMove@@YAHPAVCBaseEntity@@MPAUgametrace_s@@@Z ; SV_FlyMove
	add	esp, 12					; 0000000cH

; 2197 : 
; 2198 : 			// Now try going back down from the end point
; 2199 : 			//  press down the stepheight
; 2200 : 			dest = pEntity->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dest$40343[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _dest$40343[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _dest$40343[ebp+8], eax

; 2201 : 			dest.z -= g_psv_stepsize->value;

	mov	ecx, DWORD PTR ?g_psv_stepsize@@3PAUcvar_s@@A ; g_psv_stepsize
	fld	DWORD PTR _dest$40343[ebp+8]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _dest$40343[ebp+8]

; 2202 : 
; 2203 : 			pEntity->m_iPushableFilter = TRUE;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [edx+36], 1

; 2204 : 			TRACE_MONSTER_HULL( pEntity->edict(), pEntity->GetAbsOrigin(), dest, dont_ignore_monsters, pEntity->edict(), &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	lea	ecx, DWORD PTR _dest$40343[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+132
	add	esp, 24					; 00000018H

; 2205 : 			pEntity->m_iPushableFilter = FALSE;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 2206 : 
; 2207 : 			float updist, downdist;
; 2208 : 			Vector uporg;

	lea	ecx, DWORD PTR _uporg$40349[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2209 : 	
; 2210 : 			// If we are not on the ground any more then
; 2211 : 			//  use the original movement attempt
; 2212 : 			if( trace.vecPlaneNormal.z < 0.7f )

	fld	DWORD PTR _trace$[ebp+44]
	fcomp	DWORD PTR __real@4@3ffeb333330000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40350

; 2213 : 				goto usedown;

	jmp	$L40352
$L40350:

; 2214 : 			// If the trace ended up in empty space, copy the end
; 2215 : 			//  over to the origin.
; 2216 : 			if( !trace.fStartSolid && !trace.fAllSolid )

	cmp	DWORD PTR _trace$[ebp+4], 0
	jne	SHORT $L40353
	cmp	DWORD PTR _trace$[ebp], 0
	jne	SHORT $L40353

; 2218 : 				pEntity->SetAbsOrigin( trace.vecEndPos );

	lea	edx, DWORD PTR _trace$[ebp+20]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin
$L40353:

; 2220 : 
; 2221 : 			// Copy this origin to up.
; 2222 : 			uporg = pEntity->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _uporg$40349[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _uporg$40349[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _uporg$40349[ebp+8], eax

; 2223 : 
; 2224 : 			// decide which one went farther
; 2225 : 			downdist = (downorg[0] - lastorg[0]) * (downorg[0] - lastorg[0]) + (downorg[1] - lastorg[1]) * (downorg[1] - lastorg[1]);

	lea	ecx, DWORD PTR _downorg$40344[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	lea	ecx, DWORD PTR _lastorg$40341[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi]
	fsub	DWORD PTR [eax]
	fstp	DWORD PTR -464+[ebp]
	lea	ecx, DWORD PTR _downorg$40344[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	lea	ecx, DWORD PTR _lastorg$40341[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi]
	fsub	DWORD PTR [eax]
	fmul	DWORD PTR -464+[ebp]
	fstp	DWORD PTR -468+[ebp]
	lea	ecx, DWORD PTR _downorg$40344[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	lea	ecx, DWORD PTR _lastorg$40341[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi+4]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR -472+[ebp]
	lea	ecx, DWORD PTR _downorg$40344[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	lea	ecx, DWORD PTR _lastorg$40341[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi+4]
	fsub	DWORD PTR [eax+4]
	fmul	DWORD PTR -472+[ebp]
	fadd	DWORD PTR -468+[ebp]
	fstp	DWORD PTR _downdist$40348[ebp]

; 2226 : 			updist = (uporg[0] - lastorg[0]) * (uporg[0] - lastorg[0]) + (uporg[1] - lastorg[1]) * (uporg[1] - lastorg[1]);

	lea	ecx, DWORD PTR _uporg$40349[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	lea	ecx, DWORD PTR _lastorg$40341[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi]
	fsub	DWORD PTR [eax]
	fstp	DWORD PTR -476+[ebp]
	lea	ecx, DWORD PTR _uporg$40349[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	lea	ecx, DWORD PTR _lastorg$40341[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi]
	fsub	DWORD PTR [eax]
	fmul	DWORD PTR -476+[ebp]
	fstp	DWORD PTR -480+[ebp]
	lea	ecx, DWORD PTR _uporg$40349[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	lea	ecx, DWORD PTR _lastorg$40341[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi+4]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR -484+[ebp]
	lea	ecx, DWORD PTR _uporg$40349[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	lea	ecx, DWORD PTR _lastorg$40341[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [esi+4]
	fsub	DWORD PTR [eax+4]
	fmul	DWORD PTR -484+[ebp]
	fadd	DWORD PTR -480+[ebp]
	fstp	DWORD PTR _updist$40347[ebp]

; 2227 : 
; 2228 : 			if( downdist > updist )

	fld	DWORD PTR _downdist$40348[ebp]
	fcomp	DWORD PTR _updist$40347[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40354
$usedown$40351:

; 2230 : usedown:
; 2231 : 				pEntity->SetAbsOrigin( downorg );

	lea	ecx, DWORD PTR _downorg$40344[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 2232 : 				pEntity->SetAbsVelocity( downvel );

	lea	edx, DWORD PTR _downvel$40345[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 2234 : 			else

	jmp	SHORT $L40355
$L40354:

; 2236 : 				// copy z value from slide move
; 2237 : 				Vector vel = pEntity->GetAbsVelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vel$40356[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2238 : 				vel.z = downvel.z;

	mov	eax, DWORD PTR _downvel$40345[ebp+8]
	mov	DWORD PTR _vel$40356[ebp+8], eax

; 2239 : 				pEntity->SetAbsVelocity( vel );

	lea	ecx, DWORD PTR _vel$40356[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L40355:

; 2242 : 		else

	jmp	SHORT $L40357
$L40340:

; 2244 : 			int move = SV_FlyMove( pEntity, gpGlobals->frametime, &trace );

	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_FlyMove@@YAHPAVCBaseEntity@@MPAUgametrace_s@@@Z ; SV_FlyMove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _move$40358[ebp], eax
$L40357:

; 2246 : 
; 2247 : 		if( ent->free || pEntity->pev->flags & FL_KILLME )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L40360
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	SHORT $L40359
$L40360:

; 2248 : 			return;

	jmp	$L40308
$L40359:

; 2249 : 
; 2250 : 		SV_CheckVelocity( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z ; SV_CheckVelocity
	add	esp, 4

; 2251 : 		pEntity->ApplyAbsVelocityImpulse( -pEntity->GetBaseVelocity( ));

	lea	edx, DWORD PTR $T41852[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetBaseVelocity
	mov	ecx, eax
	call	??GVector@@QBE?AV0@XZ			; Vector::operator-
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?ApplyAbsVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::ApplyAbsVelocityImpulse

; 2252 : 
; 2253 : 		SV_CheckVelocity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_CheckVelocity@@YAXPAVCBaseEntity@@@Z ; SV_CheckVelocity
	add	esp, 4

; 2254 : 
; 2255 : 		Vector mins = pEntity->GetAbsOrigin() + pEntity->pev->mins;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 220				; 000000dcH
	push	edx
	lea	eax, DWORD PTR $T41853[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _mins$40362[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2256 : 		Vector maxs = pEntity->GetAbsOrigin() + pEntity->pev->maxs;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 232				; 000000e8H
	push	edx
	lea	eax, DWORD PTR $T41854[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _maxs$40364[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2257 : 		Vector point;

	lea	ecx, DWORD PTR _point$40366[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2258 : 
; 2259 : 		point.z = mins.z - 1.0f;

	fld	DWORD PTR _mins$40362[ebp+8]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR _point$40366[ebp+8]

; 2260 : 
; 2261 : 		for( int x = 0; x <= 1; x++ )

	mov	DWORD PTR _x$40367[ebp], 0
	jmp	SHORT $L40368
$L40369:
	mov	ecx, DWORD PTR _x$40367[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$40367[ebp], ecx
$L40368:
	cmp	DWORD PTR _x$40367[ebp], 1
	jg	$L40370

; 2263 : 			if( pEntity->pev->flags & FL_ONGROUND )

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 512				; 00000200H
	test	ecx, ecx
	je	SHORT $L40371

; 2264 : 				break;

	jmp	$L40370
$L40371:

; 2265 : 
; 2266 : 			for( int y = 0; y <= 1; y++ )

	mov	DWORD PTR _y$40372[ebp], 0
	jmp	SHORT $L40373
$L40374:
	mov	edx, DWORD PTR _y$40372[ebp]
	add	edx, 1
	mov	DWORD PTR _y$40372[ebp], edx
$L40373:
	cmp	DWORD PTR _y$40372[ebp], 1
	jg	$L40375

; 2268 : 				point.x = x ? maxs.x : mins.x;

	cmp	DWORD PTR _x$40367[ebp], 0
	je	SHORT $L41855
	mov	eax, DWORD PTR _maxs$40364[ebp]
	mov	DWORD PTR -488+[ebp], eax
	jmp	SHORT $L41856
$L41855:
	mov	ecx, DWORD PTR _mins$40362[ebp]
	mov	DWORD PTR -488+[ebp], ecx
$L41856:
	mov	edx, DWORD PTR -488+[ebp]
	mov	DWORD PTR _point$40366[ebp], edx

; 2269 : 				point.y = y ? maxs.y : mins.y;

	cmp	DWORD PTR _y$40372[ebp], 0
	je	SHORT $L41857
	mov	eax, DWORD PTR _maxs$40364[ebp+4]
	mov	DWORD PTR -492+[ebp], eax
	jmp	SHORT $L41858
$L41857:
	mov	ecx, DWORD PTR _mins$40362[ebp+4]
	mov	DWORD PTR -492+[ebp], ecx
$L41858:
	mov	edx, DWORD PTR -492+[ebp]
	mov	DWORD PTR _point$40366[ebp+4], edx

; 2270 : 
; 2271 : 				UTIL_TraceLine( point, point, dont_ignore_monsters, ent, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _point$40366[ebp]
	push	edx
	lea	eax, DWORD PTR _point$40366[ebp]
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 2272 : 
; 2273 : 				if( trace.fStartSolid )

	cmp	DWORD PTR _trace$[ebp+4], 0
	je	SHORT $L40376

; 2275 : 					pEntity->SetGroundEntity( trace.pHit );

	mov	ecx, DWORD PTR _trace$[ebp+48]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z ; CBaseEntity::SetGroundEntity

; 2276 : 					pEntity->pev->friction = 1.0f;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+288], 1065353216		; 3f800000H

; 2277 : 					break;

	jmp	SHORT $L40375
$L40376:

; 2279 : 			}

	jmp	$L40374
$L40375:

; 2280 : 		}

	jmp	$L40369
$L40370:

; 2281 : 
; 2282 : 		pEntity->RelinkEntity( TRUE, &oldAbsOrigin );

	push	0
	lea	ecx, DWORD PTR _oldAbsOrigin$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 2283 : 
; 2284 : 		// move func_pushable riders
; 2285 : 		if( pEntity->pev->movetype == MOVETYPE_PUSHSTEP && pEntity->pev->solid == SOLID_BSP )

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+264], 13			; 0000000dH
	jne	$L40390
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 4
	jne	$L40390

; 2287 : 			Vector vecAbsMins, vecAbsMaxs;

	lea	ecx, DWORD PTR _vecAbsMins$40378[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _vecAbsMaxs$40379[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2288 : 			pEntity->WorldSpaceAABB( vecAbsMins, vecAbsMaxs );

	lea	eax, DWORD PTR _vecAbsMaxs$40379[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecAbsMins$40378[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?WorldSpaceAABB@CBaseEntity@@QBEXAAVVector@@0@Z ; CBaseEntity::WorldSpaceAABB

; 2289 : 
; 2290 : 			m_rgGroundEnts.RemoveAll();

	mov	ecx, OFFSET FLAT:?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A
	call	?RemoveAll@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::RemoveAll

; 2291 : 			pMovingGround = pEntity;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR _pMovingGround, edx

; 2292 : 			s_nEnumCount++;

	mov	eax, DWORD PTR _s_nEnumCount
	add	eax, 1
	mov	DWORD PTR _s_nEnumCount, eax

; 2293 : 
; 2294 : 			vecAbsMaxs.z *= 2;

	fld	DWORD PTR _vecAbsMaxs$40379[ebp+8]
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _vecAbsMaxs$40379[ebp+8]

; 2295 : 
; 2296 : 			UTIL_AreaNode( vecAbsMins, vecAbsMaxs, AREA_SOLID, AddEntityToGroundList );

	push	OFFSET FLAT:?AddEntityToGroundList@@YAXPAVCBaseEntity@@@Z ; AddEntityToGroundList
	push	0
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecAbsMaxs$40379[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecAbsMins$40378[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?UTIL_AreaNode@@YAXVVector@@0HP6AXPAVCBaseEntity@@@Z@Z ; UTIL_AreaNode
	add	esp, 32					; 00000020H

; 2297 : 			UTIL_AreaNode( vecAbsMins, vecAbsMaxs, AREA_TRIGGERS, AddEntityToGroundList );

	push	OFFSET FLAT:?AddEntityToGroundList@@YAXPAVCBaseEntity@@@Z ; AddEntityToGroundList
	push	1
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _vecAbsMaxs$40379[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecAbsMins$40378[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?UTIL_AreaNode@@YAXVVector@@0HP6AXPAVCBaseEntity@@@Z@Z ; UTIL_AreaNode
	add	esp, 32					; 00000020H

; 2298 : 
; 2299 : 			Vector lmove = pEntity->GetAbsOrigin() - oldAbsOrigin;

	lea	ecx, DWORD PTR _oldAbsOrigin$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41863[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _lmove$40384[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2300 : 			int blocked;
; 2301 : 
; 2302 : 			// FIXME: need a recursive here for move all standing items
; 2303 : 			// e.g. player standing on the pushable which standing on the pushable
; 2304 : 			// whcih standing on the pushable.. oh, well
; 2305 : 			for( int i = 0; i < m_rgGroundEnts.Count(); i++ )

	mov	DWORD PTR _i$40387[ebp], 0
	jmp	SHORT $L40388
$L40389:
	mov	eax, DWORD PTR _i$40387[ebp]
	add	eax, 1
	mov	DWORD PTR _i$40387[ebp], eax
$L40388:
	mov	ecx, OFFSET FLAT:?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A
	call	?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Count
	cmp	DWORD PTR _i$40387[ebp], eax
	jge	$L40390

; 2307 : 				SV_PushEntity( m_rgGroundEnts[i], lmove, g_vecZero, &blocked );

	lea	ecx, DWORD PTR _blocked$40386[ebp]
	push	ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	edx, DWORD PTR _lmove$40384[ebp]
	push	edx
	mov	eax, DWORD PTR _i$40387[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A
	call	??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T41864[ebp]
	push	edx
	call	?SV_PushEntity@@YA?AUgametrace_s@@PAVCBaseEntity@@ABVVector@@1PAH@Z ; SV_PushEntity
	add	esp, 20					; 00000014H

; 2308 : 				if( m_rgGroundEnts[i]->m_iActorType == ACTOR_CHARACTER )

	mov	eax, DWORD PTR _i$40387[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A
	call	??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[]
	mov	ecx, DWORD PTR [eax]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+1604]
	cmp	edx, 3
	jne	SHORT $L40392

; 2309 : 					WorldPhysic->MoveCharacter( m_rgGroundEnts[i] );

	mov	eax, DWORD PTR _i$40387[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A
	call	??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [eax+152]

; 2310 : 				else if( m_rgGroundEnts[i]->m_iActorType == ACTOR_KINEMATIC )

	jmp	SHORT $L40394
$L40392:
	mov	ecx, DWORD PTR _i$40387[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A
	call	??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	mov	al, BYTE PTR [edx+1604]
	cmp	eax, 2
	jne	SHORT $L40394

; 2311 : 					WorldPhysic->MoveKinematic( m_rgGroundEnts[i] );

	mov	ecx, DWORD PTR _i$40387[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A
	call	??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+156]
$L40394:

; 2312 : 				if( blocked ) m_rgGroundEnts[i]->pev->flags &= ~FL_ONGROUND;

	cmp	DWORD PTR _blocked$40386[ebp], 0
	je	SHORT $L40395
	mov	eax, DWORD PTR _i$40387[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A
	call	??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 420				; 000001a4H
	mov	DWORD PTR -496+[ebp], edx
	mov	eax, DWORD PTR -496+[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ch, -3					; fffffffdH
	mov	edx, DWORD PTR -496+[ebp]
	mov	DWORD PTR [edx], ecx
$L40395:

; 2313 : 			}

	jmp	$L40389
$L40390:

; 2316 : 	else

	jmp	SHORT $L40398
$L40327:

; 2318 : 		if( gpGlobals->force_retouch != 0.0f )

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L40398

; 2320 : 			TRACE_MONSTER_HULL( ent, pEntity->GetAbsOrigin(), pEntity->GetAbsOrigin(), dont_ignore_monsters, ent, &trace );

	lea	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+132
	add	esp, 24					; 00000018H

; 2321 : 
; 2322 : 			// hentacle impact code
; 2323 : 			if(( trace.flFraction < 1.0f || trace.fStartSolid )  && trace.pHit )

	fld	DWORD PTR _trace$[ebp+16]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40399
	cmp	DWORD PTR _trace$[ebp+4], 0
	je	SHORT $L40398
$L40399:
	cmp	DWORD PTR _trace$[ebp+48], 0
	je	SHORT $L40398

; 2324 : 				SV_Impact( pEntity, NULL, &trace );

	lea	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_Impact@@YAXPAVCBaseEntity@@0PAUgametrace_s@@@Z ; SV_Impact
	add	esp, 12					; 0000000cH
$L40398:

; 2327 : 
; 2328 : 	if( ent->free || pEntity->pev->flags & FL_KILLME )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L40401
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	SHORT $L40400
$L40401:

; 2329 : 		return;

	jmp	SHORT $L40308
$L40400:

; 2330 : 	
; 2331 : 	if( !SV_RunThink( pEntity )) return;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_RunThink@@YAHPAVCBaseEntity@@@Z	; SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40402
	jmp	SHORT $L40308
$L40402:

; 2332 : 	SV_CheckWaterTransition( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_CheckWaterTransition@@YAXPAVCBaseEntity@@@Z ; SV_CheckWaterTransition
	add	esp, 4

; 2333 : 
; 2334 : 	if( pEntity->m_iActorType == ACTOR_KINEMATIC )

	mov	eax, DWORD PTR _pEntity$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	cmp	ecx, 2
	jne	SHORT $L40403

; 2335 : 		WorldPhysic->MoveKinematic( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+156]

; 2336 : 	else if( pEntity->m_iActorType == ACTOR_CHARACTER )

	jmp	SHORT $L40405
$L40403:
	mov	eax, DWORD PTR _pEntity$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	cmp	ecx, 3
	jne	SHORT $L40405

; 2337 : 		WorldPhysic->MoveCharacter( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+152]
$L40405:

; 2338 : }

	jmp	SHORT $L40308
$L40352:
	jmp	$usedown$40351
$L40308:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_Physics_Step@@YAXPAVCBaseEntity@@@Z ENDP		; SV_Physics_Step
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T41867 = -16
??GVector@@QBE?AV0@XZ PROC NEAR				; Vector::operator-, COMDAT

; 146  : 	inline Vector operator-(void) const		{ return Vector(-x,-y,-z);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41867[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??GVector@@QBE?AV0@XZ ENDP				; Vector::operator-
_TEXT	ENDS
PUBLIC	?AddToTail@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::AddToTail
;	COMDAT ?AddEntityToGroundList@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_i$ = -4
?AddEntityToGroundList@@YAXPAVCBaseEntity@@@Z PROC NEAR	; AddEntityToGroundList, COMDAT

; 2032 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2033 : 	if( !pEntity ) return;

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L40296
	jmp	$L40295
$L40296:

; 2034 : 
; 2035 : 	if( pEntity->m_iGroundEnumCount == s_nEnumCount )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	cmp	ecx, DWORD PTR _s_nEnumCount
	jne	SHORT $L40297

; 2036 : 		return;	// already added

	jmp	SHORT $L40295
$L40297:

; 2037 : 
; 2038 : 	if( pEntity->pev->solid == SOLID_NOT )

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+268], 0
	jne	SHORT $L40298

; 2039 : 		return;

	jmp	SHORT $L40295
$L40298:

; 2043 : 	{

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+264]
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 14			; 0000000eH
	ja	SHORT $L40300
	mov	edx, DWORD PTR -8+[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR $L41870[edx]
	jmp	DWORD PTR $L41871[ecx*4]
$L40303:

; 2044 : 	case MOVETYPE_NONE:
; 2045 : 	case MOVETYPE_PUSH:
; 2046 : 	case MOVETYPE_FOLLOW:
; 2047 : 	case MOVETYPE_NOCLIP:
; 2048 : 	case MOVETYPE_COMPOUND:
; 2049 : 		return;

	jmp	SHORT $L40295
$L40300:

; 2051 : 
; 2052 : 	if( pEntity->GetGroundEntity() != pMovingGround )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ; CBaseEntity::GetGroundEntity
	cmp	eax, DWORD PTR _pMovingGround
	je	SHORT $L40304

; 2053 : 		return;

	jmp	SHORT $L40295
$L40304:

; 2054 : 
; 2055 : 	pEntity->m_iGroundEnumCount = s_nEnumCount;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR _s_nEnumCount
	mov	DWORD PTR [eax+60], ecx

; 2056 : 
; 2057 : 	// store entity in list
; 2058 : 	int i = m_rgGroundEnts.AddToTail();

	mov	ecx, OFFSET FLAT:?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A
	call	?AddToTail@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::AddToTail
	mov	DWORD PTR _i$[ebp], eax

; 2059 : 	m_rgGroundEnts[i] = pEntity;

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?m_rgGroundEnts@@3V?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@A
	call	??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [eax], ecx
$L40295:

; 2060 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L41871:
	DD	$L40303
	DD	$L40300
$L41870:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
?AddEntityToGroundList@@YAXPAVCBaseEntity@@@Z ENDP	; AddEntityToGroundList
_TEXT	ENDS
PUBLIC	?SV_Physics_Pusher@@YAXPAVCBaseEntity@@@Z	; SV_Physics_Pusher
PUBLIC	?GetLocalTime@CBaseEntity@@QBEMXZ		; CBaseEntity::GetLocalTime
PUBLIC	?GetMoveDoneTime@CBaseEntity@@QBEMXZ		; CBaseEntity::GetMoveDoneTime
PUBLIC	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z		; CBaseEntity::SetMoveDoneTime
EXTRN	?DispatchBlocked@@YAXPAUedict_s@@0@Z:NEAR	; DispatchBlocked
;	COMDAT ?SV_Physics_Pusher@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_movetime$ = -4
_pBlocker$ = -8
_flOldRotateTime$40433 = -12
_flOldMoveTime$40435 = -16
?SV_Physics_Pusher@@YAXPAVCBaseEntity@@@Z PROC NEAR	; SV_Physics_Pusher, COMDAT

; 2391 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 2392 : 	if( GET_SERVER_STATE() == SERVER_ACTIVE )

	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+20
	cmp	eax, 2
	jne	SHORT $L40426

; 2394 : 		// regular thinking
; 2395 : 		if( !SV_RunThink( pEntity ))

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_RunThink@@YAHPAVCBaseEntity@@@Z	; SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40426

; 2396 : 			return;

	jmp	$L40424
$L40426:

; 2398 : 
; 2399 : 	// enable interpolation on a bmodels (Xash3D extension)
; 2400 : //	pEntity->pev->animtime = gpGlobals->time;
; 2401 : 
; 2402 : 	float movetime = pEntity->GetMoveDoneTime();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetMoveDoneTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetMoveDoneTime
	fstp	DWORD PTR _movetime$[ebp]

; 2403 : 	if( movetime > gpGlobals->frametime )

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _movetime$[ebp]
	fcomp	DWORD PTR [ecx+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40428

; 2404 : 		movetime = gpGlobals->frametime;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _movetime$[ebp], eax
$L40428:

; 2405 : 
; 2406 : 	CBaseEntity *pBlocker = NULL;

	mov	DWORD PTR _pBlocker$[ebp], 0

; 2407 : 	g_pPushedEntities->BeginPush( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?g_pPushedEntities@@3PAVCPhysicsPushedEntities@@A ; g_pPushedEntities
	call	?BeginPush@CPhysicsPushedEntities@@QAEXPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::BeginPush

; 2408 : 
; 2409 : 	if( movetime > 0 )

	fld	DWORD PTR _movetime$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L40430

; 2411 : 		if( pEntity->GetLocalAvelocity() != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	$L40431

; 2413 : 			if( pEntity->GetLocalVelocity() != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L40432

; 2415 : 				float flOldRotateTime = pEntity->GetLocalTime();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetLocalTime
	fstp	DWORD PTR _flOldRotateTime$40433[ebp]

; 2416 : 
; 2417 : 				pBlocker = SV_PushRotate( pEntity, movetime );

	mov	edx, DWORD PTR _movetime$[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_PushRotate@@YAPAVCBaseEntity@@PAV1@M@Z ; SV_PushRotate
	add	esp, 8
	mov	DWORD PTR _pBlocker$[ebp], eax

; 2418 : 
; 2419 : 				if( !pBlocker )

	cmp	DWORD PTR _pBlocker$[ebp], 0
	jne	SHORT $L40436

; 2421 : 					float flOldMoveTime = pEntity->GetLocalTime();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetLocalTime
	fstp	DWORD PTR _flOldMoveTime$40435[ebp]

; 2422 : 
; 2423 : 					// reset the local time to what it was before we rotated
; 2424 : 					pEntity->pev->ltime = flOldRotateTime;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _flOldRotateTime$40433[ebp]
	mov	DWORD PTR [edx+256], eax

; 2425 : 					pBlocker = SV_PushMove( pEntity, movetime );

	mov	ecx, DWORD PTR _movetime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_PushMove@@YAPAVCBaseEntity@@PAV1@M@Z ; SV_PushMove
	add	esp, 8
	mov	DWORD PTR _pBlocker$[ebp], eax

; 2426 : 					if( pEntity->pev->ltime < flOldMoveTime )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+256]
	fcomp	DWORD PTR _flOldMoveTime$40435[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40436

; 2427 : 						pEntity->pev->ltime = flOldMoveTime;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _flOldMoveTime$40435[ebp]
	mov	DWORD PTR [eax+256], ecx
$L40436:

; 2430 : 			else

	jmp	SHORT $L40437
$L40432:

; 2432 : 				pBlocker = SV_PushRotate( pEntity, movetime );

	mov	edx, DWORD PTR _movetime$[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_PushRotate@@YAPAVCBaseEntity@@PAV1@M@Z ; SV_PushRotate
	add	esp, 8
	mov	DWORD PTR _pBlocker$[ebp], eax
$L40437:

; 2435 : 		else 

	jmp	SHORT $L40438
$L40431:

; 2437 : 			pBlocker = SV_PushMove( pEntity, movetime );

	mov	ecx, DWORD PTR _movetime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_PushMove@@YAPAVCBaseEntity@@PAV1@M@Z ; SV_PushMove
	add	esp, 8
	mov	DWORD PTR _pBlocker$[ebp], eax
$L40438:

; 2439 : 
; 2440 : 		// update physics shadow for root pushers
; 2441 : 		WorldPhysic->MoveKinematic( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+156]
$L40430:

; 2443 : 
; 2444 : 	// if the pusher has a "blocked" function, call it
; 2445 : 	// otherwise, just stay in place until the obstacle is gone
; 2446 : 	if( pBlocker ) DispatchBlocked( pEntity->edict(), pBlocker->edict() );

	cmp	DWORD PTR _pBlocker$[ebp], 0
	je	SHORT $L40439
	mov	ecx, DWORD PTR _pBlocker$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?DispatchBlocked@@YAXPAUedict_s@@0@Z	; DispatchBlocked
	add	esp, 8
$L40439:

; 2447 : 
; 2448 : 	// NOTE: all the entities with MOVETYPE_PUSH now has two seperated thinks:
; 2449 : 	// normal regular thinking and local think (movedone)
; 2450 : 	if( pEntity->m_flMoveDoneTime <= pEntity->GetLocalTime() && pEntity->m_flMoveDoneTime > 0 )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetLocalTime
	mov	eax, DWORD PTR _pEntity$[ebp]
	fcomp	DWORD PTR [eax+44]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40440
	mov	ecx, DWORD PTR _pEntity$[ebp]
	fld	DWORD PTR [ecx+44]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40440

; 2452 : 		pEntity->SetMoveDoneTime( -1 );

	push	-1082130432				; bf800000H
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 2453 : 		pEntity->MoveDone();

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [eax+288]
$L40440:
$L40424:

; 2455 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_Physics_Pusher@@YAXPAVCBaseEntity@@@Z ENDP		; SV_Physics_Pusher
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetLocalTime@CBaseEntity@@QBEMXZ PROC NEAR		; CBaseEntity::GetLocalTime, COMDAT

; 788  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 789  : 	return pev->ltime; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+256]

; 790  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLocalTime@CBaseEntity@@QBEMXZ ENDP			; CBaseEntity::GetLocalTime
_TEXT	ENDS
;	COMDAT ?SetMoveDoneTime@CBaseEntity@@QAEXM@Z
_TEXT	SEGMENT
_flDelay$ = 8
_this$ = -4
?SetMoveDoneTime@CBaseEntity@@QAEXM@Z PROC NEAR		; CBaseEntity::SetMoveDoneTime, COMDAT

; 798  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 799  : 	if( flDelay >= 0 )

	fld	DWORD PTR _flDelay$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L35183

; 800  : 		m_flMoveDoneTime = GetLocalTime() + flDelay;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetLocalTime
	fadd	DWORD PTR _flDelay$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+44]

; 801  : 	else m_flMoveDoneTime = -1;

	jmp	SHORT $L35184
$L35183:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], -1082130432		; bf800000H
$L35184:

; 802  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMoveDoneTime@CBaseEntity@@QAEXM@Z ENDP		; CBaseEntity::SetMoveDoneTime
_TEXT	ENDS
;	COMDAT ?GetMoveDoneTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetMoveDoneTime@CBaseEntity@@QBEMXZ PROC NEAR		; CBaseEntity::GetMoveDoneTime, COMDAT

; 805  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 806  : 	return (m_flMoveDoneTime >= 0) ? m_flMoveDoneTime - GetLocalTime() : -1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L41880
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetLocalTime
	mov	ecx, DWORD PTR _this$[ebp]
	fsubr	DWORD PTR [ecx+44]
	fstp	DWORD PTR -8+[ebp]
	jmp	SHORT $L41881
$L41880:
	mov	DWORD PTR -8+[ebp], -1082130432		; bf800000H
$L41881:
	fld	DWORD PTR -8+[ebp]

; 807  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMoveDoneTime@CBaseEntity@@QBEMXZ ENDP		; CBaseEntity::GetMoveDoneTime
_TEXT	ENDS
PUBLIC	?IncrementLocalTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::IncrementLocalTime
;	COMDAT ?SV_PushMove@@YAPAVCBaseEntity@@PAV1@M@Z
_TEXT	SEGMENT
_pPusher$ = 8
_movetime$ = 12
_pBlocker$ = -4
?SV_PushMove@@YAPAVCBaseEntity@@PAV1@M@Z PROC NEAR	; SV_PushMove, COMDAT

; 2347 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2348 : 	// if this entity isn't moving, just update the time.
; 2349 : 	pPusher->IncrementLocalTime( movetime );

	mov	eax, DWORD PTR _movetime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPusher$[ebp]
	call	?IncrementLocalTime@CBaseEntity@@QAEXM@Z ; CBaseEntity::IncrementLocalTime

; 2350 : 
; 2351 : 	// not moving (while changelevel tracktrain may potentially moving on a frame forward)
; 2352 : 	if( pPusher->GetLocalVelocity() == g_vecZero || gpGlobals->changelevel )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pPusher$[ebp]
	call	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalVelocity
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	jne	SHORT $L40411
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	cmp	DWORD PTR [ecx+136], 0
	je	SHORT $L40410
$L40411:

; 2353 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L40409
$L40410:

; 2354 : 
; 2355 : 	// now check that the entire hierarchy can move into the new location
; 2356 : 	CBaseEntity *pBlocker = g_pPushedEntities->PerformLinearPush( pPusher, movetime );

	mov	edx, DWORD PTR _movetime$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPusher$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?g_pPushedEntities@@3PAVCPhysicsPushedEntities@@A ; g_pPushedEntities
	call	?PerformLinearPush@CPhysicsPushedEntities@@QAEPAVCBaseEntity@@PAV2@M@Z ; CPhysicsPushedEntities::PerformLinearPush
	mov	DWORD PTR _pBlocker$[ebp], eax

; 2357 : 	if( pBlocker ) pPusher->IncrementLocalTime( -movetime );

	cmp	DWORD PTR _pBlocker$[ebp], 0
	je	SHORT $L40413
	fld	DWORD PTR _movetime$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _pPusher$[ebp]
	call	?IncrementLocalTime@CBaseEntity@@QAEXM@Z ; CBaseEntity::IncrementLocalTime
$L40413:

; 2358 : 
; 2359 : 	return pBlocker;

	mov	eax, DWORD PTR _pBlocker$[ebp]
$L40409:

; 2360 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_PushMove@@YAPAVCBaseEntity@@PAV1@M@Z ENDP		; SV_PushMove
_TEXT	ENDS
;	COMDAT ?IncrementLocalTime@CBaseEntity@@QAEXM@Z
_TEXT	SEGMENT
_flTimeDelta$ = 8
_this$ = -4
?IncrementLocalTime@CBaseEntity@@QAEXM@Z PROC NEAR	; CBaseEntity::IncrementLocalTime, COMDAT

; 793  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 794  : 	pev->ltime += flTimeDelta; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR _flTimeDelta$[ebp]
	fadd	DWORD PTR [ecx+256]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+256]

; 795  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IncrementLocalTime@CBaseEntity@@QAEXM@Z ENDP		; CBaseEntity::IncrementLocalTime
_TEXT	ENDS
;	COMDAT ?SV_PushRotate@@YAPAVCBaseEntity@@PAV1@M@Z
_TEXT	SEGMENT
_pPusher$ = 8
_movetime$ = 12
_pBlocker$ = -4
?SV_PushRotate@@YAPAVCBaseEntity@@PAV1@M@Z PROC NEAR	; SV_PushRotate, COMDAT

; 2369 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2370 : 	// if this entity isn't moving, just update the time.
; 2371 : 	pPusher->IncrementLocalTime( movetime );

	mov	eax, DWORD PTR _movetime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPusher$[ebp]
	call	?IncrementLocalTime@CBaseEntity@@QAEXM@Z ; CBaseEntity::IncrementLocalTime

; 2372 : 
; 2373 : 	// not rotating (while changelevel tracktrain may potentially moving on a frame forward)
; 2374 : 	if( pPusher->GetLocalAvelocity() == g_vecZero || gpGlobals->changelevel )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pPusher$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	jne	SHORT $L40419
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	cmp	DWORD PTR [ecx+136], 0
	je	SHORT $L40418
$L40419:

; 2375 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L40417
$L40418:

; 2376 : 
; 2377 : 	// now check that the entire hierarchy can rotate into the new location
; 2378 : 	CBaseEntity *pBlocker = g_pPushedEntities->PerformRotatePush( pPusher, movetime );

	mov	edx, DWORD PTR _movetime$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPusher$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?g_pPushedEntities@@3PAVCPhysicsPushedEntities@@A ; g_pPushedEntities
	call	?PerformRotatePush@CPhysicsPushedEntities@@QAEPAVCBaseEntity@@PAV2@M@Z ; CPhysicsPushedEntities::PerformRotatePush
	mov	DWORD PTR _pBlocker$[ebp], eax

; 2379 : 	if( pBlocker ) pPusher->IncrementLocalTime( -movetime );

	cmp	DWORD PTR _pBlocker$[ebp], 0
	je	SHORT $L40421
	fld	DWORD PTR _movetime$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _pPusher$[ebp]
	call	?IncrementLocalTime@CBaseEntity@@QAEXM@Z ; CBaseEntity::IncrementLocalTime
$L40421:

; 2380 : 
; 2381 : 	return pBlocker;

	mov	eax, DWORD PTR _pBlocker$[ebp]
$L40417:

; 2382 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_PushRotate@@YAPAVCBaseEntity@@PAV1@M@Z ENDP		; SV_PushRotate
_TEXT	ENDS
PUBLIC	?SV_Physics_Vehicle@@YAXPAVCBaseEntity@@@Z	; SV_Physics_Vehicle
;	COMDAT ?SV_Physics_Vehicle@@YAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_movetime$ = -4
_pBlocker$40447 = -8
_pGround$ = -12
_trace$ = -68
_vecPos$ = -80
_vecEnd$ = -92
$T41890 = -104
$T41891 = -116
?SV_Physics_Vehicle@@YAXPAVCBaseEntity@@@Z PROC NEAR	; SV_Physics_Vehicle, COMDAT

; 2465 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	push	ebx
	push	esi
	push	edi

; 2466 : 	// regular thinking
; 2467 : 	if( !SV_RunThink( pEntity ))

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_RunThink@@YAHPAVCBaseEntity@@@Z	; SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40444

; 2468 : 		return;

	jmp	$L40443
$L40444:

; 2469 : 
; 2470 : 	WorldPhysic->UpdateVehicle( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [eax+100]

; 2471 : 
; 2472 : 	SV_CheckWater( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_CheckWater@@YAHPAVCBaseEntity@@@Z	; SV_CheckWater
	add	esp, 4

; 2473 : 
; 2474 : 	// sync physic states
; 2475 : 	WorldPhysic->UpdateEntityPos( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+116]

; 2476 : 
; 2477 : 	float movetime = gpGlobals->frametime;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _movetime$[ebp], ecx

; 2478 : 
; 2479 : 	if( movetime > 0 )

	fld	DWORD PTR _movetime$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L40454

; 2481 : 		CBaseEntity *pBlocker = NULL;

	mov	DWORD PTR _pBlocker$40447[ebp], 0

; 2482 : 		g_pPushedEntities->BeginPush( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?g_pPushedEntities@@3PAVCPhysicsPushedEntities@@A ; g_pPushedEntities
	call	?BeginPush@CPhysicsPushedEntities@@QAEXPAVCBaseEntity@@@Z ; CPhysicsPushedEntities::BeginPush

; 2483 : 
; 2484 : 		if( pEntity->GetLocalAvelocity() != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L40448

; 2486 : 			if( pEntity->GetLocalVelocity() != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L40449

; 2488 : 				pBlocker = SV_PushRotate( pEntity, movetime );

	mov	eax, DWORD PTR _movetime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_PushRotate@@YAPAVCBaseEntity@@PAV1@M@Z ; SV_PushRotate
	add	esp, 8
	mov	DWORD PTR _pBlocker$40447[ebp], eax

; 2489 : 				if( !pBlocker ) pBlocker = SV_PushMove( pEntity, movetime );

	cmp	DWORD PTR _pBlocker$40447[ebp], 0
	jne	SHORT $L40450
	mov	edx, DWORD PTR _movetime$[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_PushMove@@YAPAVCBaseEntity@@PAV1@M@Z ; SV_PushMove
	add	esp, 8
	mov	DWORD PTR _pBlocker$40447[ebp], eax
$L40450:

; 2491 : 			else

	jmp	SHORT $L40451
$L40449:

; 2493 : 				pBlocker = SV_PushRotate( pEntity, movetime );

	mov	ecx, DWORD PTR _movetime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_PushRotate@@YAPAVCBaseEntity@@PAV1@M@Z ; SV_PushRotate
	add	esp, 8
	mov	DWORD PTR _pBlocker$40447[ebp], eax
$L40451:

; 2496 : 		else if( pEntity->GetLocalVelocity() != g_vecZero ) 

	jmp	SHORT $L40453
$L40448:
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L40453

; 2498 : 			pBlocker = SV_PushMove( pEntity, movetime );

	mov	eax, DWORD PTR _movetime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_PushMove@@YAPAVCBaseEntity@@PAV1@M@Z ; SV_PushMove
	add	esp, 8
	mov	DWORD PTR _pBlocker$40447[ebp], eax
$L40453:

; 2500 : 
; 2501 : 		// if the pusher has a "blocked" function, call it
; 2502 : 		// otherwise, just stay in place until the obstacle is gone
; 2503 : 		if( pBlocker ) DispatchBlocked( pEntity->edict(), pBlocker->edict() );

	cmp	DWORD PTR _pBlocker$40447[ebp], 0
	je	SHORT $L40454
	mov	ecx, DWORD PTR _pBlocker$40447[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?DispatchBlocked@@YAXPAUedict_s@@0@Z	; DispatchBlocked
	add	esp, 8
$L40454:

; 2505 : 
; 2506 : 	// detect the ground
; 2507 : 	CBaseEntity *pGround = pEntity->GetGroundEntity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ; CBaseEntity::GetGroundEntity
	mov	DWORD PTR _pGround$[ebp], eax

; 2508 : 
; 2509 : 	if( pEntity->GetAbsVelocity().z > 0.0f || pGround == NULL || (pGround->pev->flags & ( FL_MONSTER|FL_CLIENT )))

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40457
	cmp	DWORD PTR _pGround$[ebp], 0
	je	SHORT $L40457
	mov	edx, DWORD PTR _pGround$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 40					; 00000028H
	test	ecx, ecx
	je	SHORT $L40456
$L40457:

; 2511 : 		pEntity->pev->flags &= ~FL_ONGROUND;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ch, -3					; fffffffdH
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx
$L40456:

; 2513 : 
; 2514 : 	if( pEntity->m_iFlags & MF_GROUNDMOVE )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	and	edx, 4
	test	edx, edx
	je	SHORT $L40458

; 2516 : 		pEntity->ClearGroundEntity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?ClearGroundEntity@CBaseEntity@@QAEXXZ	; CBaseEntity::ClearGroundEntity

; 2517 : 		pEntity->m_iFlags &= ~MF_GROUNDMOVE;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [edx+24], ecx
$L40458:

; 2519 : 
; 2520 : 	// if on ground or not moving, return.
; 2521 : 	if( pEntity->pev->flags & FL_ONGROUND || WorldPhysic->IsBodySleeping( pEntity ))

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	jne	SHORT $L40460
	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+168]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40459
$L40460:

; 2523 : 		if( pGround && FBitSet( pGround->pev->flags, FL_CONVEYOR ) && pGround->pev->speed && WorldPhysic->IsBodySleeping( pEntity ))

	cmp	DWORD PTR _pGround$[ebp], 0
	je	SHORT $L40461
	mov	eax, DWORD PTR _pGround$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 4
	test	edx, edx
	je	SHORT $L40461
	mov	eax, DWORD PTR _pGround$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L40461
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+168]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40461

; 2525 : 			// wake up body if conveyor was enabled (add light kick)
; 2526 : 			WorldPhysic->AddForce( pEntity, pGround->pev->movedir );

	mov	eax, DWORD PTR _pGround$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+88]
$L40461:

; 2528 : 		return;	// at rest

	jmp	$L40443
$L40459:

; 2530 : 
; 2531 : 	TraceResult trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 2532 : 	Vector vecPos = pEntity->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecPos$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2533 : 	Vector vecEnd = vecPos + pEntity->pev->mins.z - 1.0f;

	push	1065353216				; 3f800000H
	lea	eax, DWORD PTR $T41891[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+228]
	push	eax
	lea	ecx, DWORD PTR $T41890[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecPos$[ebp]
	call	??HVector@@QBE?AV0@M@Z			; Vector::operator+
	mov	ecx, eax
	call	??GVector@@QBE?AV0@M@Z			; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2534 : 
; 2535 : 	UTIL_TraceLine( vecPos, vecEnd, ignore_monsters, pEntity->edict() ,&trace );

	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecPos$[ebp]
	push	ecx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 2536 : 
; 2537 : 	if( trace.vecPlaneNormal[2] > 0.7f )

	lea	ecx, DWORD PTR _trace$[ebp+36]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@3ffeb333330000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40467

; 2538 : 		pEntity->SetGroundEntity( trace.pHit ? trace.pHit : ENT( 0 ));

	cmp	DWORD PTR _trace$[ebp+48], 0
	je	SHORT $L41892
	mov	edx, DWORD PTR _trace$[ebp+48]
	mov	DWORD PTR -120+[ebp], edx
	jmp	SHORT $L41893
$L41892:
	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR -120+[ebp], eax
$L41893:
	mov	eax, DWORD PTR -120+[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetGroundEntity@CBaseEntity@@QAEXPAUedict_s@@@Z ; CBaseEntity::SetGroundEntity
$L40467:
$L40443:

; 2539 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SV_Physics_Vehicle@@YAXPAVCBaseEntity@@@Z ENDP		; SV_Physics_Vehicle
_TEXT	ENDS
PUBLIC	?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z	; CBaseEntity::SetBaseVelocity
EXTRN	?g_ulFrameCount@@3KA:DWORD			; g_ulFrameCount
;	COMDAT ?RunPhysicsFrame@@YAHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_pParent$ = -4
_vecAbsVelocity$40481 = -16
$T41896 = -28
$T41897 = -40
?RunPhysicsFrame@@YAHPAVCBaseEntity@@@Z PROC NEAR	; RunPhysicsFrame, COMDAT

; 2545 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 2546 : 	// to avoid run physics frame twice for parent entities
; 2547 : 	if( pEntity->m_iPhysicsFrame == g_ulFrameCount )

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, DWORD PTR ?g_ulFrameCount@@3KA	; g_ulFrameCount
	jne	SHORT $L40471

; 2548 : 		return 1;	// handled

	mov	eax, 1
	jmp	$L40470
$L40471:

; 2549 : 
; 2550 : 	pEntity->m_iPhysicsFrame = g_ulFrameCount;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR ?g_ulFrameCount@@3KA	; g_ulFrameCount
	mov	DWORD PTR [edx+52], eax

; 2551 : 
; 2552 : 	if( gpGlobals->force_retouch != 0.0f )

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L40472

; 2554 : 		// force retouch even for stationary
; 2555 : 		pEntity->RelinkEntity( true );

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity
$L40472:

; 2557 : 
; 2558 : 	// If we've have a parent, we must simulate that first.
; 2559 : 	CBaseEntity *pParent = pEntity->m_hParent;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pParent$[ebp], eax

; 2560 : 
; 2561 : 	if( pEntity->pev->movetype == MOVETYPE_NONE && !pParent )

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+264], 0
	jne	SHORT $L40474
	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L40474

; 2563 : 		SV_Physics_None( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_Physics_None@@YAXPAVCBaseEntity@@@Z	; SV_Physics_None
	add	esp, 4

; 2564 : 		return 1;

	mov	eax, 1
	jmp	$L40470
$L40474:

; 2566 : 
; 2567 : 	// compound movetype waiting for parent
; 2568 : 	if( pEntity->pev->movetype == MOVETYPE_COMPOUND && !pEntity->pev->aiment )

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+264], 14			; 0000000eH
	jne	SHORT $L40475
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+404], 0
	jne	SHORT $L40475

; 2570 : 		if( pEntity->m_hParent )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40476

; 2571 : 			pEntity->SetParent(( CBaseEntity *)NULL );

	push	0
	push	0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetParent@CBaseEntity@@QAEXPAV1@H@Z	; CBaseEntity::SetParent
$L40476:

; 2572 : 		SV_Physics_None( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_Physics_None@@YAXPAVCBaseEntity@@@Z	; SV_Physics_None
	add	esp, 4

; 2573 : 		return 1;

	mov	eax, 1
	jmp	$L40470
$L40475:

; 2575 : 
; 2576 : 	// player is already updated for this frame
; 2577 : 	if( pParent && !pParent->IsPlayer( ))

	cmp	DWORD PTR _pParent$[ebp], 0
	je	SHORT $L40478
	mov	ecx, DWORD PTR _pParent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pParent$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L40478

; 2579 : 		// run the parent first
; 2580 : 		RunPhysicsFrame( pParent );

	mov	eax, DWORD PTR _pParent$[ebp]
	push	eax
	call	?RunPhysicsFrame@@YAHPAVCBaseEntity@@@Z	; RunPhysicsFrame
	add	esp, 4

; 2582 : 	else

	jmp	$L40479
$L40478:

; 2584 : 		SV_UpdateBaseVelocity( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_UpdateBaseVelocity@@YAXPAVCBaseEntity@@@Z ; SV_UpdateBaseVelocity
	add	esp, 4

; 2585 : 
; 2586 : 		if(!( pEntity->pev->flags & FL_BASEVELOCITY ) && pEntity->GetBaseVelocity() != g_vecZero )

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 4194304				; 00400000H
	test	ecx, ecx
	jne	SHORT $L40480
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetBaseVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L40480

; 2588 : 			// Apply momentum (add in half of the previous frame of velocity first)
; 2589 : 			Vector vecAbsVelocity = pEntity->GetAbsVelocity() + pEntity->GetBaseVelocity() * (1.0f + (gpGlobals->frametime * 0.5f));

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	fadd	DWORD PTR __real@4@3fff8000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T41896[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetBaseVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T41897[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecAbsVelocity$40481[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2590 : 			pEntity->SetAbsVelocity( vecAbsVelocity );

	lea	edx, DWORD PTR _vecAbsVelocity$40481[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 2591 : 			pEntity->SetBaseVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetBaseVelocity
$L40480:

; 2593 : 		pEntity->pev->flags &= ~FL_BASEVELOCITY;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, -4194305				; ffbfffffH
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx
$L40479:

; 2598 : 	{

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+264]
	mov	DWORD PTR -44+[ebp], ecx
	cmp	DWORD PTR -44+[ebp], 16			; 00000010H
	ja	$L40485
	mov	edx, DWORD PTR -44+[ebp]
	jmp	DWORD PTR $L41898[edx*4]
$L40488:

; 2599 : 	case MOVETYPE_NONE:
; 2600 : 		SV_Physics_None( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_Physics_None@@YAXPAVCBaseEntity@@@Z	; SV_Physics_None
	add	esp, 4

; 2601 : 		return 1;

	mov	eax, 1
	jmp	$L40470
$L40489:

; 2602 : 	case MOVETYPE_NOCLIP:
; 2603 : 		SV_Physics_Noclip( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_Physics_Noclip@@YAXPAVCBaseEntity@@@Z ; SV_Physics_Noclip
	add	esp, 4

; 2604 : 		return 1;

	mov	eax, 1
	jmp	$L40470
$L40490:

; 2605 : 	case MOVETYPE_FOLLOW:
; 2606 : 		SV_Physics_Follow( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_Physics_Follow@@YAXPAVCBaseEntity@@@Z ; SV_Physics_Follow
	add	esp, 4

; 2607 : 		return 1;

	mov	eax, 1
	jmp	SHORT $L40470
$L40491:

; 2608 : 	case MOVETYPE_COMPOUND:
; 2609 : 		SV_Physics_Compound( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_Physics_Compound@@YAXPAVCBaseEntity@@@Z ; SV_Physics_Compound
	add	esp, 4

; 2610 : 		return 1;

	mov	eax, 1
	jmp	SHORT $L40470
$L40492:

; 2611 : 	case MOVETYPE_FLY:
; 2612 : 	case MOVETYPE_TOSS:
; 2613 : 	case MOVETYPE_BOUNCE:
; 2614 : 	case MOVETYPE_FLYMISSILE:
; 2615 : 	case MOVETYPE_BOUNCEMISSILE:
; 2616 : 		SV_Physics_Toss( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_Physics_Toss@@YAXPAVCBaseEntity@@@Z	; SV_Physics_Toss
	add	esp, 4

; 2617 : 		return 1;

	mov	eax, 1
	jmp	SHORT $L40470
$L40493:

; 2618 : 	case MOVETYPE_STEP:
; 2619 : 	case MOVETYPE_PUSHSTEP:
; 2620 : 		SV_Physics_Step( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_Physics_Step@@YAXPAVCBaseEntity@@@Z	; SV_Physics_Step
	add	esp, 4

; 2621 : 		return 1;

	mov	eax, 1
	jmp	SHORT $L40470
$L40494:

; 2622 : 	case MOVETYPE_PUSH:
; 2623 : 		SV_Physics_Pusher( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?SV_Physics_Pusher@@YAXPAVCBaseEntity@@@Z ; SV_Physics_Pusher
	add	esp, 4

; 2624 : 		return 1;

	mov	eax, 1
	jmp	SHORT $L40470
$L40495:

; 2625 : 	case MOVETYPE_PHYSIC:
; 2626 : 		SV_Physics_Rigid( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?SV_Physics_Rigid@@YAXPAVCBaseEntity@@@Z ; SV_Physics_Rigid
	add	esp, 4

; 2627 : 		return 1;

	mov	eax, 1
	jmp	SHORT $L40470
$L40496:

; 2628 : 	case MOVETYPE_VEHICLE:
; 2629 : 		SV_Physics_Vehicle( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?SV_Physics_Vehicle@@YAXPAVCBaseEntity@@@Z ; SV_Physics_Vehicle
	add	esp, 4

; 2630 : 		return 1;

	mov	eax, 1
	jmp	SHORT $L40470
$L40485:

; 2632 : 
; 2633 : 	// other movetypes uses built-in engine physic
; 2634 : 	return 0;

	xor	eax, eax
$L40470:

; 2635 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L41898:
	DD	$L40488
	DD	$L40485
	DD	$L40485
	DD	$L40485
	DD	$L40493
	DD	$L40492
	DD	$L40492
	DD	$L40494
	DD	$L40489
	DD	$L40492
	DD	$L40492
	DD	$L40492
	DD	$L40490
	DD	$L40493
	DD	$L40491
	DD	$L40495
	DD	$L40496
?RunPhysicsFrame@@YAHPAVCBaseEntity@@@Z ENDP		; RunPhysicsFrame
_TEXT	ENDS
;	COMDAT ?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4
_v$ = 8
?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR ; CBaseEntity::SetBaseVelocity, COMDAT

; 390  : 	void SetBaseVelocity( const Vector& v ) { pev->basevelocity = v; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 44					; 0000002cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z ENDP	; CBaseEntity::SetBaseVelocity
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@HH@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>
PUBLIC	??1?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::~CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_this$ = -16
__$EHRec$ = -12
??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@HH@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::~CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>
	ret	0
__ehhandler$??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >
PUBLIC	?Purge@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::~CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::~CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::~CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>
	ret	0
__ehhandler$??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::~CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >
PUBLIC	??A?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::operator[]
;	COMDAT ??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Count
_TEXT	ENDS
PUBLIC	?InsertBefore@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEHH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::InsertBefore
;	COMDAT ?AddToTail@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?AddToTail@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEHXZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::AddToTail, COMDAT

; 481  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 482  : 	return InsertBefore( m_Size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEHH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::InsertBefore

; 483  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddToTail@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEHXZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::AddToTail
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Element
PUBLIC	?Destruct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z ; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L40542:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40543

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Element
	push	eax
	call	?Destruct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z ; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L40542
$L40543:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@HH@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>
PUBLIC	??1?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::~CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_this$ = -16
__$EHRec$ = -12
??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@HH@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::~CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>
	ret	0
__ehhandler$??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@HH@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >
PUBLIC	?Purge@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::~CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::~CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::~CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>
	ret	0
__ehhandler$??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAE@XZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::~CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >
PUBLIC	??A?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::operator[]
;	COMDAT ??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Count
_TEXT	ENDS
PUBLIC	?InsertBefore@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEHH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::InsertBefore
;	COMDAT ?AddToTail@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?AddToTail@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEHXZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::AddToTail, COMDAT

; 481  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 482  : 	return InsertBefore( m_Size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEHH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::InsertBefore

; 483  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddToTail@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEHXZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::AddToTail
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z ; Destruct
PUBLIC	?Element@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Element
;	COMDAT ?RemoveAll@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L40571:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40572

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Element
	push	eax
	call	?Destruct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z ; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L40571
$L40572:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PAVCBaseEntity@@H@@QAE@HH@Z	; CUtlMemory<CBaseEntity *,int>::CUtlMemory<CBaseEntity *,int>
PUBLIC	??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ	; CUtlMemory<CBaseEntity *,int>::~CUtlMemory<CBaseEntity *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_this$ = -16
__$EHRec$ = -12
??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PAVCBaseEntity@@H@@QAE@HH@Z ; CUtlMemory<CBaseEntity *,int>::CUtlMemory<CBaseEntity *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ ; CUtlMemory<CBaseEntity *,int>::~CUtlMemory<CBaseEntity *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >
PUBLIC	?Purge@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::~CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ ; CUtlMemory<CBaseEntity *,int>::~CUtlMemory<CBaseEntity *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ ; CUtlMemory<CBaseEntity *,int>::~CUtlMemory<CBaseEntity *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::~CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >
PUBLIC	??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z ; CUtlMemory<CBaseEntity *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z ; CUtlMemory<CBaseEntity *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Count
_TEXT	ENDS
PUBLIC	?InsertBefore@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::InsertBefore
;	COMDAT ?AddToTail@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?AddToTail@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHXZ PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::AddToTail, COMDAT

; 481  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 482  : 	return InsertBefore( m_Size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::InsertBefore

; 483  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddToTail@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHXZ ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::AddToTail
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
PUBLIC	?Destruct@@YAXPAPAVCBaseEntity@@@Z		; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L40600:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40601

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAVCBaseEntity@@@Z	; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L40600
$L40601:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@XZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Base
;	COMDAT ?ResetDbgInfo@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@XZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@XZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Base
;	COMDAT ?ResetDbgInfo@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@XZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@XZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::Base
;	COMDAT ?Base@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@XZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@XZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@XZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Base
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@XZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::Base
;	COMDAT ?Base@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@XZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@XZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@XZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Base
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PAVCBaseEntity@@H@@QAEPAPAVCBaseEntity@@XZ ; CUtlMemory<CBaseEntity *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PAVCBaseEntity@@H@@QAEPAPAVCBaseEntity@@XZ ; CUtlMemory<CBaseEntity *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Element
_TEXT	ENDS
PUBLIC	?IsValidIndex@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::IsValidIndex
PUBLIC	??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
PUBLIC	?GrowVector@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXHH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::ShiftElementsRight
PUBLIC	??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
PUBLIC	?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z ; Construct
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT
??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ DB '('
	DB	'elem == Count()) || IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEHH@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
?InsertBefore@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEHH@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::InsertBefore, COMDAT

; 493  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 494  : 	// Can insert at the end
; 495  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L41995
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41995
	push	495					; 000001efH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41995:

; 496  : 
; 497  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::GrowVector

; 498  : 	ShiftElementsRight(elem);

	push	1
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXHH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::ShiftElementsRight

; 499  : 	Construct( &Element(elem) );

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Element
	push	eax
	call	?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z ; Construct
	add	esp, 4

; 500  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 501  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InsertBefore@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEHH@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Purge
_TEXT	ENDS
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
PUBLIC	?ValidateGrowSize@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@IAEXXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::ValidateGrowSize
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@HH@Z PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@IAEXXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L42000
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42000:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L40686

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L40686:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@HH@Z ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::~CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::~CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NH@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsIdxValid
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	?IsReadOnly@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsReadOnly
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42005
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42005:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NH@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42006
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42006:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@XZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42009
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42009:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@XZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::Base
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z PROC NEAR ; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	16					; 00000010H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z ENDP ; Destruct
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Element
_TEXT	ENDS
PUBLIC	?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z ; Construct
PUBLIC	?IsValidIndex@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXHH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::ShiftElementsRight
;	COMDAT ?InsertBefore@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEHH@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
?InsertBefore@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEHH@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::InsertBefore, COMDAT

; 493  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 494  : 	// Can insert at the end
; 495  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBEHXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L42016
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42016
	push	495					; 000001efH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42016:

; 496  : 
; 497  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::GrowVector

; 498  : 	ShiftElementsRight(elem);

	push	1
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXHH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::ShiftElementsRight

; 499  : 	Construct( &Element(elem) );

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Element
	push	eax
	call	?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z ; Construct
	add	esp, 4

; 500  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 501  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InsertBefore@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEHH@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEXXZ ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Purge
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@IAEXXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::ValidateGrowSize
;	COMDAT ??0?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@HH@Z PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@IAEXXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L42021
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42021:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L40726

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L40726:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@HH@Z ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::~CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAE@XZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::~CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NH@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42026
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42026:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NH@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42027
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42027:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@XZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42030
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42030:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@XZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::Base
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z PROC NEAR ; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	76					; 0000004cH
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z ENDP ; Destruct
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z ; CUtlMemory<CBaseEntity *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
_TEXT	ENDS
PUBLIC	?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXHH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ShiftElementsRight
PUBLIC	?Construct@@YAXPAPAVCBaseEntity@@@Z		; Construct
;	COMDAT ?InsertBefore@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHH@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
?InsertBefore@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHH@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::InsertBefore, COMDAT

; 493  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 494  : 	// Can insert at the end
; 495  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L42037
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42037
	push	495					; 000001efH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42037:

; 496  : 
; 497  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::GrowVector

; 498  : 	ShiftElementsRight(elem);

	push	1
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXHH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ShiftElementsRight

; 499  : 	Construct( &Element(elem) );

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
	push	eax
	call	?Construct@@YAXPAPAVCBaseEntity@@@Z	; Construct
	add	esp, 4

; 500  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 501  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InsertBefore@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHH@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ	; CUtlMemory<CBaseEntity *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ ; CUtlMemory<CBaseEntity *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Purge
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PAVCBaseEntity@@H@@IAEXXZ ; CUtlMemory<CBaseEntity *,int>::ValidateGrowSize
;	COMDAT ??0?$CUtlMemory@PAVCBaseEntity@@H@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PAVCBaseEntity@@H@@QAE@HH@Z PROC NEAR	; CUtlMemory<CBaseEntity *,int>::CUtlMemory<CBaseEntity *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PAVCBaseEntity@@H@@IAEXXZ ; CUtlMemory<CBaseEntity *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L42042
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42042:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L40766

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L40766:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PAVCBaseEntity@@H@@QAE@HH@Z ENDP	; CUtlMemory<CBaseEntity *,int>::CUtlMemory<CBaseEntity *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ PROC NEAR	; CUtlMemory<CBaseEntity *,int>::~CUtlMemory<CBaseEntity *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ ; CUtlMemory<CBaseEntity *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ ENDP		; CUtlMemory<CBaseEntity *,int>::~CUtlMemory<CBaseEntity *,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NH@Z ; CUtlMemory<CBaseEntity *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ; CUtlMemory<CBaseEntity *,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z PROC NEAR ; CUtlMemory<CBaseEntity *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ; CUtlMemory<CBaseEntity *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42047
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42047:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NH@Z ; CUtlMemory<CBaseEntity *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42048
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42048:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z ENDP ; CUtlMemory<CBaseEntity *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PAVCBaseEntity@@H@@QAEPAPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PAVCBaseEntity@@H@@QAEPAPAVCBaseEntity@@XZ PROC NEAR ; CUtlMemory<CBaseEntity *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ; CUtlMemory<CBaseEntity *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42051
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42051:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PAVCBaseEntity@@H@@QAEPAPAVCBaseEntity@@XZ ENDP ; CUtlMemory<CBaseEntity *,int>::Base
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAVCBaseEntity@@@Z PROC NEAR		; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAVCBaseEntity@@@Z ENDP			; Destruct
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@IAEXXZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@IAEXXZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@IAEXXZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@IAEXXZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PAVCBaseEntity@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PAVCBaseEntity@@H@@IAEXXZ PROC NEAR ; CUtlMemory<CBaseEntity *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PAVCBaseEntity@@H@@IAEXXZ ENDP ; CUtlMemory<CBaseEntity *,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L42062
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L42062
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L42063
$L42062:
	mov	DWORD PTR -8+[ebp], 0
$L42063:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEXH@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXH@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L40852

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEXH@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::Grow
$L40852:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXH@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::GrowVector
_TEXT	ENDS
PUBLIC	??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
EXTRN	_memmove:NEAR
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ DB 'I'
	DB	'sValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 )', 00H ; `string'
CONST	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXHH@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42068
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L42068
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L42068
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42068:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L40860
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L40860

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 4
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L40860:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@@@IAEXHH@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPusherInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int> >::ShiftElementsRight
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L42071
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L42071
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L42072
$L42071:
	mov	DWORD PTR -8+[ebp], 0
$L42072:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NH@Z ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40871

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L40872

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L40872:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L40871:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsReadOnly
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0PhysicsPusherInfo_t@CPhysicsPushedEntities@@QAE@XZ ; CPhysicsPushedEntities::PhysicsPusherInfo_t::PhysicsPusherInfo_t
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlmemory.h
xdata$x	SEGMENT
__ehfuncinfo$?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z$0
xdata$x	ENDS
;	COMDAT ?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z
_TEXT	SEGMENT
$T42079 = -16
$T42080 = -20
__$EHRec$ = -12
_pMemory$ = 8
?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z PROC NEAR ; Construct, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 38   : 	new( pMemory ) T;

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T42080[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T42080[ebp], 0
	je	SHORT $L42081
	mov	ecx, DWORD PTR $T42080[ebp]
	call	??0PhysicsPusherInfo_t@CPhysicsPushedEntities@@QAE@XZ ; CPhysicsPushedEntities::PhysicsPusherInfo_t::PhysicsPusherInfo_t
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L42082
$L42081:
	mov	DWORD PTR -24+[ebp], 0
$L42082:
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T42079[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 39   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z$0:
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T42080[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?Construct@@YAXPAUPhysicsPusherInfo_t@CPhysicsPushedEntities@@@Z ENDP ; Construct
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 79   : 	{return; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L42096
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L42096
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L42097
$L42096:
	mov	DWORD PTR -8+[ebp], 0
$L42097:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEXH@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXH@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L40891

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEXH@Z ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::Grow
$L40891:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXXZ ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXH@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::GrowVector
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXHH@Z PROC NEAR ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QBE_NH@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42102
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L42102
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L42102
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42102:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L40899
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L40899

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	imul	edx, 76					; 0000004cH
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@QAEAAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@Z ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L40899:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@V?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@@@IAEXHH@Z ENDP ; CUtlArray<CPhysicsPushedEntities::PhysicsPushedInfo_t,CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int> >::ShiftElementsRight
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L42105
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L42105
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L42106
$L42105:
	mov	DWORD PTR -8+[ebp], 0
$L42106:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NH@Z ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40910

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L40911

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L40911:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L40910:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEXXZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsReadOnly
_TEXT	ENDS
PUBLIC	??0PhysicsPushedInfo_t@CPhysicsPushedEntities@@QAE@XZ ; CPhysicsPushedEntities::PhysicsPushedInfo_t::PhysicsPushedInfo_t
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlmemory.h
xdata$x	SEGMENT
__ehfuncinfo$?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z$0
xdata$x	ENDS
;	COMDAT ?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z
_TEXT	SEGMENT
$T42113 = -16
$T42114 = -20
__$EHRec$ = -12
_pMemory$ = 8
?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z PROC NEAR ; Construct, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 38   : 	new( pMemory ) T;

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	76					; 0000004cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T42114[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T42114[ebp], 0
	je	SHORT $L42115
	mov	ecx, DWORD PTR $T42114[ebp]
	call	??0PhysicsPushedInfo_t@CPhysicsPushedEntities@@QAE@XZ ; CPhysicsPushedEntities::PhysicsPushedInfo_t::PhysicsPushedInfo_t
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L42116
$L42115:
	mov	DWORD PTR -24+[ebp], 0
$L42116:
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T42113[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 39   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z$0:
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T42114[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?Construct@@YAXPAUPhysicsPushedInfo_t@CPhysicsPushedEntities@@@Z ENDP ; Construct
;	COMDAT ?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L42126
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L42126
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L42127
$L42126:
	mov	DWORD PTR -8+[ebp], 0
$L42127:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ ; CUtlMemory<CBaseEntity *,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXH@Z	; CUtlMemory<CBaseEntity *,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXH@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ ; CUtlMemory<CBaseEntity *,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L40930

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ ; CUtlMemory<CBaseEntity *,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXH@Z ; CUtlMemory<CBaseEntity *,int>::Grow
$L40930:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXH@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::GrowVector
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXHH@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42132
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L42132
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L42132
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42132:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L40938
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L40938

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L40938:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXHH@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ShiftElementsRight
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CBaseEntity *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L42135
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L42135
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L42136
$L42135:
	mov	DWORD PTR -8+[ebp], 0
$L42136:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NH@Z ENDP ; CUtlMemory<CBaseEntity *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ; CUtlMemory<CBaseEntity *,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ PROC NEAR	; CUtlMemory<CBaseEntity *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ; CUtlMemory<CBaseEntity *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40949

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L40950

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L40950:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L40949:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ ENDP	; CUtlMemory<CBaseEntity *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CBaseEntity *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ENDP ; CUtlMemory<CBaseEntity *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?Construct@@YAXPAPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T42143 = -4
_pMemory$ = 8
?Construct@@YAXPAPAVCBaseEntity@@@Z PROC NEAR		; Construct, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 38   : 	new( pMemory ) T;

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T42143[ebp], eax

; 39   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Construct@@YAXPAPAVCBaseEntity@@@Z ENDP		; Construct
_TEXT	ENDS
;	COMDAT ??0PhysicsPusherInfo_t@CPhysicsPushedEntities@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0PhysicsPusherInfo_t@CPhysicsPushedEntities@@QAE@XZ PROC NEAR ; CPhysicsPushedEntities::PhysicsPusherInfo_t::PhysicsPusherInfo_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0PhysicsPusherInfo_t@CPhysicsPushedEntities@@QAE@XZ ENDP ; CPhysicsPushedEntities::PhysicsPusherInfo_t::PhysicsPusherInfo_t
_TEXT	ENDS
;	COMDAT ??0PhysicsPushedInfo_t@CPhysicsPushedEntities@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0PhysicsPushedInfo_t@CPhysicsPushedEntities@@QAE@XZ PROC NEAR ; CPhysicsPushedEntities::PhysicsPushedInfo_t::PhysicsPushedInfo_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0PhysicsPushedInfo_t@CPhysicsPushedEntities@@QAE@XZ ENDP ; CPhysicsPushedEntities::PhysicsPushedInfo_t::PhysicsPushedInfo_t
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::NumAllocated
_TEXT	ENDS
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEXH@Z PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L42152
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42152:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41016

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L42153
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42153:

; 567  : 		return;

	jmp	$L41014
$L41016:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	16					; 00000010H
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L41035

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L41027
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L41027

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L41035
$L41027:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L41031

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L42154
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42154:

; 589  : 				return;

	jmp	$L41014
$L41031:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L41035

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L41031
$L41035:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L41038

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L42155
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42155:

; 603  : 	else

	jmp	SHORT $L42156
$L41038:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L42156
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42156:
$L41014:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QAEXH@Z ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L28985

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L28990
$L28985:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L28987

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L28987:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L28990

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L28987
$L28990:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UPhysicsPusherInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPusherInfo_t,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBEHXZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::NumAllocated
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEXH@Z PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L42165
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42165:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41057

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L42166
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42166:

; 567  : 		return;

	jmp	$L41055
$L41057:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	76					; 0000004cH
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L41076

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L41068
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L41068

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L41076
$L41068:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L41072

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L42167
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42167:

; 589  : 				return;

	jmp	$L41055
$L41072:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L41076

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L41072
$L41076:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L41079

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L42168
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42168:

; 603  : 	else

	jmp	SHORT $L42169
$L41079:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L42169
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42169:
$L41055:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QAEXH@Z ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::Grow
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UPhysicsPushedInfo_t@CPhysicsPushedEntities@@H@@QBE_NXZ ENDP ; CUtlMemory<CPhysicsPushedEntities::PhysicsPushedInfo_t,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ PROC NEAR ; CUtlMemory<CBaseEntity *,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ ENDP ; CUtlMemory<CBaseEntity *,int>::NumAllocated
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXH@Z PROC NEAR	; CUtlMemory<CBaseEntity *,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L42176
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42176:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ; CUtlMemory<CBaseEntity *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41098

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L42177
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42177:

; 567  : 		return;

	jmp	$L41096
$L41098:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	4
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L41117

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L41109
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L41109

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L41117
$L41109:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L41113

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L42178
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42178:

; 589  : 				return;

	jmp	$L41096
$L41113:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L41117

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L41113
$L41117:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L41120

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L42179
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42179:

; 603  : 	else

	jmp	SHORT $L42180
$L41120:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L42180
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L42180:
$L41096:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXH@Z ENDP	; CUtlMemory<CBaseEntity *,int>::Grow
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CBaseEntity *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ENDP ; CUtlMemory<CBaseEntity *,int>::IsExternallyAllocated
_TEXT	ENDS
END
