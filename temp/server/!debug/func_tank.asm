	TITLE	Z:\XashXTSRC\server\func_tank.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGEN@AnimateUntilDead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09ODDL@CBaseTank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LGOC@m_yawRate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07COHG@yawrate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@FNPK@m_yawRange?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08HEGC@yawrange?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@CHLD@m_yawTolerance?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@CDJF@yawtolerance?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OPBD@m_pitchRate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HOHM@pitchrate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@FMKD@m_pitchRange?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OADC@pitchrange?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@KKBE@m_pitchTolerance?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@NJEC@pitchtolerance?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@FIDB@m_fireRate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08NPEB@firerate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09OHPN@m_persist?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BBKD@persistence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OJKH@m_minRange?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MEJF@minRange?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LKMI@m_maxRange?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08JHPK@maxRange?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@HNDL@m_spriteScale?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FKCJ@spritescale?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FPBL@m_iszSpriteSmoke?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@LCMC@spritesmoke?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@KPOA@m_iszSpriteFlash?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@ECDJ@spriteflash?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@IPOC@m_bulletType?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06EBCC@bullet?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08OJPE@m_spread?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@ODJJ@firespread?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@EBJ@m_iBulletDamage?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@CAIB@bullet_damage?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@FGJJ@m_iszFireMaster?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@JBKM@firemaster?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@DJEL@m_iszFireTarget?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@POHO@firetarget?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@CBCF@m_iTankClass?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IAEJ@m_iClass?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GDEF@m_yawCenter?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MFEE@m_pitchCenter?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@JKNO@m_fireLast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LINK@m_lastSightTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GHBF@m_pControls?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@HMMP@m_flNextAttack?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@CKID@m_sightOrigin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@IOIG@m_barrelPos?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06MDNP@barrel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07CALM@barrely?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07NPAF@barrelz?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@DB@rotatesound?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@HCMJ@using?5TANK?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@KBIP@leave?5TANK?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@KOLE@func_tracktrain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MDCK@monster_target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BEDO@func_tank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@JLJO@func_tanklaser?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@GDKG@CFuncTankLaser?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CLDG@m_pLaser?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OAJH@m_laserTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@OKIM@Laser?5tank?5with?5no?5env_laser?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@JAJF@laserentity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JOGA@env_laser?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@IDLO@func_tankrocket?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@CFGE@rpg_rocket?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@EGMI@func_tankmortar?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PKDI@iMagnitude?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@GHMC@func_tankcontrols?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@JHCF@CFuncTankControls?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@ODHM@m_pController?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@IBKD@m_vecControllerUsePos?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GFDK@m_iTankName?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08PAE@m_cTanks?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MDKF@m_fVerifyTanks?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModel@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMoveDoneTime@CBaseEntity@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPointEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTransparency@CSprite@@QAEXHHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetScale@CSprite@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AnimateAndDie@CSprite@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateTargetPosition@CBaseTank@@UAE?AVVector@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseTank@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsActive@CBaseTank@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TankActivate@CBaseTank@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TankDeactivate@CBaseTank@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanFire@CBaseTank@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BarrelPosition@CBaseTank@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseTank@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncTankControls@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CBaseTank@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CBaseTank@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E35
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E40
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E41
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseTank@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseTank@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseTank@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartControl@CBaseTank@@QAEHPAVCBasePlayer@@PAVCFuncTankControls@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopControl@CBaseTank@@QAEXPAVCFuncTankControls@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseTank@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindTarget@CBaseTank@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IRelationship@CBaseTank@@QAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InRange@CBaseTank@@QAEHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CBaseTank@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrackTarget@CBaseTank@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdjustAnglesForBarrel@CBaseTank@@QAEXAAVVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TryFire@CBaseTank@@QAEXABVVector@@0PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TankTrace@CBaseTank@@QAEXABVVector@@00AAUgametrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartRotSound@CBaseTank@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopRotSound@CBaseTank@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E43
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E44
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fire@CFuncTankGun@@UAEXABVVector@@0PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CFuncTankLaser@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CFuncTankLaser@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E50
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E51
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E54
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CFuncTankLaser@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CFuncTankLaser@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLaser@CFuncTankLaser@@QAEPAVCLaser@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CFuncTankLaser@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fire@CFuncTankLaser@@UAEXABVVector@@0PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E56
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CFuncTankRocket@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fire@CFuncTankRocket@@UAEXABVVector@@0PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E58
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E59
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CFuncTankMortar@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CFuncTankMortar@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fire@CFuncTankMortar@@UAEXABVVector@@0PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E61
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E62
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CFuncTankControls@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CFuncTankControls@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E64
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E65
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E68
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CFuncTankControls@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CFuncTankControls@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControls@CFuncTankControls@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HandleTank@CFuncTankControls@@QAEXPAVCBaseEntity@@0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CFuncTankControls@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTankGun@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncTankGun@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTankGun@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTankGun@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTankLaser@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncTankLaser@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTankLaser@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTankLaser@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTankRocket@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncTankRocket@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTankRocket@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTankRocket@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTankMortar@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncTankMortar@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTankMortar@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTankMortar@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTankControls@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCFuncTankControls@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTankControls@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTankControls@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseTank@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncTankGun@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncTankLaser@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncTankRocket@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncTankMortar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFuncTankControls@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseTank@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseTank@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncTankGun@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncTankRocket@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncTankRocket@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncTankLaser@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncTankMortar@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncTankMortar@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncTankControls@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncTankControls@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCFuncTankLaser@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFuncTankGun@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseTank@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??_C@_0P@GDKG@CFuncTankLaser?$AA@		; `string'
PUBLIC	?g_DataMapHolder@CFuncTankLaser_DataDescInit@@3PAUdatamap_s@@A ; CFuncTankLaser_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_08CLDG@m_pLaser?$AA@			; `string'
PUBLIC	??_C@_0M@OAJH@m_laserTime?$AA@			; `string'
PUBLIC	?m_DataMap@CBaseTank@@2Udatamap_s@@A		; CBaseTank::m_DataMap
PUBLIC	??_C@_0BC@JHCF@CFuncTankControls?$AA@		; `string'
PUBLIC	?g_DataMapHolder@CFuncTankControls_DataDescInit@@3PAUdatamap_s@@A ; CFuncTankControls_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0O@ODHM@m_pController?$AA@		; `string'
PUBLIC	??_C@_0BG@IBKD@m_vecControllerUsePos?$AA@	; `string'
PUBLIC	??_C@_0M@GFDK@m_iTankName?$AA@			; `string'
PUBLIC	??_C@_08PAE@m_cTanks?$AA@			; `string'
PUBLIC	??_C@_0P@MDKF@m_fVerifyTanks?$AA@		; `string'
PUBLIC	?m_DataMap@CFuncTankControls@@2Udatamap_s@@A	; CFuncTankControls::m_DataMap
PUBLIC	??_C@_09ODDL@CBaseTank?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CBaseTank_DataDescInit@@3PAUdatamap_s@@A ; CBaseTank_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_09LGOC@m_yawRate?$AA@			; `string'
PUBLIC	??_C@_07COHG@yawrate?$AA@			; `string'
PUBLIC	??_C@_0L@FNPK@m_yawRange?$AA@			; `string'
PUBLIC	??_C@_08HEGC@yawrange?$AA@			; `string'
PUBLIC	??_C@_0P@CHLD@m_yawTolerance?$AA@		; `string'
PUBLIC	??_C@_0N@CDJF@yawtolerance?$AA@			; `string'
PUBLIC	??_C@_0M@OPBD@m_pitchRate?$AA@			; `string'
PUBLIC	??_C@_09HOHM@pitchrate?$AA@			; `string'
PUBLIC	??_C@_0N@FMKD@m_pitchRange?$AA@			; `string'
PUBLIC	??_C@_0L@OADC@pitchrange?$AA@			; `string'
PUBLIC	??_C@_0BB@KKBE@m_pitchTolerance?$AA@		; `string'
PUBLIC	??_C@_0P@NJEC@pitchtolerance?$AA@		; `string'
PUBLIC	??_C@_0L@FIDB@m_fireRate?$AA@			; `string'
PUBLIC	??_C@_08NPEB@firerate?$AA@			; `string'
PUBLIC	??_C@_09OHPN@m_persist?$AA@			; `string'
PUBLIC	??_C@_0M@BBKD@persistence?$AA@			; `string'
PUBLIC	??_C@_0L@OJKH@m_minRange?$AA@			; `string'
PUBLIC	??_C@_08MEJF@minRange?$AA@			; `string'
PUBLIC	??_C@_0L@LKMI@m_maxRange?$AA@			; `string'
PUBLIC	??_C@_08JHPK@maxRange?$AA@			; `string'
PUBLIC	??_C@_0O@HNDL@m_spriteScale?$AA@		; `string'
PUBLIC	??_C@_0M@FKCJ@spritescale?$AA@			; `string'
PUBLIC	??_C@_0BB@FPBL@m_iszSpriteSmoke?$AA@		; `string'
PUBLIC	??_C@_0M@LCMC@spritesmoke?$AA@			; `string'
PUBLIC	??_C@_0BB@KPOA@m_iszSpriteFlash?$AA@		; `string'
PUBLIC	??_C@_0M@ECDJ@spriteflash?$AA@			; `string'
PUBLIC	??_C@_0N@IPOC@m_bulletType?$AA@			; `string'
PUBLIC	??_C@_06EBCC@bullet?$AA@			; `string'
PUBLIC	??_C@_08OJPE@m_spread?$AA@			; `string'
PUBLIC	??_C@_0L@ODJJ@firespread?$AA@			; `string'
PUBLIC	??_C@_0BA@EBJ@m_iBulletDamage?$AA@		; `string'
PUBLIC	??_C@_0O@CAIB@bullet_damage?$AA@		; `string'
PUBLIC	??_C@_0BA@FGJJ@m_iszFireMaster?$AA@		; `string'
PUBLIC	??_C@_0L@JBKM@firemaster?$AA@			; `string'
PUBLIC	??_C@_0BA@DJEL@m_iszFireTarget?$AA@		; `string'
PUBLIC	??_C@_0L@POHO@firetarget?$AA@			; `string'
PUBLIC	??_C@_0N@CBCF@m_iTankClass?$AA@			; `string'
PUBLIC	??_C@_08IAEJ@m_iClass?$AA@			; `string'
PUBLIC	??_C@_0M@GDEF@m_yawCenter?$AA@			; `string'
PUBLIC	??_C@_0O@MFEE@m_pitchCenter?$AA@		; `string'
PUBLIC	??_C@_0L@JKNO@m_fireLast?$AA@			; `string'
PUBLIC	??_C@_0BA@LINK@m_lastSightTime?$AA@		; `string'
PUBLIC	??_C@_0M@GHBF@m_pControls?$AA@			; `string'
PUBLIC	??_C@_0P@HMMP@m_flNextAttack?$AA@		; `string'
PUBLIC	??_C@_0O@CKID@m_sightOrigin?$AA@		; `string'
PUBLIC	??_C@_0M@IOIG@m_barrelPos?$AA@			; `string'
PUBLIC	?m_DataMap@CFuncTankLaser@@2Udatamap_s@@A	; CFuncTankLaser::m_DataMap
_BSS	SEGMENT
?g_DataMapHolder@CFuncTankLaser_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CFuncTankLaser_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CFuncTankControls_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CFuncTankControls_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CBaseTank_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CBaseTank_DataDescInit::g_DataMapHolder
_BSS	ENDS
_DATA	SEGMENT
?m_DataMap@CBaseTank@@2Udatamap_s@@A DD 00H		; CBaseTank::m_DataMap
	DD	00H
	DD	FLAT:??_C@_09ODDL@CBaseTank?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S37	DD	FLAT:_$E36
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_09LGOC@m_yawRate?$AA@
	DD	070cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07COHG@yawrate?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@FNPK@m_yawRange?$AA@
	DD	0710H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08HEGC@yawrange?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0P@CHLD@m_yawTolerance?$AA@
	DD	0714H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0N@CDJF@yawtolerance?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0M@OPBD@m_pitchRate?$AA@
	DD	071cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_09HOHM@pitchrate?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0N@FMKD@m_pitchRange?$AA@
	DD	0720H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@OADC@pitchrange?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BB@KKBE@m_pitchTolerance?$AA@
	DD	0724H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0P@NJEC@pitchtolerance?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@FIDB@m_fireRate?$AA@
	DD	072cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08NPEB@firerate?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_09OHPN@m_persist?$AA@
	DD	0734H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@BBKD@persistence?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@OJKH@m_minRange?$AA@
	DD	0738H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08MEJF@minRange?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@LKMI@m_maxRange?$AA@
	DD	073cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08JHPK@maxRange?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0O@HNDL@m_spriteScale?$AA@
	DD	074cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@FKCJ@spritescale?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0BB@FPBL@m_iszSpriteSmoke?$AA@
	DD	0750H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@LCMC@spritesmoke?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0BB@KPOA@m_iszSpriteFlash?$AA@
	DD	0754H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@ECDJ@spriteflash?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0N@IPOC@m_bulletType?$AA@
	DD	0758H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06EBCC@bullet?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08OJPE@m_spread?$AA@
	DD	076cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@ODJJ@firespread?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BA@EBJ@m_iBulletDamage?$AA@
	DD	075cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0O@CAIB@bullet_damage?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0BA@FGJJ@m_iszFireMaster?$AA@
	DD	0774H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@JBKM@firemaster?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0BA@DJEL@m_iszFireTarget?$AA@
	DD	0778H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0L@POHO@firetarget?$AA@
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0N@CBCF@m_iTankClass?$AA@
	DD	077cH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_08IAEJ@m_iClass?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0M@GDEF@m_yawCenter?$AA@
	DD	0708H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0O@MFEE@m_pitchCenter?$AA@
	DD	0718H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0L@JKNO@m_fireLast?$AA@
	DD	0728H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BA@LINK@m_lastSightTime?$AA@
	DD	0730H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_0M@GHBF@m_pControls?$AA@
	DD	0700H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0P@HMMP@m_flNextAttack?$AA@
	DD	0704H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0O@CKID@m_sightOrigin?$AA@
	DD	0760H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0M@IOIG@m_barrelPos?$AA@
	DD	0740H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S42	DD	FLAT:_$E41
_$S45	DD	FLAT:_$E44
_$S49	DD	FLAT:_$E48
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CFuncTankLaser@@2Udatamap_s@@A DD 00H	; CFuncTankLaser::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0P@GDKG@CFuncTankLaser?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S52	DD	FLAT:_$E51
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_08CLDG@m_pLaser?$AA@
	DD	0780H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0M@OAJH@m_laserTime?$AA@
	DD	0784H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S57	DD	FLAT:_$E56
_$S60	DD	FLAT:_$E59
_$S63	DD	FLAT:_$E62
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CFuncTankControls@@2Udatamap_s@@A DD 00H	; CFuncTankControls::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0BC@JHCF@CFuncTankControls?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S66	DD	FLAT:_$E65
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_0O@ODHM@m_pController?$AA@
	DD	0700H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0BG@IBKD@m_vecControllerUsePos?$AA@
	DD	0704H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0M@GFDK@m_iTankName?$AA@
	DD	0710H
	DW	030H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08PAE@m_cTanks?$AA@
	DD	07d0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_0P@MDKF@m_fVerifyTanks?$AA@
	DD	07d4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_09ODDL@CBaseTank?$AA@
CONST	SEGMENT
??_C@_09ODDL@CBaseTank?$AA@ DB 'CBaseTank', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LGOC@m_yawRate?$AA@
CONST	SEGMENT
??_C@_09LGOC@m_yawRate?$AA@ DB 'm_yawRate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07COHG@yawrate?$AA@
CONST	SEGMENT
??_C@_07COHG@yawrate?$AA@ DB 'yawrate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FNPK@m_yawRange?$AA@
CONST	SEGMENT
??_C@_0L@FNPK@m_yawRange?$AA@ DB 'm_yawRange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HEGC@yawrange?$AA@
CONST	SEGMENT
??_C@_08HEGC@yawrange?$AA@ DB 'yawrange', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CHLD@m_yawTolerance?$AA@
CONST	SEGMENT
??_C@_0P@CHLD@m_yawTolerance?$AA@ DB 'm_yawTolerance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CDJF@yawtolerance?$AA@
CONST	SEGMENT
??_C@_0N@CDJF@yawtolerance?$AA@ DB 'yawtolerance', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OPBD@m_pitchRate?$AA@
CONST	SEGMENT
??_C@_0M@OPBD@m_pitchRate?$AA@ DB 'm_pitchRate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HOHM@pitchrate?$AA@
CONST	SEGMENT
??_C@_09HOHM@pitchrate?$AA@ DB 'pitchrate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FMKD@m_pitchRange?$AA@
CONST	SEGMENT
??_C@_0N@FMKD@m_pitchRange?$AA@ DB 'm_pitchRange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OADC@pitchrange?$AA@
CONST	SEGMENT
??_C@_0L@OADC@pitchrange?$AA@ DB 'pitchrange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KKBE@m_pitchTolerance?$AA@
CONST	SEGMENT
??_C@_0BB@KKBE@m_pitchTolerance?$AA@ DB 'm_pitchTolerance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NJEC@pitchtolerance?$AA@
CONST	SEGMENT
??_C@_0P@NJEC@pitchtolerance?$AA@ DB 'pitchtolerance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FIDB@m_fireRate?$AA@
CONST	SEGMENT
??_C@_0L@FIDB@m_fireRate?$AA@ DB 'm_fireRate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NPEB@firerate?$AA@
CONST	SEGMENT
??_C@_08NPEB@firerate?$AA@ DB 'firerate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OHPN@m_persist?$AA@
CONST	SEGMENT
??_C@_09OHPN@m_persist?$AA@ DB 'm_persist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BBKD@persistence?$AA@
CONST	SEGMENT
??_C@_0M@BBKD@persistence?$AA@ DB 'persistence', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OJKH@m_minRange?$AA@
CONST	SEGMENT
??_C@_0L@OJKH@m_minRange?$AA@ DB 'm_minRange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MEJF@minRange?$AA@
CONST	SEGMENT
??_C@_08MEJF@minRange?$AA@ DB 'minRange', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LKMI@m_maxRange?$AA@
CONST	SEGMENT
??_C@_0L@LKMI@m_maxRange?$AA@ DB 'm_maxRange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JHPK@maxRange?$AA@
CONST	SEGMENT
??_C@_08JHPK@maxRange?$AA@ DB 'maxRange', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HNDL@m_spriteScale?$AA@
CONST	SEGMENT
??_C@_0O@HNDL@m_spriteScale?$AA@ DB 'm_spriteScale', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FKCJ@spritescale?$AA@
CONST	SEGMENT
??_C@_0M@FKCJ@spritescale?$AA@ DB 'spritescale', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FPBL@m_iszSpriteSmoke?$AA@
CONST	SEGMENT
??_C@_0BB@FPBL@m_iszSpriteSmoke?$AA@ DB 'm_iszSpriteSmoke', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LCMC@spritesmoke?$AA@
CONST	SEGMENT
??_C@_0M@LCMC@spritesmoke?$AA@ DB 'spritesmoke', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KPOA@m_iszSpriteFlash?$AA@
CONST	SEGMENT
??_C@_0BB@KPOA@m_iszSpriteFlash?$AA@ DB 'm_iszSpriteFlash', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ECDJ@spriteflash?$AA@
CONST	SEGMENT
??_C@_0M@ECDJ@spriteflash?$AA@ DB 'spriteflash', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IPOC@m_bulletType?$AA@
CONST	SEGMENT
??_C@_0N@IPOC@m_bulletType?$AA@ DB 'm_bulletType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBCC@bullet?$AA@
CONST	SEGMENT
??_C@_06EBCC@bullet?$AA@ DB 'bullet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OJPE@m_spread?$AA@
CONST	SEGMENT
??_C@_08OJPE@m_spread?$AA@ DB 'm_spread', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ODJJ@firespread?$AA@
CONST	SEGMENT
??_C@_0L@ODJJ@firespread?$AA@ DB 'firespread', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EBJ@m_iBulletDamage?$AA@
CONST	SEGMENT
??_C@_0BA@EBJ@m_iBulletDamage?$AA@ DB 'm_iBulletDamage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CAIB@bullet_damage?$AA@
CONST	SEGMENT
??_C@_0O@CAIB@bullet_damage?$AA@ DB 'bullet_damage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FGJJ@m_iszFireMaster?$AA@
CONST	SEGMENT
??_C@_0BA@FGJJ@m_iszFireMaster?$AA@ DB 'm_iszFireMaster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JBKM@firemaster?$AA@
CONST	SEGMENT
??_C@_0L@JBKM@firemaster?$AA@ DB 'firemaster', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DJEL@m_iszFireTarget?$AA@
CONST	SEGMENT
??_C@_0BA@DJEL@m_iszFireTarget?$AA@ DB 'm_iszFireTarget', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@POHO@firetarget?$AA@
CONST	SEGMENT
??_C@_0L@POHO@firetarget?$AA@ DB 'firetarget', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CBCF@m_iTankClass?$AA@
CONST	SEGMENT
??_C@_0N@CBCF@m_iTankClass?$AA@ DB 'm_iTankClass', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IAEJ@m_iClass?$AA@
CONST	SEGMENT
??_C@_08IAEJ@m_iClass?$AA@ DB 'm_iClass', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GDEF@m_yawCenter?$AA@
CONST	SEGMENT
??_C@_0M@GDEF@m_yawCenter?$AA@ DB 'm_yawCenter', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MFEE@m_pitchCenter?$AA@
CONST	SEGMENT
??_C@_0O@MFEE@m_pitchCenter?$AA@ DB 'm_pitchCenter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JKNO@m_fireLast?$AA@
CONST	SEGMENT
??_C@_0L@JKNO@m_fireLast?$AA@ DB 'm_fireLast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LINK@m_lastSightTime?$AA@
CONST	SEGMENT
??_C@_0BA@LINK@m_lastSightTime?$AA@ DB 'm_lastSightTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GHBF@m_pControls?$AA@
CONST	SEGMENT
??_C@_0M@GHBF@m_pControls?$AA@ DB 'm_pControls', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HMMP@m_flNextAttack?$AA@
CONST	SEGMENT
??_C@_0P@HMMP@m_flNextAttack?$AA@ DB 'm_flNextAttack', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CKID@m_sightOrigin?$AA@
CONST	SEGMENT
??_C@_0O@CKID@m_sightOrigin?$AA@ DB 'm_sightOrigin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IOIG@m_barrelPos?$AA@
CONST	SEGMENT
??_C@_0M@IOIG@m_barrelPos?$AA@ DB 'm_barrelPos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GDKG@CFuncTankLaser?$AA@
CONST	SEGMENT
??_C@_0P@GDKG@CFuncTankLaser?$AA@ DB 'CFuncTankLaser', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CLDG@m_pLaser?$AA@
CONST	SEGMENT
??_C@_08CLDG@m_pLaser?$AA@ DB 'm_pLaser', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OAJH@m_laserTime?$AA@
CONST	SEGMENT
??_C@_0M@OAJH@m_laserTime?$AA@ DB 'm_laserTime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JHCF@CFuncTankControls?$AA@
CONST	SEGMENT
??_C@_0BC@JHCF@CFuncTankControls?$AA@ DB 'CFuncTankControls', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ODHM@m_pController?$AA@
CONST	SEGMENT
??_C@_0O@ODHM@m_pController?$AA@ DB 'm_pController', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IBKD@m_vecControllerUsePos?$AA@
CONST	SEGMENT
??_C@_0BG@IBKD@m_vecControllerUsePos?$AA@ DB 'm_vecControllerUsePos', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GFDK@m_iTankName?$AA@
CONST	SEGMENT
??_C@_0M@GFDK@m_iTankName?$AA@ DB 'm_iTankName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PAE@m_cTanks?$AA@
CONST	SEGMENT
??_C@_08PAE@m_cTanks?$AA@ DB 'm_cTanks', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MDKF@m_fVerifyTanks?$AA@
CONST	SEGMENT
??_C@_0P@MDKF@m_fVerifyTanks?$AA@ DB 'm_fVerifyTanks', 00H ; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CBaseTank@@UAEPAUdatamap_s@@XZ	; CBaseTank::GetDataDescMap
;	COMDAT ?GetDataDescMap@CBaseTank@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CBaseTank@@UAEPAUdatamap_s@@XZ PROC NEAR ; CBaseTank::GetDataDescMap, COMDAT

; 165  : BEGIN_DATADESC( CBaseTank )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CBaseTank@@2Udatamap_s@@A ; CBaseTank::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CBaseTank@@UAEPAUdatamap_s@@XZ ENDP	; CBaseTank::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CBaseTank@@SAPAUdatamap_s@@XZ	; CBaseTank::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CBaseTank@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CBaseTank@@SAPAUdatamap_s@@XZ PROC NEAR	; CBaseTank::GetBaseMap, COMDAT

; 165  : BEGIN_DATADESC( CBaseTank )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CBaseTank@@SAPAUdatamap_s@@XZ ENDP		; CBaseTank::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT
_$E36	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E35
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E36	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z	; DataMapInit
;	COMDAT _$E35
_TEXT	SEGMENT
_$E35	PROC NEAR					; COMDAT

; 165  : BEGIN_DATADESC( CBaseTank )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CBaseTank_DataDescInit@@3PAUdatamap_s@@A, eax ; CBaseTank_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E35	ENDP
_TEXT	ENDS
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z PROC NEAR ; DataMapInit, COMDAT

; 165  : BEGIN_DATADESC( CBaseTank )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L38365
	mov	cl, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_09ODDL@CBaseTank?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E39
	call	_atexit
	add	esp, 4
$L38365:
	call	?GetBaseMap@CBaseTank@@SAPAUdatamap_s@@XZ ; CBaseTank::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CBaseTank@@2Udatamap_s@@A+12, eax

; 166  : 	DEFINE_KEYFIELD( m_yawRate, FIELD_FLOAT, "yawrate" ),
; 167  : 	DEFINE_KEYFIELD( m_yawRange, FIELD_FLOAT, "yawrange" ),
; 168  : 	DEFINE_KEYFIELD( m_yawTolerance, FIELD_FLOAT, "yawtolerance" ),
; 169  : 	DEFINE_KEYFIELD( m_pitchRate, FIELD_FLOAT, "pitchrate" ),
; 170  : 	DEFINE_KEYFIELD( m_pitchRange, FIELD_FLOAT, "pitchrange" ),
; 171  : 	DEFINE_KEYFIELD( m_pitchTolerance, FIELD_FLOAT, "pitchtolerance" ),
; 172  : 	DEFINE_KEYFIELD( m_fireRate, FIELD_FLOAT, "firerate" ),
; 173  : 	DEFINE_KEYFIELD( m_persist, FIELD_FLOAT, "persistence" ),
; 174  : 	DEFINE_KEYFIELD( m_minRange, FIELD_FLOAT, "minRange" ),
; 175  : 	DEFINE_KEYFIELD( m_maxRange, FIELD_FLOAT, "maxRange" ),
; 176  : 	DEFINE_KEYFIELD( m_spriteScale, FIELD_FLOAT, "spritescale" ),
; 177  : 	DEFINE_KEYFIELD( m_iszSpriteSmoke, FIELD_STRING, "spritesmoke" ),
; 178  : 	DEFINE_KEYFIELD( m_iszSpriteFlash, FIELD_STRING, "spriteflash" ),
; 179  : 	DEFINE_KEYFIELD( m_bulletType, FIELD_INTEGER, "bullet" ),
; 180  : 	DEFINE_KEYFIELD( m_spread, FIELD_INTEGER, "firespread" ),
; 181  : 	DEFINE_KEYFIELD( m_iBulletDamage, FIELD_INTEGER, "bullet_damage" ),
; 182  : 	DEFINE_KEYFIELD( m_iszFireMaster, FIELD_STRING, "firemaster" ),
; 183  : 	DEFINE_KEYFIELD( m_iszFireTarget, FIELD_STRING, "firetarget" ),
; 184  : 	DEFINE_KEYFIELD( m_iTankClass, FIELD_INTEGER, "m_iClass" ),
; 185  : 	DEFINE_FIELD( m_yawCenter, FIELD_FLOAT ),
; 186  : 	DEFINE_FIELD( m_pitchCenter, FIELD_FLOAT ),
; 187  : 	DEFINE_FIELD( m_fireLast, FIELD_TIME ),
; 188  : 	DEFINE_FIELD( m_lastSightTime, FIELD_TIME ),
; 189  : 	DEFINE_FIELD( m_pControls, FIELD_CLASSPTR ),
; 190  : 	DEFINE_FIELD( m_flNextAttack, FIELD_TIME ),
; 191  : 	DEFINE_FIELD( m_sightOrigin, FIELD_VECTOR ),
; 192  : 	DEFINE_FIELD( m_barrelPos, FIELD_VECTOR ),
; 193  : END_DATADESC()

	mov	edx, 1
	test	edx, edx
	je	SHORT $L38469
	mov	DWORD PTR ?m_DataMap@CBaseTank@@2Udatamap_s@@A+4, 27 ; 0000001bH
	mov	DWORD PTR ?m_DataMap@CBaseTank@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L38470
$L38469:
	mov	DWORD PTR ?m_DataMap@CBaseTank@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CBaseTank@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z@4PAUtypedescription_s@@A
$L38470:
	mov	eax, OFFSET FLAT:?m_DataMap@CBaseTank@@2Udatamap_s@@A ; CBaseTank::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z ENDP	; DataMapInit
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
EXTRN	_strlen:NEAR
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_pszBase$ = 8
_this$ = -4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC NEAR	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E39
_TEXT	SEGMENT
_$E39	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTank@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E39	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
EXTRN	__except_list:DWORD
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File z:\xashxtsrc\common\datamap.h
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
$T40127 = -24
__$EHRec$ = -12
_this$ = -16
_i$ = -20
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC NEAR	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L30214
$L30215:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L30214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L30216

; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T40127[ebp], edx
	mov	eax, DWORD PTR $T40127[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 		}

	jmp	SHORT $L30215
$L30216:

; 202  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	ret	0
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E41
_TEXT	SEGMENT
_$E41	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E40
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E41	ENDP
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
EXTRN	__fltused:NEAR
_BSS	SEGMENT
	ALIGN	4

_gTankSpread DB	03cH DUP (?)
_BSS	ENDS
;	COMDAT _$E40
_TEXT	SEGMENT
$T40143 = -12
$T40144 = -24
$T40145 = -36
$T40146 = -48
$T40147 = -60
_$E40	PROC NEAR					; COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 199  : 	Vector( 0, 0, 0 ),		// perfect

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR $T40143[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, OFFSET FLAT:_gTankSpread
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 200  : 	Vector( 0.025, 0.025, 0.025 ),// small cone

	push	1020054733				; 3ccccccdH
	push	1020054733				; 3ccccccdH
	push	1020054733				; 3ccccccdH
	lea	ecx, DWORD PTR $T40144[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, OFFSET FLAT:_gTankSpread+12
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 201  : 	Vector( 0.05, 0.05, 0.05 ),	// medium cone

	push	1028443341				; 3d4ccccdH
	push	1028443341				; 3d4ccccdH
	push	1028443341				; 3d4ccccdH
	lea	ecx, DWORD PTR $T40145[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, OFFSET FLAT:_gTankSpread+24
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 202  : 	Vector( 0.1, 0.1, 0.1 ),	// large cone

	push	1036831949				; 3dcccccdH
	push	1036831949				; 3dcccccdH
	push	1036831949				; 3dcccccdH
	lea	ecx, DWORD PTR $T40146[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, OFFSET FLAT:_gTankSpread+36
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 203  : 	Vector( 0.25, 0.25, 0.25 ),	// extra-large cone

	push	1048576000				; 3e800000H
	push	1048576000				; 3e800000H
	push	1048576000				; 3e800000H
	lea	ecx, DWORD PTR $T40147[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, OFFSET FLAT:_gTankSpread+48
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 204  : };

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E40	ENDP
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	__real@4@00000000000000000000
PUBLIC	?Spawn@CBaseTank@@UAEXXZ			; CBaseTank::Spawn
PUBLIC	?IsActive@CBaseTank@@QAEHXZ			; CBaseTank::IsActive
PUBLIC	?BarrelPosition@CBaseTank@@QAE?AVVector@@XZ	; CBaseTank::BarrelPosition
PUBLIC	?GetModel@CBaseEntity@@QAEPBDXZ			; CBaseEntity::GetModel
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
EXTRN	?WorldPhysic@@3PAVIPhysicLayer@@A:DWORD		; WorldPhysic
EXTRN	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalOrigin
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAngles
EXTRN	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAngles
EXTRN	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z:NEAR ; UTIL_SetOrigin
;	COMDAT __real@4@00000000000000000000
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT ?Spawn@CBaseTank@@UAEXXZ
_TEXT	SEGMENT
$T40155 = -28
_this$ = -4
_angles$ = -16
?Spawn@CBaseTank@@UAEXXZ PROC NEAR			; CBaseTank::Spawn, COMDAT

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 208  : 	Precache();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 209  : 
; 210  : 	pev->movetype = MOVETYPE_PUSH;  // so it doesn't get pushed by anything

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 7

; 211  : 	pev->solid = SOLID_BSP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 4

; 212  : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 213  : 
; 214  : 	SetLocalAngles( m_vecTempAngles );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 215  : 	Vector angles = GetLocalAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 216  : 
; 217  : 	m_yawCenter = angles.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _angles$[ebp+4]
	mov	DWORD PTR [edx+1800], eax

; 218  : 	m_pitchCenter = angles.x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _angles$[ebp]
	mov	DWORD PTR [ecx+1816], edx

; 219  : 
; 220  : 	if ( IsActive() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsActive@CBaseTank@@QAEHXZ		; CBaseTank::IsActive
	test	eax, eax
	je	SHORT $L38489

; 221  : 		SetNextThink( 1.0 );

	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]
$L38489:

; 222  : 
; 223  : 	m_sightOrigin = BarrelPosition(); // Point at the end of the barrel

	lea	eax, DWORD PTR $T40155[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BarrelPosition@CBaseTank@@QAE?AVVector@@XZ ; CBaseTank::BarrelPosition
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 224  : 
; 225  : 	if ( m_fireRate <= 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1836]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38491

; 226  : 		m_fireRate = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1836], 1065353216	; 3f800000H
$L38491:

; 227  : 	if ( m_spread > MAX_FIRING_SPREADS )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1900], 5
	jbe	SHORT $L38492

; 228  : 		m_spread = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1900], 0
$L38492:

; 229  : 
; 230  : 	UTIL_SetOrigin( this, GetLocalOrigin());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 231  : 
; 232  : 	if( !m_pitchTolerance && !m_yawTolerance )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1828]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38493
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1812]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38493

; 233  : 		SetBits( pev->spawnflags, SF_TANK_LINEOFSIGHT );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+416], ecx
$L38493:

; 234  : 
; 235  : 	// create physic body
; 236  : 	m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 237  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseTank@@UAEXXZ ENDP				; CBaseTank::Spawn
_TEXT	ENDS
;	COMDAT ?GetModel@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetModel@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetModel, COMDAT

; 288  : 	const char*	GetModel() { return STRING( pev->model ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+184]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetModel@CBaseEntity@@QAEPBDXZ ENDP			; CBaseEntity::GetModel
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
;	COMDAT ?IsActive@CBaseTank@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsActive@CBaseTank@@QAEHXZ PROC NEAR			; CBaseTank::IsActive, COMDAT

; 78   : 	inline BOOL IsActive( void ) { return (pev->spawnflags & SF_TANK_ACTIVE) ? TRUE : FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+416]
	and	eax, 1
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsActive@CBaseTank@@QAEHXZ ENDP			; CBaseTank::IsActive
_TEXT	ENDS
PUBLIC	??0matrix4x4@@QAE@ABV0@@Z			; matrix4x4::matrix4x4
PUBLIC	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
EXTRN	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix4x4::VectorTransform
;	COMDAT ?BarrelPosition@CBaseTank@@QAE?AVVector@@XZ
_TEXT	SEGMENT
$T40168 = -80
___$ReturnUdt$ = 8
_this$ = -4
_entity$ = -68
?BarrelPosition@CBaseTank@@QAE?AVVector@@XZ PROC NEAR	; CBaseTank::BarrelPosition, COMDAT

; 90   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 		matrix4x4	entity = EntityToWorldTransform();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	push	eax
	lea	ecx, DWORD PTR _entity$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 92   : 		return entity.VectorTransform( m_barrelPos );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1856				; 00000740H
	push	eax
	lea	ecx, DWORD PTR $T40168[ebp]
	push	ecx
	lea	ecx, DWORD PTR _entity$[ebp]
	call	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorTransform
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 93   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?BarrelPosition@CBaseTank@@QAE?AVVector@@XZ ENDP	; CBaseTank::BarrelPosition
_TEXT	ENDS
PUBLIC	??0Vector4D@@QAE@ABV0@@Z			; Vector4D::Vector4D
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
_$S7$ = -8
_$S8$ = -12
_$S9$ = -16
??0matrix4x4@@QAE@ABV0@@Z PROC NEAR			; matrix4x4::matrix4x4, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S7$[ebp], 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _$S8$[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR _$S9$[ebp], ecx
$L26032:
	mov	edx, DWORD PTR _$S9$[ebp]
	push	edx
	mov	ecx, DWORD PTR _$S8$[ebp]
	call	??0Vector4D@@QAE@ABV0@@Z		; Vector4D::Vector4D
	mov	eax, DWORD PTR _$S8$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _$S8$[ebp], eax
	mov	ecx, DWORD PTR _$S9$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _$S9$[ebp], ecx
	mov	edx, DWORD PTR _$S7$[ebp]
	sub	edx, 1
	mov	DWORD PTR _$S7$[ebp], edx
	cmp	DWORD PTR _$S7$[ebp], 0
	ja	SHORT $L26032
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix4x4@@QAE@ABV0@@Z ENDP				; matrix4x4::matrix4x4
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector4D@@QAE@ABV0@@Z PROC NEAR			; Vector4D::Vector4D, COMDAT

; 313  : 	inline Vector4D( const Vector4D& v ) { x = v.x; y = v.y; z = v.z, w = v.w; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector4D@@QAE@ABV0@@Z ENDP				; Vector4D::Vector4D
_TEXT	ENDS
PUBLIC	??0matrix4x4@@QAE@ABVVector@@0M@Z		; matrix4x4::matrix4x4
EXTRN	??4matrix4x4@@QAEAAV0@ABV0@@Z:NEAR		; matrix4x4::operator=
EXTRN	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ:NEAR	; CBaseEntity::CalcAbsolutePosition
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ
_TEXT	SEGMENT
$T40175 = -68
$T40176 = -80
_this$ = -4
?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ PROC NEAR ; CBaseEntity::EntityToWorldTransform, COMDAT

; 732  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 733  : 	if( IsPlayer( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L35136

; 735  : 		m_local = matrix4x4( pev->origin, Vector( 0.0f, pev->angles.y, 0.0f ));

	push	1065353216				; 3f800000H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	push	0
	lea	ecx, DWORD PTR $T40176[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	push	ecx
	lea	ecx, DWORD PTR $T40175[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 737  : 	else if( pev->flags & FL_ABSTRANSFORM )

	jmp	SHORT $L35140
$L35136:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L35140

; 739  : 		CalcAbsolutePosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsolutePosition
$L35140:

; 741  : 	return m_local; 

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 180				; 000000b4H

; 742  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ENDP ; CBaseEntity::EntityToWorldTransform
_TEXT	ENDS
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	__real@8@3ff98efa351294e9c800
PUBLIC	??0Vector4D@@QAE@XZ				; Vector4D::Vector4D
PUBLIC	??BVector4D@@QAEPAMXZ				; Vector4D::operator float *
PUBLIC	?SinCos@@YAXMPAM0@Z				; SinCos
;	COMDAT __real@8@3ff98efa351294e9c800
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@8@3ff98efa351294e9c800 DQ 03f91df46a2529d39r ; 0.0174533
CONST	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT
_origin$ = 8
_angles$ = 12
_scale$ = 16
_this$ = -4
_angle$ = -8
_sr$ = -12
_sp$ = -16
_sy$ = -20
_cr$ = -24
_cp$ = -28
_cy$ = -32
??0matrix4x4@@QAE@ABVVector@@0M@Z PROC NEAR		; matrix4x4::matrix4x4, COMDAT

; 701  : 	_forceinline matrix4x4( const Vector &origin, const Vector &angles, float scale = 1.0f )

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 702  : 	{
; 703  : 		float	angle, sr, sp, sy, cr, cp, cy;
; 704  : 
; 705  : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25873

; 707  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 708  : 			SinCos( angle, &sy, &cy );

	lea	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 709  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 710  : 			SinCos( angle, &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 711  : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 712  : 			SinCos( angle, &sr, &cr );

	lea	ecx, DWORD PTR _cr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sr$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 713  : 
; 714  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax], ecx

; 715  : 			mat[1][0] = (sr*sp*cy+cr*-sy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _cr$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax], edx

; 716  : 			mat[2][0] = (cr*sp*cy+-sr*-sy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR [eax], ecx

; 717  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 718  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+4], edx

; 719  : 			mat[1][1] = (sr*sp*sy+cr*cy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 720  : 			mat[2][1] = (cr*sp*sy+-sr*cy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax+4], edx

; 721  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 722  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 723  : 			mat[1][2] = (sr*cp) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -64+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+8], edx

; 724  : 			mat[2][2] = (cr*cp) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 725  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 726  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 727  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 728  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 729  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 731  : 		else if( angles[PITCH] )

	jmp	$L25878
$L25873:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25875

; 733  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 734  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 735  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 736  : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 737  : 
; 738  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -72+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -72+[ebp]
	mov	DWORD PTR [eax], edx

; 739  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -76+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -76+[ebp]
	mov	DWORD PTR [eax], ecx

; 740  : 			mat[2][0] = (sp*cy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -80+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -80+[ebp]
	mov	DWORD PTR [eax], edx

; 741  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 742  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -84+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -84+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 743  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -88+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -88+[ebp]
	mov	DWORD PTR [eax+4], edx

; 744  : 			mat[2][1] = (sp*sy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -92+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -92+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 745  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 746  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -96+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -96+[ebp]
	mov	DWORD PTR [eax+8], edx

; 747  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 748  : 			mat[2][2] = (cp) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -100+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -100+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 749  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 750  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 751  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 752  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 753  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 755  : 		else if( angles[YAW] )

	jmp	$L25878
$L25875:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25877

; 757  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 758  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 759  : 
; 760  : 			mat[0][0] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -104+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -104+[ebp]
	mov	DWORD PTR [eax], edx

; 761  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -108+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -108+[ebp]
	mov	DWORD PTR [eax], ecx

; 762  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 763  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 764  : 			mat[0][1] = (sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -112+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -112+[ebp]
	mov	DWORD PTR [eax+4], edx

; 765  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -116+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -116+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 766  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 767  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 768  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 769  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 770  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], edx

; 771  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 772  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 773  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 774  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 775  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 777  : 		else

	jmp	$L25878
$L25877:

; 779  : 			mat[0][0] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax], ecx

; 780  : 			mat[1][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 781  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 782  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 783  : 			mat[0][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 784  : 			mat[1][1] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+4], edx

; 785  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 786  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 787  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 788  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 789  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 790  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 791  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 792  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 793  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 794  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H
$L25878:

; 796  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0matrix4x4@@QAE@ABVVector@@0M@Z ENDP			; matrix4x4::matrix4x4
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT
_angle$ = 8
_sine$ = 12
_cosine$ = 16
?SinCos@@YAXMPAM0@Z PROC NEAR				; SinCos, COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 37   : 	__asm
; 38   : 	{
; 39   : 		push	ecx

	push	ecx

; 40   : 		fld	dword ptr angle

	fld	DWORD PTR _angle$[ebp]

; 41   : 		fsincos

	fsincos

; 42   : 		mov	ecx, dword ptr[cosine]

	mov	ecx, DWORD PTR _cosine$[ebp]

; 43   : 		fstp      dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 44   : 		mov 	ecx, dword ptr[sine]

	mov	ecx, DWORD PTR _sine$[ebp]

; 45   : 		fstp	dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 46   : 		pop	ecx

	pop	ecx

; 47   : 	}
; 48   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SinCos@@YAXMPAM0@Z ENDP				; SinCos
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QBEPBMXZ PROC NEAR				; Vector::operator float const *, COMDAT

; 229  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector4D@@QAE@XZ PROC NEAR				; Vector4D::Vector4D, COMDAT

; 311  : 	inline Vector4D( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector4D@@QAE@XZ ENDP				; Vector4D::Vector4D
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector4D@@QAEPAMXZ PROC NEAR				; Vector4D::operator float *, COMDAT

; 325  : 	operator float *()					{ return &x; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector4D@@QAEPAMXZ ENDP				; Vector4D::operator float *
_TEXT	ENDS
PUBLIC	?Precache@CBaseTank@@UAEXXZ			; CBaseTank::Precache
;	COMDAT ?Precache@CBaseTank@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CBaseTank@@UAEXXZ PROC NEAR			; CBaseTank::Precache, COMDAT

; 240  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 241  : 	if ( m_iszSpriteSmoke )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1872], 0
	je	SHORT $L38498

; 242  : 		PRECACHE_MODEL( (char *)STRING(m_iszSpriteSmoke) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1872]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
$L38498:

; 243  : 
; 244  : 	if ( m_iszSpriteFlash )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1876], 0
	je	SHORT $L38500

; 245  : 		PRECACHE_MODEL( (char *)STRING(m_iszSpriteFlash) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1876]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
$L38500:

; 246  : 
; 247  : 	if ( pev->noise )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+488], 0
	je	SHORT $L38502

; 248  : 		PRECACHE_SOUND( (char *)STRING(pev->noise) );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+488]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4
$L38502:

; 249  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CBaseTank@@UAEXXZ ENDP			; CBaseTank::Precache
_TEXT	ENDS
PUBLIC	?KeyValue@CBaseTank@@UAEXPAUKeyValueData_s@@@Z	; CBaseTank::KeyValue
PUBLIC	??_C@_06MDNP@barrel?$AA@			; `string'
PUBLIC	??_C@_07CALM@barrely?$AA@			; `string'
PUBLIC	??_C@_07NPAF@barrelz?$AA@			; `string'
PUBLIC	??_C@_0M@DB@rotatesound?$AA@			; `string'
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
EXTRN	?Q_atof@@YAMPBD@Z:NEAR				; Q_atof
EXTRN	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseDelay::KeyValue
;	COMDAT ??_C@_06MDNP@barrel?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_06MDNP@barrel?$AA@ DB 'barrel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CALM@barrely?$AA@
CONST	SEGMENT
??_C@_07CALM@barrely?$AA@ DB 'barrely', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NPAF@barrelz?$AA@
CONST	SEGMENT
??_C@_07NPAF@barrelz?$AA@ DB 'barrelz', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DB@rotatesound?$AA@
CONST	SEGMENT
??_C@_0M@DB@rotatesound?$AA@ DB 'rotatesound', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseTank@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CBaseTank@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseTank::KeyValue, COMDAT

; 252  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 253  : 	if( FStrEq( pkvd->szKeyName, "yawrate" ))

	push	OFFSET FLAT:??_C@_07COHG@yawrate?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38508

; 255  : 		m_yawRate = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1804]

; 256  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 258  : 	else if( FStrEq( pkvd->szKeyName, "yawrange" ))

	jmp	$L38558
$L38508:
	push	OFFSET FLAT:??_C@_08HEGC@yawrange?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38510

; 260  : 		m_yawRange = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1808]

; 261  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 263  : 	else if( FStrEq( pkvd->szKeyName, "yawtolerance" ))

	jmp	$L38558
$L38510:
	push	OFFSET FLAT:??_C@_0N@CDJF@yawtolerance?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38512

; 265  : 		m_yawTolerance = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1812]

; 266  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 268  : 	else if( FStrEq( pkvd->szKeyName, "pitchrange" ))

	jmp	$L38558
$L38512:
	push	OFFSET FLAT:??_C@_0L@OADC@pitchrange?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38514

; 270  : 		m_pitchRange = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1824]

; 271  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 273  : 	else if( FStrEq( pkvd->szKeyName, "pitchrate" ))

	jmp	$L38558
$L38514:
	push	OFFSET FLAT:??_C@_09HOHM@pitchrate?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38516

; 275  : 		m_pitchRate = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1820]

; 276  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 278  : 	else if( FStrEq( pkvd->szKeyName, "pitchtolerance" ))

	jmp	$L38558
$L38516:
	push	OFFSET FLAT:??_C@_0P@NJEC@pitchtolerance?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38518

; 280  : 		m_pitchTolerance = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1828]

; 281  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 283  : 	else if( FStrEq( pkvd->szKeyName, "firerate" ))

	jmp	$L38558
$L38518:
	push	OFFSET FLAT:??_C@_08NPEB@firerate?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38520

; 285  : 		m_fireRate = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1836]

; 286  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 288  : 	else if( FStrEq( pkvd->szKeyName, "barrel" ))

	jmp	$L38558
$L38520:
	push	OFFSET FLAT:??_C@_06MDNP@barrel?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38522

; 290  : 		m_barrelPos.x = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1856]

; 291  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 293  : 	else if( FStrEq( pkvd->szKeyName, "barrely" ))

	jmp	$L38558
$L38522:
	push	OFFSET FLAT:??_C@_07CALM@barrely?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38525

; 295  : 		// HACKHACK: matrix uses the left-side hand
; 296  : 		// but matrices uses the right-side hand
; 297  : 		m_barrelPos.y = -Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	fchs
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1860]

; 298  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 300  : 	else if( FStrEq( pkvd->szKeyName, "barrelz" ))

	jmp	$L38558
$L38525:
	push	OFFSET FLAT:??_C@_07NPAF@barrelz?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38528

; 302  : 		m_barrelPos.z = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1864]

; 303  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 305  : 	else if( FStrEq( pkvd->szKeyName, "spritescale" ))

	jmp	$L38558
$L38528:
	push	OFFSET FLAT:??_C@_0M@FKCJ@spritescale?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38531

; 307  : 		m_spriteScale = Q_atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1868]

; 308  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 310  : 	else if( FStrEq( pkvd->szKeyName, "spritesmoke" ))

	jmp	$L38558
$L38531:
	push	OFFSET FLAT:??_C@_0M@LCMC@spritesmoke?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38533

; 312  : 		m_iszSpriteSmoke = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1872], eax

; 313  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 315  : 	else if( FStrEq( pkvd->szKeyName, "spriteflash" ))

	jmp	$L38558
$L38533:
	push	OFFSET FLAT:??_C@_0M@ECDJ@spriteflash?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38535

; 317  : 		m_iszSpriteFlash = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1876], eax

; 318  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 320  : 	else if( FStrEq( pkvd->szKeyName, "rotatesound" ))

	jmp	$L38558
$L38535:
	push	OFFSET FLAT:??_C@_0M@DB@rotatesound?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38537

; 322  : 		pev->noise = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 323  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 325  : 	else if( FStrEq( pkvd->szKeyName, "persistence" ))

	jmp	$L38558
$L38537:
	push	OFFSET FLAT:??_C@_0M@BBKD@persistence?$AA@ ; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38540

; 327  : 		m_persist = Q_atof( pkvd->szValue );

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1844]

; 328  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 330  : 	else if( FStrEq( pkvd->szKeyName, "bullet" ))

	jmp	$L38558
$L38540:
	push	OFFSET FLAT:??_C@_06EBCC@bullet?$AA@	; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38542

; 332  : 		m_bulletType = (TANKBULLET)Q_atoi( pkvd->szValue );

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1880], eax

; 333  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 335  : 	else if( FStrEq( pkvd->szKeyName, "bullet_damage" )) 

	jmp	$L38558
$L38542:
	push	OFFSET FLAT:??_C@_0O@CAIB@bullet_damage?$AA@ ; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38545

; 337  : 		m_iBulletDamage = Q_atoi( pkvd->szValue );

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1884], eax

; 338  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 340  : 	else if( FStrEq( pkvd->szKeyName, "firespread" ))

	jmp	$L38558
$L38545:
	push	OFFSET FLAT:??_C@_0L@ODJJ@firespread?$AA@ ; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38547

; 342  : 		m_spread = Q_atoi( pkvd->szValue );

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1900], eax

; 343  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 345  : 	else if( FStrEq( pkvd->szKeyName, "minRange" ))

	jmp	$L38558
$L38547:
	push	OFFSET FLAT:??_C@_08MEJF@minRange?$AA@	; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38549

; 347  : 		m_minRange = Q_atof( pkvd->szValue );

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1848]

; 348  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 350  : 	else if( FStrEq( pkvd->szKeyName, "maxRange" ))

	jmp	$L38558
$L38549:
	push	OFFSET FLAT:??_C@_08JHPK@maxRange?$AA@	; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38551

; 352  : 		m_maxRange = Q_atof( pkvd->szValue );

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1852]

; 353  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 355  : 	else if( FStrEq( pkvd->szKeyName, "firemaster" ))

	jmp	$L38558
$L38551:
	push	OFFSET FLAT:??_C@_0L@JBKM@firemaster?$AA@ ; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38553

; 357  : 		m_iszFireMaster = ALLOC_STRING( pkvd->szValue );

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1908], eax

; 358  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 360  : 	else if( FStrEq( pkvd->szKeyName, "firetarget" ))

	jmp	$L38558
$L38553:
	push	OFFSET FLAT:??_C@_0L@POHO@firetarget?$AA@ ; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38555

; 362  : 		m_iszFireTarget = ALLOC_STRING( pkvd->szValue );

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1912], eax

; 363  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 365  : 	else if( FStrEq( pkvd->szKeyName, "m_iClass" ))

	jmp	SHORT $L38558
$L38555:
	push	OFFSET FLAT:??_C@_08IAEJ@m_iClass?$AA@	; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38557

; 367  : 		m_iTankClass = Q_atoi( pkvd->szValue );

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1916], eax

; 368  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 370  : 	else

	jmp	SHORT $L38558
$L38557:

; 371  : 		BaseClass::KeyValue( pkvd );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z ; CBaseDelay::KeyValue
$L38558:

; 372  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseTank@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseTank::KeyValue
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
PUBLIC	?StartControl@CBaseTank@@QAEHPAVCBasePlayer@@PAVCFuncTankControls@@@Z ; CBaseTank::StartControl
PUBLIC	??_C@_0N@HCMJ@using?5TANK?$CB?6?$AA@		; `string'
EXTRN	?UTIL_IsMasterTriggered@@YAHHPAVCBaseEntity@@@Z:NEAR ; UTIL_IsMasterTriggered
;	COMDAT ??_C@_0N@HCMJ@using?5TANK?$CB?6?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_0N@HCMJ@using?5TANK?$CB?6?$AA@ DB 'using TANK!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?StartControl@CBaseTank@@QAEHPAVCBasePlayer@@PAVCFuncTankControls@@@Z
_TEXT	SEGMENT
_pController$ = 8
_pControls$ = 12
_this$ = -4
?StartControl@CBaseTank@@QAEHPAVCBasePlayer@@PAVCFuncTankControls@@@Z PROC NEAR ; CBaseTank::StartControl, COMDAT

; 375  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 376  : 	if ( m_pControls != NULL )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1792], 0
	je	SHORT $L38564

; 377  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L38563
$L38564:

; 378  : 
; 379  : 	// Team only or disabled?
; 380  : 	if ( m_iszMaster )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1904], 0
	je	SHORT $L38566

; 382  : 		if ( !UTIL_IsMasterTriggered( m_iszMaster, pController ) )

	mov	edx, DWORD PTR _pController$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1904]
	push	ecx
	call	?UTIL_IsMasterTriggered@@YAHHPAVCBaseEntity@@@Z ; UTIL_IsMasterTriggered
	add	esp, 8
	test	eax, eax
	jne	SHORT $L38566

; 383  : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L38563
$L38566:

; 385  : 
; 386  : 	ALERT( at_aiconsole, "using TANK!\n");

	push	OFFSET FLAT:??_C@_0N@HCMJ@using?5TANK?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 387  : 
; 388  : 	m_iState = STATE_ON;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 1

; 389  : 	m_pControls = pControls;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pControls$[ebp]
	mov	DWORD PTR [eax+1792], ecx

; 390  : 	
; 391  : 	SetNextThink( 0.3 );

	push	1050253722				; 3e99999aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]

; 392  : 	
; 393  : 	return TRUE;

	mov	eax, 1
$L38563:

; 394  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?StartControl@CBaseTank@@QAEHPAVCBasePlayer@@PAVCFuncTankControls@@@Z ENDP ; CBaseTank::StartControl
_TEXT	ENDS
PUBLIC	?StopRotSound@CBaseTank@@QAEXXZ			; CBaseTank::StopRotSound
PUBLIC	?StopControl@CBaseTank@@QAEXPAVCFuncTankControls@@@Z ; CBaseTank::StopControl
PUBLIC	??_C@_0N@KBIP@leave?5TANK?$CB?6?$AA@		; `string'
EXTRN	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAvelocity
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	?DontThink@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::DontThink
;	COMDAT ??_C@_0N@KBIP@leave?5TANK?$CB?6?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_0N@KBIP@leave?5TANK?$CB?6?$AA@ DB 'leave TANK!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?StopControl@CBaseTank@@QAEXPAVCFuncTankControls@@@Z
_TEXT	SEGMENT
_pControls$ = 8
_this$ = -4
?StopControl@CBaseTank@@QAEXPAVCFuncTankControls@@@Z PROC NEAR ; CBaseTank::StopControl, COMDAT

; 397  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 	if( !m_pControls || m_pControls != pControls )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1792], 0
	je	SHORT $L38573
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1792]
	cmp	edx, DWORD PTR _pControls$[ebp]
	je	SHORT $L38572
$L38573:

; 400  : 		return;

	jmp	SHORT $L38571
$L38572:

; 402  : 
; 403  : 	ALERT( at_aiconsole, "leave TANK!\n");

	push	OFFSET FLAT:??_C@_0N@KBIP@leave?5TANK?$CB?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 404  : 
; 405  :           m_iState = STATE_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 0

; 406  : 	StopRotSound();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRotSound@CBaseTank@@QAEXXZ		; CBaseTank::StopRotSound

; 407  : 
; 408  : 	DontThink();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DontThink@CBaseEntity@@QAEXXZ		; CBaseEntity::DontThink

; 409  : 	SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 410  : 	m_pControls = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1792], 0

; 411  : 
; 412  : 	if( IsActive( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsActive@CBaseTank@@QAEHXZ		; CBaseTank::IsActive
	test	eax, eax
	je	SHORT $L38575

; 414  : 		SetNextThink( 1.0 );

	push	1065353216				; 3f800000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]
$L38575:
$L38571:

; 416  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StopControl@CBaseTank@@QAEXPAVCFuncTankControls@@@Z ENDP ; CBaseTank::StopControl
_TEXT	ENDS
PUBLIC	?Use@CBaseTank@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CBaseTank::Use
PUBLIC	?TankActivate@CBaseTank@@QAEXXZ			; CBaseTank::TankActivate
PUBLIC	?TankDeactivate@CBaseTank@@QAEXXZ		; CBaseTank::TankDeactivate
EXTRN	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@H@Z:NEAR ; CBaseEntity::ShouldToggle
;	COMDAT ?Use@CBaseTank@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_this$ = -4
?Use@CBaseTank@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CBaseTank::Use, COMDAT

; 419  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 420  : 	if( pev->spawnflags & SF_TANK_CANCONTROL )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 32					; 00000020H
	test	edx, edx
	je	SHORT $L38583

; 422  : 		// player controlled turret
; 423  : 		if( pActivator->Classify() != CLASS_PLAYER )

	mov	eax, DWORD PTR _pActivator$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActivator$[ebp]
	call	DWORD PTR [edx+68]
	cmp	eax, 2
	je	SHORT $L38584

; 424  : 			return;

	jmp	SHORT $L38582
$L38584:

; 428  : 	else

	jmp	SHORT $L38588
$L38583:

; 430  : 		if( !ShouldToggle( useType, IsActive() ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsActive@CBaseTank@@QAEHXZ		; CBaseTank::IsActive
	push	eax
	mov	eax, DWORD PTR _useType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@H@Z ; CBaseEntity::ShouldToggle
	test	eax, eax
	jne	SHORT $L38586

; 431  : 			return;

	jmp	SHORT $L38582
$L38586:

; 432  : 
; 433  : 		if( IsActive() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsActive@CBaseTank@@QAEHXZ		; CBaseTank::IsActive
	test	eax, eax
	je	SHORT $L38587

; 434  : 			TankDeactivate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TankDeactivate@CBaseTank@@QAEXXZ	; CBaseTank::TankDeactivate

; 435  : 		else TankActivate();

	jmp	SHORT $L38588
$L38587:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TankActivate@CBaseTank@@QAEXXZ		; CBaseTank::TankActivate
$L38588:
$L38582:

; 437  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseTank@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CBaseTank::Use
_TEXT	ENDS
;	COMDAT ?TankActivate@CBaseTank@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TankActivate@CBaseTank@@QAEXXZ PROC NEAR		; CBaseTank::TankActivate, COMDAT

; 79   : 	inline void TankActivate( void ) { pev->spawnflags |= SF_TANK_ACTIVE; SetNextThink( 0.1f ); m_iState = STATE_ON; m_fireLast = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	or	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+416], edx
	push	1036831949				; 3dcccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1832], 0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TankActivate@CBaseTank@@QAEXXZ ENDP			; CBaseTank::TankActivate
_TEXT	ENDS
;	COMDAT ?TankDeactivate@CBaseTank@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TankDeactivate@CBaseTank@@QAEXXZ PROC NEAR		; CBaseTank::TankDeactivate, COMDAT

; 80   : 	inline void TankDeactivate( void ) { pev->spawnflags &= ~SF_TANK_ACTIVE; m_fireLast = 0; m_iState = STATE_OFF; StopRotSound(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+416], edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1832], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRotSound@CBaseTank@@QAEXXZ		; CBaseTank::StopRotSound
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TankDeactivate@CBaseTank@@QAEXXZ ENDP			; CBaseTank::TankDeactivate
_TEXT	ENDS
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	?InRange@CBaseTank@@QAEHM@Z			; CBaseTank::InRange
PUBLIC	?FindTarget@CBaseTank@@QAEPAVCBaseEntity@@XZ	; CBaseTank::FindTarget
PUBLIC	?IRelationship@CBaseTank@@QAEHPAVCBaseEntity@@@Z ; CBaseTank::IRelationship
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
PUBLIC	?GetTargetname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetTargetname
PUBLIC	?FNullEnt@@YAHPBUedict_s@@@Z			; FNullEnt
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
;	COMDAT ?FindTarget@CBaseTank@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
$T40207 = -56
$T40208 = -68
$T40209 = -80
$T40210 = -92
$T40211 = -104
$T40212 = -116
$T40213 = -128
_this$ = -4
_pent$ = -8
_chFireTarget$ = -12
_barrelEnd$ = -24
_pReturn$ = -28
_iBestRelationship$ = -32
_flDist$ = -36
_flNearest$ = -40
_pTarg$38605 = -44
?FindTarget@CBaseTank@@QAEPAVCBaseEntity@@XZ PROC NEAR	; CBaseTank::FindTarget, COMDAT

; 440  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 441  : 	// normal mode: find the client in PVS
; 442  : 	if( !m_iszFireTarget && !m_iTankClass )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1912], 0
	jne	SHORT $L38593
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1916], 0
	jne	SHORT $L38593

; 443  : 		return CBaseEntity::Instance( FIND_CLIENT_IN_PVS( edict() ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+68
	add	esp, 4
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	jmp	$L38592
$L38593:

; 444  : 
; 445  : 	// custom mode: find specified entity by targetname or classname
; 446  : 	edict_t *pent = UTIL_EntitiesInPVS( edict() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+72
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax

; 447  : 	const char *chFireTarget = STRING( m_iszFireTarget );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1912]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _chFireTarget$[ebp], eax

; 448  : 
; 449  : 	Vector barrelEnd = BarrelPosition();

	lea	ecx, DWORD PTR $T40207[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BarrelPosition@CBaseTank@@QAE?AVVector@@XZ ; CBaseTank::BarrelPosition
	push	eax
	lea	ecx, DWORD PTR _barrelEnd$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 450  : 	CBaseEntity *pReturn = NULL;

	mov	DWORD PTR _pReturn$[ebp], 0

; 451  : 	int iBestRelationship = R_DL;

	mov	DWORD PTR _iBestRelationship$[ebp], 1

; 452  : 	float flDist = 8192, flNearest = 8192; // so first visible entity will become the closest.

	mov	DWORD PTR _flDist$[ebp], 1174405120	; 46000000H
	mov	DWORD PTR _flNearest$[ebp], 1174405120	; 46000000H
$L38603:

; 453  : 
; 454  : 	// check all the entities
; 455  : 	while ( !FNullEnt( pent ) )

	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	$L38604

; 457  : 		CBaseEntity *pTarg = CBaseEntity::Instance( pent );

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pTarg$38605[ebp], eax

; 458  : 
; 459  : 		if( pTarg )

	cmp	DWORD PTR _pTarg$38605[ebp], 0
	je	$L38622

; 461  : 			if( m_iTankClass )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1916], 0
	je	$L38607

; 463  : 				if( pTarg->IsAlive() )

	mov	edx, DWORD PTR _pTarg$38605[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pTarg$38605[ebp]
	call	DWORD PTR [eax+200]
	test	eax, eax
	je	$L38616

; 465  : 					if( IRelationship( pTarg ) > iBestRelationship )

	mov	ecx, DWORD PTR _pTarg$38605[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IRelationship@CBaseTank@@QAEHPAVCBaseEntity@@@Z ; CBaseTank::IRelationship
	cmp	eax, DWORD PTR _iBestRelationship$[ebp]
	jle	SHORT $L38609

; 467  : 						// this entity is disliked MORE than the entity that we 
; 468  : 						// currently think is the best visible enemy. No need to do 
; 469  : 						// a distance check, just get mad at this one for now.
; 470  : 						iBestRelationship = IRelationship( pTarg );

	mov	edx, DWORD PTR _pTarg$38605[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IRelationship@CBaseTank@@QAEHPAVCBaseEntity@@@Z ; CBaseTank::IRelationship
	mov	DWORD PTR _iBestRelationship$[ebp], eax

; 471  : 						flNearest = flDist = ( pTarg->EyePosition() - barrelEnd ).Length();

	lea	eax, DWORD PTR _barrelEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40209[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40208[ebp]
	push	edx
	mov	eax, DWORD PTR _pTarg$38605[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pTarg$38605[ebp]
	call	DWORD PTR [edx+308]
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flDist$[ebp]
	mov	eax, DWORD PTR _flDist$[ebp]
	mov	DWORD PTR _flNearest$[ebp], eax

; 472  : 						pReturn = pTarg;

	mov	ecx, DWORD PTR _pTarg$38605[ebp]
	mov	DWORD PTR _pReturn$[ebp], ecx

; 474  : 					else if( IRelationship( pTarg ) == iBestRelationship )

	jmp	SHORT $L38616
$L38609:
	mov	edx, DWORD PTR _pTarg$38605[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IRelationship@CBaseTank@@QAEHPAVCBaseEntity@@@Z ; CBaseTank::IRelationship
	cmp	eax, DWORD PTR _iBestRelationship$[ebp]
	jne	SHORT $L38616

; 476  : 						// this entity is disliked just as much as the entity that
; 477  : 						// we currently think is the best visible enemy, so we only
; 478  : 						// get mad at it if it is closer.
; 479  : 						flDist = ( pTarg->EyePosition() - barrelEnd ).Length();

	lea	eax, DWORD PTR _barrelEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40211[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40210[ebp]
	push	edx
	mov	eax, DWORD PTR _pTarg$38605[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pTarg$38605[ebp]
	call	DWORD PTR [edx+308]
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flDist$[ebp]

; 480  : 				
; 481  : 						if( flDist <= flNearest )

	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR _flNearest$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38616

; 483  : 							flNearest = flDist;

	mov	eax, DWORD PTR _flDist$[ebp]
	mov	DWORD PTR _flNearest$[ebp], eax

; 484  : 							// these are guaranteed to be the same!
; 485  : 							pReturn = pTarg;

	mov	ecx, DWORD PTR _pTarg$38605[ebp]
	mov	DWORD PTR _pReturn$[ebp], ecx
$L38616:

; 490  : 			else if( FStrEq( pTarg->GetTargetname(), chFireTarget ) || FStrEq( pTarg->GetClassname(), chFireTarget ))

	jmp	SHORT $L38622
$L38607:
	mov	edx, DWORD PTR _chFireTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTarg$38605[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L38619
	mov	eax, DWORD PTR _chFireTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarg$38605[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38622
$L38619:

; 492  : 				// calculate angle needed to aim at target
; 493  : 				flDist = ( pTarg->EyePosition() - barrelEnd ).Length();

	lea	ecx, DWORD PTR _barrelEnd$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40213[ebp]
	push	edx
	lea	eax, DWORD PTR $T40212[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarg$38605[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTarg$38605[ebp]
	call	DWORD PTR [edx+308]
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flDist$[ebp]

; 494  : 
; 495  : 				if( flDist <= flNearest )

	fld	DWORD PTR _flDist$[ebp]
	fcomp	DWORD PTR _flNearest$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38622

; 497  : 					flNearest = flDist;

	mov	eax, DWORD PTR _flDist$[ebp]
	mov	DWORD PTR _flNearest$[ebp], eax

; 498  : 					// these are guaranteed to be the same!
; 499  : 					pReturn = pTarg;

	mov	ecx, DWORD PTR _pTarg$38605[ebp]
	mov	DWORD PTR _pReturn$[ebp], ecx
$L38622:

; 503  : 
; 504  : 		pent = pent->v.chain;

	mov	edx, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [edx+520]
	mov	DWORD PTR _pent$[ebp], eax

; 505  : 	}

	jmp	$L38603
$L38604:

; 506  : 
; 507  : 	// make sure what the closest entity is in-range
; 508  : 	if( pReturn != NULL && InRange( flDist ))

	cmp	DWORD PTR _pReturn$[ebp], 0
	je	SHORT $L38623
	mov	ecx, DWORD PTR _flDist$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InRange@CBaseTank@@QAEHM@Z		; CBaseTank::InRange
	test	eax, eax
	je	SHORT $L38623

; 510  : //		ALERT( at_console, "Found %s\n", pReturn->GetClassname( ));
; 511  : 		return pReturn;

	mov	eax, DWORD PTR _pReturn$[ebp]
	jmp	SHORT $L38592
$L38623:

; 513  : 
; 514  : 	return NULL;

	xor	eax, eax
$L38592:

; 515  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FindTarget@CBaseTank@@QAEPAVCBaseEntity@@XZ ENDP	; CBaseTank::FindTarget
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40216 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40216[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
EXTRN	_sqrt:NEAR
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?FNullEnt@@YAHPBUedict_s@@@Z PROC NEAR			; FNullEnt, COMDAT

; 195  : inline BOOL FNullEnt(const edict_t* pent)	{ return pent == NULL || FNullEnt(OFFSET(pent)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L40221
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40221
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L40222
$L40221:
	mov	DWORD PTR -4+[ebp], 1
$L40222:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPBUedict_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetTargetname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetTargetname, COMDAT

; 284  : 	const char*	GetTargetname() { return STRING( pev->targetname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTargetname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetTargetname
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
;	COMDAT ?IRelationship@CBaseTank@@QAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pTarget$ = 8
_this$ = -4
_iOtherClass$ = -8
?IRelationship@CBaseTank@@QAEHPAVCBaseEntity@@@Z PROC NEAR ; CBaseTank::IRelationship, COMDAT

; 518  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 519  : 	int iOtherClass = pTarget->Classify();

	mov	eax, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [edx+68]
	mov	DWORD PTR _iOtherClass$[ebp], eax

; 520  : 
; 521  : 	if( iOtherClass == CLASS_NONE )

	cmp	DWORD PTR _iOtherClass$[ebp], 0
	jne	SHORT $L38629

; 522  : 		return R_NO;

	xor	eax, eax
	jmp	$L38627
$L38629:

; 523  : 
; 524  : 	if( !m_iTankClass )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1916], 0
	jne	SHORT $L38630

; 526  : 		if( iOtherClass == CLASS_PLAYER )

	cmp	DWORD PTR _iOtherClass$[ebp], 2
	jne	SHORT $L38631

; 527  : 			return R_HT;

	mov	eax, 2
	jmp	$L38627
$L38631:

; 528  : 		return R_NO;

	xor	eax, eax
	jmp	$L38627
$L38630:

; 530  : 	else if( m_iTankClass == CLASS_PLAYER_ALLY )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1916], 11		; 0000000bH
	jne	SHORT $L38633

; 533  : 		{

	mov	edx, DWORD PTR _iOtherClass$[ebp]
	mov	DWORD PTR -12+[ebp], edx
	mov	eax, DWORD PTR -12+[ebp]
	sub	eax, 1
	mov	DWORD PTR -12+[ebp], eax
	cmp	DWORD PTR -12+[ebp], 8
	ja	SHORT $L38639
	mov	edx, DWORD PTR -12+[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR $L40239[edx]
	jmp	DWORD PTR $L40240[ecx*4]
$L38638:

; 534  : 		case CLASS_MACHINE:
; 535  : 		case CLASS_HUMAN_MILITARY:
; 536  : 		case CLASS_ALIEN_MILITARY:
; 537  : 		case CLASS_ALIEN_MONSTER:
; 538  : 		case CLASS_ALIEN_PREDATOR:
; 539  : 		case CLASS_ALIEN_PREY:
; 540  : 			return R_HT;

	mov	eax, 2
	jmp	$L38627
$L38639:

; 541  : 		default:
; 542  : 			return R_NO;

	xor	eax, eax
	jmp	$L38627
$L38633:

; 545  : 	else if( m_iTankClass == CLASS_HUMAN_MILITARY )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1916], 4
	jne	SHORT $L38641

; 548  : 		{

	mov	ecx, DWORD PTR _iOtherClass$[ebp]
	mov	DWORD PTR -16+[ebp], ecx
	mov	edx, DWORD PTR -16+[ebp]
	sub	edx, 2
	mov	DWORD PTR -16+[ebp], edx
	cmp	DWORD PTR -16+[ebp], 9
	ja	SHORT $L38648
	mov	eax, DWORD PTR -16+[ebp]
	jmp	DWORD PTR $L40241[eax*4]
$L38646:

; 549  : 		case CLASS_PLAYER:
; 550  : 		case CLASS_PLAYER_ALLY:
; 551  : 		case CLASS_ALIEN_MILITARY:
; 552  : 		case CLASS_ALIEN_MONSTER:
; 553  : 		case CLASS_ALIEN_PREDATOR:
; 554  : 		case CLASS_ALIEN_PREY:
; 555  : 			return R_HT;

	mov	eax, 2
	jmp	SHORT $L38627
$L38647:

; 556  : 		case CLASS_HUMAN_PASSIVE:
; 557  : 			return R_DL;

	mov	eax, 1
	jmp	SHORT $L38627
$L38648:

; 558  : 		default:
; 559  : 			return R_NO;

	xor	eax, eax
	jmp	SHORT $L38627
$L38641:

; 562  : 	else if( m_iTankClass == CLASS_ALIEN_MILITARY )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1916], 5
	jne	SHORT $L38652

; 565  : 		{

	mov	edx, DWORD PTR _iOtherClass$[ebp]
	mov	DWORD PTR -20+[ebp], edx
	mov	eax, DWORD PTR -20+[ebp]
	sub	eax, 2
	mov	DWORD PTR -20+[ebp], eax
	cmp	DWORD PTR -20+[ebp], 9
	ja	SHORT $L38657
	mov	edx, DWORD PTR -20+[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR $L40242[edx]
	jmp	DWORD PTR $L40243[ecx*4]
$L38655:

; 566  : 		case CLASS_PLAYER:
; 567  : 		case CLASS_PLAYER_ALLY:
; 568  : 		case CLASS_HUMAN_MILITARY:
; 569  : 			return R_HT;

	mov	eax, 2
	jmp	SHORT $L38627
$L38656:

; 570  : 		case CLASS_HUMAN_PASSIVE:
; 571  : 			return R_DL;

	mov	eax, 1
	jmp	SHORT $L38627
$L38657:

; 572  : 		default:
; 573  : 			return R_NO;

	xor	eax, eax
	jmp	SHORT $L38627
$L38652:

; 576  : 
; 577  : 	return R_NO;

	xor	eax, eax
$L38627:

; 578  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L40240:
	DD	$L38638
	DD	$L38639
$L40239:
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
$L40241:
	DD	$L38646
	DD	$L38647
	DD	$L38648
	DD	$L38646
	DD	$L38648
	DD	$L38646
	DD	$L38646
	DD	$L38646
	DD	$L38648
	DD	$L38646
$L40243:
	DD	$L38655
	DD	$L38656
	DD	$L38657
$L40242:
	DB	0
	DB	1
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
?IRelationship@CBaseTank@@QAEHPAVCBaseEntity@@@Z ENDP	; CBaseTank::IRelationship
_TEXT	ENDS
;	COMDAT ?InRange@CBaseTank@@QAEHM@Z
_TEXT	SEGMENT
_range$ = 8
_this$ = -4
?InRange@CBaseTank@@QAEHM@Z PROC NEAR			; CBaseTank::InRange, COMDAT

; 581  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 582  : 	if( range < m_minRange )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _range$[ebp]
	fcomp	DWORD PTR [eax+1848]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38662

; 583  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L38661
$L38662:

; 584  : 
; 585  : 	if( m_maxRange > 0 && range > m_maxRange )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1852]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38663
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _range$[ebp]
	fcomp	DWORD PTR [edx+1852]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38663

; 586  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L38661
$L38663:

; 587  : 
; 588  : 	return TRUE;

	mov	eax, 1
$L38661:

; 589  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InRange@CBaseTank@@QAEHM@Z ENDP			; CBaseTank::InRange
_TEXT	ENDS
PUBLIC	?Think@CBaseTank@@UAEXXZ			; CBaseTank::Think
PUBLIC	?TrackTarget@CBaseTank@@QAEXXZ			; CBaseTank::TrackTarget
PUBLIC	?StartRotSound@CBaseTank@@QAEXXZ		; CBaseTank::StartRotSound
PUBLIC	__real@8@3fff8000000000000000
EXTRN	_fabs:NEAR
EXTRN	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAvelocity
;	COMDAT __real@8@3fff8000000000000000
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT ?Think@CBaseTank@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_avelocity$ = -16
?Think@CBaseTank@@UAEXXZ PROC NEAR			; CBaseTank::Think, COMDAT

; 592  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 593  : 	SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 594  : 	TrackTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackTarget@CBaseTank@@QAEXXZ		; CBaseTank::TrackTarget

; 595  : 
; 596  : 	Vector avelocity = GetLocalAvelocity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	push	eax
	lea	ecx, DWORD PTR _avelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 597  : 
; 598  : 	if ( fabs( avelocity.x ) > 1 || fabs( avelocity.y ) > 1 )

	fld	DWORD PTR _avelocity$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38670
	fld	DWORD PTR _avelocity$[ebp+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38669
$L38670:

; 599  : 		StartRotSound();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRotSound@CBaseTank@@QAEXXZ	; CBaseTank::StartRotSound

; 600  : 	else StopRotSound();

	jmp	SHORT $L38671
$L38669:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRotSound@CBaseTank@@QAEXXZ		; CBaseTank::StopRotSound
$L38671:

; 601  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CBaseTank@@UAEXXZ ENDP				; CBaseTank::Think
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	?TryFire@CBaseTank@@QAEXABVVector@@0PAUentvars_s@@@Z ; CBaseTank::TryFire
PUBLIC	?CanFire@CBaseTank@@QAEHXZ			; CBaseTank::CanFire
PUBLIC	?AdjustAnglesForBarrel@CBaseTank@@QAEXAAVVector@@M@Z ; CBaseTank::AdjustAnglesForBarrel
PUBLIC	__real@4@4002a000000000000000
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	__real@4@3ff8a3d70a0000000000
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
PUBLIC	??0gametrace_s@@QAE@XZ				; gametrace_s::gametrace_s
PUBLIC	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z		; CBaseEntity::SetMoveDoneTime
PUBLIC	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z		; FClassnameIs
PUBLIC	??_C@_0BA@KOLE@func_tracktrain?$AA@		; `string'
PUBLIC	??_C@_0P@MDCK@monster_target?$AA@		; `string'
PUBLIC	?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z	; UTIL_MakeVectorsPrivate
EXTRN	?UTIL_AngleDistance@@YAMMM@Z:NEAR		; UTIL_AngleDistance
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
EXTRN	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsAngles
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
EXTRN	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z:NEAR	; FClassnameIs
EXTRN	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z:NEAR	; UTIL_VecToAngles
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
;	COMDAT ??_C@_0BA@KOLE@func_tracktrain?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_0BA@KOLE@func_tracktrain?$AA@ DB 'func_tracktrain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MDCK@monster_target?$AA@
CONST	SEGMENT
??_C@_0P@MDCK@monster_target?$AA@ DB 'monster_target', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4@4002a000000000000000
CONST	SEGMENT
__real@4@4002a000000000000000 DD 041200000r	; 10
CONST	ENDS
;	COMDAT __real@4@3fff8000000000000000
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT __real@4@3ff8a3d70a0000000000
CONST	SEGMENT
__real@4@3ff8a3d70a0000000000 DD 03c23d70ar	; 0.01
CONST	ENDS
;	COMDAT ?TrackTarget@CBaseTank@@QAEXXZ
_TEXT	SEGMENT
$T40252 = -204
$T40253 = -216
$T40254 = -228
$T40255 = -240
$T40256 = -252
$T40257 = -264
$T40258 = -276
$T40259 = -288
$T40260 = -300
$T40261 = -312
$T40262 = -324
$T40263 = -336
$T40272 = -348
$T40273 = -360
$T40274 = -372
$T40275 = -384
_this$ = -4
_tr$ = -60
_updateTime$ = -64
_lineOfSight$ = -68
_angles$ = -80
_direction$ = -92
_targetPosition$ = -104
_barrelEnd$ = -116
_pController$ = -120
_pTarget$ = -124
_ownerTemp$38690 = -128
_range$38702 = -132
_flYawCenter$ = -136
_flPitchCenter$ = -140
_avelocity$ = -152
_distY$ = -156
_distX$ = -160
_forward$38728 = -172
_fire$38736 = -176
_forward$38737 = -188
_length$38739 = -192
?TrackTarget@CBaseTank@@QAEXXZ PROC NEAR		; CBaseTank::TrackTarget, COMDAT

; 604  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 464				; 000001d0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 605  : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 606  : 	BOOL updateTime = FALSE, lineOfSight;

	mov	DWORD PTR _updateTime$[ebp], 0

; 607  : 	Vector angles, direction, targetPosition, barrelEnd;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _direction$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _targetPosition$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _barrelEnd$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 608  : 	CBasePlayer *pController = NULL;

	mov	DWORD PTR _pController$[ebp], 0

; 609  : 	CBaseEntity *pTarget;
; 610  : 
; 611  : 	// Get a position to aim for
; 612  : 	if( m_pControls && m_pControls->m_pController )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1792], 0
	je	$L38685
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1792]
	cmp	DWORD PTR [edx+1792], 0
	je	$L38685

; 614  : 		// Tanks attempt to mirror the player's angles
; 615  : 		pController = m_pControls->m_pController;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1792]
	mov	edx, DWORD PTR [ecx+1792]
	mov	DWORD PTR _pController$[ebp], edx

; 616  : 		pController->pev->viewmodel = 0;

	mov	eax, DWORD PTR _pController$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+188], 0

; 617  : 		SetNextThink( 0.05 );

	push	1028443341				; 3d4ccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]

; 618  : 
; 619  : 		if( FBitSet( pev->spawnflags, SF_TANK_MATCHTARGET ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$L38686

; 621  : 			// "Match target" mode:
; 622  : 			// first, get the player's angles
; 623  : 			angles = pController->pev->v_angle;

	mov	ecx, DWORD PTR _pController$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 116				; 00000074H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _angles$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _angles$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _angles$[ebp+8], edx

; 624  : 			// Work out what point the player is looking at
; 625  : 			UTIL_MakeVectorsPrivate( angles, direction, NULL, NULL );

	push	0
	push	0
	lea	ecx, DWORD PTR _direction$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	eax, DWORD PTR _angles$[ebp]
	push	eax
	call	?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z ; UTIL_MakeVectorsPrivate
	add	esp, 16					; 00000010H

; 626  : 
; 627  : 			targetPosition = pController->EyePosition() + direction * 1000;

	push	1148846080				; 447a0000H
	lea	ecx, DWORD PTR $T40253[ebp]
	push	ecx
	lea	ecx, DWORD PTR _direction$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T40254[ebp]
	push	edx
	lea	eax, DWORD PTR $T40252[ebp]
	push	eax
	mov	ecx, DWORD PTR _pController$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pController$[ebp]
	call	DWORD PTR [edx+308]
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _targetPosition$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _targetPosition$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _targetPosition$[ebp+8], eax

; 628  : 
; 629  : 			edict_t *ownerTemp = pev->owner;	// store the owner, so we can put it back after the check

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+408]
	mov	DWORD PTR _ownerTemp$38690[ebp], eax

; 630  : 			pev->owner = pController->edict();	// when doing the matchtarget check, don't hit the player or the tank.

	mov	ecx, DWORD PTR _pController$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+408], eax

; 631  : 
; 632  : 			UTIL_TraceLine( pController->EyePosition(), targetPosition, missile, ignore_glass, edict(), &tr );

	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _targetPosition$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40255[ebp]
	push	edx
	mov	eax, DWORD PTR _pController$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pController$[ebp]
	call	DWORD PTR [edx+308]
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@W4IGNORE_GLASS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 24					; 00000018H

; 633  : 
; 634  : 			pev->owner = ownerTemp; // put the owner back

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _ownerTemp$38690[ebp]
	mov	DWORD PTR [ecx+408], edx

; 635  : 
; 636  : 			// Work out what angle we need to face to look at that point
; 637  : 			direction = tr.vecEndPos - GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T40256[ebp]
	push	eax
	lea	ecx, DWORD PTR _tr$[ebp+20]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _direction$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _direction$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _direction$[ebp+8], eax

; 638  : 			angles = UTIL_VecToAngles( direction );

	lea	ecx, DWORD PTR _direction$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40257[ebp]
	push	edx
	call	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z	; UTIL_VecToAngles
	add	esp, 8
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _angles$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _angles$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _angles$[ebp+8], eax

; 639  : 			targetPosition = tr.vecEndPos;

	mov	ecx, DWORD PTR _tr$[ebp+20]
	mov	DWORD PTR _targetPosition$[ebp], ecx
	mov	edx, DWORD PTR _tr$[ebp+24]
	mov	DWORD PTR _targetPosition$[ebp+4], edx
	mov	eax, DWORD PTR _tr$[ebp+28]
	mov	DWORD PTR _targetPosition$[ebp+8], eax

; 640  : 
; 641  : 			// Calculate the additional rotation to point the end of the barrel at the target
; 642  : 			// (instead of the gun's center)
; 643  : 			AdjustAnglesForBarrel( angles, direction.Length() );

	lea	ecx, DWORD PTR _direction$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AdjustAnglesForBarrel@CBaseTank@@QAEXAAVVector@@M@Z ; CBaseTank::AdjustAnglesForBarrel

; 645  : 		else

	jmp	SHORT $L38694
$L38686:

; 647  : 			// "Match angles" mode
; 648  : 			// just get the player's angles
; 649  : 			angles = pController->pev->v_angle;

	mov	edx, DWORD PTR _pController$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 116				; 00000074H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _angles$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _angles$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _angles$[ebp+8], eax
$L38694:

; 652  : 	else

	jmp	$L38695
$L38685:

; 654  : 		if( IsActive( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsActive@CBaseTank@@QAEHXZ		; CBaseTank::IsActive
	test	eax, eax
	je	SHORT $L38696

; 656  : 			SetNextThink( 0.01 );

	push	1008981770				; 3c23d70aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 658  : 		else

	jmp	SHORT $L38697
$L38696:

; 660  : 			SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 661  : 			m_iState = STATE_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 0

; 662  : 			DontThink();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DontThink@CBaseEntity@@QAEXXZ		; CBaseEntity::DontThink

; 663  : 			return;

	jmp	$L38675
$L38697:

; 665  : 
; 666  : 		pTarget = FindTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindTarget@CBaseTank@@QAEPAVCBaseEntity@@XZ ; CBaseTank::FindTarget
	mov	DWORD PTR _pTarget$[ebp], eax

; 667  : 
; 668  : 		if( !pTarget )

	cmp	DWORD PTR _pTarget$[ebp], 0
	jne	SHORT $L38698

; 670  : 			if( IsActive() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsActive@CBaseTank@@QAEHXZ		; CBaseTank::IsActive
	test	eax, eax
	je	SHORT $L38699

; 671  : 				SetNextThink( 0.1 ); // at rest

	push	1036831949				; 3dcccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]
$L38699:

; 672  : 			m_iState = STATE_ON;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 1

; 673  : 			return;

	jmp	$L38675
$L38698:

; 675  : 
; 676  : 		// Calculate angle needed to aim at target
; 677  : 		barrelEnd = BarrelPosition();

	lea	ecx, DWORD PTR $T40258[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BarrelPosition@CBaseTank@@QAE?AVVector@@XZ ; CBaseTank::BarrelPosition
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _barrelEnd$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _barrelEnd$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _barrelEnd$[ebp+8], edx

; 678  : 		targetPosition = pTarget->EyePosition();

	lea	eax, DWORD PTR $T40259[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [edx+308]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _targetPosition$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _targetPosition$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _targetPosition$[ebp+8], eax

; 679  : 		float range = ( targetPosition - barrelEnd ).Length();

	lea	ecx, DWORD PTR _barrelEnd$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40260[ebp]
	push	edx
	lea	ecx, DWORD PTR _targetPosition$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _range$38702[ebp]

; 680  : 		
; 681  : 		if( !InRange( range ))

	mov	eax, DWORD PTR _range$38702[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InRange@CBaseTank@@QAEHM@Z		; CBaseTank::InRange
	test	eax, eax
	jne	SHORT $L38704

; 683  : 			m_iState = STATE_ON;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 1

; 684  : 			return;

	jmp	$L38675
$L38704:

; 686  : 
; 687  : 		UTIL_TraceLine( barrelEnd, targetPosition, dont_ignore_monsters, edict(), &tr );

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	lea	eax, DWORD PTR _targetPosition$[ebp]
	push	eax
	lea	ecx, DWORD PTR _barrelEnd$[ebp]
	push	ecx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 688  : 		lineOfSight = FALSE;

	mov	DWORD PTR _lineOfSight$[ebp], 0

; 689  : 
; 690  : 		// No line of sight, don't track
; 691  : 		// g-cont. but allow tracking for non-armed tanks because this may be it's projectors or security cameras
; 692  : 		if( tr.flFraction == 1.0 || tr.pHit == pTarget->edict() || m_bulletType == BULLET_NONE )

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38706
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	cmp	DWORD PTR _tr$[ebp+48], eax
	je	SHORT $L38706
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1880], 0
	jne	SHORT $L38707
$L38706:

; 694  : 			lineOfSight = TRUE;

	mov	DWORD PTR _lineOfSight$[ebp], 1

; 695  : 
; 696  : 			if( InRange( range ) && pTarget && pTarget->IsAlive() )

	mov	eax, DWORD PTR _range$38702[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InRange@CBaseTank@@QAEHM@Z		; CBaseTank::InRange
	test	eax, eax
	je	SHORT $L38707
	cmp	DWORD PTR _pTarget$[ebp], 0
	je	SHORT $L38707
	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	je	SHORT $L38707

; 698  : 				updateTime = TRUE;

	mov	DWORD PTR _updateTime$[ebp], 1

; 699  : 				m_sightOrigin = UpdateTargetPosition( pTarget );

	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40261[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+344]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L38707:

; 702  : 
; 703  : 		// Track sight origin
; 704  : 
; 705  : 		direction = m_sightOrigin - GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T40262[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _direction$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _direction$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _direction$[ebp+8], edx

; 706  : 		angles = UTIL_VecToAngles( direction );

	lea	eax, DWORD PTR _direction$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40263[ebp]
	push	ecx
	call	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z	; UTIL_VecToAngles
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _angles$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _angles$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _angles$[ebp+8], edx

; 707  : 
; 708  : 		// Calculate the additional rotation to point the end of the barrel at the target (not the gun's center) 
; 709  : 		AdjustAnglesForBarrel( angles, direction.Length() );

	lea	ecx, DWORD PTR _direction$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _angles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AdjustAnglesForBarrel@CBaseTank@@QAEXAAVVector@@M@Z ; CBaseTank::AdjustAnglesForBarrel
$L38695:

; 711  : 
; 712  : 	float flYawCenter = m_yawCenter;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1800]
	mov	DWORD PTR _flYawCenter$[ebp], edx

; 713  : 	float flPitchCenter = m_pitchCenter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	DWORD PTR _flPitchCenter$[ebp], ecx

; 714  : 
; 715  : 	// HACKHACK: get the range center as sum of two angles
; 716  : 	// it's not fully properly but it works
; 717  : 	if( m_hParent != NULL && FClassnameIs( m_hParent->pev, "func_tracktrain" ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L38713
	push	OFFSET FLAT:??_C@_0BA@KOLE@func_tracktrain?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	edx, DWORD PTR [eax+4]
	push	edx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L38713

; 719  : 		flYawCenter += m_hParent->GetAbsAngles().y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	fld	DWORD PTR _flYawCenter$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _flYawCenter$[ebp]

; 720  : 		flPitchCenter += m_hParent->GetAbsAngles().x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	fld	DWORD PTR _flPitchCenter$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _flPitchCenter$[ebp]
$L38713:

; 722  : 
; 723  : 	// Force the angles to be relative to the center position
; 724  : 	angles.y = flYawCenter + UTIL_AngleDistance( angles.y, flYawCenter );

	mov	eax, DWORD PTR _flYawCenter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angles$[ebp+4]
	push	ecx
	call	?UTIL_AngleDistance@@YAMMM@Z		; UTIL_AngleDistance
	add	esp, 8
	fadd	DWORD PTR _flYawCenter$[ebp]
	fstp	DWORD PTR _angles$[ebp+4]

; 725  : 	angles.x = flPitchCenter + UTIL_AngleDistance( angles.x, flPitchCenter );

	mov	edx, DWORD PTR _flPitchCenter$[ebp]
	push	edx
	mov	eax, DWORD PTR _angles$[ebp]
	push	eax
	call	?UTIL_AngleDistance@@YAMMM@Z		; UTIL_AngleDistance
	add	esp, 8
	fadd	DWORD PTR _flPitchCenter$[ebp]
	fstp	DWORD PTR _angles$[ebp]

; 726  : 
; 727  : 	// limit against range in y
; 728  : 	if( m_yawRange != 0 && ( angles.y > flYawCenter + m_yawRange ))

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1808]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38715
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flYawCenter$[ebp]
	fadd	DWORD PTR [edx+1808]
	fcomp	DWORD PTR _angles$[ebp+4]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38715

; 730  : 		angles.y = flYawCenter + m_yawRange;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flYawCenter$[ebp]
	fadd	DWORD PTR [eax+1808]
	fstp	DWORD PTR _angles$[ebp+4]

; 731  : 		updateTime = FALSE;	// Don't update if you saw the player, but out of range

	mov	DWORD PTR _updateTime$[ebp], 0

; 733  : 	else if( m_yawRange != 0 && ( angles.y < flYawCenter - m_yawRange ))

	jmp	SHORT $L38717
$L38715:
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1808]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38717
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flYawCenter$[ebp]
	fsub	DWORD PTR [edx+1808]
	fcomp	DWORD PTR _angles$[ebp+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38717

; 735  : 		angles.y = (flYawCenter - m_yawRange);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flYawCenter$[ebp]
	fsub	DWORD PTR [eax+1808]
	fstp	DWORD PTR _angles$[ebp+4]

; 736  : 		updateTime = FALSE; // Don't update if you saw the player, but out of range

	mov	DWORD PTR _updateTime$[ebp], 0
$L38717:

; 738  : 
; 739  : 	if( updateTime )

	cmp	DWORD PTR _updateTime$[ebp], 0
	je	SHORT $L38718

; 740  : 		m_lastSightTime = gpGlobals->time;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+1840], eax
$L38718:

; 741  : 
; 742  : 	Vector avelocity;

	lea	ecx, DWORD PTR _avelocity$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 743  : 
; 744  : 	// move toward target at rate or less
; 745  : 	float distY = UTIL_AngleDistance( angles.y, GetAbsAngles().y );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _angles$[ebp+4]
	push	edx
	call	?UTIL_AngleDistance@@YAMMM@Z		; UTIL_AngleDistance
	add	esp, 8
	fst	DWORD PTR _distY$[ebp]

; 746  : 
; 747  : 	avelocity.y = distY * 10;

	fmul	DWORD PTR __real@4@4002a000000000000000
	fstp	DWORD PTR _avelocity$[ebp+4]

; 748  : 	avelocity.y = bound( -m_yawRate, avelocity.y, m_yawRate );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1804]
	fchs
	fcomp	DWORD PTR _avelocity$[ebp+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40266
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1804]
	fcomp	DWORD PTR _avelocity$[ebp+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40264
	mov	edx, DWORD PTR _avelocity$[ebp+4]
	mov	DWORD PTR -388+[ebp], edx
	jmp	SHORT $L40265
$L40264:
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1804]
	fstp	DWORD PTR -388+[ebp]
$L40265:
	mov	ecx, DWORD PTR -388+[ebp]
	mov	DWORD PTR -392+[ebp], ecx
	jmp	SHORT $L40267
$L40266:
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1804]
	fchs
	fstp	DWORD PTR -392+[ebp]
$L40267:
	mov	eax, DWORD PTR -392+[ebp]
	mov	DWORD PTR _avelocity$[ebp+4], eax

; 749  : 
; 750  : 	// Limit against range in x
; 751  : 	if( angles.x > flPitchCenter + m_pitchRange )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flPitchCenter$[ebp]
	fadd	DWORD PTR [ecx+1824]
	fcomp	DWORD PTR _angles$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38721

; 752  : 		angles.x = flPitchCenter + m_pitchRange;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flPitchCenter$[ebp]
	fadd	DWORD PTR [edx+1824]
	fstp	DWORD PTR _angles$[ebp]

; 753  : 	else if( angles.x < flPitchCenter - m_pitchRange )

	jmp	SHORT $L38723
$L38721:
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flPitchCenter$[ebp]
	fsub	DWORD PTR [eax+1824]
	fcomp	DWORD PTR _angles$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38723

; 754  : 		angles.x = flPitchCenter - m_pitchRange;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flPitchCenter$[ebp]
	fsub	DWORD PTR [ecx+1824]
	fstp	DWORD PTR _angles$[ebp]
$L38723:

; 755  : 
; 756  : 	// Move toward target at rate or less
; 757  : 	float distX = UTIL_AngleDistance( angles.x, GetAbsAngles().x );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _angles$[ebp]
	push	eax
	call	?UTIL_AngleDistance@@YAMMM@Z		; UTIL_AngleDistance
	add	esp, 8
	fst	DWORD PTR _distX$[ebp]

; 758  : 
; 759  : 	avelocity.x = distX  * 10;

	fmul	DWORD PTR __real@4@4002a000000000000000
	fstp	DWORD PTR _avelocity$[ebp]

; 760  : 	avelocity.x = bound( -m_pitchRate, avelocity.x, m_pitchRate );

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1820]
	fchs
	fcomp	DWORD PTR _avelocity$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40270
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1820]
	fcomp	DWORD PTR _avelocity$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40268
	mov	eax, DWORD PTR _avelocity$[ebp]
	mov	DWORD PTR -396+[ebp], eax
	jmp	SHORT $L40269
$L40268:
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1820]
	fstp	DWORD PTR -396+[ebp]
$L40269:
	mov	edx, DWORD PTR -396+[ebp]
	mov	DWORD PTR -400+[ebp], edx
	jmp	SHORT $L40271
$L40270:
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1820]
	fchs
	fstp	DWORD PTR -400+[ebp]
$L40271:
	mov	ecx, DWORD PTR -400+[ebp]
	mov	DWORD PTR _avelocity$[ebp], ecx

; 761  : 
; 762  : 	avelocity.z = 0.0f;	// not used

	mov	DWORD PTR _avelocity$[ebp+8], 0

; 763  : 
; 764  : 	SetLocalAvelocity( avelocity );

	lea	edx, DWORD PTR _avelocity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 765  : 	SetMoveDoneTime( 0.05 );

	push	1028443341				; 3d4ccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 766  : 
; 767  : 	// firing with player-controlled tanks:
; 768  : 	if( pController )

	cmp	DWORD PTR _pController$[ebp], 0
	je	$L38725

; 770  : 		if( gpGlobals->time < m_flNextAttack )

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx+1796]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38726

; 771  : 			return;	// too early

	jmp	$L38675
$L38726:

; 772  : 
; 773  : 		if( pController->pev->button & IN_ATTACK )

	mov	edx, DWORD PTR _pController$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+384]
	and	ecx, 1
	test	ecx, ecx
	je	$L38727

; 775  : 			Vector forward;

	lea	ecx, DWORD PTR _forward$38728[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 776  : 			UTIL_MakeVectorsPrivate( GetAbsAngles(), forward, NULL, NULL );

	push	0
	push	0
	lea	ecx, DWORD PTR _forward$38728[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z ; UTIL_MakeVectorsPrivate
	add	esp, 16					; 00000010H

; 777  : 
; 778  : 			// to make sure the gun doesn't fire too many bullets
; 779  : 			m_fireLast = gpGlobals->time - (1.0f / m_fireRate ) - 0.01f;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR [edx+1836]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fsubr	DWORD PTR [eax]
	fsub	DWORD PTR __real@4@3ff8a3d70a0000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1832]

; 780  : 
; 781  : 			TryFire( BarrelPosition(), forward, pController->pev );

	mov	edx, DWORD PTR _pController$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR _forward$38728[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40272[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BarrelPosition@CBaseTank@@QAE?AVVector@@XZ ; CBaseTank::BarrelPosition
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TryFire@CBaseTank@@QAEXABVVector@@0PAUentvars_s@@@Z ; CBaseTank::TryFire

; 782  : 		
; 783  : 			if( pController->IsPlayer() )

	mov	eax, DWORD PTR _pController$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pController$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L38730

; 784  : 				((CBasePlayer *)pController)->m_iWeaponVolume = LOUD_GUN_VOLUME;

	mov	eax, DWORD PTR _pController$[ebp]
	mov	DWORD PTR [eax+2408], 1000		; 000003e8H
$L38730:

; 785  : 
; 786  : 			m_flNextAttack = gpGlobals->time + (1.0f / m_fireRate);

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR [ecx+1836]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1796]

; 788  : 		else

	jmp	SHORT $L38732
$L38727:

; 790  : 			m_iState = STATE_ON;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 1
$L38732:

; 793  : 	else if( CanFire() && ( FBitSet( pev->spawnflags, SF_TANK_LINEOFSIGHT ) || ( fabs( distX ) < m_pitchTolerance && fabs( distY ) < m_yawTolerance )))

	jmp	$L38749
$L38725:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanFire@CBaseTank@@QAEHXZ		; CBaseTank::CanFire
	test	eax, eax
	je	$L38734
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 16					; 00000010H
	test	ecx, ecx
	jne	SHORT $L38735
	fld	DWORD PTR _distX$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1828]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L38734
	fld	DWORD PTR _distY$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1812]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L38734
$L38735:

; 795  : 		BOOL fire = FALSE;

	mov	DWORD PTR _fire$38736[ebp], 0

; 796  : 		Vector forward;

	lea	ecx, DWORD PTR _forward$38737[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 797  : 		UTIL_MakeVectorsPrivate( GetAbsAngles(), forward, NULL, NULL );

	push	0
	push	0
	lea	ecx, DWORD PTR _forward$38737[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z ; UTIL_MakeVectorsPrivate
	add	esp, 16					; 00000010H

; 798  : 
; 799  : 		if( FBitSet( pev->spawnflags, SF_TANK_LINEOFSIGHT ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 16					; 00000010H
	test	eax, eax
	je	$L38738

; 801  : 			float length = direction.Length();

	lea	ecx, DWORD PTR _direction$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _length$38739[ebp]

; 802  : 			UTIL_TraceLine( barrelEnd, barrelEnd + forward * length, dont_ignore_monsters, edict(), &tr );

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	mov	edx, DWORD PTR _length$38739[ebp]
	push	edx
	lea	eax, DWORD PTR $T40273[ebp]
	push	eax
	lea	ecx, DWORD PTR _forward$38737[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T40274[ebp]
	push	ecx
	lea	ecx, DWORD PTR _barrelEnd$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	edx, DWORD PTR _barrelEnd$[ebp]
	push	edx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 803  : 			if ( tr.pHit == pTarget->edict() || ( FClassnameIs( pTarget, "monster_target" ) && tr.fInOpen ))

	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	cmp	DWORD PTR _tr$[ebp+48], eax
	je	SHORT $L38743
	push	OFFSET FLAT:??_C@_0P@MDCK@monster_target?$AA@ ; `string'
	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L38742
	cmp	DWORD PTR _tr$[ebp+8], 0
	je	SHORT $L38742
$L38743:

; 804  : 				fire = TRUE;

	mov	DWORD PTR _fire$38736[ebp], 1
$L38742:

; 806  : 		else

	jmp	SHORT $L38745
$L38738:

; 808  : 			fire = TRUE;

	mov	DWORD PTR _fire$38736[ebp], 1
$L38745:

; 810  : 
; 811  : 		if( fire )

	cmp	DWORD PTR _fire$38736[ebp], 0
	je	SHORT $L38746

; 813  : 			TryFire( BarrelPosition(), forward, pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR _forward$38737[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40275[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BarrelPosition@CBaseTank@@QAE?AVVector@@XZ ; CBaseTank::BarrelPosition
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TryFire@CBaseTank@@QAEXABVVector@@0PAUentvars_s@@@Z ; CBaseTank::TryFire

; 815  : 		else

	jmp	SHORT $L38748
$L38746:

; 817  : 			m_fireLast = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1832], 0
$L38748:

; 820  : 	else

	jmp	SHORT $L38749
$L38734:

; 822  : 		m_fireLast = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1832], 0
$L38749:
$L38675:

; 824  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TrackTarget@CBaseTank@@QAEXXZ ENDP			; CBaseTank::TrackTarget
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40286 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40286[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40289 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40289[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
PUBLIC	?FNullEnt@@YAHPAUentvars_s@@@Z			; FNullEnt
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT
_pev$ = 8
_szClassname$ = 12
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z PROC NEAR		; FClassnameIs, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 295  : 	if( FNullEnt( pev )) return FALSE;

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L32565
	xor	eax, eax
	jmp	SHORT $L32564
$L32565:

; 296  : 	return FStrEq( STRING( pev->classname ), szClassname );

	mov	ecx, DWORD PTR _szClassname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pev$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
$L32564:

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z ENDP		; FClassnameIs
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?FNullEnt@@YAHPAUentvars_s@@@Z PROC NEAR		; FNullEnt, COMDAT

; 196  : inline BOOL FNullEnt(entvars_t* pev)				{ return pev == NULL || FNullEnt(OFFSET(pev)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pev$[ebp], 0
	je	SHORT $L40296
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40296
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L40297
$L40296:
	mov	DWORD PTR -4+[ebp], 1
$L40297:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAUentvars_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad pev in OFFSET()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?OFFSET@@YAHPAUentvars_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L32439

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32439:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
;	COMDAT ?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z
_TEXT	SEGMENT
_vecAngles$ = 8
_p_vForward$ = 12
_p_vRight$ = 16
_p_vUp$ = 20
?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z PROC NEAR ; UTIL_MakeVectorsPrivate, COMDAT

; 343  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 344  : 	g_engfuncs.pfnAngleVectors( vecAngles, p_vForward, p_vRight, p_vUp );

	mov	eax, DWORD PTR _p_vUp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p_vRight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p_vForward$[ebp]
	push	edx
	mov	ecx, DWORD PTR _vecAngles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+80
	add	esp, 16					; 00000010H

; 345  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z ENDP	; UTIL_MakeVectorsPrivate
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator->, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
PUBLIC	?GetLocalTime@CBaseEntity@@QBEMXZ		; CBaseEntity::GetLocalTime
;	COMDAT ?SetMoveDoneTime@CBaseEntity@@QAEXM@Z
_TEXT	SEGMENT
_flDelay$ = 8
_this$ = -4
?SetMoveDoneTime@CBaseEntity@@QAEXM@Z PROC NEAR		; CBaseEntity::SetMoveDoneTime, COMDAT

; 798  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 799  : 	if( flDelay >= 0 )

	fld	DWORD PTR _flDelay$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L35183

; 800  : 		m_flMoveDoneTime = GetLocalTime() + flDelay;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetLocalTime
	fadd	DWORD PTR _flDelay$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+44]

; 801  : 	else m_flMoveDoneTime = -1;

	jmp	SHORT $L35184
$L35183:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], -1082130432		; bf800000H
$L35184:

; 802  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMoveDoneTime@CBaseEntity@@QAEXM@Z ENDP		; CBaseEntity::SetMoveDoneTime
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetLocalTime@CBaseEntity@@QBEMXZ PROC NEAR		; CBaseEntity::GetLocalTime, COMDAT

; 788  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 789  : 	return pev->ltime; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+256]

; 790  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLocalTime@CBaseEntity@@QBEMXZ ENDP			; CBaseEntity::GetLocalTime
_TEXT	ENDS
;	COMDAT ?CanFire@CBaseTank@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?CanFire@CBaseTank@@QAEHXZ PROC NEAR			; CBaseTank::CanFire, COMDAT

; 81   : 	inline BOOL CanFire( void ) { return (gpGlobals->time - m_lastSightTime) < m_persist; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx+1840]
	mov	edx, DWORD PTR _this$[ebp]
	fcomp	DWORD PTR [edx+1844]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40314
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40315
$L40314:
	mov	DWORD PTR -8+[ebp], 0
$L40315:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CanFire@CBaseTank@@QAEHXZ ENDP				; CBaseTank::CanFire
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0gametrace_s@@QAE@XZ PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0gametrace_s@@QAE@XZ ENDP				; gametrace_s::gametrace_s
_TEXT	ENDS
PUBLIC	__real@8@4004e52ee0d31e0fc000
EXTRN	_atan2:NEAR
;	COMDAT __real@8@4004e52ee0d31e0fc000
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
__real@8@4004e52ee0d31e0fc000 DQ 0404ca5dc1a63c1f8r ; 57.2958
CONST	ENDS
;	COMDAT ?AdjustAnglesForBarrel@CBaseTank@@QAEXAAVVector@@M@Z
_TEXT	SEGMENT
_angles$ = 8
_distance$ = 12
_this$ = -4
_r2$ = -8
_d2$ = -12
?AdjustAnglesForBarrel@CBaseTank@@QAEXAAVVector@@M@Z PROC NEAR ; CBaseTank::AdjustAnglesForBarrel, COMDAT

; 828  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 829  : 	float r2, d2;
; 830  : 
; 831  : 	if( m_barrelPos.y != 0 || m_barrelPos.z != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1860]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38760
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1864]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L38762
$L38760:

; 833  : 		distance -= m_barrelPos.z;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _distance$[ebp]
	fsub	DWORD PTR [edx+1864]
	fst	DWORD PTR _distance$[ebp]

; 834  : 		d2 = distance * distance;

	fmul	DWORD PTR _distance$[ebp]
	fstp	DWORD PTR _d2$[ebp]

; 835  : 
; 836  : 		if( m_barrelPos.y )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1860]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38761

; 838  : 			r2 = m_barrelPos.y * m_barrelPos.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1860]
	fmul	DWORD PTR [edx+1860]
	fstp	DWORD PTR _r2$[ebp]

; 839  : 			angles.y += (180.0 / M_PI) * atan2( m_barrelPos.y, sqrt( d2 - r2 ) );

	mov	eax, DWORD PTR _angles$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	QWORD PTR -20+[ebp]
	fld	DWORD PTR _d2$[ebp]
	fsub	DWORD PTR _r2$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1860]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fmul	QWORD PTR __real@8@4004e52ee0d31e0fc000
	fadd	QWORD PTR -20+[ebp]
	mov	edx, DWORD PTR _angles$[ebp]
	fstp	DWORD PTR [edx+4]
$L38761:

; 841  : 		if ( m_barrelPos.z )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1864]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38762

; 843  : 			r2 = m_barrelPos.z * m_barrelPos.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1864]
	fmul	DWORD PTR [edx+1864]
	fstp	DWORD PTR _r2$[ebp]

; 844  : 			angles.x -= (180.0 / M_PI) * atan2( -m_barrelPos.z, sqrt( d2 - r2 ) );

	mov	eax, DWORD PTR _angles$[ebp]
	fld	DWORD PTR [eax]
	fstp	QWORD PTR -28+[ebp]
	fld	DWORD PTR _d2$[ebp]
	fsub	DWORD PTR _r2$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1864]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fmul	QWORD PTR __real@8@4004e52ee0d31e0fc000
	fsubr	QWORD PTR -28+[ebp]
	mov	edx, DWORD PTR _angles$[ebp]
	fstp	DWORD PTR [edx]
$L38762:

; 847  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AdjustAnglesForBarrel@CBaseTank@@QAEXAAVVector@@M@Z ENDP ; CBaseTank::AdjustAnglesForBarrel
_TEXT	ENDS
;	COMDAT ?TryFire@CBaseTank@@QAEXABVVector@@0PAUentvars_s@@@Z
_TEXT	SEGMENT
_barrelEnd$ = 8
_forward$ = 12
_pevAttacker$ = 16
_this$ = -4
?TryFire@CBaseTank@@QAEXABVVector@@0PAUentvars_s@@@Z PROC NEAR ; CBaseTank::TryFire, COMDAT

; 851  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 852  : 	// NOTE: reason - player pressed a "fire"
; 853  : 	// in other cases we can't building some interesting things
; 854  : 	// e.g. barrel spinning up before fire
; 855  : 	m_iState = STATE_IN_USE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 4

; 856  : 
; 857  : 	if( UTIL_IsMasterTriggered( m_iszFireMaster, NULL ))

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1908]
	push	edx
	call	?UTIL_IsMasterTriggered@@YAHHPAVCBaseEntity@@@Z ; UTIL_IsMasterTriggered
	add	esp, 8
	test	eax, eax
	je	SHORT $L38769

; 859  : 		Fire( barrelEnd, forward, pevAttacker );

	mov	eax, DWORD PTR _pevAttacker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _forward$[ebp]
	push	ecx
	mov	edx, DWORD PTR _barrelEnd$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+340]
$L38769:

; 861  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?TryFire@CBaseTank@@QAEXABVVector@@0PAUentvars_s@@@Z ENDP ; CBaseTank::TryFire
_TEXT	ENDS
PUBLIC	?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z ; CBaseTank::Fire
PUBLIC	?SetTransparency@CSprite@@QAEXHHHHHH@Z		; CSprite::SetTransparency
PUBLIC	?SetScale@CSprite@@QAEXM@Z			; CSprite::SetScale
PUBLIC	?AnimateAndDie@CSprite@@QAEXM@Z			; CSprite::AnimateAndDie
EXTRN	__ftol:NEAR
EXTRN	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z:NEAR ; CBaseDelay::SUB_UseTargets
EXTRN	?SpriteCreate@CSprite@@SAPAV1@PBDABVVector@@H@Z:NEAR ; CSprite::SpriteCreate
EXTRN	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalVelocity
EXTRN	?SetParent@CBaseEntity@@QAEXPAV1@H@Z:NEAR	; CBaseEntity::SetParent
;	COMDAT ?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z
_TEXT	SEGMENT
$T40326 = -24
_barrelEnd$ = 8
_this$ = -4
_pSprite$38778 = -8
_pSprite$38781 = -12
?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z PROC NEAR ; CBaseTank::Fire, COMDAT

; 865  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 866  : 	if( m_fireLast != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1832]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L38776

; 868  : 		if( m_iszSpriteSmoke )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1872], 0
	je	$L38777

; 870  : 			CSprite *pSprite = CSprite::SpriteCreate( STRING( m_iszSpriteSmoke ), barrelEnd, TRUE );

	push	1
	mov	edx, DWORD PTR _barrelEnd$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1872]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?SpriteCreate@CSprite@@SAPAV1@PBDABVVector@@H@Z ; CSprite::SpriteCreate
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pSprite$38778[ebp], eax

; 871  : 			pSprite->AnimateAndDie( RANDOM_FLOAT( 15.0, 20.0 ) );

	push	1101004800				; 41a00000H
	push	1097859072				; 41700000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _pSprite$38778[ebp]
	call	?AnimateAndDie@CSprite@@QAEXM@Z		; CSprite::AnimateAndDie

; 872  : 			pSprite->SetTransparency( kRenderTransAlpha, pev->rendercolor.x, pev->rendercolor.y, pev->rendercolor.z, 255, kRenderFxNone );

	push	0
	push	255					; 000000ffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+344]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+340]
	call	__ftol
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+336]
	call	__ftol
	push	eax
	push	4
	mov	ecx, DWORD PTR _pSprite$38778[ebp]
	call	?SetTransparency@CSprite@@QAEXHHHHHH@Z	; CSprite::SetTransparency

; 873  : 			pSprite->SetLocalVelocity( Vector( 0.0f, 0.0f, RANDOM_FLOAT( 40, 80 )));

	push	1117782016				; 42a00000H
	push	1109393408				; 42200000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	0
	push	0
	lea	ecx, DWORD PTR $T40326[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _pSprite$38778[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 874  : 			pSprite->SetScale( m_spriteScale );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1868]
	push	eax
	mov	ecx, DWORD PTR _pSprite$38778[ebp]
	call	?SetScale@CSprite@@QAEXM@Z		; CSprite::SetScale
$L38777:

; 876  : 
; 877  : 		if( m_iszSpriteFlash )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1876], 0
	je	SHORT $L38780

; 879  : 			CSprite *pSprite = CSprite::SpriteCreate( STRING( m_iszSpriteFlash ), barrelEnd, TRUE );

	push	1
	mov	edx, DWORD PTR _barrelEnd$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1876]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?SpriteCreate@CSprite@@SAPAV1@PBDABVVector@@H@Z ; CSprite::SpriteCreate
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pSprite$38781[ebp], eax

; 880  : 			pSprite->SetTransparency( kRenderTransAdd, 255, 255, 255, 255, kRenderFxNoDissipation );

	push	14					; 0000000eH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	5
	mov	ecx, DWORD PTR _pSprite$38781[ebp]
	call	?SetTransparency@CSprite@@QAEXHHHHHH@Z	; CSprite::SetTransparency

; 881  : 			pSprite->SetScale( m_spriteScale );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1868]
	push	eax
	mov	ecx, DWORD PTR _pSprite$38781[ebp]
	call	?SetScale@CSprite@@QAEXM@Z		; CSprite::SetScale

; 882  : 			pSprite->AnimateAndDie( 60 );

	push	1114636288				; 42700000H
	mov	ecx, DWORD PTR _pSprite$38781[ebp]
	call	?AnimateAndDie@CSprite@@QAEXM@Z		; CSprite::AnimateAndDie

; 883  : 			pSprite->SetParent( this );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pSprite$38781[ebp]
	call	?SetParent@CBaseEntity@@QAEXPAV1@H@Z	; CBaseEntity::SetParent
$L38780:

; 885  : 
; 886  : 		SUB_UseTargets( this, USE_TOGGLE, 0 );

	push	0
	push	0
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets
$L38776:

; 888  : 
; 889  : 	m_fireLast = gpGlobals->time;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+1832], edx

; 890  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z ENDP	; CBaseTank::Fire
_TEXT	ENDS
;	COMDAT ?SetTransparency@CSprite@@QAEXHHHHHH@Z
_TEXT	SEGMENT
_rendermode$ = 8
_r$ = 12
_g$ = 16
_b$ = 20
_a$ = 24
_fx$ = 28
_this$ = -4
?SetTransparency@CSprite@@QAEXHHHHHH@Z PROC NEAR	; CSprite::SetTransparency, COMDAT

; 79   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 		pev->rendermode = rendermode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR [ecx+328], edx

; 81   : 		pev->rendercolor.x = r;

	fild	DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+336]

; 82   : 		pev->rendercolor.y = g;

	fild	DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+340]

; 83   : 		pev->rendercolor.z = b;

	fild	DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+344]

; 84   : 		pev->renderamt = a;

	fild	DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+332]

; 85   : 		pev->renderfx = fx;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _fx$[ebp]
	mov	DWORD PTR [eax+348], ecx

; 86   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?SetTransparency@CSprite@@QAEXHHHHHH@Z ENDP		; CSprite::SetTransparency
_TEXT	ENDS
;	COMDAT ?SetScale@CSprite@@QAEXM@Z
_TEXT	SEGMENT
_scale$ = 8
_this$ = -4
?SetScale@CSprite@@QAEXM@Z PROC NEAR			; CSprite::SetScale, COMDAT

; 89   : 	inline void SetScale( float scale ) { pev->scale = scale; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [ecx+324], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScale@CSprite@@QAEXM@Z ENDP				; CSprite::SetScale
_TEXT	ENDS
PUBLIC	??_C@_0BB@GGEN@AnimateUntilDead?$AA@		; `string'
PUBLIC	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
EXTRN	?AnimateUntilDead@CSprite@@QAEXXZ:NEAR		; CSprite::AnimateUntilDead
;	COMDAT ??_C@_0BB@GGEN@AnimateUntilDead?$AA@
; File z:\xashxtsrc\server\effects.h
CONST	SEGMENT
??_C@_0BB@GGEN@AnimateUntilDead?$AA@ DB 'AnimateUntilDead', 00H ; `string'
CONST	ENDS
;	COMDAT ?AnimateAndDie@CSprite@@QAEXM@Z
_TEXT	SEGMENT
_framerate$ = 8
_this$ = -4
?AnimateAndDie@CSprite@@QAEXM@Z PROC NEAR		; CSprite::AnimateAndDie, COMDAT

; 94   : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 		SetThink(AnimateUntilDead); 

	push	OFFSET FLAT:??_C@_0BB@GGEN@AnimateUntilDead?$AA@ ; `string'
	push	OFFSET FLAT:?AnimateUntilDead@CSprite@@QAEXXZ ; CSprite::AnimateUntilDead
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 96   : 		pev->framerate = framerate;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _framerate$[ebp]
	mov	DWORD PTR [ecx+312], edx

; 97   : 		pev->dmgtime = gpGlobals->time + (m_maxFrame / framerate); 

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1772]
	fdiv	DWORD PTR _framerate$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+484]

; 98   : 		pev->nextthink = gpGlobals->time; 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+260], ecx

; 99   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AnimateAndDie@CSprite@@QAEXM@Z ENDP			; CSprite::AnimateAndDie
_TEXT	ENDS
PUBLIC	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z	; CBaseEntity::FunctionCheck
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::ThinkSet, COMDAT

; 560  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 		m_pfnThink = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1744], ecx

; 562  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnThink)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1744]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 563  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 564  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP	; CBaseEntity::ThinkSet
_TEXT	ENDS
PUBLIC	??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:NEAR ; UTIL_FunctionToName
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ DB 'F'
	DB	'UNCTION NOT IN TABLE!: %s:%s (%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT
_this$ = -4
_pFunction$ = 8
_name$ = 12
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z PROC NEAR	; CBaseEntity::FunctionCheck, COMDAT

; 554  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 		if (pFunction && !UTIL_FunctionToName( GetDataDescMap(), pFunction ) )

	cmp	DWORD PTR _pFunction$[ebp], 0
	je	SHORT $L35044
	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	test	eax, eax
	jne	SHORT $L35044

; 556  : 			ALERT( at_warning, "FUNCTION NOT IN TABLE!: %s:%s (%08lx)\n", GetClassname(), name, (unsigned long)pFunction );

	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L35044:

; 557  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ENDP		; CBaseEntity::FunctionCheck
_TEXT	ENDS
PUBLIC	?TankTrace@CBaseTank@@QAEXABVVector@@00AAUgametrace_s@@@Z ; CBaseTank::TankTrace
PUBLIC	??D@YA?AVVector@@MABV0@@Z			; operator*
;	COMDAT ?TankTrace@CBaseTank@@QAEXABVVector@@00AAUgametrace_s@@@Z
_TEXT	SEGMENT
$T40340 = -52
$T40341 = -64
$T40342 = -76
$T40343 = -88
$T40344 = -100
$T40345 = -112
_vecStart$ = 8
_vecForward$ = 12
_vecSpread$ = 16
_tr$ = 20
_this$ = -4
_x$ = -8
_y$ = -12
_z$ = -16
_vecDir$ = -28
_vecEnd$ = -40
?TankTrace@CBaseTank@@QAEXABVVector@@00AAUgametrace_s@@@Z PROC NEAR ; CBaseTank::TankTrace, COMDAT

; 893  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
$L38792:

; 897  : 		x = RANDOM_FLOAT( -0.5f, 0.5f ) + RANDOM_FLOAT( -0.5f, 0.5f );

	push	1056964608				; 3f000000H
	push	-1090519040				; bf000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	fstp	DWORD PTR -116+[ebp]
	add	esp, 8
	push	1056964608				; 3f000000H
	push	-1090519040				; bf000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR -116+[ebp]
	fstp	DWORD PTR _x$[ebp]

; 898  : 		y = RANDOM_FLOAT( -0.5f, 0.5f ) + RANDOM_FLOAT( -0.5f, 0.5f );

	push	1056964608				; 3f000000H
	push	-1090519040				; bf000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	fstp	DWORD PTR -120+[ebp]
	add	esp, 8
	push	1056964608				; 3f000000H
	push	-1090519040				; bf000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fadd	DWORD PTR -120+[ebp]
	fstp	DWORD PTR _y$[ebp]

; 899  : 		z = x * x + y * y;

	fld	DWORD PTR _x$[ebp]
	fmul	DWORD PTR _x$[ebp]
	fld	DWORD PTR _y$[ebp]
	fmul	DWORD PTR _y$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _z$[ebp]

; 900  : 	} while( z > 1 );

	fld	DWORD PTR _z$[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38792

; 901  : 
; 902  : 	Vector vecDir = vecForward + x * vecSpread.x * gpGlobals->v_right + y * vecSpread.y * gpGlobals->v_up;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR _vecSpread$[ebp]
	fld	DWORD PTR _y$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR $T40342[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T40343[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	push	ecx
	mov	edx, DWORD PTR _vecSpread$[ebp]
	fld	DWORD PTR _x$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T40340[ebp]
	push	eax
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T40341[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vecForward$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 903  : 	Vector vecEnd = vecStart + vecDir * 4096;

	push	1166016512				; 45800000H
	lea	edx, DWORD PTR $T40344[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T40345[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecStart$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 904  : 
; 905  : 	UTIL_TraceLine( vecStart, vecEnd, dont_ignore_monsters, edict(), &tr );

	mov	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	lea	edx, DWORD PTR _vecEnd$[ebp]
	push	edx
	mov	eax, DWORD PTR _vecStart$[ebp]
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 906  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TankTrace@CBaseTank@@QAEXABVVector@@00AAUgametrace_s@@@Z ENDP ; CBaseTank::TankTrace
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT
_fl$ = 12
_v$ = 16
___$ReturnUdt$ = 8
$T40348 = -12
??D@YA?AVVector@@MABV0@@Z PROC NEAR			; operator*, COMDAT

; 288  : inline Vector operator* ( float fl, const Vector& v ) { return v * fl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40348[ebp]
	push	ecx
	mov	ecx, DWORD PTR _v$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??D@YA?AVVector@@MABV0@@Z ENDP				; operator*
_TEXT	ENDS
PUBLIC	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z		; EMIT_SOUND
;	COMDAT ?StartRotSound@CBaseTank@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartRotSound@CBaseTank@@QAEXXZ PROC NEAR		; CBaseTank::StartRotSound, COMDAT

; 909  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 910  : 	if( !pev->noise || FBitSet( pev->spawnflags, SF_TANK_SOUNDON ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+488], 0
	je	SHORT $L38808
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 32768				; 00008000H
	test	ecx, ecx
	je	SHORT $L38807
$L38808:

; 911  : 		return;

	jmp	SHORT $L38806
$L38807:

; 912  : 
; 913  : 	SetBits( pev->spawnflags, SF_TANK_SOUNDON );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	or	ch, -128				; ffffff80H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+416], ecx

; 914  : 	EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ), 0.85f, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1062836634				; 3f59999aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+488]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L38806:

; 915  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartRotSound@CBaseTank@@QAEXXZ ENDP			; CBaseTank::StartRotSound
_TEXT	ENDS
EXTRN	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z:NEAR	; EMIT_SOUND_DYN
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
_volume$ = 20
_attenuation$ = 24
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z PROC NEAR		; EMIT_SOUND, COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 610  : 	EMIT_SOUND_DYN( entity, channel, sample, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 611  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z ENDP		; EMIT_SOUND
_TEXT	ENDS
PUBLIC	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z		; STOP_SOUND
;	COMDAT ?StopRotSound@CBaseTank@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopRotSound@CBaseTank@@QAEXXZ PROC NEAR		; CBaseTank::StopRotSound, COMDAT

; 918  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 919  : 	if( FBitSet( pev->spawnflags, SF_TANK_SOUNDON ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 32768				; 00008000H
	test	edx, edx
	je	SHORT $L38814

; 920  : 		STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+488]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH
$L38814:

; 921  : 	ClearBits( pev->spawnflags, SF_TANK_SOUNDON );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	dh, 127					; 0000007fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+416], edx

; 922  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopRotSound@CBaseTank@@QAEXXZ ENDP			; CBaseTank::StopRotSound
_TEXT	ENDS
;	COMDAT ?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z PROC NEAR		; STOP_SOUND, COMDAT

; 614  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 615  : 	EMIT_SOUND_DYN( entity, channel, sample, 0, 0, SND_STOP, PITCH_NORM );

	push	100					; 00000064H
	push	32					; 00000020H
	push	0
	push	0
	mov	eax, DWORD PTR _sample$[ebp]
	push	eax
	mov	ecx, DWORD PTR _channel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entity$[ebp]
	push	edx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 616  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z ENDP			; STOP_SOUND
_TEXT	ENDS
;	COMDAT _$E44
_TEXT	SEGMENT
_$E44	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E43
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E44	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncTankGun@@@@QAE@PBD@Z	; CEntityFactory<CFuncTankGun>::CEntityFactory<CFuncTankGun>
PUBLIC	??_C@_09BEDO@func_tank?$AA@			; `string'
_BSS	SEGMENT
_func_tank DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09BEDO@func_tank?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_09BEDO@func_tank?$AA@ DB 'func_tank', 00H		; `string'
CONST	ENDS
;	COMDAT _$E43
_TEXT	SEGMENT
_$E43	PROC NEAR					; COMDAT

; 931  : LINK_ENTITY_TO_CLASS( func_tank, CFuncTankGun );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_09BEDO@func_tank?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_func_tank
	call	??0?$CEntityFactory@VCFuncTankGun@@@@QAE@PBD@Z ; CEntityFactory<CFuncTankGun>::CEntityFactory<CFuncTankGun>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E43	ENDP
_TEXT	ENDS
PUBLIC	?Fire@CFuncTankGun@@UAEXABVVector@@0PAUentvars_s@@@Z ; CFuncTankGun::Fire
EXTRN	?FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z:NEAR ; CBaseEntity::FireBullets
EXTRN	?UTIL_MakeAimVectors@@YAXABVVector@@@Z:NEAR	; UTIL_MakeAimVectors
;	COMDAT ?Fire@CFuncTankGun@@UAEXABVVector@@0PAUentvars_s@@@Z
_TEXT	SEGMENT
_barrelEnd$ = 8
_forward$ = 12
_pevAttacker$ = 16
_this$ = -4
_i$ = -8
_bulletCount$38868 = -12
?Fire@CFuncTankGun@@UAEXABVVector@@0PAUentvars_s@@@Z PROC NEAR ; CFuncTankGun::Fire, COMDAT

; 934  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 	int i;
; 936  : 
; 937  : 	if( m_fireLast != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1832]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L38867

; 939  : 		// fireBullets needs gpGlobals->v_up, etc.
; 940  : 		UTIL_MakeAimVectors( GetAbsAngles( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeAimVectors@@YAXABVVector@@@Z	; UTIL_MakeAimVectors
	add	esp, 4

; 941  : 
; 942  : 		int bulletCount = (gpGlobals->time - m_fireLast) * m_fireRate;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx+1832]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+1836]
	call	__ftol
	mov	DWORD PTR _bulletCount$38868[ebp], eax

; 943  : 
; 944  : 		if( bulletCount > 0 )

	cmp	DWORD PTR _bulletCount$38868[ebp], 0
	jle	$L38869

; 946  : 			for( i = 0; i < bulletCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38870
$L38871:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L38870:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _bulletCount$38868[ebp]
	jge	$L38872

; 949  : 				{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1880]
	mov	DWORD PTR -52+[ebp], ecx
	cmp	DWORD PTR -52+[ebp], 1
	je	SHORT $L38877
	cmp	DWORD PTR -52+[ebp], 2
	je	SHORT $L38881
	cmp	DWORD PTR -52+[ebp], 3
	je	$L38885
	jmp	$L38889
$L38877:

; 950  : 				case TANK_BULLET_9MM:
; 951  : 					FireBullets( 1, barrelEnd, forward, gTankSpread[m_spread], 4096, BULLET_MONSTER_9MM, 1, m_iBulletDamage, pevAttacker );

	mov	edx, DWORD PTR _pevAttacker$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1884]
	push	ecx
	push	1
	push	6
	push	1166016512				; 45800000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1900]
	imul	eax, 12					; 0000000cH
	add	eax, OFFSET FLAT:_gTankSpread
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR _forward$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	eax, DWORD PTR _barrelEnd$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z ; CBaseEntity::FireBullets

; 952  : 					break;

	jmp	$L38874
$L38881:

; 953  : 				case TANK_BULLET_MP5:
; 954  : 					FireBullets( 1, barrelEnd, forward, gTankSpread[m_spread], 4096, BULLET_MONSTER_MP5, 1, m_iBulletDamage, pevAttacker );

	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1884]
	push	eax
	push	1
	push	7
	push	1166016512				; 45800000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1900]
	imul	edx, 12					; 0000000cH
	add	edx, OFFSET FLAT:_gTankSpread
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	eax, DWORD PTR _forward$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR _barrelEnd$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z ; CBaseEntity::FireBullets

; 955  : 					break;

	jmp	SHORT $L38874
$L38885:

; 956  : 				case TANK_BULLET_12MM:
; 957  : 					FireBullets( 1, barrelEnd, forward, gTankSpread[m_spread], 4096, BULLET_MONSTER_12MM, 1, m_iBulletDamage, pevAttacker );

	mov	eax, DWORD PTR _pevAttacker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1884]
	push	edx
	push	1
	push	8
	push	1166016512				; 45800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1900]
	imul	ecx, 12					; 0000000cH
	add	ecx, OFFSET FLAT:_gTankSpread
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	push	ecx
	mov	ecx, edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	eax, DWORD PTR _forward$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR _barrelEnd$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FireBullets@CBaseEntity@@QAEXKVVector@@00MHHHPAUentvars_s@@@Z ; CBaseEntity::FireBullets
$L38889:
$L38874:

; 962  : 			}

	jmp	$L38871
$L38872:

; 963  : 
; 964  : 			BaseClass::Fire( barrelEnd, forward, pevAttacker );

	mov	eax, DWORD PTR _pevAttacker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _forward$[ebp]
	push	ecx
	mov	edx, DWORD PTR _barrelEnd$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z ; CBaseTank::Fire
$L38869:

; 967  : 	else

	jmp	SHORT $L38890
$L38867:

; 969  : 		BaseClass::Fire( barrelEnd, forward, pevAttacker );

	mov	eax, DWORD PTR _pevAttacker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _forward$[ebp]
	push	ecx
	mov	edx, DWORD PTR _barrelEnd$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z ; CBaseTank::Fire
$L38890:

; 971  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Fire@CFuncTankGun@@UAEXABVVector@@0PAUentvars_s@@@Z ENDP ; CFuncTankGun::Fire
_TEXT	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT
_$E48	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E47
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E48	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncTankLaser@@@@QAE@PBD@Z ; CEntityFactory<CFuncTankLaser>::CEntityFactory<CFuncTankLaser>
PUBLIC	??_C@_0P@JLJO@func_tanklaser?$AA@		; `string'
_BSS	SEGMENT
_func_tanklaser DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0P@JLJO@func_tanklaser?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_0P@JLJO@func_tanklaser?$AA@ DB 'func_tanklaser', 00H ; `string'
CONST	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT
_$E47	PROC NEAR					; COMDAT

; 989  : LINK_ENTITY_TO_CLASS( func_tanklaser, CFuncTankLaser );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0P@JLJO@func_tanklaser?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_tanklaser
	call	??0?$CEntityFactory@VCFuncTankLaser@@@@QAE@PBD@Z ; CEntityFactory<CFuncTankLaser>::CEntityFactory<CFuncTankLaser>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E47	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CFuncTankLaser@@UAEPAUdatamap_s@@XZ ; CFuncTankLaser::GetDataDescMap
;	COMDAT ?GetDataDescMap@CFuncTankLaser@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CFuncTankLaser@@UAEPAUdatamap_s@@XZ PROC NEAR ; CFuncTankLaser::GetDataDescMap, COMDAT

; 991  : BEGIN_DATADESC( CFuncTankLaser )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTankLaser@@2Udatamap_s@@A ; CFuncTankLaser::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CFuncTankLaser@@UAEPAUdatamap_s@@XZ ENDP ; CFuncTankLaser::GetDataDescMap
_TEXT	ENDS
PUBLIC	?DataMapAccess@@YAXPAVCBaseTank@@PAPAUdatamap_s@@@Z ; DataMapAccess
PUBLIC	?GetBaseMap@CFuncTankLaser@@SAPAUdatamap_s@@XZ	; CFuncTankLaser::GetBaseMap
;	COMDAT ?GetBaseMap@CFuncTankLaser@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CFuncTankLaser@@SAPAUdatamap_s@@XZ PROC NEAR ; CFuncTankLaser::GetBaseMap, COMDAT

; 991  : BEGIN_DATADESC( CFuncTankLaser )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseTank@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CFuncTankLaser@@SAPAUdatamap_s@@XZ ENDP	; CFuncTankLaser::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E51
_TEXT	SEGMENT
_$E51	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E50
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E51	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z ; DataMapInit
;	COMDAT _$E50
_TEXT	SEGMENT
_$E50	PROC NEAR					; COMDAT

; 991  : BEGIN_DATADESC( CFuncTankLaser )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CFuncTankLaser_DataDescInit@@3PAUdatamap_s@@A, eax ; CFuncTankLaser_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E50	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S53@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z PROC NEAR ; DataMapInit, COMDAT

; 991  : BEGIN_DATADESC( CFuncTankLaser )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S53@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L38997
	mov	cl, BYTE PTR _?$S53@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S53@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0P@GDKG@CFuncTankLaser?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E54
	call	_atexit
	add	esp, 4
$L38997:
	call	?GetBaseMap@CFuncTankLaser@@SAPAUdatamap_s@@XZ ; CFuncTankLaser::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CFuncTankLaser@@2Udatamap_s@@A+12, eax

; 992  : 	DEFINE_FIELD( m_pLaser, FIELD_CLASSPTR ),
; 993  : 	DEFINE_FIELD( m_laserTime, FIELD_TIME ),
; 994  : END_DATADESC()

	mov	edx, 1
	test	edx, edx
	je	SHORT $L39007
	mov	DWORD PTR ?m_DataMap@CFuncTankLaser@@2Udatamap_s@@A+4, 2
	mov	DWORD PTR ?m_DataMap@CFuncTankLaser@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L39008
$L39007:
	mov	DWORD PTR ?m_DataMap@CFuncTankLaser@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncTankLaser@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z@4PAUtypedescription_s@@A
$L39008:
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTankLaser@@2Udatamap_s@@A ; CFuncTankLaser::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z ENDP ; DataMapInit
_TEXT	ENDS
;	COMDAT _$E54
_TEXT	SEGMENT
_$E54	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankLaser@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E54	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@OKIM@Laser?5tank?5with?5no?5env_laser?$CB?6?$AA@ ; `string'
PUBLIC	?Activate@CBaseEntity@@UAEXXZ			; CBaseEntity::Activate
PUBLIC	?Activate@CFuncTankLaser@@UAEXXZ		; CFuncTankLaser::Activate
PUBLIC	?GetLaser@CFuncTankLaser@@QAEPAVCLaser@@XZ	; CFuncTankLaser::GetLaser
EXTRN	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_Remove
EXTRN	?TurnOff@CLaser@@QAEXXZ:NEAR			; CLaser::TurnOff
;	COMDAT ??_C@_0BP@OKIM@Laser?5tank?5with?5no?5env_laser?$CB?6?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_0BP@OKIM@Laser?5tank?5with?5no?5env_laser?$CB?6?$AA@ DB 'Laser tank'
	DB	' with no env_laser!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?Activate@CFuncTankLaser@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Activate@CFuncTankLaser@@UAEXXZ PROC NEAR		; CFuncTankLaser::Activate, COMDAT

; 997  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 998  : 	if( !GetLaser( ) )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLaser@CFuncTankLaser@@QAEPAVCLaser@@XZ ; CFuncTankLaser::GetLaser
	test	eax, eax
	jne	SHORT $L39014

; 1000 : 		ALERT( at_error, "Laser tank with no env_laser!\n" );

	push	OFFSET FLAT:??_C@_0BP@OKIM@Laser?5tank?5with?5no?5env_laser?$CB?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1001 : 		UTIL_Remove( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 1002 : 		return;

	jmp	SHORT $L39013
$L39014:

; 1006 : 		m_pLaser->TurnOff();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1920]
	call	?TurnOff@CLaser@@QAEXXZ			; CLaser::TurnOff

; 1008 : 
; 1009 : 	m_bulletType = TANK_BULLET_OTHER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1880], 4

; 1010 : 
; 1011 : 	BaseClass::Activate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Activate@CBaseEntity@@UAEXXZ		; CBaseEntity::Activate
$L39013:

; 1012 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CFuncTankLaser@@UAEXXZ ENDP			; CFuncTankLaser::Activate
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Activate@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Activate, COMDAT

; 365  : 	virtual void	Activate( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Activate
_TEXT	ENDS
PUBLIC	??_C@_0M@JAJF@laserentity?$AA@			; `string'
PUBLIC	?KeyValue@CFuncTankLaser@@UAEXPAUKeyValueData_s@@@Z ; CFuncTankLaser::KeyValue
;	COMDAT ??_C@_0M@JAJF@laserentity?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_0M@JAJF@laserentity?$AA@ DB 'laserentity', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CFuncTankLaser@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CFuncTankLaser@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CFuncTankLaser::KeyValue, COMDAT

; 1015 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1016 : 	if( FStrEq( pkvd->szKeyName, "laserentity" ))

	push	OFFSET FLAT:??_C@_0M@JAJF@laserentity?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39021

; 1018 : 		pev->message = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+468], eax

; 1019 : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 1021 : 	else

	jmp	SHORT $L39023
$L39021:

; 1023 : 		BaseClass::KeyValue( pkvd );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseTank@@UAEXPAUKeyValueData_s@@@Z ; CBaseTank::KeyValue
$L39023:

; 1025 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CFuncTankLaser@@UAEXPAUKeyValueData_s@@@Z ENDP ; CFuncTankLaser::KeyValue
_TEXT	ENDS
PUBLIC	??_C@_09JOGA@env_laser?$AA@			; `string'
EXTRN	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z:NEAR ; UTIL_FindEntityByTargetname
;	COMDAT ??_C@_09JOGA@env_laser?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_09JOGA@env_laser?$AA@ DB 'env_laser', 00H		; `string'
CONST	ENDS
;	COMDAT ?GetLaser@CFuncTankLaser@@QAEPAVCLaser@@XZ
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = -8
?GetLaser@CFuncTankLaser@@QAEPAVCLaser@@XZ PROC NEAR	; CFuncTankLaser::GetLaser, COMDAT

; 1028 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 	if( m_pLaser )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1920], 0
	je	SHORT $L39028

; 1030 : 		return m_pLaser;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+1920]
	jmp	$L39027
$L39028:

; 1033 : 
; 1034 : 	pEntity = UTIL_FindEntityByTargetname( NULL, STRING( pev->message ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+468]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pEntity$[ebp], eax
$L39031:

; 1035 : 
; 1036 : 	while( pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L39032

; 1038 : 		// Found the laser
; 1039 : 		if( FClassnameIs( pEntity->pev, "env_laser" ))

	push	OFFSET FLAT:??_C@_09JOGA@env_laser?$AA@	; `string'
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L39033

; 1041 : 			m_pLaser = (CLaser *)pEntity;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [ecx+1920], edx

; 1042 : 			break;

	jmp	SHORT $L39032
$L39033:

; 1046 : 			pEntity = UTIL_FindEntityByTargetname( pEntity, STRING( pev->message ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pEntity$[ebp], eax

; 1048 : 	}

	jmp	SHORT $L39031
$L39032:

; 1049 : 	return m_pLaser;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+1920]
$L39027:

; 1050 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLaser@CFuncTankLaser@@QAEPAVCLaser@@XZ ENDP		; CFuncTankLaser::GetLaser
_TEXT	ENDS
PUBLIC	?Think@CFuncTankLaser@@UAEXXZ			; CFuncTankLaser::Think
;	COMDAT ?Think@CFuncTankLaser@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Think@CFuncTankLaser@@UAEXXZ PROC NEAR			; CFuncTankLaser::Think, COMDAT

; 1053 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1054 : 	if( m_pLaser && ( gpGlobals->time > m_laserTime ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1920], 0
	je	SHORT $L39041
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR [edx+1924]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39041

; 1055 : 		m_pLaser->TurnOff();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1920]
	call	?TurnOff@CLaser@@QAEXXZ			; CLaser::TurnOff
$L39041:

; 1056 : 
; 1057 : 	CBaseTank::Think();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Think@CBaseTank@@UAEXXZ		; CBaseTank::Think

; 1058 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CFuncTankLaser@@UAEXXZ ENDP			; CFuncTankLaser::Think
_TEXT	ENDS
PUBLIC	?Fire@CFuncTankLaser@@UAEXABVVector@@0PAUentvars_s@@@Z ; CFuncTankLaser::Fire
EXTRN	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsOrigin
EXTRN	?TurnOn@CLaser@@QAEXXZ:NEAR			; CLaser::TurnOn
EXTRN	?FireAtPoint@CLaser@@QAEXABVVector@@AAUgametrace_s@@@Z:NEAR ; CLaser::FireAtPoint
;	COMDAT ?Fire@CFuncTankLaser@@UAEXABVVector@@0PAUentvars_s@@@Z
_TEXT	SEGMENT
_barrelEnd$ = 8
_forward$ = 12
_this$ = -4
_tr$ = -60
_bulletCount$39050 = -64
_i$39052 = -68
?Fire@CFuncTankLaser@@UAEXABVVector@@0PAUentvars_s@@@Z PROC NEAR ; CFuncTankLaser::Fire, COMDAT

; 1061 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1062 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1063 : 
; 1064 : 	if( m_fireLast != 0 && GetLaser() )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1832]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L39049
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLaser@CFuncTankLaser@@QAEPAVCLaser@@XZ ; CFuncTankLaser::GetLaser
	test	eax, eax
	je	$L39049

; 1066 : 		// TankTrace needs gpGlobals->v_up, etc.
; 1067 : 		UTIL_MakeAimVectors( GetAbsAngles( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeAimVectors@@YAXABVVector@@@Z	; UTIL_MakeAimVectors
	add	esp, 4

; 1068 : 
; 1069 : 		int bulletCount = (gpGlobals->time - m_fireLast) * m_fireRate;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx+1832]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+1836]
	call	__ftol
	mov	DWORD PTR _bulletCount$39050[ebp], eax

; 1070 : 		if( bulletCount )

	cmp	DWORD PTR _bulletCount$39050[ebp], 0
	je	$L39051

; 1072 : 			for( int i = 0; i < bulletCount; i++ )

	mov	DWORD PTR _i$39052[ebp], 0
	jmp	SHORT $L39053
$L39054:
	mov	ecx, DWORD PTR _i$39052[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$39052[ebp], ecx
$L39053:
	mov	edx, DWORD PTR _i$39052[ebp]
	cmp	edx, DWORD PTR _bulletCount$39050[ebp]
	jge	$L39055

; 1074 : 				m_pLaser->SetAbsOrigin( barrelEnd );

	mov	eax, DWORD PTR _barrelEnd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1920]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 1075 : 				TankTrace( barrelEnd, forward, gTankSpread[m_spread], tr );

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1900]
	imul	ecx, 12					; 0000000cH
	add	ecx, OFFSET FLAT:_gTankSpread
	push	ecx
	mov	edx, DWORD PTR _forward$[ebp]
	push	edx
	mov	eax, DWORD PTR _barrelEnd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TankTrace@CBaseTank@@QAEXABVVector@@00AAUgametrace_s@@@Z ; CBaseTank::TankTrace

; 1076 : 				
; 1077 : 				m_laserTime = gpGlobals->time;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+1924], eax

; 1078 : 				m_pLaser->TurnOn();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1920]
	call	?TurnOn@CLaser@@QAEXXZ			; CLaser::TurnOn

; 1079 : 				m_pLaser->pev->dmgtime = gpGlobals->time - 1.0f;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1920]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+484]

; 1080 : 				m_pLaser->FireAtPoint( barrelEnd, tr );

	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _barrelEnd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1920]
	call	?FireAtPoint@CLaser@@QAEXABVVector@@AAUgametrace_s@@@Z ; CLaser::FireAtPoint

; 1081 : 				m_pLaser->SetNextThink( 0 );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1920]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1920]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+80]

; 1082 : 			}

	jmp	$L39054
$L39055:

; 1083 : 
; 1084 : 			BaseClass::Fire( barrelEnd, forward, pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _forward$[ebp]
	push	edx
	mov	eax, DWORD PTR _barrelEnd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z ; CBaseTank::Fire
$L39051:

; 1087 : 	else

	jmp	SHORT $L39056
$L39049:

; 1089 : 		BaseClass::Fire( barrelEnd, forward, pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _forward$[ebp]
	push	eax
	mov	ecx, DWORD PTR _barrelEnd$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z ; CBaseTank::Fire
$L39056:

; 1091 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Fire@CFuncTankLaser@@UAEXABVVector@@0PAUentvars_s@@@Z ENDP ; CFuncTankLaser::Fire
_TEXT	ENDS
;	COMDAT _$E56
_TEXT	SEGMENT
_$E56	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E55
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E56	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncTankRocket@@@@QAE@PBD@Z ; CEntityFactory<CFuncTankRocket>::CEntityFactory<CFuncTankRocket>
PUBLIC	??_C@_0BA@IDLO@func_tankrocket?$AA@		; `string'
_BSS	SEGMENT
	ALIGN	4

_func_tankrocket DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BA@IDLO@func_tankrocket?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_0BA@IDLO@func_tankrocket?$AA@ DB 'func_tankrocket', 00H ; `string'
CONST	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT
_$E55	PROC NEAR					; COMDAT

; 1101 : LINK_ENTITY_TO_CLASS( func_tankrocket, CFuncTankRocket );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BA@IDLO@func_tankrocket?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_tankrocket
	call	??0?$CEntityFactory@VCFuncTankRocket@@@@QAE@PBD@Z ; CEntityFactory<CFuncTankRocket>::CEntityFactory<CFuncTankRocket>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E55	ENDP
_TEXT	ENDS
PUBLIC	?Precache@CFuncTankRocket@@UAEXXZ		; CFuncTankRocket::Precache
PUBLIC	??_C@_0L@CFGE@rpg_rocket?$AA@			; `string'
EXTRN	?UTIL_PrecacheOther@@YAXPBD@Z:NEAR		; UTIL_PrecacheOther
;	COMDAT ??_C@_0L@CFGE@rpg_rocket?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_0L@CFGE@rpg_rocket?$AA@ DB 'rpg_rocket', 00H	; `string'
CONST	ENDS
;	COMDAT ?Precache@CFuncTankRocket@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CFuncTankRocket@@UAEXXZ PROC NEAR		; CFuncTankRocket::Precache, COMDAT

; 1104 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 	UTIL_PrecacheOther( "rpg_rocket" );

	push	OFFSET FLAT:??_C@_0L@CFGE@rpg_rocket?$AA@ ; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 1106 : 	BaseClass::Precache();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Precache@CBaseTank@@UAEXXZ		; CBaseTank::Precache

; 1107 : 
; 1108 : 	m_bulletType = TANK_BULLET_OTHER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1880], 4

; 1109 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CFuncTankRocket@@UAEXXZ ENDP			; CFuncTankRocket::Precache
_TEXT	ENDS
PUBLIC	?Fire@CFuncTankRocket@@UAEXABVVector@@0PAUentvars_s@@@Z ; CFuncTankRocket::Fire
EXTRN	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z:NEAR ; CBaseEntity::Create
;	COMDAT ?Fire@CFuncTankRocket@@UAEXABVVector@@0PAUentvars_s@@@Z
_TEXT	SEGMENT
_barrelEnd$ = 8
_forward$ = 12
_this$ = -4
_bulletCount$39116 = -8
_i$39118 = -12
_pRocket$39122 = -16
?Fire@CFuncTankRocket@@UAEXABVVector@@0PAUentvars_s@@@Z PROC NEAR ; CFuncTankRocket::Fire, COMDAT

; 1112 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1113 : 	if( m_fireLast != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1832]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L39115

; 1115 : 		int bulletCount = (gpGlobals->time - m_fireLast) * m_fireRate;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx+1832]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+1836]
	call	__ftol
	mov	DWORD PTR _bulletCount$39116[ebp], eax

; 1116 : 
; 1117 : 		if( bulletCount > 0 )

	cmp	DWORD PTR _bulletCount$39116[ebp], 0
	jle	SHORT $L39117

; 1119 : 			for( int i = 0; i < bulletCount; i++ )

	mov	DWORD PTR _i$39118[ebp], 0
	jmp	SHORT $L39119
$L39120:
	mov	ecx, DWORD PTR _i$39118[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$39118[ebp], ecx
$L39119:
	mov	edx, DWORD PTR _i$39118[ebp]
	cmp	edx, DWORD PTR _bulletCount$39116[ebp]
	jge	SHORT $L39121

; 1121 : 				CBaseEntity *pRocket = CBaseEntity::Create( "rpg_rocket", barrelEnd, GetAbsAngles(), edict() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	eax, DWORD PTR _barrelEnd$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@CFGE@rpg_rocket?$AA@ ; `string'
	call	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z ; CBaseEntity::Create
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRocket$39122[ebp], eax

; 1122 : 			}

	jmp	SHORT $L39120
$L39121:

; 1123 : 			BaseClass::Fire( barrelEnd, forward, pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _forward$[ebp]
	push	eax
	mov	ecx, DWORD PTR _barrelEnd$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z ; CBaseTank::Fire
$L39117:

; 1126 : 	else

	jmp	SHORT $L39123
$L39115:

; 1128 : 		BaseClass::Fire( barrelEnd, forward, pev );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _forward$[ebp]
	push	ecx
	mov	edx, DWORD PTR _barrelEnd$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z ; CBaseTank::Fire
$L39123:

; 1130 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Fire@CFuncTankRocket@@UAEXABVVector@@0PAUentvars_s@@@Z ENDP ; CFuncTankRocket::Fire
_TEXT	ENDS
;	COMDAT _$E59
_TEXT	SEGMENT
_$E59	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E58
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E59	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncTankMortar@@@@QAE@PBD@Z ; CEntityFactory<CFuncTankMortar>::CEntityFactory<CFuncTankMortar>
PUBLIC	??_C@_0BA@EGMI@func_tankmortar?$AA@		; `string'
_BSS	SEGMENT
_func_tankmortar DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BA@EGMI@func_tankmortar?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_0BA@EGMI@func_tankmortar?$AA@ DB 'func_tankmortar', 00H ; `string'
CONST	ENDS
;	COMDAT _$E58
_TEXT	SEGMENT
_$E58	PROC NEAR					; COMDAT

; 1141 : LINK_ENTITY_TO_CLASS( func_tankmortar, CFuncTankMortar );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BA@EGMI@func_tankmortar?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_tankmortar
	call	??0?$CEntityFactory@VCFuncTankMortar@@@@QAE@PBD@Z ; CEntityFactory<CFuncTankMortar>::CEntityFactory<CFuncTankMortar>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E58	ENDP
_TEXT	ENDS
PUBLIC	?KeyValue@CFuncTankMortar@@UAEXPAUKeyValueData_s@@@Z ; CFuncTankMortar::KeyValue
PUBLIC	??_C@_0L@PKDI@iMagnitude?$AA@			; `string'
;	COMDAT ??_C@_0L@PKDI@iMagnitude?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_0L@PKDI@iMagnitude?$AA@ DB 'iMagnitude', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CFuncTankMortar@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CFuncTankMortar@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CFuncTankMortar::KeyValue, COMDAT

; 1144 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1145 : 	if( FStrEq( pkvd->szKeyName, "iMagnitude" ))

	push	OFFSET FLAT:??_C@_0L@PKDI@iMagnitude?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39177

; 1147 : 		pev->impulse = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+388], eax

; 1148 : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 1150 : 	else

	jmp	SHORT $L39179
$L39177:

; 1152 : 		BaseClass::KeyValue( pkvd );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseTank@@UAEXPAUKeyValueData_s@@@Z ; CBaseTank::KeyValue
$L39179:

; 1154 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CFuncTankMortar@@UAEXPAUKeyValueData_s@@@Z ENDP ; CFuncTankMortar::KeyValue
_TEXT	ENDS
PUBLIC	?Precache@CFuncTankMortar@@UAEXXZ		; CFuncTankMortar::Precache
;	COMDAT ?Precache@CFuncTankMortar@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CFuncTankMortar@@UAEXXZ PROC NEAR		; CFuncTankMortar::Precache, COMDAT

; 1157 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1158 : 	BaseClass::Precache();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Precache@CBaseTank@@UAEXXZ		; CBaseTank::Precache

; 1159 : 
; 1160 : 	m_bulletType = TANK_BULLET_OTHER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1880], 4

; 1161 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CFuncTankMortar@@UAEXXZ ENDP			; CFuncTankMortar::Precache
_TEXT	ENDS
PUBLIC	?Fire@CFuncTankMortar@@UAEXABVVector@@0PAUentvars_s@@@Z ; CFuncTankMortar::Fire
EXTRN	?ExplosionCreate@@YAXABVVector@@0PAUedict_s@@HH@Z:NEAR ; ExplosionCreate
;	COMDAT ?Fire@CFuncTankMortar@@UAEXABVVector@@0PAUentvars_s@@@Z
_TEXT	SEGMENT
_barrelEnd$ = 8
_forward$ = 12
_this$ = -4
_bulletCount$39191 = -8
_tr$39193 = -64
?Fire@CFuncTankMortar@@UAEXABVVector@@0PAUentvars_s@@@Z PROC NEAR ; CFuncTankMortar::Fire, COMDAT

; 1164 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1165 : 	if( m_fireLast != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1832]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L39190

; 1167 : 		int bulletCount = (gpGlobals->time - m_fireLast) * m_fireRate;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx+1832]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+1836]
	call	__ftol
	mov	DWORD PTR _bulletCount$39191[ebp], eax

; 1168 : 
; 1169 : 		// Only create 1 explosion
; 1170 : 		if( bulletCount > 0 )

	cmp	DWORD PTR _bulletCount$39191[ebp], 0
	jle	$L39192

; 1172 : 			TraceResult tr;

	lea	ecx, DWORD PTR _tr$39193[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1173 : 
; 1174 : 			// TankTrace needs gpGlobals->v_up, etc.
; 1175 : 			UTIL_MakeAimVectors( GetAbsAngles());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeAimVectors@@YAXABVVector@@@Z	; UTIL_MakeAimVectors
	add	esp, 4

; 1176 : 			TankTrace( barrelEnd, forward, gTankSpread[m_spread], tr );

	lea	ecx, DWORD PTR _tr$39193[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1900]
	imul	eax, 12					; 0000000cH
	add	eax, OFFSET FLAT:_gTankSpread
	push	eax
	mov	ecx, DWORD PTR _forward$[ebp]
	push	ecx
	mov	edx, DWORD PTR _barrelEnd$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TankTrace@CBaseTank@@QAEXABVVector@@00AAUgametrace_s@@@Z ; CBaseTank::TankTrace

; 1177 : 			ExplosionCreate( tr.vecEndPos, GetAbsAngles(), edict(), pev->impulse, TRUE );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+388]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	eax, DWORD PTR _tr$39193[ebp+20]
	push	eax
	call	?ExplosionCreate@@YAXABVVector@@0PAUedict_s@@HH@Z ; ExplosionCreate
	add	esp, 20					; 00000014H

; 1178 : 			BaseClass::Fire( barrelEnd, forward, pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _forward$[ebp]
	push	eax
	mov	ecx, DWORD PTR _barrelEnd$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z ; CBaseTank::Fire
$L39192:

; 1181 : 	else

	jmp	SHORT $L39194
$L39190:

; 1183 : 		BaseClass::Fire( barrelEnd, forward, pev );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _forward$[ebp]
	push	ecx
	mov	edx, DWORD PTR _barrelEnd$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z ; CBaseTank::Fire
$L39194:

; 1185 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Fire@CFuncTankMortar@@UAEXABVVector@@0PAUentvars_s@@@Z ENDP ; CFuncTankMortar::Fire
_TEXT	ENDS
;	COMDAT _$E62
_TEXT	SEGMENT
_$E62	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E61
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E62	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCFuncTankControls@@@@QAE@PBD@Z ; CEntityFactory<CFuncTankControls>::CEntityFactory<CFuncTankControls>
PUBLIC	??_C@_0BC@GHMC@func_tankcontrols?$AA@		; `string'
_BSS	SEGMENT
_func_tankcontrols DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BC@GHMC@func_tankcontrols?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_0BC@GHMC@func_tankcontrols?$AA@ DB 'func_tankcontrols', 00H ; `string'
CONST	ENDS
;	COMDAT _$E61
_TEXT	SEGMENT
_$E61	PROC NEAR					; COMDAT

; 1190 : LINK_ENTITY_TO_CLASS( func_tankcontrols, CFuncTankControls );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BC@GHMC@func_tankcontrols?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_tankcontrols
	call	??0?$CEntityFactory@VCFuncTankControls@@@@QAE@PBD@Z ; CEntityFactory<CFuncTankControls>::CEntityFactory<CFuncTankControls>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E61	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CFuncTankControls@@UAEPAUdatamap_s@@XZ ; CFuncTankControls::GetDataDescMap
;	COMDAT ?GetDataDescMap@CFuncTankControls@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CFuncTankControls@@UAEPAUdatamap_s@@XZ PROC NEAR ; CFuncTankControls::GetDataDescMap, COMDAT

; 1192 : BEGIN_DATADESC( CFuncTankControls )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTankControls@@2Udatamap_s@@A ; CFuncTankControls::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CFuncTankControls@@UAEPAUdatamap_s@@XZ ENDP ; CFuncTankControls::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CFuncTankControls@@SAPAUdatamap_s@@XZ ; CFuncTankControls::GetBaseMap
;	COMDAT ?GetBaseMap@CFuncTankControls@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CFuncTankControls@@SAPAUdatamap_s@@XZ PROC NEAR ; CFuncTankControls::GetBaseMap, COMDAT

; 1192 : BEGIN_DATADESC( CFuncTankControls )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CFuncTankControls@@SAPAUdatamap_s@@XZ ENDP	; CFuncTankControls::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E65
_TEXT	SEGMENT
_$E65	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E64
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E65	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z ; DataMapInit
;	COMDAT _$E64
_TEXT	SEGMENT
_$E64	PROC NEAR					; COMDAT

; 1192 : BEGIN_DATADESC( CFuncTankControls )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CFuncTankControls_DataDescInit@@3PAUdatamap_s@@A, eax ; CFuncTankControls_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E64	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S67@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z PROC NEAR ; DataMapInit, COMDAT

; 1192 : BEGIN_DATADESC( CFuncTankControls )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S67@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L39258
	mov	cl, BYTE PTR _?$S67@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S67@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0BC@JHCF@CFuncTankControls?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E68
	call	_atexit
	add	esp, 4
$L39258:
	call	?GetBaseMap@CFuncTankControls@@SAPAUdatamap_s@@XZ ; CFuncTankControls::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CFuncTankControls@@2Udatamap_s@@A+12, eax

; 1193 : 	DEFINE_FIELD( m_pController, FIELD_CLASSPTR ),
; 1194 : 	DEFINE_FIELD( m_vecControllerUsePos, FIELD_VECTOR ),
; 1195 : 	DEFINE_AUTO_ARRAY( m_iTankName, FIELD_STRING ),
; 1196 : 	DEFINE_FIELD( m_cTanks, FIELD_INTEGER ),
; 1197 : 	DEFINE_FIELD( m_fVerifyTanks, FIELD_BOOLEAN ),
; 1198 : END_DATADESC()

	mov	edx, 1
	test	edx, edx
	je	SHORT $L39279
	mov	DWORD PTR ?m_DataMap@CFuncTankControls@@2Udatamap_s@@A+4, 5
	mov	DWORD PTR ?m_DataMap@CFuncTankControls@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L39280
$L39279:
	mov	DWORD PTR ?m_DataMap@CFuncTankControls@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CFuncTankControls@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z@4PAUtypedescription_s@@A
$L39280:
	mov	eax, OFFSET FLAT:?m_DataMap@CFuncTankControls@@2Udatamap_s@@A ; CFuncTankControls::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z ENDP ; DataMapInit
_TEXT	ENDS
;	COMDAT _$E68
_TEXT	SEGMENT
_$E68	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCFuncTankControls@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E68	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CFuncTankControls@@UAEXXZ		; CFuncTankControls::Spawn
PUBLIC	?FStringNull@@YAHH@Z				; FStringNull
EXTRN	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z:NEAR ; UTIL_SetSize
;	COMDAT ?Spawn@CFuncTankControls@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CFuncTankControls@@UAEXXZ PROC NEAR		; CFuncTankControls::Spawn, COMDAT

; 1201 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1202 : 	pev->solid = SOLID_TRIGGER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 1

; 1203 : 	pev->movetype = MOVETYPE_NONE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 0

; 1204 : 	pev->effects |= EF_NODRAW;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	al, -128				; ffffff80H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax

; 1205 : 
; 1206 : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 1207 : 	UTIL_SetSize( pev, pev->mins, pev->maxs );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 232				; 000000e8H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 220				; 000000dcH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 1208 : 
; 1209 : 	// store pev->target for backward compatibility
; 1210 : 	if( m_cTanks < MAX_CONTROLLED_TANKS && !FStringNull( pev->target ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2000], 48		; 00000030H
	jge	SHORT $L39286
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+456]
	push	eax
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39286

; 1212 : 		m_iTankName[m_cTanks] = pev->target;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2000]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+456]
	mov	DWORD PTR [eax+ecx*4+1808], edx

; 1213 : 		m_cTanks++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2000]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2000], ecx
$L39286:

; 1215 : 
; 1216 : 	SetLocalAngles( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 1217 : 	SetBits( m_iFlags, MF_TRIGGER );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 1218 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CFuncTankControls@@UAEXXZ ENDP			; CFuncTankControls::Spawn
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT
_iString$ = 8
?FStringNull@@YAHH@Z PROC NEAR				; FStringNull, COMDAT

; 201  : inline BOOL FStringNull(int iString)			{ return iString == iStringNull; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _iString$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStringNull@@YAHH@Z ENDP				; FStringNull
_TEXT	ENDS
PUBLIC	??_C@_06FOPF@parent?$AA@			; `string'
PUBLIC	??_C@_08IDGH@movewith?$AA@			; `string'
PUBLIC	?KeyValue@CFuncTankControls@@UAEXPAUKeyValueData_s@@@Z ; CFuncTankControls::KeyValue
EXTRN	?UTIL_StripToken@@YAXPBDPAD@Z:NEAR		; UTIL_StripToken
;	COMDAT ??_C@_06FOPF@parent?$AA@
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
??_C@_06FOPF@parent?$AA@ DB 'parent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT
??_C@_08IDGH@movewith?$AA@ DB 'movewith', 00H		; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CFuncTankControls@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
_tmp$39295 = -132
?KeyValue@CFuncTankControls@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CFuncTankControls::KeyValue, COMDAT

; 1221 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1222 : 	// get support for spirit field too
; 1223 : 	if( FStrEq( pkvd->szKeyName, "parent" ) || FStrEq( pkvd->szKeyName, "movewith" ))

	push	OFFSET FLAT:??_C@_06FOPF@parent?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L39292
	push	OFFSET FLAT:??_C@_08IDGH@movewith?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39291
$L39292:

; 1225 : 		m_iParent = ALLOC_STRING(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 1226 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1228 : 	else if( m_cTanks < MAX_CONTROLLED_TANKS ) 

	jmp	SHORT $L39294
$L39291:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2000], 48		; 00000030H
	jge	SHORT $L39294

; 1230 : 		// add this field to the target list
; 1231 : 		// this assumes that additional fields are targetnames and their values are delay values.
; 1232 : 		char tmp[128];
; 1233 : 		UTIL_StripToken( pkvd->szKeyName, tmp );

	lea	ecx, DWORD PTR _tmp$39295[ebp]
	push	ecx
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UTIL_StripToken@@YAXPBDPAD@Z		; UTIL_StripToken
	add	esp, 8

; 1234 : 		m_iTankName[m_cTanks] = ALLOC_STRING( tmp );

	lea	ecx, DWORD PTR _tmp$39295[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2000]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+1808], eax

; 1235 : 		m_cTanks++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2000]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2000], ecx

; 1236 : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1
$L39294:

; 1238 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CFuncTankControls@@UAEXPAUKeyValueData_s@@@Z ENDP ; CFuncTankControls::KeyValue
_TEXT	ENDS
PUBLIC	?OnControls@CFuncTankControls@@UAEHPAVCBaseEntity@@@Z ; CFuncTankControls::OnControls
PUBLIC	__real@4@4003f000000000000000
;	COMDAT __real@4@4003f000000000000000
; File z:\xashxtsrc\server\func_tank.cpp
CONST	SEGMENT
__real@4@4003f000000000000000 DD 041f00000r	; 30
CONST	ENDS
;	COMDAT ?OnControls@CFuncTankControls@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pTest$ = 8
_this$ = -4
_vecTransformedControlerUsePos$39301 = -16
$T40442 = -28
$T40443 = -40
$T40444 = -52
?OnControls@CFuncTankControls@@UAEHPAVCBaseEntity@@@Z PROC NEAR ; CFuncTankControls::OnControls, COMDAT

; 1241 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1242 : 	if( m_hParent != NULL && FClassnameIs( m_hParent->pev, "func_tracktrain" ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39300
	push	OFFSET FLAT:??_C@_0BA@KOLE@func_tracktrain?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L39300

; 1244 : 		// transform local controller pos through tankcontrols pos
; 1245 : 		Vector vecTransformedControlerUsePos = EntityToWorldTransform().VectorTransform( m_vecControllerUsePos );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1796				; 00000704H
	push	ecx
	lea	edx, DWORD PTR $T40442[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	mov	ecx, eax
	call	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorTransform
	push	eax
	lea	ecx, DWORD PTR _vecTransformedControlerUsePos$39301[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1246 : 		if(( vecTransformedControlerUsePos - pTest->GetAbsOrigin() ).Length() < 30 )

	mov	ecx, DWORD PTR _pTest$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T40443[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecTransformedControlerUsePos$39301[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fcomp	DWORD PTR __real@4@4003f000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39304

; 1248 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L39299
$L39304:

; 1251 : 	else if(( m_vecControllerUsePos - pTest->GetAbsOrigin() ).Length() < 30 )

	jmp	SHORT $L39307
$L39300:
	mov	ecx, DWORD PTR _pTest$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T40444[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1796				; 00000704H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fcomp	DWORD PTR __real@4@4003f000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39307

; 1253 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L39299
$L39307:

; 1255 : 
; 1256 : 	return FALSE;

	xor	eax, eax
$L39299:

; 1257 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnControls@CFuncTankControls@@UAEHPAVCBaseEntity@@@Z ENDP ; CFuncTankControls::OnControls
_TEXT	ENDS
PUBLIC	?HandleTank@CFuncTankControls@@QAEXPAVCBaseEntity@@0H@Z ; CFuncTankControls::HandleTank
;	COMDAT ?HandleTank@CFuncTankControls@@QAEXPAVCBaseEntity@@0H@Z
_TEXT	SEGMENT
_pActivator$ = 8
_m_pTank$ = 12
_activate$ = 16
_this$ = -4
?HandleTank@CFuncTankControls@@QAEXPAVCBaseEntity@@0H@Z PROC NEAR ; CFuncTankControls::HandleTank, COMDAT

; 1260 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1261 : 	// it's tank entity
; 1262 : 	if( m_pTank && m_pTank->IsTank( ))

	cmp	DWORD PTR _m_pTank$[ebp], 0
	je	SHORT $L39319
	mov	eax, DWORD PTR _m_pTank$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _m_pTank$[ebp]
	call	DWORD PTR [edx+252]
	test	eax, eax
	je	SHORT $L39319

; 1264 : 		if( activate )

	cmp	DWORD PTR _activate$[ebp], 0
	je	SHORT $L39315

; 1266 : 			if(((CBaseTank *)m_pTank)->StartControl((CBasePlayer *)pActivator, this ))

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _m_pTank$[ebp]
	call	?StartControl@CBaseTank@@QAEHPAVCBasePlayer@@PAVCFuncTankControls@@@Z ; CBaseTank::StartControl
	test	eax, eax
	je	SHORT $L39318

; 1268 : 				m_iState = STATE_ON; // we have active tank!

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 1
$L39318:

; 1271 : 		else

	jmp	SHORT $L39319
$L39315:

; 1273 : 			((CBaseTank *)m_pTank)->StopControl( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m_pTank$[ebp]
	call	?StopControl@CBaseTank@@QAEXPAVCFuncTankControls@@@Z ; CBaseTank::StopControl
$L39319:

; 1276 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?HandleTank@CFuncTankControls@@QAEXPAVCBaseEntity@@0H@Z ENDP ; CFuncTankControls::HandleTank
_TEXT	ENDS
PUBLIC	?Use@CFuncTankControls@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CFuncTankControls::Use
PUBLIC	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z		; EHANDLE::operator=
EXTRN	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix4x4::VectorITransform
;	COMDAT ?Use@CFuncTankControls@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_this$ = -4
_i$39334 = -8
_tryTank$39338 = -12
_i$39350 = -16
_tryTank$39354 = -20
$T40451 = -32
?Use@CFuncTankControls@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CFuncTankControls::Use, COMDAT

; 1279 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1280 : 	if( !m_pController && useType != USE_OFF )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1792], 0
	jne	$L39328
	cmp	DWORD PTR _useType$[ebp], 0
	je	$L39328

; 1282 : 		if( !pActivator || !( pActivator->IsPlayer( )))

	cmp	DWORD PTR _pActivator$[ebp], 0
	je	SHORT $L39330
	mov	ecx, DWORD PTR _pActivator$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActivator$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L39329
$L39330:

; 1283 : 			return;

	jmp	$L39327
$L39329:

; 1284 : 
; 1285 : 		if( m_iState != STATE_OFF || ((CBasePlayer *)pActivator)->m_pTank != NULL )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1788], 0
	jne	SHORT $L39333
	mov	ecx, DWORD PTR _pActivator$[ebp]
	add	ecx, 2864				; 00000b30H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39332
$L39333:

; 1286 : 			return;

	jmp	$L39327
$L39332:

; 1287 : 
; 1288 : 		// find all specified tanks
; 1289 : 		for( int i = 0; i < m_cTanks; i++ )

	mov	DWORD PTR _i$39334[ebp], 0
	jmp	SHORT $L39335
$L39336:
	mov	ecx, DWORD PTR _i$39334[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$39334[ebp], ecx
$L39335:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$39334[ebp]
	cmp	eax, DWORD PTR [edx+2000]
	jge	SHORT $L39337

; 1291 : 			CBaseEntity *tryTank = NULL;

	mov	DWORD PTR _tryTank$39338[ebp], 0
$L39340:

; 1292 : 	
; 1293 : 			// find all tanks with current name
; 1294 : 			while( tryTank = UTIL_FindEntityByTargetname( tryTank, STRING( m_iTankName[i] )))

	mov	ecx, DWORD PTR _i$39334[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1808]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _tryTank$39338[ebp]
	push	ecx
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _tryTank$39338[ebp], eax
	cmp	DWORD PTR _tryTank$39338[ebp], 0
	je	SHORT $L39341

; 1296 : 				HandleTank( pActivator, tryTank, TRUE );

	push	1
	mov	edx, DWORD PTR _tryTank$39338[ebp]
	push	edx
	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleTank@CFuncTankControls@@QAEXPAVCBaseEntity@@0H@Z ; CFuncTankControls::HandleTank

; 1297 : 			}			

	jmp	SHORT $L39340
$L39341:

; 1298 : 		}

	jmp	SHORT $L39336
$L39337:

; 1299 : 
; 1300 : 		if( m_iState == STATE_ON )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1788], 1
	jne	$L39347

; 1302 : 			// we found at least one tank to use, so holster player's weapon
; 1303 : 			m_pController = (CBasePlayer *)pActivator;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pActivator$[ebp]
	mov	DWORD PTR [edx+1792], eax

; 1304 : 			m_pController->m_pTank = this;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1792]
	add	ecx, 2864				; 00000b30H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1305 : 
; 1306 : 			if( m_pController->m_pActiveItem )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1792]
	cmp	DWORD PTR [ecx+2980], 0
	je	SHORT $L39344

; 1308 : 				m_pController->m_pActiveItem->Holster();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1792]
	mov	ecx, DWORD PTR [eax+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1792]
	mov	edx, DWORD PTR [eax+2980]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+368]

; 1309 : 				m_pController->pev->weaponmodel = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1792]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+192], 0
$L39344:

; 1312 : 
; 1313 : 			m_pController->m_iHideHUD |= HIDEHUD_WEAPONS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1792]
	mov	eax, DWORD PTR [edx+2928]
	or	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1792]
	mov	DWORD PTR [edx+2928], eax

; 1314 : 
; 1315 : 			// remember where the player's standing, so we can tell when he walks away
; 1316 : 			if( m_hParent != NULL && FClassnameIs( m_hParent->pev, "func_tracktrain" ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39345
	push	OFFSET FLAT:??_C@_0BA@KOLE@func_tracktrain?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L39345

; 1318 : 				// transform controller pos into local space because parent can be moving
; 1319 : 				m_vecControllerUsePos = m_pController->EntityToWorldTransform().VectorITransform( m_pController->GetAbsOrigin() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1792]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T40451[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1792]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	mov	ecx, eax
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1796				; 00000704H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1321 : 			else m_vecControllerUsePos = m_pController->GetAbsOrigin();

	jmp	SHORT $L39347
$L39345:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1792]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1796				; 00000704H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L39347:

; 1324 : 	else if( m_pController && useType != USE_ON )

	jmp	$L39349
$L39328:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1792], 0
	je	$L39349
	cmp	DWORD PTR _useType$[ebp], 1
	je	$L39349

; 1326 : 		// find all specified tanks
; 1327 : 		for( int i = 0; i < m_cTanks; i++ )

	mov	DWORD PTR _i$39350[ebp], 0
	jmp	SHORT $L39351
$L39352:
	mov	edx, DWORD PTR _i$39350[ebp]
	add	edx, 1
	mov	DWORD PTR _i$39350[ebp], edx
$L39351:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$39350[ebp]
	cmp	ecx, DWORD PTR [eax+2000]
	jge	SHORT $L39353

; 1329 : 			CBaseEntity *tryTank = NULL;

	mov	DWORD PTR _tryTank$39354[ebp], 0
$L39356:

; 1330 : 
; 1331 : 			// find all tanks with current name
; 1332 : 			while( tryTank = UTIL_FindEntityByTargetname( tryTank, STRING( m_iTankName[i] )))

	mov	edx, DWORD PTR _i$39350[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+1808]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _tryTank$39354[ebp]
	push	edx
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _tryTank$39354[ebp], eax
	cmp	DWORD PTR _tryTank$39354[ebp], 0
	je	SHORT $L39357

; 1334 : 				HandleTank( pActivator, tryTank, FALSE );

	push	0
	mov	eax, DWORD PTR _tryTank$39354[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleTank@CFuncTankControls@@QAEXPAVCBaseEntity@@0H@Z ; CFuncTankControls::HandleTank

; 1335 : 			}			

	jmp	SHORT $L39356
$L39357:

; 1336 : 		}

	jmp	SHORT $L39352
$L39353:

; 1337 : 
; 1338 : 		// bring back player's weapons
; 1339 : 		if( m_pController->m_pActiveItem )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1792]
	cmp	DWORD PTR [eax+2980], 0
	je	SHORT $L39358

; 1340 : 			m_pController->m_pActiveItem->Deploy();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1792]
	mov	ecx, DWORD PTR [edx+2980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1792]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+360]
$L39358:

; 1341 : 
; 1342 : 		m_pController->m_iHideHUD &= ~HIDEHUD_WEAPONS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1792]
	mov	edx, DWORD PTR [ecx+2928]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1792]
	mov	DWORD PTR [ecx+2928], edx

; 1343 : 		m_pController->m_pTank = NULL;				

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1792]
	add	ecx, 2864				; 00000b30H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1344 : 
; 1345 : 		m_pController = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1792], 0

; 1346 : 		m_iState = STATE_OFF;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 0
$L39349:
$L39327:

; 1348 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CFuncTankControls@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CFuncTankControls::Use
_TEXT	ENDS
EXTRN	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z:NEAR	; ENT
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z PROC NEAR	; EHANDLE::operator=, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 	if (pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L34280

; 72   : 		m_pent = ENT( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 73   : 		if (m_pent)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L34281

; 74   : 			m_serialnumber = m_pent->serialnumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$L34281:

; 76   : 	else

	jmp	SHORT $L34282
$L34280:

; 78   : 		m_pent = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 79   : 		m_serialnumber = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$L34282:

; 81   : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z ENDP		; EHANDLE::operator=
_TEXT	ENDS
PUBLIC	??0IEntityFactory@@QAE@XZ			; IEntityFactory::IEntityFactory
PUBLIC	?Create@?$CEntityFactory@VCFuncTankGun@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTankGun>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncTankGun@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncTankGun>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncTankGun@@@@UAEIXZ ; CEntityFactory<CFuncTankGun>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncTankGun@@@@6B@	; CEntityFactory<CFuncTankGun>::`vftable'
EXTRN	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ:NEAR ; EntityFactoryDictionary
;	COMDAT ??_7?$CEntityFactory@VCFuncTankGun@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncTankGun@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncTankGun@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTankGun>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncTankGun@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncTankGun@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTankGun@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCFuncTankGun@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncTankGun>::CEntityFactory<CFuncTankGun>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncTankGun@@@@6B@ ; CEntityFactory<CFuncTankGun>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncTankGun@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncTankGun>::CEntityFactory<CFuncTankGun>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncTankGun@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCFuncTankGun@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncTankGun>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncTankGun@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncTankGun>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTankGun@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCFuncTankGun@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncTankGun>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncTankGun@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncTankGun>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTankGun@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncTankGun@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncTankGun>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1920				; 00000780H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncTankGun@@@@UAEIXZ ENDP ; CEntityFactory<CFuncTankGun>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncTankLaser@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTankLaser>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncTankLaser@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncTankLaser>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncTankLaser@@@@UAEIXZ ; CEntityFactory<CFuncTankLaser>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncTankLaser@@@@6B@	; CEntityFactory<CFuncTankLaser>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncTankLaser@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncTankLaser@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncTankLaser@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTankLaser>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncTankLaser@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncTankLaser@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTankLaser@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncTankLaser@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncTankLaser>::CEntityFactory<CFuncTankLaser>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncTankLaser@@@@6B@ ; CEntityFactory<CFuncTankLaser>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncTankLaser@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncTankLaser>::CEntityFactory<CFuncTankLaser>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncTankLaser@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncTankLaser@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncTankLaser>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncTankLaser@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncTankLaser>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTankLaser@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncTankLaser@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncTankLaser>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncTankLaser@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncTankLaser>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTankLaser@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncTankLaser@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncTankLaser>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1928				; 00000788H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncTankLaser@@@@UAEIXZ ENDP ; CEntityFactory<CFuncTankLaser>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncTankRocket@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTankRocket>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncTankRocket@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncTankRocket>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncTankRocket@@@@UAEIXZ ; CEntityFactory<CFuncTankRocket>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncTankRocket@@@@6B@	; CEntityFactory<CFuncTankRocket>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncTankRocket@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncTankRocket@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncTankRocket@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTankRocket>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncTankRocket@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncTankRocket@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTankRocket@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncTankRocket@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncTankRocket>::CEntityFactory<CFuncTankRocket>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncTankRocket@@@@6B@ ; CEntityFactory<CFuncTankRocket>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncTankRocket@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncTankRocket>::CEntityFactory<CFuncTankRocket>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncTankRocket@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncTankRocket@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncTankRocket>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncTankRocket@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncTankRocket>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTankRocket@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncTankRocket@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncTankRocket>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncTankRocket@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncTankRocket>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTankRocket@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncTankRocket@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncTankRocket>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1920				; 00000780H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncTankRocket@@@@UAEIXZ ENDP ; CEntityFactory<CFuncTankRocket>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncTankMortar@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTankMortar>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncTankMortar@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncTankMortar>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncTankMortar@@@@UAEIXZ ; CEntityFactory<CFuncTankMortar>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncTankMortar@@@@6B@	; CEntityFactory<CFuncTankMortar>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncTankMortar@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncTankMortar@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncTankMortar@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTankMortar>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncTankMortar@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncTankMortar@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTankMortar@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncTankMortar@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncTankMortar>::CEntityFactory<CFuncTankMortar>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncTankMortar@@@@6B@ ; CEntityFactory<CFuncTankMortar>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncTankMortar@@@@QAE@PBD@Z ENDP	; CEntityFactory<CFuncTankMortar>::CEntityFactory<CFuncTankMortar>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncTankMortar@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncTankMortar@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncTankMortar>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncTankMortar@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncTankMortar>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTankMortar@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncTankMortar@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncTankMortar>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncTankMortar@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncTankMortar>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTankMortar@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncTankMortar@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncTankMortar>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1920				; 00000780H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncTankMortar@@@@UAEIXZ ENDP ; CEntityFactory<CFuncTankMortar>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCFuncTankControls@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTankControls>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCFuncTankControls@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CFuncTankControls>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCFuncTankControls@@@@UAEIXZ ; CEntityFactory<CFuncTankControls>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCFuncTankControls@@@@6B@	; CEntityFactory<CFuncTankControls>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCFuncTankControls@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCFuncTankControls@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCFuncTankControls@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CFuncTankControls>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCFuncTankControls@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCFuncTankControls@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCFuncTankControls@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCFuncTankControls@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CFuncTankControls>::CEntityFactory<CFuncTankControls>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCFuncTankControls@@@@6B@ ; CEntityFactory<CFuncTankControls>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCFuncTankControls@@@@QAE@PBD@Z ENDP ; CEntityFactory<CFuncTankControls>::CEntityFactory<CFuncTankControls>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z ; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCFuncTankControls@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCFuncTankControls@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CFuncTankControls>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCFuncTankControls@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CFuncTankControls>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCFuncTankControls@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCFuncTankControls@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CFuncTankControls>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCFuncTankControls@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CFuncTankControls>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCFuncTankControls@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCFuncTankControls@@@@UAEIXZ PROC NEAR ; CEntityFactory<CFuncTankControls>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 2008				; 000007d8H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCFuncTankControls@@@@UAEIXZ ENDP ; CEntityFactory<CFuncTankControls>::GetEntitySize
_TEXT	ENDS
PUBLIC	??_7IEntityFactory@@6B@				; IEntityFactory::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT
??_7IEntityFactory@@6B@ DD FLAT:__purecall		; IEntityFactory::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IEntityFactory@@QAE@XZ PROC NEAR			; IEntityFactory::IEntityFactory, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IEntityFactory@@6B@ ; IEntityFactory::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0IEntityFactory@@QAE@XZ ENDP				; IEntityFactory::IEntityFactory
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_this$ = -16
__$EHRec$ = -12
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseDelay@@2Udatamap_s@@A:BYTE	; CBaseDelay::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseDelay@@2Udatamap_s@@A ; CBaseDelay::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseTank@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseTank@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseTank@@2Udatamap_s@@A ; CBaseTank::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseTank@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	?SetClassname@CBaseEntity@@QAEXPBD@Z		; CBaseEntity::SetClassname
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
PUBLIC	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z		; CBaseEntity::operator new
PUBLIC	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z		; CBaseEntity::operator delete
PUBLIC	??0CFuncTankGun@@QAE@XZ				; CFuncTankGun::CFuncTankGun
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T40524 = -20
$T40525 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39468

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39468:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39470

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1920					; 00000780H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40525[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40525[ebp], 0
	je	SHORT $L40526
	mov	ecx, DWORD PTR $T40525[ebp]
	call	??0CFuncTankGun@@QAE@XZ			; CFuncTankGun::CFuncTankGun
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40527
$L40526:
	mov	DWORD PTR -28+[ebp], 0
$L40527:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40524[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40524[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39470:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40525[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncTankGun@@PAV1@PBD@Z ENDP	; GetClassPtr
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC NEAR		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32448

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L32447
$L32448:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$L32447:

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4
_pszClassName$ = 8
?SetClassname@CBaseEntity@@QAEXPBD@Z PROC NEAR		; CBaseEntity::SetClassname, COMDAT

; 302  : 	void		SetClassname( const char *pszClassName ) { pev->classname = MAKE_STRING( pszClassName ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClassname@CBaseEntity@@QAEXPBD@Z ENDP		; CBaseEntity::SetClassname
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT
_stAllocateBlock$ = 8
_pev$ = 12
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator new, COMDAT

; 489  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 490  : 		return (void *)ALLOC_PRIVATE(ENT(pev), stAllocateBlock);

	mov	eax, DWORD PTR _stAllocateBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+252
	add	esp, 8

; 491  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z ENDP		; CBaseEntity::operator new
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 12
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator delete, COMDAT

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 497  : 		pev->flags |= FL_KILLME;

	mov	eax, DWORD PTR _pev$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+420], ecx

; 498  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z ENDP		; CBaseEntity::operator delete
_TEXT	ENDS
PUBLIC	??0CFuncTankLaser@@QAE@XZ			; CFuncTankLaser::CFuncTankLaser
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T40545 = -20
$T40546 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39479

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39479:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39481

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1928					; 00000788H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40546[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40546[ebp], 0
	je	SHORT $L40547
	mov	ecx, DWORD PTR $T40546[ebp]
	call	??0CFuncTankLaser@@QAE@XZ		; CFuncTankLaser::CFuncTankLaser
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40548
$L40547:
	mov	DWORD PTR -28+[ebp], 0
$L40548:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40545[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40545[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39481:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40546[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncTankLaser@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CFuncTankRocket@@QAE@XZ			; CFuncTankRocket::CFuncTankRocket
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T40558 = -20
$T40559 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z PROC NEAR ; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39490

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39490:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39492

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1920					; 00000780H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40559[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40559[ebp], 0
	je	SHORT $L40560
	mov	ecx, DWORD PTR $T40559[ebp]
	call	??0CFuncTankRocket@@QAE@XZ		; CFuncTankRocket::CFuncTankRocket
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40561
$L40560:
	mov	DWORD PTR -28+[ebp], 0
$L40561:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40558[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40558[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39492:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40559[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncTankRocket@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CFuncTankMortar@@QAE@XZ			; CFuncTankMortar::CFuncTankMortar
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T40571 = -20
$T40572 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z PROC NEAR ; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39501

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39501:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39503

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1920					; 00000780H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40572[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40572[ebp], 0
	je	SHORT $L40573
	mov	ecx, DWORD PTR $T40572[ebp]
	call	??0CFuncTankMortar@@QAE@XZ		; CFuncTankMortar::CFuncTankMortar
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40574
$L40573:
	mov	DWORD PTR -28+[ebp], 0
$L40574:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40571[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40571[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39503:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40572[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncTankMortar@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CFuncTankControls@@QAE@XZ			; CFuncTankControls::CFuncTankControls
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T40584 = -20
$T40585 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z PROC NEAR ; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L39512

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L39512:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L39514

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2008					; 000007d8H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T40585[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T40585[ebp], 0
	je	SHORT $L40586
	mov	ecx, DWORD PTR $T40585[ebp]
	call	??0CFuncTankControls@@QAE@XZ		; CFuncTankControls::CFuncTankControls
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L40587
$L40586:
	mov	DWORD PTR -28+[ebp], 0
$L40587:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T40584[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T40584[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L39514:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T40585[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCFuncTankControls@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	?EarPosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EarPosition
PUBLIC	?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z	; CBaseEntity::BodyTarget
PUBLIC	?IsPointSized@CBaseEntity@@UBEHXZ		; CBaseEntity::IsPointSized
PUBLIC	?Illumination@CBaseEntity@@UAEHXZ		; CBaseEntity::Illumination
PUBLIC	?UpdateTargetPosition@CBaseTank@@UAE?AVVector@@PAVCBaseEntity@@@Z ; CBaseTank::UpdateTargetPosition
PUBLIC	?ObjectCaps@CBaseTank@@UAEHXZ			; CBaseTank::ObjectCaps
PUBLIC	?IsTank@CBaseTank@@UAEHXZ			; CBaseTank::IsTank
PUBLIC	??0CBaseTank@@QAE@XZ				; CBaseTank::CBaseTank
PUBLIC	?GetState@CBaseDelay@@UAE?AW4STATE@@XZ		; CBaseDelay::GetState
PUBLIC	?OnChangeLevel@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeLevel
PUBLIC	?OnTeleport@CBaseEntity@@UAEXXZ			; CBaseEntity::OnTeleport
PUBLIC	?PortalSleep@CBaseEntity@@UAEXM@Z		; CBaseEntity::PortalSleep
PUBLIC	?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ; CBaseEntity::StartMessage
PUBLIC	?GetPosition@CBaseEntity@@UAEMXZ		; CBaseEntity::GetPosition
PUBLIC	?OnChangeParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeParent
PUBLIC	?OnClearParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnClearParent
PUBLIC	?OnRemove@CBaseEntity@@UAEXXZ			; CBaseEntity::OnRemove
PUBLIC	?Classify@CBaseEntity@@UAEHXZ			; CBaseEntity::Classify
PUBLIC	?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z	; CBaseEntity::DeathNotice
PUBLIC	?IsRigidBody@CBaseEntity@@UAEHXZ		; CBaseEntity::IsRigidBody
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z	; CBaseEntity::GetState
PUBLIC	?BloodColor@CBaseEntity@@UAEHXZ			; CBaseEntity::BloodColor
PUBLIC	?IsTriggered@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::IsTriggered
PUBLIC	?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ; CBaseEntity::MyMonsterPointer
PUBLIC	?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ; CBaseEntity::MySquadMonsterPointer
PUBLIC	?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ	; CBaseEntity::GetVehicleDriver
PUBLIC	?GetToggleState@CBaseEntity@@UAEHXZ		; CBaseEntity::GetToggleState
PUBLIC	?AddPoints@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPoints
PUBLIC	?AddPointsToTeam@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPointsToTeam
PUBLIC	?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::AddPlayerItem
PUBLIC	?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::RemovePlayerItem
PUBLIC	?GiveAmmo@CBaseEntity@@UAEHHPADH@Z		; CBaseEntity::GiveAmmo
PUBLIC	?GetDelay@CBaseEntity@@UAEMXZ			; CBaseEntity::GetDelay
PUBLIC	?IsMoving@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMoving
PUBLIC	?OverrideReset@CBaseEntity@@UAEXXZ		; CBaseEntity::OverrideReset
PUBLIC	?TransferReset@CBaseEntity@@UAEXXZ		; CBaseEntity::TransferReset
PUBLIC	?SetToggleState@CBaseEntity@@UAEXH@Z		; CBaseEntity::SetToggleState
PUBLIC	?StartSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StartSneaking
PUBLIC	?StopSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StopSneaking
PUBLIC	?OnControls@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::OnControls
PUBLIC	?IsSneaking@CBaseEntity@@UAEHXZ			; CBaseEntity::IsSneaking
PUBLIC	?IsAlive@CBaseEntity@@UAEHXZ			; CBaseEntity::IsAlive
PUBLIC	?IsBSPModel@CBaseEntity@@UAEHXZ			; CBaseEntity::IsBSPModel
PUBLIC	?IsCustomModel@CBaseEntity@@UAEHXZ		; CBaseEntity::IsCustomModel
PUBLIC	?ReflectGauss@CBaseEntity@@UAEHXZ		; CBaseEntity::ReflectGauss
PUBLIC	?HasTarget@CBaseEntity@@UAEHH@Z			; CBaseEntity::HasTarget
PUBLIC	?IsPlayer@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPlayer
PUBLIC	?IsNetClient@CBaseEntity@@UAEHXZ		; CBaseEntity::IsNetClient
PUBLIC	?IsMonster@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMonster
PUBLIC	?IsPushable@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPushable
PUBLIC	?IsProjectile@CBaseEntity@@UAEHXZ		; CBaseEntity::IsProjectile
PUBLIC	?IsFuncScreen@CBaseEntity@@UAEHXZ		; CBaseEntity::IsFuncScreen
PUBLIC	?IsPortal@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPortal
PUBLIC	?IsMover@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMover
PUBLIC	?IsBreakable@CBaseEntity@@UAEHXZ		; CBaseEntity::IsBreakable
PUBLIC	?TeamID@CBaseEntity@@UAEPBDXZ			; CBaseEntity::TeamID
PUBLIC	?Touch@CBaseEntity@@UAEXPAV1@@Z			; CBaseEntity::Touch
PUBLIC	?Blocked@CBaseEntity@@UAEXPAV1@@Z		; CBaseEntity::Blocked
PUBLIC	?MoveDone@CBaseEntity@@UAEXXZ			; CBaseEntity::MoveDone
PUBLIC	?Respawn@CBaseEntity@@UAEPAV1@XZ		; CBaseEntity::Respawn
PUBLIC	??_7CFuncTankGun@@6B@				; CFuncTankGun::`vftable'
PUBLIC	?UpdateOwner@CBaseEntity@@UAEXXZ		; CBaseEntity::UpdateOwner
PUBLIC	?FBecomeProne@CBaseEntity@@UAEHXZ		; CBaseEntity::FBecomeProne
PUBLIC	?Center@CBaseEntity@@UAE?AVVector@@XZ		; CBaseEntity::Center
PUBLIC	?EyePosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EyePosition
EXTRN	?FVisible@CBaseEntity@@UAEHPAV1@@Z:NEAR		; CBaseEntity::FVisible
EXTRN	?FVisible@CBaseEntity@@UAEHABVVector@@@Z:NEAR	; CBaseEntity::FVisible
EXTRN	?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z:NEAR	; CBaseEntity::ShouldCollide
EXTRN	?Save@CBaseEntity@@UAEHAAVCSave@@@Z:NEAR	; CBaseEntity::Save
EXTRN	?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z:NEAR	; CBaseEntity::Restore
EXTRN	?SetObjectCollisionBox@CBaseEntity@@UAEXXZ:NEAR	; CBaseEntity::SetObjectCollisionBox
EXTRN	?SetNextThink@CBaseEntity@@UAEXM@Z:NEAR		; CBaseEntity::SetNextThink
EXTRN	?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceAttack
EXTRN	?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseEntity::TakeDamage
EXTRN	?TakeHealth@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeHealth
EXTRN	?TakeArmor@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeArmor
EXTRN	?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z:NEAR	; CBaseEntity::Killed
EXTRN	?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceBleed
EXTRN	?DamageDecal@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::DamageDecal
EXTRN	?IsInWorld@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::IsInWorld
EXTRN	?GetNextTarget@CBaseEntity@@UAEPAV1@XZ:NEAR	; CBaseEntity::GetNextTarget
;	COMDAT ??_7CFuncTankGun@@6B@
CONST	SEGMENT
??_7CFuncTankGun@@6B@ DD FLAT:?GetDataDescMap@CBaseTank@@UAEPAUdatamap_s@@XZ ; CFuncTankGun::`vftable'
	DD	FLAT:?Spawn@CBaseTank@@UAEXXZ
	DD	FLAT:?Precache@CBaseTank@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseTank@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseTank@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseTank@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseTank@@UAEXXZ
	DD	FLAT:?Use@CBaseTank@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?Fire@CFuncTankGun@@UAEXABVVector@@0PAUentvars_s@@@Z
	DD	FLAT:?UpdateTargetPosition@CBaseTank@@UAE?AVVector@@PAVCBaseEntity@@@Z
CONST	ENDS
;	COMDAT ??0CFuncTankGun@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncTankGun@@QAE@XZ PROC NEAR			; CFuncTankGun::CFuncTankGun, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseTank@@QAE@XZ			; CBaseTank::CBaseTank
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncTankGun@@6B@ ; CFuncTankGun::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncTankGun@@QAE@XZ ENDP				; CFuncTankGun::CFuncTankGun
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeLevel@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeLevel, COMDAT

; 366  : 	virtual void	OnChangeLevel( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeLevel@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnChangeLevel
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnTeleport@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnTeleport, COMDAT

; 367  : 	virtual void	OnTeleport( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnTeleport@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnTeleport
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4
?PortalSleep@CBaseEntity@@UAEXM@Z PROC NEAR		; CBaseEntity::PortalSleep, COMDAT

; 368  : 	virtual void	PortalSleep( float seconds ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PortalSleep@CBaseEntity@@UAEXM@Z ENDP			; CBaseEntity::PortalSleep
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CBaseEntity::StartMessage, COMDAT

; 369  :           virtual void	StartMessage( CBasePlayer *pPlayer ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ENDP	; CBaseEntity::StartMessage
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetPosition@CBaseEntity@@UAEMXZ PROC NEAR		; CBaseEntity::GetPosition, COMDAT

; 370  : 	virtual float	GetPosition( void ) { return 0.0f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPosition@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetPosition
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeParent, COMDAT

; 371  : 	virtual void	OnChangeParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CBaseEntity@@UAEXXZ ENDP		; CBaseEntity::OnChangeParent
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnClearParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnClearParent, COMDAT

; 372  : 	virtual void	OnClearParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnClearParent
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnRemove@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::OnRemove, COMDAT

; 373  : 	virtual void	OnRemove( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnRemove@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnRemove
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::Classify, COMDAT

; 385  : 	virtual int Classify ( void ) { return CLASS_NONE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Classify
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z PROC NEAR ; CBaseEntity::DeathNotice, COMDAT

; 386  : 	virtual void DeathNotice ( entvars_t *pevChild ) { } // monster maker children use this to tell the monster maker that they have died.

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z ENDP	; CBaseEntity::DeathNotice
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsRigidBody@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsRigidBody, COMDAT

; 387  : 	virtual BOOL IsRigidBody( void ) { return (m_iActorType == ACTOR_DYNAMIC); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	mov	eax, ecx
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsRigidBody@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsRigidBody
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z PROC NEAR	; CBaseEntity::GetState, COMDAT

; 401  : 	virtual STATE GetState ( CBaseEntity* pEnt ) { return GetState(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z ENDP	; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::BloodColor, COMDAT

; 408  : 	virtual int	BloodColor( void ) { return DONT_BLEED; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::BloodColor
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::IsTriggered, COMDAT

; 410  : 	virtual BOOL	IsTriggered( CBaseEntity *pActivator ) {return TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::IsTriggered
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ PROC NEAR ; CBaseEntity::MyMonsterPointer, COMDAT

; 411  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ENDP ; CBaseEntity::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ PROC NEAR ; CBaseEntity::MySquadMonsterPointer, COMDAT

; 412  : 	virtual CSquadMonster *MySquadMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ENDP ; CBaseEntity::MySquadMonsterPointer
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ PROC NEAR	; CBaseEntity::GetVehicleDriver, COMDAT

; 413  : 	virtual CBaseEntity *GetVehicleDriver( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ ENDP		; CBaseEntity::GetVehicleDriver
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::GetToggleState, COMDAT

; 414  : 	virtual int	GetToggleState( void ) { return TS_AT_TOP; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseEntity@@UAEHXZ ENDP		; CBaseEntity::GetToggleState
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPoints@CBaseEntity@@UAEXHH@Z PROC NEAR		; CBaseEntity::AddPoints, COMDAT

; 415  : 	virtual void	AddPoints( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPoints@CBaseEntity@@UAEXHH@Z ENDP			; CBaseEntity::AddPoints
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z PROC NEAR	; CBaseEntity::AddPointsToTeam, COMDAT

; 416  : 	virtual void	AddPointsToTeam( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z ENDP		; CBaseEntity::AddPointsToTeam
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::AddPlayerItem, COMDAT

; 417  : 	virtual BOOL	AddPlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::AddPlayerItem
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::RemovePlayerItem, COMDAT

; 418  : 	virtual BOOL	RemovePlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::RemovePlayerItem
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT
_this$ = -4
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z PROC NEAR		; CBaseEntity::GiveAmmo, COMDAT

; 419  : 	virtual int 	GiveAmmo( int iAmount, char *szName, int iMax ) { return -1; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z ENDP			; CBaseEntity::GiveAmmo
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseEntity@@UAEMXZ PROC NEAR			; CBaseEntity::GetDelay, COMDAT

; 420  : 	virtual float	GetDelay( void ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetDelay
_TEXT	ENDS
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMoving, COMDAT

; 421  : 	virtual int	IsMoving( void ) { return GetAbsVelocity() != g_vecZero; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMoving
_TEXT	ENDS
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40652
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40652
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40652
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40653
$L40652:
	mov	DWORD PTR -8+[ebp], 0
$L40653:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OverrideReset, COMDAT

; 422  : 	virtual void	OverrideReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OverrideReset
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TransferReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::TransferReset, COMDAT

; 423  : 	virtual void	TransferReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransferReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::TransferReset
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?SetToggleState@CBaseEntity@@UAEXH@Z PROC NEAR		; CBaseEntity::SetToggleState, COMDAT

; 426  : 	virtual void	SetToggleState( int state ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetToggleState@CBaseEntity@@UAEXH@Z ENDP		; CBaseEntity::SetToggleState
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StartSneaking, COMDAT

; 427  : 	virtual void	StartSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StartSneaking
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StopSneaking, COMDAT

; 428  : 	virtual void	StopSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StopSneaking
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?OnControls@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::OnControls, COMDAT

; 429  : 	virtual BOOL	OnControls( CBaseEntity *pTest ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnControls@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::OnControls
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSneaking@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsSneaking, COMDAT

; 430  : 	virtual BOOL	IsSneaking( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSneaking@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsSneaking
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsAlive, COMDAT

; 431  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	jne	SHORT $L40670
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40670
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40671
$L40670:
	mov	DWORD PTR -8+[ebp], 0
$L40671:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsAlive
_TEXT	ENDS
EXTRN	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z:NEAR	; UTIL_GetModelType
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBSPModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBSPModel, COMDAT

; 432  : 	virtual BOOL	IsBSPModel( void ) { return UTIL_GetModelType( pev->modelindex ) == mod_brush; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBSPModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBSPModel
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsCustomModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsCustomModel, COMDAT

; 433  : 	virtual BOOL	IsCustomModel( void ) { return pev->solid == SOLID_CUSTOM; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+268], 5
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCustomModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsCustomModel
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ReflectGauss@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ReflectGauss, COMDAT

; 434  : 	virtual BOOL	ReflectGauss( void ) { return (( IsBSPModel() || IsCustomModel()) && !pev->takedamage ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	test	eax, eax
	jne	SHORT $L40678
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+208]
	test	eax, eax
	je	SHORT $L40679
$L40678:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40679
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40680
$L40679:
	mov	DWORD PTR -8+[ebp], 0
$L40680:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReflectGauss@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ReflectGauss
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_targetname$ = 8
?HasTarget@CBaseEntity@@UAEHH@Z PROC NEAR		; CBaseEntity::HasTarget, COMDAT

; 435  : 	virtual BOOL	HasTarget( string_t targetname ) { return FStrEq(STRING(targetname), STRING(pev->targetname) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _targetname$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasTarget@CBaseEntity@@UAEHH@Z ENDP			; CBaseEntity::HasTarget
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPlayer@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPlayer, COMDAT

; 437  : 	virtual BOOL	IsPlayer( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPlayer
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsNetClient@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsNetClient, COMDAT

; 438  : 	virtual BOOL	IsNetClient( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetClient@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsNetClient
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMonster@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsMonster, COMDAT

; 439  : 	virtual BOOL	IsMonster( void ) { return (pev->flags & FL_MONSTER ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+420]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMonster@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMonster
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPushable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsPushable, COMDAT

; 440  : 	virtual BOOL	IsPushable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPushable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPushable
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsProjectile@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsProjectile, COMDAT

; 441  : 	virtual BOOL	IsProjectile( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsProjectile@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsProjectile
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsFuncScreen@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsFuncScreen, COMDAT

; 442  : 	virtual BOOL	IsFuncScreen( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFuncScreen@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsFuncScreen
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPortal@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPortal, COMDAT

; 443  : 	virtual BOOL	IsPortal( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPortal@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPortal
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMover@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMover, COMDAT

; 445  : 	virtual BOOL	IsMover( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMover
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBreakable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBreakable, COMDAT

; 446  : 	virtual BOOL	IsBreakable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBreakable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBreakable
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?TeamID@CBaseEntity@@UAEPBDXZ PROC NEAR			; CBaseEntity::TeamID, COMDAT

; 447  : 	virtual const char	*TeamID( void ) { return ""; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TeamID@CBaseEntity@@UAEPBDXZ ENDP			; CBaseEntity::TeamID
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Touch@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Touch, COMDAT

; 466  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 		if( m_pfnTouch )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1748], 0
	je	SHORT $L35012

; 468  : 			(this->*m_pfnTouch)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1748]
$L35012:

; 469  : 
; 470  : 		// forward the blocked event to our parent, if any.
; 471  : 		if( m_hParent != NULL && !m_isChaining )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35013
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1628]
	test	ecx, ecx
	jne	SHORT $L35013

; 472  : 			m_hParent->Touch( pOther );

	mov	edx, DWORD PTR _pOther$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+280]
$L35013:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Touch
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Blocked@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Blocked, COMDAT

; 476  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 		if( m_pfnBlocked )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1756], 0
	je	SHORT $L35016

; 478  : 			(this->*m_pfnBlocked)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1756]
$L35016:

; 479  : 
; 480  : 		// forward the blocked event to our parent, if any.
; 481  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35017

; 482  : 			m_hParent->Blocked( pOther );

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+284]
$L35017:

; 483  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Blocked
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MoveDone@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::MoveDone, COMDAT

; 485  : 	virtual void MoveDone( void ) { if( m_pfnMoveDone )(this->*m_pfnMoveDone)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1760], 0
	je	SHORT $L35020
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1760]
$L35020:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveDone@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::MoveDone
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?Respawn@CBaseEntity@@UAEPAV1@XZ PROC NEAR		; CBaseEntity::Respawn, COMDAT

; 513  : 	virtual CBaseEntity *Respawn( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Respawn@CBaseEntity@@UAEPAV1@XZ ENDP			; CBaseEntity::Respawn
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?UpdateOwner@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::UpdateOwner, COMDAT

; 705  : 	virtual	void UpdateOwner( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateOwner@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::UpdateOwner
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FBecomeProne@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::FBecomeProne, COMDAT

; 709  : 	virtual BOOL FBecomeProne( void ) {return FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FBecomeProne@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::FBecomeProne
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40717 = -16
$T40718 = -28
?Center@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR		; CBaseEntity::Center, COMDAT

; 714  : 	virtual Vector Center( ) { return (pev->absmax + pev->absmin) * 0.5; }; // center point of entity

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T40718[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	push	edx
	lea	eax, DWORD PTR $T40717[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 208				; 000000d0H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Center@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::Center
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40721 = -16
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EyePosition, COMDAT

; 715  : 	virtual Vector EyePosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of eyes

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T40721[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EyePosition
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40724 = -16
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EarPosition, COMDAT

; 716  : 	virtual Vector EarPosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of ears

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T40724[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EarPosition
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40727 = -16
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseEntity::BodyTarget, COMDAT

; 717  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ); };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T40727[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseEntity::BodyTarget
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPointSized@CBaseEntity@@UBEHXZ PROC NEAR		; CBaseEntity::IsPointSized, COMDAT

; 718  : 	virtual BOOL IsPointSized() const { return (pev->size == g_vecZero) ? true : false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	setne	al
	and	eax, 255				; 000000ffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPointSized@CBaseEntity@@UBEHXZ ENDP			; CBaseEntity::IsPointSized
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Illumination@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::Illumination, COMDAT

; 720  : 	virtual int Illumination( ) { return GETENTITYILLUM( ENT( pev ) ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+60
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Illumination@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Illumination
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseDelay::GetState, COMDAT

; 881  : 	virtual STATE GetState( void ) { return m_iState; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1788]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ ENDP		; CBaseDelay::GetState
_TEXT	ENDS
;	COMDAT ?UpdateTargetPosition@CBaseTank@@UAE?AVVector@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pTarget$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40736 = -16
$T40737 = -28
$T40738 = -40
$T40739 = -52
$T40740 = -64
$T40741 = -76
?UpdateTargetPosition@CBaseTank@@UAE?AVVector@@PAVCBaseEntity@@@Z PROC NEAR ; CBaseTank::UpdateTargetPosition, COMDAT

; 65   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 		// kill the player aiming jitter for scripted tanks
; 67   : 		if( m_bulletType == TANK_BULLET_NONE && pTarget->IsPlayer( ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1880], 0
	jne	SHORT $L38246
	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L38246

; 68   : 			return pTarget->Center() * 0.25f + pTarget->EyePosition() * 0.75f;

	push	1061158912				; 3f400000H
	lea	eax, DWORD PTR $T40739[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40738[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTarget$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [eax+308]
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T40740[ebp]
	push	ecx
	push	1048576000				; 3e800000H
	lea	edx, DWORD PTR $T40737[ebp]
	push	edx
	lea	eax, DWORD PTR $T40736[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [edx+304]
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L38245
$L38246:

; 69   : 		return pTarget->BodyTarget( GetAbsOrigin() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T40741[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [edx+316]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L38245:

; 70   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?UpdateTargetPosition@CBaseTank@@UAE?AVVector@@PAVCBaseEntity@@@Z ENDP ; CBaseTank::UpdateTargetPosition
_TEXT	ENDS
PUBLIC	?ObjectCaps@CBaseEntity@@UAEHXZ			; CBaseEntity::ObjectCaps
;	COMDAT ?ObjectCaps@CBaseTank@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseTank@@UAEHXZ PROC NEAR			; CBaseTank::ObjectCaps, COMDAT

; 76   : 	virtual int ObjectCaps( void ) { return (BaseClass :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | FCAP_HOLD_ANGLES; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	ah, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseTank@@UAEHXZ ENDP			; CBaseTank::ObjectCaps
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ObjectCaps, COMDAT

; 364  : 	virtual int	ObjectCaps( void ) { return FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 2
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ObjectCaps
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseTank@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTank@CBaseTank@@UAEHXZ PROC NEAR			; CBaseTank::IsTank, COMDAT

; 105  : 	virtual BOOL IsTank( void ) { return TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTank@CBaseTank@@UAEHXZ ENDP				; CBaseTank::IsTank
_TEXT	ENDS
PUBLIC	??_7CFuncTankLaser@@6B@				; CFuncTankLaser::`vftable'
;	COMDAT ??_7CFuncTankLaser@@6B@
CONST	SEGMENT
??_7CFuncTankLaser@@6B@ DD FLAT:?GetDataDescMap@CFuncTankLaser@@UAEPAUdatamap_s@@XZ ; CFuncTankLaser::`vftable'
	DD	FLAT:?Spawn@CBaseTank@@UAEXXZ
	DD	FLAT:?Precache@CBaseTank@@UAEXXZ
	DD	FLAT:?KeyValue@CFuncTankLaser@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseTank@@UAEHXZ
	DD	FLAT:?Activate@CFuncTankLaser@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseTank@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CFuncTankLaser@@UAEXXZ
	DD	FLAT:?Use@CBaseTank@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?Fire@CFuncTankLaser@@UAEXABVVector@@0PAUentvars_s@@@Z
	DD	FLAT:?UpdateTargetPosition@CBaseTank@@UAE?AVVector@@PAVCBaseEntity@@@Z
CONST	ENDS
;	COMDAT ??0CFuncTankLaser@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncTankLaser@@QAE@XZ PROC NEAR			; CFuncTankLaser::CFuncTankLaser, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseTank@@QAE@XZ			; CBaseTank::CBaseTank
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncTankLaser@@6B@ ; CFuncTankLaser::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncTankLaser@@QAE@XZ ENDP				; CFuncTankLaser::CFuncTankLaser
_TEXT	ENDS
PUBLIC	??_7CFuncTankRocket@@6B@			; CFuncTankRocket::`vftable'
;	COMDAT ??_7CFuncTankRocket@@6B@
CONST	SEGMENT
??_7CFuncTankRocket@@6B@ DD FLAT:?GetDataDescMap@CBaseTank@@UAEPAUdatamap_s@@XZ ; CFuncTankRocket::`vftable'
	DD	FLAT:?Spawn@CBaseTank@@UAEXXZ
	DD	FLAT:?Precache@CFuncTankRocket@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseTank@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseTank@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseTank@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseTank@@UAEXXZ
	DD	FLAT:?Use@CBaseTank@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?Fire@CFuncTankRocket@@UAEXABVVector@@0PAUentvars_s@@@Z
	DD	FLAT:?UpdateTargetPosition@CBaseTank@@UAE?AVVector@@PAVCBaseEntity@@@Z
CONST	ENDS
;	COMDAT ??0CFuncTankRocket@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncTankRocket@@QAE@XZ PROC NEAR			; CFuncTankRocket::CFuncTankRocket, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseTank@@QAE@XZ			; CBaseTank::CBaseTank
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncTankRocket@@6B@ ; CFuncTankRocket::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncTankRocket@@QAE@XZ ENDP				; CFuncTankRocket::CFuncTankRocket
_TEXT	ENDS
PUBLIC	??_7CFuncTankMortar@@6B@			; CFuncTankMortar::`vftable'
;	COMDAT ??_7CFuncTankMortar@@6B@
CONST	SEGMENT
??_7CFuncTankMortar@@6B@ DD FLAT:?GetDataDescMap@CBaseTank@@UAEPAUdatamap_s@@XZ ; CFuncTankMortar::`vftable'
	DD	FLAT:?Spawn@CBaseTank@@UAEXXZ
	DD	FLAT:?Precache@CFuncTankMortar@@UAEXXZ
	DD	FLAT:?KeyValue@CFuncTankMortar@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseTank@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseTank@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseTank@@UAEXXZ
	DD	FLAT:?Use@CBaseTank@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?Fire@CFuncTankMortar@@UAEXABVVector@@0PAUentvars_s@@@Z
	DD	FLAT:?UpdateTargetPosition@CBaseTank@@UAE?AVVector@@PAVCBaseEntity@@@Z
CONST	ENDS
;	COMDAT ??0CFuncTankMortar@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CFuncTankMortar@@QAE@XZ PROC NEAR			; CFuncTankMortar::CFuncTankMortar, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseTank@@QAE@XZ			; CBaseTank::CBaseTank
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncTankMortar@@6B@ ; CFuncTankMortar::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CFuncTankMortar@@QAE@XZ ENDP				; CFuncTankMortar::CFuncTankMortar
_TEXT	ENDS
PUBLIC	?ObjectCaps@CFuncTankControls@@UAEHXZ		; CFuncTankControls::ObjectCaps
PUBLIC	??_7CFuncTankControls@@6B@			; CFuncTankControls::`vftable'
PUBLIC	??0CBaseDelay@@QAE@XZ				; CBaseDelay::CBaseDelay
PUBLIC	??1CBaseDelay@@QAE@XZ				; CBaseDelay::~CBaseDelay
PUBLIC	?Precache@CBaseEntity@@UAEXXZ			; CBaseEntity::Precache
PUBLIC	?IsTank@CBaseEntity@@UAEHXZ			; CBaseEntity::IsTank
PUBLIC	?Think@CBaseEntity@@UAEXXZ			; CBaseEntity::Think
;	COMDAT ??_7CFuncTankControls@@6B@
CONST	SEGMENT
??_7CFuncTankControls@@6B@ DD FLAT:?GetDataDescMap@CFuncTankControls@@UAEPAUdatamap_s@@XZ ; CFuncTankControls::`vftable'
	DD	FLAT:?Spawn@CFuncTankControls@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CFuncTankControls@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CFuncTankControls@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CFuncTankControls@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CFuncTankControls@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CFuncTankControls@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CFuncTankControls@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CFuncTankControls@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CFuncTankControls@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CFuncTankControls@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CFuncTankControls@@QAE@XZ PROC NEAR			; CFuncTankControls::CFuncTankControls, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CFuncTankControls@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1796				; 00000704H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CFuncTankControls@@6B@ ; CFuncTankControls::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CFuncTankControls@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseDelay@@QAE@XZ			; CBaseDelay::~CBaseDelay
	ret	0
__ehhandler$??0CFuncTankControls@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CFuncTankControls@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CFuncTankControls@@QAE@XZ ENDP			; CFuncTankControls::CFuncTankControls
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Precache, COMDAT

; 326  : 	virtual void	Precache( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Precache
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTank@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsTank, COMDAT

; 444  : 	virtual BOOL	IsTank( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTank@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsTank
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Think@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Think, COMDAT

; 458  : 	virtual void Think( void ) { if (m_pfnThink) (this->*m_pfnThink)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1744], 0
	je	SHORT $L35006
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1744]
$L35006:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Think
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CFuncTankControls@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CFuncTankControls@@UAEHXZ PROC NEAR		; CFuncTankControls::ObjectCaps, COMDAT

; 148  : 	virtual int ObjectCaps( void ) { return (BaseClass::ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | FCAP_IMPULSE_USE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	al, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CFuncTankControls@@UAEHXZ ENDP		; CFuncTankControls::ObjectCaps
_TEXT	ENDS
PUBLIC	??_7CBaseTank@@6B@				; CBaseTank::`vftable'
;	COMDAT ??_7CBaseTank@@6B@
CONST	SEGMENT
??_7CBaseTank@@6B@ DD FLAT:?GetDataDescMap@CBaseTank@@UAEPAUdatamap_s@@XZ ; CBaseTank::`vftable'
	DD	FLAT:?Spawn@CBaseTank@@UAEXXZ
	DD	FLAT:?Precache@CBaseTank@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseTank@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseTank@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseTank@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseTank@@UAEXXZ
	DD	FLAT:?Use@CBaseTank@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?Fire@CBaseTank@@UAEXABVVector@@0PAUentvars_s@@@Z
	DD	FLAT:?UpdateTargetPosition@CBaseTank@@UAE?AVVector@@PAVCBaseEntity@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseTank@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseTank@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseTank@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseTank@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseTank@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseTank@@QAE@XZ PROC NEAR				; CBaseTank::CBaseTank, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseTank@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1856				; 00000740H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseTank@@6B@ ; CBaseTank::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseTank@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseDelay@@QAE@XZ			; CBaseDelay::~CBaseDelay
	ret	0
__ehhandler$??0CBaseTank@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseTank@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseTank@@QAE@XZ ENDP				; CBaseTank::CBaseTank
PUBLIC	??0CBaseEntity@@QAE@XZ				; CBaseEntity::CBaseEntity
PUBLIC	??_7CBaseDelay@@6B@				; CBaseDelay::`vftable'
PUBLIC	?Spawn@CBaseEntity@@UAEXXZ			; CBaseEntity::Spawn
PUBLIC	?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z	; CBaseEntity::Use
EXTRN	?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseDelay::GetDataDescMap
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT
??_7CBaseDelay@@6B@ DD FLAT:?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ ; CBaseDelay::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseDelay@@6B@ ; CBaseDelay::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::CBaseDelay
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Spawn, COMDAT

; 325  : 	virtual void	Spawn( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Spawn
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
_pActivator$ = 8
_pCaller$ = 12
_useType$ = 16
_value$ = 20
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z PROC NEAR	; CBaseEntity::Use, COMDAT

; 461  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 		if (m_pfnUse) (this->*m_pfnUse)( pActivator, pCaller, useType, value );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1752], 0
	je	SHORT $L35009
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCaller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1752]
$L35009:

; 463  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z ENDP	; CBaseEntity::Use
_TEXT	ENDS
PUBLIC	??1CBaseEntity@@QAE@XZ				; CBaseEntity::~CBaseEntity
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::~CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseEntity@@QAE@XZ			; CBaseEntity::~CBaseEntity
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::~CBaseDelay
_TEXT	ENDS
PUBLIC	??_7CBaseEntity@@6B@				; CBaseEntity::`vftable'
PUBLIC	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@XZ		; CBaseEntity::GetState
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	??0CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::CMeshDesc
EXTRN	??1CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::~CMeshDesc
EXTRN	?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseEntity::GetDataDescMap
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT
??_7CBaseEntity@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CBaseEntity::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseEntity@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseEntity@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseEntity@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseEntity@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseEntity@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??0CMeshDesc@@QAE@XZ			; CMeshDesc::CMeshDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1632				; 00000660H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseEntity@@6B@ ; CBaseEntity::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseEntity@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	ret	0
__ehhandler$??0CBaseEntity@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseEntity@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::CBaseEntity
PUBLIC	??_C@_0M@FCIN@parentflags?$AA@			; `string'
PUBLIC	??_C@_05JCDO@style?$AA@				; `string'
PUBLIC	??_C@_0L@MCHI@reflection?$AA@			; `string'
PUBLIC	??_C@_0N@DCCA@vlight_cache?$AA@			; `string'
EXTRN	_atoi:NEAR
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0M@FCIN@parentflags?$AA@ DB 'parentflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT
??_C@_05JCDO@style?$AA@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT
??_C@_0L@MCHI@reflection?$AA@ DB 'reflection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT
??_C@_0N@DCCA@vlight_cache?$AA@ DB 'vlight_cache', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pkvd$ = 8
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseEntity::KeyValue, COMDAT

; 328  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 		// get support for spirit field too
; 330  : 		if( FStrEq( pkvd->szKeyName, "parent" ) || FStrEq( pkvd->szKeyName, "movewith" ))

	push	OFFSET FLAT:??_C@_06FOPF@parent?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L34875
	push	OFFSET FLAT:??_C@_08IDGH@movewith?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34874
$L34875:

; 332  : 			m_iParent = ALLOC_STRING(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 333  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 335  : 		else if( FStrEq( pkvd->szKeyName, "parentflags" ))

	jmp	$L34896
$L34874:
	push	OFFSET FLAT:??_C@_0M@FCIN@parentflags?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34879

; 337  : 			m_iParentFlags = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 338  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 340  : 		else if( FStrEq( pkvd->szKeyName, "style" ))

	jmp	$L34896
$L34879:
	push	OFFSET FLAT:??_C@_05JCDO@style?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34882

; 342  : 			m_iStyle = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 343  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 345  : 		else if( FStrEq( pkvd->szKeyName, "reflection" ))

	jmp	$L34896
$L34882:
	push	OFFSET FLAT:??_C@_0L@MCHI@reflection?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34885

; 348  : 			{

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L34891
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L34892
	jmp	SHORT $L34888
$L34891:

; 349  : 			case 1: pev->effects |= EF_NOREFLECT; break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
	jmp	SHORT $L34888
$L34892:

; 350  : 			case 2: pev->effects |= EF_REFLECTONLY; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L34888:

; 352  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 354  : 		else if( FStrEq(pkvd->szKeyName, "vlight_cache"))

	jmp	SHORT $L34896
$L34885:
	push	OFFSET FLAT:??_C@_0N@DCCA@vlight_cache?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34894

; 356  : 			pev->iuser3 = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+588], eax

; 357  : 			pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 359  : 		else pkvd->fHandled = FALSE;

	jmp	SHORT $L34896
$L34894:
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L34896:

; 360  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseEntity::KeyValue
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseEntity::GetState, COMDAT

; 398  : 	virtual STATE GetState ( void ) { return STATE_OFF; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ ENDP		; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::~CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::~CBaseEntity
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
EXTRN	_malloc:NEAR
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC NEAR		; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L40817
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40817:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L39570

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L39570:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PADH@@QAE@XZ PROC NEAR			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC NEAR		; CUtlMemory<char *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40822
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40822:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40823
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40823:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC NEAR		; CUtlMemory<char *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40826
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40826:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC NEAR	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?Destruct@@YAXPAPAD@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L39603:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L39604

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAD@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L39603
$L39604:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC NEAR	; CUtlMemory<char *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40835
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L40835
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40836
$L40835:
	mov	DWORD PTR -8+[ebp], 0
$L40836:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC NEAR		; CUtlMemory<char *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39636

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L39637

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L39637:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L39636:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR	; CUtlMemory<char *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR ; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
EXTRN	_memset:NEAR
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAD@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAD@Z ENDP				; Destruct
_TEXT	ENDS
END
